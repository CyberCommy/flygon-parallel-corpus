- en: Creating Directives and Implementing Change Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建指令和实现变更检测
- en: In this chapter, we will learn and understand all about Angular Directives and
    change detection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和理解关于Angular指令和变更检测的所有内容。
- en: We will learn about different types of directives provided by Angular and also
    create some custom user-defined directives. We will deep dive into learning how
    Angular handles the change detection and how we can utilize change detection in
    our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习Angular提供的不同类型的指令，并创建一些自定义用户定义的指令。我们将深入学习Angular如何处理变更检测以及如何在我们的应用程序中利用变更检测。
- en: 'At the end of this chapter, you will be able to do the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下几点：
- en: Understand Angular Directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular指令
- en: Understand and implement built-in Component Directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置组件指令
- en: Understand and implement built-in Structural Directives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置结构指令
- en: Understand and implement built-in Attribute Directives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置属性指令
- en: Create custom-defined Attribute Directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义属性指令
- en: Understand how change detection works in Angular
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular中的变更检测工作原理
- en: Angular Directives
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular指令
- en: Directives allows us to extend the behavior of the elements. We can manipulate
    the **Document Object Model** (**DOM**) of a HTML page using the different types
    of directive definitions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令允许我们扩展元素的行为。我们可以使用不同类型的指令定义来操纵HTML页面的**文档对象模型**（**DOM**）。
- en: Angular uses the `@Directive` metadata to tell the application about the type
    of directives they have and the functional capabilities defined with each directive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用`@Directive`元数据来告诉应用程序它们具有的指令类型以及每个指令定义的功能能力。
- en: 'The following diagram shows the different types of directives:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了不同类型的指令：
- en: '![](assets/b5831068-99f7-4172-bdfb-823dd2570215.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5831068-99f7-4172-bdfb-823dd2570215.png)'
- en: 'There are mainly three types of Angular Directives:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种类型的Angular指令：
- en: '**Component Directives**: We can define these as user-defined directives, similar
    to custom directives in Angular 1.x'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件指令**：我们可以将其定义为用户定义的指令，类似于Angular 1.x中的自定义指令'
- en: '**Structural Directives**: Directives that alter or transform the DOM elements
    (one or more) on the fly'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构指令**：在运行时改变或转换DOM元素（一个或多个）的指令'
- en: '**Attribute Directives**: Directives that extend the behavior or look and feel
    of an element'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性指令**：扩展元素的行为或外观'
- en: In Angular 1.x, we had the A (Attribute), E (Element), C (Class), M (Matches
    comment) directives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 1.x中，我们有A（属性）、E（元素）、C（类）、M（匹配注释）指令。
- en: Angular comes with a lot of built-in directives, which we will be categorized
    in the preceding mentioned categories.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular带有许多内置指令，我们将在前面提到的类别中对其进行分类。
- en: Angular uses directives that use `ng`, hence avoid using `ng` along with custom-defined
    directives; it may lead to unknown issues. For example, `ng-changeColor` is an
    instance of bad styling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用使用`ng`的指令，因此避免在自定义指令中使用`ng`；这可能会导致未知问题。例如，`ng-changeColor`是一个不好的样式实例。
- en: Component Directives
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件指令
- en: Component Directives are user-defined directives to extend the functionality
    and create small reusable functionalities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件指令是用户定义的指令，用于扩展功能并创建小型可重用功能。
- en: Think of Component Directives as directives that have a template attached to
    them since Components Directives have their own view or template defined with
    them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件指令视为附加了模板的指令，因为组件指令具有自己的视图或模板定义。
- en: In previous chapters, we have created many components. If you have mastered
    the art of creating components and using them in our layouts, you will already
    know how to create Component Directives.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了许多组件。如果您已经掌握了创建组件并在布局中使用它们的艺术，您将已经知道如何创建组件指令。
- en: 'A quick recap on Angular components: components are small reusable pieces of
    code that we can use in throughout our applications.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular组件的快速回顾：组件是可以在整个应用程序中重复使用的小型代码片段。
- en: 'In the following code snippet, we will see the basic syntax of the component.
    Create a file named `my-template.component.ts`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将看到组件的基本语法。创建一个名为`my-template.component.ts`的文件：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Import the newly created component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入新创建的组件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, call the Component Directive in our `index.html` file*:*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`index.html`文件中调用组件指令*：*
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the simplest and easiest component example you will have seen;
    it''s as simple as this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将看到的最简单和最简单的组件示例；就是这么简单：
- en: '![](assets/31ded739-70f8-4344-b7f2-e25a87f9d902.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31ded739-70f8-4344-b7f2-e25a87f9d902.png)'
- en: So, whatever components we have created so far are all Component Directives.
    If you want to deep dive into learning more and creating components, refer to
    [Chapter 4](ffd90f48-2aef-462a-9d96-35e182ce3db9.xhtml), Working with Components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止我们创建的所有组件都是组件指令。如果您想深入学习更多并创建组件，请参考[第4章](ffd90f48-2aef-462a-9d96-35e182ce3db9.xhtml)，使用组件。
- en: Structural Directives
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: As the name mentions, Structural Directives alter the DOM structure by adding,
    appending, or removing DOM elements on the fly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，结构指令通过在运行时添加、附加或删除DOM元素来改变DOM结构。
- en: Angular Structural Directives are displayed with an (`*`) asterisk symbol before
    the directive name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Angular结构指令在指令名称之前显示为（*）星号符号。
- en: 'Some of the commonly used Structural Directives are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的结构指令如下：
- en: '`ngFor`: Repeater directive generally used to loop through and display a list
    of elements.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`：重复器指令通常用于循环并显示元素列表。'
- en: '`ngIf`: Shows or hides DOM elements depending on the result of expression evaluation;
    the result is either true or false.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngIf`：根据表达式评估的结果显示或隐藏DOM元素；结果要么是true，要么是false。'
- en: '`ngSwitch`: Returns if the match expression value matches the value of the
    switch expression. The result returned can be any value; a conditional check is
    done for matching values.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`：如果匹配表达式的值与开关表达式的值匹配，则返回。返回的结果可以是任何值；匹配值进行条件检查。'
- en: Only one Structural Directive is allowed per element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素只允许一个结构指令。
- en: 'Let''s learn about each of these Structural Directives in detail and create
    few examples using them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个结构指令，并使用它们创建一些示例：
- en: ngFor directive
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngFor指令
- en: The `ngFor` directive will help us iterate the items and append them to the
    list on the fly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令将帮助我们迭代项目并在运行时将它们附加到列表中。'
- en: We need to declare an array in the `StructureDirectiveComponent` class, and
    then use `ngFor` to loop the values and display them in the template.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`StructureDirectiveComponent`类中声明一个数组，然后使用`ngFor`来循环这些值并在模板中显示它们。
- en: The list `<li>` elements get appended on the fly to the `<ul>` element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`<li>`元素会在运行时附加到`<ul>`元素上。
- en: 'The following is the component snippet for the `ngFor` directive usage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ngFor`指令用法的组件片段：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding component is shown as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件的输出如下所示：
- en: '![](assets/5aaf455e-5a7e-4fd1-bf51-2cb0ddbe07dd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5aaf455e-5a7e-4fd1-bf51-2cb0ddbe07dd.png)'
- en: ngIf directive
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngIf指令
- en: The `ngIf` directive help us to evaluate the expression based on a condition
    very similar to the `if` statements in any programming language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf`指令帮助我们根据条件评估表达式，非常类似于任何编程语言中的`if`语句。'
- en: 'The general syntax is shown in the following code snippet :'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语法如下代码片段所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet has a `*ngIf` condition; if `isLoggedIn` is `true`,
    the directive will render the statement inside; otherwise, it will skip and continue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段有一个`*ngIf`条件；如果`isLoggedIn`为`true`，指令将渲染内部的语句；否则，它将跳过并继续。
- en: 'Let''s create an example using both the `*ngFor` and `*ngIf` statements as
    shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例，同时使用`*ngFor`和`*ngIf`语句，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We used `*ngFor` and `*ngIf` in the `view` template.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`view`模板中使用了`*ngFor`和`*ngIf`。
- en: In the component class, we define a `isLoggedIn` variable with Boolean values.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件类中，我们使用布尔值定义了一个`isLoggedIn`变量。
- en: We create an array of teams having team names in the list, which we will iterate
    and display in the view.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个团队名称列表的数组，我们将迭代并在视图中显示。
- en: 'Run the app, and we should see output as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/89017779-cdb5-4ff2-884a-f4f9018faedb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89017779-cdb5-4ff2-884a-f4f9018faedb.png)'
- en: ngSwitch directive
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngSwitch指令
- en: 'When we have to evaluate the expression based on multiple values, we make use
    of `ngSwitch`. An example of `ngSwitch` is shown in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要根据多个值来评估表达式时，我们使用`ngSwitch`。`ngSwitch`的示例如下代码片段所示：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Based on the value of `taxRate`, our application will decide which element to
    display. Let's update our example and add an `*ngSwitch` statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`taxRate`的值，我们的应用程序将决定显示哪个元素。让我们更新我们的示例并添加一个`*ngSwitch`语句。
- en: 'The updated example code is given as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的示例代码如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code example is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码示例的输出如下：
- en: '![](assets/d2dafbae-53df-4af5-84a7-ec492220de4e.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2dafbae-53df-4af5-84a7-ec492220de4e.png)'
- en: Attribute Directives
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute Directives extend the behavior or the look and feel of a given element.
    Attribute Directives are very similar to HTML attributes defined along with the
    element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令扩展了给定元素的行为或外观。属性指令与HTML属性非常相似，与元素一起定义。
- en: 'Attribute Directives can be of two types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令可以分为两种类型：
- en: Built-in Attribute Directive
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置属性指令
- en: Custom or user-defined Attributes Directive
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义或用户定义的属性指令
- en: Let's now look at them in detail in the following sections.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在以下章节中详细查看它们。
- en: Built-in Attribute Directives
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置属性指令
- en: As mentioned before, attributes are properties of the elements in the page.
    Some of the examples of the attributes for HTML elements are class, style, and
    so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，属性是页面中元素的属性。HTML元素的属性示例包括class、style等。
- en: Similarly Angular provides several built-in Attribute Directives. The directives
    include `ngModel`, `ngClass`, `ngStyle`, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Angular提供了几个内置的属性指令。这些指令包括`ngModel`、`ngClass`、`ngStyle`等等。
- en: 'Let''s learn about each of these Attribute Directives by creating few examples
    that are shown as follows for your reference:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一些示例来了解每个属性指令，如下所示：
- en: '`ngModel`: Using `ngModel`, we can implement a Two-way Data Binding. For learning
    more about Data Binding and Template Syntax, please refer to [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：使用`ngModel`，我们可以实现双向数据绑定。要了解更多关于数据绑定和模板语法的内容，请参考[第8章](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml)，*模板和数据绑定语法*。'
- en: The `ngModel` directive is written inside a square with the parentheses of event
    binding `[()]`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`指令写在带有事件绑定`[()]`的括号内。'
- en: Remember to import the forms Module from Angular forms or else you will get
    error messages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从Angular表单中导入表单模块，否则你会收到错误消息。
- en: 'An example of the `ngModel` Attribute Directive is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`属性指令的一个示例如下：'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`ngClass`: When we want to add or remove any CSS class to a DOM element, it''s
    preferred that we use the `ngClass` Attribute Directive. We can assign class names
    in different ways to `ngClass`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngClass`：当我们想要向DOM元素添加或移除任何CSS类时，最好使用`ngClass`属性指令。我们可以以不同的方式为`ngClass`分配类名。'
- en: We can assign class names using a `string`, or an `object` or a component `method`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`string`、`object`或组件`method`来分配类名
- en: 'An example of the `ngClass` Attribute Directive is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`属性指令的一个示例如下：'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember to wrap the name of CSS class in a single quote; otherwise, you won't
    see the styling.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将CSS类名用单引号括起来；否则，你将看不到样式。
- en: Remember to include the style sheet either in `index.html` or in your respective
    component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`index.html`或你的相应组件中包含样式表。
- en: '`ngStyle`: When we want to manipulate a few style properties of any DOM element,
    we can use `ngStyle`. You can relate this to inline styling in the CSS world.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngStyle`：当我们想要操纵任何DOM元素的一些样式属性时，我们可以使用`ngStyle`。你可以将其与CSS世界中的内联样式相关联。'
- en: 'An example of an `ngStyle` Attribute Directive is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`属性指令的一个示例如下：'
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alright, now that we learned about our built-in Attribute Directives, let's
    put them all together in an example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经了解了内置属性指令，让我们在一个示例中将它们全部放在一起。
- en: 'The following is a code example using `ngModel`, `ngClass`, and `ngStyle`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`ngModel`、`ngClass`和`ngStyle`的代码示例：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Take a look at the following screenshot with the output of the preceding code
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图，显示了前面代码示例的输出：
- en: '![](assets/ac668668-085d-4228-930b-d3c696a4a2ff.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ac668668-085d-4228-930b-d3c696a4a2ff.png)'
- en: Creating custom directives - Structural and Attribute Directives
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义指令-结构和属性指令
- en: So far in previous sections, we have learned about and implemented built-in
    directives provided by Angular.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在之前的章节中，我们已经学习并实现了Angular提供的内置指令。
- en: By creating custom user-defined directives, Angular allows us to define and
    extend the behavior and functionality of the elements in the page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建自定义用户定义的指令，Angular允许我们定义和扩展页面中元素的行为和功能。
- en: To create custom directives, we have to use the `@Directive` decorator and implement
    the logic in the class definition.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义指令，我们必须使用`@Directive`装饰器并在类定义中实现逻辑。
- en: We can create custom Component, Structural, and Attribute Directives.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自定义组件、结构和属性指令。
- en: Any user-defined HTML tag is a component attribute (for example, `<my-app>`).
    We have been creating custom components all along, throughout each chapter of
    the book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户定义的HTML标记都是组件属性（例如，`<my-app>`）。在本书的每一章中，我们一直在创建自定义组件。
- en: Angular CLI - generating the directives
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI-生成指令
- en: We will use the Angular CLI tool to generate directives for our examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Angular CLI工具为我们的示例生成指令。
- en: 'Navigate to the project directory and run the following `ng` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到项目目录并运行以下`ng`命令：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should see the output as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下屏幕截图中显示的输出：
- en: '![](assets/e9f368e1-a5ad-4770-a4bf-252859cb8b9a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9f368e1-a5ad-4770-a4bf-252859cb8b9a.png)'
- en: As you can see in the preceding screenshot, the newly generated directive `highlightDirective`
    is created and the `app.module.ts` file is updated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的屏幕截图中看到的，新生成的指令`highlightDirective`已经创建，并且`app.module.ts`文件已经更新。
- en: 'Before we go ahead with implementing our directives, here''s a quick recap
    of the Structural and Attribute Directives:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实现我们的指令之前，让我们快速回顾一下结构和属性指令：
- en: '**Structural Directive**: As the name suggests, the structural attribute affects
    the structure of the HTML layout since it shapes or reshapes the DOM structure.
    It can affect one or more elements in the page.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构指令：顾名思义，结构属性影响HTML布局的结构，因为它塑造或重塑了DOM结构。它可以影响页面中的一个或多个元素。
- en: '**Attribute Directive**: Defines and extends the appearance or behavior of
    an element in the page.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令：定义并扩展页面中元素的外观或行为。
- en: We learned to generate custom directives using Angular CLI and now we clearly
    know what and how Structural and Attribute Directives work.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了使用Angular CLI生成自定义指令，现在我们清楚地知道结构指令和属性指令是如何工作的。
- en: It's time to create our own custom directives. Read on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们自己的自定义指令了。继续阅读。
- en: Creating custom Attribute Directives
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义属性指令
- en: We will start by creating custom Attribute Directives. We will continue with
    the example `highlightDirective` we created in the preceding section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建自定义属性指令开始。我们将继续使用前一节中创建的示例`highlightDirective`。
- en: As the name suggests, we will use this directive to highlight the changed text
    color of elements attached to this attribute.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，我们将使用这个指令来突出显示附加到这个属性的元素的更改文本颜色。
- en: It's time to define the functionality and behavior of our directive, `highlightDirective`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义我们的指令`highlightDirective`的功能和行为了。
- en: 'In the `highlight-directive.ts` file, add the following lines of the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`highlight-directive.ts`文件中，添加以下代码行：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We need to import the required utilities provided by Angular for working with
    directives.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入Angular提供的必要工具来处理指令。
- en: We will import `Directive`, `ElementRef`, and `AfterViewInit` from `@angular/core`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`@angular/core`中导入`Directive`，`ElementRef`和`AfterViewInit`。
- en: As mentioned earlier, we define a directive using the `@Directive` decorator
    and passing the name `appHighlightDirective` in the metadata selector.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们使用`@Directive`装饰器定义指令，并在元数据选择器中传递名称`appHighlightDirective`。
- en: We are exporting the `appHighlightDirective` class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在导出`appHighlightDirective`类。
- en: As mentioned earlier, the Attribute Directive is specific to an element and
    hence we need to create an instance of the `ElementRef` variable, `elRef`, which
    we will use to target and update the element attached to our custom directive.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，属性指令特定于一个元素，因此我们需要创建`ElementRef`变量`elRef`的实例，我们将使用它来定位和更新附加到我们自定义指令的元素。
- en: In the `constructor` we are targeting the specific element by using the `nativeElement`
    method and updating the `style` property `color` with a value, `orange`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`中，我们使用`nativeElement`方法来定位特定的元素，并使用一个值`orange`更新`style`属性`color`。
- en: 'Now that we have created our directive, we need to apply it to the element
    in the app component template `app.component.html` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的指令，我们需要将其应用到应用程序组件模板`app.component.html`文件中的元素上：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/f4e1909f-6687-4223-84f4-05c8e09a3c6e.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4e1909f-6687-4223-84f4-05c8e09a3c6e.png)'
- en: See how easy and simple it is to create a custom Attribute Directive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看创建自定义属性指令是多么简单和容易。
- en: If you notice carefully, it's a very basic attribute which changes the color
    of the text. Now what if we want to pass the value of the color dynamically instead
    of a statically?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，它是一个非常基本的属性，可以改变文本的颜色。现在，如果我们想要动态地传递颜色的值而不是静态地传递呢？
- en: We have to enable our attribute to pass values as well. Let's see what changes
    we need to make our directive a more suitable candidate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使我们的属性能够传递值。让我们看看我们需要对我们的指令进行哪些更改，使其成为更合适的候选者。
- en: 'Let''s first edit in our component `app.component.html` template where we want
    to use the attribute:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will see, we are now passing a value `green` through the `highlightColor`
    variable for our attribute `appHighlightDirective`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update our `highlight-directive.ts` file and add the following lines of
    code to it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see the changes we have done in the `highlight-directive.ts` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We have additionally imported `Input` and `AfterViewInit` modules from the `@angular/core`
    library.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the `@Input` decorator to tell Angular that we want the value to
    be passed dynamically through the variable defined as `highlightColor`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ngAfterViewInit` method we are creating an object instance of the element
    using the `ElementRef` instance, `elRef`, and using the `nativeElement` method
    to update the `style` property `color` of the element.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `color` of the text changes to the value passed through the element's `appHighlightDirective`
    attribute's value passed through `highlightColor`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97851e61-16e0-47c9-b1ec-71eb2c6234a6.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Alright, so far so good. Our attribute is rather shaping up really well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the progress you have made so far in implementing our custom directive:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is good stuff. But what if we want to bind `Javascript` events such as
    `mouseover`, `mouseout`, `click`, or so on, to our attribute?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the necessary changes needed to implement events attached to our
    attribute. For this we will need a beautiful image and we will attach a few events
    along with custom Attribute Directive.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an image to the component `app.component.html` file template:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Important notes on the preceding code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We have added our custom attribute component, `appHighlightDirective`, to the
    element.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we have added two attributes, `showOpacity` and `hideOpacity`,
    which will have the style property of opacity to the element.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will attach `onmouseover` and `onmouseout` events to these attributes and
    will change the opacity of the image dynamically.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have added an image to the component view template, the updated
    output looks like the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f5b79ad5-80cd-4d95-9af4-e71d7c152651.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move over to the custom directive `highlight-directive.directive.ts`
    file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the updates we have done to the file in the preceding code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules `Directive`, `ElementRef`, `Input`, `HostListener`,
    and `AfterViewInit` from `@angular/core`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that for binding and implementing events to elements, we especially need
    to import `HostListener`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `@HostListener` decorator, we are binding the `mouseover` and `mouseout`
    events to the element we are attaching the custom attribute.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that when we use `this.elRef.nativeElement`, we are referring to the element
    which has the custom attribute attached to it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are assigning the value of the `this.hideOpacity` variable when the user
    takes the mouse over the element.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are assigning the value of the `this.showOpacity` variable when the user
    takes the mouse out of the element.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the application and you should see the output as shown in the following
    screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32301da1-f670-419a-8c74-abf66825e318.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Awesome. Now let''s see the progress you have made so far in implementing our
    custom directive:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned to attach events such `mouseover` and `mouseout` to our custom
    attribute, `highlightDirective`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you have learned to create and use a custom Attribute Directive
    having attributes and methods attached to the directive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In next section, you will learn to create custom Structural Directives.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Structural Directives
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far you have learned and implemented built-in directives--Component, Structural,
    and Attribute Directives.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to generate custom directives using Angular CLI in the section
    *Angular CLI - generating the directives*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In previous section, we learned and implemented custom Attribute Directives.
    In this section, we will learn to create Structural Directives.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new directive using Angular CLI:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the output of the preceding command as shown in the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/486c19c6-3e4f-4d92-b6c2-63183bf002a6.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Run the preceding `ng` command and we should see the directive created and the
    `app.module.ts` is updated with the newly created directive.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, time to create and implement our custom Structural Directive. Here''s
    the use case we will build using our custom Structural Directive:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We will use our Structural Directive to loop through a list of products.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The directive should display elements only which have `isAvailable` set to `true`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First let''s define our products JSON in the `app.component.ts` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just created a JSON list of products with the keys `productName` and `isAvailable`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Nothing super-heroic, not just yet!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to use the `*ngFor` loop and display the list of products in `app.component.html`
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's quickly analyze the preceding code
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We are using a built-in Structural Directive, `*ngFor`, for looping through
    the product list and displaying the name using the key `product.productName`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are defining our custom Structural Directive, `appCustomStructural`, and
    passing the `product` object for analysis.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are passing the entire product object to our attribute, we can now
    define our custom logic in `appCustomStructural` and do transformations based
    on our application needs.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time for some super-heroic work in our directive `custom-structural.directive.ts`
    file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s analyze in detail the preceding code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules `Directive`, `Input`, `TemplateRef`, `ViewContainerRef`,
    and `AfterViewInit` from `@angular/core`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are defining the CSS `selector` for our custom Structural Directive, `appCustomStructural`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `@Input` decorator, we are explicitly telling Angular that our
    custom directive will get input through `appCustomStructural`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we are injecting the instances of `TemplateRef<any>` and
    `ViewContainerRef`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `TemplateRef<any>`, we are mentioning that it's an embedded template that
    can be used to instantiate embedded views.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Structural Directives involve the shaping or reshaping of the DOM structure
    in the page, we are injecting `ViewContainerRef`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are checking if the value of `product.isAvailable` is equal to `true`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of `product.isAvailable` is true using the instance of `ViewContainerRef`--a
    container where one or more views can be attached, by using the method `createEmbeddedView`--we
    are appending the element to the view.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/00f90d26-7cc6-4a29-a867-5628af7de144.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: We see only Shoes and Belts being displayed since only those products have the
    `isAvailable` key set to true. Try changing the values of other products too and
    see the output display.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the custom Structural Directive. We learned
    about important utilities provided by Angular--`createEmbeddedView`, `ViewContainerRef`,
    and `TemplateRef`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary of things we have learned and implemented so far for our custom
    directives follows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`. We learned
    to pass values to the custom Attribute Directive using the `highlightColor` variable.
    We have learned to attach events such as `mouseover` and `mouseout` to our custom
    attribute `highlightDirective`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to create a custom Structural Directive `appCustomStructural`.
    We have learned to use `createEmbeddedView`, `ViewContainerRef`, and `TemplateRef`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about change detection, an important aspect
    of how Angular framework works internally, and also learn to use it for our applications
    as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Implementing change detection in Angular
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Change detection is the process of detecting any internal state changes in a
    model or component class and then reflect them back to the view, mainly by manipulating
    DOM.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Change detection is one of the most important changes from Angular 1.x to 2.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The application state changes happen either from model to view or vice versa.
    To understand better, take a look at the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5976ebb9-6ba5-40b2-9d0e-5f09c1b09a8b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Application state changes can happen in two ways:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: From Model to View Template (DOM)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From View (DOM) to Model (Component Class)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know that state changes happen either in a model or in DOM, let's
    analyze what triggers change detection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Change detection is triggered by the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript events (`click`, `mouseover`, `keyup`, and so on)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTimeout()` and `setInterval()`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous requests
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that all the preceding three listed ways are async processes. So it's safe
    to say that in Angular, change detection happens whenever we have async methods/requests
    in place.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into understanding more on change detection--how it works, how
    it's handled, and so on--let's quickly create an example to understand what triggers
    change detection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We created a button with a click event calling the `toggleUser` method.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the click event on `toggleUser`, the variable `isLoggedIn` value is set either
    to `true` or `false`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the variable, the value of `isLoggedIn` in the view is updated. If
    the value is `true`, Hello Packt Author is displayed, and if the value is false,
    `Hello Guest user` is displayed.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will learn about how Angular handles change detection
    internally and the utilities provided by Angular to help us implement better change
    detection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Change detection - Angular and ZoneJS
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official site of ZoneJS describes the library as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A Zone is an execution context that persists across async tasks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses ZoneJS for detecting changes and then calls the listener methods
    of those events.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Angular takes advantage of zones to handle all the internal state changes and
    change detection. Zones understand the context of the asynchronous actions and
    state changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Angular has a built-in `ngZone`, which tracks all the completed asynchronous
    actions and notifies them with a `onTurnDone` event. Every component gets a change
    detector, which keeps track of all the bindings attached to the component in a
    tree structure.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We don't have `$scope.apply` or `$digest` like in the previous version of Angular.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: By default, Angular change detection will always check whether the values have
    changed. Change detection is always performed the same from the top root component
    to the inner components in a tree structure.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: This is done for all components through change detector objects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Using `ngZones`, the performance of the Angular applications has increased drastically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Change detection strategy
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Angular defines a change detection strategy for every component
    in our application--which means every time there is any change in our template,
    it traverses down to the last component in a tree structure check for any changes
    and makes the necessary updates.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: This takes a performance hit!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Hence, Angular provides us with options to define explicitly which change detection
    strategy we want to implement for our components.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides a `ChangeDetectionStrategy` module by which we can define the
    change detection strategy we want to use.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different values `ChangeDetectionStrategy` takes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '`Default`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPush`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze each of these options in detail to understand how each of these
    work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: ChangeDetectionStrategy - Default
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default mechanism that Angular implements--changes are triggered
    by events and the propagation of changes goes from the view template to the model.
    Based on the logic implemented, the DOM structure is updated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note here is that using this strategy, every time Angular
    will traverse through all the components starting from the root component to the
    last component for checking if the properties have to be updated throughout.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Refer the example we created in preceding section, *Implementing change detection
    in Angular*. We are updating the properties and Angular by default uses the `ChangeDetectionStrategy`
    with the `Default` value.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ChangeDetectionStrategy - OnPush
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use `OnPush` to improve the performance of our Angular applications. We have
    to explicitly mention that we want to use the `OnPush` value for `ChangeDetectionStrategy`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Changes are triggered by events and the propagation of changes goes for the
    entire object that is rendered in the `view` template and not for each property.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `OnPush` value, we are forcing Angular to depend only on the
    inputs. We pass the objects through the `@Input` decorator and only the complete
    object and it's properties will be affected and not any individual property changed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of ChangeDetectionStrategy - OnPush
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous section you have learned about ChangeDetectionStrategy using both
    `default` and `OnPush` options.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of using `OnPush` option over `default` are given:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: It helps in increasing the performance of our Angular applications.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular doesn't have to traverse the entire component tree structure for detecting
    individual changes on properties.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular internally can skip the nested tree structures when inputted properties
    don't change.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To understand it better, let's create a use case. For that first we need to
    create a new component named `change-detect` using Angular CLI `ng` command.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the component is created, you should see the output as shown in the following
    screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0155047-2a5f-472b-8666-670957f012c5.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a `class` user and with properties `userName` and `userId` in
    the `user.ts` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s edit the `Component` class we generated and add the following lines
    of code snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s analyze the preceding code in detail:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules from `Input`, `Component`, and `ChangeDetectionStrategy`
    from the `@angular/core` library.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are importing the newly created `User` class into the component class.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are explicitly mentioning the value for `changeDetection` as `ChangeDetectionStrategy.OnPush`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the CSS `selector`; `app-change-detect` where we will display the
    output of the component.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are telling Angular to use the `OnPush` option, we need to use `@Input`
    and pass object that is in our case `User`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per the template part, we are binding the user properties, `userName` and
    `userId`, in the `view` template.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great. So far we have created our component and have explicitly mentioned that
    whenever a change is detected, the entire object that is the `user` object should
    be updated and not just an individual property.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create methods to test our logic. So an in the `AppComponent`
    class, add the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For our component, we have mentioned the `selector` to be used as `app-change-detect`.
    We need to use the component inside the template `app.component.html` file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We have also mentioned that the component takes the input as `user`; hence we
    are passing the user object to the component.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Add the following lines of code to the `app.component.html` template file with
    the component `app-change-detect`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alright, we are all set. Run the app and you should see the output as shown
    in the following screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9cc998d-b059-4abc-bfd5-bdeda22aca63.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'The application functionality can be summarized as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The `app-change-detect` component is loaded into `AppComponent` template.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default values passed for the object are displayed in the `view` template.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `Change Detection: OnPush` button and we see the updated user
    loaded in the view.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we click on `Change Detection: Default`, unlike the previous examples
    we have created, we don''t see any changes happening to the properties. It''s
    because we have explicitly mentioned that any change detection should be passed
    through objects and not properties using the `OnPush` option of `ChangeDetectionStrategy`.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have learned about change detection strategies provided
    by Angular. We have explored how we can improve the performance of our applications
    by using the `OnPush` option by forcing Angular to only check for objects passed
    as inputs and not individual properties.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Updating properties will tell Angular to traverse through the entire application
    component tree structure and it takes a hit on performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about directives and also about different types
    of directives, namely Component Directives, Structural Directives, and Attribute
    Directives.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We implemented custom user-defined directives to understand how we can extend
    directives and use them more effectively.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: We learned briefly about ZoneJS, and how zones can help us to handle the `async`
    tasks in modern applications frameworks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how Angular handles changes detection and how we can use
    change detection methods to improve the overall application performance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about asynchronous programming using Observables.
    In this chapter, we will learn how to take advantage of asynchronous programming
    with Angular by using Observable and Promises.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will learn how to built a basic, yet extensible asynchronous
    JSON API for querying the Marvel Cinematic Universe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
