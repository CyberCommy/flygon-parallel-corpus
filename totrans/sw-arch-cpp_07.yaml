- en: Leveraging C++ Language Features
  prefs: []
  type: TYPE_NORMAL
- en: The C++ language is a unique beast. It's used in a plethora of cases, varying
    from creating firmware and operating systems, desktop and mobile applications,
    to server software, frameworks, and services. C++ code runs on all kinds of hardware,
    is massively deployed on compute clouds, and can even be found in outer space.
    Such success wouldn't have been possible without the broad set of features this
    multi-paradigm language has.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how to leverage what the C++ language offers so that
    we can achieve safe and performant solutions. We will demonstrate the best industry
    practices for type safety, avoiding memory issues, and creating efficient code
    in an equally efficient manner. We will also teach you how to use certain language
    features when designing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing resources and avoiding leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving computations from runtime to compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the power of safe types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating easy to read and performant code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing code into modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this journey, you'll learn about the features and techniques that are
    available in various standards of C++, ranging from C++98 all the way to C++20\.
    This will include declarative programming, RAII, `constexpr`, templates, concepts,
    and modules. Without further ado, let's begin this journey.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following tools to build the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A compiler that supports C++20 (GCC 11+ is recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.15+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Designing great APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although C++ allows you to use the well-known object-oriented APIs that you
    may be familiar with if you write code in so-called coffee-based languages, it
    has some other tricks up its sleeves. We'll mention a few of them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging RAII
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's the main difference between a C API and a C++ one? Usually, it's not
    about polymorphism or having classes per se, but about an idiom called RAII.
  prefs: []
  type: TYPE_NORMAL
- en: '**RAII** stands for **Resource Acquisition Is Initialization**, but it''s actually
    more about releasing resources than acquiring them. Let''s take a look at a similar
    API written in C and C++ to show this feature in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The C++ API is based on the C one, but this doesn't always need to be the case.
    What's important here is that in the C++ API, there's no need for a separate function
    to free our precious resource. Thanks to the RAII idiom, it's done automatically
    once a `ResourceRaii` object goes out of scope. This takes the burden of manual
    resource management away from the user, and the best part is that it comes at
    no extra cost.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, we didn't need to write any class of our own – we just reused the
    standard library's `unique_ptr`, which is a lightweight pointer. It ensures that
    the object it manages will always be freed, and it will always be freed exactly
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're managing some special kinds of resources and not memory, we had
    to use a custom deleter type. Our `acquireResourceRaii` function would need to
    pass the actual pointer to the `releaseResource` function. The C API itself doesn't
    need to be exposed to the user if you only want to consume it from C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to note here is that RAII is not just for managing memory:
    you can use it to easily handle ownership of any resource, such as locks, file
    handles, database connections, and anything else that should be released once
    its RAII wrappers go out of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the interfaces of containers in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementations of the standard library are great places to search for idiomatic
    and performant C++ code. For instance, if you want to read some really interesting
    template code, you should give `std::chrono` a shot, as it demonstrates some useful
    techniques and has a fresh approach to this. A link to libstdc++'s implementation
    can be found in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to other places of the library, even a quick peek at its containers
    shows that their interfaces tend to differ from their counterparts in other programming
    languages. To show this, let''s take a look at a pretty straightforward class
    from the standard library, `std::array`, and analyze it bit by bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you can see when you start reading the class definition is that
    it creates aliases for some types. This is common across the standard containers,
    and the names of those aliases are the same in many of them. This happens for
    a few reasons. One of them is the rule of least surprise – having it this way
    reduces the time developers spend scratching their heads and trying to understand
    what you meant and how a specific alias was named. Another reason is that the
    users of your class and library writers will often depend on such type traits
    when they're writing their own code. If your container won't provide such aliases,
    it will make using it with some standard utilities or type traits harder, so the
    users of your APIs will have to work around this or even use a completely different
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Having such type aliases can be useful even if you're not using them in your
    templates. It's not uncommon to rely on those types for function parameters and
    class member fields, so always remember to provide them if you're writing a class
    that other people could use. For instance, if you're writing an allocator, many
    of its consumers will rely on specific type aliases being present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the array class will bring us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, the next interesting thing about `std::array` is that it has no definition
    of a constructor, including copy/move constructors; assign operators; or destructors.
    It's simply because having those wouldn't add any value. Often, adding such members
    when it's not necessary is actually harmful to performance. With a non-defaulted
    constructor (and `T() {}` is already non-defaulted, as opposed to `T() = default;`),
    your class is no longer trivial nor trivially constructible, which prevents the
    compiler from making optimizations to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what other declarations our class has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see two member functions, including a member swap. Often, it's profitable
    to not rely on the default behavior of `std::swap` and to provide our own. For
    instance, in the case of `std::vector`, the underlying storage is swapped as a
    whole instead of each element being swapped. When you're writing a member swap
    function, be sure to also introduce a free function named `swap` so that it can
    be detected via **argument-dependent lookup** (**ADL**). It could just call your
    member's `swap` function.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing regarding the swap function that's worth mentioning is that it's
    conditionally `noexcept`. If the stored type can be swapped without throwing exceptions,
    the array's swap will be `noexcept` as well. Having a non-throwing swap can help
    you achieve strong exception safety guarantees in copy operations for classes
    that are storing our type as a member.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code block, now comes a big set of functions that
    show us another important aspect of many classes – their iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Iterators are vital for every container. If you don't provide iterator access
    for your class, you won't be able to use it in range-based for loops and it won't
    be compatible with all the useful algorithms from the standard library. This doesn't
    mean that you need to write your own iterator types – you could just use a simple
    pointer if your storage is contiguous. Providing `const` iterators can help you
    use your class in an immutable manner, and providing reverse iterators can help
    with enabling more use cases for your container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what comes next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Following the iterators, we have a few ways to inspect and modify the container's
    data. In the case of `array`, all of them are `constexpr`. This means that if
    we were to write some compile-time code, we could use our array class. We'll look
    at this in more detail later in this chapter, in the *Moving computations at compile
    time* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we made it through the whole definition of our `array`. Its interface
    doesn''t end there, however. Starting with C++17, after a type definition, you
    can spot lines similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Such statements are called **deduction guides**. They''re part of a feature
    called **Class Template Argument Deduction** (**CTAD**), which was introduced
    in C++17\. It allows you to omit the template parameters when you''re declaring
    a variable. It''s handy for `array` because now, you can just write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it could be even handier for more complex types, such as maps, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, however, a catch here: we needed to specify that we''re passing the
    key-value pair when we passed the first argument (note that we also used a deduction
    guide for it).'
  prefs: []
  type: TYPE_NORMAL
- en: Since we're on the topic of interfaces, let's point to some other aspects of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers in interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The types that you use in your interfaces matter a lot. Even if there's documentation,
    a good API should still be intuitive at a glance. Let's see how different approaches
    to passing resource parameters to a function can suggest different things to the
    API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When should you use which of those functions?
  prefs: []
  type: TYPE_NORMAL
- en: Since smart pointers are now the standard way to deal with resources, `A` and
    `B` should be left for simple parameter passing and shouldn't be used if you don't
    do anything with the ownership of the passed objects. `A` should only be used
    for a single resource. For example, if you want to pass multiple instances, you
    could use a container, such as `std::span`. If you know the object you want to
    pass is not null, it's best to pass it by using a reference, such as a const reference.
    You can also consider passing by value if the object is not too big.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb regarding functions `C` to `F` is that you should only
    pass smart pointers as arguments if you want to manipulate the pointers themselves;
    for example, for transferring ownership.
  prefs: []
  type: TYPE_NORMAL
- en: The `C` function takes a `unique_ptr` by value. This means it's a resource sink.
    In other words, it consumes and then frees the resource. Note that just by selecting
    a specific type, the interface expresses its intent clearly.
  prefs: []
  type: TYPE_NORMAL
- en: The `D` function should only be used if you want to pass in a `unique_ptr` containing
    one resource and receive another resource in the same `unique_ptr` as an out parameter.
    It's not a good idea to have such a function for simply passing a resource since
    it requires that the caller stores it specifically in a `unique_ptr`. In other
    words, if you think about passing a `const unique_ptr<Resource>&`, just pass a
    `Resource*` (or `Resource&`) instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `E` function is meant for sharing resource ownership with the callee. Passing
    a `shared_ptr` by value can be relatively costly, as it is required to increment
    its reference counters. However, in this case, passing `shared_ptr` by value is
    okay, since a copy must be made somewhere if the callee really wants to become
    a shared owner.
  prefs: []
  type: TYPE_NORMAL
- en: The `F` function is similar to `D` and should only be used when you want to
    manipulate the `shared_ptr` instance and propagate the change through this in/out
    parameter. If you're unsure if the function should take ownership or not, consider
    passing a `const shared_ptr&`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying preconditions and postconditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not uncommon for a function to have some requirements regarding its parameters.
    Each requirement should be stated as a precondition. If a function guarantees
    that its result has some properties – for example, it is non-negative – the function
    should make that clear as well. Some developers resort to placing comments to
    inform others about this, but it doesn't really enforce the requirement in any
    way. Placing `if` statements is better, but hides the reason for the check. Currently,
    the C++ standard still doesn't offer a way to deal with this (contracts were first
    voted into the C++20 standard, just to be removed later on). Fortunately, libraries
    such as Microsoft's **Guideline Support Library** (**GSL**) provide their own
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that, for whatever reason, we''re writing our own queue implementation.
    The push member function could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the user doesn't even need access to the implementation to be sure
    that some checks are in place. The code is also self-documenting as it's clear
    what the function requires and what the result will be.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging inline namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In systems programming, oftentimes, you're not always just writing code against
    an API; often, you need to care about ABI compatibility as well. A famous ABI
    break happened when GCC released its fifth version, with one of the major changes
    being the change of the class layout of `std::string`. This meant that libraries
    working with older GCC versions (or still using the new ABI in newer versions,
    which is still a thing in recent GCC releases) would not work with code written
    using a later ABI. In the case of an ABI break, if you receive a linker error,
    you can consider yourself lucky. In some cases, such as mixing `NDEBUG` code with
    debug code, you'll likely get memory corruption if a class only has members available
    in one such configuration' for instance, special members being added for better
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some memory corruptions, which are often hard to debug, can easily be turned
    into linker errors with the use of C++11''s inline namespaces. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the preceding code uses inline namespaces, the users won''t see a difference
    between the two build types when you''re declaring objects of this class: all
    declarations from an inline namespace are visible in the surrounding scope. The
    linker, however, will end up with different symbol names, which will cause the
    linker to fail if it tries to link incompatible libraries, giving us the ABI safety
    we''re looking for and a nice error message mentioning the inline namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: For more tips on providing safe and elegant ABIs, please see *Arvid Norberg's*
    *The ABI Challenge* talk from *C++Now* 2019, which is linked in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging std::optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going back from ABIs to APIs, let's mention one more type that we omitted when
    we were designing great APIs earlier in this book. The hero of this section can
    save the day when it comes to optional parameters for functions as it can help
    your types have components that may or may not hold value, and it can also be
    used for designing clean interfaces or as a replacement for pointers. This hero
    is called `std::optional` and was standardized in C++17\. If you can't use C++17,
    you can still find it in Abseil (`absl::optional`), or find a very similar version
    from Boost (`boost::optional`). A big plus of using those classes is that they
    express the intent very clearly, which helps with writing clean and self-documenting
    interfaces. Let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Optional function parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll start by passing arguments to functions that can, but may not, hold value.
    Have you ever stumbled upon a function signature similar to the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it's just too easy to pass a `-1` by mistake when you didn't want
    to if `param` was calculated somewhere else in code – perhaps where it was even
    a valid value. How about the following signature?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, it''s much clearer what to do if you don''t want to pass a `value`:
    just pass an empty optional. The intent is clear, and `-1` can still be used as
    a valid value instead of you having to give it any special meaning in a type-unsafe
    manner.'
  prefs: []
  type: TYPE_NORMAL
- en: That's just one usage of our optional template. Let's see some others.
  prefs: []
  type: TYPE_NORMAL
- en: Optional function return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like with accepting special values to signify the *no value* of a parameter,
    a function can sometimes return *no value*. Which of the following would you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How can you tell what value the first function will return in case of errors?
    Or will it throw an exception instead of returning a magic value? Moving on to
    the second signature, it looks like `false` will be returned if there is an error,
    but it's still easy to just forget to check it and read `parsed_number` directly,
    potentially causing trouble. In the third case, while it's relatively safe to
    assume a `nullptr` will be returned on errors and an integer in case of success,
    it's now unclear if the returned `int` should be freed.
  prefs: []
  type: TYPE_NORMAL
- en: With the last signature, it's clear by just looking at it that an empty value
    will be returned in case of errors and that there's nothing else that needs to
    be done. It's simple, understandable, and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Optional return values can also be used to just mark a *no value* being returned,
    not necessarily that an error had occurred. Having said that, let's move on to
    our last use case for optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Optional class members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Achieving coherence in a class state is not always an easy task. For instance,
    sometimes, you want to have a member or two that can simply not be set. Instead
    of creating another class for such a case (which increases code complexity) or
    reserving a special value (which is easy to pass unnoticed), you can use an optional
    class member. Consider the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see which fields are necessary and which ones don't need to be
    filled. The same data could be stored using empty strings, but this wouldn't be
    clearly visible just from the struct's definition. Another alternative would be
    to use `std::unique_ptr's`, but then we would lose data locality, which is often
    essential for performance. For such cases, `std::optional` can be of great value.
    It should definitely be a part of your toolbox when you want to design clean and
    intuitive APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge can help you provide high-quality and intuitive APIs. There's
    one more thing you can do to improve them further that will also help you write
    less buggy code by default. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing declarative code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you familiar with imperative versus declarative coding styles? The former
    is when your code tells the machine *how* to achieve what you want step by step.
    The latter is when you tell the machine just *what* you want to achieve. Certain
    programming languages favor one over the other. For instance, C is imperative,
    while SQL is declarative, just like many functional languages. Some languages
    allow you to mix the styles – think of LINQ in C#.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a flexible beast that allows you to write code in both ways. Is there
    one you should prefer? It turns out that when you're writing declarative code,
    usually a higher level of abstraction is kept, which leads to fewer bugs and easier-to-spot
    errors. So, how can we write C++ declaratively? There are two main tactics to
    apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is to write functional-style C++, which is where you prefer a
    pure-functional style (no side effects of functions) if possible. Instead of writing
    loops by hand, you should try using standard library algorithms. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compare the preceding code with the following snippet, which does the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both snippets return the last day that had a relatively stable temperature.
    Which one of those would you rather read? Which one is easier to understand? Even
    if you're not that familiar with C++ algorithms now, after encountering them a
    few times in code, they just feel simpler, safer, and cleaner than hand-crafted
    loops. That's because they often are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second tactic for writing declarative code in C++ is already somewhat present
    in the previous snippet. You should prefer using declarative APIs, such as the
    one from the ranges library. And although no range views were used in our snippet,
    they can make a lot of difference. Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a great example of declarative coding: you just specify what should
    happen, not how. The preceding code takes the first two even numbers, reverses
    their order, and prints them as a string, thus printing the famous answer to life,
    the universe, and everything: 42\. All of this is done in an intuitive and easily
    modifiable way.'
  prefs: []
  type: TYPE_NORMAL
- en: Showcasing a featured items gallery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough with the toy examples, though. Remember our Dominican Fair application
    from [Chapter 3](7f6118d3-ac40-4b40-9348-6ffabde7ef9b.xhtml), *Functional and
    Nonfunctional Requirements*? Let's write a component that will select and display
    a few featured items from the stores that a customer saved as their favorites.
    This can be pretty handy when we're writing a mobile app, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a mostly C++17 implementation, which we'll update to C++20
    throughout this chapter. This will include adding support for ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with some code for obtaining information about the current
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the store owners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The stores also need to have items in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Some items may not have photos or prices, which is why we used `std::optional`
    for those fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add some code that describes our items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a helper lambda for converting our `optionals` into strings.
    Since we only want to use it in our `<<` operator, we defined it inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how we used C++14''s generic lambdas (the auto parameter), along with
    C++17''s `constexpr` and the `is_same_v` type trait, so that we have a different
    implementation when we''re dealing with an optional `<string>` versus other cases.
    Achieving the same pre-C++17 would require writing templates with overloads, resulting
    in more complicated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can define the store itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What's worth noting here is the use of the `gsl::not_null` template from the
    Guidelines Support Library, which signals that the owner will always be set. Why
    not use just a plain old reference? That's because we may want our store to be
    moveable and copyable. Using a reference would hinder that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have those building blocks, let's define how to get a customer's
    favorite stores. For simplicity, let's assume we're dealing with hardcoded stores
    and merchants instead of creating code to deal with external data stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a type alias for the stores and begin our function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s hardcode some merchants, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a store with some items, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduced our first C++20 feature. You might not be familiar with
    the `.field = value;` syntax unless you've coded in C99 or newer. Starting from
    C++20, you can use this notation (officially called designated initializers) to
    initialize aggregate types. It's more constrained than in C99 because the order
    is important, although it has some other minor differences. Without those initializers,
    it can be hard to understand which value initializes which field. With them, the
    code is more verbose but easier to comprehend, even for people unfamiliar with
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve defined our stores, we can write the last part of our function,
    which will do the actual lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our stores, let''s write some code to obtain the featured
    items for those stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was for obtaining items from one store. Let''s also write
    a function that will obtain items from all the given stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `std::copy` to insert elements into a vector, with memory
    preallocated by the reserve call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a way to obtain interesting items, let''s sort them by "freshness"
    so that the most recently added ones will appear first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we leveraged `std::sort` with a custom comparator. If you like,
    you could also force the same type for both `left` and `right`. To do so in a
    generic manner, let''s use another C++20 feature: template lambdas. Let''s apply
    them to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `T` type for the lambda will be deduced just like it would for any other
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two parts that are missing are the actual rendering code and the main
    function to glue it all together. In our example case, rendering will be as simple
    as printing to an `ostream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we just copy each element to the standard output and insert a newline
    between the elements. Using `copy` and an `ostream_iterator` allows you to handle
    the element's separators for yourself. This can be handy in some cases; for instance,
    if you don't want a comma (or a newline, in our case) after the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our main function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Voila! Feel free to run the code to see how it prints our featured items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're done with our base implementation, let's see how we can improve
    it by using some new language features from C++20.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing standard ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first addition will be the ranges library. As you may recall, it can help
    us achieve elegant, simple, and declarative code. For brevity, first, we will
    pull in the `ranges` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll leave the code-defining merchants, items, and stores as-is. Let''s start
    our modifications by using the `get_featured_items_for_store` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, making a range out of a container is straightforward: just
    pass it to a pipe operator. Instead of our hand-crafted loop to filter featured
    elements, we can use the `views::filter` expression, passing it a member pointer
    as the predicate. Due to the magic of `std::invoke` under the hood, this will
    correctly filter out all items that have our Boolean data member set to `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to convert each item into a `gsl::not_null` pointer so that we
    can avoid unnecessary item copies. Finally, we return a vector of such pointers,
    the same as in our base code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can use the preceding function to obtain all the featured
    items from all our stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a range from all the stores and transformed them using the
    function we created in the previous step. Because we needed to dereference each
    element first, we used a helper lambda. Views are lazily evaluated, so each transform
    will be done only when it is about to be consumed. This can sometimes save you
    lots of time and computations: assuming you would only want the first N items,
    you can skip the unnecessary calls to `get_featured_items_for_store`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our lazy view, similar to our base implementation, we can reserve
    space in the vector and copy items there from each nested vector in the `all_featured`
    view. Range algorithms are more concise to use if you take the whole container.
    Look how copy doesn't require us to write `std::begin(elem)` and `std::end(elem)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our items, let''s simplify our sorting code by using ranges
    to process them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see how ranges can help you write more concise code. The preceding
    copy and the sort here are both range *algorithms*, as opposed to *views*. They
    are eager and allow you to use projections. In our case, we just passed another
    member of our item class so that it can be used for comparison when sorting. Effectively,
    each item will be projected as just its `date_added`, which will then be compared
    using `greater{}`.
  prefs: []
  type: TYPE_NORMAL
- en: But wait – our items are actually `gsl::not_null` pointers to `Item`. How does
    this work? It turns out that our projection will dereference the `gsl::not_null`
    pointer first because of the cleverness of `std::invoke`. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change that we can make is in our "rendering" code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, ranges just help us remove some boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: When you run our updated version of the code, you should get the same output
    as in the base case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were expecting more from ranges than just concise code, there''s good
    news: they can be used even more efficiently in our case.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing memory overhead and increasing performance using ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You already know that using lazy evaluation in `std::ranges::views` can help
    with performance by eliminating unnecessary compute. It turns out we can also
    use ranges to reduce the memory overhead in our example. Let''s revisit our code
    for obtaining featured items from a store. It can be shortened down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that our function no longer returns items, instead relying on C++14's auto
    return type deduction. In our case, instead of returning a vector, our code will
    return a lazy view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to consume this for all stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, because our preceding function returns a view instead of the vector, we
    end up with a view of views after calling `transform`. This means we can use yet
    another standard view called join to join our nested views into just one that's
    unified.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `std::ranges::distance` to preallocate space in our destination
    vector, after which we make our copy. Some ranges are sized, in which case you
    could call `std::ranges::size` instead. The resulting code has just one call to
    `reserve`, which should give us a nice performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes introducing ranges to our code. Since we ended this section on
    a performance-related note, let's talk about one more topic that's important for
    this aspect of C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: Moving computations at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with the advent of modern C++ in the early 2000s, C++ programming became
    more about computing things during compilation instead of deferring them to runtime.
    It's much cheaper to detect errors during compilation than to debug them later
    on. Similarly, it's much faster to have the result ready before the program is
    started instead of calculating it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, there was template metaprogramming, but with C++11 onward, each new
    standard brought additional features for compile-time compute: be it type traits,
    constructs such as `std::enable_if` or `std::void_t`, or C++20''s `consteval`
    for computing stuff only at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: One feature that improved over the years was the `constexpr` keyword and its
    related code. C++20 really improved and extended `constexpr`. Now, you can not
    only write regular simple `constexpr` functions thanks to the previous standards
    (quite an improvement from C++11's single-expression ones), but you can also use
    dynamic allocations and exceptions inside them, not to mention `std::vector and
    std::string`!
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s more: even virtual functions can now be `constexpr`: overload resolution
    happens as usual, but if a given one is `constexpr`, it can get called at compile
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another improvement was made to standard algorithms. Their non-parallel
    versions are all ready for you to use in your compile-time code. Consider the
    following example, which can be used to check if a given merchant is present in
    a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're doing a binary search for an array of merchants, sorted
    by their IDs.
  prefs: []
  type: TYPE_NORMAL
- en: To gain insight into the code and its performance, we recommend that you take
    a quick look at the assembly that this code generates. Along with the advent of
    compile-time computations and chasing performance, one of the invaluable tools
    that was developed was the [https://godbolt.org](https://godbolt.org) site. It
    can be used to quickly play with code to see how different architectures, compilers,
    flags, library versions, and implementations influence the generated assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We tested the preceding code using GCC trunk (before GCC 11 was officially
    released) with `-O3` and `--std=c++2a`. In our case, we checked the generated
    assembly with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the few dozens of assembly lines using the following Godbolt: [https://godbolt.org/z/PYMTYx](https://godbolt.org/z/PYMTYx).'
  prefs: []
  type: TYPE_NORMAL
- en: '*But wait* – you could say that *there''s a function call in the assembly,
    so maybe we could inline it so it can be optimized better?* That would be a valid
    point. Often, this helps a lot, although now, we just get the assembly inlined
    (see: [https://godbolt.org/z/hPadxd](https://godbolt.org/z/hPadxd)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, try changing the signature to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`constexpr` functions are implicitly inline, so we removed that keyword. If
    we look into the assembly, we will see that some magic happened: the search was
    optimized away! As you can see at [https://godbolt.org/z/v3hj3E](https://godbolt.org/z/v3hj3E),
    all the assembly that was left was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The compiler optimized our code so that the only thing left is our pre-computed
    result being returned. That's pretty impressive, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Helping the compiler help you by using const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compilers can optimize pretty well, even if you don't give them `inline` or
    `constexpr` keywords, as in the preceding example. One thing that helps them achieve
    performance for you is marking variables and functions as `const`. Perhaps even
    more importantly, it also helps you avoid making mistakes in your code. Many languages
    have immutable variables by default, which can lead to fewer bugs, code that's
    easier to reason about, and often faster multi-threaded performance.
  prefs: []
  type: TYPE_NORMAL
- en: Even though C++ has mutable variables by default and you need to explicitly
    type `const`, we encourage you to do so. It can really help you stop making tricky
    typos related to modifying a variable that you shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: Using `const` (or `constexpr`) code is part of a bigger philosophy called type
    safety. Let's say a few words about it.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of safe types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ relies heavily on mechanisms that help you write type-safe code. Language
    constructs such as explicit constructors and conversion operators have been baked
    into the language for a long time. More and more safe types are being introduced
    to the standard library. There's `optional` to help you avoid referencing empty
    values, `string_view` to help you avoid going out of a range, and `any` as a safe
    wrapper for any type, just to name a few. Moreover, with its zero-cost abstractions,
    it's recommended that you create your own types that are useful and hard or impossible
    to misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Often, using C-style constructs can lead to type-unsafe code. One example would
    be C-style casts. They can resolve to a `const_cast, static_cast`, `reinterpret_cast`,
    or one of these two combined with a `const_cast`. Accidentally writing to a `const`
    object that was `const_cast` is undefined behavior. So is reading memory returned
    from a `reinterpret_cast<T>`, if T was not the original type of the object (C++20's
    `std::bit_cast` can help here). Both of those cases are much easier avoided if
    C++ casts are used.
  prefs: []
  type: TYPE_NORMAL
- en: C was perhaps too permissive when it came to types. Fortunately, C++ introduces
    many type-safe alternatives to problematic C constructs. There are streams and
    `std::format` instead of `printf` et al., and there's `std::copy` and other similar
    algorithms instead of the unsafe `memcpy`. Finally, there are templates instead
    of functions taking a void `*` (and paying a price in terms of performance). With
    C++, templates get even more type safety through a feature called concepts. Let's
    see how we can improve our code by using them.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first way concepts can improve your code is by making it more generic. Do
    you remember the cases where you needed to change the container type in one place,
    which caused a cascade of changes in other places too? If you weren't changing
    the container to one with totally different semantics and that you had to use
    in a different way, that means your code may not have been generic enough.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, have you ever written a template or sprinkled `auto` over
    your code and later wondered if your code would break if someone changed the underlying
    type?
  prefs: []
  type: TYPE_NORMAL
- en: 'Concepts are all about putting the right level of constraints onto the types
    you''re operating on. They constrain what types your template can match, and are
    checked at compile time. For instance, let''s say you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, `foo()` must be passed a type that supports `std::swap` to work.
  prefs: []
  type: TYPE_NORMAL
- en: Do you recall some templates that matched just too many types? Previously, you
    could use `std::enable_if`, `std::void_t`, or `if constexpr` to constrain them.
    However, writing `enable_if` statements was a bit cumbersome and could slow down
    your compilation times. Here, concepts come to the rescue once more due to their
    conciseness and how they express their intent clearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few dozen standard concepts in C++20\. Most of them live in the
    `<concepts>` header and can be divided into four categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Core language concepts, such as `derived_from`, `integral`, `swappable`, and
    `move_constructible`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison concepts, such as `boolean-testable`, `equality_comparable_with`,
    and `totally_ordered`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object concepts, such as `movable`, `copyable`, `semiregular`, and `regular`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callable concepts, such as `invokable`, `predicate`, and `strict_weak_order`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional ones are defined in the `<iterator>` header. These can be divided
    into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect callable concepts, such as `indirect_binary_predicate` and `indirectly_unary_invocable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common algorithm requirements, such as `indirectly_swappable`, `permutable`,
    `mergeable`, and `sortable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a dozen can be found in the `<ranges>` header. Examples include `range`
    (duh), `contiguous_range`, and `view`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that''s not enough for your needs, you can declare your own concepts similarly
    to how the standard defines the ones we just covered. For instance, the `movable`
    concept is implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, if you look at `std::swappable`, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This means a type, `T`, will be `swappable` if `ranges::swap(a, b)` compiles
    for two references of this type.
  prefs: []
  type: TYPE_NORMAL
- en: When defining your own concepts, be sure that you cover the semantic requirements
    for them. Specifying and using a concept when defining an interface is a promise
    that's made to the consumers of that interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you can go with the so-called shorthand notation in declarations for
    brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For readability and type safety, it's recommended that you use `auto` together
    with a concept to constrain the type and let your readers know the kind of object
    they're dealing with. Code written in this manner will retain the perks of auto-like
    genericity. You can use this in both regular functions and lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: A great bonus of using concepts is shorter error messages. It's not uncommon
    to cut a few dozens and dozens of lines about one compilation error down to just
    a few lines. Yet another bonus is that you can overload on concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to our Dominican Fair example. This time, we'll add some
    concepts to see how they can improve our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make `get_all_featured_items` return just a range of items. We
    can do so by adding the concept to the return type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Now, let''s add yet another requirement to this type that
    will be enforced when we call `order_items_by_date_added`: our range must be sortable.
    `std::sortable` has already been defined for a range iterator, but for our convenience,
    let''s define a new concept called `sortable_range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Similar to its standard library counterpart, we can accept a comparator and
    a projection (which we introduced with ranges). Our concept is satisfied by (will
    be matched by) types that satisfy the `random_access_range` concept, as well as
    having an iterator that satisfies the aforementioned sortable concept. It's as
    simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining concepts, you can also use the `requires` clause to specify additional
    constraints. For instance, if you want our range to store elements with a `date_added`
    member only, you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However, in our case, we don't need to constrain the type that much, as you
    should leave some flexibility when you're using concepts and define them so that
    it will make sense to reuse them.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s important here is that you can use the `requires` clause to specify
    what code should be valid to call on your type when it meets the requirements
    for a concept. If you want, you can specify constraints on the type that''s returned
    by each subexpression; for instance, to define something incrementable, you could
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our concept, let''s redefine the `order_items_by_date_added`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, our compiler will check if any range we pass to it is a sortable one and
    contains a `date_added` member that can be sorted using `std::ranges::greater{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to use the more constrained concept here, the function would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s redo our rendering function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that a concept name can be used instead of the `typename`
    keyword in a template declaration. One line below this, you can see that the `requires`
    keyword can also be used to further constrain the appropriate types based on their
    traits. This can be handy if you don't want to specify a new concept.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for concepts. Now, let's write some modular C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modular C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last big feature of C++ we'll discuss in this chapter is modules. They are
    yet one more addition to C++20 that has a great impact on building and partitioning
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ has used `#include` for a really long time now. However, this textual form
    of dependency inclusion has its flaws, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the need to process lots of text (even a `Hello World` after preprocessing
    is around half a million lines of code), it's slow. This leads to **one-definition
    rule** (**ODR**) violations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of your `includes` matters, but it shouldn't. This one is twice as
    bad as the preceding one as it also leads to cyclic dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it's hard to encapsulate stuff that just needs to be in header files.
    Even if you put some stuff in a detailed namespace, someone will use it, as Hyrum's
    law predicts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, this is when modules enter the game. They should solve the aforementioned
    flaws, bringing a great speedup to build times and better C++ scalability when
    it comes to building. With modules, you only export what you want to export, which
    results in good encapsulation. Having a specific order of dependency inclusion
    is no longer an issue too, as the order of imports doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing, compiler support for modules is still
    only partially done. This is why we decided to just showcase what was already
    available in GCC 11\. Sadly, this means that stuff such as module partitions won't
    be covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each module, after compilation, will be compiled to not only the object file
    but also a module interface file. This means that instead of parsing a file with
    all of its dependencies, compilers can quickly know what types and functions a
    given module contains. All you need to do is to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You can use it once `my_module` has been compiled and available. The module
    itself should be defined in a `.cppm` file, but those are still not supported
    by CMake. You might be better off just naming them `.cpp` for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let's return to our Dominican Fair example and show how
    to use them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create our first module for the customer code, starting with
    the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This statement marks that from this point on, everything will be private in
    this module. This marks a good place to put your includes and other content that
    won't be exported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must specify the name of the exported module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the name we''ll use to import the module later. This line must
    come before the exported contents. Now, let''s specify what our module will actually
    export, prefixing the definitions with the `export` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And done! Our first module is ready to be used. Let''s create another one for
    the merchant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Pretty similar to our first module, here, we specified the name and the type
    to be exported (as opposed to a type alias and a function for the first one).
    You can export other definitions, such as templates, too. It gets tricky with
    macros, though, as you need to import `<header_file>` for them to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, a good advantage of modules is that they don''t allow macros to
    propagate to imported modules. This means that when you write code such as the
    following, the module won''t have `MY_MACRO` defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It helps to have determinism in modules as it protects you from breaking code
    in other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a third module for our stores and items. We won''t discuss
    exporting other functions, enums, and other types as it won''t differ from the
    previous two modules. What''s interesting is how the module file starts. First,
    let''s include what we need in our private module section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In C++20, standard library headers are not modules yet, but this will likely
    change in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the interesting part. Our store module imports the merchant module
    we defined previously and then reexports it as part of the store''s interface.
    This can be handy if your module is a facade for other ones, such as in module
    partitions in the near future (also part of C++20). When available, you will be
    able to split your module across multiple files. One of them could contain the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed previously, it would then be exported by the main file of your
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This concludes modules and the big C++ features that we planned for this chapter.
    Let's summarize what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about many C++ features and their impact on writing
    concise, expressive, and performant C++ code. We learned about providing proper
    C++ component interfaces. You're now able to apply principles such as RAII to
    write elegant code that's free from resource leaks. You also know how to leverage
    types such as `std::optional` to express your intent better in your interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we demonstrated how to use features such as generic and template lambdas,
    as well as `if constexpr` for writing less code that will work with many types.
    You're now also able to define objects in a clear manner using designated initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, you learned how to write simple code in a declarative style using
    standard ranges, how to write code that can be executed at both compile time and
    runtime using `constexpr`, and how to write more constrained templated code using
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demoed how to write modular code with C++ modules. In the next chapter,
    we'll discuss how to design C++ code so that we can build upon the available idioms
    and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we ensure that each file that our code will open will be closed when
    it's not being used anymore?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use "naked" pointers in C++ code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deduction guide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use `std::optional` and `gsl::not_null`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are range algorithms different than views?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you constrain your type by doing more than just specifying the concept's
    name when you're defining a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is `import X` different than `import <X>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++ Core Guidelines*, the section on *Concepts*: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'libstdc++''s implementation of `std::chrono`: [https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html](https://code.woboq.org/gcc/libstdc++-v3/include/std/chrono.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
