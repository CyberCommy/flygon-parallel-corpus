- en: Deploying Answerly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we learned about Django's testing API and wrote some
    tests for Answerly. As the final step, let's deploy Answerly on an Ubuntu 18.04
    (Bionic Beaver) server using the Apache web server and mod_wsgi.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you have the code on your server under `/answerly`
    and are able to push updates to that code. You will make some changes to your
    code in this chapter. Despite making changes, you will need to avoid developing
    the habit of making direct changes in production. For example, you might be using
    a version control system (such as git) to track changes in your code. Then, you
    can make changes on your local workstation, push them to a remote repository (for
    example, hosted on GitHub or GitLab), and pull them on your server. This code
    is available in version control on GitHub ([https://github.com/tomarayn/Answerly](https://github.com/tomarayn/Answerly)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Organize our configuration code to separate production and development settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare our Ubuntu Linux server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy our project using Apache and mod_wsgi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at how Django lets us deploy our projects as twelve-factor apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by organizing our configuration to separate development and production
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing configuration for production and development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've kept a single `requirements` file and a single `settings.py`.
    This has made development convenient. However, we can't use our development settings
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: The current best practice is to have a separate file for each environment. Each
    environment's file then imports a common file with shared values. We'll use this
    pattern for our requirements and settings files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by splitting up our requirements file.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting our requirements file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create `requirements.common.txt` at the root of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of our environment, these are our common requirements, which we'll
    need to run Answerly. However, this `requirements` file is never used directly.
    Our development and production requirements files will reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s list our development requirements in `requirements.development.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file will install everything from `requirements.common.txt` (thanks
    to `-r`) as well as our testing packages (`coverage`, `factory-boy`, and `selenium`).
    We’re putting these files in our development file because we don't expect to run
    these tests in our production environment. If we were running tests in production,
    then we’d probably move them to `requirements.common.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For production, our `requirements.production.txt` file is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Answerly doesn't need any special packages. However, we will still create one
    for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install packages in production, we now execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's split up the settings file along similar lines.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting our settings file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we will follow the current Django best practice of splitting our settings
    file into three files: `common_settings.py`, `production_settings.py`, and `dev_settings.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating common_settings.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create `common_settings.py` by renaming our current `settings.py` file
    and then making some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let's change the secret key to be obtained from an environment
    variable by updating `SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a new setting, `STATIC_ROOT`. `STATIC_ROOT` is the directory
    where Django will collect all the static files from across our installed apps
    to make it easier to serve them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the database config, we can remove all the credentials and keep the `ENGINE` value
    (to make it clear that we intend to use Postgres everywhere):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a development settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dev_settings.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our development settings will be in `django/config/dev_settings.py`. Let's build
    it incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import everything from `common_settings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll override some settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In development, we always want to run in debug mode. Also, we can feel safe
    hardcoding a secret key, as we know it won''t be used in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since our development database is local, we can hardcode the values in our settings
    to make the settings simpler. If your database is not local, avoid checking passwords
    into version control and use `os.getenv()` like in production.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add more settings that our development-only apps may require. For
    example, in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying
    with Docker*, we had settings for caches and the Django Debug Toolbar app. Answerly
    doesn't use those right now, so we won't include those settings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add production settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating production_settings.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create our production settings in `django/config/production_settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '`production_settings.py` is similar to `dev_settings.py` but often uses `os.getenv()`
    to get values from environment variables. This helps us to keep secrets (for example,
    passwords, API tokens, and so on) out of version control and decouples settings
    from particular servers. We''ll touch on this again in the *Factor 3 – config*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the common settings. Out of an abundance of caution, we ensure
    that the debug mode is off.
  prefs: []
  type: TYPE_NORMAL
- en: Having a `SECRET_KEY` set is vital to our system staying secure. We `assert`
    to prevent Django from starting up without `SECRET_KEY`. The `common_settings.py` file should
    have already set it from an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: A production website will be accessed on a domain other than `localhost`. We
    will tell Django what other domains we're serving by appending the `DJANGO_ALLOWED_HOSTS` environment
    variable to the `ALLOWED_HOSTS` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s update the database configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We updated the database configuration using values from environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our settings sorted, let's prepare our server.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our code is ready to go into production, let's prepare our server.
    In this chapter, we will use Ubuntu 18.04 (Bionic Beaver). If you're running another
    distribution, then some package names may be different, but the steps we'll take
    will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare our server, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required operating system packages
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Elasticsearch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by installing the packages we need.
  prefs: []
  type: TYPE_NORMAL
- en: Installing required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run Answerly on our server, we will need to ensure that the correct software
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a list of packages we will need in `ubuntu/packages.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will install packages for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Full Python 3 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache HTTP Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mod_wsgi, the Apache HTTP module for running Python web apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PostgreSQL database server and client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 8, required for Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the packages, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll install our Python packages to a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now that we have all the packages, we will need to set up Elasticsearch.
    Unfortunately, Ubuntu doesn't ship with a recent version of Elasticsearch, so
    we'll install it directly from Elastic instead.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will get Elasticsearch directly from Elastic. Elastic makes this simple by
    running a server with Ubuntu-compatible `.deb` packages that we can add to our
    server (Elastic also ships and supports RPMs, if that’s more convenient for you).
    Finally, we have to remember to rebind Elasticsearch to localhost or we will have
    an unsecured server running on an open public port.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add Elasticsearch to our list of trusted repositories by running the
    following three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands perform the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Elastic GPG key to the list of trusted GPG keys
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that `apt` gets packages over `HTTPS` by installing the `apt-transport-https`
    package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new sources file that lists the Elastic package server so that `apt` knows
    how to get the Elasticsearch package from Elastic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the list of available packages (which will now include Elasticsearch)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the Elasticsearch available, let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's configure Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Running Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Elasticsearch is configured to bind to a public IP address and includes
    no authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the address Elasticsearch is running on, let''s edit `/etc/elasticsearch/elasticsearch.yml`.
    Find the line with `network.host` and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you don't change the `network.host` setting, then you'll be running Elasticsearch
    with no authentication and on a public IP. Your server getting hacked becomes
    inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to make sure that Ubuntu starts Elasticsearch and keeps it
    running. To accomplish that, we need to tell systemd to start Elasticsearch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands perform the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully reload systemd, which will then become aware of the newly installed Elasticsearch
    service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Elasticsearch service so that it starts when the server boots (in
    case of reboots or shutdown)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start Elasticsearch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you need to stop the Elasticsearch service, you can use `systemctl`: `sudo
    systemctl stop elasticsearch.service`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Elasticsearch running, let’s configure the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has support for migrations but cannot create the database or database
    user by itself. We’ll write a script to do this for us now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the database creation script to our project in `postgres/make_database.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the database, let''s run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands do the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch us to be the `postgres` user, who is trusted to connect to the Postgres
    database without any additional credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set environment variables, describing our new database user and schema. **Remember
    to change the `password` value to a strong password.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `make_database.sh` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our server configured, let's deploy Answerly using Apache and
    mod_wsgi.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Answerly with Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will deploy Answerly using Apache and mod_wsgi. mod_wsgi is an open source
    Apache module that lets Apache host Python programs that implement the **Web Server
    Gateway Interface** (**WSGI**) specification.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache web server is one of the many great options for deploying Django
    projects. Many organizations have an operations team who deploy Apache servers,
    so using Apache can remove some organizational hurdles in using Django for a project.
    Apache (with mod_wsgi) also knows how to run multiple web apps and route requests
    between them, unlike our previous configuration in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, where we needed a reverse proxy (NGINX) and web server
    (uWSGI). The downside of using Apache is that it uses more memory than uWSGI.
    Also, Apache doesn't have a way of passing environment variables to our WSGI process.
    On the whole, deploying with Apache can be a really useful and important tool
    in a Django developer's belt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a virtual host config
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `wsgi.py`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an environment config file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the static files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the virtual host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start creating a virtual host config for our Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the virtual host config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single Apache web server can host many websites using different technologies
    from different locations. To keep each website separate, Apache provides the capacity
    to define a virtual host. Each virtual host is a logically separate site that
    serves one or more domains and ports.
  prefs: []
  type: TYPE_NORMAL
- en: Since Apache has already been a great web server, we will use it to serve our
    static files. The web server serving the static files and our mod_wsgi process
    won't be competing, because they will run as separate processes, thanks to mod_wsgi's
    daemon mode. mod_wsgi daemon mode means that Answerly will run in separate processes
    from the rest of Apache. Apache will still be responsible for starting/stopping
    these processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the Apache virtual host config to our project under `apache/answerly.apache.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the some of these instructions more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<VirtualHost *:80>`: This instructs Apache that everything until the closing
    `</VirtualHost>` tag is part of the virtual host definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WSGIDaemonProcess`: This configures mod_wsgi to run in daemon mode. The daemon
    process will be named `answerly`. The `python-home` option defines the virtual
    environment for the Python process that the daemon will use. The  `python-path` option lets
    us add our modules to the daemon''s python so that they can be imported. The `processes`
    and `threads` options tell Apache how many of each to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WSGIProcessGroup`: This associates this virtual host with the Answerly mod_wsgi
    daemon. Remember that you keep the `WSGIDaemonProcess` name and the `WSGIProcessGroup`
    name the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WSGIScriptAlias`: This describes which requests should be routed to which
    WSGI script. In our case, all requests should go to Answerly''s WSGI script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Directory /answerly/django/config>`: This block gives all users permission
    to access our WSGI script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alias /static/ /answerly/django/static_root`: This routes any request that
    begins with `/static/` not to mod_wsgi but to our static file root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Directory /answerly/django/static_root>`: This block gives users permission
    to access files in `static_root`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ErrorLog` and `CustomLog`: They describe where Apache should send its logs
    for this virtual host. In our case, we want to log it in the Apache `log` directory
    (commonly, `/var/log/apache`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now configured Apache to run Answerly. However, if you compare your
    Apache configuration and your uWSGI configuration from [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, you'll notice a difference. In the uWSGI configuration,
    we provided the environment variables that our `production_settings.py` relies
    on. However, mod_wsgi doesn't offer us such a facility. Instead, we will update
    `django/config/wsgi.py` to provide the environment variables that `production_settings.py`
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Updating wsgi.py to set environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will update `django/config/wsgi.py` to provide the environment variables
    that `production_settings.py` wants but mod_wsgi can't provide. We will also update
    `wsgi.py` to read a configuration file on startup and then set the environment
    variables itself. This way, our production settings aren't coupled to mod_wsgi
    or a config file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/config/wsgi.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the updated `wsgi.py`, we check whether there is a `DJANGO_SETTINGS_MODULE`
    environment variable. If it is absent, we parse our config file and set environment
    variables. Our `for` loop transforms the names of the variables to ensure that
    they are uppercase since `ConfigParser` makes them `lowercase` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create our environment config file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the environment config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll store our environment config under `/etc/answerly/answerly.ini`. We don't
    want it stored under `/answerly` because it's not part of our code. This file
    describes the settings for *just* this server. We should never check this file
    into version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `/etc/answerly/answerly.ini` on our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the two things to remember about this file:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to set `DJANGO_DB_PASSWORD` to the same value you set in when you ran
    the `make_database.sh` script. *Remember to make sure that this password is strong
    and secret*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to set a strong `DJANGO_SECRET_KEY` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should now have our environment set up for Apache. Next, let's migrate the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the database for Answerly in a previous step, but we didn't create
    the tables. Let's now migrate the database using Django's built-in migration tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, we want to execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `django/config/production_settings.py` will require us to provide `DJANGO_SECRET_KEY`
    with a value, but it won't be used in this case. However, providing the correct
    value for `DJANGO_DB_PASSWORD` and the other `DJANGO_DB` variables is critical.
  prefs: []
  type: TYPE_NORMAL
- en: Once our `migrate` command returns successful, then our database will have all
    the tables we need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make our static (JavaScript/CSS/image) files available to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our virtual host config, we configured Apache to serve our static (JS, CSS,
    image, and so on) files. For Apache to serve these files, we need to collect them
    all under one parent directory. Let's use Django's built-in `manage.py collectstatic`
    command to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, let''s run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will copy static files from all our installed apps into
    `/answerly/django/static_root` (per our `STATIC_ROOT` definition in `production_settings.py`).
    Our virtual host config tells Apache to serve these files directly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's tell Apache to start serving Answerly.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Answerly virtual host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have Apache serve Answerly to users, we will need to enable the virtual host
    config we created the preceding section, creating the virtual host config. To
    enable a virtual host in Apache, we will add a soft link point at the virtual
    host config to Apache's `site-enabled` directory and tell Apache to reload its
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add our soft link to the Apache `site-enabled` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We prefix our softlink with `001` to control what our config gets loaded. Apache
    loads site configs by filename in character ordinal order (for example, `B` comes
    before `a` in Unicode/ASCII encoding). The prefix is used to make the order more
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Apache is frequently packaged with a default site. Check out `/etc/apache/sites-enabled/`
    for sites you don't want to run. Since everything in there should be a soft link,
    they should be safe to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the virtual host, we will need to reload Apache''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You've deployed Answerly on your server.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter so far, we've looked at how to deploy Django with Apache and
    mod_wsgi. First, we configured our server by installing packages from Ubuntu and
    Elastic (for Elasticsearch). Then, we configured Apache to run Answerly as a virtual
    host. Our Django code will be executed by mod_wsgi.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've seen two very different deployment, one using Docker and
    one using Apache and mod_wsgi. Despite being very different environments, we've
    followed many similar practices. Let's look at how Django best practices come
    out of the popular twelve-factor app methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Django projects as twelve-factor apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *twelve-factor app* document explains a methodology to develop web apps
    and services. These principles were documented in 2011 by Adam Wiggins and others
    primarily on their experience at Heroku (a popular Platform as a Service, PaaS,
    provider). Heroku was one of the first PaaS that helped developers build easy-to-scale
    web applications and services. Since being posted, the principles of twelve-factor
    apps have shaped a lot of the thinking about how to build and deploy SaaS apps—like
    web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The twelve-factors provide many benefits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easing automation and onboarding using declarative formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasizing portability across deployed environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encouraging production/development environment parity and continuous deployment
    and integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying scaling without requiring re-architecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, when evaluating the twelve factors, it's important to remember that
    they are strongly coupled to Heroku's approach to deployment. Not all platforms
    (or PaaS providers) have exactly the same approach. This doesn't make the twelve
    factors right and other approaches wrong, nor vice versa. Rather the twelve factors
    are useful principles to keep in mind. You should adapt them to help your projects,
    just as you would with any methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'The twelve factor use of the word *app* is different to Django''s usability:'
  prefs: []
  type: TYPE_NORMAL
- en: A Django project is the equivalent of a twelve factor app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Django app is the equivalent of a twelve factor library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will examine what each of the twelve-factors means and how
    they can be applied to your Django projects.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 1 – Code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"One codebase tracked in revision control, many deploys" – [12factor.net](http://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This factor emphasizes the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: All code should be tracked in a version-controlled code repository (repo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each deployment should be able to reference a single version/commit in that
    repo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that when we experience a bug, we know exactly the version of the
    code that is responsible for that. If our project spans multiple repos, the twelve-factor
    approach requires that shared code be refactored into libraries and tracked as
    dependencies (refer to the *Factor 2 – Dependencies* section). If multiple projects
    use the same repository, then they should be refactored into separate repositories
    (sometimes called *multi repo*). Over the years since twelve-factor was first
    published, multirepo versus monorepo (where a single repo is used for multiple
    projects) has become increasingly debated. Some large projects have found benefits
    to using a mono repo. Other projects have found success with multiple repos.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, this factor strives to ensure that we know what is running in
    which environment.
  prefs: []
  type: TYPE_NORMAL
- en: We can write our Django apps in a reusable way so that they can be hosted as
    libraries that are installed with `pip` (multirepo style). Alternatively, you
    can host all your Django projects and apps in the same repo (monorepo) by modifying
    the Python path of your Django project.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 2 – Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Explicitly declare and isolate dependencies" – [12 factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: A twelve-factor app shouldn't assume anything about its environment. The libraries
    and tools a project uses must be declared by the project and installed as part
    of the deployment (refer to *Factor 5 – Build, release, and run* section). All
    running twelve-factor apps should be isolated from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Django projects benefit from Python's rich toolset. “In Python there are two
    separate tools for these steps – Pip is used for declaration and Virtualenv for
    isolation” ([https://12factor.net/dependencies](https://12factor.net/dependencies)). In
    Answerly, we also used a list of Ubuntu packages that we installed with `apt`.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 3 – Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Store config in the environment" – [12factor.net](http://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The twelve-factor app methodology provides a useful definition of a config:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An app''s config is everything that is likely to vary between deploys (staging,
    production, developer environments, etc)" – [https://12factor.net/config](https://12factor.net/config)'
  prefs: []
  type: TYPE_NORMAL
- en: The twelve-factor app methodology also encourages the use of environment variables
    for communicating config values to our code. This means that if there's a problem,
    we can test exactly the code that was deployed (provided by Factor 1) with the
    exact config used. We can also check whether an error is a config issue or a code
    issue by deploying the same code with a different config.
  prefs: []
  type: TYPE_NORMAL
- en: In Django, our config is referenced by our `settings.py` files. In both MyMDB
    and Answerly, we’ve seen common config values such as `SECRET_KEY`, database credentials,
    and API keys (for example, AWS keys) passed by environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an area where Django best practices differ from the strictest
    reading of a twelve-factor app. Django projects generally create a separate settings
    file for staging, production, and local development with most settings hardcoded.
    It's primarily credentials and secrets which are passed as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 4 – Backing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Treat backing services as attached resources" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: A twelve-factor app should not care where a backing service (for example, database)
    is located and should always access it via a URL. The benefit of this is that
    our code is not coupled to a particular environment. This approach also permits
    each piece of our architecture to scale independently.
  prefs: []
  type: TYPE_NORMAL
- en: Answerly, as deployed in this chapter, is located on the same server as its
    database. However, we don't use a local authentication mechanism but instead provide
    Django with a host, port, and credentials. This way, we could move our database
    to another server and no code would have to be changed. We would simply update
    our config.
  prefs: []
  type: TYPE_NORMAL
- en: Django is written with the assumption that we will treat most services as attached
    resources (for example, most database documentation assumes this). We still need
    to practice this principle when working with third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 5 – Build, release, and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Strictly separate build and run stages" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The twelve-factor approach encourages a deployment to be divided into three
    distinct steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: Where the code and dependencies are gathered into a single bundle
    (a *build*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Release**: Where the build is combined with a config and ready for execution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run**: Where the combined build and config are executed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A twelve-factor app further requires each release to have a unique ID so that
    it can be identified.
  prefs: []
  type: TYPE_NORMAL
- en: This level of deployment detail is beyond Django's scope, and there's a variety
    of levels of adherence to this strict three-step model. A project that uses Django
    and Docker, as seen in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*, may adhere to it very closely. MyMDB had a clear build
    with all the dependencies bundled in the Docker image. However, in this chapter,
    we never made a bundled build. Instead, we installed dependencies (running `pip
    install`) after our code was already on our server. Many projects succeed with
    this simple model. However, as the project scales, this may cause complications.
    Answerly's deployment shows how twelve-factor principles may be bent and still
    work for some projects.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 6 – Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Execute the app as one or more stateless processes" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this factor is that app processes should be *stateless*. Each task
    is executed without relying on a previous task having left data behind. Instead,
    state should be stored in backing services (refer to *Factor 4 – Backing services*
    section), such as a database or external cache. This enables an app to scale easily,
    because all processes are equally eligible to process a request.
  prefs: []
  type: TYPE_NORMAL
- en: Django is built around this assumption. Even sessions, where a user's login
    state is stored, isn't saved in a process but in the database by default. Instances
    of view classes are never reused. The only place where Django comes close to violating
    this is one of the cache backends (local memory cache). However, as we discussed,
    that's an inefficient backend. Generally, Django projects use a backing service
    (for example, memcached) for their caches.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 7 – Port binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Export services via port binding" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this factor is that our process should be accessed directly through
    its port. Accessing a project should be a matter of sending a properly formed
    request to `app.example.com:1234`. Further, a twelve-factor app should not be
    run as an Apache module or web server container. If our project needs to parse
    HTTP requests, it should use library (refer to *Factor 2 – Dependencies* section)
    to parse them.
  prefs: []
  type: TYPE_NORMAL
- en: Django follows parts of this principle. Users access a Django project over an
    HTTP port using HTTP. One aspect of Django that diverges from twelve-factors is
    that it's almost always run as a child process of a web server (whether Apache,
    uWSGI, or something else). It’s the web server, not Django, that performs the
    port binding. However, this minor difference has not kept Django projects from
    scaling effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 8 – Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Scale out via the process model" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: The twelve-factor app principles are focused on scaling (a vital concern for
    a PaaS provider like Heroku). In factor 8, we saw how the trade-offs and decisions
    made previously come together to help a project scale.
  prefs: []
  type: TYPE_NORMAL
- en: Since a project runs as a stateless process (refer to *Factor 6 – Processes*
    section) available as a port (refer to *Factor 7 – Port binding* section), concurrency
    is just a matter of having more processes (across one or more machines). The processes
    don't need to care whether they're on the same machine or not since any state
    (like a question's answer) is stored in a backing service (refer to *Factor 4
    – Backing services* section) such as a database. Factor 8 tells us to trust the
    Unix process model for running services instead of daemonizing or creating PID
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Since Django projects run as child processes of a web server, they often adapt
    this principle. Django projects that need to scale often use a combination of
    reverse proxy (for example, Nginx) and lightweight web server (for example, uWSGI
    or Gunicorn). Django projects don't directly concern themselves with how processes
    are managed, but follow the best practice for the web server they’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 9 – Disposability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Maximize robustness with fast startup and graceful shutdown" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: The disposibility factor has two parts. Firstly, a twelve-factor app should
    be able to start processing requests on its port soon after the process starts.
    Remember that all its dependencies (refer to *Factor 2 – Dependencies* section)
    have already been installed (refer to *Factor 5 – Build, release, and run* section).
    A twelve-factor app should handle a process stopping or shutting gracefully. The
    process shouldn't put a twelve-factor app into an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: Django projects are able to shut down gracefully because Django wraps each request
    in an atomic transaction by default. If a Django process (whether managed by uWSGI,
    Apache, or anything else) is stopped while a request is only partially processed,
    the transaction will never be committed. The database will discard the transaction.
    When we're dealing with other backing services (for example, S3 or Elasticsearch)
    that don't support transactions, we have to make sure that we consider this in
    our design.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 10 – Dev/prod parity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Keep development, staging, and production as similar as possible" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: All environments that a twelve-factor app run in should be as similar as possible.
    This is much easier when a twelve-factor app is a simple process (refer to *Factor
    6 – Processes* section). This also includes the backing services the twelve-factor
    app uses (refer to *Factor 4 – Backing services* section). For example, a twelve-factor
    app's development environment should include the same database as the production
    environment. Tools such as Docker and Vagrant can make this much easier to accomplish
    today.
  prefs: []
  type: TYPE_NORMAL
- en: The general Django best practice is to use the same database (and other backing
    services) in development and production. In this book, we've striven to do so.
    However, the Django community often uses the `manage.py runserver` command in
    development, as opposed to running uWSGI or Apache.
  prefs: []
  type: TYPE_NORMAL
- en: Factor 11 – Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Treat logs as event streams" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs should be just output as an unbuffered `stdout` stream, and a *twelve-factor
    app never concerns itself with routing or storage of its output stream* ([https://12factor.net/logs](https://12factor.net/logs)). When
    the process runs, it should just output unbuffered content to `stdout`. Whoever
    starts the process (whether a developer or a production server's init process)
    can then redirect that stream appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: A Django project generally uses Python's logging module. This can support writing
    to a log file or outputting an unbuffered stream. Generally, Django projects append
    to a file. That file may be processed or rotated separately (for example, using
    the `logrotate` utility).
  prefs: []
  type: TYPE_NORMAL
- en: Factor 12 – Admin processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Run admin/management tasks as one-off processes" – [12factor.net](https://12factor.net)'
  prefs: []
  type: TYPE_NORMAL
- en: All projects require a one-off task to be run from time to time (for example,
    database migration). When a twelve-factor app's one-off task is run, it should
    be run as a separate process from the processes that handle regular requests.
    However, the one-off process should run with the same environment as all other
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: In Django that means using the same virtual environment, settings file, and
    environment variables for running our `manage.py` tasks as our normal process.
    This is what we did earlier when we migrated the database.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reviewing all the principles of a twelve-factor app, we will take a look
    at how Django projects are able to follow these principles to help make our project
    easy to deploy, scale, and automate.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a Django project and a strict twelve-factor app
    is that Django apps are run by a web server rather than as separate processes
    (Factor 6). However, as long as we avoid complicated web server configurations
    (as we do in this book), we can continue to gain the benefits of being a twelve-factor
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on deploying Django to a Linux server running Apache
    and mod_wsgi. We've also reviewed the principles of a twelve factor app and how
    a Django app can use them to be easy to deploy, scale, and automate.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've launched Answerly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at creating a mailing list management app called
    MailApe.
  prefs: []
  type: TYPE_NORMAL
