- en: Creating Business Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While examining the logical architecture of `hms_sys` in [Chapter 7](cabfde73-7c51-4741-8832-ca8427793869.xhtml), *Setting
    up Projects and Processes,* a handful of common business object types surfaced
    across the entire scope of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/253f3c63-fe1e-4bb4-80cc-0b2ae4bba3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The objects, as displayed in the preceding diagram, are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Artisan** object represents a single **Artisan**—an end user who creates
    product items to be sold, and who makes those products available to the HMS Central
    Office through the system. **Artisans** are collected in the Central Office's
    data structure, and can be managed to a certain extent by Central Office staff,
    but the majority of their actual data needs to be owned and managed by the individual
    artisans themselves; that way, they have as much control over their information
    as possible, and Central Office staff aren't put in the position of managing data
    changes for artisans if, for example, they change their address, or want to add
    or change a company name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Product** is a representation of a physical object, something that an Artisan
    has created that is for sale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Order** is the result of a customer placing an order for a Product through
    the HMS web store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three object types also infer two others that were not called out earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Customer**, representing an actual customer that placed an **Order**, and
    that can be attached to one or more orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Address**, representing a physical location that something could be shipped
    to or from, which can also be attached to one or more orders, may be a property
    of a **Customer**, and almost certainly will be a property of an **Artisan**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will cover the implementation of those objects as a common class
    library that can be leveraged by the application and service projects' code, including
    the design, implementation, automated testing, and build process that turns it
    into a deployable package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Iteration goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly of stories and tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick review of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the basic business objects in `hms_sys`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the business objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution and installation considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality assurance and acceptance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation/use, maintenance, and decommissioning considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The deliverable for this iteration, then, is a class library that can be installed
    alongside or incorporated with the packages and code of the real projects—the
    user applications and the service—to provide the common representational structure
    of these business objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The `hms_core` package/library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capable of being built as a free standing package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Includes base classes that provide baseline representations of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artisans
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly of stories and tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the components of the business objects package are intended to be consumed
    or used by other packages in the system, most of the relevant stories are still
    focused on providing something that a developer needs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need a common definition and functional structure to represent
    addresses in the system, so that I can incorporate them into the parts of the
    system that need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `BaseAddress` **Abstract Base Class **(**ABC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `BaseAddress` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test the `BaseAddress` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a developer, I need a common definition and functional structure to represent
    artisans in the system, so that I can incorporate them into the parts of the system
    that need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `BaseArtisan` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `BaseArtisan` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test the `BaseArtisan` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a developer, I need a common definition and functional structure to represent
    customers in the system, so that I can incorporate them into the parts of the
    system that need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `BaseCustomer` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `BaseCustomer` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test the `BaseCustomer` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a developer, I need a common definition and functional structure to represent
    orders in the system, so that I can incorporate them into the parts of the system
    that need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `BaseOrder` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `BaseOrder` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test the `BaseOrder`  ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a developer, I need a common definition and functional structure to represent
    products in the system, so that I can incorporate them into the parts of the system
    that need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `BaseProduct` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `BaseProduct` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test the `BaseProduct` ABC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an **Artisan**, I need the business objects library to be installed with
    my application so that the application will work as needed without me having to
    install dependent components for it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine whether `setup.py` based packaging can include packages from outside
    the local project structure, and implement it if it can
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, implement `Makefile` based processes for including `hms_core` in
    the other projects' packaging processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the **Artisan** packaging/installation process will also work for
    Central Office installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a system administrator, I need the business objects library to be installed
    with the **Artisan** gateway service so that it will work as needed without me
    having to install dependent components of it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the **Artisan** packaging/installation process will also work for
    **Artisan** gateway installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth noting that while this design starts by defining a lot of abstract
    classes, that is not the only way it could have gone. Another viable option would
    have been to start with simple Concrete Classes in each of the other libraries,
    then extract the common requirements across those, and create ABCs to enforce
    those requirements. That approach would yield concrete functionality sooner, while
    relegating structural and data standards to later, and requiring the movement
    of a fair chunk of code from the Concrete Classes back down to the ABCs, but it's
    still a viable option.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class, in any object-oriented language, can be thought of as a blueprint for
    creating objects—defining what those objects, as instances of the class, are,
    have, and can do. Classes frequently represent real world objects, be they people,
    places, or things, but even when they don't, they provide a concise set of data
    and capabilities/functionality that fits into a logical conceptual unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As `hms_sys` development progresses, there will be several classes, both concrete
    and abstract, that will be designed and implemented. In most cases, the design
    will start with a class diagram—a drawing of one-to-many classes that shows the
    structure of each and any relationship between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8a4d1e52-b870-4add-bea0-2cba58b74892.png)'
  prefs: []
  type: TYPE_IMG
- en: A **Concrete Class** is intended to be instantiated, to have object instances
    created from the blueprint it provides. An **Abstract Class** provides baseline
    functionality, interface requirements, and type identity for objects that have
    specific **Class Members** (concrete or abstract) that will be inherited by, or
    that require implementation in, classes that derive from them. The scope of those
    members, both **Properties** and **Methods**, are indicated by **+** for public
    members, **-** for private members, and **#** for protected members by convention,
    though as already noted, Python doesn't have truly protected or private members.
    Still, those at least provide some indication of what the intended scope of a
    member is.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the basic business objects in hms_sys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in the development process, we simply don't know whether the exact
    same functionality for all of the business object classes will be in play in the
    two applications and the service that are going to be built. The data ownership
    rules—determination of what users can create, update, or delete what data inside
    an object—haven't been detailed enough to make those decisions yet. We do, however,
    have enough information, based solely on the purposes of those objects, to start
    defining what data they represent, and what constraints should exist around those
    data points.
  prefs: []
  type: TYPE_NORMAL
- en: We may have enough information here and now to know that certain functionalities
    need to exist for some of these object types as well—that **Artisan** objects
    need the ability to add and remove related **Product** objects, for example—even
    if we don't know yet how that's going to work, or whether there are data ownership
    rules around those. We can also make some educated guesses around which classes
    will need to be abstract (because their actual implementations will vary between
    the applications and the service).
  prefs: []
  type: TYPE_NORMAL
- en: Address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Address` class represents a physical location—a place that something could
    be mailed or shipped to, or that could be found on a map. The properties of an
    address are going to be consistent no matter what context the objects are encountered
    in—that is, an address is an address whether it's associated with an **Artisan**,
    a **Customer**, or an **Order**—and it feels safe to assume at this point that
    the whole of any address can be altered by an object that it is a member of, or
    none of it can be. At this point, barring information to the contrary, it doesn't
    feel like storing addresses as separate items in the backend data structure will
    be necessary; although it's possible that they'll have a meaningful independent
    existence of their own, there's no reason to assume that they will.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, making addresses an abstract class doesn''t feel like it''s
    necessary, at least not yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7887406d-de5a-4e06-9e15-6d0b50c80f46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An **Address** is a dumb data object, at least so far; it consists of a data
    structure, but has no methods or functionality. The properties of the class themselves
    are fairly simple, and have a few rules around them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`street_address` is the street address of the location. It should be a single
    line string value, is required (cannot be empty), and should probably not allow
    any whitespace characters other than spaces. An example value of `street_address`
    would be `1234 Main Street`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`building_address` is an optional second line of the address, used to indicate
    more detail about where at the street address the actual location is. Examples
    might include an apartment number, a suite or office location or number, and so
    on. If it''s present in any given address, it should be a string value with the
    same constraints as `street_address`, but, again, it''s an optional value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city` is a required string value, also restricted to a single line, and the
    same whitespace rules as `street_address`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`region` is an optional string value, with the same constraints, as are `postal_code`
    and `country`, at least for the time being.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These last three properties are difficult to generate rules around without some
    sort of country specific context. It's possible, though it seems unlikely, for
    addresses in some countries to not have regions or postal codes, while in other
    countries, they have completely different names and data requirements. By way
    of example, consider that in the United States, region and `postal_code` represent
    the **State** and **ZIP** **Code** (five numbers, with an optional dash and four
    more numbers), while in Canada they would represent a territory or province and
    a postal code that is alphanumeric. There may be a solution for some aspects of
    the requirements on a country by country basis, and that will be examined after
    the initial property definitions are taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial implementation of `Address` is pretty straightforward; we start
    by defining a class with the properties that will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of those `property` calls specify a getter, setter, and deleter method
    that then have to be implemented. The getter methods are all very simple, each
    returning the associated property value that stores the instance''s data for that
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter methods are also relatively simple, though there''s logic that has
    to be implemented in order to enforce the type and value rules noted earlier.
    The properties of Address, so far, fall into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Required, non-empty, single line strings (such as `street_address`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional (`None`) or non-empty, single line string values (`building_address`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation for the required values will all follow the same pattern,
    using `street_address` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter method process, then, from start to finish, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the `value` submitted is a `str` type, and raises a `TypeError`
    if that's not the case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list of forbidden characters—newline, carriage return, and tab, (`'\n'`,
    `'\r'`, `'\t'`)—that shouldn't be allowed in the value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume that the value is valid until otherwise determined (`is_valid = True`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the existence of each of those bad characters in the value, and if
    they are present, flags the value as invalid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check to see if the value is only whitespace (`value.strip()`) or if any invalid
    characters were found, and if so, raises a `ValueError`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no errors were raised, set the internal storage attribute for the property
    to the now verified value (`self._street_address = value`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This same code, with `street_address` changed to `city`, takes care of the city
    property's setter implementation. This property setter process/flow is going to
    come up repeatedly, in this iteration and iterations that follow. When it's in
    use from this point on, it'll be referred to as a standard required text line
    property setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional properties use a very similar structure, but check for (and allow)
    a `None` value first, since setting their values to `None` is technically valid/allowed.
    The `building_address` property setter serves as an example of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This setter method process, like the standard required text line property before
    it, will appear with some frequency, and will be referred to as a standard optional
    text line property setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deleter methods are also going to be quite simple—all of these properties,
    if deleted, can be set to a value of `None` so that they still have a value (thus
    avoiding instances of  `AttributeError` if they are referenced elsewhere), but
    one that can be used to indicate that there isn''t a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the property definitions and their underlying methods defined, all that
    remains to make the class usable is the definition of its `__init__` method, so
    that creation of an `Address` instance can actually accept and store the relevant
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s tempting to just stick to a simple structure, with the various address
    elements accepted and required in the order that they''d be normally be used in,
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach, equally valid, would be to allow default values for the arguments
    that would translate to the optional properties of the instance created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both approaches are perfectly valid from a functional standpoint—it would be
    possible to create an `Address` instance using either—but the first is probably
    going to be more easily understood, while the second would allow the creation
    of a minimal instance without having to worry about specifying every argument
    value every time. Making a decision about which argument structure to use should
    probably involve some serious thought about a variety of factors, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: Who will be creating new `Address` instances?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do those `Address` creation processes look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and where will new `Address` instances be needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will they be created? That is, will there be some sort of UI around the
    process with any consistency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The who question has a very simple answer, and one that mostly answers the other
    questions as well: pretty much any user may need to be able to create a new address.
    Central Office staff probably will in the process of setting up new **Artisan**
    accounts. **Artisans** may occasionally need to if they need to change their address.
    **Customers**, though only indirectly, will need to when they place their first
    order, and may well need to create addresses for shipping separate from their
    own default/billing addresses. Even the **Artisan** gateway service will probably
    need to create `Address` instances as part of the processes for handling movement
    of data back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most of those cases, though, there will be some sort of UI involved: a web
    store form for the **Customer** and **Order **related items, and whatever GUI
    is in place in the **Artisan** and Central Office applications. With a UI sitting
    on top of the address creation process, the onus for passing arguments from that
    UI to `__init__` would only be of importance or concern to the developer. So those
    questions, though they shed some light on what the functional needs are, really
    don''t help much in making a choice between the two argument form possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, there''s no reason that the `__init__` can''t be defined one way,
    and another method created for Address to allow the other structure, a `standard_address`,
    perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That then allows `__init__` to use the structure that leverages the various
    default argument values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That makes `Address` functionally complete, at least for the purposes of the
    story concerning it in this iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As any class is undergoing development, it''s quite possible that questions
    will arise around use cases that the developer envisions, or that simply occur
    while considering some aspect of how the class works. Some examples that surfaced
    while `Address` was being fleshed out are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What can/should happen if a non-default property value is deleted in an instance?
    If a required value is deleted, the instance is no longer well formed and is technically
    invalid as a result—should it even be possible to perform such a deletion?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a Python module, `pycountry`, that gathers up ISO derived country and
    region information. Would it be desirable to try to leverage that data in order
    to ensure that country/region combinations are realistic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will `Address` eventually need any sort of output capabilities? Label text,
    for example? Or maybe the ability to generate a row in a CSV file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such questions are probably worth saving somewhere, even if they never become
    relevant. If there isn''t some sort of project system repository for such things,
    or some process in place in the development team for preserving them so they don''t
    get lost, they can always be added to the code itself as some kind of comment,
    perhaps like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: BaseArtisan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Artisan` class represents an artisan who participates in the Hand Made
    Stuff marketplace—a person who creates products that are available to be sold
    through the Central Office's web store. Knowing that there will almost certainly
    be different functional rules for each different user's interaction with a final
    `Artisan` class, it makes sense to make an abstract class in the `hms_core` code
    base that defines the common functionality and requirements for any concrete `Artisan`
    in the other packages. We'll name that class `BaseArtisan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `Address` class we just completed, the design and implementation of
    `BaseArtisan` starts with a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a445950-577b-44bb-9176-75d7383ad17d.png)'
  prefs: []
  type: TYPE_IMG
- en: It's not unusual for abstract classes to have a naming convention that indicates
    that they are abstract. In this case, the prefix of Base is that indicator, and
    will be used for other abstract classes as development progresses.
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseArtisan` is intended to provide a common set of state data rules and functionality
    for all of the properties associated with any **Artisan** in any part of the system.
    The properties themselves, then, will be concrete implementations. `BaseArtisan`
    is also intended to provide some (minimal) functional requirements, in the form
    of the `add_product` and `remove_product` methods. It''s a given, since artisans
    and products relate to each other, that a concrete `Artisan` object will need
    to be able to add and remove `Product` objects, but the specifics about how those
    processes work may well vary between the two applications and the services that
    are making use of that functionality, so they will be abstract—required to be
    overridden/implemented in any class that derives from `BaseArtisan`.'
  prefs: []
  type: TYPE_NORMAL
- en: This class diagram also includes the `Address` class that was created earlier,
    with a diamond ended connector between the two classes. That connection indicates
    that the `Address` class is used as an aggregated property of `BaseArtisan`—that
    is, that the address property of `BaseArtisan` is an instance of `Address`. That
    is also indicated in the address property itself, with an `<Address>` specified
    as the type of the address property. In simple terms, a `BaseArtisan` has an `Address`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be possible to define `BaseArtisan` as inheriting from `Address`.
    The class diagram for that relationship would be almost identical, except for
    the connector, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74358f19-2088-48eb-8097-1f0d77f8e0b8.png)'
  prefs: []
  type: TYPE_IMG
- en: In this relationship, a `BaseArtisan` is an `Address`—it would have all of the
    properties of an `Address`, as well as any method members that might be added
    down the line. Both of these relationships are perfectly legal, but there are
    advantages to using the aggregation (or composition) approach over relying on
    inheritance that are worth noting before moving on to the implementation of `BaseArtisan`.
  prefs: []
  type: TYPE_NORMAL
- en: OO principles – composition over inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's probable that the most obvious of those advantages is that the structure
    is easily understood. An `Artisan` instance will have an address property that
    is another object, and that object has its own relevant properties. At the `Artisan`
    level, where there is only one address of any importance, that might not seem
    significant. Other objects, however, such as `Customer` and `Order`, might have
    more than one associated address (billing and shipping addresses, for example),
    or even several: `Customer` might have several shipping addresses that need to
    be held on to and available.
  prefs: []
  type: TYPE_NORMAL
- en: As a system's object library becomes larger and more complex, using a purely
    inheritance based design approach will inevitably result in large trees of classes,
    many of which may do nothing more than provide functionality solely for the purpose
    of being inherited. A composition based design will reduce that complexity, probably
    significantly more so in larger and more complex libraries, since the functionality
    will be encapsulated in single classes, instances of which become properties themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of composition does have some potential drawbacks too, though: deeply
    nested objects, properties of properties of properties *ad nauseam*, can result
    in long chains of data structure. For example, if an `order` in the context of
    `hms_sys` has a `customer` that in turn has a `shipping_address`, finding the
    `postal_code` of that address from the **Order** would look something like `order.customer.shipping_address.postal_code`.
    That''s not a terribly deep or complex path to get the data involved, and because
    the property names are easily understood it''s not difficult to understand the
    entire path. At the same time, it''s not hard to imagine this sort of nesting
    getting out of control, or relying on names that aren''t as easily understood.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible (perhaps likely) that a need will arise for a class to provide
    a local implementation of some composed property class methods, which adds to
    the complexity of the parent object's class. By way of example, assume that the
    address class of the `shipping_address` just mentioned has a method that checks
    various shipping APIs and returns a list of them sorted from lowest to highest
    cost—call it `find_best_shipping`. If there is a requirement that the `order`
    objects be able to use that functionality, that will probably end up with a `find_best_shipping`
    method being defined at the order class level that calls the address-level method
    and returns the relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of those are significant drawbacks, however. Provided that there is
    some discipline exercised in making sure that the design is logical and easily
    understood, with meaningful member names, they will probably be no worse than
    tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a more pure, object oriented standpoint, a more significant concern is
    the diamond problem. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Diagrammed, these classes form a diamond shape, hence the diamond problem''s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d7e7c53-3fd0-4fde-a5d8-0ba31e420401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happens upon the execution of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Which method will be called? Unless the language itself defines how to resolve
    the ambiguity, the only thing that is probably safe to assume is that the method
    of `Root` will not be called, since both the `Left` and `Right` classes override
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python resolves ambiguities of this nature by using the order of inheritance
    specified in the class'' definition as a **Method Resolution Order** (**MRO**).
    In this case, because `Bottom` is defined as inheriting from `Left` and `Right`—`class
    Bottom(Left, Right)`—that is the order that will be used to determine which `method`
    of the several available will actually be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although it seems unlikely that any of the installable `hms_sys` components
    will ever reach a level of complexity where inheritance issues would be a significant
    concern, there is no guarantee that it will never happen. Given that, and that
    a refactoring effort to move from an inheritance based to a composition based
    structure would probably be both painful and prone to introducing breaking changes,
    a composition based approach, even with some of the drawbacks inherent to it,
    feels like a better design even at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing BaseArtisan's properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to represent an **Artisan** as a person (who may also have a company
    name), with a location and products, `BaseArtisan` provides six property members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contact_name` is the name of the contact person for an **Artisan**. It should
    be a standard required text line property, as defined earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact_email` is the email address of the person named in `contact_name`.
    It should be a well formed email address, and will be required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company_name` is a standard optional text line property (optional because
    not all **artisans** will have a company name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address` will be required, and will be an instance of `Address`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`website` is an optional web site address for the **Artisan**. If it''s present,
    it will need to be a well formed URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`products` will be a collection of `BaseProduct` objects, in much the same
    way that `address` is a single `Address` instance. Some implementation details
    around product will be deferred until `BaseProduct` is fully defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As before, the process starts with creating the class, and defining the properties
    whose implementations will be fleshed out next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The inclusion of `metaclass=abc.ABCMeta` defines `BaseArtisan` as an Abstract
    Base Class, using the `abc` module''s `ABCMeta` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since `company_name` and `contact_name` are standard optional and required text
    line implementations, as were described in creating the `Address` class, their
    implementations will follow the pattern established there, and will not be examined
    in any detail. The processes for both are identical to those for `Address.building_address`
    and `Address.street_address`, respectively—the only things that will change are
    the names of the getter, setter, and deleter methods and the state data attributes
    that store the properties' values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `_get_` and `_del_` methods that are associated with all of
    the properties except for products will follow the same basic patterns that''ve
    been established already:'
  prefs: []
  type: TYPE_NORMAL
- en: Getter methods will simply return the value stored in the corresponding state
    storage attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleter methods will set the value of the corresponding state storage attribute
    to `None`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The getter and deleter method implementations for `address`, `company_name`,
    and `contact_email`, for example, can be the exact same process as previously
    shown, even though `address` is not a simple value property and `contact_email`
    hasn''t been implemented yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This probably feels like a lot of boilerplate, copy and paste code, but that's
    the cost of being able to perform the type and value checking that's handled by
    the setter methods. The setter methods themselves are where the magic happens
    that keeps the high degree of data type and integrity that's desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setter for the `address` property is perhaps surprisingly simple, since
    all that really needs to be enforced is that any value passed to it must be an
    instance of the `Address` class. There is no value checking, since any `Address`
    instance that was successfully created will have performed its own type and value
    checks as part of the initialization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `contact_email` setter could work much like the standard required text line
    setter process defined in `Address._set_street_address`. It has some of the same
    data rules associated, after all—it's a required value, cannot be empty, and since
    it's an email address, it can't be multi-line or have tabs. Since it's an email
    address, though, it also cannot have spaces in it, and there are other character
    restrictions that are common to all email addresses that aren't accounted for
    in that original structure. Since the requirements for the property include it
    being a well formed email address, there may be other, better ways to validate
    a value passed to the setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, an application will want to assure that an email address is both well
    formed and valid. There''s really only one way to do either, though, and it''s
    out of scope for `hms_sys`, even if it makes sense to try and implement it: send
    a confirmation email, and don''t store the value until/unless a confirmation response
    is received.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of approaches that will get us most of the way to the validation
    of a well formed email address. The one that is probably the best place to start
    is to use a regular expression to match against the value, or to remove everything
    that is a well formed email address and not allow the value to be set unless there's
    nothing left after that replacement executes. Using a regular expression probably
    won't guarantee that the value is well formed, though it will catch a lot of invalid
    values. Combining that with some standard Python functionality found in the `email.utils`
    module should at least get the code to a point where testing can be built to look
    for well formed addresses that fail, and allow modification of the check process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import some items, namely the `parseaddr` function from `email.utils`
    and the `re` module, in order to create the regular expression object we''ll use
    to test with. Those imports should happen at the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a module level constant regular expression object that
    will be used to check email address values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will match whole strings that start with one or more characters *A* through
    *Z* (upper or lower case), any digit 0-9, or an underscore, period, plus, or dash,
    followed by `@`, then most domain names. This structure was found on the internet
    with a quick search, and may not be complete, but it looks like it should work
    for most email addresses as it is. All the setter method implementation needs
    to do now is check that the value is a string, parse a recognizable address out
    of the string, check the parsed value, and if everything checks out, set the value
    of the data storage attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar approach should be a good starting point for the website setter method,
    using the following as the regular expression to test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts with the same optional value check that was established in `Address._set_building_address`,
    but uses the `URL_CHECK` regular expression object to check the value passed in
    much the same way that `_set_contact_email` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That leaves just one property to implement: `products`. The products property
    has aspects to it that may not be apparent at first, but that have potentially
    significant implications on how it should be implemented. First and foremost,
    it''s a collection of other objects—whether that''s a list, a dictionary, or something
    else hasn''t yet been decided—but in any event it''s not a single object the way
    that `address` is. Additionally, it was defined as being a read-only property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Only the getter method is provided in the `property` definition. This is intentional,
    but requires some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since products is intended to deal with a collection of product objects, it''s
    pretty important that the `products` property itself cannot be changed to something
    else. For example, if products were settable, it would be possible to execute
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's certainly possible to put type and value checking code in place to
    prevent that sort of assignment—and although there isn't a setter method associated
    with the property itself, we'll almost certainly want to have one available later
    on, and it should implement that type and value checking anyway. However, its
    use will probably be limited to populating an instance's products during the creation
    of the artisan instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other potential concern is that it would be possible to alter the collection''s
    membership in ways that are both bug prone and difficult to regulate. For example,
    using the same `artisan` instance, and assuming that the underlying data storage
    for products is a list, there is nothing to stop code from doing any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, allowing arbitrary deletion of an artisan's products (`del artisan.products`)
    is probably not a great idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a minimum, then, we want to assure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulation of the membership of `products` is either not allowed or cannot
    affect the real, underlying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to (and perhaps manipulation of) individual `products` members' members
    is still allowed, that is, given a list of product instances, reading data from
    and writing data to them is not constrained by the collection they live in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a couple of options, even without developing some sort of custom
    collection type. Since the `products` property uses a getter method to fetch and
    return the values, it would be possible to alter the data being returned in order
    to either:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a direct copy of the actual data, in which case altering the membership
    of the returned collection wouldn't touch the original collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a copy of the data in a different collection type; if the real data is
    stored in a list, for example, returning a tuple of that list would provide all
    of the same iterable sequence capabilities as the original list, but would not
    allow alteration of the membership of that copy itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python keeps track of objects by object reference—that is, it pays attention
    to where in memory an object actually lives, by association with the name assigned
    to the object—so when a list or tuple of objects is created from an already existing
    list of objects, the members of the new collection are the same objects as were
    present in the original list, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a copy of the original list will create a new and distinct collection
    that will still have the same members in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, too will creating a tuple in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning either a new list or a tuple created from the original state data
    value would, then, take care of preventing changes made against the property value
    from affecting the real underlying data. For now the tuple returning option feels
    like the better choice, since it''s more restrictive, in which case `_get_products`
    will be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The deleter method `_del_products` cannot use `None` as a default with the
    getter that''s now in place. It will have to be changed to something else since
    trying to return a `tuple` of a `None` default value would raise an error. For
    now, the deleted value will be changed to an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is the setter method, `_set_products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Taken together, these variations restrict changes to the products property
    pretty significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: The property itself is read-only, not allowing the value to be set or deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value returned from the getter method is identical to, but distinct from,
    the one that's actually stored in the state data of the object it's being gotten
    from, and while it still allows access to the members of the original collection,
    it does not allow the original collection's membership to be altered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setter method enforces type checking for the entire collection, assuring
    that the membership of the collection is composed only of the appropriate object
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What isn't accounted for yet are actual processes for making changes to the
    collection's members—that capability is in the method members.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing BaseArtisan's methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BaseArtisan`, as it''s currently designed, is expected to provide two abstract
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_product`, which requires a mechanism for adding `products` to the products
    collection of an instance to be implemented on derived Concrete Classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_product`, which similarly requires a mechanism for removing an item
    from the `products` collection of a derived instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are specified as abstract methods because, while there will almost certainly
    be some common functionality involved with each of them across the application
    and service installables of `hms_sys`, there will also almost certainly be significant
    implementation differences across those same components—artisans, for example,
    may well be the only users who can truly remove items from their `products` collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, in most programming languages that support defining abstract methods,
    those methods are not expected to provide any actual implementation. It''s quite
    possible, in fact, that the act of defining a method as abstract actually prohibits
    any implementation. Python does not enforce that restriction on abstract methods,
    but still doesn''t expect any implementation either. As a result, our abstract
    methods do not need to be any more complicated than this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re allowed to put concrete implementation into an abstract method,
    though, it''s possible to leverage that to provide baseline functionality in cases
    where there is some that''s useful to keep in one place. These two methods, `add_product`
    and `remove_product`, fall into that category:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a product will always need to perform type checking, raise errors when
    invalid types are presented, and append the new item to the instance's collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a product will always involve removing the specified product from the
    instance's product collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With those factors in mind, it can actually be beneficial to put those common
    processes into the abstract method as if they were concrete implementations. Those
    processes can then be called from derived class instances, with or without additional
    logic before or after the execution of the baselines themselves. Consider a basic
    implementation of `add_product` in `BaseArtisan` that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A derived class—an `Artisan` class that lives in the Central Office''s application,
    for example—would be required to implement `add_product`, but could implement
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is a trade off to this approach, though: it would be possible for a derived
    class to implement a completely new `add_product` process, skipping the ready-made
    validation/business rules. An alternative approach would be to define an abstract
    validation method (`_check_products`, maybe) that handles the validation process
    and is called directly by a concrete implementation of `add_product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove_product` method can be similarly defined, and could be implemented
    in a similar fashion in derived class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be other methods that would make sense to add to `BaseArtisan`, but
    if there are, they will probably surface as the implementations of concrete `Artisan`
    classes are developed. For now, we can call `BaseArtisan` done, after defining
    its `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: BaseCustomer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class that defines what a customer''s data structure looks like is very
    simple, and uses code structures that have already been established in `Address`
    and `BaseArtisan` for all of its properties. Like the relationship of `BaseArtisan` with
    concrete `Artisan` instances, `Customer` objects are expected to vary significantly
    in what they can do, and perhaps what data access is allowed across the different
    components of the system. Once again, we''ll start by defining an ABC—`BaseCustomer`—rather
    than a concrete `Customer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d1ea61e-9206-4487-bb53-828c74428616.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The properties of `BaseCustomer` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`, a standard required text line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`billing_address` and `shipping_address`, which are, apart from their names,
    identical to the address property defined in `BaseArtisan`. The `shipping_address`
    will be made optional, since it''s quite possible for a customer to have only
    one address that''s used for both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only new aspect of `BaseCustomer` that feels worth mentioning is how the
    `shipping_address` is annotated during initialization. `BaseCustomer.__init__`
    is mostly going to follow the same structure/approach that''s been shown in previous
    class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shipping_address` argument''s annotation, `(Address,None)`, is new, after
    a fashion. We''ve used built in types as annotation types before, as well as having
    a built in, non-`None` type and `None` for optional argument specifications before.
    `Address.__init__` uses this notation several times. This code, even though it
    uses a class that we have defined, works the same way: the `Address` class is
    also a type, just like `str` is in previous examples. It''s just a type that has
    been defined here in this project.'
  prefs: []
  type: TYPE_NORMAL
- en: BaseOrder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating pretty much any dumb data object class, or even mostly
    dumb ones, is very similar no matter what those classes represent, at least so
    long as whatever data structure rules are in play hold true across the entire
    scope of those efforts. As more such data oriented classes are created, fewer
    new approaches to specific needs will be needed until eventually there will be
    a concise set of approaches for implementing various properties of all the various
    types and value constraints needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BaseOrder` class, shown here with `BaseProduct`, is a good example of
    that effect, at least at first glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f92b29d-afdd-4bcd-9188-fcd993c7ae6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The list of `BaseOrder` properties is very short, since all an order really
    represents is a customer relationship with a collection of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '`customer` is an instance of `BaseCustomer`, which in turn has the `billing_address`
    and `shipping_address` properties of that **customer**;apart from the fact that
    the type of the property''s value is going to be a `BaseCustomer` instance, it''s
    reasonable to assume that it''ll behave in the same way that the `Address` type
    properties of `BaseCustomer` do'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`products` is a collection of `BaseProduct` instances that can probably behave
    exactly like the `products` property of `BaseArtisan`—it''ll be doing the same
    sort of thing, after all, storing product instances and preventing mutation of
    those instances—so the initial implementation of it will be copied directly from
    `BaseArtisan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, both properties, barring some changing of names in the case of the
    **customer** property, already have established implementation patterns, so there's
    nothing substantially new to show in `BaseOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying code directly from one class to another is a contentious topic at times;
    even if everything works perfectly, it is, by definition, duplicating code, which
    means that there are now multiple copies of that code to be maintained if something
    goes awry later on.
  prefs: []
  type: TYPE_NORMAL
- en: BaseProduct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BaseProduct` ABC also has a lot of near boilerplate property code, though
    only three of its properties fall into implementation patterns that''ve been established
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is a standard required text line property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`summary` is a standard required text line property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` is an optional string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimensions` is a standard optional text line property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shipping_weight` is a required number value, which may only be used for determining
    shipping costs, but could also appear in product displays in the web store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata` is a dictionary of metadata keys (strings) and values (strings also,
    probably). This is a new data structure, so we''ll examine it in detail shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`available` is a required Boolean value that allows the artisan to indicate
    that the product is available to be sold on the HMS web store, though it may be
    visible to central office staff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store_available` is also a required Boolean value, indicating that the HMS
    web store should consider the **product** available. It is intended to be controlled
    by the Central Office staff, though it may be visible to an artisan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseProduct` has only two methods associated so far, both for use in managing
    the metadata values associated with a product instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_metadata` will set a metadata key/value on the instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_metadata` will remove a metadata key and value from the instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `name`, `summary`, and `dimensions` properties, as standard required and
    optional text lines, will follow those patterns. The `description` is almost an
    optional text line implementation; all that needs to be changed there is removing
    the whitespace character checks, and it''s good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `shipping_weight` property varies most significantly
    in the setter method `_set_shipping_weight`, but is (hopefully) about what would
    be expected given the normal getter/setter/deleter method structure that is the
    typical approach for properties in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be said for the implementation of both of the `available` properties,
    though it makes sense to allow both formal Boolean (`True` and `False`) values
    and integer value equivalents (`1` and `0`) as valid setter value arguments. This
    gives a bit of wiggle room in cases where the object''s state data may not be
    able to be stored as true Booleans—though that is an unlikely circumstance, it''s
    not out of the realm of possibility, either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That leaves only the `metadata` property implementation. Metadata is probably
    best thought of as data about other data—in this case, data about the products
    that the class is fundamental to representing. In this particular case, the `metadata`
    property is intended to provide highly flexible data that may vary wildly from
    one product (or product type) to another, while still being available in a relatively
    simple manner within a more rigidly defined class/object structure. This will
    be important in the context of Hand Made Stuff's needs because the products that
    artisans create and sell through their web store can be virtually anything: beads,
    wood, or metal furniture, clothing, jewelry, whatever. Though there are a few
    descriptions that could potentially be applied to any product—what it's made out
    of, for example, and perhaps some basic items such as color—there are others that
    make it nearly impossible to categorize products across the entire spectrum available
    without either requiring a lot more data structures in the current product class
    structure, or a lot of product types that live in what would almost certainly
    be a prohibitively complex relationship with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The initial implementation and design will center, then, around maintaining
    a `dict` based metadata structure with each object. If more stringent requirements
    arise later (such as requiring that items made of wood must specify the type of
    wood, for example), a refactoring effort to adjust accordingly may be necessary,
    but for now a simple `dict` feels reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Like the products property of `BaseArtisan` and `BaseOrder`, the `metadata` 
    of a `BaseProduct` needs to be difficult to casually or accidentally change—it
    should require something of a conscious decision to make changes. Given that the
    `metadata` structure is expected to provide data with which to categorize products,
    the keys, at the very least, will have some restrictions around what can be used.
    Metadata names should be meaningful and reasonably short. So, too should `metadata`
    values, though they will probably be less constrained than their corresponding
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking all of these items together, the getter and deleter methods are not
    significantly different from their equivalents for the other properties—the usual
    name changes and a different deleted default value are about all there is to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The setter method is, as is most often the case, where the significant differences
    are; in this case, when it's called, the expectation is that the intention is
    to clear out any existing metadata and replace it with a new, validated set of
    keys and values. This changes the entire collection in the property, not just
    some or all of its members. Since the class will also be providing a dedicated
    method to allow the addition of new `metadata`, or changes to existing items in
    the `metadata`, and that method will need to perform whatever validation is desired
    against both keys and values, the `_set_metadata` property setter method will
    use the similarly named `set_metadata` method to assure that all metadata meets
    the same standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make sure that the incoming value is a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set up a variable to keep track of any invalid values encountered, and
    clear the current metadata out with the same mechanism that''s used to clear it
    out during initialization, `_del_metadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With those accomplished, we can iterate across the value''s keys and values,
    calling `set_metadata` for each pair until they''ve all been accounted for, and
    trapping any errors raised in order to provide more useful error messaging when
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If any bad values were detected, then we''ll want to raise an error and note
    them. If no errors occur, then the property''s been repopulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_metadata` method looks a lot like our varied property setter methods—keys
    and (for now) values in metadata both act like standard required text line properties—so
    the type and value checking being performed for each will look very familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the type and value checking for the `key` argument''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the type and value checking for the `value` argument''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The removal of `metadata` requires considerably shorter and simpler code, though
    it also assumes that if an attempt is made to remove metadata that doesn''t exist,
    no error need be raised. There might be a need to allow such an error to occur,
    but for now the assumption is that it won''t be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With `BaseProduct` complete, the required scope of the `hms_core` class library
    is fulfilled. Unit testing still needs to be written, and any issues that surface
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with duplicated code – HasProducts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BaseArtisan` and `BaseOrder` have `products` properties that behave the same
    way, to the extent that the original implementation of those properties involved
    essentially copying and pasting the code from one into the other. While that''s
    probably not such a big deal in this particular case (since the `hms_core` class
    library is small, with few members, and there are only two places where that duplicate
    code would have to be maintained), in larger libraries, or if there was a lot
    of duplication of that code, it could become very problematic very quickly. Since
    Python allows classes to inherit from multiple parent classes, we can leverage
    that capability to define a new ABC—`HasProducts`—that will keep all of the product
    property related code in one place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e29b2099-a83d-4ea8-aaea-ea553f4752fc.png)'
  prefs: []
  type: TYPE_IMG
- en: This approach is a variation of an object oriented principle that's usually
    referred to as a mixin—a class that contains concrete implementations of functionality
    for use in other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `HasProducts` is, essentially, just a collection or repackaging
    of the product properties code of `BaseArtisan` and `BaseOrder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter, setter, and deleter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `products` property definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Object initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract methods for adding and removing products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `HasProducts` in `BaseArtisan` and `BaseOrder` is not difficult, though
    it involves refactoring them to remove code that is already in place that will
    override the common code in `HasProducts`. It starts with making sure that the
    class using `HasProducts` inherits from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__` method of the derived class has to be altered to call the `__init__`
    of `HasProducts` as well, in order to assure that it performs all the relevant
    initialization tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The processes of setting default values and instance values for the new class
    no longer have to worry about handling the `products` property setup, since that''s
    handled by `HasProducts.__init__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `products` property in each, along with their associated getter,
    setter, and deleter methods, can just be removed from the derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With `HasProducts` implemented, the full structure and functionality of the
    `hms_core` package is tentatively complete—tentatively because it hasn''t been
    unit tested yet. The class diagram for the entire package shows all of the moving
    parts, and the relationships between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de3e0c91-0f1b-4f4c-8c47-d3dbf41517c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, these classes provide definitions that could be described as dumb data
    objects. They provide little or no functionality that isn't directly related in
    some fashion to the definition and regulation of a specific data structure. Even
    `HasProducts`, and the classes that derive from it, fall into this category since
    the functionality provided there is strictly concerned with providing a data structure
    and controlling how that structure can be manipulated. As other classes are created
    that derive from these classes, those classes will start to become smarter, starting
    with persistence of the data for individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, unit tests for these classes need to be written, to assure that
    they have been tested, and that they can be retested on demand. Since that represents
    a significant shift in coding goals, and will involve some in depth examination
    of testing goals and how to accomplish them, this first unit testing pass warrants
    its own chapter.
  prefs: []
  type: TYPE_NORMAL
