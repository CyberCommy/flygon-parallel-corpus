- en: Controlling LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce several methods of controlling the range
    of NeoPixel LEDs that come with the Adafruit Circuit Playground Express. In these
    recipes, we will examine various ways of setting the colors of the pixels, each
    with its own trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: We will also demonstrate how to time operations so that fades and other light
    animation effects can be created. NeoPixels are a powerful way of allowing a richer
    visual interaction with your projects. These recipes will provide you with the
    necessary building blocks to incorporate these visual concepts into your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning on the pin 13 LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the brightness of the NeoPixel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the color of a single NeoPixel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying an LED color using the RGB and hex code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting an LED color using color names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting all NeoPixels to the same color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a range of NeoPixels to one color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random NeoPixel LED colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating LED animations with random colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating LED animations with rainbow colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit Circuit Playground Express layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the locations of the LEDs that will be used in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d6ba682-80e1-44fc-baee-79158532496b.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: The pin 13 LED is a simple single red LED that will be used in the first recipe.
    There are a total of 10 NeoPixels on the board. Each NeoPixel is made up of a
    red, green, and blue LED. By controlling the individual brightness of each of
    these LEDs, you will be able to set any NeoPixel to a specific color.
  prefs: []
  type: TYPE_NORMAL
- en: Turning on the pin 13 LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to turn the pin 13 LED on and off. This is
    the simplest LED available on the board as it has only one color, and interacting
    with it in Python is also very straightforward. For these reasons, the pin 13
    LED is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should see the pin 13 LED turn red at this stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the current state of the LED using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn off the LED, run the following code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The light of the pin 13 LED will now be switched off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. This
    library contains an object class called `express`, which is the main class that
    we will use to interact with the hardware on this board. When the library is imported,
    it creates an instance of this class called `cpx`.
  prefs: []
  type: TYPE_NORMAL
- en: The `cpx` object exposes a property called `red_led`. This property can be used
    to retrieve the current value of the LED. If the LED is on, it will return the
    `True` value; otherwise, if the LED is off, it will return the `False` value.
    Setting the value of this property will turn the LED on or off depending on whether
    a `True` or `False` value is set.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the simplest LED lights on the board to deal with, because it
    is controlled by setting a value to either `True` or `False`. You cannot control
    the color or the brightness of this LED. The other recipes in this book will control
    the NeoPixel lights on the board, which have a richer range of functionality and
    as a result, a more complicated API is needed to control them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `red_led` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.red_led](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.red_led).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on importing the `cpx` variable can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/#usage-example](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/#usage-example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the brightness of the NeoPixel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling the brightness of the pixels will be the theme of this recipe. It
    is important to be able to set the brightness of the pixels depending on the need
    of the project. Note that you will have to change the brightness to a level that
    is bright enough so that the pixels are clearly visible, but not so bright that
    it causes discomfort.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the first pixel should be the color red with full brightness.
    Run the following line of code to set the brightness level to 50%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The brightness level can be brought further down to 10% and still be comfortably
    visible. You can do this by running the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `brightness` property accepts a value from `0` to `1.0`, which goes from
    least bright to most bright. Note that the NeoPixels on this board can be very
    bright, and they can strain your eyes if you look at them directly at the highest
    level of brightness.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you set the brightness level to 10%, as this makes viewing
    the pixels more comfortable. Then, depending on the project, you can tweak the
    brightness to the most appropriate level.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when the pixels will be underneath a thin covering of plastic
    and you will want to increase the brightness level. On the other hand, there will
    be times when you will be directly looking at them and you will want to decrease
    the brightness level.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to note that the way the brightness levels are implemented means
    that you can only change all the NeoPixels at one time. That is, with the brightness
    property, you cannot make some pixels brighter and some pixels darker. So, whatever
    value you set for brightness will apply to all the pixels on the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pixels have the capability of being very bright when they are left at the
    maximum level of 100% brightness. An example of where this setting is more suitable
    is when you embed your device in a plastic container. The following photograph
    is taken from a NeoPixel project, where the Circuit Playground Express board was
    placed inside the base of a snow globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cddce960-db40-45aa-a407-294794c2a227.png)'
  prefs: []
  type: TYPE_IMG
- en: In this project, the base is made of white plastic. So, even though the board
    is not directly visible, the pixels are bright enough to shine through the white
    plastic and fill the whole globe with light.
  prefs: []
  type: TYPE_NORMAL
- en: The DIY snow globe kit shown in this project can be found at [https://www.adafruit.com/product/3722](https://www.adafruit.com/product/3722).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: The brightness property is documented at [https://circuitpython.readthedocs.io/projects/NeoPixel/en/latest/api.html#NeoPixel.NeoPixel.brightness](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/api.html#neopixel.NeoPixel.brightness).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of changing the brightness level can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/NeoPixels](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/neopixels).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the color of a single NeoPixel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to set the a specific NeoPixel to different colors.
    It will then show you how to change the color of any of the 10 NeoPixels that
    come with the board. This will be a useful recipe to follow so that you can start
    unleashing the power and flexibility of these onboard pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see the first NeoPixel turn red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the following code, you should see the first NeoPixel turn green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the following code, you should see the first NeoPixel turn blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should retrieve the current color value of the first NeoPixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to turn off the first NeoPixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code and the second NeoPixel should turn red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the `cpx` object that will be used to control
    the NeoPixels. This object has an attribute called `pixels`, which can be accessed
    like a list. The index that is used indicates which of the 10 NeoPixels is to
    be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: In the first code snippet, we set the value to a tuple that represents the desired
    color—it is comprised of red, green, and blue values. Each value should be represented
    as an integer from 0 to 255\. By setting the value to (255, 0, 0), the red LED
    will be at its highest value and the green and blue LEDs will be switched off.
    This will create the color red.
  prefs: []
  type: TYPE_NORMAL
- en: Following the same approach, the NeoPixel is then set to green and blue by providing
    the correct values for each of those colors. The current RGB values of a specific
    pixel can also be easily retrieved by simply accessing the value of any specific
    example.
  prefs: []
  type: TYPE_NORMAL
- en: A pixel can be switched off by setting all the RGB components to a value of
    0, as shown in the preceding code in this recipe. The final preceding code snippet
    just gives an example of setting the second pixel to the color red by referring
    to the correct index value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In older versions of the library, you could provide the colors as a list of
    three integers, instead of a tuple of three integers. It is best to avoid doing
    this and stick to using tuples instead of lists. This is because your code will
    work in both the newer and older versions of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each NeoPixel is made up of a red, green, and blue LED. When you set the strength
    of each color in this recipe, it directly changes the brightness levels of these
    individual LEDs. It is a possible to use a consumer microscope to view each of
    the three individual LED lights that make up each NeoPixel. The following photograph
    is taken from one of these consumer grade microscopes with a magnification of
    200x. As you can see, the separate red, green, and blue LEDs are clearly visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b25ccf3e-f210-4dab-b042-0457e92f2e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the pixels attribute can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.pixels](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.pixels).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on the NeoPixel can be found at [https://learn.adafruit.com/adafruit-NeoPixel-uberguide/the-magic-of-NeoPixels](https://learn.adafruit.com/adafruit-neopixel-uberguide/the-magic-of-neopixels).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying an LED color using the RGB and hex code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a common convention to express any color using the hex code, which
    works by representing the red, green, and blue components of the color. This recipe
    demonstrates how to set the color of a NeoPixel using this hex code convention.
    Using such a popular convention will be useful when you want to apply specific
    color settings from other applications on the web or your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the first NeoPixel turn red. Run the following code to retrieve
    the color value of the first NeoPixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to set the next two pixels to green and blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to set the fourth pixel to yellow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to display the integer value for the color blue, and
    then set the next pixel to the color blue using this integer value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first code snippet sets the first pixel on the board to the color red using
    the hex notation for colors. The pixel's interface accepts color values to be
    given as either a tuple of three integers or as a hex value, which, in Python,
    correlates to an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of value given, the library extracts the correct values
    of the red, green, and blue components of the color and sets the pixel to that
    color. The second code snippet indicates that when reading back the values, they
    will always be retrieved as a tuple of the three color components.
  prefs: []
  type: TYPE_NORMAL
- en: The final code snippet demonstrates that the hex notation being used is a standard
    feature of the Python language, which is used to specify the value of an integer
    in terms of its hex values. The equivalent integer value can also be used to set
    a color.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hex code notation system to describe a color''s red, green, and blue components
    is extremely popular. Due to its popularity, it is easy to find a variety of online
    tools and desktop applications that provide color pickers and color wheels, which
    represent colors as hex codes. You can simply choose you desired color in these
    programs and then copy and paste the hex values into your scripts. The following
    screenshot is taken from the popular open source image editor, GIMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6918ea9c-b73f-4c25-9bd5-8456b961f999.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see the color wheel that is available in
    the application. This rich interface easily allows you to find the color that
    you are looking for by changing its hue or saturation. Once you have picked the
    color that you want, you can copy the hex code value, which is labeled as **HTML
    notation** in this application. This value can then be used in your script using
    the same technique shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: GIMP is available on Linux, macOS, and Windows and can be downloaded for free
    from [https://www.gimp.org](https://www.gimp.org).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on integer literals in the Python language can be found at [https://docs.python.org/3/reference/lexical_analysis.html#integer-literals](https://docs.python.org/3/reference/lexical_analysis.html#integer-literals).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactive color wheel can be found at [https://www.sessions.edu/color-calculator/](https://www.sessions.edu/color-calculator/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting an LED color using color names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using human-readable color names can make it much easier to keep track of what
    colors are in use in your application. This recipe demonstrates a technique that
    allows you to set pixel colors using regular color names. This feature of referring
    to colors by a standard set of color names is available in popular languages,
    including CSS. This recipe shows you how to bring this feature to your MicroPython
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should see the first NeoPixel turn red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code to set the first eight pixels to one of the named colors
    in alphabetical order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A global variable called RGB is created; this is a dictionary that is used for
    matching color names to their RGB color codes. This allows the color values to
    be retrieved by their names, instead of directly specifying their hex codes every
    time they need to be used. The first snippet uses the RGB code to set the first
    pixel to the color red.
  prefs: []
  type: TYPE_NORMAL
- en: The second block of code loops through each color name in alphabetical order
    and sets a pixel to that color. Since there are eight colors defined in the color
    lookup dictionary, the first eight pixels will have their colors set—each pixel
    will have its own color from the list of colors.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using human-readable color names can improve code readability. The technique
    described in this recipe, however, requires you to specify each color name and
    its associated hex code manually. This is fine if you are only using a small number
    of colors, but if you want to support a large number of colors, then this can
    become very tedious. Another factor to bear in mind is that many of these boards
    have limited memory capacity, so creating very large dictionaries can cause the
    board to run out of memory. A small color lookup table, such as the one shown
    in this example, shouldn't cause these sorts of issues.
  prefs: []
  type: TYPE_NORMAL
- en: When you are looking for color names and their associated hex codes, there are
    a number of standard sources that can be used. One popular list of color names
    is the **World Wide Web Consortium** (**W3C**), which is used in CSS. There is
    also a standard color list provided with the open source text editor, Vim. This
    list of color names is stored in a file called `rgb.txt`, which comes with each
    Vim installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of using this color listing is that it comes in a machine-readable
    format, where each line represents one color and the color components and names
    are whitespace-delimited. This makes parsing and using these color names a relatively
    trivial process. The following screenshot shows the output of a useful Vim script
    that parses this file and presents each color name and its applied color for easy
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c942081-50b5-4340-a7e3-35462c0e0f18.png)'
  prefs: []
  type: TYPE_IMG
- en: This Vim color script can be found at [https://vim.fandom.com/wiki/View_all_colors_available_to_gvim](https://vim.fandom.com/wiki/View_all_colors_available_to_gvim).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: The W3C color names can be found at [https://www.w3.org/TR/css-color-3/](https://www.w3.org/TR/css-color-3/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of additive color theory can be found at [https://study.com/academy/lesson/additive-color-theory-definition.html](https://study.com/academy/lesson/additive-color-theory-definition.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting all NeoPixels to the same color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how you can set all the pixels to one color through a single
    call, instead of looping through all the NeoPixels and setting their colors individually.
    You can use this technique to create a nice effect to set all 10 NeoPixels to
    the same color. They are arranged in a perfect circle, so it creates a ring of
    color when they are all set to the same color. It is also an easy way to turn
    all the NeoPixels off in one call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You should see all 10 NeoPixels turn blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code to turn off all 10 NeoPixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first code snippet, the `fill` method is called and the color value is
    provided as the first argument. The `fill` method will loop through all the pixels
    and set them to the desired color, which, in this case, is the color blue. This
    method accepts both the hex color notation and tuples of three integer values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This operation of setting all the pixels to the same color is relatively popular,
    and the method has been provided for your convenience. However, it is important
    to note that the implementation of this method doesn't just take a simple loop
    and set the color for each pixel. Instead, it uses a feature where you can set
    all the color values before displaying them.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this feature is that you can first set all the colors, and
    then make a single call to display them all at once. This is a better way of setting
    the pixels rather than with a simple `for` loop, so it provides another good reason
    to use the `fill` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `fill` method can be found at [https://circuitpython.readthedocs.io/projects/NeoPixel/en/latest/api.html#NeoPixel.NeoPixel.fill](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/api.html#neopixel.NeoPixel.fill).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of products that work with the NeoPixel library can be found at [https://www.adafruit.com/category/168](https://www.adafruit.com/category/168).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a range of NeoPixels to one color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will explore how the slicing feature can be used to set a specific
    range of pixels to a specific color. This can be quite useful when you want to
    turn the ring of pixels into a gauge to show the level of a value from 1 to 10\.
    Essentially, it provides a clearer and simpler way of setting a range of pixels
    to a particular color.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see the first two NeoPixels light up as red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn the next three pixels to green and the last five pixels to blue using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pixels` attribute understands when you set values using the `slice` method.
    However, it expects that if you set the color for two pixels, then you should
    provide a list of two color values, as was done in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can reduce this repetition by taking a list of the color values
    and multiplying it by the required number of values. This is the approach that
    is used to set the three pixels to the color green.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The slicing notation that is used in Python is concise and powerful. It is a
    very smart way to change the colors on a range of pixels in one line of code.
    This very much embraces the Python approach of keeping code short and concise
    without compromising on readability.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Further details on using the `*` operator to repeat values in Python's lists
    can be found at [http://interactivepython.org/runestone/static/CS152f17/Lists/ConcatenationandRepetition.html](http://interactivepython.org/runestone/static/CS152f17/Lists/ConcatenationandRepetition.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on Python string slicing can be found at [https://docs.python.org/3/tutorial/introduction.html#lists](https://docs.python.org/3/tutorial/introduction.html#lists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random NeoPixel LED colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates a technique that can be used to endlessly generate
    random colors. We will then use these random colors on a specific NeoPixel. Adding
    randomness to the color section can make projects more interesting, as you can
    never predict the exact sequence of colors that will appear as your script executes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each time you run the previous lines of code, you should get a random integer
    between the values of 0 and 255.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code to define a function, and then call the function to
    confirm that it is working correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the following code repeatedly; the first NeoPixel should change to a random
    color on each call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Set all the pixels to the same random color on each call using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use the `random` module, which is part of the Python standard
    library and CircuitPython. Calling `randint` and providing a range from 0 to 255
    will give us a random integer for each color component.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `get_random_color` function to randomly select each of the
    three color components and, therefore, make a random color. Now that we have this
    function, we can call it to set the color of a single pixel or all the pixels,
    as demonstrated in the final two code snippets in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the `random` module in MicroPython projects opens up a whole range
    of fun possibilities for unique and different projects. This recipe covered one
    example of combining the random library with code to specify a color so that random
    colors can be chosen. Over 16 million different colors might be randomly selected
    using this method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the CircuitPython random library can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/random/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/random/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project using the `random` library and Circuit Playground Express to create
    electronic dice can be found at [https://learn.adafruit.com/circuit-playground-d6-dice/](https://learn.adafruit.com/circuit-playground-d6-dice/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating LED animations with random colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will combine some aspects of the previous recipes in this chapter
    to create an animation using randomly selected colors. This recipe builds on the
    techniques of other recipes to create your first animation. With 10 pixels on
    the board, there are a lot of options for creating engaging visual animations
    on the board—this is just one of those.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code and a `10` second animation of colors should
    appear around the ring of pixels on the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the animation for 30 seconds and cycle through all the pixels three
    times, with a 1-second delay between each light change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For this final animation, run the animation for five seconds and change all
    the pixel colors once a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three different animations are presented in this recipe. When it comes to light
    animations, the sky's the limit. There are so many different ways to control color
    change and timing and each different approach will create a slightly different
    visual effect. However, a key aspect of all animation is timing; we can control
    the pace of the animation by using the `sleep` call, which is part of the `time`
    module. In this way, we can slow down or speed up the animations we create.
  prefs: []
  type: TYPE_NORMAL
- en: The first animation in this recipe is a simple `for` loop, which sets the color
    of each pixel to a random color and pauses for one second between these color
    changes. The second animation builds on the first one by having an outer loop
    that loops 3 times and so changes the pixels 30 times.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last animation takes a different approach by setting all the pixels
    to the same color and then changing them together during each loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animations in this recipe can be tweaked to create a variety of different
    animations. For instance, you could change the speed of the animation or the number
    of times the animation loops around the pixels. The preceding code can be used
    in a function that receives these two parameters as arguments. This can then be
    used in a larger program, which will call the function to make animations with
    different settings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the CircuitPython time library can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/time/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/time/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project using the Circuit Playground Express to create an animated bike light
    can be found at [https://learn.adafruit.com/circuit-playground-bike-light](https://learn.adafruit.com/circuit-playground-bike-light).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating LED animations with rainbow colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will produce a ring of colors following the same sequence of colors
    found in a rainbow. These colors will each appear after a certain delay, creating
    a rainbow animation effect. Using a sequence of colors that naturally fits together,
    like the ones found in the rainbow, can be both pleasing and engaging. The strength
    of this animation is in learning how to control the exact sequence of colors being
    animated, whether they be in a rainbow sequence or another sequence of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code defines a list of color values that have the same
    values and sequence as that which appears in a rainbow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set a more comfortable level of brightness and turn off all the pixels
    before starting the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following block of code, loop through the seven colors in the rainbow
    and set one pixel to each color, with a brief delay of `0.2` seconds between each
    light change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following animation to go back to each pixel and turn it off at the
    same rate of `0.2` seconds per light change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code combines all the steps described and wraps these into one
    infinite `while` loop. Add this section of code to the `main.py` file, and then
    create a continuous rainbow animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A rainbow in nature is made up of seven colors: red, orange, yellow, green,
    blue, indigo, and violet. We store these colors'' values, and their correct sequences
    as they appear in nature, in a list. The brightness level is set and then the
    `fill` method is called to turn off all the pixels on the board.'
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop is started that contains two loops. The first inner loop will
    loop through each color in the rainbow and set one pixel to each color. The second
    inner loop will then go back to the seven pixels that were colored and turn each
    one off.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following photograph shows the rainbow animation from this recipe running
    on the Circuit Playground Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a153e9c0-d041-4160-b6ae-a24207d78566.png)'
  prefs: []
  type: TYPE_IMG
- en: There are many ways to make further derivative animations from this rainbow
    animation. For instance, you could add more colors that are not part of the natural
    rainbow. We have defined 7 colors but there are 10 pixels on the board, so you
    could define another 3 different colors. You could also have the starting pixel
    be randomly selected in each loop, so that the animation starts at a different
    pixel in each loop.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence and names of the seven colors of the rainbow can be found at [https://sciencetrends.com/7-colors-rainbow-order/](https://sciencetrends.com/7-colors-rainbow-order/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A different implementation of a rainbow animation can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-NeoPixel](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-neopixel).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
