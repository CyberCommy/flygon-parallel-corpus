- en: Diving into Modern C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ programming language has been changed dramatically since its invention
    in 1979\. Some people in this era might be a little bit scared to code using C++
    language since it is not user-friendly. The memory management we have to deal
    with sometimes makes people unwilling to use this language. Fortunately, since
    **C++11**--also known as **modern C++**, along with **C++14** and **C++17**--has
    been released, numerous features have been introduced to simplify our code in
    the C++ language. Moreover, the best part of it is that the C++ programming language
    is a great language for any project, from low-level programming to web programming,
    as well as functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is the best place to start our journey in this book, as it is
    addressed to the C++ programmers to refresh their knowledge and will discuss the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding several new features in modern C++
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the C++ Standard Libraries in modern C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the Lambda expression and all features included in C++ Lambda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using smart pointer to avoid manual memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with many return values using tuples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting closer with several new features in modern C++
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is new in modern C++ in comparison to the old one? There are so many
    changes in modern C++ compared to the old one, and the book pages will dramatically
    increase if we discuss all of them. However, we will discuss the new features
    in modern C++, which we should know about, to make us more productive in coding
    activities. We will discuss several new keywords, such as `auto`, `decltype`,
    and `nullptr`. We will also discuss the enhancement of the `begin()` and `end()`
    function that has now become a non-member class function. We will also discuss
    the augmented support for the `for-each` technique to iterate over collections
    using the `range-based for loop` techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The next few subsections in this chapter will also discuss the new features
    of modern C++, namely Lambda expressions, smart pointers, and tuples, which were
    just added in the C++11 release.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data type automatically using the auto keyword
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to the modern C++, the C++ language has a keyword named `auto` that is
    used to explicitly specify that the variable should have **automatic duration**.
    The automatic duration that adheres to the variable will create the variable at
    the point of definition (and initialized, if relevant) and destroy the variable
    when the block they are defined in is exited. For instance, the local variable
    will be created when it is defined at the beginning of the function and destroyed
    when the program exits the function where the local variable is there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Since C++11, the `auto` keyword is used to tell the compiler to deduce the actual
    type of a variable that is being declared from its initializer. And since C++14,
    the keyword can also be applied to a function to specify the return type of the
    function that is a trailing return type. Now, in modern C++, the use of the `auto`
    keyword to specify the automatic duration is abolished since all variables are
    set to automatic duration by default.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an `auto.cpp` code demonstrating the use of the `auto` keyword
    in the variables. We will define four variables with the `auto` keyword, and then
    find out the data type for each variable using the `typeid()` function. Let''s
    take a look:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the preceding code, we have an `a` variable that will store
    the `integer` value and have a `b` variable that will store the `double` value.
    We calculate the addition of `a` and `b` and store the result in variable `c`.
    Here, we expect that `c` will store the `double` object since we add the `integer`
    and `double` object. The last is the `d` variable that will store the `initializer_list<double>`
    data type. When we run the preceding code, we will see the following output on
    the console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d5e1164-6f13-4afb-9011-c6444f0c3589.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding snapshot, we are just given the first character
    of the data type, such as `i` for `integer`, `d` for `double`, and `St16initializer_listIdE`
    for `initializer_list<double>`, that is the last lowercase `d` character that
    stands for `double`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的快照所示，我们只给出了数据类型的第一个字符，比如`i`代表`整数`，`d`代表`双精度`，`St16initializer_listIdE`代表`initializer_list<double>`，最后一个小写的`d`字符代表`双精度`。
- en: We may have to enable the **Run-Time Type Information** (**RTTI**) feature in
    our compiler options to retrieve the data type object. However, GCC has enabled
    the feature by default. Also, the output of the use of the `typeid()` function
    depends on the compiler. We may get the raw type name or just a symbol as we did
    in the preceding example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在编译器选项中启用**运行时类型信息**（**RTTI**）功能来检索数据类型对象。然而，GCC已经默认启用了这个功能。此外，`typeid()`函数的使用输出取决于编译器。我们可能会得到原始类型名称，或者就像我们在前面的例子中所做的那样，只是一个符号。
- en: 'Besides, for variable, as we discussed earlier, the `auto` keyword can also
    be applied to a function to deduce a function''s return type automatically. Suppose
    we have the following trivial function named `add()` to calculate the addition
    of two parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于变量，正如我们之前讨论的那样，`auto`关键字也可以应用于函数，自动推断函数的返回类型。假设我们有以下名为`add()`的简单函数来计算两个参数的加法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can refactor the preceding method to use the `auto` keyword, as we can see
    in the following lines of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构前面的方法来使用`auto`关键字，如下所示的代码行：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similar to the auto-type variable, the compiler can decide the correct return
    type based on the returned value of the function. And, as shown in the preceding
    code, the function will indeed return the integer value since we just add two
    integer values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与自动类型变量类似，编译器可以根据函数的返回值决定正确的返回类型。正如前面的代码所示，该函数确实返回整数值，因为我们只是添加了两个整数值。
- en: 'Another feature that uses the `auto` keyword in modern C++ is trailing the
    return type syntax. By using this feature, we can specify the return type, the
    rest of the function prototype, or function signature. From the preceding code,
    we can refactor it to use the feature as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++中使用`auto`关键字的另一个特性是尾返回类型语法。通过使用这个特性，我们可以指定返回类型，函数原型的其余部分，或函数签名。从前面的代码中，我们可以重构它以使用以下特性：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You might ask me why we have to specify the data type again after the arrow
    symbol (`->`), even though we have used the `auto` keyword. We will find the answer
    when we cover the `decltype` keyword in the next section. Also, by using this
    feature, we can now refactor the preceding `auto.cpp` code a little bit by modifying
    the syntax of the `main()` method, instead of the following syntax of `main()`
    function signature:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我为什么我们在箭头符号(`->`)之后再次指定数据类型，即使我们已经使用了`auto`关键字。当我们在下一节讨论`decltype`关键字时，我们将找到答案。此外，通过使用这个特性，我们现在可以通过修改`main()`方法的语法来稍微重构前面的`auto.cpp`代码，而不是`main()`函数签名的以下语法：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can change the signature syntax into the following line of code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将签名语法改为以下代码行：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will see all of our code in this book using this trailing return type
    feature to apply the modern C++ syntax.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到本书中的所有代码都使用这个尾返回类型特性来应用现代C++语法。
- en: Querying the type of an expression using the decltype keyword
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用decltype关键字查询表达式的类型
- en: We discussed in the preceding section that the `auto` keyword can automatically
    deduce the type of the variable based on the type of values it stores. The keyword
    can also deduce the function's return type based on the type of its return value.
    Now, let's combine the `auto` keyword and the `decltype` keyword to gain the power
    of modern C++.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分讨论了`auto`关键字可以根据其存储的值的类型自动推断变量的类型。该关键字还可以根据其返回值的类型推断函数的返回类型。现在，让我们结合`auto`关键字和`decltype`关键字，获得现代C++的功能。
- en: 'Before we combine the two keywords, we will find out what the `decltype` keyword
    is used for--it is used for asking the type of an object or an expression. Let''s
    take a look at the following several lines of trivial variable declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结合这两个关键字之前，我们将找出`decltype`关键字的用途--它用于询问对象或表达式的类型。让我们看一下以下几行简单的变量声明：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, based on the preceding code, we can declare other variables using the
    `decltype` keyword as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于前面的代码，我们可以使用`decltype`关键字声明其他变量，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see in the preceding code, we can specify the type of an object based
    on another object''s type. Now, let''s suppose we need to refactor the preceding
    `add()` method to become a template. Without the `auto` and `decltype` keyword,
    we will have the following template implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们可以根据另一个对象的类型指定对象的类型。现在，假设我们需要重构前面的`add()`方法成为一个模板。没有`auto`和`decltype`关键字，我们将有以下模板实现：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Fortunately, since the `auto` keyword can specify the return type of the function,
    which is a trailing return type, and the `decltype` keyword can deduce the type
    based on the expression, we can refactor the preceding template as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于`auto`关键字可以指定函数的返回类型，即尾返回类型，而`decltype`关键字可以根据表达式推断类型，我们可以将前面的模板重构如下：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To prove, let''s compile and run the following `decltype.cpp` code. We will
    use the following template to calculate the addition of two different value types--`integer`
    and `double`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明，让我们编译和运行以下的`decltype.cpp`代码。我们将使用以下模板来计算两种不同值类型--`整数`和`双精度`的加法：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compilation process should run smoothly without error. We will see the
    following output on the screen if we run the preceding code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程应该可以顺利进行，没有错误。如果我们运行前面的代码，我们将在屏幕上看到以下输出：
- en: '![](img/9b573b77-6cc6-41a6-94cb-8fc04dd314c8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b573b77-6cc6-41a6-94cb-8fc04dd314c8.png)'
- en: As we can see, we have successfully combined the `auto` and `decltype` keyword
    to create a template simpler than we usually do before the modern C++ is announced.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们成功地结合了`auto`和`decltype`关键字，创建了一个比现代C++宣布之前通常更简单的模板。
- en: Pointing to a null pointer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指向空指针
- en: 'Another new feature in modern C++ is a keyword named `nullptr` that replaces
    the `NULL` macro to represent a null pointer. Now, there''s no ambiguity in the
    use of the `NULL` macro for zero numeric or a null pointer. Let''s suppose we
    have the following two method''s signature in our declaration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++中的另一个新功能是一个名为`nullptr`的关键字，它取代了`NULL`宏来表示空指针。现在，在使用`NULL`宏表示零数字或空指针时不再存在歧义。假设我们在声明中有以下两个方法的签名：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The former function will pass a pointer as the argument and the latter will
    pass the integer number as its argument. Then, we invoke the `funct()` method
    and pass the `NULL` macro as the parameter, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数将传递一个指针作为参数，后一个将传递整数作为参数。然后，我们调用`funct()`方法并将`NULL`宏作为参数传递，如下所示：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What we intend to call is the former function. However, since we pass the `NULL`
    parameters, which is basically defined as `0`, the latter function will be invoked.
    In modern C++, we can use the `nullptr` keyword to ensure that we will pass a
    null pointer to the argument. The invocation of the `funct()` method should be
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算调用前一个函数。然而，由于我们传递了`NULL`参数，它基本上被定义为`0`，后一个函数将被调用。在现代C++中，我们可以使用`nullptr`关键字来确保我们将传递一个空指针给参数。调用`funct()`方法应该如下：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the compiler will invoke the former function since it passes a null pointer
    to the argument, and this is what we expect. There will be no ambiguity anymore,
    and it will avoid unnecessary future problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器将调用前一个函数，因为它将一个空指针传递给参数，这是我们期望的。不再存在歧义，将避免不必要的未来问题。
- en: Returning an iterator using non-member begin() and end() function
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非成员begin()和end()函数返回迭代器
- en: 'Prior to modern C++, to iterate a sequence, we call the `begin()` and `end()`
    member method of each container. For array, we can iterate its element by iterating
    the index. Since C++11, the language has a non-member function--`begin()` and
    `end()`--to retrieve the iterator of the sequence. Let''s suppose we have an array
    of the following elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++之前，要迭代一个序列，我们需要调用每个容器的`begin()`和`end()`成员方法。对于数组，我们可以通过迭代索引来迭代它的元素。自C++11以来，语言有一个非成员函数--`begin()`和`end()`--来检索序列的迭代器。假设我们有以下元素的数组：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the language doesn''t have the `begin()` and `end()` function, we need
    to iterate the elements of the array using the index we can see in the following
    lines of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当语言没有`begin()`和`end()`函数时，我们需要使用索引来迭代数组的元素，可以在下面的代码行中看到：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Fortunately, using the `begin()` and `end()` function, we can refactor the
    preceding `for` loop to become as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用`begin()`和`end()`函数，我们可以重构前面的`for`循环如下：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, the use of the `begin()` and `end()` function creates a compact
    code since we don''t need to worry about the length of the array because the iterator
    pointer of `begin()` and `end()` will do it for us. For comparison, let''s take
    a look at the following `begin_end.cpp` code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用`begin()`和`end()`函数创建了一个紧凑的代码，因为我们不需要担心数组的长度，因为`begin()`和`end()`的迭代器指针会为我们做这件事。为了比较，让我们看一下以下的`begin_end.cpp`代码：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To prove the preceding code, we can compile the code, and, when we run it,
    the following output should be displayed on the console screen:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明前面的代码，我们可以编译代码，当我们运行它时，应该在控制台屏幕上显示以下输出：
- en: '![](img/3219ad51-9855-43ce-b596-536273d9c047.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3219ad51-9855-43ce-b596-536273d9c047.png)'
- en: As we can see in the screenshot, we've got the exact same output when we use
    the conventional `for-loop` or `begin()` and `end()` functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在屏幕截图中看到的，当我们使用传统的`for-loop`或`begin()`和`end()`函数时，我们得到了完全相同的输出。
- en: Iterating over collections using range-based for loops
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环迭代集合
- en: 'In the modern C++, there is a new feature that is augmented to support the
    `for-each` technique to iterate over collections. This feature is useful if you
    want to do something to the elements of a collection or array without caring about
    the number of elements or the indexes. The syntax of the feature is also simple.
    Suppose we have an array named `arr` and we want to iterate each element using
    the `range-based for loop` technique; we can use the following syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代C++中，有一个新功能被增强，支持“for-each”技术来迭代集合。如果你想对集合或数组的元素做一些操作而不关心元素的数量或索引，这个功能就很有用。这个功能的语法也很简单。假设我们有一个名为`arr`的数组，我们想要使用`range-based
    for loop`技术迭代每个元素，我们可以使用以下语法：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, we can refactor our preceding `begin_end.cpp` code to use `range-based
    for loop` as we can see in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以重构我们之前的`begin_end.cpp`代码，使用`range-based for loop`，如下所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syntax we see in the preceding code is simpler now. If we compile the preceding
    code, we should find no error and, if we run the code, we should see the following
    output on the console screen:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中看到的语法现在更简单了。如果我们编译前面的代码，应该不会出现错误，如果我们运行代码，应该在控制台屏幕上看到以下输出：
- en: '![](img/3f3f2d37-a65c-491d-86e6-c0cc8523e391.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3f2d37-a65c-491d-86e6-c0cc8523e391.png)'
- en: We now have a new technique to iterate over the collection without caring about
    the indexes of the collection. We will keep using it in this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种新的技术来迭代集合，而不必关心集合的索引。我们将在本书中继续使用它。
- en: Leveraging the use of C++ language with the C++ Standard Libraries
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用C++语言与C++标准库
- en: The C++ Standard Libraries are a powerful set of classes and functions that
    have many capabilities needed to create an application. They are controlled by
    the C++ ISO Standard Committee and is influenced by the **Standard Template Libraries**
    (**STL**), which were the generic libraries before C++11 was introduced. All features
    in Standard Libraries are declared in `std namespace` and no headers end in `.h`
    anymore (except 18 headers of the ISO C90 C Standard Library that is incorporated
    into the C++ Standard Libraries).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There are several header files containing the declaration of the C++ Standard
    Libraries. However, it is almost impossible to discuss all header files in these
    tiny chapters. We will, therefore, talk about some features that we will use most
    in our daily coding activities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Placing any objects in the container
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Container** is an object that is used to store other objects and manage the
    memory that is used by the objects it contains. An array is a new feature added
    in C++11 to store the collection of specific data types. It is a sequence container
    since it stores the same data type objects and arranges them linearly. Let''s
    take a look at the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in the preceding code, we instance a new array named `arr`, set
    its length as `10`, and only approve the `int` element. As we can guess, the output
    of the code is a line of numbers `0` through `9`, which is shown in the original
    data, and the other line will show the altered data, as we can see in the following
    screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf41be3-c581-4cf9-87d9-be35bc06f403.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: There is no performance issue if we declare an array using `std::array`; we
    use in the `array.cpp` code and compare it with a usual array as we use in the
    `begin_end.cpp` code. However, in modern C++, we are given a new array declaration
    that has a friendly value semantic, so that it can be passed to or returned from
    functions by value. Also, the interface of this new array declaration makes it
    more convenient to find the size, and use it with **Standard Template Library**
    (**STL**)-style iterator-based algorithms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to use an array as the container since we can store the data and
    manipulate them. We can also sort and find a specific element if we want. However,
    since the array is a compile-time non-resizable object, we have to decide the
    size of the array we intend to use at the very beginning as we cannot change the
    size later. In other words, we cannot insert or remove the element from the existing
    array. As a solution to this problem, and for the best practice of using the container
    as well, we can now use a `vector` to store our collection. Let''s take a look
    at the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we have a `vector` instance in our preceding code instead of an `array`
    instance. As we can see, we give an additional value for the `vector` instance
    using the `push_back()` method. We can add the value anytime we want. The manipulation
    of each element is also easier since `vector` has an `at()` method that returns
    a reference to the element of the specific index. The following screenshot is
    what we will see as the output when running the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6c12da0-75ee-450a-b324-a86e4bf59dad.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: It is better to always use the `at()` method instead of the `[]` operator when
    we want to access the specific element by its index in a `vector` instance. It's
    because, when we accidentally access the out of range position, the `at()` method
    will throw an `out_of_range` exception. Otherwise, the `[]` operator will give
    undefined behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Using algorithms
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can sort the elements of the collection we have in `array` or `vector`,
    as well as find specific content of the element. For these purposes, we have to
    use the algorithm feature provided by the C++ Standard Library. Let''s take a
    look at the following code to demonstrate the sorting element capability in the
    algorithm feature:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we see in the preceding code, we invoked the `sort()` method twice. First,
    we just supplied the range of the elements we wanted to sort. Then we added the
    comparison function, `comparer()`, to be provided to the `sort()` method to gain
    more flexibility the method has. The output we will see on the console from the
    preceding code is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，我们两次调用了`sort()`方法。首先，我们只提供了我们想要排序的元素的范围。然后，我们添加了比较函数`comparer()`，以便将其提供给`sort()`方法，以获得更多灵活性。从前面的代码中，我们将在控制台上看到的输出如下：
- en: '![](img/a39ab3f7-55b8-4dda-8f2f-4d253d92f0d9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a39ab3f7-55b8-4dda-8f2f-4d253d92f0d9.png)'
- en: From the preceding screenshot, we can see that we have six elements in a `vector`
    at the beginning. We then sort the elements of the vector using a simple `sort()`
    method. Then, we invoke the `sort()` method again, but instead of a simple `sort()`
    method, we now supply `comparer()` to the `sort()` method. As a result, the vector
    elements will be sorted descendingly since the `comparer()` function looks for
    the greater value from two inputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到一开始`vector`中有六个元素。然后，我们使用简单的`sort()`方法对向量的元素进行排序。然后，我们再次调用`sort()`方法，但现在不是简单的`sort()`方法，而是将`comparer()`提供给`sort()`方法。结果，向量元素将按降序排序，因为`comparer()`函数从两个输入中寻找更大的值。
- en: 'Now, let''s move to another capability the algorithm feature has, which is
    finding a particular element. Let''s suppose we have the `Vehicle` class in our
    code. It has two private fields named `m_vehicleType` and `m_totalOfWheel`, and
    we can retrieve the value from the getter methods named `GetType()` and `GetNumOfWheel()`
    respectively. It also has two constructors, which are the default constructor
    and the user-defined one. The declaration of the class should be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向算法特性具有的另一个功能，即查找特定元素。假设我们在代码中有`Vehicle`类。它有两个名为`m_vehicleType`和`m_totalOfWheel`的私有字段，我们可以从getter方法`GetType()`和`GetNumOfWheel()`中检索值。它还有两个构造函数，分别是默认构造函数和用户定义的构造函数。类的声明应该如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The implementation of the `Vehicle` class is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类的实现如下：'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will store a collection of `Vehicle` in the `vector` container, and then
    we will search for some elements based on its property. The code will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`vector`容器中存储一组`Vehicle`，然后根据其属性搜索一些元素。代码如下：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, we instance four `Vehicle` objects, then store them in `vector`.
    There, we try to find the vehicle that has two wheels. The `find_if()` function
    is used for this purpose. We also have the `TwoWheeled()` method to provide the
    comparison value. Since we are finding the two-wheeled vehicle, we will inspect
    the `totalOfWheel` variable in the `Vehicle` class by invoking the `GetNumOfWheel()`
    method. In contrast, if we want to find the element that doesn''t conform to the
    comparison value, we can use the `find_if_not()` function, which had been added
    in C++11\. The output we get should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们实例化了四个`Vehicle`对象，然后将它们存储在`vector`中。在那里，我们试图找到有两个轮子的车辆。`find_if()`函数用于此目的。我们还有`TwoWheeled()`方法来提供比较值。由于我们正在寻找两轮车辆，我们将通过调用`GetNumOfWheel()`方法来检查`Vehicle`类中的`totalOfWheel`变量。相反，如果我们想找到不符合比较值的元素，我们可以使用在C++11中添加的`find_if_not()`函数。我们得到的输出应该是这样的：
- en: '![](img/7c5af549-86c7-4414-896e-e9fe96a9cb20.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c5af549-86c7-4414-896e-e9fe96a9cb20.png)'
- en: As we can see in the `vehicle.cpp` code and `find.cpp` code, we now add the
    `using namespace std;` line in the `*.cpp` files. We do this to make our coding
    activity become more productive since we don't have to type many words. In contrast,
    in `vehicle.h`, we still using `std::` followed by the methods or properties name
    rather than use the std namespace at the beginning. It's best practice to not
    declare `using namespace` in header files since the header files are the files
    we will deliver if we create some libraries for instances. The user of our library
    may have another method with the same name as the function our library has. It
    will definitely create conflict between these two functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`vehicle.cpp`代码和`find.cpp`代码中看到的，我们现在在`*.cpp`文件中添加了`using namespace std;`行。我们这样做是为了使我们的编码活动变得更加高效，因为我们不必输入太多的单词。相反，在`vehicle.h`中，我们仍然使用`std::`后跟方法或属性名称，而不是在开头使用std命名空间。在头文件中最好不要声明`using
    namespace`，因为头文件是我们将为实例创建一些库时要交付的文件。我们库的用户可能有与我们的库具有相同名称的函数。这肯定会在这两个函数之间创建冲突。
- en: 'Another algorithm feature we will use most is the `for_each` loop. Instead
    of using the `for` loop, the use of the `for_each` loop will make our code more
    concise in many cases. It''s also simpler and less error prone than a `for` loop
    because we can define a specific function for the `for_each` loop. Now let''s
    refactor our previous code to use the `for_each` loop. The code is written as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最常使用的另一个算法特性是`for_each`循环。使用`for_each`循环而不是使用`for`循环，在许多情况下会使我们的代码更简洁。它也比`for`循环更简单，更不容易出错，因为我们可以为`for_each`循环定义一个特定的函数。现在让我们重构我们之前的代码以使用`for_each`循环。代码如下所示：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, with the `for_each` loop, we have a clearer code. We only need to provide
    the first and last iterator and then pass a function--the `PrintOut()` function
    in this case--that will be invoked in each element in the range.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`for_each`循环，我们有了更清晰的代码。我们只需要提供第一个和最后一个迭代器，然后传递一个函数--在这种情况下是`PrintOut()`函数--它将在范围内的每个元素中被调用。
- en: Simplifying the function notation using a Lambda expression
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda表达式简化函数表示
- en: 'The Lambda expression is an anonymous notation that represents something that
    performs an operation or calculation. In functional programming, the Lambda expression
    is useful to produce the first class and pure function, which we will discuss
    in separate chapters in this book. For now, let''s familiarize ourselves with
    this new feature introduced in C++11 by investigating three basic parts of the
    Lambda expression:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'capturing list: []'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'parameter list: ()'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'body: {}'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The order of these three basic parts is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The capturing list part is also used as a mark to identify the Lambda expression.
    It is a placeholder to value to be involved in the expression. The only capture
    defaults are the ampersand symbol (`&`), which will implicitly capture the automatic
    variables by reference, and the equal sign (`=`), which will implicitly capture
    the automatic variables by copy (we will discuss it further in the upcoming section).
    The parameter list is similar to the capturing list in every function where we
    can pass the value to it. The body is the implementation of the function itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lambda expression for a tiny function
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine we have a tiny one-line function that we invoke only once. It''s better
    if we write the operation of that function directly when we need it. We actually
    had this function in our previous example when discussing the C++ Standard Library.
    Just go back to the `for_each.cpp` file and we will find the `PrintOut()` function
    that is only invoked once by `for_each()`. We can make this `for_each` loop more
    readable if we use Lambda. Let''s take a look at the following code snippet to
    examine how we refactor the `for_each.cpp` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we have transformed the `PrintOut()` function that we used in
    the `for_each.cpp` file into a Lambda expression and passed it to the `for_each`
    loop. It will indeed give the same output as the `for_each.cpp` file does. However,
    now our code becomes more concise and readable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lambda expression for multiline functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lambda expression can also be used for multiline functions, so we can put
    the body of the function on it. This will make our code more readable as well.
    Let''s make a new code. In that code, we will have an integer collection and an
    intent to inspect whether the selected element is the prime number or not. We
    can make a separate function, for instance, `PrintPrime()`, then invoke it. However,
    since the prime number checking operation is called only once, it''s more readable
    if we transform it into a Lambda expression. The code should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output we should see on the screen is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04d24940-d788-4a9d-a8cd-006f15cfc228.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we have successfully identified the
    prime number by using the Lambda expression.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Returning a value from the Lambda expression
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our two preceding samples of the Lambda expression are just for the purpose
    to print on console. It means the function does not need to return any value.
    However, we can ask the Lambda expression to return a value for an instance if
    we do the calculation inside the function and return the calculation result. Let''s
    take a look at the following code to examine the use of this Lambda:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we use the `transform()` method in the preceding code, we have a Lambda
    expression that returns a value from the calculation of `n * n`. However, there's
    no return type stated in the expression. This is because we can omit the statement
    of the return type since the compiler has understood that the expression will
    return an `integer` value. So, after we have another vector, `vect2`, which has
    the same size as `vect`, we can invoke the `transform()` method along with the
    Lambda expression, and the value of `vect` will be doubled and stored in `vect2`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, if we want to, specify the return type to the Lambda expression. As
    we can see in the preceding code, we transformed the `vect3` vector based on all
    values of the `vect` vector, but now we specify the return type to `double` using
    the arrow symbol (`->`). The result of the preceding code should be like the following
    screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e395ef78-2ab2-418d-a186-6fe8b1884f70.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, we have successfully found the
    doubled and average result using the Lambda expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Capturing a value to the Lambda expression
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous Lambda expression examples, we keep the capturing part and
    the square bracket (`[]`) empty since the Lambda doesn''t capture anything and
    doesn''t have any extra member variable in the anonymous object generated by the
    compiler. We can also specify the object we want to capture in the Lambda expression
    by specifying it in this square bracket. Let''s take a look at the following piece
    of code to go through the discussion:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we will try to capture the value in the Lambda expression,
    explicitly and implicitly. Let''s suppose we have two variables, `a` and `b`,
    and we want to explicitly capture the values, we can specify them in the Lambda
    expression using the `[a,b]` statement, and then using the values inside the function
    body. Moreover, if we wish to capture the value implicitly, just use `[=]` for
    the capturing part and then the expression will know which variable we intend
    to use when we specify them in the function body. If we run the preceding code,
    we will get the following output on the screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55d1c5a-b38f-4bed-a8e2-b2e2945878c8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'We can also mutate the state of the values we capture without modifying the
    value outside the Lambda expression function body. For this purpose, we can use
    the same techniques as used previously, and add the `mutable` keyword as shown
    in the following block of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code will double the element of the `vect` vector. It uses capturing
    by value in the Lambda expression and also the `mutable` keyword. As we can see,
    we passed the vector element by reference `(int& x)` and multiplied it by two,
    then changed the value of `a` and `b`. However, since we use the `mutable` keyword,
    the final result of `a` and `b` will remain the same, although, we have passed
    the vector by reference. The output on the console looks like the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a58756-c71c-4554-afd8-05f6e71dff45.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'If we want to change the value of the `a` and `b` variables, we have to use
    the Lambda expression to capture by reference. We can do this by passing the reference
    to the angle bracket in the Lambda expression, for instance, `[&a, &b]`. For more
    detail, let''s take a look at the following piece of code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code has the same behavior with the `lambda_capturing_by_value_mutable.cpp`
    file that will double the element of the `vect` vector. However, by capturing
    by reference, it now also modifies the value of `a` and `b` when they are processed
    in the `for_each` loop. The `a` and `b` values will be changed at the end of the
    code, as we can see in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d62a43b-5efe-443e-899c-c80c88f26608.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Preparing the value using initialization captures
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another great feature of the Lambda expression coming up in C++14 is its initialization
    captures. The expression can capture a value of the variable and assign it to
    the expression''s variable. Let''s take a look at the following piece of code
    implementing the initialization captures:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see in the preceding code, we have an int variable named `a` with
    the value `5`. The Lambda expression, `myLambda`, then captures the `a` value
    and executes it in the code. The result is that now the `a` value will be `7`
    since it is added by `2`. The following output screenshot should appear in our
    console window when we run the preceding code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66131890-ed47-4d35-93cc-c79b68cbd840.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: From the preceding snapshot, we see that we can prepare the value to be included
    in the calculation inside the Lambda expression.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic Lambda expression to be used many times with many different
    data types
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before C++14, we have to specifically state the type of the parameter list.
    Fortunately, now in C++14, Lambda expressions accept `auto` as a valid parameter
    type. Therefore, we can now build a generic Lambda expression as demonstrated
    in the following code. In that code, we have only one Lambda expression to find
    out which is the greatest value between two numbers passed to the expression.
    We will use the `auto` keyword in parameter declaration so it can be passed by
    any data type. Therefore, the `findMax()` function parameters can be passed by
    both the `int` and `float` data type. The code should be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output we will see on the console should be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2d0eb85-dba1-4aa5-bd8e-445522a4e8a2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: The C++17 language plans to introduce two new features for the Lambda expression--they
    are capturing `*this`, which allows the expression to capture the enclosing object
    by copy, and the `constexpr` Lambda expressions, which allows us to use the result
    of the Lambda expressions and generate `constexpr` objects at compile time. However,
    since C++17 has not been released yet, we cannot try it for now.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding manual memory management with smart pointers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The smart pointers are highly useful and have an essential knowledge in using
    C++ efficiently. C++11 added many new abilities for the smart pointer we can find
    in the `memory` header file. For a long time, before C++11, we used `auto_ptr`
    as a smart pointer. However, it was quite unsafe since it had incompatible copy
    semantics. It's also deprecated now, and we should not use it anymore. Fortunately,
    C++ has presented `unique_ptr`, which has a similar functionality, but with additional
    features, such as adding `deleters` and support for arrays. Anything we can do
    with `auto_pt`, we can and should do with `unique_ptr` instead. We will discuss
    `unique_ptr` in depth along with other new smart pointers in C++11--`shared_ptr`
    and `weak_ptr`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a raw pointer using unique_ptr
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next pointer we will see is the `unique_ptr` pointer. It is fast, efficient,
    and a near drop-in replacement for raw or naked pointers. It provides exclusive
    ownership semantics, which exclusively owns the object that it points to. By its
    exclusiveness, it can destroy the object when its destructor is called if it has
    a non-null pointer. It also cannot be copied due to its exclusiveness. It has
    no copy constructor and copy assignment. Although it cannot be copied, it can
    be moved since it provides a move constructor and a move assignment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the methods we can use to construct `unique_ptr`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Based on the preceding code, `up1` and `up2` will construct two new `unique_ptr`
    that point to nothing (null), whereas `up3` will point to the address that holds
    the `1234` value. However, C++14 adds a new library function to construct `unique_ptr`,
    that is, `make_unique`. So, we can construct a new `unique_ptr` pointer as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `up4` variable will also point to the address that holds the `1234` value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following block of code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We try to construct a new `unique_ptr` pointer that points to the address that
    holds a `BodyMass` data type. In `BodyMass`, we have a constructor as well as
    a destructor. Now, let''s see how the `unique_ptr` pointer works by running the
    preceding code. The output we get on the screen should be like the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f91c15d-0216-4193-9396-a4d0aba1463d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the constructor is invoked when we
    construct `unique_ptr`. Moreover, unlike the traditional C++ language, where we
    have to free the memory up when we use a pointer, in modern C++, the memory will
    be freed up automatically when it is out of scope. We can see that the destructor
    of `BodyMass` is invoked when the program exits, which means `myWeight` is out
    of scope.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test the exclusiveness of `unique_ptr` by analyzing the following
    code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we can see in the preceding code, we see that we can''t assign the `unique_ptr`
    instance to another pointer since it will break the exclusiveness of `unique_ptr`.
    The compiler will throw an error if we make the following expression:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, we can assign the value of the `unique_ptr` to another object since
    it has been allocated. To prove it, we have added a copy constructor to log when
    the following expression is executed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we run the preceding `unique_ptr_2.cpp` code, we will see the following
    output on the screen:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33ba25b-3a90-47b9-a234-0d796c2c263e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the copy constructor is called when
    the copy assignment is executed. It proves that we can copy the value of the `unique_ptr`
    object but not the object itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed earlier, `unique_ptr` has moved the constructor, although it
    has no copy constructor. The use of this construction can be found in the following
    piece of code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code, we have two new functions--`GetBodyMass()` and `UpdateBodyMass()`.
    We construct a new `unique_ptr` object from the `GetBodyMass()` function, then
    we update the value of its *Weight* using the `UpdateBodyMass()` function. We
    can see that we use the `move` function when we pass an argument to the `UpdateBodyMass()`
    function. It''s because `unique_ptr` has no copy constructor, and it has to be
    moved in order to update the value of its property. The screen output of the preceding
    code is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5188478c-d944-4612-b5cf-2b73c89a204d.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Sharing objects using shared_ptr
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In contrast to `unique_ptr`, `shared_ptr` implements shared ownership semantics,
    so it offers the ability of copy constructor and copy assignment. Although they
    have a difference in the implementation, `shared_ptr` is actually the counted
    version of `unique_ptr`. We can call the `use_count()` method to find out the
    counter value of the `shared_ptr` reference. Each instance of the `shared_ptr`
    valid object is counted as one. We can copy the `shared_ptr` instance to other
    `shared_ptr` variables and the reference count will be incremented. When a `shared_ptr`
    object is destroyed, the destructor decrements the reference count. The object
    will be deleted only if the count reaches zero. Now let''s examine the following
    `shared_ptr` code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Before we examine each line of the preceding code, let''s take a look at the
    following output that should appear on the console window:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88c9cd88-ace1-4cb8-a3bf-bd423b32376a.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: First, we create a `shared_ptr` object named `sp1` without instantiating it.
    From the console, we see that `sp1` is not initialized and the counter is still
    `0`. It is also not unique since the pointer is pointed to nothing. We then construct
    `sp1` using the `make_shared` method. Now, `sp1` is initialized and the counter
    becomes `1`. It also becomes unique since it's only one of the `shared_ptr` object
    (proven by the value of the counter that is `1`). Next, we create another variable
    named `sp2`, and copy `sp1` to it. As a result, `sp1` and `sp2` now share the
    same object proven by the counter and the uniqueness value. Then, invoking the
    `reset()` method in `sp2` will destroy the object of `sp2`. Now, the counter of
    `sp1` becomes `1`, and it is unique again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In the `shared_ptr_1.cpp` code, we declare the `unique_ptr` object using `shared_ptr<int>`,
    then invoke `make_shared<int>` to instance the pointer. It's because we just need
    to analyze the `shared_ptr` behavior. However, we should use `make_shared<>` for
    shared pointers since it has to keep the reference counter somewhere in memory
    and allocates the counter and memory for objects together instead of two separate
    allocations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the objects using a weak_ptr pointer
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed the `shared_ptr` in the preceding section. The pointer is
    actually a little bit fat pointer. It logically points to two objects, the object
    being managed and the pointing counter using the `use_count()` method. Every `shared_ptr`
    basically has a strong reference count that prevents the object from being deleted
    and a weak reference count that does not prevent the object being deleted if the
    `shared_ptr` object''s use count reaches 0, although we don''t even use the weak
    reference count. For this reason, we can use only one reference count so we can
    use the `weak_ptr` pointer. The `weak_ptr` pointer refers to an object that is
    managed by `shared_ptr`. The advantage of `weak_ptr` is that it can be used to
    refer to an object, but we can only access it if the object still exists and without
    preventing the object from being deleted by some other reference holder if the
    strong reference count reaches zero. It is useful when we deal with data structures.
    Let''s take a look at the following block of code to analyze the use of `weak_ptr`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before we analyze the preceding code, let''s take a look at the following screenshot
    from the output console if we run the code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed5b0412-e22b-4ff3-86b2-2cb32d2480b7.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: At first, we instantiate `shared_ptr` and, as we discussed previously, the `weak_ptr`
    points to the object managed by `shared_ptr`. We then assign `wp` to the `shared_ptr`
    variable, `sp`. After we have a `weak_ptr` pointer, we then check its behavior.
    By calling the `expired()` method, we can figure out whether the referenced object
    was already deleted. And, since the `wp` variable is just constructed, it is not
    expired yet. The `weak_ptr` pointer also holds the value of the object counting
    by calling the `use_count()` method, as we used in `shared_ptr`. We then invoke
    the `locked()` method to create a `shared_ptr` that manages the referenced object
    and finds the value `weak_ptr` is pointing at. We now have a `shared_ptr` variable
    pointing to the address that holds the `1234` value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We reset `sp` to `nullptr` afterward. Although we don't touch the `weak_ptr`
    pointer, it is also changed. As we can see from the console screenshot, now `wp`
    is expired since the object has been deleted. The counter also changes and becomes
    `0` since it points to nothing. Moreover, it is unlocked since the `shared_ptr`
    object has been deleted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Storing many different data types using tuples
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will get acquainted with tuples, an object that is able to hold a collection
    of elements, and each element can be of a different type. It is a new feature
    in C++11 and gives power to functional programming. The tuples will be most useful
    when creating a function that returns the value. Moreover, since functions don''t
    change the global state in functional programming, we can return the tuples for
    all the values we need to change instead. Now, let''s examine the following piece
    of code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, we created two tuples, `t1` and `t2`, with different
    constructing techniques using `tuple<int, string, bool>` and `make_tuple`. However,
    these two different techniques will give the same result. Obviously, in the code,
    we access each element in tuples using `get<x>(y)`, where `x` is the index and
    `y` is the tuple object. And, with confidence, we will get the following result
    on the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1853ef6-56aa-4020-949d-d1e527e4f8ff.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Unpacking tuples values
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another useful member that functions in the tuples classes is `tie()`, which
    is used to unpack a tuple into individual objects or create a tuple of `lvalue`
    references. Also, we have the `ignore` helper class in tuples, a placeholder to
    skip an element when unpacking a tuple is using `tie()`. Let''s see the use of
    `tie()` and `ignore` in the following block of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding code, we have the same two tuples that `tuples_1.cpp` has.
    We want to unpack `t1` into variables `i`, `s`, and `b` respectively, using the
    `tie()` method. Then, we unpack `t2` to the `s` variable only, ignoring the `int`
    and `bool` data in `t2`. If we run the code, the output should be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb5b261a-d591-4942-8062-caadadba0aac.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Returning a tuple value type
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, we can maximize the use of tuples in functional programming
    when we want to write a function that returns multiple data. Let''s take a look
    at the following block of code to know how to return the tuple and access the
    return value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see in the preceding code, we have a new function named `GetData()`
    returning a `Tuple` value. From that function, we will consume the data returning
    from it. We begin with creating the name variable and get the value from the `GetData()`
    function. We can also use the `tie()` method to unpack the tuple coming from the
    `GetData()` function, as we can see in the code when we access the data when ID
    = `2`. The output on the console should be like the following screenshot when
    we run the code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f46900eb-e1ba-4d02-9f88-af7b6a43b879.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have refreshed our experience in the C++ language by completing this chapter.
    Now we know that C++ is more modern, and it comes with numerous features that
    assist us in creating a better program. We can use the Standard Library to make
    our code efficient since we don't need to write too many redundant functions.
    We can use the Lambda expression to make our code tidy, easy to read, and easy
    to maintain. We can also use the smart pointer so we don't need to worry about
    memory management anymore. Moreover, as we are concerned about immutability in
    functional programming, we will discuss that deeper in the next chapter; the use
    of tuples can help us ensure that no global state is involved in our code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss First-Class and Pure Function, which is
    used to purify our class and ensure that no outside state is involved in the current
    function. As a result, it will avoid side effects in our functional code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
