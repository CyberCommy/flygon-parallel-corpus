- en: Chapter 4. Building Custom Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main objective of this chapter is to develop a custom widget that can perform
    a spatial query and display the results in a simple HTML table. In the process
    of building the custom widget, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a simple class using dojo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure dojo globally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the lifecycle of a dojo widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a template widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to provide support for internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize the dojo code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the draw toolbar works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build the custom widget using all the features discussed in the chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dojo classes provide a way to inherit and extend other modules to use templating
    as well as create widgets. Classes in dojo reside within a module and the module
    returns the class declaration. To declare classes within a module, we need to
    load a module named `dojo/_base/declare`, which provides support for declaring
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a simple dojo class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple class](graphics/B04959_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, `declare` is the callback function decoration for the `dojo/_base/declare`
    module. The class declaration accepts three arguments: *classname*, *superclass*,
    and *properties*.'
  prefs: []
  type: TYPE_NORMAL
- en: The classname argument is optional. When a classname string is provided, the
    declaration is called a **named class**. When it is omitted, as in our case, it
    is called an **anonymous class**. We will stick with using anonymous classes for
    a while as named classes must be used only under particular conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The superclass is the module or an array of modules that we would like to extend.
    If the superclass argument is null (as in our snippet), it means that our class
    declaration itself is a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument in the class declaration is the class properties. We can
    define the class constructor, other class properties, and class methods here.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dojo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dojo has a global object named `dojoConfig` which holds all the configuration
    parameters. We can modify the `dojoConfig` object to configure options and default
    behavior for the various aspects of the dojo toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: The `dojoConfig` object lets us define the location for the custom modules defined
    in our web application and tags it with a package name. So, when we need to load
    these custom modules, we can refer to the folder location using the package name
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dojoConfig` object must be declared before referencing the Esri JS API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring dojo](graphics/B04959_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are other configuration options such as `async`, `parseOnLoad`, `waitSeconds`,
    and `cacheBust`. For detailed information on the `dojoConfig` topic, refer to
    the dojo toolkit documentation at [https://dojotoolkit.org/documentation/tutorials/1.10/dojo_config/](https://dojotoolkit.org/documentation/tutorials/1.10/dojo_config/).
  prefs: []
  type: TYPE_NORMAL
- en: The `async` option defines whether the dojo core should be loaded asynchronously.
    The recommended value is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `locale` option lets us override the default language provided to dojo by
    the browser. This will help us develop the app for a different target locale and
    test our widgets for the internationalization support using dojo's `i18n` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cacheBust` option is a very useful option, which when configured to `true`,
    appends the time string to each URL from the module, thus avoiding module caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how these options work out for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Configuring dojo](graphics/B04959_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Effect of configuring cacheBust to True in the dojoConfig object
  prefs: []
  type: TYPE_NORMAL
- en: Developing a standalone widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developing standalone widgets is the main purpose of writing classes in dojo.
    Dojo exclusively provides us a module for supporting the development of widgets:
    `dijit/_WidgetBase`. We also need other ancillary modules such as `dijit` templating
    modules, the dojo parse, and dojo internationalization modules to develop a full-fledged
    widget in a web application.'
  prefs: []
  type: TYPE_NORMAL
- en: The key aspect associated with the `WidgetBase` module is the concept of the
    life cycle of a widget. The widget life cycle gives us methods to work with during
    the different stages of the widget, that is, from the initialization of the widget,
    to the stage when its `dom` nodes are fully loaded and utilizable by the application,
    until the destruction of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module should be passed in as a superclass array in the class declaration.
    Here is the snippet for a basic widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The dijit life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `_WidgetBase` option provides several methods that the program flow will
    execute in a particular sequence. Some of the most important methods executed
    in order are shown in the following infographic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dijit life cycle](graphics/B04959_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The widget lifecycle infographic
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**constructor**: This is the first method called when the widget is instantiated.
    The `constructor` function can used as a special property named `domNode`. This
    can contain the value of the reference to `domNode` where the widget will be placed.
    The first argument for the `constructor` function will be an `options` object
    to which we can send any object value we would like to send to the widget:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**postCreate**: This method is executed just after all the properties of the
    widget are executed. All the event handlers for the widget will be defined here.
    A particular line of code should be added in the `postCreate()` method so that
    all the definitions made in `WidgetBase` will be inherited properly. In the following
    code snippet, the particular line of code has been highlighted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**postCreate()**: This method is also the right place to host the special `this.own()`
    method. The event handler defined within this method will release event handles
    when the instance of the widget is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Startup**: This method is fired after the dom nodes are constructed. So,
    any modification to the dom node will be done here. This is the method through
    which the widget will be called externally for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating templated widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templated widgets are ones that allow the developer to load an HTML file as
    a template string at runtime. All the dom nodes specific to the widget should
    be defined in this HTML template. Dojo provides two more modules to make our experience
    of using templates easier and more efficient. These modules are named `dijit/_TemplatedMixin`
    and `dijit/_WidgetsInTemplateMixin`. Apart from these two modules, we also need
    to load a dojo plugin named `dojo/text!`, which actually loads the HTML page as
    a template string. The way the plugin works is that the HTML file path should
    be appended after the exclamation (`!`) in `dojo/text!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The class properties should include a specific property named `templateString`.
    The value of the this property will be the callback function decoration used to
    represent the `dojo/text!<filename.html>` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a basic code snippet that covers all the topics discussed previously
    and tries to develop a template widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating templated widgets](graphics/B04959_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our template file is very innocuous, containing a simple `h1` header tag. It
    is this HTML string that the `templateString` property holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `app_widgets/widgettemplate/template/_widget.html` file
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how to instantiate this widget. As mentioned earlier, we need
    to call the `startup` method in the widget to execute this widget. We will call
    this from another JavaScript file, which will pass a reference to the dom node
    where our widget will be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating templated widgets](graphics/B04959_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of /js/widgets/app.js
  prefs: []
  type: TYPE_NORMAL
- en: 'This file will be called from the `index.html` file, which has the `dom` element
    named `templatedWidgetDiv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Widget folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to discuss the widget folder structure. When developing large
    projects, the folder structure is an important part of the project-building exercise
    that we need to define at the initial stage of the project itself. We will be
    providing general guidelines on how to decide upon the folder structure. This
    can be modified to suit your preferences and project needs.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for creating project folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The guideline for creating project folders are describe in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Guidelines for creating project folders](graphics/B04959_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's discuss each of these in a detailed manner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a single point of entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need not crowd the index page with all widget instantiation. It's better
    if we can define a module that can serve as the single point of entry to instantiate
    all the widgets we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML page will only contain a reference to the JS API and this single point
    of entry JavaScript module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the file serving as the single-point-of-entry are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a single point of entry](graphics/B04959_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining dojoConfig
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed this earlier. The `dojoConfig` object will be declared in the index
    page itself. This is a global object whose values can be accessed anywhere in
    the program by loading the module named `dojo/_base/config`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the core tenet of the AMD pattern of coding. The concept of modularizing
    means that we should decouple any code that is functionally different. As we know,
    the dojo modules return a publicly accessible object. This object can be a class
    declaration, as we saw earlier. A different use of the module is that this can
    be used as a configuration file for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample `config` file that has been created off a dojo module has been provided
    for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Providing support for internationalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Customizing the text that is shown in the app according to the locale of the
    user is known as **internationalization**. Dojo provides a plugin named `dojo/i18n!`
    to provide this support. When we mention plugin, it means that it expects a file
    path as an argument after the exclamation mark (`!`). The file path refers to
    a JavaScript module, which mentions an object named `root` and lists all the supported
    locales.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `dojo/i18n!app_widgets/widget_i18n/nls/strings` refers to the `strings`
    module defined within the `app_widgets/widget_i18n/nls` folder (remember that
    `app_widgets` is the name package referring to the `/js/widgets` location).
  prefs: []
  type: TYPE_NORMAL
- en: The current locale is determined by the user's browser. A `locale` in dojo is
    usually a five-letter string; the first two characters represent the language,
    the third character is a hyphen, and the last two characters represent the country.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `en-us` value represents English as the language and the US as the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ja-jp` value represents Japanese as the language and Japan as the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `zh-cn` value represents Simplified Chinese as the language and China as
    the country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `zh-tw` value represents Simplified Chinese as the language and Taiwan as
    the country![Providing support for internationalization](graphics/B04959_04_09.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to provide internationalization support
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The steps to provide internationalization support are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `nls` in the folder where the widget resides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a module that has an object named `root` and lists all the locales supported
    below the `root` object. For example, take a look at the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `root` object will contain all the string variables for which language support
    is provided, for example, `widgetTitle` and `description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder for each locale defined, such as `zh-cn` and `de-at`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a module with the same name as that of the `root` module in each of the
    `language` folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new modules will contain all the properties of the `root` object. The value
    of the properties will contain the language-specific translation of the corresponding
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the module named `dojo/i18n!` appended with the path to the root module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `declare` constructor, assign the `callback` function declaration of
    the `i18n` module to the property named `this.nls`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An overview of the widget folder structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s review the `widget` folder structure once again so that we can use this
    as a template before starting any project:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a main file (say `index.html`). The main file should have the `dojoConfig`
    object, a reference to all the CSS used in the app, and the Esri CSS. It should
    also have a reference to the API and a reference to the module, which serves as
    the point of entry (`app.js`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All widgets go into the `js` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the site-wide CSS and images go into the `CSS` and `image` folders in the
    application `root` directory, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the widgets will be placed within the `widgets` folder inside the `js` folder.
    Each widget can be placed within a separate folder within the `widgets` folder
    too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Templates will be placed inside the `template` folder within the `widget` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the resources needed for internationalization within a folder named `nls`:![An
    overview of the widget folder structure](graphics/B04959_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building a custom widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will extend the app that we developed in the last chapter with advanced
    functionalities and modularized code refactoring. Let''s create a custom widget
    in the app that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the user to draw a polygon on the map. The polygon will be symbolized
    by a semi-transparent red fill and a dashed yellow outline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The polygon should fetch all the major wildfire events within the boundary of
    the polygon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This shall be shown as a graphic and the data should be in a grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization support must be provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules required for the widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's list the modules required to define classes and their corresponding intended
    callback function decoration.
  prefs: []
  type: TYPE_NORMAL
- en: Modules for the class declaration and OOPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/_base/declare` | `declare` |'
  prefs: []
  type: TYPE_TB
- en: '| `dijit/_WidgetBase` | `_WidgetBase` |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/_base/lang` | `lang` |'
  prefs: []
  type: TYPE_TB
- en: Modules for using HTML templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dijit/_TemplatedMixin` | `_TemplatedMixin` |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/text!` | `dijitTemplate` |'
  prefs: []
  type: TYPE_TB
- en: Module for using event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/on` | `on` |'
  prefs: []
  type: TYPE_TB
- en: '| `dijit/a11yclick` | `a11yclick` |'
  prefs: []
  type: TYPE_TB
- en: Modules for manipulating dom elements and their styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/dom-style` | `domStyle` |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/dom-class` | `domClass` |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/domReady!` |   |'
  prefs: []
  type: TYPE_TB
- en: Modules for using the draw toolbar and displaying graphics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/toolbars/draw` | `Draw` |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/symbols/SimpleFillSymbol` | `SimpleFillSymbol` |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/symbols/SimpleLineSymbol` | `SimpleLineSymbol` |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/graphic` | `Graphic` |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/_base/Color` | `Color` |'
  prefs: []
  type: TYPE_TB
- en: Modules for querying data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/tasks/query` | `Query` |'
  prefs: []
  type: TYPE_TB
- en: '| `esri/tasks/QueryTask` | `QueryTask` |'
  prefs: []
  type: TYPE_TB
- en: Modules for internationalization support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dojo/i18n!` | `nls` |'
  prefs: []
  type: TYPE_TB
- en: Using the draw toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The draw toolbar enables us to draw graphics on the map. This toolbar has events
    associated with it. When a draw operation is completed, it returns the object
    drawn on the map as geometry. Follow these steps to create a graphic using the
    draw toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the draw toolbar](graphics/B04959_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initiating the draw toolbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The draw toolbar is provided by the module called `esri/toolbars/draw`. The
    draw toolbar accepts the map object as an argument. Instantiate the draw toolbar
    within the `postCreate` function. The draw toolbar also accepts an additional
    optional argument named `options`. One of the properties in the `options` object
    is named `showTooltips`. This can be set to `true` so that we can see a tooltip
    associated while drawing. The text in the tooltip can be customized. Otherwise,
    a default tooltip associated with draw geometry is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The draw toolbar can be activated on the `click` or `touch` event (in case of
    smart phones or tablets) of a button, which is intended to indicate the start
    of a `draw` event. Dojo provides a module that takes care of `touch` as well as
    `click` events. The module is named `dijit/a11yclick`.
  prefs: []
  type: TYPE_NORMAL
- en: To activate the draw toolbar, we need to provide the type of symbol to draw.
    The draw toolbar provides a list of constants, which corresponds to the type of
    the draw symbol. These constants are `POINT`, `POLYGON`, `LINE`, `POLYLINE`, `FREEHAND_POLYGON`,
    `FREEHAND_POLYLINE`, `MULTI_POINT`, `RECTANGLE`, `TRIANGLE`, `CIRCLE`, `ELLIPSE`,
    `ARROW`, `UP_ARROW`, `DOWN_ARROW`, `LEFT_ARROW`, and `RIGHT_ARROW`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While activating the draw toolbar these constants must be used to define the
    type of the draw operation required. Our objective is to draw a polygon at the
    click of a draw button. The code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initiating the draw toolbar](graphics/B04959_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The draw operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the draw toolbar is activated, the draw operation begins. For point geometry,
    the draw operation is just a single click. For a polyline and a polygon, the single
    click adds a vertex to the polyline, and a double-click ends the sketch. For a
    freehand polyline or polygon, the `click` and `drag` operation draw the geometry
    and a `mouse-up` operation ends the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The draw-end event handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the draw operation is complete, we need an event handler to do something
    with the shape that was drawn by the draw toolbar. The API provides a `draw-end`
    event, which is fired once the draw operation is complete. This event handler
    must be connected to the draw toolbar. This event handler will be defined within
    the `this.own()` function inside the `postCreate()` method of the widget. The
    event result can be passed to a named or anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Symbolizing the drawn shape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `draw-end` event callback function, we will get the geometry of the drawn
    shape as the result object. To add this geometry back to the map, we need to symbolize
    it. A symbol is associated with the geometry that it symbolizes. Also, the styling
    of the symbol is defined by the colors or pictures used to fill up the symbol
    and its size. Just to symbolize a polygon, we need to use the `SimpleFillSymbol`
    and `SimpleLineSymbol` modules. We may also need the `esri/color` module to define
    the fill colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a snippet to understand this better. This is a simple snippet
    used to construct a symbol for a polygon with a semi-transparent solid red color
    fill and a yellow dash-dot line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolizing the drawn shape](graphics/B04959_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, `SimpleFillSymbol.STYLE_SOLID` and `SimpleLineSymbol.STYLE_DASHDOT`
    are the constants provided by the `SimpleFIllSymbol` and `SimpleLineSymbol` modules
    respectively. These constants are used to style the polygon and the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two colors are defined in the construction of the symbol: one for filling up
    the polygon and the other for coloring the outline. A color can be defined by
    four components. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Red
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red, green, and blue components takes values from `0` to `255` and the opacity
    takes a value from `0` to `1`. A combination of red, green, and blue components
    can be used to produce any color according to the RGB color theory. So, to create
    a yellow color, we use the maximum of red component (`255`) and the maximum of
    green component (`255`); we don't want the blue component to contribute to our
    color, so we use `0`. An opacity value of `0` means 100% transparency, and an
    opacity value of `1` means 100% opaqueness. We have used `0.2` for the fill color.
    This means that we need our polygon to be 20% opaque, or 80% transparent. The
    default value for this component is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: A symbol is just a generic object. This means any polygon geometry can use the
    symbol to render itself. Now, we need a container object to display the drawn
    geometry with the previously defined symbol on the map. A graphic object provided
    by the `esri/Graphic` module acts as a container object, which can accept a geometry
    and symbol. The graphic object can be added to the map's graphic layer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A graphic layer is always present in the map object, which can be accessed by
    using the `graphics` property of the map (`this.map.graphics`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolizing the drawn shape](graphics/B04959_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing the query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The widget''s main function is to define and execute a query based on the user''s
    draw input. The following image will provide a general way for us to construct
    a `querytask` and handle the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing the query](graphics/B04959_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initializing the QueryTask and Query object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will be working with Active Wildfire feature layers that we used in the
    previous chapter. When providing the input geometry, we will be using the geometry
    that we got from the `draw-end` event instead of using the map''s current extent
    geometry, like we did in the previous chapter. We will be fetching all the features
    within the draw geometry, hence we will be using the truthy expression (`1=1`)
    as the `where` clause. The following lines of code explain how the `query` object
    is constructed and how the `queryTask` is executed and stored as a deferred variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Query event handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `execute` method on the `QueryTask` object returns a deferred variable.
    This means that we should use the `.then()` operation to elicit the task execution
    result. The success handler returns a `featureset`. A `featureset` is an array
    of features. A feature contains a graphic as well as some attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are two operations that we needs to perform to display the query
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight the query result by symbolizing it appropriately and adding it as
    appropriate graphics on the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the details of Active Wildfires satisfying the query conditions in a simple
    HTML table. The HTML table should come from an HTML template file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the HTML template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need an HTML template to render the widget. This widget will have the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: A button whose `click` event will toggle the draw event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button to clear the draw graphic, as well as the result graphic and the HTML
    table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `dom` element to hold onto the HTML table being constructed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot explains how the HTML template is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the HTML template](graphics/B04959_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This HTML file should be loaded as a plugin using the `dojo/text!` plugin.
    Once this is done, all the `dom` elements referred by `dojo-attach-point` can
    be accessed in the code using this notation. Also, functions to handle the click
    events for the `toggleDraw` button and the `clear` button should be implemented.
    The following screenshot shows a barebones implementation of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the HTML template](graphics/B04959_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Symbolizing query results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The features returned by the query are wildfire locations, all of which have
    a point geometry. We can use `SimpleMarkerSymbol` or `PictureMarkerSymbol` to
    symbolize features returned by the query. The `PictureMarker` symbol accepts the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`angle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xoffset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yoffset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use a PNG resource, which is part of the application to define `PictureMarkerSymbol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding the graphics to the map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All the query result features should be converted into a graphic with the `PictureMarkerSymbol`
    that we just defined. Additionally, we will also be adding an `infotemplate` to
    each graphic. The `infotemplate` content will be taken from query result attributes.
    The HTML table can also be constructed by iterating through the features returned
    by the query result object. The following screenshot illustrates the entire process
    clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the graphics to the map](graphics/B04959_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete code listing can be found in the folder called `B049549_04_CODE02`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create classes and custom widgets in dojo,
    and you also learned about the life cycle of a dojo widget. Then, we walked through
    the guidelines for creating a folder structure for any dojo-related project. We
    also looked at how we can provide support for different languages using the internationalization
    feature provide by the dojo module. Finally, we created a custom widget that uses
    a draw tool to accept a user-drawn polygon and uses it to query a feature layer.
    We showed the results in an HTML table as well as on the map. In the following
    chapters, we will be dealing with how to symbolize the graphics better and intuitively
    using a technique known as rendering. Rendering is a great visualization technique
    that lets us define rules to symbolize features differently, based on the value
    of a particular attribute in the feature. In further chapters, we will be extending
    the visualization techniques to cover non-spatial representations of data such
    as charts and graphs.
  prefs: []
  type: TYPE_NORMAL
