- en: Chapter 2. Real-World Objects to UML Diagrams and Java 9 via JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to recognize objects from real-life situations.
    We will understand that working with objects makes it simpler to write code that
    is easier to understand and reuse. We will learn how to recognize real-world elements
    and translate them into the different components of the object-oriented paradigm
    supported in Java 9\. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify objects from applications requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture objects from the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate classes to create objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize variables and constants to create fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify actions to create methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize classes with UML diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use feedback from domain experts to improve our classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with Java objects in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying objects from applications requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you have to solve a problem in the real world, you use elements and
    interact with them. For example, when you are thirsty, you take a glass, fill
    it up with water, soda, or your favorite juice, and then you drink. Similarly,
    you can easily recognize elements, known as objects, from real-world scenarios
    and then translate them into object-oriented code. We will start learning the
    principles of object-oriented programming to use them in the Java 9 programming
    language to develop any kind of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will imagine we have to develop a RESTful Web Service that will be consumed
    by mobile apps and a web application. These apps and applications will have different
    user interfaces and diverse user experiences. However, we don't have to worry
    about these differences because we will be focused on the Web Service, that is,
    we will be backend developers.
  prefs: []
  type: TYPE_NORMAL
- en: Artists use different combinations of geometric shapes and organic shapes to
    create art. Of course, creating art is a bit more complex than this simple definition,
    but our goal is to learn object-oriented programming and not to become experts
    in art.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geometric shapes are made of points and lines, and they are precise. The following
    are examples of geometric shapes: circles, triangles, squares, rectangles.'
  prefs: []
  type: TYPE_NORMAL
- en: Organic shapes are shapes that have a natural look and have a curving appearance.
    These shapes are usually irregular or asymmetrical. We usually associate things
    from the natural world, such as animals and plants, with organic shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When artists want to create abstract interpretations of things that would normally
    require organic shapes, they use geometric shapes. Imagine that Vanessa Pitstop
    is a painter and craftswoman. She started uploading videos about her artwork to
    Instagram and YouTube a few years ago and reaches a great milestone in her artistic
    career: San Francisco Museum of Modern Art prepares an exhibition of her most
    important artwork. This special event generated a huge impact on social networking
    sites and, as usually happens, there is a new software development task related
    to this important boost in popularity.'
  prefs: []
  type: TYPE_NORMAL
- en: Pitstop is an extremely popular YouTuber and her channel has more than four
    million followers. Many Hollywood actresses bought their artwork and uploaded
    selfies on Instagram with her artwork as a background. Her exhibition generated
    a huge additional interest in her creations and one of the sponsors wants to create
    mobile apps and a web application that reproduce her artwork based on geometric
    shapes and provide details about the all the tools and the acrylic paint that
    the user needs to buy to produce the artwork.
  prefs: []
  type: TYPE_NORMAL
- en: Pitstop sketches basic shapes and then paints them with acrylic paint to build
    geometric patterns. The mobile app and the web application will use our Web Service
    to build Pitstop's predefined patterns, based on the canvas size and some predefined
    color schemes selected by the user. Our Web Service will receive the canvas size
    and the color scheme to generate the pattern and a bill of materials. Specifically,
    the Web Service will provide a list of the different tools and the acrylic paint
    tubes, jars, or bottles that the user must buy to paint the drawn pattern. Finally,
    the user will be able to place an online order to request all of some of the suggested
    materials.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a first example of Pitstop's artwork with geometric
    patterns. Let's take a look at the image and extract the objects that compose
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying objects from applications requirements](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following objects compose the geometric pattern, specifically, the following
    2D shapes from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28 circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 28 circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is fairly simple to describe 108 objects or 2D shapes that compose the pattern.
    We were able to recognize all these objects and to indicate the specific 2D shape
    for each of them. If we measure each triangle, we will realize they are equilateral
    triangles.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a second example of Pitstop's artwork with geometric
    patterns. Let's take a look at the image and extract the objects that compose
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying objects from applications requirements](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following objects compose the geometric pattern, specifically, the following
    2D shapes from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 regular pentagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 24 regular hexagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 24 regular hexagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 regular pentagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This time, we could describe 100 objects or 2D shapes that compose the pattern.
    We were able to recognize all these objects and indicate the specific 2D shape
    for each of them. If we measure each pentagon and hexagon, we will realize they
    are regular pentagons and hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a third example of Pitstop's artwork with geometric
    patterns. In this case, we have a huge number of 2D shapes. Let's take a look
    at the image and just extract the different 2D shapes included in the pattern.
    This time, we won't count the number of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying objects from applications requirements](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The pattern includes the following 2D shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular pentagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular hexagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular heptagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular octagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular decagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following image shows a fourth example of Pitstop's artwork with geometric
    patterns. In this case, we also have a huge number of 2D shapes and some of them
    intersect with each other. However, we will still be able to recognize the different
    2D shapes if we pay some attention. Let's take a look at the image and just extract
    the different 2D shapes included in the pattern. We won't count the number of
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying objects from applications requirements](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The pattern includes the following 2D shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular pentagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular decagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular octagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following image shows a fifth example of Pitstop's artwork with geometric
    patterns. In this case, we will recognize the shapes from left to right because
    the pattern has a different orientation. We have many shapes that intersect with
    each other. Let's take a look at the image and just extract the different 2D shapes
    included in the pattern. We won't count the number of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying objects from applications requirements](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The pattern includes the following 2D shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular octagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular octagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing real-world objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could easily recognize objects from Pitstop''s artwork. We understood that
    each pattern is composed of many 2D geometric shapes and we recognized the different
    shapes that she used in all the examples we analyzed. Now, let''s focus on one
    of the core requirements for the Web Service, which is calculating the required
    amounts of acrylic paint to produce the artwork. We must take into account the
    following data for each 2D shape included in the pattern in order to calculate
    the required materials and the amount of acrylic paint to produce each shape:'
  prefs: []
  type: TYPE_NORMAL
- en: The line color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The perimeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fill color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to use a specific color for the line that draws the borders of
    each shape, and therefore, we have to calculate the perimeter to use it as one
    of the values that will allow us to estimate the amount of acrylic paint that
    the user must buy to paint the border of each 2D shape. Then, we have to calculate
    the area to use it as one of the values that will allow us to estimate the amount
    of acrylic paint that the user must buy to fill the area of each 2D shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to start working on the backend code for our Web Service that calculates
    areas and perimeters for the different 2D shapes we have recognized in all the
    sample artwork we have analyzed so far. We conclude that the Web Service must
    support patterns with the following nine shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equilateral triangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular pentagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular hexagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular octagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular decagons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After doing some research to refresh our minds about 2D geometry, we can start
    writing Java 9 code. Specifically, we might write nine methods that calculate
    the areas of the previously enumerated 2D shapes and another nine to calculate
    their perimeters. Note that we are talking about methods that would return the
    calculated value, also known as functions. We stopped thinking about objects,
    and therefore, we will face some problems with this path, which we will solve
    with an object-oriented approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we start thinking about methods to solve the problem, one possible
    solution is to code the following eighteen functions to do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calculateCircleArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateEllipseArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateEquilateralTriangleArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateSquareArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRectangleArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularPentagonArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularHexagonArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularOctagonArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularDecagonArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateCirclePerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateEllipsePerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateEquilateralTrianglePerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateSquarePerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRectanglePerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularPentagonPerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularHexagonPerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularOctagonPerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateRegularDecagonPerimeter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the previously enumerated methods has to receive the necessary parameters
    of each shape and return either its calculated area or perimeter. These functions
    do not have side effects, that is, they do not make changes to the parameters
    they receive and they just return the results of the calculated areas or perimeters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's forget about methods or functions for one moment. Let's go back to
    the real-world objects from the Web Service requirements that we were assigned.
    We have to calculate the areas and perimeters of nine elements, which are nine
    nouns in the requirements that represent real-life objects, specifically 2D shapes.
    We have already built a list with nine real-world objects.
  prefs: []
  type: TYPE_NORMAL
- en: After recognizing the real-life objects and thinking a bit about them, we can
    start designing our Web Service by following an object-oriented paradigm. Instead
    of creating a set of methods that perform the required tasks, we can create software
    objects that represent the state and behavior of each of the enumerated 2D shapes.
    This way, the different objects mimic the real-world 2D shapes. We can work with
    the objects to specify the different attributes required to calculate the area
    and perimeter. Then, we can extend these objects to include the additional data
    required to calculate other required values, such as the quantity of acrylic paint
    required to paint the borders.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move to the real world and think about each of the previously enumerated
    nine shapes. Imagine that we have to draw each of the shapes on paper and calculate
    their areas and perimeters. After we draw each shape, which values will we use
    to calculate their areas and perimeters? Which formulas will we use?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started working on an object-oriented design before we started coding, and
    therefore, we will work as if we didn't know many concepts of geometry. For example,
    we can easily generalize the formulas that we use to calculate the perimeters
    and areas of regular polygons. However, in most cases we won't be experts on the
    subject and we have to gain some knowledge on the application domain before we
    can generalize behavior with an object-oriented approach. Thus, we will dive deeper
    into the subject as if we had little knowledge on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows a drawn circle and the formulas that we will use
    to calculate its perimeter and area. We just need the radius value, usually identified
    as **r**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn ellipse and the formulas that we will use
    to calculate its perimeter and area. We need the values for the semimajor axis
    (usually labelled as **a**) and semiminor axis (usually labelled as **b**). Notice
    that the formula provided for the perimeter provides an approximation that is
    not very accurate. We will dive deeper on this specific problem later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn equilateral triangle and the formulas that
    we will use to calculate its perimeter and area. This type of triangle has equal
    sides, and the three internal angles are equal to 60 degrees. We just need the
    length of side value, usually identified as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn square and the formulas that we will use
    to calculate its perimeter and area. We just need the length of side value, usually
    identified as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn rectangle and the formulas that we will use
    to calculate its perimeter and area. We need the width and height values, usually
    identified as **w** and **h**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn regular pentagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn regular hexagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn regular octagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a drawn regular decagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing real-world objects](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table summarizes the data required for each shape to calculate
    its perimeter and area:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Shape | Required data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Circle | Radius |'
  prefs: []
  type: TYPE_TB
- en: '| Ellipse | Semimajor and semiminor axes |'
  prefs: []
  type: TYPE_TB
- en: '| Equilateral triangle | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: '| Square | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: '| Rectangle | Width and height |'
  prefs: []
  type: TYPE_TB
- en: '| Regular pentagon | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: '| Regular hexagon | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: '| Regular octagon | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: '| Regular decagon | Length of a side |'
  prefs: []
  type: TYPE_TB
- en: Each object that represents a specific shape encapsulates the required data
    that we identified. For example, an object that represents an ellipse will encapsulate
    the ellipse's semimajor and semiminor axes values, while an object that represents
    a rectangle will encapsulate the rectangle's width and height values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Data encapsulation** is one of the major pillars of object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating classes to create objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to draw and calculate the perimeters and areas of three
    different rectangles. You will end up with three rectangles drawn with their widths
    and height values and their calculated perimeters and areas. It would be great
    to have a blueprint to simplify the process of drawing each rectangle with their
    different width and height values.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, a **class** is a template definition or blueprint
    from which objects are created. Classes are models that define the state and behavior
    of an object. After declaring a class that defines the state and behavior of a
    rectangle, we can use it to generate objects that represent the state and behavior
    of each real-world rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects are also known as instances. For example, we can say each `rectangle`
    object is an instance of the `Rectangle` class.
  prefs: []
  type: TYPE_NORMAL
- en: The following picture shows two rectangle instances named `rectangle1` and `rectangle2`.
    These instances are drawn with their width and height values specified. We can
    use a `Rectangle` class as a blueprint to generate the two different `Rectangle`
    instances. Note that `rectangle1` has the width and height values of `36` and
    `20`, and `rectangle2` has the width and height values of `22` and `41`. Each
    instance has different values for their width and height. It is very important
    to understand the difference between a class and the objects or instances generated
    through its usage. The object-oriented programming features supported in Java
    9 allow us to discover which blueprint we used to generate a specific object.
    We will use these features in many examples in the upcoming chapters. Thus, we
    can determine whether each object is an instance of the `Rectangle` class or not.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating classes to create objects](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows two regular pentagon instances named `pentagon1`
    and `pentagon2`. These instances are drawn with their length of side values specified.
    We can use a `RegularPentagon` class as a blueprint to generate the two different
    `RegularPentagon` instances. Note that `pentagon1` has the length of a side value
    of `20`, and `pentagon2` has the length of a side value of `16`. Each instance
    has different values for its length of a side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating classes to create objects](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows four ellipse instances named `ellipse1`, `ellipse2`,
    `ellipse3`, and `ellipse4`. These instances are drawn with their semimajor axis
    and semiminor axis values specified. We can use an `Ellipse` class as a blueprint
    to generate the four different `Ellipse` instances. Note that each ellipse has
    its own specific values for the semimajor and semiminor axes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating classes to create objects](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We recognized nine completely different real-world objects from the Web Service
    requirements, and therefore, we can generate the following nine classes to create
    the necessary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Circle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ellipse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EquilateralTriangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Square`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularPentagon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularHexagon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularOctagon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularDecagon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the usage of **Pascal case** for class names. Pascal case means that the
    first letter of each word that composes the name is capitalized, while the other
    letters are in lowercase. This is a coding convention in Java. For example, we
    use the `EquilateralTriangle` name for the class that will be the blueprint that
    will allow us to generate multiple equilateral triangles.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing variables and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know the information required for each of the shapes to achieve our goals.
    Now, we have to design the classes to include the necessary fields that provide
    the required data to each instance. We have to make sure that each class has the
    necessary fields that encapsulate all the data required by the objects to perform
    all the tasks based on our application domain.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `Circle` class. We need to know the radius for each instance
    of this class, that is, for each circle object. Thus, we need an encapsulated
    variable that allows each instance of the `Circle` class to specify the value
    for the radius.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variables defined in a class to encapsulate the data for each instance of
    the class in Java 9 are known as **fields**. Each instance has its own independent
    value for the fields defined in the class. The fields allow us to define the characteristics
    for an instance of the class. In other programming languages that support object-oriented
    principles, these variables defined in a class are known as **attributes**.
  prefs: []
  type: TYPE_NORMAL
- en: The `Circle` class defines a floating point field named `radius`, whose initial
    value is equal to `0` for any new instance of the class. After we create an instance
    of the `Circle` class, it is possible to change the value of the `radius` attribute.
    Thus, our circle can become smaller or larger after we created it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the usage of **Camel case** for field names. Camel case means that the
    first letter is lowercase, and then, the first letter for each word that composes
    the name is capitalized, while the other letters are in lowercase. It is a coding
    convention in Java for both variables and fields. For example, we use the name
    `radius` for the field that stores the value of the radius and we will use `lengthOfSide`
    for the property that stores the value of the length of side in other classes
    that require this data.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we create two instances of the `Circle` class. One of the instances
    is named `circle1` and the other `circle2`. The instance names allow us to access
    the encapsulated data for each object, and therefore, we can use them to change
    the values of the exposed fields.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 uses a dot (`.`) to allow us to access the properties of instances. So,
    `circle1.radius` provides access to the radius for the `Circle` instance named
    `circle1`, and `circle2.radius` does the same for the `Circle` instance named
    `circle2`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the naming convention makes it easy for us to differentiate an instance
    name, that is, a variable, from a class name. Whenever we see the first letter
    in uppercase or capitalized, it means that we are talking about a class, as in
    `Circle` or `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: We can assign `14` to `circle1.radius` and `39` to `circle2.radius`. This way,
    each `Circle` instance will have a different value for the `radius` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the `Rectangle` class. We have to define two floating point
    fields for this class: `width` and `height`. Their initial values will also be
    `0`. Then, we can create four instances of the `Rectangle` class named `rectangle1`,
    `rectangle2`, `rectangle3`, and `rectangle4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign the values summarized in the following table to the four instances
    of the `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instance name | `width` | `height` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `rectangle1` | `141` | `281` |'
  prefs: []
  type: TYPE_TB
- en: '| `rectangle2` | `302` | `162` |'
  prefs: []
  type: TYPE_TB
- en: '| `rectangle3` | `283` | `73` |'
  prefs: []
  type: TYPE_TB
- en: '| `rectangle4` | `84` | `214` |'
  prefs: []
  type: TYPE_TB
- en: This way, `rectangle1.width` will be equal to `141`, while `rectangle4.width`
    will be equal to `84`. The `rectangle1` instance represents a rectangle with `width`
    of `141` and `height` of `281`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the floating point fields defined for each of
    the nine classes that we need for our Web Service backend code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Fields list |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Circle` | `radius` |'
  prefs: []
  type: TYPE_TB
- en: '| `Ellipse` | `semiMinorAxis` and `semiMajorAxis` |'
  prefs: []
  type: TYPE_TB
- en: '| `EquilateralTriangle` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: '| `Square` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: '| `Rectangle` | `width` and `height` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegularPentagon` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegularHexagon` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegularOctagon` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegularDecagon` | `lengthOfSide` |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fields are members of their respective classes. However, fields aren't the
    only members that classes can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that six of these classes have the same field: `lengthOfSide`, specifically,
    the following six classes: `EquilateralTriangle`, `Square`, `RegularPentagon`,
    `RegularHexagon`, `RegularOctagon`, and `RegularDecagon`. We will dive deep into
    what these six classes have in common later and take advantage of object-oriented
    features to reuse code and simplify our Web Service maintenance. However, we are
    just starting our journey, and we will make improvements as we learn additional
    object-oriented features included in Java 9\. In fact, let''s remember we are
    learning about the application domain and that we are still not experts in 2D
    shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows a **UML** (**Unified Modeling Language**) class diagram
    with the nine classes and their fields. This diagram is very easy to understand.
    The class name appears on the top of the rectangle that identifies each class.
    A rectangle below the same shape that holds the class name displays all the field
    names exposed by the class with a plus sign (**+**) as a prefix. This prefix indicates
    that what follows it is an attribute name in UML and a field name in Java 9\.
    Take into account that the next UML diagram doesn't represent the best organization
    for our classes. It is just the first sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing variables and constants](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Identifying actions to create methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we designed nine classes and identified the necessary fields for each
    of them. Now, it is time to add the necessary pieces of code that work with the
    previously defined fields to perform all the necessary tasks, that is, to calculate
    perimeters and areas. We have to make sure that each class has the necessary encapsulated
    functions that process the property values specified in the objects to perform
    all the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's forget a bit about similarities between the different classes. We will
    work with them individually as if we didn't have the necessary knowledge of geometric
    formulas. We will start with the `Circle` class. We need pieces of code that allow
    each instance of this class to use the value of the `radius` property to calculate
    the area and perimeter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions defined in a class to encapsulate the behavior of each instance
    of the class are known as **methods**. Each instance can access the set of methods
    exposed by the class. The code specified in a method can work with the fields
    specified in the class. When we execute a method, it will use the fields of the
    specific instance. Whenever we define methods, we must make sure that we define
    them in a logical place, that is, in the place where the required data is kept.
  prefs: []
  type: TYPE_NORMAL
- en: When a method doesn't require parameters, we can say that it is a **parameterless**
    method. In this case, all the methods we will initially define for the classes
    will be parameterless methods that just work with the values of the previously
    defined fields and use the formulas previously shown in the figures when we analyzed
    each 2D shape in detail. Thus, we will be able to call these methods without arguments.
    We will start creating methods, but we will be able to explore additional options
    based on specific Java 9 features later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Circle` class defines the following two parameterless methods. We will
    declare the code for both methods within the definition of the `Circle` class
    so that they can access the `radius` property value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calculateArea`: This method returns a floating point value with the calculated
    area for the circle. It returns Pi (`π`) multiplied by the square of the `radius`
    field value (*π * radius*² or *π * (radius ^ 2)*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculatePerimeter`: This method returns a floating point value with the calculated
    perimeter for the circle. It returns Pi (`π`) multiplied by 2 times the `radius`
    field value (*π * 2 * radius*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java 9, `Math.PI` provides us with the value for Pi. The `Math.pow` method
    allows us to calculate the value of a first argument raised to the power of the
    second argument. We will learn how to code these methods in Java 9 later.
  prefs: []
  type: TYPE_NORMAL
- en: These methods do not have side effects, that is, they do not make changes to
    the related instance. The methods just return the calculated values, and therefore,
    we consider them non-mutating methods. Their operation is naturally described
    by the `calculate` verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 9 uses a dot (`.`) to allow us to execute the methods of the instances.
    Imagine that we have two instances of the `Circle` class: `circle1` with the `radius`
    property equal to `5` and `circle2` with the `radius` property equal to `10`.'
  prefs: []
  type: TYPE_NORMAL
- en: If we call `circle1.calculateArea()`, it will return the result of *π * 5*²,
    which is approximately `78.54`. If we call `square2.calculateArea()`, it will
    return the result of *π * 10*², which is approximately `314.16`. Each instance
    has a diverse value for the `radius` attribute, and therefore, the results of
    executing the `calculateArea` method are different for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: If we call `circle1.calculatePerimeter()`, it will return the result of *π *
    2 * 5*, which is approximately `31.41`. On the other hand, if we call `circle2.calculatePerimeter()`,
    it will return the result of *π *2 * 10*, which is approximately `62.83`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the `Rectangle` class. We need exactly two methods with
    the same names specified for the `Circle` class: `calculateArea` and `calculatePerimeter`.
    In addition, the methods return the same type and don''t need parameters, so we
    can declare both of them as parameterless methods, as we did in the `Circle` class.
    However, these methods have to calculate the results in a different way; that
    is, they have to use the appropriate formulas for a rectangle and take into account
    the values for the `width` and `height` fields. The other classes also need the
    same two methods. However, each of them will use the appropriate formulas for
    the related shape.'
  prefs: []
  type: TYPE_NORMAL
- en: We have a specific problem with the `calculatePerimeter` method that the `Ellipse`
    class generates. Perimeters are extremely complex to calculate for ellipses, so
    there are many formulas that provide approximations. An exact formula requires
    an infinite series of calculations. We will use an initial formula that isn't
    very accurate but we will find a workaround for this situation later and we will
    improve the results. The initial formula will allow us to return a floating point
    value with the calculated approximation of the perimeter for the ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an updated version of the UML diagram with the
    nine classes, their attributes, and their methods. It shows the results of the
    second round:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying actions to create methods](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Organizing classes with UML diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our object-oriented solution includes nine classes with their fields
    and methods. However, if we take another look at these nine classes, we will notice
    that all of them have the same two methods: `calculateArea` and `calculatePerimeter`.
    The code for the methods in each class is different because each shape uses a
    special formula to calculate either the area or perimeter. However, the declarations,
    contracts, interfaces, or protocols for the methods are the same. Both methods
    have the same name, are always parameterless, and return a floating point value.
    Thus, all of them return the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: When we talked about the nine classes, we said we were talking about nine different
    geometrical 2D shapes or simply shapes. Thus, we can generalize the required behavior,
    protocol, or interface for these nine shapes. The nine shapes must define the
    `calculateArea` and `calculatePerimeter` methods with the previously explained
    declarations. We can create an interface to make sure that the nine classes provide
    the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is a special class named `Shape`, and it generalizes the requirements
    for the geometrical 2D shapes in our application. In this case, we will work with
    a special class that we won''t use to create instances, but in the future, we
    will use interfaces for the same goal. The `Shape` class declares two parameterless
    methods that return a floating point value: `calculateArea` and `calculatePerimeter`.
    Then, we will declare the nine classes as subclasses of the `Shape` class, which
    will inherit these definitions, and provide the specific code for each of these
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The subclasses of `Shape` (`Circle`, `Ellipse`, `EquilateralTriangle`, `Square`,
    `Rectangle`, `RegularPentagon`, `RegularHexagon`, `RegularOctagon`, and `RegularDecagon`)
    implement the methods because they provide code while maintaining the same method
    declarations specified in the `Shape` superclass. **Abstraction** and **hierarchy**
    are two major pillars of object-oriented programming. We are just making our first
    steps in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming allows us to discover whether an object is an instance
    of a specific superclass. After we change the organization of the nine classes
    and they become subclasses of `Shape`, any instance of `Circle`, `Ellipse`, `EquilateralTriangle`,
    `Square`, `Rectangle`, `RegularPentagon`, `RegularHexagon`, `RegularOctagon`,
    or `RegularDecagon` is also an instance of the `Shape` class.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it isn't difficult to explain the abstraction because we speak the
    truth about the object-oriented model when we say that it represents the real
    world.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to say that a regular decagon is indeed a shape, and therefore,
    an instance of `RegularDecagon` is also an instance of the `Shape` class. An instance
    of `RegularDecagon` is both a `Shape` (the superclass of `RegularDecagon`) and
    a `RegularDecagon` (the class that we used to create the object).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an updated version of the UML diagram with the superclass
    or base class (`Shape`), its nine subclasses, and their attributes and methods.
    Note that the diagram uses a line that ends in an arrow that connects each subclass
    to its superclass. You can read the line that ends in an arrow as the following:
    the class where the line begins *is a subclass of* the class that has the line
    ending with an arrow. For example, `Circle` is a subclass of `Shape`, and `Rectangle`
    is a subclass of `Shape`. The diagram shows the results of the third round.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing classes with UML diagrams](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A single class can be the superclass of many subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Using feedback from domain experts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to have a meeting with our domain expert, that is, someone
    that has an excellent knowledge of 2D geometry. We can use the UML diagram to
    explain the object-oriented design for the solution. After we explain the different
    classes that we will use for abstracting the behavior, the domain expert explains
    to us that there are many shapes that have something in common and that we can
    generalize the behavior even further. The following six shapes are regular polygons:'
  prefs: []
  type: TYPE_NORMAL
- en: An equilateral triangle (the `EquilateralTriangle` class) has three sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A square (the `Square` class) has four sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular pentagon (the `RegularPentagon` class) has five sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular hexagon (the `RegularHexagon` class) has six sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular octagon (the `RegularOctagon` class) has eight sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular decagon (the `RegularDecagon` class) has ten sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular polygons are polygons that are both equiangular and equilateral. All
    the sides that compose a regular polygon have the same length and are placed around
    a common center. This way, all the angles between any two sides are equal.
  prefs: []
  type: TYPE_NORMAL
- en: The following picture shows the six regular polygons and the generalized formulas
    that we can use to calculate their perimeters and areas. The generalized formula
    to calculate the area requires us to calculate a cotangent, which is abbreviated
    as **cot** in the formula.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using feedback from domain experts](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java 9, the `Math` class doesn''t provide a method to directly calculate
    a cotangent. However, it provides a method to calculate a tangent: `Math.tan`.
    The cotangent of `x` is equal to `1` divided by the tangent of `x`: `1/ Math.tan(x)`.
    Thus, we can easily calculate the cotangent with this formula.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the three shapes use the same formula with just a different value for the
    number of sides (**n**) parameter, we can generalize the required interface for
    the six regular polygons. The interface is a special class named `RegularPolygon`
    that defines a new `getSidesCount` method that returns the number of sides with
    an integer value. The `RegularPolygon` class is a subclass of the previously defined
    `Shape` class. It makes sense because a regular polygon is indeed a shape. The
    six classes that represent regular polygons become subclasses of `RegularPolygon`.
    However, both the `calculateArea` and `calculatePerimeter` methods are coded in
    the `RegularPolygon` class using the generalized formulas. The subclasses code
    the `getSidesCount` method to return the right value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EquilateralTriangle`: 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Square`: 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularPentagon`: 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularHexagon`: 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularOctagon`: 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularDecagon`: 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RegularPolygon` class also defines the `lengthOfSide` property that was
    previously defined in the three classes that represent regular polygons. Now,
    the six classes become subclasses of `RegularPolygon` and inherit the `lengthOfSide`
    property. The following figure shows an updated version of the UML diagram with
    the new `RegularPolygon` class and the changes in the six classes that represent
    regular polygons. The six classes that represent regular polygons do not declare
    either the `calculateArea` or `calculatePerimeter` methods because these classes
    inherit them from the `RegularPolygon` superclass and don't need to make changes
    to these methods that apply a general formula.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows the results of the fourth round.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using feedback from domain experts](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we analyzed ellipses, we mentioned that there was a problem when calculating
    its perimeter. We talked with our domain expert and he provided us with detailed
    information about the issue. There are many formulas that provide approximations
    of the perimeter value for this shape. It makes sense to add additional methods
    that calculate the perimeter using other formulas. He suggested us to make it
    possible to calculate the perimeters with the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: A formula proposed by *David W. Cantrell*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second version of the formula developed by *Srinivasa Aiyangar Ramanujan*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will define the following two additional parameterless methods to the `Ellipse`
    class. The new methods will return a floating point value and solve the specific
    problem of the ellipse shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calculatePerimeterWithRamanujanII`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculatePerimeterWithCantrell`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, the `Ellipse` class will implement the methods specified in the `Shape`
    superclass and also add two specific methods that aren't included in any of the
    other subclasses of `Shape`. The following figure shows an updated version of
    the UML diagram with the new methods for the `Ellipse` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows the results of the fifth round:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using feedback from domain experts](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects are also known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following class names follows the Pascal case convention and would
    be an appropriate name for a class in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`regularDecagon`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RegularDecagon`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Regulardecagon`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code specified in a method within a class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can access the fields specified in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cannot interact with other members of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cannot access the fields specified in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The functions defined in a class to encapsulate behavior for each instance
    of the class are known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherits only methods from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherits only fields from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherits all members from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The variables defined in a class to encapsulate data for each instance of the
    class in Java 9 are known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The variables defined in a class to encapsulate data for each instance of the
    class in Java 9 are known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following field names follows the Camel case convention and would
    be an appropriate name for a field in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SemiMinorAxis`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`semiMinorAxis`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`semiminoraxis`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to recognize real-world elements and translate
    them into the different components of the object-oriented paradigm supported in
    Java 9: classes, fields, methods, and instances. You understood that the classes
    represent blueprints or templates to generate the objects, also known as instances.'
  prefs: []
  type: TYPE_NORMAL
- en: We designed a few classes with fields and methods that represent blueprints
    for real-life objects, specifically, 2D shapes. Then, we improved the initial
    design by taking advantage of the power of abstraction and specialized different
    classes. We generated many versions of the initial UML diagram as we added superclasses
    and subclasses. We understood the application domain and we made changes to the
    original design as our knowledge increased and we realized we were able to generalize
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned some of the basics of the object-oriented paradigm,
    we are ready to start creating classes and instances in Java 9 with JShell, which
    is what we are going to discuss in the next chapter. It is time to start object-oriented
    coding!
  prefs: []
  type: TYPE_NORMAL
