- en: Chapter 10. Multithreading in Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in games – creating a thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining and detaching a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data race and mutex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a thread-safe class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand multithreading, let us first understand the meaning of threads.
    A thread is a concurrent unit of execution. It has its own call stack for methods
    being invoked, their arguments, and local variables. Each application has at least
    one thread running when it is started, the main thread. When we talk about multithreading,
    it means one process has many threads running independently and concurrently,
    but with shared memory. Often, multithreading is confused with multi-processing.
    A multiprocessor has multiple processes running, each with its own thread.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Although multithreaded applications may be complex to write, they are lightweight.
    However, a multithreaded architecture is not well suited for a distributed application.
    In games, we may have one or more threads running. The golden question is when
    and why should we use multithreading. Although this is quite subjective, you would
    use multithreading if you want multiple tasks to happen concurrently. So if you
    do not want your physics code, or audio code in the game, to wait for the main
    loop to finish processing, you would multithread the physics and the audio loop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in games – creating a thread
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step of writing multithreaded code is to spawn a thread. At this point,
    we must note that the application is already running an active thread, the main
    thread. So when we spawn a thread, there will be two active threads in the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio. No other prerequisites are required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to spawn a thread. Add a source
    file called `Source.cpp` and add the following code to it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to include the header file, `thread.h`. This gives us access
    to all the inbuilt libraries that we may need to create our multithreaded application.
    The next step is to create the task or the function that we need to thread. In
    this example, we have created a function called `ThreadOne`. This function represents
    any function that we can use to multithread. This could be a physics function,
    or audio, or anything that we may desire. For simplicity, we have used a function
    that prints a message. The next step is to spawn a thread. We simply need to write
    the keyword `thread`, assign a name to the thread (`T1`) and then write the function/task
    that we want to thread. In this case, it is `ThreadOne`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This spawns a thread and will not execute independently of the main thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Joining and detaching a thread
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a thread is spawned, it starts executing as a new task, separate from
    the main thread. However, there may be situations in which we want the task to
    rejoin the main thread. This is possible. We may also want that the thread always
    stays apart from the main thread. That is also possible. However, there are a
    few precautions that we must take when attaching to and detaching from the main
    thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine and Visual Studio.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we will see how easy it is to join and detach threads. Add a
    source file called `Source.cpp`. Add the following code to it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, at first two threads are spawned. The two threads
    are `T1` and `T2`. When the threads are spawned, they act independently and concurrently.
    However, when there is a need for any thread to be joined back to the main thread,
    we can do that as well. First, we need to check whether the thread can be joined
    to the main thread. We accomplish this with the joinable function. If the function
    returns `true`, the thread can join to the main thread. We can join to the main
    thread with the `join` function. If we directly join, without first checking whether
    the thread can join to the main thread, it may cause issues with the main thread
    failing to accept the thread. After the thread joins to the main thread, the main
    thread waits for that thread to finish.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If we want to detach a thread from the main thread, we can use the `detach`
    function. However, after we detach it from the main thread, it is detached forever.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to a thread
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in functions, we may also want to send parameters and arguments to the
    thread. As threads are just tasks, and tasks are just a collection of functions,
    it is necessary to understand how to send arguments to a thread. If we can send
    arguments to a thread at runtime, then the thread can perform all the operations
    dynamically. In most cases, we would thread the physics, AI, or audio sections
    of the code. All these sections would require functions that take in arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine and a working copy of Visual Studio. No other prerequisites
    are required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to add a heuristic function
    to our game for pathfinding. Add a source file called `Source.cpp`. Add the following
    code to it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to do pass arguments is to write a `Wrapper` class and overload
    the `()` operator. After we overload the `()` operator, we can send arguments
    to the thread. To do this, we create a string and store the string in a variable.
    Then we need to spawn a thread as usual; however, instead of just passing in the
    function name, we pass in the class name and the string. In threads, we need to
    pass the arguments by reference, so we could use the `ref` function. However,
    a better way to do this is by using the `move` function, where we note the memory
    location itself and pass it to the argument. The `operator` function accepts the
    string and prints the message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: If we want to create a new thread and make it the same as the first thread,
    we can again use the `move` function to do this. In addition to this, we can get
    the thread's ID by using the `get_id` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When two or more tasks want to use the same resource, we have a race condition.
    Until one task finishes using the resource, the other task cannot get access to
    it. This is known as a **deadlock**, and we must avoid deadlocks at all costs.
    For example, resource `Collision` and resource `Audio` are used by process `Locomotion`
    and process `Bullet`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`Locomotion` starts to use `Collision`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Locomotion` and `Bullet` try to start using `Audio`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bullet` "wins" and gets `Audio` first'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now `Bullet` needs to use `Collision`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collision` is locked by `Locomotion`, which is waiting for `Bullet`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed copy of Visual
    Studio.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to avoid deadlocks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we have spawned a thread, `t1`, which starts a function
    to print numbers from 0 to -100, decreasing by 1\. There is also a main thread,
    which starts to print numbers from 0 to 100, increasing by 1\. Again, we have
    chosen these functions for simplicity of understanding. These could easily be
    replaced by an *A** algorithm and a search algorithm, or anything we want.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the console output, we notice that it is quite messy. The reason
    for that is the `cout` object is being used by both the main thread and `t1`.
    Hence there is a data race condition taking place. Whoever is winning at each
    turn is getting to display the number. We must avoid this kind of programming
    structure at all costs. More often than not, it will cause a deadlock and disruption.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Data race and mutex
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data race conditions are very common in multithreaded applications, but we must
    avoid such a scenario so that deadlocks do not happen. A **mutex** helps us to
    overcome deadlocks. A mutex is a program object that allows multiple program threads
    to share the same resource, such as file access, but not simultaneously. When
    a program is started, a mutex is created with a unique name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to understand data races and mutexes.
    Add a source file called `Source.cpp` and add the following code to it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, both the main thread and `t1` want to display some numbers.
    However, as both of them want to use the `cout` object, it creates a data race
    situation. To avoid this, one approach is to use mutex locks. So before executing
    the `print` statement, we have `mutex.lock`, and after the `print` statement,
    we have `mutex.unlock`. This will work, and prevent the data race condition, as
    mutex will allow one thread to use the resource and make the other thread wait
    for it. However, this program is not yet thread safe. This is because if the `cout`
    statement throws an error or exception, the mutex will never get unlocked and
    the other threads will always be in a `wait` state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, we will use the **Resource Acquisition is Initialization technique**
    (**RAII**) of C++. We add an inbuilt lock guard to the function. This code is
    exception-safe because C++ guarantees that all stack objects are destroyed at
    the end of the enclosing scope, known as **stack unwinding**. The destructors
    of both the lock and file objects are therefore guaranteed to be called when returning
    from the function, whether an exception has been thrown or not. Therefore, it
    will not stop other threads from waiting eternally if an exception has occurred.
    Despite doing this, this application is not thread safe. This is because the `cout`
    object is a global object, so other parts of the program can access it as well.
    Therefore, we need to encapsulate this even further. This we will see later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Writing a thread-safe class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with multiple threads, writing a thread-safe class becomes an absolute
    must. If we do not write classes that are thread safe, there are many complications
    that may arise, such as deadlocks. We must also keep in mind that when we write
    a thread-safe class, there is no potential danger from data races and mutex.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version Visual
    Studio.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to write a thread safe class in
    C++. Add a source file called `Source.cpp` and add the following code to it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how, despite writing a mutex and locks, our code
    was not thread safe. This is because we were using a global object, `cout`, which
    could be accessed from other parts of the code as well and so was not thread safe.
    So we have avoided doing this by adding one more layer of abstraction and outputting
    the result to a log file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class called `Logfile`. Inside this class, we have created
    a lock guard and a mutex. On top of that, we have also created a stream object
    called `f`. Using this, we output the contents to a text file. The threads that
    need access to this functionality will need to create an object of the `LogFile`
    and then use the function appropriately. We are using the lock guard in the RAII
    system. Because of this layer of abstraction, there is no chance that the functionality
    can be used externally and it is quite safe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`Logfile`的类。在这个类里，我们创建了一个锁保护和一个互斥锁。除此之外，我们还创建了一个名为`f`的流对象。使用这个对象，我们将内容输出到一个文本文件中。需要访问这个功能的线程将需要创建一个`LogFile`对象，然后适当地使用这个函数。我们在RAII系统中使用了锁保护。由于这种抽象层，外部无法使用这个功能，因此是非常安全的。
- en: However, even in this program, we need to take certain precautions. The first
    precaution that we should take is that we should not return `f` from any function.
    Also, we have to be careful that `f` should not be directly available from any
    other class or external function. If we do either of the above, the resource `f`
    will again be available to external sections of the program, will not be protected,
    and will therefore no longer be thread safe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在这个程序中，我们也需要采取一定的预防措施。我们应该采取的第一项预防措施是不要从任何函数中返回`f`。此外，我们必须小心，`f`不应该直接从任何其他类或外部函数中获取。如果我们做了上述任何一项，资源`f`将再次可用于程序的外部部分，将不受保护，因此将不再是线程安全的。
