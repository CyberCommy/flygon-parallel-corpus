- en: '*Chapter 2*: Making Your Programs Easy to Script'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux and other **Unix** systems have strong **scripting** support. The whole
    idea of Unix, from the very beginning, was to make a system easy to develop on.
    One of these features is to take the output of one program and make it the input
    of another program—hence building new tools with existing programs. We should
    always keep this in mind when creating programs for Linux. The Unix philosophy
    is to make small programs that do one thing only—and do it well. By having many
    small programs that do only one thing, we can freely choose how to combine them.
    And by combining small programs, we can write shell scripts—a common task in Unix
    and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach us how to make programs that are easy to script and
    easy to interact with other programs. That way, other people will find them much
    more useful. It's even likely they will find new ways of using our programs that
    we haven't even thought of, making the programs more popular and easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Return values and how to read them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting a program with a relevant return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting stdin, stdout, and stderr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting programs using pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to stdout and stderr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from stdin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a pipe-friendly program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting the result to file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All you need for this chapter is a Linux computer with GCC and Make installed,
    preferably via one of the meta-packages or group installs mentioned in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*. It's also preferable if you use the *Bash
    shell* for optimal compatibility. Most of the examples will work with other shells
    as well, but there's no guarantee that everything will work the same way on every
    possible shell out there. You can check which shell you are using by running `echo
    $SHELL` in your terminal. If you are using Bash, it will say `/bin/bash`.
  prefs: []
  type: TYPE_NORMAL
- en: You can download all the code for this chapter from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u5VItw](https://bit.ly/3u5VItw)'
  prefs: []
  type: TYPE_NORMAL
- en: Return values and how to read them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`return`. It''s that same `return` statement we use to return a value from
    `main()` to the shell. The original Unix operating system and the C programming
    language came around at the same time and from the same place. As soon as the
    C language was completed in the early 1970s, Unix was rewritten in C. Previously,
    it was written in assembler only. And hence, C and Unix fit together tightly.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason why return values are so crucial in Linux is that we can build shell
    scripts. Those shell scripts use other programs and, hopefully, our programs,
    as its parts. For the shell script to be able to check whether a program has succeeded
    or not, it reads the return value of that program.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will write a program that tells the user if a file or directory
    exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's recommended that you use Bash for this recipe. I can't guarantee compatibility
    with other shells.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write a small **shell script** that demonstrates the
    purpose of the return values, how to read them, and how to interpret them. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write the code, we must investigate what return values the program
    uses that we will use in our script. Execute the following commands, and make
    a note of the return values we get. The `test` command is a small utility that
    tests certain conditions. In this example, we''ll use it to determine if a file
    or directory exists. The `-e` option stands for *exists*. The `test` command doesn''t
    give us any output; it just exits with a return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know what return values the `test` program gives us (0 when the
    file or directory exists, otherwise 1), we can move on and write our script. Write
    the following code in a file and save it as `exist.sh`. You can also download
    it from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh).
    The shell script uses the `test` command to determine whether the specified file
    or directory exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to make it *executable* with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to try out our script. We try it with directories that do exist
    and with those that don''t. We also check the exit code after each run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that it''s working and leaving the correct exit codes, we
    can write `echo` to print a text stating whether the file or directory exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write a more complicated one-liner—one that takes advantage of
    the unique error code 3 we assigned to "file not found" in our script. Note that
    you shouldn''t type `>` at the start of the second line. This character is automatically
    inserted by the shell when you end the first line with a backslash to indicate
    the continuation of a long line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `test` program is a small utility designed to test files and directories,
    compare values, and so on. In our case, we used it to test if the specified file
    or directory exists (`-e` for exist).
  prefs: []
  type: TYPE_NORMAL
- en: The `test` program doesn't print anything; it just exits in silence. It does,
    however, leave a return value. It is that return value that we check with the
    `$?` variable. It's also the very same variable we check in the script's `if`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other special variables in the script that we used. The first
    one was `$#`, which contains the number of `argc` in C. At the very start of the
    script, we compared if `$#` is *not equal* to 1 (`-ne` stands for *not equal*).
    If `$#` is not equal to 1, an error message is printed and the script aborts with
    code 1.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for putting `$#` inside quotes is just a safety mechanism. If, in
    some unforeseen event, `$#` were to contain spaces, we still want the content
    to be evaluated as a single value, not two. The same thing goes for the quotes
    around the other variables in the script.
  prefs: []
  type: TYPE_NORMAL
- en: The next special variable is `$0`. This variable contains argument 0, which
    is the name of the program, just as with `argv[0]` in C, as we saw *in* [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to the program is stored in `$1`, as shown in the `test`
    case. The first argument in our case is the supplied filename or directory that
    we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: Like our C programs, we want our scripts to exit with a relevant return value
    (or `exit` to leave the script and set a return value. In case the user doesn't
    supply precisely one argument, we exit with code 1, a general error code. And
    if the script is executed as it should, and the file or directory exists, we exit
    with code 0\. If the script is executed as it should, but the file or directory
    doesn't exist, we exit with code 3, which isn't reserved for a particular use,
    but still indicates an error (all *non-zero* codes are error codes). This way,
    other scripts can fetch the return value of our script and act upon it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 5*, we did just that—act upon the exit code from our script with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`&&` means "and". We can read the whole line as an `if` statement. If `exist.sh`
    is true—that is, exit code 0—then execute the `echo` command. If the `exit` code
    is anything other than 0, then the `echo` command is never executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 6*, we redirected all the output from the script to `/dev/null` and
    then used a complete `if` statement to check for error code 3\. If error code
    3 is encountered, we print a message with `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot more tests and comparisons we can do with the `test` program.
    They are all listed in the manual; that is, `man 1 test`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with Bash and shell scripting, there is a lot of useful
    information in the manual page, `man 1 bash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of `&&` is `||` and is pronounced "or." So, the opposite of what
    we did in this recipe would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to dig deep into the world of Bash and shell scripting, there is
    an excellent guide at *The Linux Documentation Project*: https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html.'
  prefs: []
  type: TYPE_NORMAL
- en: Exiting a program with a relevant return value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to exit a C program with a relevant `return`
    fits together with the system from a broader perspective. We will also learn what
    some common return values mean.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we only need the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write two different versions of a program here to show you two different
    methods of exiting. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by writing the first version using `return`, which we have seen
    previously. But this time, we will use it to return from `main()` and eventually
    the `functions_ver1.c`. All the return statements are highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, **compile** it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it. Try to follow along and see which functions call and return to
    which other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the preceding program to use `exit()` inside the functions
    instead. What will happen then is that as soon as `exit()` is called, the program
    will `exit()` is called inside another function, that function will not return
    to `main()` first. Save the following program in a new file as `functions_ver2.c`.
    All the `return` and `exit` statements are highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile this version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it and see what happens (and compare the output from the previous
    program):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, check the return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that in C, 0 is regarded as *false* or error, while anything else is
    considered to be *true* (or correct). This is the opposite of the return values
    to the shell. This can be a bit confusing at first. However, as far as the shell
    is concerned, 0 is "all ok," while anything else indicates an error.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two versions is how the functions and the entire
    program returns. In the first version, each function returns to the calling function—in
    the order they were called. In the second version, each function exits with the
    `exit()` function. This means that the program will exit directly and return the
    specified value to the shell. The second version isn't good practice; it's much
    better to return to the calling function. If someone else were to use your function
    in another program, and it suddenly exits the entire program, that would be a
    big surprise. That's not usually how we do it. However, I wanted to demonstrate
    the difference between `exit()` and `return` here.
  prefs: []
  type: TYPE_NORMAL
- en: I also wanted to demonstrate another point. Just as a function returns to its
    calling function with `return`, a program returns to its parent process (usually
    the shell) in the same way. So, in a way, programs in Linux are treated as functions
    in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Bash calls the program (the upper arrow), which
    then starts in `main()`, which then calls the next function (the arrows to the
    right), and so on. The arrows returning on the left show how each function returns
    to the calling function, and then finally to Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.1_B13043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Calling and returning
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot more return codes we can use. The most common ones are the
    ones we''ve seen here; `0` for *ok* and `1` for *error*. However, all other codes
    except `0` mean some form of error. Code `1` is a general error, while the other
    error codes are more specific. There isn''t exactly a standard, but there are
    some commonly used codes. Some of the most common codes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.2_B13043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Common error codes in Linux and other UNIX-like systems
  prefs: []
  type: TYPE_NORMAL
- en: Except for these codes, there are some additional ones listed at the end of
    `/usr/include/sysexit.h`. The codes listed in that file range from `64` to `78`
    and address errors such as data format error, service unavailable, **I/O** errors,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting stdin, stdout, and stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to **redirect** *standard input*, *standard
    output*, and *standard error* to and from files. Redirecting data to and from
    files is one of the basic principles of Linux and other Unix systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**stdin** is the shorthand word for **standard input**. **stdout** and **stderr**
    are the shorthand words for **standard output** and **standard error**, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's best if we use the Bash shell for this recipe for compatibility purposes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the hang of redirections, we will be performing a bunch of experiments
    here. We are really going to twist and turn the redirections and see stdout, stderr,
    and stdin operate in all kinds of ways. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by saving a list of the files and directories in the top root
    directory. We can do this by redirecting standard output (stdout) from the `ls`
    command into a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take a look at the file with `cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the `wc` command to count lines, words, and characters. Remember
    to press *Ctrl + D* when you have finished typing in the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how `wc` works, we can redirect its input to come from a file
    instead—the file we created with the file listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What about standard error? Standard error is its own output stream, separated
    from standard output. If we redirect standard output and generate an error, we
    will still see the error message on the screen. Let''s try it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like standard output, we can redirect standard error. Notice that we don''t
    get any error message here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The error messages are saved in `errors.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even redirect standard output and standard error at the same time, to
    different files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also redirect standard output and error into the same file for convenience:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even redirect all three (stdin, stdout, and stderr) at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write to standard error from the shell to write error messages
    of our own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of printing a message to stderr from Bash is like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn''t prove that our hello message got printed to standard
    error. We can prove this by redirecting the standard output to a file. If we still
    see the error message, then it''s printed on standard error. When we do this,
    we need to wrap the first statement in parenthesis to separate it from the last
    redirect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Stdin, stdout, and stderr are represented by files in the `/dev` directory.
    This means we can even redirect stdin from a file. This experiment doesn''t do
    anything useful—we could have just typed `wc`, but it proves a point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this means that we can even redirect a standard error message back to
    standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standard output, or stdout, is where all the normal output from programs gets
    printed. Stdout is also referred to as **file descriptor** 1.
  prefs: []
  type: TYPE_NORMAL
- en: Standard error, or *stderr*, is where all error messages get printed. Stderr
    is also referred to as file descriptor 2\. That is why we used `2>` when we redirected
    stderr to a file. If we wanted to, for clarity, we could have redirected *stdout*
    as `1>` instead of just `>`. But the default redirection with `>` is stdout, so
    there is no need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: When we redirected both stdout and stderr in *Step 9*, we used an `&` sign.
    This reads as "stdout *and* stderr".
  prefs: []
  type: TYPE_NORMAL
- en: Standard input, or *stdin*, is where all input data is read from. Stdin is also
    referred to as file descriptor 0\. Stdin redirects with a `<`, but just as with
    stdout and stderr, we can also write it as `0<`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for separating the two outputs, stdout and stderr, is so that when
    we redirect the output from a program to a file, we should still be able to see
    the error message on the screen. We also don't want the file to be cluttered with
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Having separate outputs also makes it possible to have one file for the actual
    output, and another one as a log file for error messages. This is especially handy
    in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: You might have heard the phrase "*Everything in Linux is either a file or a
    process*". That saying is true. There is no other *thing* in Linux, except for
    files or processes. Our experiments with `/dev/stdout`, `/dev/stderr`, and `/dev/stdin`
    proved this. Files represent even the input and output of programs.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 11*, we redirected the output to the `/dev/stderr` file, which is standard
    error. The message, therefore, got printed on standard error.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 12*, we pretty much did the same thing but without using the actual
    device file. The funny-looking `1>&2` redirection reads as "*send standard output
    to standard error*".
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using `/dev/stderr`, for example, we could have used `/dev/fd/2`,
    where `/dev/fd/1`, and stdin, which is `/dev/fd/0`. So, for example, the following
    will print the list to stderr:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Just like we can send standard output to standard error with `1>&2`, we can
    do the opposite with `2>&1`, which means we can send standard error to standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting programs using pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to use **pipes** to connect programs. When we
    write our C programs, we always want to strive to make them easy to pipe together
    with other programs. That way, our programs will be much more useful. Sometimes,
    programs that are connected with pipes are called **filters**. The reason for
    this is that, often, when we connect programs with pipes, it is to filter or transform
    some data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in the previous recipe, it's recommended that we use the Bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to explore pipes in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are already familiar with `wc` and `ls` from the previous recipe. Here,
    we will use them together with a pipe to count the number of files and directories
    in the root directory of the system. The pipe is the vertical line symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make things a bit more interesting. This time, we want to list only
    **symbolic links** in the root directory (by using two programs with a pipe).
    The result will differ from system to system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only want the actual filenames, not the information about them. So,
    this time, we will add another program at the end called `awk`. In this example,
    we are telling `awk` to print the ninth field. One or more whitespaces separate
    each field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add another "`sed` – `s` means *substitute*. Then, we can tell `sed`
    that we want to substitute the start of the line (`^`) with the text `This is
    a link:`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of things are going on here, but don't feel discouraged if you don't get
    it all. The importance of this recipe is to demonstrate how to use a *pipe* (the
    vertical line symbol, `|`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the very first step, we counted the number of files and directories in the
    root of the filesystem using `wc`. When we run `ls` interactively, we get a nice-looking
    list that spans the width of our terminal. The output is also most likely color-coded.
    But when we run `ls` by redirecting its output through a pipe, `ls` doesn''t have
    a real terminal to output to, so it falls back to outputting the text one file
    or directory per line, without any colors. You can try this yourself if you like
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Since `ls` it outputting one file or directory per line, we can count the number
    of lines with `wc` (the `-l` option).
  prefs: []
  type: TYPE_NORMAL
- en: In the next step (*Step 2*), we used `grep` to only list links from the output
    of `ls -l`. Links in the output from `ls -l` start with the letter `l` at the
    start of the line. After that is the access rights, which for links is `rwx` for
    everyone. This is what we search for with `lrwx` with `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we only wanted the actual filenames, so we added a program called `awk`.
    The `awk` tool lets us single out a particular column or field in the output.
    We singled out the ninth column (`$9`), which is the filename.
  prefs: []
  type: TYPE_NORMAL
- en: By running the output from `ls` through two other tools, we created a list of
    only the links in the root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 3*, we added another tool, or filter as it sometimes called. This
    tool is `sed`, a *stream editor*. With this program, we can make changes to the
    text. In this case, we added the text `This is a link:` in front of every link.
    The following is a short explanation of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`s` means "substitute"; that is, we wish to modify some text. Inside the two
    first slashes (`/`) is the text or expressions that should match what we want
    to modify. Here, we have the beginning of the line, `^`. Then, after the second
    slash, we have the text that we want to replace the matched text with, up until
    the final slash. Here, we have the text `This is a link:`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beware of unnecessary piping; it''s easy to get caught up in endless piping.
    One silly—but instructive—example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We could leave out `cat` and still get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for this one (which I am guilty of myself from time to time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no reason to pipe the previous example at all. The `grep` utility
    can take a filename argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For anyone interested in the history of Unix and how far back pipes go, there
    is an exciting video from 1982 on YouTube, uploaded by AT&T: [https://www.youtube.com/watch?v=tc4ROCJYbm0](https://www.youtube.com/watch?v=tc4ROCJYbm0).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to stdout and stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to print text to both *stdout* and *stderr*
    in a C program. In the two previous recipes, we learned what stdout and stderr
    are, why they exist, and how to redirect them. Now, it's our turn to write correct
    programs that output error messages on standard error, and regular messages on
    standard output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to write output to both stdout and stderr in
    a C program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file called `output.c` and save it. In this program,
    we will write output using three different functions: `printf()`, `fprintf()`,
    and `dprintf()`. With `fprintf()`, we can specify a file stream such as stdout
    or stderr, while with `dprintf()`, we can specify the file descriptor (1 for stdout
    and 2 for stderr, just as we have seen previously):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program like you usually would:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that the regular messages are printed to stdout, we can send the error
    messages to `/dev/null`, a black hole in the Linux system. Doing this will only
    display the messages printed to stdout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will do the reverse; we will send the messages printed to stdout to
    `/dev/null`, showing only the error messages that are printed to stderr:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s send all messages, from both stdout and stderr, to `/dev/null`.
    This will display nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example, where we used `printf()`, doesn't contain anything new or
    unique. All output printed with the regular `printf()` function is printed to
    stdout.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we saw some new examples, including the two lines where we use `fprintf()`.
    That function, `fprintf()`, allows us to specify a `stdio.h`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at some examples of using `dprintf()`. This function allows
    us to specify a **file descriptor** to print to. We covered file descriptors in
    the previous recipes of this chapter, but we will discuss them in more depth later
    in this book. Three file descriptors are always open—0 (stdin), 1 (stdout), and
    2 (stderr)—in every program we write on Linux. Here, we printed the regular message
    to file descriptor (*fd* for short) 1, and the error message to file descriptor
    2.
  prefs: []
  type: TYPE_NORMAL
- en: To be correct in our code, we need to include the very first line (the `#define`
    line) for the sake of `dprintf()`. We can read all about it in the manual page
    (`man 3 dprintf`), under *Feature Test Macro Requirements*. The `_POSIX_C_SOURCE`,
    is for **POSIX** standards and compatibility. We will cover this in more depth
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When we tested the program, we verified that the regular messages got printed
    to standard output by redirecting the error messages to a file called `/dev/null`,
    showing only the messages printed to standard output. Then, we did the reverse
    to verify that the error messages got printed to standard error.
  prefs: []
  type: TYPE_NORMAL
- en: The special file, `/dev/null`, acts as a black hole in Linux and other Unix
    systems. Everything we send to that file simply disappears. Try it out with `ls
    / &> /dev/null`, for example. No output will be displayed since everything is
    redirected to the black hole.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned that three file streams are opened in a program, assuming it includes
    `stdio.h`, as well as three file descriptors. These three file descriptors are
    always opened, even if `stdio.h` is not included. If we were to include `unistd.h`,
    we could also use macro names for the three file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows these file descriptors, their macro names, and file
    streams, which are handy for future reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – File descriptors and file streams in Linux'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B13043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – File descriptors and file streams in Linux
  prefs: []
  type: TYPE_NORMAL
- en: Reading from stdin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to write a program in C that reads from standard
    input. Doing so enables your programs to take input from other programs via a
    *pipe*, making them easier to use as a filter, thus making them more useful in
    the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need the GCC compiler and preferably the Bash shell for this recipe,
    although it should work with any shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand the program that we are about to write, you should look
    at an ASCII table, an example of which can be found at the following URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write a program that takes single words as input, converts
    their cases (uppercase into lower and lowercase into upper), and prints the result
    to standard output. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code into a file and save it as `case-changer.c`. In this
    program, we use `fgets()` to read characters from stdin. We then use a `for` loop
    to loop over the input, character by character. Before we start the next loop
    with the next line of input, we must zero out the arrays using `memset()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it out by typing some words in it. Quit the program by pressing *Ctrl +
    D*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to *pipe* some input to it, for example, the first five lines from
    `ls`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to pipe some uppercase words into it from a manual page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we created two character **arrays** of 20 bytes each and initialize them
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used `fgets()`, wrapped in a `while` loop, to read characters from
    standard input. The `fgets()` function reads characters until it reaches a *newline*
    character or an `c` array, and also returned.
  prefs: []
  type: TYPE_NORMAL
- en: To read more input—that is, more than one word—we continue reading input with
    the help of the `while` loop. The `while` loop won't finish until we either press
    *Ctrl + D* or the input stream is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fgets()` function returns the character read on success and `NULL` on
    error or when an EOF occurs while no characters have been read (that is, no more
    input). Let''s break down the `fgets()` function so that we can understand it
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, `c`, is where we store the data. In this case, it's our
    character array.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument, `sizeof(c)`, is the maximum size we want to read. The `fgets()`
    function is safe here; it reads one less than the size we specify. In our case,
    it will only read 19 characters, leaving room for the **null character**.
  prefs: []
  type: TYPE_NORMAL
- en: The final and third argument, `stdin`, is the stream we want to read from—in
    our case, standard input.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `while` loop is where the case conversions are happening, character
    by character in the `for` loop. In the first `if` statement, we check if the current
    character is an uppercase one. If it is, then we add 32 to the character. For
    example, if the character is *A*, then it's represented by 65 in the **ASCII table**.
    When we add 32, we get 97, which is *a*. The same goes for the entire alphabet.
    It's always 32 characters apart between the uppercase and lowercase versions.
  prefs: []
  type: TYPE_NORMAL
- en: The next `if` statement does the reverse. If the character is a lowercase one,
    we subtract 32 and get the uppercase version.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are only checking characters between 65 and 90, and 97 and 122, all
    other characters are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Once we printed the result on the screen, we reset the character arrays to all
    zeros with `memset()`. If we don't do this, we will have leftover characters in
    the next run.
  prefs: []
  type: TYPE_NORMAL
- en: Using the program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We tried the program by running it interactively and typing words into it. Each
    time we hit the *Enter* key, the word is transformed; the uppercase letters will
    become lowercase and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we piped data to it from the `ls` command. That output got converted into
    uppercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we tried to pipe it uppercase words from the manual page (the headings).
    All the headings in a manual page are uppercase and start at the beginning of
    the line. This is what we "grep" for with `egrep`, and then pipe to our `case-changer`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about `fgets()`, see the manual page, `man 3 fgets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write a small program to print a minimum ASCII table for the letters
    *a-z* and *A-Z*. This small program also demonstrates that each character is represented
    by a number:'
  prefs: []
  type: TYPE_NORMAL
- en: ascii-table.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Writing a pipe-friendly program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write a program that is **pipe-friendly**.
    It will take input from standard input and output the result on standard output.
    Any error messages are going to be printed on standard error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need the GCC compiler, GNU Make, and preferably the **Bash** shell for
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to write a program that converts miles per hour
    into kilometers per hour. As a test, we are going to *pipe* data to it from a
    text file that contains measurements from a car trial run with average speeds.
    The text file is in **miles per hour** (**mph**), but we want them in **kilometers
    per hour** (**kph**) instead. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the following text file or download it from GitHub from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt).
    If you are creating it yourself, name it `avg.txt`. This text will be used as
    the input for a program we will write. The text simulates measurement values from
    a car trial run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the actual program. Type in the following code and save it as `mph-to-kph.c`,
    or download it from GitHub from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c).
    This program will convert miles per hour into kilometers per hour. This conversion
    is performed in the `printf()` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the program by running it interactively. Type in some miles per hour values
    and hit *Enter* after each value. The program will print out the corresponding
    value in kilometers per hour:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to use our program as a filter to transform the table containing
    miles per hour into kilometers per hour. But first, we must filter out only the
    mph values. We can do this with `awk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a list of the numbers only, we can add our `mph-to-kph` program
    at the end to convert the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the last value is `nn`, a non-numeric value, which is an error in the
    measurement, we don''t want to show the error message in the output. Therefore,
    we redirect stderr to `/dev/null`. Note the parenthesis around the expression,
    before the redirect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much prettier! However, we also want to add *km/h* at the end of every
    line to know what the value is. We can use `sed` to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program is similar to the one from the previous recipe. The features we
    added here check if the input data is numeric or not, and if it isn't, the program
    aborts with an error message that is printed to stderr. The regular output is
    still printed to stdout, as far as it goes without an error.
  prefs: []
  type: TYPE_NORMAL
- en: The program is only printing the numeric values, no other information. This
    makes it better as a filter, since the *km/h* text can be added by the user with
    other programs. That way, the program can be useful for many more scenarios that
    we haven't thought about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line where we check for numeric input might require some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `strspn()` function only reads the characters that we specified in the second
    argument to the function and then returns the number of read characters. We can
    then compare the number of characters read by `strspn()` with the entire length
    of the string, which we get with `strlen()`. If those match, we know that every
    character is either numeric, a dot, a minus, or a newline. If they don't match,
    this means an illegal character was found in the string.
  prefs: []
  type: TYPE_NORMAL
- en: For `strspn()` and `strlen()` to work, we included `string.h`. For `atof()`
    to work, we included `stdlib.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Piping data to the program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Step 5*, we selected only the third field—the mph value—using the `awk`
    program. The awk `$3` variable means field number 3\. Each field is a new word,
    separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 6*, we redirected the output from the `awk` program—the mph values—into
    our `mph-to-kph` program. As a result, our program printed the km/h values on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 7*, we redirected the error messages to `/dev/null` so that the output
    from the program is clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in *Step 8*, we added the text *km/h* after the kph values in the
    output. We did this by using the `sed` program. The `sed` program can look a bit
    cryptic, so let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This `sed` script is similar to the previous ones we have seen. But this time,
    we substituted the end of the line with a `$` sign instead of the beginning with
    `^`. So, what we did here is substitute the end of the line with the text "km/h".
    Note, though, that we needed to *escape* the slash in "km/h" with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of useful information about `strlen()` and `strspn()` in the respective
    manual pages. You can read them with `man 3 strlen` and `man 3 strspn`.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the result to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to redirect the output of a program to two
    different files. We are also going to learn some best practices when writing a
    **filter**, a program specifically made to be connected with other programs with
    a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program we will build in this recipe is a new version of the program from
    the previous recipe. The `mph-to-kph` program in the previous recipe had one drawback:
    it always stopped when it found a non-numeric character. Often, when we run filters
    on long input data, we want the program to continue running, even if it has detected
    some erroneous data. This is what we are going to fix in this version.'
  prefs: []
  type: TYPE_NORMAL
- en: We will keep the default behavior just as it was previously; that is, it will
    abort the program when it encounters a non-numeric value. However, we will add
    an option (`-c`) so that it can continue running the program even if a non-numeric
    value was detected. Then, it's up to the end user to decide how he or she wants
    to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the requirements listed in the *Technical requirements* section of this
    chapter apply here (the GCC compiler, the Make tool, and the Bash shell).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This program will be a bit longer, but if you like, you can download it from
    GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c).
    Since the code is a bit longer, I will be splitting it up into several steps.
    However, all of the code still goes into a single file called `mph-to-kph_v2.c`.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the feature macro and the required header files. Since we
    are going to use `getopt()`, we need the `_XOPEN_SOURCE` macro, as well as the
    `unistd.h` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the function prototype for the help function. We will also
    start writing the `main()` function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add the `getopt()` function inside a `while` loop. This is similar
    to the *Writing a program that parses command-line options recipe* from [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create another `while` loop, where we will fetch data from stdin
    with `fgets()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must write the function body for the `help` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out, without any options, by giving it some numeric values and
    a non-numeric value. The result should be the same as what we received previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try it out using the `-c` option so that we can continue running
    the program even though a non-numeric value has been detected. Type some numeric
    and non-numeric values into the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'That worked just fine! Now, let''s add some more data to the `avg.txt` file
    and save it as `avg-with-garbage.txt`. This time, there will be more lines with
    non-numeric values. You can also download the file from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run `awk` on that file again to see only the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the moment of truth. Let''s add the `mph-to-kph_v2` program at the
    end with the `-c` option. This should convert all the mph values into kph values
    and continue running, even though non-numeric values will be found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'That worked! The program continued, even though there were non-numeric values.
    Since the error messages are printed to stderr and the values are printed to stdout,
    we can redirect the output to two different files. That leaves us with a clean
    output file and a separate error file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the two files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code itself is similar to what we had in the previous recipe, except for
    the added `getopt()` and the help function. We covered `getopt()` in detail in
    [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary
    Tools and Writing Our First Linux Programs*, so there's no need to cover it again
    here.
  prefs: []
  type: TYPE_NORMAL
- en: To continue reading data from stdin when a non-numeric value is found (while
    using the `-c` option), we use `continue` to skip one iteration of the loop. Instead
    of aborting the program, we print an error message to stderr and then move on
    to the next iteration, leaving the program running.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we passed two arguments to the `printHelp()` function. The first
    argument is a `FILE` *pointer*. We use this to pass *stderr* or *stdout* to the
    function. Stdout and stderr are *streams*, which can be reached via their `FILE`
    pointer. This way, we can choose if the help message should be printed to stdout
    (in case the user asked for the help) or to stderr (in case there was an error).
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the name of the program, as we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: We then compiled and tested the program. Without the `-c` option, it works just
    as it did previously.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we tried the program with data from a file that contains some garbage.
    That's usually how data looks; it's often not "perfect". That's why we added the
    option to continue, even though non-numeric values were found.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the previous recipe, we used `awk` to select only the third field
    (`print $3`) from the file.
  prefs: []
  type: TYPE_NORMAL
- en: The exciting part is *Step 12*, where we redirected both *stderr* and *stdout*.
    We separated the two outputs into two different files. That way, we have a clean
    output file with only the km/h values. We can then use that file for further processing
    since it doesn't contain any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: We could have written the program to do all the steps for us, such as filter
    out the values from the text file, do the conversions, and then write the result
    to a new file. But that's an **anti-pattern** in Linux and Unix. Instead, we want
    to write small tools that do one thing only—and do it well. That way, the program
    can be used on other files with a different structure, or for a completely different
    purpose. We could even grab the data straight from a device or modem if we wanted
    to and pipe it into our program. The tools for extracting the correct fields from
    the file (or device) have already been created; there's no need to reinvent the
    wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we needed to enclose the entire command, with pipes and all, before
    redirecting the output and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eric S. Raymond has written some excellent rules to stick to when developing
    software for Linux and Unix. They can all be found in his book, *The Art of Unix
    Programming*. Two of the rules that apply to us in this recipe include the *Rule
    of Modularity*, which says that we should write simple parts that are connected
    with clean interfaces. The other rule that applies to us is the *Rule of Composition*,
    which says to write programs that will be connected to other programs.
  prefs: []
  type: TYPE_NORMAL
- en: His book is available for free online at [http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/).
  prefs: []
  type: TYPE_NORMAL
- en: Reading environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to communicate with the shell—and to configure a program—is via
    **environment variables**. By default, there are a lot of environment variables
    already set. These variables contain information on just about anything regarding
    your user and your settings. Some examples include the username, which type of
    terminal you are using, the path variable we discussed in previous recipes, your
    preferred editor, your preferred locale and language, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to read these variables will make it much easier for you to adapt
    your programs to the user's environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will write a program that reads environment variables, adapts
    its output, and prints some information about the user and the session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we can use just about any shell. Other than a shell, we'll
    need the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to write a program that reads environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following code into a file called `env-var.c`. You can also download
    the whole program from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c).
    This program will read some common environment variables from your shell using
    the `getenv()` function. The strange-looking number sequences (`\033[0;31`) are
    used to color the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program using GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. The information that will be printed for you will differ from
    mine. The last line will also be in color if your terminal supports it. If it
    doesn''t, it will tell you that your terminal doesn''t support colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s investigate the environment variables we used by using `echo`. Make
    a note of the `$TERM` variable. The dollar sign (`$`) tells the shell that we
    want to print the `TERM` variable, not the word *TERM*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to change the `$TERM` variable to a regular `xterm`, without color
    support, we would get a different output from the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on, we should reset our terminal to the value it was before we
    changed it. This will probably be something else on your computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to set an environment variable temporarily for the duration
    of the program. We can do this by setting the variable and executing the program
    on the same line. Notice that when the program ends, the variable is still the
    same as it was previously. We just override the variable when the program executes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also print a complete list of all the environment variables using the
    `env` command. The list will probably be several pages long. All of these variables
    can be accessed using the `getenv()` C function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the `getenv()` function to get the values from the shell's environment
    variables. We print these variables to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Then, at the end of the program, we check if the current terminal has color
    support. This is usually denoted by something such as `xterm-256color`, `screen-256color`,
    and so on. We then use the `strstr()` function (from `string.h`) to check if the
    `$TERM` variable contains the `256color` substring. If it does, the terminal has
    color support, and we print a colorized message on the screen. If it doesn't,
    however, we print that the terminal doesn't have color support, without using
    any colors.
  prefs: []
  type: TYPE_NORMAL
- en: All of these variables are the shell's *environment variables* and can be printed
    with the `echo` command; for example, `echo $TERM`. We can also set our own environment
    variables in the shell; for instance, `export FULLNAME=Jack-Benny`. Likewise,
    we can change existing ones by overwriting them, just as we did with the `$TERM`
    variable. We can also override them by setting them at runtime, like we did with
    `TERM=xterm ./env-var`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular variables set with the `FULLNAME=Jack-Benny` syntax are only available
    to the current shell and are hence called `export` command, they become **global
    variables** or *environment variables*, a more common name, available to both
    **subshells** and child processes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs: []
  type: TYPE_NORMAL
- en: We can also change environment variables and create new ones in a C program
    by using the `setenv()` function. However, when we do so, those variables won't
    be available in the shell that started the program. The program we run is a **child
    process** of the shell, and hence it can't change the shell's variable; that is,
    its **parent process**. But any other programs started from inside our own program
    will be able to see those variables. We will discuss parent and child processes
    in more depth later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short example of how to use `setenv()`. The `1` in the third argument
    to `setenv()` means that we want to overwrite the variable if it already exists.
    If we change it to a `0`, it prevents overwriting:'
  prefs: []
  type: TYPE_NORMAL
- en: env-var-set.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run the program and then try to read `$FULLNAME` from the
    shell, we''ll notice that it doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
