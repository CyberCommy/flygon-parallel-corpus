- en: Chapter 5. Handling Events and Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal uses events for notifying classes about things that happen in the game
    world in an efficient manner. Events and delegates are useful to ensure that these
    notifications can be issued in a way which minimizes class coupling, and allows
    arbitrary classes to subscribe to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling events implemented via virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unregistering a delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a respawning pickup for an First Person Shooter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events implemented via virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some `Actor` and `Component` classes provided with Unreal include event handlers
    in the form of virtual functions. This recipe will show you how to customize those
    handlers by overriding the virtual function in question.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an empty `Actor` in the Editor. Call it `MyTriggerVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation for the preceding functions to the cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project, and place an instance of `MyTriggerActor` into the level.
    Verify that overlap/touch events are handled by walking into the volume, and seeing
    the output printed to the screen:![How to do it...](img/00092.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we first declare a `UPROPERTY` to hold a reference to our component
    subobject. We then create two `UFUNCTION` declarations. These are marked as `virtual`
    and `override` so that the compiler understands we want to replace the parent
    implementation, and that our function implementations can be replaced in turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of the functions, we use `FString::printf` to create an
    `FString` from some preset text, and substitute some data parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `FString` `OtherActor->GetName()` returns, and is dereferenced
    using the `*` operator before being passed into `FString::Format`. Not doing this
    results in an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `FString` is then passed to a global engine function, `AddOnScreenDebugMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first argument of `-1` tells the engine that duplicate strings are allowed,
    the second parameter is the length of time the message should be displayed for
    in seconds, the third argument is the color, and the fourth is the actual string
    to print itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when a component of our actor overlaps something else, its `UpdateOverlaps`
    function will call `NotifyActorBeginOverlap`, and the virtual function dispatch
    will call our custom implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates allow us to call a function without knowing which function is assigned.
    They are a safer version of a raw function pointer. This recipe shows you how
    to associate a `UFUNCTION` to a delegate so that it is called when the delegate
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you've followed the previous recipe in order to create a `TriggerVolume`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside our `GameMode` header, declare the delegate with the following macro,
    just before the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member to our game mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `DelegateListener`. Add the following to
    the declaration of that class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation, add this to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `DelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `DelegateListener` header include.
    Inside the `DelegateListener::BeginPlay` implementation, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `EnableLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the following code in our TriggerVolume''s `NotifyActorBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to add `#include "UE4CookbookGameMode.h"` to your CPP file too so that
    the compiler knows about the class before we use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your game. Make sure that your game mode is set in the current level
    (refer to the *Instantiating an Actor using SpawnActor* recipe in [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components* if you don't know
    how), and drag a copy of your TriggerVolume out into the level. Also, drag a copy
    of `DelegateListener` out into the level, and place it about 100 units above a
    flat surface:![How to do it...](img/00093.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you hit **Play**, and walk into the area covered by the Trigger volume,
    you should see the `PointLight` component, which we added to `DelegateListener`,
    turn on:![How to do it...](img/00094.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside our `GameMode` header, we declare a type of delegate that doesn't take
    any parameters, called `FTriggerHitSignature`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create an instance of the delegate as a member of our `GameMode` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `PointLight` component inside `DelegateListener` so that we have a
    visual representation of the delegate being executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we initialize our `PointLight`, then disable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We override `BeginPlay`. We first call the parent class's implementation of
    `BeginPlay()`. Then we get the game world, retrieving the `GameMode` class using
    `GetGameMode()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Casting the resulting `AGameMode*` to a pointer of our `GameMode` class requires
    the use of the `Cast` template function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then access the delegate instance member of the `GameMode`, and bind
    our `EnableLight` function to the delegate, so it will be called when the delegate
    is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we are binding to `UFUNCTION`(), so we use `BindUObject`. If we
    wanted to bind to a plain C++ class function, we would have used `BindRaw`. If
    we want to bind to a static function, we will use `BindStatic()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `TriggerVolume` overlaps the player, it retrieves `GameMode`, then calls
    `ExecuteIfBound` on the delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExecuteIfBound` checks that there''s a function bound to the delegate, and
    then invokes it for us.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EnableLight` function enables the `PointLight` component when invoked by
    the delegate object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next section, *Unregistering a delegate,* shows you how to safely unregister
    your delegate binding in the event of the `Listener` being destroyed before the
    delegate is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unregistering a delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to remove a delegate binding. This is like setting
    a function pointer to `nullptr` so that it no longer references an object that
    has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need to follow the previous recipe in order for you to have a delegate
    to unregister.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `DelegateListener`, add the following overridden function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe combines both of the previous recipes in this chapter so far. We
    override `EndPlay`, which is an event implemented as a virtual function, so that
    we can execute code when our `DelegateListener` leaves play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that overridden implementation, we call the `Unbind()` method on the delegate,
    which unlinks the member function from the `DelegateListener` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without this being done, the delegate dangles like a pointer, leaving it in
    an invalid state when the `DelegateListener` leaves the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the delegates that we've used haven't taken any input parameters. This
    recipe shows you how to change the signature of the delegate so that it accepts
    some input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure you've followed the recipe at the beginning of this chapter, which shows
    you how to create a `TriggerVolume` and the other infrastructure that we require
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to `GameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member to `GameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `ParamDelegateListener`. Add the following
    to the declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation, add this to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ParamDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `ParamDelegateListener` header
    include. Inside the `ParamDelegateListener::BeginPlay` implementation, add the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `SetLightColor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `TriggerVolume`, in `NotifyActorBeginOverlap`, add the following
    line after the call to `MyStandardDelegate.ExecuteIfBound`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our new delegate signature uses a slightly different macro for declaration.
    Note the `_OneParam` suffix at the end of `DECLARE_DELEGATE_OneParam`. As you'd
    expect, we also need to specify what type our parameter will be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like when we created a delegate without parameters, we need to create an
    instance of the delegate as a member of our `GameMode` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now create a new type of `DelegateListener`, one that is expecting a parameter
    to be passed into the function that it binds to the delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we call the `ExecuteIfBound()` method for the delegate, we now need to
    pass in the value that will be inserted into the function parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function that we have bound, we use the parameter to set the color
    of our light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that `TriggerVolume` doesn't need to know anything about the `ParamDelegateListener`
    in order to call functions on it. The delegate has allowed us to minimize coupling
    between the two classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With only minimal changes, parameters can be passed through to a delegate at
    creation time. This recipe shows you how to specify data to be always passed as
    parameters to a delegate invocation. The data is calculated when the binding is
    created, and doesn't change from that point forward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure you've followed the previous recipe. We will be extending the functionality
    of the previous recipe to pass additional creation-time parameters to our bound
    delegate function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your `AParamDelegateListener::BeginPlay` function, change the call to
    `BindUObject` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the declaration of `SetLightColor` to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alter the implementation of `SetLightColor` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your project. Verify that when you walk into `TriggerVolume`,
    the light turns off because of the false payload parameter passed in when you
    bound the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we bind the function to the delegate, we specify some additional data (in
    this case, a Boolean of value `false`). You can pass up to four 'payload' variables
    in this fashion. They are applied to your function after any parameters declared
    in the `DECLARE_DELEGATE_*` macro that you used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the function signature of our delegate so that it can accept the extra
    argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function, we use the extra argument to turn the light on or off depending
    on the value being true or false at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to change the call to `ExecuteIfBound`—the delegate system automatically
    applies the delegate parameters, passed in through `ExecuteIfBound`, first. It
    then applies any payload parameters, which are always specified after the function
    reference in a call to `BindUObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Unregistering a delegate* shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard delegates used so far in this chapter are essentially a function
    pointer—they allow you to call one particular function on one particular object
    instance. Multicast delegates are a collection of function pointers, each potentially
    on different objects, that will all be invoked when the delegate is **broadcast**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you have followed the initial recipe in the chapter, as
    it shows you how to create `TriggerVolume` that is used to broadcast the multicast
    delegate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to the `GameMode` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `MulticastDelegateListener`. Add the following
    to the declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation, add this to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MulticastDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `MulticastDelegateListener` header
    include. Inside the `MulticastDelegateListener::BeginPlay` implementation, add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `ToggleLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement our `EndPlay` overridden function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to `TriggerVolume::NotifyActorBeginOverlap()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Compile and load your project. Set the `GameMode` in your level to be our cookbook
    game mode, then drag four or five instances of the `MulticastDelegateListener`
    into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step into `TriggerVolume` to see all the `MulticastDelegateListener` toggle
    their light's visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might expect, the delegate type needs to be explicitly declared as a
    multicast delegate rather than a standard single-binding one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new `Listener` class is very similar to our original `DelegateListener`.
    The primary difference is that we need to store a reference to our delegate instance
    in `FDelegateHandle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the actor is destroyed, we safely remove ourselves from the list of functions
    bound to the delegate by using the stored `FDelegateHandle` as a parameter to
    `Remove()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Broadcast()` function is the multicast equivalent of `ExecuteIfBound()`.
    Unlike standard delegates, there is no need to check if the delegate is bound
    either in advance or with a call like `ExecuteIfBound`. `Broadcast()` is safe
    to run no matter how many functions are bound, or even if none are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have multiple instances of our multicast listener in the scene, they
    each register themselves with the multicast delegate implemented in the `GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, when the `TriggerVolume` overlaps a player, it broadcasts the delegate,
    and each Listener is notified causing them to toggle the visibility of their associated
    point light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multicast delegates can take parameters in exactly the same way that a standard
    delegate can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom Event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom delegates are quite useful, but one of their limitations is that they
    can be broadcast externally by some other third-party class, that is, their Execute/Broadcast
    methods are publically accessible.
  prefs: []
  type: TYPE_NORMAL
- en: At times, you may want a delegate that is externally assignable by other classes,
    but can only be broadcast by the class which contains them. This is the primary
    purpose of Events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you've followed the initial recipe in this chapter so that you have
    the `MyTriggerVolume` and `CookBookGameMode` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following event declaration macro to the header of your `MyTriggerVolume`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an instance of the declared event signature to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In `AMyTriggerVolume::NotifyActorBeginOverlap`, add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Actor` class, called `TriggerVolEventListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following class members to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `PointLight` in the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `BeginPlay`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `OnTriggerEvent()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project, and launch the editor. Create a level with the game mode
    set to our `UE4CookbookGameMode`, then drag an instance of `ATriggerVolEventListener`
    and `AMyTriggerVolume` out into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `TriggerVolEventListener`, and you'll see `TriggerVolEventListener` listed
    as a category in the **Details** panel, with the property **Trigger Event Source**:![How
    to do it...](img/00095.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the drop-down menu to select your instance of `AMyTriggerVolume` so that
    the Listener knows which event to bind to:![How to do it...](img/00096.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your game, and enter the trigger volume's zone of effect. Verify that the
    color of your `EventListener` changes to green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the other types of delegates, Events require their own special macro
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the class that the event will be implemented into. This
    will be the only class able to call `Broadcast()`, so make sure it is the right
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is the type name for our new event function signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add an instance of this type to our class. Unreal documentation suggests
    `On<x>` as a naming convention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something overlaps our `TriggerVolume`, we call broadcast on our own event
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new class, we create a point light as a visual representation of
    the event being triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a pointer to `TriggerVolume` to listen to events from. We mark
    the `UPROPERTY` as `EditAnywhere`, because this allows us to set it in the Editor
    rather than having to acquire the reference programmatically using `GetAllActorsOfClass`
    or something else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last is our event handler for when something enters the `TriggerVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create and initialize our point light in the constructor as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the game starts, the Listener checks that our `TriggerVolume` reference
    is valid, then binds our `OnTriggerEvent` function to the `TriggerVolume` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `OnTriggerEvent`, we change our light's color to green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something enters `TriggerVolume`, it causes `TriggerVolume` to call broadcast
    on its own event. Our `TriggerVolEventListener` then has its bound method invoked,
    changing our light's color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use the concepts introduced in the previous recipes
    to create an actor that informs other actors of the passage of time within your
    game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class called `TimeOfDayHandler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a multicast delegate declaration to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an instance of our delegate to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following properties to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the initialization of these properties to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `Tick`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Actor` class called `Clock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize and transform the components in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to `BeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, implement `TimeChanged` as your event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Place an instance of `TimeOfDayHandler` and the `AClock` into your level, and
    play to see that the hands on the clock are rotating:![How to do it...](img/00097.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TimeOfDayHandler` contains a delegate which takes two parameters, hence the
    use of the `TwoParams` variant of the macro.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our class contains variables to store hours, minutes, and seconds, and the `TimeScale`,
    which is an acceleration factor used to speed up time for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the handler's `Tick` function, we accumulate elapsed seconds based on
    the time elapsed since the last frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check if the elapsed seconds have gone over 60\. If so, we subtract 60, and
    increment `Minutes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise with `Minutes`—if they go over 60, we subtract 60, and increment `Hours`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Minutes` and `Hours` were updated, we broadcast our delegate to let any
    object that has subscribed to the delegate know that the time has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Clock` actor uses a series of Scene components and Static meshes to build
    a mesh hierarchy that resembles a clock face.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Clock` constructor, we parent the components in the hierarchy, and set
    their initial scale and rotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `BeginPlay`, the clock uses `GetAllActorsOfClass()` to fetch all the `time
    of day` handlers in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's at least one `TimeOfDayHandler` in the level, the `Clock` accesses
    the first one, and subscribes to its `TimeChanged` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `TimeChanged` event fires, the clock rotates the hour and minute hands
    based on how many hours and minutes the time currently has.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a respawning pickup for an First Person Shooter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a placeable pickup that will respawn after
    a certain amount of time, suitable as an ammo or other pickup for an FPS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class called `Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the following delegate type in `Pickup.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following properties to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the overridden `NotifyActorBeginOverlap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a second `Actor` class called `PickupSpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Add `Pickup.h` to the includes in the `PickupSpawner` implementation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize our root component in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Spawn a pickup when gameplay starts with the `SpawnPickup` function in `BeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `PickupCollected`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following code for `SpawnPickup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Compile and launch the editor, then drag an instance of `PickupSpawner` out
    into the level. Walk into the pickup represented by the spinning cube, and verify
    that it spawns again 10 seconds later:![How to do it...](img/00098.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we need to create a delegate inside our `Pickup` that our Spawner
    can subscribe to so that it knows when the player collects the pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Pickup` also contains a Static mesh as a visual representation, and a `RotatingMovementComponent`
    so that the mesh will spin in a way to attract the attention of the players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Pickup` constructor, we load one of the engine's inbuilt meshes
    as our visual representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify that the mesh will overlap with other objects, then set the rotation
    rate of our mesh at 10 units per second in the *X* and *Z* axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player overlaps the `Pickup`, it fires off its `PickedUp` delegate
    from the first step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PickupSpawner` has a Scene component to specify where to spawn the pickup
    actor. It has a function for doing so, and a `UPROPERTY`-tagged reference to the
    currently spawned `Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PickupSpawner` constructor, we initialize our components as always.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When play begins, the Spawner runs its `SpawnPickup` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function spawns an instance of our `Pickup`, then binds `APickupSpawner::PickupCollected`
    to the `OnPickedUp` function on the new instance. It also stores a reference to
    that current instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `PickupCollected` runs after the player has overlapped the `Pickup`, a
    timer is created to respawn the pickup after 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The existing delegate binding to the collected pickup is removed, then the pickup
    is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After 10 seconds, the timer fires, running `SpawnActor` again, which creates
    a new `Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
