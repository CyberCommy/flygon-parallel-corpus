- en: Chapter 5. Handling Events and Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal uses events for notifying classes about things that happen in the game
    world in an efficient manner. Events and delegates are useful to ensure that these
    notifications can be issued in a way which minimizes class coupling, and allows
    arbitrary classes to subscribe to be notified.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Handling events implemented via virtual functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unregistering a delegate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Event
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a respawning pickup for an First Person Shooter
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events implemented via virtual functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some `Actor` and `Component` classes provided with Unreal include event handlers
    in the form of virtual functions. This recipe will show you how to customize those
    handlers by overriding the virtual function in question.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an empty `Actor` in the Editor. Call it `MyTriggerVolume`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class header:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the implementation for the preceding functions to the cpp file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your project, and place an instance of `MyTriggerActor` into the level.
    Verify that overlap/touch events are handled by walking into the volume, and seeing
    the output printed to the screen:![How to do it...](img/00092.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we first declare a `UPROPERTY` to hold a reference to our component
    subobject. We then create two `UFUNCTION` declarations. These are marked as `virtual`
    and `override` so that the compiler understands we want to replace the parent
    implementation, and that our function implementations can be replaced in turn.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of the functions, we use `FString::printf` to create an
    `FString` from some preset text, and substitute some data parameters.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `FString` `OtherActor->GetName()` returns, and is dereferenced
    using the `*` operator before being passed into `FString::Format`. Not doing this
    results in an error.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `FString` is then passed to a global engine function, `AddOnScreenDebugMessage`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first argument of `-1` tells the engine that duplicate strings are allowed,
    the second parameter is the length of time the message should be displayed for
    in seconds, the third argument is the color, and the fourth is the actual string
    to print itself.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when a component of our actor overlaps something else, its `UpdateOverlaps`
    function will call `NotifyActorBeginOverlap`, and the virtual function dispatch
    will call our custom implementation.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates allow us to call a function without knowing which function is assigned.
    They are a safer version of a raw function pointer. This recipe shows you how
    to associate a `UFUNCTION` to a delegate so that it is called when the delegate
    is executed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you've followed the previous recipe in order to create a `TriggerVolume`
    class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside our `GameMode` header, declare the delegate with the following macro,
    just before the class declaration:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a new member to our game mode:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new `Actor` class called `DelegateListener`. Add the following to
    the declaration of that class:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `DelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `DelegateListener` header include.
    Inside the `DelegateListener::BeginPlay` implementation, add the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, implement `EnableLight`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Put the following code in our TriggerVolume''s `NotifyActorBeginOverlap` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Be sure to add `#include "UE4CookbookGameMode.h"` to your CPP file too so that
    the compiler knows about the class before we use it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your game. Make sure that your game mode is set in the current level
    (refer to the *Instantiating an Actor using SpawnActor* recipe in [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components* if you don't know
    how), and drag a copy of your TriggerVolume out into the level. Also, drag a copy
    of `DelegateListener` out into the level, and place it about 100 units above a
    flat surface:![How to do it...](img/00093.jpeg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you hit **Play**, and walk into the area covered by the Trigger volume,
    you should see the `PointLight` component, which we added to `DelegateListener`,
    turn on:![How to do it...](img/00094.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside our `GameMode` header, we declare a type of delegate that doesn't take
    any parameters, called `FTriggerHitSignature`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create an instance of the delegate as a member of our `GameMode` class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `PointLight` component inside `DelegateListener` so that we have a
    visual representation of the delegate being executed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we initialize our `PointLight`, then disable it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We override `BeginPlay`. We first call the parent class's implementation of
    `BeginPlay()`. Then we get the game world, retrieving the `GameMode` class using
    `GetGameMode()`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Casting the resulting `AGameMode*` to a pointer of our `GameMode` class requires
    the use of the `Cast` template function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then access the delegate instance member of the `GameMode`, and bind
    our `EnableLight` function to the delegate, so it will be called when the delegate
    is executed.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we are binding to `UFUNCTION`(), so we use `BindUObject`. If we
    wanted to bind to a plain C++ class function, we would have used `BindRaw`. If
    we want to bind to a static function, we will use `BindStatic()`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `TriggerVolume` overlaps the player, it retrieves `GameMode`, then calls
    `ExecuteIfBound` on the delegate.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExecuteIfBound` checks that there''s a function bound to the delegate, and
    then invokes it for us.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EnableLight` function enables the `PointLight` component when invoked by
    the delegate object.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next section, *Unregistering a delegate,* shows you how to safely unregister
    your delegate binding in the event of the `Listener` being destroyed before the
    delegate is called
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unregistering a delegate
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to remove a delegate binding. This is like setting
    a function pointer to `nullptr` so that it no longer references an object that
    has been deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll need to follow the previous recipe in order for you to have a delegate
    to unregister.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `DelegateListener`, add the following overridden function declaration:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the function like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe combines both of the previous recipes in this chapter so far. We
    override `EndPlay`, which is an event implemented as a virtual function, so that
    we can execute code when our `DelegateListener` leaves play.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that overridden implementation, we call the `Unbind()` method on the delegate,
    which unlinks the member function from the `DelegateListener` instance.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without this being done, the delegate dangles like a pointer, leaving it in
    an invalid state when the `DelegateListener` leaves the game.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the delegates that we've used haven't taken any input parameters. This
    recipe shows you how to change the signature of the delegate so that it accepts
    some input.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure you've followed the recipe at the beginning of this chapter, which shows
    you how to create a `TriggerVolume` and the other infrastructure that we require
    for this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to `GameMode`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new member to `GameMode`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new `Actor` class called `ParamDelegateListener`. Add the following
    to the declaration:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `ParamDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `ParamDelegateListener` header
    include. Inside the `ParamDelegateListener::BeginPlay` implementation, add the
    following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, implement `SetLightColor`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside our `TriggerVolume`, in `NotifyActorBeginOverlap`, add the following
    line after the call to `MyStandardDelegate.ExecuteIfBound`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our new delegate signature uses a slightly different macro for declaration.
    Note the `_OneParam` suffix at the end of `DECLARE_DELEGATE_OneParam`. As you'd
    expect, we also need to specify what type our parameter will be.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like when we created a delegate without parameters, we need to create an
    instance of the delegate as a member of our `GameMode` class.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now create a new type of `DelegateListener`, one that is expecting a parameter
    to be passed into the function that it binds to the delegate.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we call the `ExecuteIfBound()` method for the delegate, we now need to
    pass in the value that will be inserted into the function parameter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function that we have bound, we use the parameter to set the color
    of our light.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that `TriggerVolume` doesn't need to know anything about the `ParamDelegateListener`
    in order to call functions on it. The delegate has allowed us to minimize coupling
    between the two classes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With only minimal changes, parameters can be passed through to a delegate at
    creation time. This recipe shows you how to specify data to be always passed as
    parameters to a delegate invocation. The data is calculated when the binding is
    created, and doesn't change from that point forward.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure you've followed the previous recipe. We will be extending the functionality
    of the previous recipe to pass additional creation-time parameters to our bound
    delegate function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your `AParamDelegateListener::BeginPlay` function, change the call to
    `BindUObject` to the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change the declaration of `SetLightColor` to this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alter the implementation of `SetLightColor` as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and run your project. Verify that when you walk into `TriggerVolume`,
    the light turns off because of the false payload parameter passed in when you
    bound the function.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we bind the function to the delegate, we specify some additional data (in
    this case, a Boolean of value `false`). You can pass up to four 'payload' variables
    in this fashion. They are applied to your function after any parameters declared
    in the `DECLARE_DELEGATE_*` macro that you used.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the function signature of our delegate so that it can accept the extra
    argument.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function, we use the extra argument to turn the light on or off depending
    on the value being true or false at compile time.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to change the call to `ExecuteIfBound`—the delegate system automatically
    applies the delegate parameters, passed in through `ExecuteIfBound`, first. It
    then applies any payload parameters, which are always specified after the function
    reference in a call to `BindUObject`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe *Unregistering a delegate* shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard delegates used so far in this chapter are essentially a function
    pointer—they allow you to call one particular function on one particular object
    instance. Multicast delegates are a collection of function pointers, each potentially
    on different objects, that will all be invoked when the delegate is **broadcast**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you have followed the initial recipe in the chapter, as
    it shows you how to create `TriggerVolume` that is used to broadcast the multicast
    delegate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to the `GameMode` header:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new `Actor` class called `MulticastDelegateListener`. Add the following
    to the declaration:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `MulticastDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `MulticastDelegateListener` header
    include. Inside the `MulticastDelegateListener::BeginPlay` implementation, add
    the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement `ToggleLight`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement our `EndPlay` overridden function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following line to `TriggerVolume::NotifyActorBeginOverlap()`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile and load your project. Set the `GameMode` in your level to be our cookbook
    game mode, then drag four or five instances of the `MulticastDelegateListener`
    into the scene.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step into `TriggerVolume` to see all the `MulticastDelegateListener` toggle
    their light's visibility.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might expect, the delegate type needs to be explicitly declared as a
    multicast delegate rather than a standard single-binding one.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new `Listener` class is very similar to our original `DelegateListener`.
    The primary difference is that we need to store a reference to our delegate instance
    in `FDelegateHandle`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the actor is destroyed, we safely remove ourselves from the list of functions
    bound to the delegate by using the stored `FDelegateHandle` as a parameter to
    `Remove()`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Broadcast()` function is the multicast equivalent of `ExecuteIfBound()`.
    Unlike standard delegates, there is no need to check if the delegate is bound
    either in advance or with a call like `ExecuteIfBound`. `Broadcast()` is safe
    to run no matter how many functions are bound, or even if none are.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have multiple instances of our multicast listener in the scene, they
    each register themselves with the multicast delegate implemented in the `GameMode`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, when the `TriggerVolume` overlaps a player, it broadcasts the delegate,
    and each Listener is notified causing them to toggle the visibility of their associated
    point light.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multicast delegates can take parameters in exactly the same way that a standard
    delegate can.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom Event
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom delegates are quite useful, but one of their limitations is that they
    can be broadcast externally by some other third-party class, that is, their Execute/Broadcast
    methods are publically accessible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: At times, you may want a delegate that is externally assignable by other classes,
    but can only be broadcast by the class which contains them. This is the primary
    purpose of Events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you've followed the initial recipe in this chapter so that you have
    the `MyTriggerVolume` and `CookBookGameMode` implementations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following event declaration macro to the header of your `MyTriggerVolume`
    class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add an instance of the declared event signature to the class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `AMyTriggerVolume::NotifyActorBeginOverlap`, add this:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new `Actor` class, called `TriggerVolEventListener`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following class members to its declaration:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Initialize `PointLight` in the class constructor:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside `BeginPlay`, add the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, implement `OnTriggerEvent()`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile your project, and launch the editor. Create a level with the game mode
    set to our `UE4CookbookGameMode`, then drag an instance of `ATriggerVolEventListener`
    and `AMyTriggerVolume` out into the level.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `TriggerVolEventListener`, and you'll see `TriggerVolEventListener` listed
    as a category in the **Details** panel, with the property **Trigger Event Source**:![How
    to do it...](img/00095.jpeg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the drop-down menu to select your instance of `AMyTriggerVolume` so that
    the Listener knows which event to bind to:![How to do it...](img/00096.jpeg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your game, and enter the trigger volume's zone of effect. Verify that the
    color of your `EventListener` changes to green.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the other types of delegates, Events require their own special macro
    function.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the class that the event will be implemented into. This
    will be the only class able to call `Broadcast()`, so make sure it is the right
    one.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is the type name for our new event function signature.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add an instance of this type to our class. Unreal documentation suggests
    `On<x>` as a naming convention.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something overlaps our `TriggerVolume`, we call broadcast on our own event
    instance.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new class, we create a point light as a visual representation of
    the event being triggered.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a pointer to `TriggerVolume` to listen to events from. We mark
    the `UPROPERTY` as `EditAnywhere`, because this allows us to set it in the Editor
    rather than having to acquire the reference programmatically using `GetAllActorsOfClass`
    or something else.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last is our event handler for when something enters the `TriggerVolume`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create and initialize our point light in the constructor as usual.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the game starts, the Listener checks that our `TriggerVolume` reference
    is valid, then binds our `OnTriggerEvent` function to the `TriggerVolume` event.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `OnTriggerEvent`, we change our light's color to green.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something enters `TriggerVolume`, it causes `TriggerVolume` to call broadcast
    on its own event. Our `TriggerVolEventListener` then has its bound method invoked,
    changing our light's color.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use the concepts introduced in the previous recipes
    to create an actor that informs other actors of the passage of time within your
    game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class called `TimeOfDayHandler`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a multicast delegate declaration to the header:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add an instance of our delegate to the class declaration:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following properties to the class:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the initialization of these properties to the constructor:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside `Tick`, add the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new `Actor` class called `Clock`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to the class header:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize and transform the components in the constructor:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following to `BeginPlay`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Lastly, implement `TimeChanged` as your event handler.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Place an instance of `TimeOfDayHandler` and the `AClock` into your level, and
    play to see that the hands on the clock are rotating:![How to do it...](img/00097.jpeg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TimeOfDayHandler` contains a delegate which takes two parameters, hence the
    use of the `TwoParams` variant of the macro.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our class contains variables to store hours, minutes, and seconds, and the `TimeScale`,
    which is an acceleration factor used to speed up time for testing purposes.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the handler's `Tick` function, we accumulate elapsed seconds based on
    the time elapsed since the last frame.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check if the elapsed seconds have gone over 60\. If so, we subtract 60, and
    increment `Minutes`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise with `Minutes`—if they go over 60, we subtract 60, and increment `Hours`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Minutes` and `Hours` were updated, we broadcast our delegate to let any
    object that has subscribed to the delegate know that the time has changed.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Clock` actor uses a series of Scene components and Static meshes to build
    a mesh hierarchy that resembles a clock face.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Clock` constructor, we parent the components in the hierarchy, and set
    their initial scale and rotations.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `BeginPlay`, the clock uses `GetAllActorsOfClass()` to fetch all the `time
    of day` handlers in the level.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's at least one `TimeOfDayHandler` in the level, the `Clock` accesses
    the first one, and subscribes to its `TimeChanged` event.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `TimeChanged` event fires, the clock rotates the hour and minute hands
    based on how many hours and minutes the time currently has.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a respawning pickup for an First Person Shooter
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a placeable pickup that will respawn after
    a certain amount of time, suitable as an ammo or other pickup for an FPS.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程向您展示了如何创建一个可放置的拾取物，在一定时间后重新生成，适用于FPS中的弹药或其他拾取物。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new `Actor` class called `Pickup`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pickup`的新的`Actor`类。
- en: 'Declare the following delegate type in `Pickup.h`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pickup.h`中声明以下委托类型：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following properties to the class header:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类头文件中：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following code to the constructor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数中：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the overridden `NotifyActorBeginOverlap`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写的`NotifyActorBeginOverlap`：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a second `Actor` class called `PickupSpawner`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为`PickupSpawner`的`Actor`类。
- en: 'Add the following to the class header:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到类头文件中：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Add `Pickup.h` to the includes in the `PickupSpawner` implementation file.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickupSpawner`的实现文件中将`Pickup.h`添加到包含文件中。
- en: 'Initialize our root component in the constructor:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化我们的根组件：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Spawn a pickup when gameplay starts with the `SpawnPickup` function in `BeginPlay`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中使用`SpawnPickup`函数在游戏开始时生成一个拾取物：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement `PickupCollected`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`PickupCollected`：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the following code for `SpawnPickup`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SpawnPickup`创建以下代码：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Compile and launch the editor, then drag an instance of `PickupSpawner` out
    into the level. Walk into the pickup represented by the spinning cube, and verify
    that it spawns again 10 seconds later:![How to do it...](img/00098.jpeg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器，然后将`PickupSpawner`的一个实例拖到关卡中。走到由旋转立方体表示的拾取物上，并验证它在10秒后再次生成：![如何做...](img/00098.jpeg)
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As usual, we need to create a delegate inside our `Pickup` that our Spawner
    can subscribe to so that it knows when the player collects the pickup.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，在我们的`Pickup`内部创建一个委托，以便我们的Spawner可以订阅它，以便它知道玩家何时收集了拾取物。
- en: The `Pickup` also contains a Static mesh as a visual representation, and a `RotatingMovementComponent`
    so that the mesh will spin in a way to attract the attention of the players.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pickup`还包含一个静态网格作为视觉表示，以及一个`RotatingMovementComponent`，使网格以一种方式旋转，以吸引玩家的注意。'
- en: Inside the `Pickup` constructor, we load one of the engine's inbuilt meshes
    as our visual representation.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pickup`构造函数中，我们加载引擎内置的网格作为我们的视觉表示。
- en: We specify that the mesh will overlap with other objects, then set the rotation
    rate of our mesh at 10 units per second in the *X* and *Z* axes.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定网格将与其他对象重叠，然后在*X*和*Z*轴上将网格的旋转速率设置为每秒10个单位。
- en: When the player overlaps the `Pickup`, it fires off its `PickedUp` delegate
    from the first step.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家与`Pickup`重叠时，它会从第一步触发其`PickedUp`委托。
- en: The `PickupSpawner` has a Scene component to specify where to spawn the pickup
    actor. It has a function for doing so, and a `UPROPERTY`-tagged reference to the
    currently spawned `Pickup`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PickupSpawner`有一个场景组件来指定生成拾取物的位置。它有一个执行此操作的函数，并且有一个`UPROPERTY`标记的对当前生成的`Pickup`的引用。'
- en: In the `PickupSpawner` constructor, we initialize our components as always.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickupSpawner`构造函数中，我们像往常一样初始化我们的组件。
- en: When play begins, the Spawner runs its `SpawnPickup` function.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏开始时，Spawner运行其`SpawnPickup`函数。
- en: This function spawns an instance of our `Pickup`, then binds `APickupSpawner::PickupCollected`
    to the `OnPickedUp` function on the new instance. It also stores a reference to
    that current instance.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数生成我们的`Pickup`的一个实例，然后将`APickupSpawner::PickupCollected`绑定到新实例上的`OnPickedUp`函数。它还存储对当前实例的引用。
- en: When `PickupCollected` runs after the player has overlapped the `Pickup`, a
    timer is created to respawn the pickup after 10 seconds.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家与`Pickup`重叠后，`PickupCollected`运行，创建一个定时器在10秒后重新生成拾取物。
- en: The existing delegate binding to the collected pickup is removed, then the pickup
    is destroyed.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除到已收集拾取物的现有委托绑定，然后销毁拾取物。
- en: After 10 seconds, the timer fires, running `SpawnActor` again, which creates
    a new `Pickup`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10秒后，定时器触发，再次运行`SpawnActor`，创建一个新的`Pickup`。
