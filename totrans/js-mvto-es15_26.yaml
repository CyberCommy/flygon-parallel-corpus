- en: Chapter 13. Advanced Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hesitated when naming this chapter, *Advanced Patterns*. This isn't really
    about patterns that are more complicated or sophisticated than other patterns.
    It is about patterns that you wouldn't use very frequently. Frankly, coming from
    a static programming language background, some of them seem crazy. Nonetheless
    they are completely valid patterns and are in use within big name projects everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live post processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the topics we've been talking about continuously during this module is
    the importance of making your code modular. Small classes are easier to test,
    provide better reuse, and promote better collaboration for teams. Modular, loosely
    coupled code is easier to maintain, as changes can be limited. You may remember
    the example of a ripstop we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: With modular code of this sort we see a lot of inversion of control. Classes
    have functionality inserted into them through passing additional classes by their
    creators. This moves the responsibility for how some portions of the child class
    work to the parent. For small projects, this is a pretty reasonable approach.
    As projects get more complicated and dependency graphs get more complicated, manually
    injecting the functionality becomes more and more difficult. We are still creating
    objects all over the code base, passing them into created objects so the coupling
    problem still exists, we've just shifted it up a level.
  prefs: []
  type: TYPE_NORMAL
- en: If we think of object creation as a service, then a solution to this problem
    presents itself. We can defer the object creation to a central location. This
    allows us to change the implementations for a given interface in one place, simply
    and easily. It also allows us to control object lifetime so that we can reuse
    objects or recreate them every time they are used. If we need to replace one implementation
    of an interface with another implementation, then we can be confident that we
    need to only change it in one location. Because the new implementation still fulfils
    the contract, that is the interface, then all the classes that make use of the
    interface can remain ignorant of the change.
  prefs: []
  type: TYPE_NORMAL
- en: What's more is that by centralizing object creation it becomes easier to construct
    objects that depend on other objects. If we look at a dependency graph for a module
    such as the `UserManager` variable, it is clear that it has a number of dependencies.
    These dependencies may have additional dependencies and so forth. To build a `UserManager`
    variable, we not only need to pass in the database, but also `ConnectionStringProvider`,
    `CredentialProvider`, and `ConfigFileConnectionStringReader`. Goodness, that is
    going to be a lot of work to create instances of all of these. If we, instead,
    register implementations of each of these interfaces in a registry, then we need
    only go to the registry to look up how to make them. This can be automated and
    the dependencies automatically get injected to all dependencies without a need
    to explicitly create any of them. This method of solving dependencies is commonly
    referred to as 'solving the transitive closure'.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency injection framework handles the responsibility of constructing
    objects. On application set up the dependency injection framework is primed with
    a combination of names and objects. From this, it creates a registry or a container.
    When constructing an object through the container, the container looks at the
    signature of the constructor and attempts to satisfy the arguments on the constructor.
    Here is an illustration of a dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency injection](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In more statically typed languages such as C# or Java, dependency injection
    frameworks are commonplace. They usually work by using reflection, a method of
    using code to extract structural information from other code. When building the
    container, one specifies an interface and one or more concrete classes that can
    satisfy the interface. Of course using interfaces and reflection to perform dependency
    injection requires that the language support both interfaces and introspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no way to do this in JavaScript. JavaScript has neither direct introspection
    nor a traditional object inheritance model. A common approach is to use variable
    names to solve the dependency problem. Consider a class that has a constructor
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes two arguments that are very specifically named. When we
    construct this class through the dependency injection, these two arguments are
    satisfied by looking through the names registered with the container and passing
    them into the constructor. However, without introspection how can we extract the
    names of the parameters so we know what to pass into the constructor?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is actually amazingly simple. The original text of any function
    in JavaScript is available by simply calling `toString` on it. So, for the constructor
    given in the preceding code, we can do just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we can parse the string returned to extract the names of the parameters.
    Care must be taken to parse the text correctly, but it is possible. The popular
    JavaScript framework, Angular, actually uses this method to do its dependency
    injection. The result remains relatively preformat. The parsing really only needs
    to be done once and the results cached, so no additional penalty is incurred.
  prefs: []
  type: TYPE_NORMAL
- en: I won't go through how to actually implement the dependency injection, as it
    is rather tedious. When parsing the function, you can either parse it using a
    string-matching algorithm or build a lexer and parser for the JavaScript grammar.
    The first solution seems easier but it is likely a better decision to try to build
    up a simple syntax tree for the code into which you're injecting. Fortunately,
    the entire method body can be treated as a single token, so it is vastly easier
    than building a fully-fledged parser.
  prefs: []
  type: TYPE_NORMAL
- en: If you're willing to impose a different syntax on the user of your dependency
    injection framework then you can even go so far as to create your own syntax.
    The Angular 2.0 dependency injection framework, `di.js`, supports a custom syntax
    for denoting both places where objects should be injected and for denoting which
    objects satisfy some requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using it as a class into which some code needs to be injected, looks like this
    code, taken from the `di.js` examples page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CoffeeMaker` instance might look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might have also noticed that this example makes use of the `class` keyword.
    This is because the project is very forward looking and requires the use of `traceur.js`
    to provide for ES6 class support. We'll learn about `traceur.js` file in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Live post processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be apparent now that running `toString` over a function in JavaScript
    is a valid way to perform tasks. It seems odd but, really, writing code that emits
    other code is as old as Lisp or possibly older. When I first came across how dependency
    injection works in AngularJS, I was both disgusted at the hack and impressed by
    the ingenuity of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is possible to do dependency injection by interpreting code on the fly,
    then what more could we do with it? The answer is: quite a lot. The first thing
    that comes to mind is that you could write domain specific languages.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about DSLs in [Chapter 5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "Chapter 5. Behavioral Patterns"), *Behavioral Patterns*, and even created a very
    simple one. With the ability to load and rewrite JavaScript, we can take advantage
    of a syntax that is close to JavaScript but not wholly compatible. When interpreting
    the DSL, our interpreter would write out additional tokens needed to convert the
    code to actual JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the nice features of TypeScript that I''ve always liked is that parameters
    to the constructors that are marked as public are automatically transformed into
    properties on the object. For instance, the TypeScript code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiles to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We could do something similar in our DSL. Starting with the `Axe` definition
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've used a comment here to denote that `headHeight` should be public. Unlike
    the TypeScript version, we would like our source code to be valid JavaScript.
    Because comments are included in the `toString` function this works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to actually emit new JavaScript from this. I''ve taken
    a naïve approach and used regular expressions. This approach would quickly get
    out of hand and probably only works with the well-formed JavaScript in the `Axe`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we extract the parameters to the function and check for those that have
    the `public` annotation. The result of this function can be passed back into eval
    for use in the current object or written out to a file if we're using this function
    in a pre-processor. Typically use of eval in JavaScript is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: There are tons of different things that can be done using this sort of processing.
    Even without string post-processing there are some interesting programming concept
    we can explore by just wrapping methods.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modularity of software is a great feature, the majority of this module has been
    about modularity and its advantages. However, there are some features of software
    that span the entire system. Security is a great example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to have similar security code in all the modules of the application
    to check that people are, in fact, authorized to perform some action. So if we
    have a function of the sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is a fair bit of code in place to check if a user is
    authorized. This same boilerplate code is used elsewhere in the application. In
    fact, with this being a high security application, the security checks are in
    place in every public function. All is well until we need to make a change to
    the common security code. This change needs to take place in every single public
    function in the application. We can refactor our application all we want, but
    the truth remains: we need to have at least some code in each of the public methods
    to perform a security check. This is known as a cross-cutting concern.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other instances of cross-cutting concerns in most large applications.
    Logging is a great example, as is database access and performance instrumenting.
    **Aspect oriented programming** (**AOP**) presents a way to minimize the repeated
    code through a process known as **weaving**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An aspect is a piece of code that can intercept method calls and change them.
    On the .Net platform there is a tool called PostSharp that does aspect weaving
    and, on the Java platform, one called AspectJ. These tools hook into the build
    pipeline and modify the code after it has been transformed into instructions.
    This allows code to be injected wherever needed. The source code appears unchanged
    but the compiled output now includes calls to the aspect. Aspects solve the cross
    cutting concern by being injected into existing code. Here you can see the application
    of an aspect to a method through a weaver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Aspect oriented programming](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course we don't have the luxury of a design-time compile step in most JavaScript
    workflows. Fortunately, we've already seen some approaches that would allow us
    to implement cross cuts using JavaScript. The first thing we need is the wrapping
    of methods that we saw in the testing chapter. The second is the `tostring` abilities
    from earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are some AOP libraries already in existence for JavaScript that may be
    a good bet to explore. However, we can implement a simple interceptor here. First
    let's decide on the grammar for requesting injection. We'll use the same idea
    of comments from earlier to denote methods that require interception. We'll just
    make the first line in the method a comment that reads `aspect(<name of aspect>)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll take a slightly modified version of our same `GoldTransfer`
    class from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve stripped out all the security stuff that used to exist in it and added
    a console log so we can see that it actually works. Next we''ll need an aspect
    to weave into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For this we use a simple class that has a `BeforeCall` and `AfterCall` method,
    one which is called before and one which is called after the original method.
    We don''t need to use eval in this case so the interceptions are safer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This interceptor can easily be modified to a shortcut and return something before
    the main method body is called. It can also be changed so that the output of the
    function can be modified by simply tracking the output from the wrapped method
    and then modifying it in the `AfterCall` method.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly lightweight example of AOP. There are some frameworks in existence
    for JavaScript AOP, but perhaps the best approach is to make use of a precompiler
    or macro language.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw much earlier in this module, the inheritance pattern for JavaScript
    is different from the typical pattern seen in languages like C# and Java. JavaScript
    uses prototype inheritance that allows adding functions to a class quite easily
    and from multiple sources. Prototype inheritance allows for adding methods from
    multiple sources in a similar fashion to the much-maligned multiple-inheritance.
    The primary criticism of multiple inheritance is that it is difficult to understand
    which overload of a method will be called in a situation. This problem is somewhat
    alleviated in a prototype inheritance model. Thus we can feel comfortable using
    the approach of adding functionality from several sources, which is known as mixins.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a chunk of code which can be added to existing classes to expand
    their functionality. They make the most sense in scenarios where the functions
    need to be shared between disparate classes where an inheritance relationship
    is too strong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a scenario where this sort of functionality would be handy.
    In the land of Westeros, death is not always as permanent as in our world. However,
    those who return from the dead may not be exactly as they were when they were
    alive. While much of the functionality is shared between `Person` and `ReanimatedPerson`,
    they are not close enough to have an inheritance relationship. In this code you
    can see the `extend` function of underscore used to add mixins to our two people
    classes. It is possible to do this without `underscore` but, as mentioned earlier,
    there are some complex edge cases around `extends` which make using a library
    handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Mixins provide a mechanism to share functionality between diverse objects but
    do pollute the prototype structure.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preprocessing code through macros is not a new idea. It was, and probably still
    is, very popular for C and C++. In fact, if you take a look at some of the source
    code for the Gnu utilities for Linux they are written almost entirely in macros.
    Macros are notorious for being hard to understand and debug. For a time, newly-created
    languages like Java and C# did not support macros for exactly this reason.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, even more recent languages like Rust and Julia have brought
    the idea of macros back. These languages were influenced by the macros from the
    Scheme language, a dialect of Lisp. The difference between C macros and Lisp/Scheme
    macros is that the C versions are textual while the Lisp/Scheme ones are structural.
    This means that C macros are just glorified find/replace tools while Scheme macros
    are aware of the **abstract syntax tree** (**AST**) around them, allowing them
    to be much more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The AST for Scheme is a far simpler construct than that of JavaScript. Nonetheless,
    there is a very interesting project called `Sweet.js` that tries to create structural
    macros for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sweet.js` plugs into the JavaScript build pipeline and modified JavaScript
    source code using one or more macros. There are a number of fully-fledged JavaScript
    transpilers, that is compilers that emit JavaScript. These compilers are problematic
    for sharing code between multiple projects. Their code is so different that there
    is no real way to share it. `Sweet.js` supports multiple macros being expanded
    in a single step. This allows for much better code sharing. The reusable bits
    are a smaller size and more easy to run together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of `Sweet.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The macro here provides ECMAScript-2015-style deconstructors that split an array
    into tree fields. The macro matches an array assignment and also regular assignment.
    For regular assignment the macro simply returns the identity, while for assignment
    of an array it will explode the text and replace it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you run it over the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is just one example macro. The power of macros is really quite spectacular.
    Macros can create an entirely new language or change very minor things. They can
    be easily plugged in to fit any sided requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using name-based dependency injection allows for conflicts between names. In
    order to avoid conflicts it may be worth prefacing your injected arguments with
    a special character. For instance, AngularJS uses the `$` sign to denote an injected
    term.
  prefs: []
  type: TYPE_NORMAL
- en: Several times in this chapter I've mentioned the JavaScript build pipeline.
    It may seem odd that we have to build an interpreted language. However, there
    are certain optimizations and process improvements that may result from building
    JavaScript. There are a number of tools that can be used to help building JavaScript.
    Tools such as Grunt and Gulp are specifically designed to perform JavaScript and
    web tasks but you can also make use of traditional build tools such as Rake, Ant,
    or even Make.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered a number of advanced JavaScript patterns. Of these
    patterns it's my belief that dependency injection and macros are the most useful
    to us. You may not necessarily want to use them on every project. When approaching
    problems simply being aware of the possible solutions may change your approach
    to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this module I have talked extensively about the next versions of
    JavaScript. However, you don't need to wait until some future time to make use
    of many of these tools. Today, there are ways to compile newer versions of JavaScript
    down to the current version of JavaScript. The final chapter will explore a number
    of these tools and techniques.
  prefs: []
  type: TYPE_NORMAL
