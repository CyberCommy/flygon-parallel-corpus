- en: Chapter 6. Components, Templates, and Custom Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at the fundamentals of building a user interface
    by looking at the way layout and elements work hand in hand to create flexible
    UIs. Data binding provides a detached way of writing and reading data to and from
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll explore ways to customize controls in a fundamental and
    powerful way using control templates. This is useful when a control's functionality
    is what's needed, but its looks are not. In other cases, the built-in controls
    may not have the required behavior; in these cases, custom and user controls can
    be created for application-specific needs. But first we should consider the more
    general concept of components built using C++, and how these can be used in C++
    and non-C++ projects.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Runtime Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in [Chapter 2](ch02.html "Chapter 2. COM and C++ for Windows 8
    Store Apps"), *COM and C++ for Windows 8 Store Apps*, the Windows Runtime is based
    on COM classes implementing COM interfaces. Any such class that is also written
    to metadata (a `winmd` file) can be exported from a DLL and thus used by any other
    WinRT-compliant language or environment; the ones currently supported are C++,
    .NET languages (C# and VB), and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Such components must only use WinRT types in their public interface. For C++,
    this means that STL-based classes can only be used in the nonpublic area of a
    WinRT class. When passed in public methods or properties, these must be converted
    to WinRT types.
  prefs: []
  type: TYPE_NORMAL
- en: One typical scenario is an existing C++ type, perhaps written sometime in the
    past, and needs to be used in WinRT for data binding purposes, or at least exposed
    to WinRT clients beyond the current project. Let's see how this transition can
    be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Converting C++ to WinRT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a concrete example, and then discuss things more generally. Suppose
    we have the following standard C++ classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simply stated, a `book` class is defined and has a name, an author, and a collection
    of reviews (`book_review` class). Each review consists of a name, the review content,
    and a numeric rating.
  prefs: []
  type: TYPE_NORMAL
- en: These classes are written in standard C++ and have no knowledge of WinRT (or
    C++/CX for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: As these stand, they can only be used internally in a C++ project. They cannot
    be exported to other WinRT environments (for example, .NET), and even in a C++
    project they cannot benefit from features such as data binding, as these are not
    WinRT classes in any way.
  prefs: []
  type: TYPE_NORMAL
- en: These (and similar) classes need to be wrapped in a WinRT class. With C++, this
    can be done in two ways. The first is by using WRL; the benefit is that standard
    C++ is being used (and not Microsoft-specific extensions), but this benefit is
    somewhat diminished, as WinRT is Microsoft specific anyway (at least at the time
    of writing). The second possible benefit is more control of the resulting WinRT
    types. Although this may sound appealing, it's also much harder to do, and unnecessary
    for most cases, so most of the time we'll take the easier approach by leveraging
    C++/CX.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using WRL to create a WinRT component is sometimes necessary. One example is
    when a single class needs to implement a WinRT interface and a native COM interface.
    For instance, a media encoder or decoder must be COM/WinRT classes that must implement
    not only the `Windows::Media::IMediaExtension` interface, but also the Media Foundation
    non-WinRT interface, `IMFTransform`. WRL is the only way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap the book-related classes, we''ll create a Windows Runtime Component
    project (we''ll call it `BookLibrary`). Then, we''ll add a C++/CX WinRT class
    to wrap `book` and `book_review`. Let''s start with the `book_review` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Bindable` attribute is applied to the class so that proper code is generated
    for data binding to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the public stuff is WinRT only. The `book_review` wrapped instance is in
    the private section of the class. Any attempt to make it public would cause a
    compilation error. The error states, "**a non-value type cannot have any public
    data members**"; that's the first issue—since WinRT is based on COM, and COM is
    based on interfaces, which are defined by virtual tables, they can only contain
    methods (functions) and not data members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the data member would turn into a method that returns a non-WinRT type,
    the compiler would issue a different error, "**(MethodName): signature of public
    member contains native type ''book_review''**". The net result is that only WinRT
    types can be used in public members.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard C++ has no concept of properties. Data members are sometimes wrapped
    by getters and/or setters. These should be turned into WinRT properties, as was
    done with `Name`, `Content`, and `Rating` in the preceding code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WinRT coding conventions are to use Pascal casing for class and member names,
    so these may need to change slightly to reflect this (for example, `name` in `book_review`
    is changed to `Name` in `BookReview`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: One thing that's missing from the `BookReview` class is implementation of `INotifyPropertyChanged`,
    as described in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*.
    This is needed because the `Rating` property can be changed after a `BookReview`
    is constructed. The implementation was omitted for easier focus on the fundamentals,
    but should be implemented in a real scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The header file does not implement the constructor and the properties `Name`
    and `Content`. Here''s the constructor (implemented in the corresponding CPP file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The constructor (like any other method) must accept WinRT types, using `Platform::String^`
    for any string that's required. This is used to initialize the wrapped `book_review`
    instance (which requires a standard `std::wstring`) by using the `Data` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Name` and `Content` properties are read only, but must return WinRT types—a
    `Platform::String^` in this case (which as you may recall wraps a WinRT `HSTRING`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is straightforward, this time going in the other direction,
    by using a `Platform::String` constructor that accepts a `const wchar_t*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to take a look at the wrapper created for the `book` class. This
    is a bit more complicated, as a book holds a `std::vector` of `book_review` objects;
    `std::vector` is not a WinRT type, so it must be projected with another type,
    representing a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Name` and `Author` properties are straightforward, and implemented inline.
    The constructor initializes these, and they remain read only throughout the lifetime
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The original `book` class has a `std::vector<book_review>` instance. In WinRT,
    a collection such as vector should be projected as a `Windows::Foundation::Collections::IVector<BookReview>`
    or `IVectorView<BookReview>` (in the same namespace, the latter being a read-only
    view of the former).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The namespace prefixes may be a bit confusing. Why is `IVector<T>` in `Windows::Foundation::Collections`
    but `Vector<T>` is in `Platform::Collections`? The rule is simple. WinRT types
    go into the `Windows::*` namespaces, while the specific C++ implementation go
    into the `Platform::*` namespace. Generally speaking, `Platform::*` types cannot
    be exported in WinRT types, as they are C++-specific implementations of WinRT
    interfaces (mostly). The notable exceptions are `Platform::String` and `Platform::Object`,
    which are understood as the replacement for `HSTRING` and `IInspectable` pointers
    respectively, and so are used in public methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Book` class provides the `Reviews` read-only property as `IVectorView<BookReview^>^`.
    It can return any object implementing this interface. The `Platform::Collections::Vector<T>`
    provides an implementation of `IVector<T>`. `IVector<T>` provides the `GetView`
    method, returning `IVectorView<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The property implementation tries to optimize by caching the `IVectorView<BookReview>`
    result if no new reviews are added, or the property is never called (indicated
    by a `nullptr` in `_reviews`). Otherwise, `Vector<BookReview>` is created, and
    `BookReview` objects are added with `IVector<BookReview>::Append`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last interesting method to implement is `AddReview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `_reviews` data member is set to `nullptr` to force future calls to the
    `Reviews` property to regenerate the returned collection.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with collections such as `std::vector` and its WinRT wrappers (such
    as `Vector<T>`), try to use `std::vector` as much as possible. Only use `Vector<T>`
    when exporting from a WinRT class. Make all collection manipulations on native
    C++ types as they have less overhead than WinRT types (because of the WinRT interface
    based nature).
  prefs: []
  type: TYPE_NORMAL
- en: Crossing the ABI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Application Binary Interface** (**ABI**) is the boundary between standard
    C++ and WinRT. Any C++ class that is not implemented as a WinRT class cannot cross
    the ABI. The previously used types `std::wstring` and `std::vector<>` are perfect
    examples of types that require projection when crossing the ABI. The compiler
    will not allow non-WinRT types to be used in public sections in `public ref class`
    declarations. See [Chapter 2](ch02.html "Chapter 2. COM and C++ for Windows 8
    Store Apps"), *COM and C++ for Windows 8 Store Apps* for further discussions on
    mapping native C++ types to WinRT types.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Windows Runtime Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a Windows Runtime Component is built, a metadata file (`.winmd`) is created
    that indicates which types, interfaces, enums, and so on are exported from the
    library. For example, our `BookLibrary` component DLL produces `BookLibrary.winmd`.
    Opening it in `ILDASM` shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming Windows Runtime Components](img/5022_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This clearly shows the exported types, `Book` and `BookReview`. The strange
    interface names represent the internal WinRT implementation provided by the compiler—WinRT
    is all about interfaces. The `*Factory` interfaces exist if there are any non-default
    constructors. For example, opening `__IBookFactory` shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming Windows Runtime Components](img/5022_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the `CreateInstance` method, modelled after the single constructor of `Book`.
    This interface is implemented by the activation factory that creates `Book` instances
    (implemented behind the scenes by C++/CX for any `public ref class`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__IBookPublicNonVirtuals` interface is the one implemented by the `Book`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming Windows Runtime Components](img/5022_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Consuming the resulting DLL is possible from any WinRT compliant environment.
    In a C++ project, a reference to the `winmd` file needs to be added. For that
    right-click on the project node in Solution Explorer and select **References…**.
    And then select **Add New Reference** in the **Common Properties** or **Framework
    and References** node (or get to the same location from the project properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming Windows Runtime Components](img/5022_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the reference is added (by selecting the `BookLibrary` project, or browsing
    for a `winmd` file in the general case), all exported types can be used immediately,
    just like any other WinRT type. Here''s an example of creating a `Book` with some
    reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Consuming the `BookLibrary` DLL from other environments, such as .NET can be
    similarly accomplished, as demonstrated in [Chapter 2](ch02.html "Chapter 2. COM
    and C++ for Windows 8 Store Apps"), *COM and C++ for Windows 8 Store Apps*. Each
    environment performs whatever projection is needed, all based on the metadata
    (`winmd`) file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WinRT components created with C++ are the only ones that guarantee not involving
    the .NET CLR. Components created by C# will always require the CLR, even if used
    from a C++ client.
  prefs: []
  type: TYPE_NORMAL
- en: Other C++ library projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking at the available project types in Visual Studio 2012 shows two more
    options for creating reusable libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other C++ library projects](img/5022_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The outlined projects create a classic DLL or static library, but do not, by
    default, generate a `winmd` file. These components can only be consumed by other
    C++ Store projects (WinRT components or other Store-enabled libraries). What's
    the difference in relation to a regular, classic C++ DLL, or static library? First,
    any usage of a forbidden Win32 API will cause a compiler error. Second, these
    projects cannot use C++/CX unless specific steps are performed, such as adding
    a reference to the `platform.winmd` and `windows.winmd` files.
  prefs: []
  type: TYPE_NORMAL
- en: Custom control templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Layout, Elements, and Controls"), *Layout,
    Elements, and Controls*, we discussed various elements and controls provided by
    WinRT. Customizing the appearance of elements and controls can be done using the
    following levels (from simple to complex). Of course, not all elements/controls
    support all levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Change property values; by far the simplest customizations are achieved by changing
    properties. Common examples are the font-related properties (`FontSize`, `FontFamily`,
    and so on), `Foreground` and `Background`, and many others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For content controls (those deriving from `ContentControl`), the `Content` property
    can be set to any element, as complex as required. For example, this can make
    a `Button` show images, text, and anything else that's required, while still maintaining
    the expected button behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data templates may be used for properties that support it, to display data objects
    in a rich and meaningful way. `ContentControl::Content` supports this, as it's
    typed as `Platform::Object^`, meaning it can accept anything. If this is a derived
    type that is not `UIElement`, the `DataTemplate` is used if provided (in this
    case through the `ContentControl::ContentTemplate` property). This is also used
    by all `ItemsControl` derivatives through the `ItemTemplate` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types derived from `ItemsControl` have the `ItemContainerStyle` and `ItemsPanel`
    properties that can further customize the way data is presented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the preceding list is impressive, there are times when these customizations
    are not enough. For example, a `Button` is always rectangular; and although it
    can contain anything (it's a `ContentControl`), it can never be elliptic. Some
    things are just "baked" into the control's appearance. This is where control templates
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between elements and controls is the existence of
    the `Control::Template` property that defines the way the control appears. Elements
    don't have this property. For example, an `Ellipse` is an ellipse, it cannot look
    like anything else, because that would violate its very definition. Thus, an `Ellipse`
    is an element and not a control.
  prefs: []
  type: TYPE_NORMAL
- en: Controls (deriving from `Control`) can change their `Template` property and
    have a different look (but preserve functionality). In fact, all controls have
    default templates that WinRT provides (otherwise, controls would have no "look").
  prefs: []
  type: TYPE_NORMAL
- en: Building a control template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A control template is of the type `ControlTemplate` . It's very similar to a
    `DataTemplate` (both derive from `FrameworkTemplate`), and can contain a single
    `UIElement` (typically a `Panel`) that comprises the control's look.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we'll build an alternate control template for the `ProgressBar`
    control. We'll start with simple steps, and add features as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'A control template is typically created as a resource, so it can be reused
    more easily. Here''s a first simple attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the template, we simply set it to the `Template` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea here is to create a dark blue rectangle on top of which another rectangle
    (with rounded corners) will show the current progress. The result, however, is
    less than ideal (the top `ProgressBar` is using the default template):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a control template](img/5022_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ProgressBar` doesn''t seem to show any progress (`Value="30"` should have
    shown 30 percent filled `ProgressBar`, as the default `Maximum` is `100`, just
    like the top `ProgressBar`). And why would it? We just created a `Rectangle`,
    which has a default `Width` of `0`. One way to get around this is to bind the
    `Width` property of the second `Rectangle` to the `Value` property of the `ProgressBar`.
    Here''s one way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`TemplateBinding` is a markup extension that binds to the control being templated.
    This is necessary, as we can''t use the `Source` or `ElementName` with a regular
    `Binding`. Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a control template](img/5022_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is certainly better, but the progress indicator seems small compared to
    the reference `ProgressBar` at the top. The reason is simple, `Value` is taken
    as `Width`, but it really should be proportional to the width of the entire `ProgressBar`.
    We can solve this by using a value converter, but there is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProgressBar` already has the smarts to set the `Width` property of some
    elements to the required proportional value. We just need to tell it which element
    it should be. It turns out this element must have a specific name, in this case
    `ProgressBarIndicator`. All we need to do is set the `x:Name` property to this
    value on the relevant element, our second `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a control template](img/5022_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now it looks exactly right. Where did that special name come from? The secret
    is looking at the control's default template, looking for specially named parts.
    All the default control templates can be found in the file `C:\Program Files (x86)\Windows
    Kits\8.0\Include\WinRT\Xaml\Design\Generic.xaml` (on 32-bit Windows systems, the
    directory starts with `C:\Program Files`). The control templates are part of the
    default styles for the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `ProgressBar` control template, most elements are named with
    uninteresting names, for example, `e1`, `e2`, and so on—`ProgressBarIndicator`
    stands out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In WPF and Silverlight, the `TemplatePart` attribute placed on controls indicate
    which named parts are looked up by the control and what their type should be.
    Although WinRT defines the `TemplatePart` attribute, it doesn't seem to be used
    in the current version of WinRT, so we resign ourselves to doing some "guesswork".
  prefs: []
  type: TYPE_NORMAL
- en: Using the control's properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The template now functions correctly (or so it seems). Changing properties,
    such as `Foreground` or `Background`, has no effect when using our new template.
    That''s because the template doesn''t use them in any way. Sometimes, this is
    what we want, but typical templates want to provide ways to customize their own
    appearance; one way is to leverage existing properties on the control. This was
    already briefly demonstrated with `TemplateBinding` to the `Value` property, but
    here''s a more interesting template, which uses several properties from `ProgressBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, there are several interesting things to note.
    The `TemplateBinding` markup extension is used to bind to the templated control's
    properties (`Background` and `Foreground`); `TemplateBinding` works for one-way
    bindings only (source to target, but not the other way around). For two-way binding
    properties, the longer syntax must be used, that is, a `Binding` expression with
    the `RelativeSource` property set to another markup extension, named `RelativeSource`
    (which should not be confused with the `Binding::RelativeSource` property name),
    which accepts `Mode` (also as a constructor parameter) that can be either `Self`
    (target and source are the same object, not useful here) or `TemplatedParent`,
    which means the control that is being templated, which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TemplateBinding` should have worked here as well, as we''re only interested
    in the one-way binding. But, since `Value` can be bound two way, `TemplateBinding`
    fails. This seems to be a bug in the current WinRT implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `ProgressBar` that uses this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the control''s properties](img/5022_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling state changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `ProgressBar` normally shows the progress of an operation. Sometimes, however,
    the application doesn''t know the progress of an operation—it only knows that
    it''s underway. A `ProgressBar` can indicate this by setting its `IsIndeterminate`
    property to `true`. Here''s how a standard `ProgressBar` appears in this mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling state changes](img/5022_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's actually difficult to capture a static image of that, as the `ProgressBar`
    shows an interesting nonlinear animation consisting of small circles.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `IsIndeterminate` to `true` on the `ProgressBar` that uses our template
    has no effect on the way the `ProgressBar` is shown. That's because our control
    didn't take into account this property.
  prefs: []
  type: TYPE_NORMAL
- en: How can we solve that? One way would be to add something to the control template
    that would be hidden by default, but if `IsIndeterminate` turns to `true`, something
    will become visible and indicate that the `ProgressBar` is in that special mode
    (with a value converter, for instance). Although this is technically possible,
    that's not the way it's typically done. One of the reasons is that some state
    changes can be difficult to monitor with just bindings and value converters—for
    example, if the mouse cursor hovers over the control (not relevant for a `ProgressBar`,
    but relevant for many other controls), a property may not be enough. And how would
    we start an animation?
  prefs: []
  type: TYPE_NORMAL
- en: All these state changes and reactions are handled through an auxiliary object,
    known as `VisualStateManager`. A control transitions between states; these states
    and their transitions can be captured by the `VisualStateManager`. For each change,
    a set of `Storyboard` objects can be provided; these `Storyboard` objects represent
    animations in the general case, or simple state changes in a particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an extended template that deals with the effects of the `IsIndeterminate`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `VisualStateManager` has one interesting property, which is an attached
    property, `VisualStateGroups`. For each group, one state is always active; this
    means a control can be in several states at once. For example, a button can be
    in a pressed state and in a keyboard-focused state. The `VisualStateGroups` property
    must be set on the top-level `Panel` comprising the control template (a `Grid`
    in our case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `VisualStateGroup` consists of `VisualState` objects that indicate what
    to do (which animations to run) for each state. The state names must be the correct
    names, as the control changes to these states based on its internal logic. How
    did we know which state groups exist and which states are in each group? This
    is done by looking at the default control template. This can be done by looking
    in the aforementioned file, but can also be achieved with Visual Studio 2012 by
    right-clicking on a control, and selecting **Edit Template** | **Edit a Copy…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling state changes](img/5022_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the control template, a third rectangle named `IndetRect` was created with
    an initial opacity of zero, making it invisible. When the `ProgressBar` moves
    into the `Indeterminate` state, an animation is executed using the `DoubleAnimation`
    class (animating a property of the type `double`) that changes the opacity of
    that rectangle to `1` (fully shown) in one second (the `Duration` property), with
    auto reverse (`AutoReverse="true"`) and animating forever (`RepeatBehavior="Forever"`).
    Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling state changes](img/5022_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And the opacity is animating, fading in and out of this rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete cover of animations is beyond the scope of this book, but this should
    give you a sense of it. A `Storyboard` represents a time line, in which animation
    objects are played, in this case a `DoubleAnimation` object, but there are many
    others.
  prefs: []
  type: TYPE_NORMAL
- en: How does the state actually change? The control, with its own logic, calls the
    static `VisualStateManager::GoToState` method, setting the new state within a
    particular group. For a control template's author, that does not matter; the only
    thing that matters is setting the required animations according to the expected
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `VisualStateManager` also allows specifying the actual transition to take
    place when state changes occur. This is in contrast to the actual state itself.
    What this means is that a transition can be temporary when moving to a particular
    state, but the state itself may have different animations. For further information,
    refer to the MSDN documentation, starting with the `VisualStateGroup::Transitions`
    property and the `VisualTransition` class.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing using attached properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ProgressBar` template created thus far used properties set on the `ProgressBar`
    itself using the `TemplateBinding` markup extension, or a regular `Binding` with
    a `Source` specified with the `RelativeSource` markup extension and with `TemplatedParent`
    as its `Mode`. What about adding properties that only make sense for our template?
    For example, in the preceding template definition, the `ProgressBar` shows a text
    string of its value. What if we wanted to allow the template user to hide the
    text or change its color?
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgressBar` was not created with all this in mind. And why would it? It
    was created with the needed properties for some customization level; this is acceptable
    for the default `ProgressBar` template.
  prefs: []
  type: TYPE_NORMAL
- en: One way to get around this is to create a new class that derives from `ProgressBar`
    and add the required properties. Although this works (and we'll discuss custom
    controls in the next section), this is somewhat inelegant—we don't need any new
    functionality from the `ProgressBar`, rather we need some properties to tweak
    its template.
  prefs: []
  type: TYPE_NORMAL
- en: A more elegant solution is to use attached properties, which are defined on
    one class, but can be used by any other class (it must be derived from `DependencyObject`,
    though). Technically, we can look for appropriate attached properties defined
    elsewhere in WinRT, but it's better to create a new class that defines these attached
    properties and use them in the `ProgressBar` template.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an attached property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Attached properties are dependency properties (which we''ll discuss in detail
    in the next section) that are registered by calling the static `DependencyProperty::RegisterAttached`
    method. This sets up a static field that manages this property for all objects
    using it. Two static methods accompany the registration that actually sets and
    gets the attached property value on an object. Here''s the declaration of a class,
    `ProgressBarProperties` that defines a single attached property, `ShowText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The static field must be initialized and this is done in the CPP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `RegisterAttached` method accepts the property name, its type (as a `TypeName`
    structure), the type of its owner, and a `PropertyMetadata` instance that can
    accept the default value of the property (if not set on an actual object and that
    property is queried). A more detailed explanation of `PropertyMetadata` can be
    found in the next section, where dependency properties are described; for now,
    we'll focus on the attached property usage in control templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextBlock` inside the `ProgressBar` template can use the attached property
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The parenthesis around the property path is required, otherwise the XAML parser
    fails to understand the expression correctly, which results in a runtime binding
    failure. The converter used is for converting a `Boolean` to a `Visibility` enumeration,
    as was demonstrated in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data
    Binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, defining and registering an attached property is simple, yet verbose.
    One solution would be to define macros to automate this boilerplate code. The
    downloadable source for this chapter has some macros for defining and registering
    dependency and attached properties that should make these easier to work with
    (in a file called `DPHelper.h`). Here''s an example of another attached property,
    defined using the aforementioned macros. First, inside the `ProgressBarProperties`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the implementation file (to initialize the static field):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This property can be used inside the template on the `TextBlock` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control templates provide a powerful and complete way to change the control's
    appearance. But that's just appearance—the control still behaves in the same way.
    If a new functionality is required, templates are not enough, and a new class
    should be created. This is where custom elements come in.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of authoring custom elements in WinRT, we'll take a look
    at the two most frequently used controls—user controls and custom controls. Then,
    we'll briefly discuss how to create custom panels and custom shapes.
  prefs: []
  type: TYPE_NORMAL
- en: User controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user control is typically used to group related elements and controls together,
    for the purpose of re-use. Appropriate properties and events are exposed from
    this control, providing easy access to its functionality. As an added bonus, Visual
    Studio supports user control UI design, just as it does for a regular page.
  prefs: []
  type: TYPE_NORMAL
- en: User controls derive from the `UserControl` class. The UI design is effectively
    the `Content` property of the control, just like a `ContentControl` . They are
    typically placed in their own Windows Runtime Component project so that they can
    be used in any WinRT project, using C++ or another language.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a color picker user control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example of a user control, we''ll create a color picker control, which
    allows for selecting a solid color by manipulating three sliders for the red,
    green, and blue color components (RGB). To begin, after creating a Windows Runtime
    Component project, we can add a new item of the type **User Control** to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a color picker user control](img/5022_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A design surface is opened with the usual pair of files created, `ColorPicker.h`
    and `ColorPicker.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to do is define properties that would provide easy access
    to the user control's functionality. Most of the time, these will not be simple
    properties that wrap some private field, but rather dependency properties.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simple properties that wrap a field (perhaps with some validation in the setter)
    lack certain features that are desirable when working with a UI framework. Specifically,
    WinRT dependency properties have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Change notifications when the property's value is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various providers can attempt to set the property's value, but only one such
    provider wins at a time. Nevertheless, all values are retained. If the winning
    provider goes away, the property's value is set to the next winner in the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property value inheritance down the visual tree (for some predefined set of
    properties).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No memory is allocated for a property's value if that value is never changed
    from its default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features provide the basis of some of WinRT's powerful capabilities, such
    as data binding, styles, and animation.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, these properties look the same as any other property—a getter
    and a setter. But no private fields are involved. Instead, a static field manages
    the property values for all instances using that property.
  prefs: []
  type: TYPE_NORMAL
- en: Defining dependency properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the way to define a dependency property (must be done in a class that
    derives from `DependencyObject`, which is always the case with `UserControl`).
    A private static field manages the property, which is exposed publicly as a read-only
    property. A setter and getter exist as easy access to the actual `set` and `get`
    methods, implemented in the `DependencyObject` base class. The following code
    demonstrates the creation of a dependency property of the type `Windows::UI::Color`
    named `SelectedColor` that is exposed by the `ColorPicker` user control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetValue` and `SetValue` properties are inherited from `DependencyObject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static property's name should be suffixed with `Property`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's never a good idea to add more code to the `get()` or `set()` parts of the
    property, because these are sometimes not used and one can call the `GetValue`
    and `SetValue` methods directly; this is done by the XAML parser, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The missing part is the initialization of the static field, typically done
    in the `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A **dependency property** (**DP**) is registered by calling the static `DependencyProperty::Register`
    method, passing the property name, its type (as a `TypeName` structure), the containing
    type, and the `PropertyMetadata` object, which can accept the property's default
    value (`Colors::Black` in this case) and an optional callback to invoke when the
    property changes. This will be useful in the `ColorPicker` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code can repeat numerous times, once for each DP. This clearly calls out
    for some helper macros. Here are three other properties defined on the `ColorPicker`
    using the macros. First, in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is considerably shorter (and less error prone) than the verbose version.
    These macros can be found in the `DPHelper.h` file, available with the downloadable
    source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is implement the change notification methods, if they
    exist. In this case, `Red`, `Green`, and `Blue` should reflect the `SelectedColor`
    property color components, and vice versa. First, if `Red`, `Green`, or `Blue`
    changes, use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since the registered handler must be static, it's easier to delegate the actual
    work to an instance method (`OnRGBChangedInternal` in the preceding code). The
    code updates the `SelectedColor` property based on the changed RGB property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other direction implementation is along the same lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code snippets may seem to create an infinite loop—if `Red` changes,
    `SelectedColor` changes, which changes `Red` again, and so on. Fortunately, this
    is handled automatically by the dependency property mechanism, which invokes the
    callback if the property value actually changes; setting to the same value does
    not invoke the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Building the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to create the actual UI of the user control using regular
    XAML. Binding expressions can be used to bind to properties exposed by the control
    (since these are DPs, they provide automatic change notification for bindings).
    Here''s a UI for the `ColorPicker` with the sliders bound to the `Red`, `Green`,
    and `Blue` properties and a `Rectangle` that binds to the `SelectedColor` property
    of the control (default XAML namespaces are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Adding events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Events can be added to the user control to notify interested parties of interesting
    events. Here''s an event added in the header file of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The event uses the `EventHandler<T>` delegate that requires the client to provide
    a method that accepts a `Platform::Object^` and a `T` (`Color` in this case).
    We''ll raise the event when the `SelectedColor` property changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using the ColorPicker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can use the `ColorPicker` in another project, by adding a reference
    in the usual way and adding an XML namespace mapping. Then just use the control
    like any other. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The control is placed inside a border and its `SelectedColorChanged` event
    is handled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the `TextBlock` at the bottom of the control. This is how it looks
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the ColorPicker](img/5022_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User controls are great for encapsulating a piece of UI functionality that can
    be easily reused. Their potential disadvantage is the lack of deep customization.
    Suppose in the `ColorPicker` example, we would like to have the sliders placed
    vertically rather than horizontally, or we want an ellipse rather than a rectangle.
    Although it's possible to add properties that would allow some customization,
    there's no way we can anticipate everything.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to create a custom control with a default control template that
    can be changed completely as desired, while still retaining the original functionality.
    This is exactly how the regular WinRT controls are built.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ColorPicker custom control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A custom (also known as templated) control derives from the `Control` class.
    A good starting point is the Visual Studio Templated Control template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a ColorPicker custom control](img/5022_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a pair of files, `ColorPicker.h` and `ColorPicker.cpp`, and an
    XAML file named `Generic.xaml` that holds the default style for the `ColorPicker`
    that includes the default template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All custom control styles must reside in the same `Generic.xaml` file. Its name
    and origin lie in WPF, which supports different styles for different Windows UI
    Themes. This is not relevant to WinRT, but the convention remains.
  prefs: []
  type: TYPE_NORMAL
- en: Practically, when authoring multiple custom controls, using the same file is
    inconvenient at best. This can be remedied by using the `ResourceDictionary::MergedDictionaries`
    property to include other XAML files into `Generic.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default template looks much the same as the default UI created for the
    user control, with one important difference; no data binding expressions. The
    reason is that if there were bindings, a custom template would have to duplicate
    those to maintain functionality and this puts an unreasonable burden on custom
    template authors; the alternative is binding in code. Here''s the revised markup
    for the default template of `ColorPicker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The interesting parts of the template are assigned names. These names will be
    looked up by the control and bound in code. These are the named parts discussed
    at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Binding in code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining the dependency properties and events in a custom control is exactly
    the same as with a user control.
  prefs: []
  type: TYPE_NORMAL
- en: When a template is applied to a control, the virtual `Control::OnApplyTemplate`
    method is called. This is the best opportunity for the control to hunt down its
    named parts and connect to them using bindings, or event handlers, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bind the three sliders, a helper method is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The method uses `GetTemplateChild()` to get a named element. If that element
    does not exist, `nullptr` is returned. A typical control simply moves on and does
    not throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the code casts to `RangeBase` rather than `Slider`. This is possible
    because the required property is `Value` defined on `RangeBase`. This means that
    this can be something other than a `Slider`, as long as it derives from `RangeBase`
    (for example,. `ScrollBar` or `ProgressBar`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, a binding is created in code by instantiating a `Binding` object, setting
    the source object (the `Source` and `Path` properties), binding mode (the `Mode`
    property), and converter (if needed, using the `Converter` property), and then
    finally calling `BindingOperations::SetBinding` with the target object, the target
    DP, and the binding instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `OnApplyTemplate` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The three potential sliders (actually the controls derived from `RangeBase`)
    are bound, and then the `SolidColorBrush` is bound, if it exists. This means it
    can be the `Fill` of a `Rectangle`, an `Ellipse`, or the `BorderBrush` of a `Border`—as
    long as it's a `SolidColorBrush`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the custom control is the same as using the user control. But, it's possible
    to replace the control template (as was done at the beginning of this chapter
    with the `ProgressBar`) to create a `ColorPicker` that looks different, yet has
    the same functionality, all with no code at all—just XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Custom panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WinRT provides the standard panels deriving from `Panel`. It's possible to create
    new panels that arrange their children in unique ways, such as a radial panel,
    whose children are arranged along the circumference of an ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: The layout process is a two-step process—measure and arrange. This is modelled
    precisely by the methods of `Panel` to override two methods for this exact purpose,
    `MeasureOverride` and `ArrangeOverride`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MeasureOverride` asks the panel (or any element that overrides it for that
    matter) what size it requires. For a panel, the main concern is the requirements
    of its child elements. The panel should call `UIElement::Measure` for each child
    element, causing its own `MeasureOverride` to be called (and this may go on if
    that child is a panel, or acts like a panel, in itself).'
  prefs: []
  type: TYPE_NORMAL
- en: The panel needs to decide what size it requires based on its children's requirements
    and the layout logic it wants to employ. The parameter sent to `MeasureOverride`
    is the available size provided by that panel's container. This can be an infinite
    size in either one or both dimensions (for example, a `ScrollViewer` indicates
    it has infinite space in directions where scrolling is available). It's important
    to return a finite size; otherwise WinRT has no way of knowing how much space
    to leave for the panel and throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrangeOverride` is a more interesting method that actually implements a special
    layout logic, for which the panel was created. The panel calls `UIElement::Arrange`
    on each element that forces that element to be placed within a specific rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This procedure is almost identical to the way it's done in WPF or Silverlight;
    many such examples are on the web, and can be converted to WinRT with little difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Custom drawn elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom drawn elements can be created in WinRT by deriving them from the `Windows::UI::Xaml::Path`
    class, which is a kind of `Shape`. A `Path` is based on a `Geometry`—a mathematical
    abstraction of a 2D layout that can be a `PathGeometry` , which in itself can
    be built from various `PathSegment` objects. These shapes are beyond the scope
    of this book, but, again, they are similar to the ones existing in Silverlight,
    so a lot of information about them is available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WinRT currently does not support WPF's `OnRender` method that uses `DrawingContext`
    to do free-style drawing of various kinds. Hopefully, this will be supported in
    a future version.
  prefs: []
  type: TYPE_NORMAL
- en: Many new controls exist as part of the WinRT XAML toolkit, available for free
    on Microsoft's CodePlex site at [http://winrtxamltoolkit.codeplex.com/](http://winrtxamltoolkit.codeplex.com/).
    The problem with the toolkit is that it's written as a .NET class library, and
    so can only be used by .NET projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the backbone of module re-use. True WinRT components use WinRT
    types only and so can be exported to any WinRT-compatible environment, such as
    C++/CX, .NET, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Control templates provide the ultimate control customization mechanism that
    can be done in XAML alone, with little or no code (code may be needed if value
    converters are used). Templates are appropriate if the control's appearance needs
    to change, but its functionality should remain intact, and is what's needed.
  prefs: []
  type: TYPE_NORMAL
- en: Custom and user controls are used when new functionality is needed that is not
    provided by any built-in control. By deriving from `UserControl` and `Control`,
    dependency properties and events can be added to create a new reusable control.
  prefs: []
  type: TYPE_NORMAL
- en: User controls and custom controls should be packaged in such WinRT components
    for easy re-use by C++ and other projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at some of the special features of Windows
    Store apps, such as Live Tiles and Push Notifications. These (and other) capabilities
    can make your Store app unique and appealing.
  prefs: []
  type: TYPE_NORMAL
