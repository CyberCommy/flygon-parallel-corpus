- en: Chapter 4. Designing for Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is an architectural style confirming to the web architecture design and
    needs to be properly designed and implemented so that it allows you to take advantage
    of the scalable web. This chapter covers advanced design principles related to
    performance that every developer must know when building RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous and long-running jobs in REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP PATCH and partial updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will elaborate on the different HTTP cache headers and learn how to send
    conditional requests to see whether the new content or the cached content needs
    to be returned. We will then show with samples how to use JAX-RS to implement
    caching.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will cover how the Facebook API uses ETags for caching. Next,
    we will walk through asynchronous request response processing with JAX-RS and
    best practices. Finally, we will cover HTTP PATCH method and learn how to implement
    partial updates and common practices around partial updates.
  prefs: []
  type: TYPE_NORMAL
- en: Different snippets of code are included in the chapter, but complete samples
    that show these snippets in action are included as part of this book's source
    code download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Caching principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the different programming principles when designing
    RESTful services. One of the areas we will cover is caching. Caching involves
    storing response information related to the requests in a temporary storage for
    a specific period of time. This ensures the server is not burdened with processing
    those requests in future when the responses can be fulfilled from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The cache entries can be invalidated after a specific time interval. The cache
    entries can also be invalidated when the objects, which are in the cache, change,
    for example, when some API modifies or deletes a resource.
  prefs: []
  type: TYPE_NORMAL
- en: There are many benefits to caching. Caching helps to reduce **latency** and
    improve application responsiveness. It helps in reducing the number of requests
    the server has to deal with and thus the server is able to handle more requests,
    and the clients will get responses quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, assets such as images, JavaScript files, and stylesheets can all
    be cached fairly heavily. Also, it is advisable to cache responses, which may
    require intensive computation on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Caching details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following section covers the topics related to caching. The key to making
    caching work effectively is to use HTTP caching headers that specify how long
    a resource is valid and when it was last changed.
  prefs: []
  type: TYPE_NORMAL
- en: Types of caching headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next section covers the types of caching headers followed by examples of
    each type of caching header. The following are the types of headers:'
  prefs: []
  type: TYPE_NORMAL
- en: Strong caching headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak caching headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong caching headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strong caching headers specify for how long a cached resource is valid and
    the browser does not need to send any more `GET` requests till that period. `Expires`
    and `Cache-Control max-age` are strong caching headers.
  prefs: []
  type: TYPE_NORMAL
- en: Weak caching headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The weak caching headers help the browser decide if it needs to fetch an item
    from the cache by issuing a conditional `GET` request. `Last-Modified` and `ETag`
    are examples of weak caching headers.
  prefs: []
  type: TYPE_NORMAL
- en: Expires and Cache-Control – max-age
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Expires` and `Cache-Control` headers specify the time period during which
    the browser can use the cached resource without checking for a newer version.
    The newer resource will not be fetched until the expiry date or maximum age specified
    is reached if these headers are set. The `Expires` header takes a date after which
    the resource becomes invalid. Instead of specifying a date, the `max-age` attribute
    mentions how long the resource is valid after it is downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache-Control header and directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In **HTTP 1.1**, the `Cache-Control` header specifies the resource caching
    behavior as well as the maximum age the resource can be cached. The following
    table shows the different directives of the `Cache-Control` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | When this directive is used, the browser can cache the object,
    but proxies and content delivery networks cannot |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | When this directive is used, an object can be cached by browser,
    proxies, and content delivery networks |'
  prefs: []
  type: TYPE_TB
- en: '| `no-cache` | When this directive is used, an object will not be cached |'
  prefs: []
  type: TYPE_TB
- en: '| `no-store` | When this is used, an object can be cached in memory but should
    not be stored on disk |'
  prefs: []
  type: TYPE_TB
- en: '| `max-age` | This denotes the time for which the resource is valid |'
  prefs: []
  type: TYPE_TB
- en: 'Here is an example of a response with the `Cache-Control HTTP/1.1` header in
    a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding response has a `Cache-Control` header with directives as `private`
    and `max-age` set to 24 hours or 86400 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a resource is invalid based on the `max-age` or `Expires` header, the
    client can request the resource again or send a conditional `GET` request that
    gets the resource only if it has changed. This can be achieved by the weaker caching
    headers: the `Last-Modified` and ETag headers as shown in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Last-Modified and ETag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These headers enable the browser to check if the resource has changed since
    the last `GET` request. In the `Last-Modified` header, there is a date associated
    with the modification of the resource. In the ETag header, there can be any value
    that uniquely identifies a resource (like a hash). However, these headers allow
    the browser to efficiently update its cached resources by issuing conditional
    `GET` requests. Conditional `GET` requests will return the full response only
    if the resource has changed at the server. This ensures conditional `GET` requests
    will have lower latency than full `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache-Control header and the REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code shows how to add the `Cache-Control` header to a JAX-RS response.
    The sample is available as part of the book's downloadable source bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: JAX-RS has a `javax.ws.rs.core.Cache-Control` class, which is an abstraction
    for the `HTTP/1.1 Cache-Control` header. The `setMaxAge()` method on the `cacheControl`
    object corresponds to the `max-age` directive and `setPrivate(true)` corresponds
    to the `private` directive. The response is built using the `responseBuilder.build()`
    method. The `cacheControl` object is added to the `Response` object that is returned
    by the `getCoffee()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the response with headers produced by this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: ETags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP defines a powerful caching mechanism that includes the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ETag` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `If-Modified-Since` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `304 Not Modified` response code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How ETags work
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following section digs into some basics of how ETags work. The following
    diagram gives a better picture of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How ETags work](img/7963OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at each of the processes related to ETags:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a `GET` request to the [http://api.com/coffee/1234](http://api.com/coffee/1234)
    REST resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends back a **200 OK** with an **ETag** value, for example, "**123456789"**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After some time, the client sends another `GET` request to [api.com/coffee/1234](http://api.com/coffee/1234)
    REST resource along with the `If-None-Match: "123456789"` header.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server checks if the resource MD5 hash has not been modified, then sends
    a `304 Not-Modified` response with no response body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the resource had changed, a 200 OK would be sent as the response. Additionally,
    as part of the response, a new ETag is sent by the server.
  prefs: []
  type: TYPE_NORMAL
- en: The ETag header and the REST API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows how to add the `ETag` header to the JAX-RS response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet of code, the instance of `javax.ws.core.EntityTag`
    object is created by using a hash of the resource, which for simplicity, we have
    "123456789".
  prefs: []
  type: TYPE_NORMAL
- en: The `request,evalautePreconditions` method checks for the value of the `EntityTag
    et` object. If the preconditions are met, it returns a response with `200 OK`.
  prefs: []
  type: TYPE_NORMAL
- en: The `EntityTag` object, `et`, is then sent with the response, which is returned
    by the `getCoffeeWithETag` method. For more details, please refer to the sample
    available as part of the source bundle for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Types of ETags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A strongly validating ETag match indicates that the content of the two resources
    is byte-for-byte identical and that all other entity fields (such as Content-Language)
    are also unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: A weakly validating ETag match only indicates that the two resources are semantically
    equivalent, and that cached copies can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Caching helps reduce the number of requests made by the client. It also helps
    in reducing the number of complete responses saving bandwidth and computational
    time with the conditional `GET` requests and ETags, `IF-None-Match` headers, and
    `304-Not Modified` response.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to specify either `Expires` or `Cache-Control max-age`
    along with one of the two `Last-Modified` and ETag headers in the HTTP response.
    Sending both `Expires` and `Cache-Control max-age` is redundant. Similarly, sending
    both `Last-Modified` and ETag is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: The Facebook REST API and ETags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Facebook Marketing API supports ETags on the Graph API. When the consumer
    makes a Graph API call, the response header includes an ETag with a value that
    is the hash of the data returned in the API call. Next time the consumer makes
    the same API call, he can include the `If-None-Match` request header with the
    ETag value saved from the first step. If the data has not changed, the response
    status code will be `304 –Not Modified` and no data is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the data on the server side has changed since the last query, the data is
    returned as usual with a new ETag. This new value of ETag can be used for subsequent
    calls. For more details, check [http://developers.facebook.com](http://developers.facebook.com).
  prefs: []
  type: TYPE_NORMAL
- en: RESTEasy and caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RESTEasy is a JBoss project that provides various frameworks to help build RESTful
    web services and RESTful Java applications. RESTEasy can run in any servlet container,
    but has a tighter integration with the JBoss Application Server.
  prefs: []
  type: TYPE_NORMAL
- en: RESTEasy provides an extension to JAX-RS that allows setting `Cache-Control`
    headers on a successful `GET` request automatically.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides a server-side, local, in-memory cache that can sit in front
    of the JAX-RS services. It automatically caches marshalled responses from HTTP
    GET JAX-RS invocations if the JAX-RS resource method sets a `Cache-Control` header.
  prefs: []
  type: TYPE_NORMAL
- en: When a `HTTP GET` request arrives, the RESTEasy server cache will check to see
    if the URI is stored in the cache. If it does, it returns the already marshalled
    response without invoking the JAX-RS method.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, check [http://www.jboss.org/resteasy](http://www.jboss.org/resteasy).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tips when caching on the server side**'
  prefs: []
  type: TYPE_NORMAL
- en: Invalidate the cache entry for a `PUT` or a `POST` request. Do not cache a request
    that has a query parameter, as once the query parameter value changes the cached
    response from the server may not be valid.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous and long-running jobs in REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common pattern in developing RESTful API is to deal with asynchronous and
    long-running jobs. API developers need to create resources that might take a considerable
    amount of time. They cannot have the clients wait on the API to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Consider placing an order for a coffee at a coffee shop. The order details are
    stored in a queue and when the barista is free, he processes your order. Till
    then you get a receipt acknowledging your order but the actual coffee arrives
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous resource processing works on the same principles. Asynchronous
    resources mean the resources cannot be created immediately. Maybe it will be placed
    inside a task/message queue that will handle the actual creation of the resource
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following request to order a small coffee in our sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The response can be sent back as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The response sends back a `202 Accepted` header. The `Location` header can provide
    details about the coffee resource.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous request and response processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asynchronous processing is included in both client- and server-side APIs
    of JAX-RS 2.0 to facilitate asynchronous interaction between client and server
    components. The following list shows the new interfaces and classes added to support
    this feature on the server and the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncResponse`: This is an injectable JAX-RS asynchronous response that provides
    means for asynchronous server-side response processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Suspended`: The `@Suspended` annotation instructs the container that the
    HTTP request processing should happen in a secondary thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionCallback`: This is a request-processing callback that receives request-processing
    completion events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionCallback`: This is an asynchronous request-processing lifecycle
    callback that receives connection-related asynchronous response lifecycle events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvocationCallback`: This is a callback that can be implemented to receive
    the asynchronous processing events from the invocation processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future`: This allows the client to poll for completion of the asynchronous
    operation or to block and wait for it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Future` interface introduced in Java SE 5 provides two different mechanism
    to get the result of an asynchronous operation: first by invoking the `Future.get(…)`
    variants that blocks until the result is available or a timeout occurs, and the
    second way is to check for completion by invoking the `isDone()` and `isCancelled()`,
    which are Boolean methods that return the current status of `Future`. For more
    details, check [http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the asynchronous request/response processing in
    JAX-RS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous request and response processing](img/7963OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The client makes a request for an asynchronous method on `CoffeeResource`. The
    `CoffeeResource` class creates a new thread, which can do some intensive operation
    and then send back the response. Meanwhile, the request thread is released and
    can handle other requests. When the thread working on the operation finishes the
    processing, it returns the response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows how an asynchronous resource can be developed
    using JAX-RS 2.0 API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `CoffeesResource` class is a stateless session bean, which has a method
    called `order()`. This method is annotated with the `@Asynchronous` annotation,
    which will work in the fire-and-forget manner. When the resource is requested
    by the client through the `order()` method's resource path, a new thread is spawned
    to work on preparing the request's response. The thread is submitted to the executor
    for execution and the thread processing the client request is released (via `ctx.suspend`)
    to process other incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: When the worker thread, created to prepare the response, is done with preparing
    the response, it invokes the `ctx.resume` method, which lets the container know
    the response is ready to be sent back to the client. If the `ctx.resume` method
    is invoked before the `ctx.suspend` method (the worker thread has prepared the
    result before the execution reaching the `ctx.suspend` method), the suspension
    is ignored and the result will be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same functionality can be achieved using the `@Suspended` annotation that
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `@Suspended` annotation is cleaner as this does not involve the use
    of the `ExecutionContext` variable to instruct the container to suspend and then
    resume the communication thread when the worker thread, aka the `prepareResponse()`
    method in this case, is finished. The client code to consume the asynchronous
    resource can use the callback mechanism or polling at the code level. The following
    code shows how to use polling via the `Future` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code begins with forming the request to the `Coffee` resource. It uses the
    `javax.ws.rs.client.Client` instance to call the `target()` method, which creates
    a `javax.ws.rs.client.WebTarget` instance for the `Coffee` resource. The `Future.get(…)`
    method blocks until the response is back from the server or the 30 seconds timeout
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another API for the asynchronous client is to use the `javax.ws.rs.client.InvocationCallback`
    instance, which is a callback that can be implemented to get asynchronous events
    from the invocation. For more details, check [https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html](https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/     client/InvocationCallback.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous resources best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section lists the best practices when working with asynchronous
    RESTful resources.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a 202 Accepted message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For asynchronous requests/responses, the API should send back a `202 Accepted`
    message, in case the request is valid and the resource may be available in time,
    even if it is a few seconds. `202 Accepted` means the request has been accepted
    for processing and the resource will be available shortly. The `202 Accepted`
    message should specify the `Location` header, which can be used by the client
    to know where the resource will be available once it is created. The API should
    not send back a `201 Created` message if the response is not available immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Setting expiration for objects in the queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API developer should expire the objects after a certain amount of time in
    the queue. This ensures queue objects do not accumulate over time and are purged
    periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Using message queues to handle tasks asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API developer should consider using message queuing for asynchronous operations
    so that the messages are placed in the queue until a receiver receives them. **Advanced
    Messaging Queuing Protocol** (**AMQP**) is a standard that enables reliable and
    secure routing, queuing, publishing, and subscribing of messages. For more details,
    check Advanced Message Queuing Protocol at [http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).
  prefs: []
  type: TYPE_NORMAL
- en: For example, when an asynchronous resource method is invoked, use message queuing
    to send messages and handle different tasks based on messages and events asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample, if a coffee order is placed, a message can be sent using RabbitMQ
    ([http://www.rabbitmq.com/](http://www.rabbitmq.com/)) to trigger the `COMPLETED`
    event. Once the order is completed, the details can be moved to an inventory system.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers another important detail for RESTful services for doing
    partial updates.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP PATCH and partial updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common problem for API developers is to implement partial updates. This can
    happen when the client sends a request that must change just one part of a resource''s
    state. For example, imagine that there is a JSON representation of your `Coffee`
    resource that looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once the order is completed, the status needs to be changed from `"PROCESSING"`
    to `"COMPLETED"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an RPC-style API, this could be handled by adding a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the REST case using the `PUT` method, all the data like this needs to be
    sent, which will waste bandwidth and memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid sending the whole data for a minor update, another solution is to
    use `PATCH` to do a partial update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, not all web servers and client will provide support for `PATCH`, so
    people have been supporting both partial updates with `POST` and `PUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial updates with `PUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, using either `PUT` or `POST` for partial updates are both acceptable.
    The Facebook API uses `POST` to update partial resources. Using partial `PUT`
    would be more consistent with how we implement RESTful resources and methods as
    CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement support for the `PATCH` method, here is how to add an annotation
    in JAX-RS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how to associate the annotation of `javax.ws.rs.HTTPMethod`
    with the name "`PATCH`". Once this annotation is created, then the `@PATCH` annotation
    can be used on any JAX-RS resource method.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Patch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON Patch is part of RFC 6902\. It is a standard designed to allow performing
    operations on JSON documents. JSON Patch can work with the `HTTP PATCH` method.
    It is useful to provide partial updates to JSON documents. The media type `"application/json-patch+json"`
    is used to identify such patch documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op`: This identifies the operation to be performed on the document. The acceptable
    values are `"add"`, `"replace"`, `"move"`, `"remove"`, `"copy"`, or `"test"`.
    Any other value is an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: This is the JSON pointer that represents the location in the JSON document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This denotes the value to be replaced in the JSON document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `move` operation takes a `"from"` member, which identifies the location
    in the target document to move the value from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a JSON Patch document sent in a `HTTP PATCH` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding request shows how JSON Patch can be used to replace the status
    of a coffee order identified by resource `coffee/orders/1234` .The operation,
    that is, `"op"` in the preceding snippet, is `"replace"`, which sets the value
    `"COMPLETED"` to the status object in the JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON Patch is very useful for single-page applications, real-time collaboration,
    offline data changes, and can also be used in applications that need to make small
    updates in large documents. For more details, check [http://jsonpatchjs.com/](http://jsonpatchjs.com/),
    which is an implementation of `JSON Patch.(RFC 6902)` and `JSON Pointer.(RFC 6901)`
    under the MIT License.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section lists some of the online resources that are related to
    the topics covered in this chapter and may be useful for review:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RESTEasy: [http://resteasy.jboss.org/](http://resteasy.jboss.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Couchbase: [http://www.couchbase.com/](http://www.couchbase.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Facebook Graph API Explorer: [https://developers.facebook.com/](https://developers.facebook.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RabbitMQ: [https://www.rabbitmq.com/](https://www.rabbitmq.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON Patch RFC 6902: [http://tools.ietf.org/html/rfc6902](http://tools.ietf.org/html/rfc6902)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON Pointer RFC 6901: [http://tools.ietf.org/html/rfc6901](http://tools.ietf.org/html/rfc6901)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered some serious ground introducing fundamental concepts of
    caching, demonstrating the different HTTP caching headers such as `Cache-Control`,
    `Expires`, and so on. We also saw how headers work and how ETags and `Last-Modified`
    headers work for conditional `GET` requests that can improve performance. We covered
    best practices for caching, how RESTEasy supports server-side caching, and how
    Facebook API uses ETags. This chapter addressed asynchronous RESTful resources
    and best practices when working with an asynchronous API. We covered HTTP Patch
    and partial updates along with JSON Patch (RFC 6902).
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will deal with advanced topics that every developer building
    RESTful services should know related to commonly used patterns and best practices
    in areas of rate limiting, response pagination, and internationalization of REST
    resources. It will also cover additional topics such as HATEOAS, REST, and their
    extensibility.
  prefs: []
  type: TYPE_NORMAL
