- en: Chapter 2. Creating Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on how to create C++ classes and structs that integrate
    well with the UE4 Blueprints editor. These classes are graduated versions of the
    regular C++ classes, and are called `UCLASS`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `UCLASS` is just a C++ class with a whole lot of UE4 macro decoration on top.
    The macros generate additional C++ header code that enables integration with the
    UE4 Editor itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `UCLASS` is a great practice. The `UCLASS` macro, if configured correctly,
    can possibly make your `UCLASS` Blueprintable. The advantage of making your `UCLASS`
    Blueprintable is that it can enable your custom C++ objects to have Blueprints
    visually editable properties (`UPROPERTY`) with handy UI widgets such as text
    fields, sliders, and model selection boxes. You can also have functions (`UFUNCTION`)
    that are callable from within a Blueprints diagram. Both of these are shown in
    the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Classes](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the left, two `UPROPERTY` decorated class members (a `UTexture` reference
    and an `FColor`) show up for editing in a C++ class's Blueprint. On the right,
    a C++ function `GetName` marked as `BlueprintCallable` `UFUNCTION` shows up as
    callable from a Blueprints diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code generated by the `UCLASS` macro will be located in a `ClassName.generated.h`
    file, which will be the last `#include` required in your `UCLASS` header file,
    `ClassName.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a `UCLASS` – deriving from `UObject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user-editable `UPROPERTY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a `UPROPERTY` from Blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a `UCLASS` as the type of a `UPROPERTY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Blueprint from your custom `UCLASS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating `UObject`-derived classes (`ConstructObject <>` and `NewObject
    <>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying `UObject`-derived classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `USTRUCT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `UENUM()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `UFUNCTION`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that the sample objects we create in this class, even when Blueprintable,
    will not be placed in levels. That is because in order to be placed in levels,
    your C++ class must derive from the `Actor` base class, or below it. See [Chapter
    4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121 "Chapter 4. Actors
    and Components"), *Actors and Components* for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UE4 code is, typically, very easy to write and manage once you know the
    patterns. The code we write to derive from another `UCLASS`, or to create a `UPROPERTY`
    or `UFUNCTION,` is very consistent. This chapter provides recipes for common UE4
    coding tasks revolving around basic `UCLASS` derivation, property and reference
    declaration, construction, destruction, and general functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Making a UCLASS – deriving from UObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When coding with C++, you can have your own code that compiles and runs as native
    C++ code, with appropriate calls to `new` and `delete` to create and destroy your
    custom objects. Native C++ code is perfectly acceptable in your UE4 project as
    long as your `new` and `delete` calls are appropriately paired so that no leaks
    are present in your C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, also declare custom C++ classes, which behave like UE4 classes,
    by declaring your custom C++ objects as `UCLASS`. `UCLASS` use UE4's Smart Pointers
    and memory management routines for allocation and deallocation according to Smart
    Pointer rules, can be loaded and read by the UE4 Editor, and can optionally be
    accessed from Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that when you use the `UCLASS` macro, your `UCLASS` object''s creation
    and destruction must be completely managed by UE4: you must use `ConstructObject`
    to create an instance of your object (not the C++ native keyword `new`), and call
    `UObject::ConditionalBeginDestroy()` to destroy the object (not the C++ native
    keyword `delete`). How to create and destroy your `UObject`-derivative classes
    is outlined in the *Instantiating UObject-derived classes (ConstructObject <>
    and NewObject <>)* and *Destroying UObject-derived classes* sections later in
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to write a C++ class that uses the `UCLASS`
    macro to enable managed memory allocation and deallocation as well as to permit
    access from the UE4 Editor and Blueprints. You need a UE4 project into which you
    can add new code to use this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create your own `UObject` derivative class, follow the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: From your running project, select **File** | **Add C++ Class** inside the UE4
    Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add C++ Class** dialog that appears, go to the upper-right side of
    the window, and tick the **Show All Classes** checkbox:![How to do it...](img/00053.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `UCLASS` by choosing to derive from the `Object` parent class. `UObject`
    is the root of the UE4 hierarchy. You must tick the **Show All Classes** checkbox
    in the upper-right corner of this dialog for the `Object` class to appear in the
    list view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Object` (top of the hierarchy) as the parent class to inherit from,
    and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that although `Object` will be written in the dialog box, in your C++
    code, the C++ class you will deriving from is actually `UObject` with a leading
    uppercase `U`. This is the naming convention of UE4:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS` deriving from `UObject` (on a branch other than `Actor`) must be named
    with a leading `U`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS` deriving from `Actor` must be named with a leading `A` ([Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components*).'
  prefs: []
  type: TYPE_NORMAL
- en: C++ classes (that are not `UCLASS`) deriving from nothing do not have a naming
    convention, but can be named with a leading `F` (for example, `FAssetData`), if
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Direct derivatives of `UObject` will not be level placeable, even if they contain
    visual representation elements such as `UStaticMeshes`. If you want to place your
    object inside a UE4 level, you must at least derive from the `Actor` class or
    beneath it in the inheritance hierarchy. See [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components* for how to derive
    from the `Actor` class for a level-placeable object.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's example code will not be placeable in the level, but you can
    create and use Blueprints based on the C++ classes that we write in this chapter
    in the UE4 Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Name your new `Object` derivative something appropriate for the object type
    that you are creating. I call mine `UserProfile`. This comes off as `UUserObject`
    in the naming of the class in the C++ file that UE4 generates to ensure that the
    UE4 conventions are followed (C++ `UCLASS` preceded with a leading `U`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to Visual Studio, and ensure your class file has the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your project. You can now use your custom `UCLASS` object inside
    Visual Studio, and inside the UE4 Editor. See the following recipes for more details
    on what you can do with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UE4 generates and manages a significant amount of code for your custom `UCLASS`.
    This code is generated as a result of the use of the UE4 macros such as `UPROPERTY`,
    `UFUNCTION`, and the `UCLASS` macro itself. The generated code is put into `UserProfile.generated.h`.
    You must `#include` the `UCLASSNAME.generated.h` file with the `UCLASSNAME.h`
    file for compilation to succeed. Without including the `UCLASSNAME.generated.h`
    file, compilation would fail. The `UCLASSNAME.generated.h` file must be included
    as the last `#include` in the list of `#include` in `UCLASSNAME.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Right | Wrong |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The error that occurs when a `UCLASSNAME.generated.h` file is not included
    last in a list of includes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a bunch of keywords that we want to discuss here, which modify the
    way a `UCLASS` behaves. A `UCLASS` can be marked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blueprintable`: This means that you want to be able to construct a Blueprint
    from the **Class Viewer** inside the UE4 Editor (when you right-click, **Create
    Blueprint Class…** becomes available). Without the `Blueprintable` keyword, the
    **Create Blueprint Class…** option will not be available for your `UCLASS`, even
    if you can find it from within the **Class Viewer** and right-click on it:![There''s
    more…](img/00054.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Create Blueprint Class…** option is only available if you specify `Blueprintable`
    in your `UCLASS` macro definition. If you do not specify `Blueprintable`, then
    the resultant `UCLASS` will not be `Blueprintable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintType`: Using this keyword implies that the `UCLASS` is usable as
    a variable from another Blueprint. You can create Blueprint variables from the
    **Variables** group in the left-hand panel of any Blueprint''s **EventGraph**.
    If `NotBlueprintType` is specified, then you cannot use this Blueprint variable
    type as a variable in a Blueprints diagram. Right-clicking the `UCLASS` name in
    the **Class Viewer** will not show **Create Blueprint Class…** in its context
    menu:![There''s more…](img/00055.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `UCLASS` that have `BlueprintType` specified can be added as variables to
    your Blueprint class diagram's list of variables.
  prefs: []
  type: TYPE_NORMAL
- en: You may be unsure whether to declare your C++ class as a `UCLASS` or not. It
    is really up to you. If you like Smart Pointers, you may find that `UCLASS` not
    only make for safer code, but also make the entire code base more coherent and
    more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add additional programmable `UPROPERTY` to the Blueprints diagrams, see the
    *Creating a user-editable UPROPERTY* section below. For details on referring to
    instances of your `UCLASS` using appropriate Smart Pointers, refer to [Chapter
    3](part0043_split_000.html#190861-c0ca69a0411046888a488e5085138121 "Chapter 3. Memory
    Management and Smart Pointers"), *Memory Management and Smart Pointers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user-editable UPROPERTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each `UCLASS` that you declare can have any number of `UPROPERTY` declared for
    it within it. Each `UPROPERTY` can be a visually editable field, or some Blueprints
    accessible data member of the `UCLASS`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of qualifiers that we can add to each `UPROPERTY`, which
    change the way it behaves from within the UE4 Editor, such as `EditAnywhere` (screens
    from which the `UPROPERTY` can be changed), and `BlueprintReadWrite` (specifying
    that Blueprints can both read and write the variable at any time in addition to
    the C++ code being allowed to do so).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use this recipe, you should have a C++ project into which you can add C++
    code. In addition, you should have completed the preceding recipe, *Making a UCLASS
    – deriving from UObject*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add members to your `UCLASS` declaration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a Blueprint of your `UObject` class derivative, and open the Blueprint
    in the UE4 editor by double-clicking it from the object browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now specify values in Blueprints for the default values of these new
    `UPROPERTY` fields:![How to do it...](img/00056.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify per-instance values by dragging and dropping a few instances of the
    Blueprint class into your level, and editing the values on the object placed (by
    double-clicking on them).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parameters passed to the `UPROPERTY()` macro specify a couple of important
    pieces of information regarding the variable. In the preceding example, we specified
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditAnywhere`: This means that the `UPROPERTY()` macro can be edited either
    directly from the Blueprint, or on each instance of the `UClass` object as placed
    in the game level. Contrast this with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditDefaultsOnly`: The Blueprint''s value is editable, but it is not editable
    on a per-instance basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditInstanceOnly`: This would allow editing of the `UPROPERTY()` macro in
    the game-level instances of the `UClass` object, and not on the base blueprint
    itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintReadWrite`: This indicates that the property is both readable and
    writeable from Blueprints diagrams. `UPROPERTY()` with `BlueprintReadWrite` must
    be public members, otherwise compilation will fail. Contrast this with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly`: The property must be set from C++ and cannot be changed
    from Blueprints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`: You should always specify a `Category` for your `UPROPERTY()`.
    The `Category` determines which submenu the `UPROPERTY()` will appear under in
    the property editor. All `UPROPERTY()` specified under `Category=Stats` will appear
    in the same `Stats` area in the Blueprints editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complete `UPROPERTY` listing is located at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).
    Give it a browse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a UPROPERTY from Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a `UPROPERTY` from Blueprints is fairly simple. The member must be
    exposed as a `UPROPERTY` on the member variable that you want to access from your
    Blueprints diagram. You must qualify the `UPROPERTY` in your macro declaration
    as being either `BlueprintReadOnly` or `BlueprintReadWrite` to specify whether
    you want the variable to be either readable (only) from Blueprints, or even writeable
    from Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the special value `BlueprintDefaultsOnly` to indicate that
    you only want the default value (before the game starts) to be editable from the
    Blueprints editor. `BlueprintDefaultsOnly` indicates the data member cannot be
    edited from Blueprints at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create some `UObject`-derivative class, specifying both `Blueprintable` and
    `BlueprintType`, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `BlueprintType` declaration in the `UCLASS` macro is required to use the
    `UCLASS` as a type within a Blueprints diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Within the UE4 Editor, derive a Blueprint class from the C++ class, as shown
    in *Creating a Blueprint from your custom UCLASS*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of your Blueprint-derived class in the UE4 Editor by dragging
    an instance from the **Content Browser** into the main game world area. It should
    appear as a round white sphere in the game world unless you've specified a model
    mesh for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Blueprints diagram which allows function calls (such as the **Level Blueprint**,
    accessible via **Blueprints** | **Open Level Blueprint**), try printing the **Name**
    property of your Warrior instance, as seen in the following screenshot:![How to
    do it...](img/00057.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigating Blueprints diagrams is easy. Right-click and drag to pan a Blueprints
    diagram; *Alt* + Right-Click + Drag to zoom.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UPROPERTY` are automatically written `Get`/`Set` methods for UE4 classes.
    They must not be declared as `private` variables within the `UCLASS`, however.
    If they are not declared as `public` or `protected` members, you will get a compiler
    error of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a UCLASS as the type of a UPROPERTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you've constructed some custom `UCLASS` intended for use inside UE4\. But
    how do you instantiate them? Objects in UE4 are reference-counted and memory-managed,
    so you should not allocate them directly using the C++ keyword `new`. Instead,
    you'll have to use a function called `ConstructObject` to instantiate your `UObject`
    derivative. `ConstructObject` doesn't just take the C++ class of the object you
    are creating, it also requires a Blueprint class derivative of the C++ class (a
    `UClass*` reference). A `UClass*` reference is just a pointer to a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How do we instantiate an instance of a particular Blueprint from C++ code? C++
    code does not, and should not, know concrete `UCLASS` names, since these names
    are created and edited in the UE4 Editor, which you can only access after compilation.
    We need a way to somehow hand back the Blueprint class name to instantiate to
    the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: The way we do this is by having the UE4 programmer select the `UClass` that
    the C++ code is to use from a simple drop-down menu listing all the Blueprints
    available (derived from a particular C++ class) inside the UE4 Editor. To do this,
    we simply have to provide a user-editable `UPROPERTY` with a `TSubclassOf<C++ClassName>`-typed
    variable. Alternatively, you can use `FStringClassReference` to achieve the same
    objective.
  prefs: []
  type: TYPE_NORMAL
- en: This makes selecting the `UCLASS` in the C++ code is exactly like selecting
    a texture to use. `UCLASS` should be considered as resources to the C++ code,
    and their names should never be hardcoded into the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your UE4 code, you're often going to need to refer to different `UCLASS`
    in the project. For example, say you need to know the `UCLASS` of the player object
    so that you can use `SpawnObject` in your code on it. Specifying a `UCLASS` from
    C++ code is extremely awkward, because the C++ code is not supposed to know about
    the concrete instances of the derived `UCLASS` that were created in the Blueprints
    editor at all. Just as we don't want to bake specific asset names into the C++
    code, we don't want to hardcode derived Blueprints class names into the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we use a C++ variable (for example, `UClassOfPlayer`), and select that
    from a Blueprints dialog in the UE4 editor. You can do so using a `TSubclassOf`
    member or an `FStringClassReference` member, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the C++ class that you'd like to add the `UCLASS` reference member
    to. For example, decking out a class derivative with the `UCLASS` of the player
    is fairly easy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From inside a `UCLASS`, use code of the following form to declare a `UPROPERTY`
    that allows selection of a `UClass` (Blueprint class) that derives from `UObject`
    in the hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Blueprint the C++ class, and then open that Blueprint. Click on the drop-down
    menu beside your `UClassOfPlayer` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the appropriate `UClassOfPlayer` member from the drop-down menu of the
    listed `UClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TSubclassOf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TSubclassOf< >` member will allow you to specify a `UClass` name using
    a drop-down menu inside the UE4 editor when editing any Blueprints that have `TSubclassOf<
    >` members.
  prefs: []
  type: TYPE_NORMAL
- en: FStringClassReference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MetaClass` tag refers to the base C++ class from which you expect the `UClassName`
    to derive. This limits the drop-down menu's contents to only the Blueprints derived
    from that C++ class. You can leave the `MetaClass` tag out if you wish to display
    all the Blueprints in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blueprint from your custom UCLASS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blueprinting is just the process of deriving a Blueprint class for your C++
    object. Creating Blueprint-derived classes from your UE4 objects allows you to
    edit the custom `UPROPERTY` visually inside the editor. This avoids hardcoding
    any resources into your C++ code. In addition, in order for your C++ class to
    be placeable within the level, it must be Blueprinted first. But this is only
    possible if the C++ class underlying the Blueprint is an `Actor` class-derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a way to load resources (such as textures) using `FStringAssetReferences`
    and `StaticLoadObject`. These pathways to loading resources (by hardcoding path
    strings into your C++ code) are generally discouraged, however. Providing an editable
    value in a `UPROPERTY()`, and loading from a proper concretely typed asset reference
    is a much better practice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a constructed `UCLASS` that you'd like to derive a Blueprint
    class from (see the *Making a UCLASS – deriving from UObject* section earlier
    in this chapter) in order to follow this recipe. You must have also marked your
    `UCLASS` as `Blueprintable` in the `UCLASS` macro for Blueprinting to be possible
    inside the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any `UObject`-derived class with the meta keyword `Blueprintable` in the `UCLASS`
    macro declaration will be `Blueprintable`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To Blueprint your `UserProfile` class, first ensure that `UCLASS` has the `Blueprintable`
    tag in the `UCLASS` macro. This should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `UserProfile` C++ class in the **Class Viewer** (**Window** | **Developer
    Tools** | **Class Viewer**). Since the previously created `UCLASS` does not derive
    from `Actor`, to find your custom `UCLASS`, you must turn off **Filters** | **Actors
    Only** in the **Class Viewer** (which is checked by default):![How to do it…](img/00059.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the **Actors Only** check mark to display all the classes in the **Class
    Viewer**. If you don't do this, then your custom C++ class may not show!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keep in mind that you can use the small search box inside the **Class Viewer**
    to easily find the `UserProfile` class by starting to type it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Find your `UserProfile` class in the **Class Viewer**, right-click on it, and
    create a Blueprint from it by selecting **Create Blueprint…**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your Blueprint. Some prefer to prefix the Blueprint class name with `BP_`.
    You may choose to follow this convention or not, just be sure to be consistent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on your new Blueprint as it appears in the **Content Browser**,
    and take a look at it. You will be able to edit the **Name** and **Email** fields
    for each `UserProfile` Blueprint instance you create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any C++ class you create that has the `Blueprintable` tag in its `UCLASS` macro
    can be Blueprinted within the UE4 editor. A Blueprint allows you to customize
    properties on the C++ class in the visual GUI interface of UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating UObject-derived classes (ConstructObject < > and NewObject < >)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating class instances in C++ is traditionally done using the keyword `new`.
    However, UE4 actually creates instances of its classes internally, and requires
    you to call special factory functions to produce copies of any `UCLASS` that you
    want to instantiate. You produce instances of the UE4 Blueprints classes, not
    the C++ class alone. When you create `UObject`-derived classes, you will need
    to instantiate them using special UE4 Engine functions.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method allows UE4 to exercise some memory management on the object,
    controlling what happens to the object when it is deleted. This method allows
    UE4 to track all references to an object so that on object destruction, all references
    to the object can be easily unlinked. This ensures that no dangling pointers with
    references to invalidated memory exist in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiating `UObject`-derived classes that are not `AActor` class derivatives
    does not use `UWorld::SpawnActor< >`. Instead, we have to use special global functions
    named `ConstructObject< >`, or `NewObject< >`. Note that you should not use the
    bare C++ keyword `new` to allocate new instances of your UE4 `UObject` class derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need at least two pieces of information to properly instantiate your
    `UCLASS` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: A C++ typed `UClass` reference to the class type that you would like to instantiate
    (Blueprint class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original C++ base class from which the Blueprint class derives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a globally accessible object (like your `GameMode` object), add a `TSubclassOf<
    YourC++ClassName > UPROPERTY()` to specify and supply the `UCLASS` name to your
    C++ code. For example, we add the following two lines to our `GameMode` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Enter the UE4 editor, and select your `UClass` name from the drop-down menu
    so that you can see what it does. Save, and exit the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your C++ code, find the section where you want to instantiate the `UCLASS`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instantiate the object using `ConstructObject< >` with the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, using the `UserProfile` object that we specified in the last recipe,
    we would get code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer, you can also use the `NewObject` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instantiating a `UObject` class using `ConstructObject` or `NewObject` is simple.
    `NewObject` and `ConstructObject` do nearly the same thing: instantiate an object
    of Blueprint class type, and return a C++ pointer of the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `NewObject` has a nasty first parameter which requires you to
    pass `GetTransientPackage()` with each call. `ConstructObject` does not require
    this parameter with each call. In addition, `ConstructObject` provides you with
    more construction options.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the keyword `new` when constructing your UE4 `UObject` derivative!
    It will not be properly memory-managed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NewObject` and `ConstructObject` are what the OOP world calls factories. You
    ask the factory to make you the object—you don''t go about constructing it by
    yourself. Using a factory pattern enables the engine to easily track objects as
    they are created.'
  prefs: []
  type: TYPE_NORMAL
- en: Destroying UObject-derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing any `UObject` derivative is simple in UE4\. When you are ready to delete
    your `UObject`-derived class, we will simply call a single function (`ConditionalBeginDestroy()`)
    on it to begin teardown. We do not use the native C++ `delete` command on `UObject`
    derivatives. We show this in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to call `ConditionalBeginDestroy()` on any unused `UObject`-derived
    classes so that they get removed from memory. Do not call `delete` on a `UObject`-derived
    class to recoup the system memory. You must use the internal engine-provided memory
    management functions instead. The way to do this is shown next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call `objectInstance->ConditionalBeginDestroy()` on your object instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Null all your references to `objectInstance` in your client code, and do not
    use `objectInstance` again after `ConditionalBeginDestroy()` has been called on
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ConditionalBeginDestroy()` function begins the destruction process by removing
    all internal engine linkages to it. This marks the object for destruction as far
    as the engine is concerned. The object is then destroyed some time later by destroying
    its internal properties, followed by actual destruction of the object.
  prefs: []
  type: TYPE_NORMAL
- en: After `ConditionalBeginDestroy()` has been called on an object, your (client)
    code must consider the object to be destroyed, and must no longer use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actual memory recovery happens some time later than when `ConditionalBeginDestroy()`
    has been called on an object. There is a garbage collection routine that finishes
    clearing the memory of objects that are no longer referenced by the game program
    at fixed time intervals. The time interval between garbage collector calls is
    listed in `C:\Program Files (x86)\Epic Games\4.11\Engine\Config \BaseEngine.ini`,
    and defaults to one collection every 60 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If memory seems low after several `ConditionalBeginDestroy()` calls, you can
    trigger memory cleanup by calling `GetWorld()->ForceGarbageCollection(true)` to
    force an internal memory cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you do not need to worry about garbage collection or the interval unless
    you urgently need memory cleared. Do not call garbage collection routines too
    often, as this may cause unnecessary lag in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a USTRUCT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may want to construct a Blueprints editable property in UE4 that contains
    multiple members. The `FColoredTexture` struct that we will create in this chapter
    will allow you to group together a texture and its color inside the same structure
    for inclusion and specification in any other `UObject` derivative, `Blueprintable`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a USTRUCT](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `FColoredTexture` structure does have the visual within Blueprints appearance
    as shown in the figure above.
  prefs: []
  type: TYPE_NORMAL
- en: This is for good organization and convenience of your other `UCLASS` `UPROPERTIES()`.
    You may want to construct a C++ structure in your game using the keyword `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `UObject` is the base class of all UE4 class objects, while an `FStruct` is
    just any plain old C++ style struct. All objects that use the automatic memory
    management features within the engine must derive from this class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you' recall from the C++ language, the only difference between a C++ class
    and a C++ struct is that C++ classes have default `private` members, while structs
    default to `public` members. In languages like C#, this isn't the case. In C#,
    a struct is value-typed, while a class is reference-typed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create a structure `FColoredTexture` in C++ code to contain a texture
    and a modulating color:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file `ColoredTexture.h` in your project folder (not `FColoredTexture`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ColoredTexture.h` contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ColoredTexture.h` as a `UPROPERTY()` in some Blueprintable `UCLASS()`,
    using a `UPROPERTY()` declaration like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UPROPERTY()` specified for the `FColoredTexture` will show up in the editor
    as editable fields when included as `UPROPERTY()` fields inside another class,
    as shown in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason for making a struct a `USTRUCT()` instead of just a plain old
    C++ struct is to interface with the UE4 Engine functionality. You can use plain
    C++ code (without creating `USTRUCT()` objects) for quick small structures that
    don't ask the engine to use them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UENUM( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ `enum` are very useful in typical C++ code. UE4 has a custom type of enumeration
    called `UENUM()`, which allows you to create an `enum` that will show up in a
    drop-down menu inside a Blueprint that you are editing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the header file that will use the `UENUM()` you are specifying, or create
    a file `EnumName.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use code of the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your `UENUM()` in a `UCLASS()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UENUM()` show up nicely in the code editor as drop-down menus in the Blueprints
    editor from which you can only select one of a few values.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UFUNCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UFUNCTION()` are useful because they are C++ functions that can be called
    from both your C++ client code as well as Blueprints diagrams. Any C++ function
    can be marked as a `UFUNCTION()`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Construct a `UClass` with a member function that you''d like to expose to Blueprints.
    Decorate that member function with `UFUNCTION( BlueprintCallable, Category=SomeCategory)`
    to make it callable from Blueprints. For example, the following is the `Warrior`
    class again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Create an instance of your `Warrior` class by dragging an instance on to your
    game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Blueprints, call the `ToString()` function on that `Warrior` instance by
    clicking on your `Warrior` instance. Then, in a Blueprints diagram, type in `ToString()`.
    It should look like in the following screenshot:![How to do it...](img/00062.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to call a function on an instance, the instance must be selected in
    the **World Outliner** when you start to type into the autocomplete menu in the
    Blueprints diagram, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UFUNCTION()` are really C++ functions, but with additional metadata that make
    them accessible to Blueprints.'
  prefs: []
  type: TYPE_NORMAL
