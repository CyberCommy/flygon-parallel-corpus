- en: '*Chapter 11*: Exercise – Stubbing and Spying XHR Requests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started on this chapter, you need to understand why we need to
    stub or spy requests and methods, and to do this, you will need an understanding
    of Cypress requests and how to test individual methods. The previous chapters
    have presented extensive knowledge on how you can easily get started on Cypress,
    and we have covered concepts relating to network requests and functional testing.
    In this chapter, we will be building on the concepts that we have gained in the
    previous chapters with the focus being a hands-on approach by use of examples
    and exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding XHR requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to stub requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to spy on methods in a test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will be ready to get started
    on visual testing with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we recommend that you clone the repository that contains the
    source code and all the tests, exercises, and solutions that we will write in
    this chapter from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
    The source code for this chapter can be found in the `chapter-11` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our GitHub repository, we have a finance test application that we will
    use for the different examples and exercises of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note: running commands in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'NB: The default Windows Command Prompt and PowerShell do not correctly resolve
    the directory locations.'
  prefs: []
  type: TYPE_NORMAL
- en: Kindly follow the Windows commands listed further that work exclusively on Windows
    operating systems suffixed with the word `*windows`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the test application is running on your machine, run the following
    commands from the root folder directory of the application in the terminal on
    your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have our tests in the `chapter-11` directory and the test application located
    in the root directory of the repository. To properly run our tests, we have to
    run both our application and the Cypress tests, as the tests run on the live application
    that runs locally on our machines. It is important to also note that the application
    will require the use of port `3000` for the frontend application and port `3001`
    for the server application.
  prefs: []
  type: TYPE_NORMAL
- en: The first command will navigate to the `cypress-realworld-app` directory where
    our application is located. Then the `npm run cypress-init` command will install
    the dependencies that the application requires to run and the `npm run cypress-app`
    command will start the application. Optionally, you can reset the application
    state using the `npm run cypress-app-reset` command. Resetting the application
    removes any data that has been added that was not part of the application, taking
    the application state back to when you cloned the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding XHR requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XMLHttpRequest** (**XHR**) is an API that exists in all modern-day browsers
    and takes the form of an object whose methods are used to transfer data between
    a web browser sending the requests and the web server serving responses. The XHR
    API is unique as we can use it to update a browser page without reloading the
    page, request and receive server data after a page loads, and even send data to
    the server as a background task. In this section, we will cover the basics of
    XHR requests and their importance when it comes to the process of writing our
    Cypress tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing XHR requests in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XHR requests are a developer's dream as they allow you to *silently* send and
    receive data from the server without worrying about issues such as errors or waiting
    times when the client application needs to reload to perform an action. While
    XHR is a dream to developers, it is a nightmare for testers as it introduces uncertainties
    such as being unable to know when a request will finish processing and even when
    data has been returned from the server.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the issue of XHR uncertainties, Cypress introduced the `cy.intercept()`
    command, which we have looked at in depth in both [*Chapter 9*](B15616_09_Final_NM_ePUB.xhtml#_idTextAnchor196),
    *Advanced Uses of Cypress Test Runner,* and [*Chapter 10*](B15616_10_Final_NM_ePUB.xhtml#_idTextAnchor211),
    *Exercise – Navigation and Network Requests,* in the network requests section.
    The `cy.intercept()` command listens to XHR responses and knows when Cypress has
    returned a response for a specific XHR request. With the `cy.intercept()` command,
    we can instruct Cypress to wait until the response for a particular request has
    been received, which makes it more deterministic when we are writing tests that
    wait for responses from a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block from the `xhr-requests/xhr.spec.js` file shows the
    code to log a user into our finance test application. When a user is logged in,
    the application sends requests to the server to load the notifications, bank accounts,
    and transaction details that the application requires. These details are returned
    as XHR responses from the API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we are logging a user in and waiting for Cypress
    to return XHR responses to our transaction, notification, and bank account requests
    that are sent from the server. The responses are only sent when there is a successful
    user login attempt. We can visualize how Cypress handles XHR requests in a test
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – XHR requests and responses from the server'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – XHR requests and responses from the server
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the application making XHR requests to our server for
    `/bankAccounts`, `/transactions`, and `/notifications`. For our test to be deterministic
    and for us to wait for a specified time to ensure a successful login, we use the
    `cy.intercept()` command to check when the responses from the XHR requests have
    been sent back by the server and whether they have been sent back with the correct
    status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Waiting for XHR responses in tests gives us significant advantages over tests
    that do not have any *fail mechanisms* that handle waits or tests that have explicit
    time waits. The alternative to waiting for XHR responses is to explicitly wait
    for a specific amount of time, which is only an estimation and not the exact time
    that Cypress waits for a particular response. Some of the advantages of waiting
    for responses to routes while running our tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to assert the returned XHR response object from the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests that are robust, hence reducing flakiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having failure messages that can be understood due to their preciseness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to stub responses and "fake" server responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these advantages highlighted, usage of XHR requests assists us to deterministically
    know when the responses are received and when Cypress can continue executing our
    commands, having received all the required responses for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – utilizing XHR requests in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about XHR requests, what they are, and how Cypress
    utilizes them to send and fetch requests from the application server. We also
    learned how we can wait for XHR responses to reduce flaky tests by deterministically
    waiting for the responses from our server responses. We also learned how XHR can
    assist us, how we can have precise failure messages, and even how we can assert
    responses from our server responses. Finally, we went through how we can use the
    `cy.intercept()` command with XHR responses and the potential benefits of being
    able to control the execution of our tests by reducing test uncertainties. In
    the next section, we will look at using stubbing to control the XHR responses
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to stub requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what XHR requests are, it is important to know how we can help
    Cypress test XHR requests, and better still, how we can avoid actual responses
    from the server and instead create our own "fake" responses that our application
    will interpret as the actual responses that have been sent from the server. In
    this section, we will look at how we can stub XHR requests to the server, when
    to stub requests, and the impact of stubbing server requests in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing XHR requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress gives the flexibility of allowing users to either have their requests
    reach the server, or instead have stubbed responses when the requests to the server
    endpoints are made by the application. With the flexibility of Cypress, we even
    have the ability to allow some requests to pass through to the server while denying
    other requests and stubbing them instead. Stubbing XHR responses adds a layer
    of control to our tests. With stubbing, we are in control of the data returned
    to the client and we have access to change the response of the **body**, **status**,
    and **headers**, or even introduce a delay if we want to simulate network latency
    in the server response.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of stubbing requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having stubbed requests gives us more control over the responses that are returned
    to the tests and also over the data that will be received by the client making
    the requests to the server. The following are the advantages of stubbing our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Having control over the body, headers, and status of the responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick response times of the responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No required code changes to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network delay simulations can be added to the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's also look at some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of stubbing requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While stubbing is a good way of handling XHR responses to Cypress client applications
    under test, it also comes with some downsides to our testing process as highlighted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: The inability to have test coverage on some server endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No guarantee that the response data and stubbed data are a match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to stub XHR responses in the majority of tests to reduce the
    amount of time it takes to execute tests and also to have a healthy mix of stubbed
    and actual API responses from the server. XHR stubbing in Cypress is also best
    suited when working with JSON APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, in the `xhr-requests/xhr-stubbing.spec.js` file,
    we are going to stub the `bankAccounts` endpoint and avoid making the actual requests
    to the server when we are running our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have stubbed the `/bankaccounts` server response
    and instead of waiting for a response, we provided a response ourselves that is
    almost identical to the response that the server would have sent back. The following
    screenshot shows the successful stubbed response and the "fake" stubbed bank account
    information that we provided to our client using the stubbed response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Stubbed XHR response in the client application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Stubbed XHR response in the client application
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11.2*, we can see that it is almost impossible to tell whether our
    response was stubbed or we received it from our server. With Cypress, it is impossible
    for the client application to recognize whether a response was genuinely sent
    from the server or was stubbed, a quality that makes Cypress an effective tool
    for intercepting requests and sending responses that would otherwise have taken
    a long time to be sent from the server. We will learn more about stubbing XHR
    responses in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the financial application provided in the GitHub repository and located
    in the `cypress-realworld-app` directory, carry out the following exercise to
    test your knowledge on stubbing XHR responses. The solutions to the exercise can
    be found in the `chapter-11/integration/xhr-requests-exercises` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Stub the login POST request of the application and instead of returning the
    name of the test user in the dashboard, change it to reflect your name and your
    username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assert that the response returned does indeed have your username and name information
    that was stubbed. The following screenshot shows the information on the page that
    should change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Change the name and username by stubbing the login response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Change the name and username by stubbing the login response
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To properly stub a response, you need to understand what the server sends as
    a response when the route is not stubbed. To do this, open the browser console
    on your browser, click the **Network** tab, and then select the **XHR filter**
    option. You can now see all the responses and requests sent to the server and
    received by your client. To get the specific request to a stub, you should click
    the exact request and copy the response from the **Response** tab of the browser
    console's **Network** window. The exact response (or a response that is similar
    in structure) is what we should use to stub our server responses so as to ensure
    the consistency of responses to our client. From the **Network** window, we can
    also obtain information such as the headers sent and received with the request,
    and the actual URL that is used to send the requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of the **notifications** XHR response
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Server XHR response for notifications endpoint on the Chrome
    browser console'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Server XHR response for notifications endpoint on the Chrome browser
    console
  prefs: []
  type: TYPE_NORMAL
- en: After a successful login, select a random transaction from the `Everyone Dashboard`
    tab and modify the transaction amount to be $100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From this exercise, you not only learned how to stub XHR responses but also
    how the client handles the data that it has received from the server. By understanding
    the benefits of XHR response stubbing, you are now ready to tackle complex Cypress
    tests that involve stubbed responses.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding how to stub requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to use XHR server requests to receive requests
    and also to intercept the requests sent by using stubs. We also learned how with
    stubs, we can control the nature of the responses we send back to the client application,
    and also how we can assert our stubbed responses that look similar to the client
    responses that we receive from the server. Finally, we learned how we can use
    our browser to identify which responses to stub, and use the content of the responses
    that we are stubbing. In the next section, we will look at how spying works and
    how we can utilize it in our Cypress methods.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to spy on methods in a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spies and stubs are closely related with the difference being that, unlike stubs,
    which can be used to modify data of a method or a request, spies only obtain the
    state of the method or request and do not have the ability to modify the method
    or the request. They work just like real-life spies who only track and report.
    Spies help us understand the execution of tests, what elements have been called,
    and what has been executed. In this section, we will learn about the concept of
    spying in Cypress, the advantages of spying on methods, and how we can utilize
    spying to write better Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: Why spy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use spies in Cypress to record calls in a method along with the arguments
    of the method. By using spies, we can assert that a specific method was called
    a certain number of times and was called with the right arguments. We can even
    tell what the return values of a method were, or the execution context of the
    method at the time it was called. Spies are mostly used in the unit testing context
    but also have applications in the integration context, such as testing that two
    functions have proper integration with each other and that they work harmoniously
    when executed together. When executed, the `cy.spy()` command returns a value
    instead of a promise like almost all the other Cypress commands. The `cy.spy()`
    command does not have a timeout and cannot be chained further with other Cypress
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the advantages of using spies in tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Spies do not modify the requests or methods called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spies give you the ability to quickly verify whether methods have been called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They offer an easy way to test functional integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spying is an interesting concept as it introduces a way to monitor methods
    without necessarily taking an action on the outcome. In the following code block,
    we have a test that consists of a simple function to sum two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method, we have set `cy.spy()` to monitor our `sum` method
    and trigger the spy when the method is called or when it is called with arguments.
    Whenever the method is called, our spy will record the number of times it was
    called, and we can also go ahead and check whether or not our method was called
    with any arguments. The `sum` function is inside a JavaScript object, and the
    trigger for the spy method is the `obj.sum(1, 2)` sum function call, which is
    called before our assertions are executed in the test. The following screenshot
    shows the spies, the number of calls, and the aliases of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Spying on a sum method'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_11.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Spying on a sum method
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this method that uses the `cy.spy()` method on the `sum()` function,
    we can see that both the spies of the `sum` method and the `sum` method called
    with arguments were triggered once the `sum` method started executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will explore a more complex scenario where we will
    try to spy on a method that returns all the transactions in our JSON database
    from the server. The following code block shows the spy of the method that will
    fetch all of our transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we are verifying that the request to fetch the transactions from
    the database takes place. With this test, we can monitor our method and check
    that the proper arguments are passed to our method when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that, with spies, we are able to identify which methods were called,
    how many times they were called, and what arguments were used when the method
    was called. We will learn more about spies in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the financial application provided in the GitHub repository and located
    in the `cypress-realworld-app` directory, carry out the following exercises to
    test your knowledge of stubbing XHR responses. The solutions to the exercise can
    be found in the `chapter-11/integration/spies-exercise` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a method called `Area` that calculates the area of a triangle, spy on
    the `area` method, and call the method to assert that indeed the `area` method
    is called and spied by `cy.spy()`. Assert that the method was also called with
    the `base` and `height` arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using our application, log in as a user and spy on the API request method to
    fetch all the bank accounts of that logged-in user. Assert that the method to
    make the API request to the server was called and that the arguments were passed
    as parameters to the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This exercise will assist you in understanding how spies work in Cypress and
    the different methods that can be used with `cy.spy()` to find the contents of
    the methods that are being spied on. By spying on methods, we are also able to
    tell whether or not the method arguments are called and how they were called,
    together with the return values.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding how to spy on methods in a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about spying, covering how important spying is and
    how different it is from stubbing, as we are not allowed to change the values
    of the method or the request being spied on. We also learned how we can use stubbing
    to identify the arguments of a method, the number of times a method was called,
    the execution context, and also the return values of the methods being spied on.
    Using the examples and the exercise, we also got to interact with the `cy.spy()`
    command, which helped us to understand the command and how it works in the context
    of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter's focus was mainly on XHR requests and responses and how they interact
    with the client and the server. We started by first understanding what XHR requests
    and responses are and how important they are when we want to send requests from
    the client and also receive requests from the server. In this chapter, we also
    looked at how we can "fake" server responses by stubbing XHR responses using the
    Cypress stub functionality that is built into the `cy.intercept()` command. Finally,
    we explored the Cypress `cy.spy()` command, which further gave us an idea of how
    we can monitor methods in Cypress and get the ability to find out the number of
    times the methods were executed, how they were executed, their arguments, and
    even their return values. In the final section, we learned the importance of knowing
    that with spying, we can only "observe" how the execution takes place, and not
    necessarily have the ability to change the execution process of the request or
    the methods that are being tested.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that through this chapter, you have gained the skills of knowing what
    XHR requests are, how they work, how to stub them, and how to spy on Cypress methods.
    In the next chapter, we will look at visual testing in Cypress.
  prefs: []
  type: TYPE_NORMAL
