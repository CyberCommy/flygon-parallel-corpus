- en: Testing the Node Applications – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll look at how we can test our code to make sure it's working
    as expected. Now, if you've ever set up test cases for other languages, then you
    know how hard it can be to get started. You have to set up the actual test infrastructure.
    Then you have to write your individual test cases. Every time I didn't test an
    application, it was because the setup process and the tools available to me were
    such a burden. Then you dig around for information online and you get really simple
    examples, but not examples for testing real-world things like asynchronous code.
    We'll be doing all of that in this chapter. I'll give you a very simple setup
    for testing and writing your test cases.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the best tools available so you'll actually be excited to write
    those test cases and see all of those green checkmarks. We'll be testing from
    here on out as well, so let's dive in looking at how we can test some code.
  prefs: []
  type: TYPE_NORMAL
- en: Basic testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll create your very first test case so that you can test
    whether your code is working as expected. By adding automatic testing to our project,
    we'll be able to verify that a function does what it says it'll do. If we make
    a function that's supposed to add two numbers together, we can automatically verify
    it's doing that. And if we have a function that's supposed to fetch a user from
    the database, we can make sure it's doing that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now to get started in this section, we'll look at the very basics of setting
    up a testing suite inside a Node.js project. We'll be testing a real-world function.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the testing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get started, we will make a directory to store our code for this
    chapter. We''ll make one on the desktop using `mkdir` and we''ll call this directory
    `node-tests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll change directory inside it using `cd`, so we can go ahead and run
    `npm init`. We''ll be installing modules and this will require a `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/584340e3-28e2-4603-a985-6fa4ec7f1654.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll run `npm init` using the default values for everything, simply hitting
    *enter* throughout every single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2276dd53-3b2e-41ad-ab4b-b70728616f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now once that `package.json` file is generated, we can open up the directory
    inside Atom. It's on the desktop and it's called `node-tests`.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we're ready to actually define a function we want to test. The goal
    in this section is to learn how to set up testing for a Node project, so the actual
    functions we'll be testing are going to be pretty trivial, but it will help illustrate
    exactly how to set up our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a Node project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, let''s make a fake module. This module will have some functions
    and we''ll test those functions. In the root of the project, we''ll create a brand
    new directory and I''ll call this directory `utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91f6a6aa-0422-4de1-b593-62b42deb4787.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can assume this will store some utility functions, such as adding a number
    to another number, or stripping out whitespaces from a string, anything kind of
    hodge-podge that doesn''t really belong to any specific location. We''ll make
    a new file in the `utils` folder called `utils.js`, and this is a similar pattern
    to what we did when we created the `weather` and `location` directories in our
    weather app in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/503f66d8-7558-4525-9aec-8c92b0a1bb99.png)'
  prefs: []
  type: TYPE_IMG
- en: You're probably wondering why we have a folder and a file with the same name.
    This will be clear when we start testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now before we can write our first test case to make sure something works, we
    need something to test. I''ll make a very basic function that takes two numbers
    and adds them together. We''ll create an adder function as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This arrow function (`=>`) will take two arguments, `a` and `b`, and inside
    the function, we''ll return the value `a + b`. Nothing too complex here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now since we just have one expression inside our arrow function (`=>`) and
    we want to return it, we can actually use the arrow function (`=>`) expression
    syntax, which lets us add our expression as shown in the following code, `a +
    b`, and it''ll be implicitly returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's no need to explicitly add a `return` keyword on to the function. Now
    that we have `utils.js` ready to go, let's explore testing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using a framework called Mocha in order to set up our test suite. This
    will let us configure our individual test cases and also run all of our test files.
    This will be really important for creating and running tests. The goal here is
    to make testing simple and we'll use Mocha to do just that. Now that we have a
    file and a function we actually want to test, let's explore how to create and
    run a test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha – the testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be doing the testing using the super popular testing framework Mocha,
    which you can find at [mochajs.org](https://mochajs.org/). This is a fantastic
    framework for creating and running test suites. It''s super popular and their
    page has all the information you''d ever want to know about setting it up, configuring
    it, and all the cool bells and whistles it has included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ef865ef-3a75-4f15-bce3-cc3dd95785f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you scroll down on this page, you''ll be able to see a table of contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa505fff-2c7e-46bb-ad6e-43d622059cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you can explore everything Mocha has to offer. We'll be covering most of
    it in this chapter, but for anything we don't cover, I do want to make you aware
    you can always learn about it on this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve explored the Mocha documentation page, let''s install it and
    start using it. Inside the Terminal, we''ll install Mocha. First up, let''s clear
    the Terminal output. Then we''ll install it using the `npm install` command. When
    you use `npm install`, you can also use the shortcut `npm i`. This has the exact
    same effect. I''ll use `npm i` with `mocha`, specifying the version `@3.0.0`.
    This is the most recent version of the library as of this filming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we do want to save this into the `package.json` file. Previously, we've
    used the `save` flag, but we'll talk about a new flag, called `save-dev`. The
    `save-dev` flag is will save this package for development purposes only—and that's
    exactly what Mocha will be for. We don't actually need Mocha to run our app on
    a service like Heroku. We just need Mocha locally on our machine to test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the `save-dev` flag, it installs the module much the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d3d4bba5-1689-45b2-a839-d163e8cd6131.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But if you explore `package.json`, you''ll see things are a little different.
    Inside our `package.json` file, instead of a dependencies attribute, we have a
    `devDependencies` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/732a982a-a748-4705-9bad-ce655510abc2.png)'
  prefs: []
  type: TYPE_IMG
- en: In there we have Mocha, with the version number as the value. The `devDependencies`
    are fantastic because they're not going to be installed on Heroku, but they will
    be installed locally. This will keep the Heroku boot times really, really quick.
    It won't need to install modules that it's not going to actually need. We'll be
    installing both `devDependencies` and `dependencies` in most of our projects from
    here on out.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test file for the add function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Mocha installed, we can go ahead and create a test file. In
    the `utils` folder, we''ll make a new file called `utils.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a48c09b3-f218-4fb9-925f-47c9b04e15bb.png)'
  prefs: []
  type: TYPE_IMG
- en: This file will store our test cases. We'll not store our test cases in `utils.js`.
    This will be our application code. Instead, we'll make a file called `utils.test.js`.
    When we use this `test.js` extension, we're basically telling our app that this
    will store our test cases. When Mocha goes through our app looking for tests to
    run, it should run any file with this extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a test file, the only thing left to do is create a test case. A
    test case is a function that runs some code, and if things go well, great, the
    test is considered to have passed. And if things do not go well, the test is considered
    to have failed. We can create a new test case, using `it`. It is a function provided
    by Mocha. We''ll be running our project test files through Mocha, so there''s
    no reason to import it or do anything like that. We simply call it just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it lets us define a new test case and it takes two arguments. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First up, we''ll have a string description of what exactly the test is doing.
    If we''re testing that the adder function works, we might have something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that it plays into the sentence. It should read like this, `it should
    add two numbers`; describes exactly what the test will verify. This is called
    **behavior-driven development**, or **BDD**, and that's the principles that Mocha
    was built on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve set up the test string, the next thing to do is add a function
    as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this function, we''ll add the code that tests that the add function
    works as expected. This means it will probably call `add` and check that the value
    that comes back is the appropriate value given the two numbers passed in. That
    means we do need to import the `util.js` file up at the top. We''ll create a constant,
    call `utils`, setting it equal to the return result from requiring utils. We''re
    using `./` since we will be requiring a local file. It''s in the same directory
    so I can simply type `utils` without the `js` extension as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the utils library loaded in, inside the callback we can call
    it. Let''s make a variable to store the return results. We''ll call this one results.
    And we''ll set it equal to `utils.add` passing in two numbers. Let''s use something
    like `33` and `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We would expect it to get `44` back. Now at this point, we do have some code
    inside of our test suites so we run it. We'll do that by configuring that test
    script we looked at in the previous chapter inside a `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the test script simply prints a message to the screen saying that
    no tests exist. What we''ll do instead is call Mocha. As shown in the following
    code, we''ll be calling Mocha, passing in as the one and only argument the actual
    files we want to test. We can use a globbing pattern to specify multiple files.
    In this case, we''ll be using `**` to look in every single directory. We''re looking
    for a file called `utils.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is a very specific pattern. It''s not going to be particularly useful.
    Instead, we can swap out the file name with a star as well. Now we''re looking
    for any file on the project that has a file name ending in `.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is exactly what we want. From here, we can run our test suite by saving
    `package.json` and moving to the Terminal. We''ll use the `clear` command to clear
    the Terminal output and then we can run our `test` script using command shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we''ll execute that Mocha command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3119576-d86c-4ad2-834f-c55d42ee1617.png)'
  prefs: []
  type: TYPE_IMG
- en: It'll go off. It'll fetch all of our test files. It'll run all of them and print
    the results on the screen inside Terminal as shown in the preceding screenshot.
    Here we can see we have a green checkmark next to our test, `should add two numbers`.
    Next, we have a little summary, one passing test, and it happened in 8 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in our case, we don''t actually assert anything about the number that comes
    back. It could be 700 and we wouldn''t care. The test will always pass. To make
    a test fail what we have to do is throw an error. That means we can throw a new
    error and we pass into the constructor function whatever message we want to use
    as the error as shown in the following code block. In this case, I could say something
    like `Value not correct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with this in place, I can save the test file and rerun things from the
    Terminal by rerunning `npm test`, and when we do that now we have 0 tests passing
    and we have 1 test failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e79b1dd-204b-4b42-8ef9-cd2f4eedebf7.png)'
  prefs: []
  type: TYPE_IMG
- en: Next we can see the one test is should add two numbers, and we get our error
    message, Value not correct. When we throw a new error, the test fails and that's
    exactly what we want to do for add.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the if condition for the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll create an `if` statement for the test. If the response value is
    not equal to `44`, that means we have a problem on our hands and we''ll throw
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `if` condition, we can throw a new error and we''ll use a template
    string as our message string because I do want to use the value that comes back
    in the error message. I''ll say `Expected 44, but got`, then I''ll inject the
    actual value, whatever happens to come back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our case, everything will line up great. But what if the `add` method
    wasn''t working correctly? Let''s simulate this by simply tacking on another addition,
    adding on something like `22` in `utils.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll save the file, rerun the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc218425-26d3-4080-b0c2-449f70e511e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we get an error message: Expected 44, but got 66\. This error message is
    fantastic. It lets us know that something is going wrong with the test and it
    even tells us exactly what we got back and what we expected. This will let us
    go into the `add` function, look for errors, and hopefully fix them.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating test cases doesn't need to be something super complex. In this case,
    we have a simple test case that tests a simple function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the squaring a number function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll create a new function that squares a number and returns the result.
    We''ll define that in the `utils.js` file using `module.exports.square`. We''ll
    set that equal to an arrow function (`=>`) that takes in one number, `x`, and
    we''ll return `x` times `x`, `x * x`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have this brand new function square and we''ll create a new test case
    that makes sure `square` works as expected. In `utils.test.js`, next to the `if`
    condition for `add` function, we''ll call the `it` function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `it` function, we''ll add our two arguments, the string, and the
    callback function. Inside the string, we''ll create our message, `should square
    a number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And inside the callback function, we can actually go ahead and call `square`.
    Now we do want to create a variable to store the result so we can check that the
    result is what we expect it to be. Then we can call `utils.square` passing in
    a number. I''ll go with `3` in this case, which means I should expect 9 to come
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, we can have an `if` statement, if the result does not equal
    `9`, then we''ll throw a message because things went wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can throw an error using `throw new Error`, passing in whatever message
    we like. We can use a regular string, but I always prefer using a template string
    so we can inject values easily. I''ll say something like `Expected 9, but got`,
    followed by the value that''s not correct; in this case, that''s stored in the
    response variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can save this test case and run the test suite from the Terminal. Using
    the up arrow key and the *enter* key, we can rerun the last command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f9f81971-f62f-4d66-b24b-28de4fbf9eef.png)'
  prefs: []
  type: TYPE_IMG
- en: We get two tests passing, should add two numbers and should square a number
    both have checkmarks next to them. And we ran both tests in just 14 milliseconds,
    which is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the next thing, we want to do is mess up the `square` function to make
    sure our test fails when the number is not correct. I''ll add `1` on to the result
    in `utils.js`, which will cause the test to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can rerun things from the Terminal and we should see the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d97536cd-561d-4137-87b2-e23a7c65b50a.png)'
  prefs: []
  type: TYPE_IMG
- en: We get Expected 9, but got 10\. This is fantastic. We now have a test suite
    capable of testing both the `add` function and the `square` function. I'll remove
    that `+ 1`, and we are done.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a very, very basic test suite that we can execute with Mocha. Currently,
    we have two tests and to create those tests we used the `it` method provided by
    Mocha. In the upcoming sections, we'll be exploring more methods that Mocha gives
    us and we'll also be looking at better ways to do our assertions. Instead of manually
    creating them, we'll be using an assertion library to help with the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: Autorestarting the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we write more test cases, let''s see an automatic way to rerun our test
    suite when we change either our test code or our application code. We''ll be doing
    that with `nodemon`. Now, previously we used `nodemon` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We would type `nodemon` and we would pass in a file like `app.js`. Whenever
    any code in our app changed, it would rerun the `app.js` file as a Node application.
    What we can actually do is specify any command in the world we want to run when
    our files change. This means we can rerun `npm test` when the files change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll use the `exec` flag. This flag tells `nodemon` that we''ll
    specify a command to run, and it might not necessarily be a Node file. As shown
    in the following command, we can specify that command. It''ll be `''npm test''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Windows, remember to use double quotes in place of single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can now run the `nodemon` command. It''ll kick off for
    the first time running our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52e75c77-16e7-4be1-bc90-2ce1e09df52b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we see we have two tests passing. Let''s go ahead into the app `utils.js`
    and make a change to one of the functions, so it fails. We''ll add `3` or `4`
    onto the result for `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It automatically restarts over here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81443c9b-d50d-4ae9-a1ed-25ef54e1b1df.png)'
  prefs: []
  type: TYPE_IMG
- en: And now we see that we have a test suite where one test passes and one tests
    fails. I can always go ahead and undo that error we added, save the file, and
    the test suite will automatically rerun.
  prefs: []
  type: TYPE_NORMAL
- en: This will make testing your application that much easier. You won't have to
    switch to the Terminal and rerun the `npm test` command every time we make a change
    to our application. Now we have a command that we can run, we'll shut down `nodemon`
    and use the up arrow key to show it again.
  prefs: []
  type: TYPE_NORMAL
- en: And we can actually move this into a script inside of `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `package.json` we''ll make a new script right after the test script.
    Now we''ve used the `start` script and the `test` script—these are built-in—we''ll
    create a custom one called `test-watch`, and we can run the `test-watch` script
    to kick things off. Inside of `test-watch`, we''ll have the exact same command
    we ran from Terminal. That means we''ll be rounding `nodemon`. We''ll be using
    the `exec` flag and inside of quotes, we''ll be running `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can run the script from the Terminal as opposed
    to having to type out this command every single time we want to start up the autotest
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script we have inside `package.json` currently will work on macOS and Linux.
    It''ll also work on Heroku, which uses Linux. But it will not work on Windows.
    The following script will:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"test-watch": "nodemon --exec \"npm test\""`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, we're escaping the quotes surrounding `npm test` and we're
    using double quotes, which as we know are the only quotes supported by Windows.
    This script will remove any errors you're seeing, something like npm cannot be
    found, which you will get if you wrap `npm tests` in single quotes and run the
    script on Windows. So use the above script for cross-OS compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a script with a custom name, such as `test-watch`, in the Terminal all
    we need to do is run `npm run` followed by the script name, `test-watch`, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If I do this, it will start things off. We''ll get our test suite and it''s
    still waiting for changes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9abb5b25-aa06-48bc-b910-8b07bcfd103c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, every time you start the test suite you can simply use `npm run test-watch`.
    That'll start up the `test-watch` script, which starts up `nodemon`. Every time
    a change happens in your project, it'll rerun `npm test`, showing the results
    of the test suite to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to automatically restart our test suite, let's go ahead
    and get back into the specifics of testing in Node.
  prefs: []
  type: TYPE_NORMAL
- en: Using assertion libraries in testing Node modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we made two test cases to verify that `utils.add`
    and our `utils.square` method work as expected. We did that using an `if` condition,
    that is, if the value was not `44` that means something went wrong and we threw
    an error. In this section, we''ll learn how to use an assertion library, which
    will take care of all of the `if` condition in `utils.test.js` code for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because when we add more and more tests, the code will end up looking pretty
    similar and there's no reason to keep rewriting it. Assertion libraries let us
    make assertions about values, whether it's about their type, the value itself,
    whether an array contains an element, all sorts of things like that. They really
    are fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one we''ll be using is called expect. You can find it by going to Google
    and googling `mjackson expect`. And this is the result we''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db8fec07-660e-4fe8-aaed-8f51c493f29c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s mjackson''s repository, expect. It is a fantastic and super popular assertion
    library. This library will let us pass in a value and make some assertions about
    it. On this page, we scroll down past the introduction and the installation we
    can get down to an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/728344df-44fe-4c2e-b48f-77d20eaf4672.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we have our Assertions header and we
    have our first assertion, `toExist`. This will verify that a value exists. In
    the next line, we have an example, we pass in a string to `expect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fb080fa-90b3-4c74-856d-41b77619b2cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the value we want to make some assertions about. In the context of
    our application, that would be the response variable in the `utils.test.js`, shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to assert that it is equal to `44`. After we call `expect`, we can
    start chaining on some assertion calls. In the assertion example, next we check
    if it does exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This would not throw an error because a string is indeed truthy inside JavaScript.
    If we passed in something like `undefined`, which is not `truthy`, `toExist` would
    fail. It would throw an error and the test case would not pass. Using these assertions,
    we can make it really, really easy to check the values in our tests without having
    to write all of that code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring assertion libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and start exploring the assertion libraries. First up, let''s
    install the module inside the Terminal by running `npm install`. The module name
    itself is called expect and we''ll grab the most recent version, `@1.20.2`. Once
    again, we''ll be using the `save-dev` flag like we did with Mocha. Because we
    do indeed want to save this dependency in `package.json`, but it''s a `dev` dependency,
    it''s not required for the application to run whether it''s on Heroku or some
    other service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `expect` library has been donated to a different organization. The latest
    version, which is v21.1.0 is not compatible with the backward version we are using
    here that is 1.20.2. What I like you to do is install the 1.20.2 version in the
    section that will make sure, you'll use in next several sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and install this dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b511a1be-49e1-48ed-a0f9-3a2124c7d558.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can move to the application, and check out the `package.json` file,
    as shown in the following screenshot, it looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d77c03b2-9944-4f4e-a3cd-313fb6fcf88c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have both expect and Mocha. Now, inside our `utils.test` file, we can kick
    things off by loading in the library and making our first assertions using expect.
    Up at the very top of the file, we''ll load in the library, creating a constant
    called `expect` and `require(''expect'')`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get started by swapping out the `if` condition in the `utils.test.js`
    code with a call to `expect` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw in the example on assertion/expect page, we''ll start all our assertions
    by calling `expect` as a function passing in the value we want to make assertions
    about. In this case, that is the `res` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can assert all sorts of things. In this case, we want to assert that
    the value is equal to `44`. We''ll make our assertion `toBe`. On the documentation
    page, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07986522-41a9-488c-a795-be6e3f87be25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This asserts that a value equals another value and that''s exactly what we
    want. We assert that our value passed into expect equals another value using `toBe`,
    passing that value in as the first argument. Back inside Atom, we can go ahead
    and use this assertion, `.toBe`, and we''re expecting the result variable to be
    the number `44`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our test case and it should work exactly as it did with the `if`
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove it does work, let''s move into the Terminal and use the `clear` command
    to clear the Terminal output. Now we can run that `test-watch` script as shown
    in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e72bdf9c-5f95-4901-8a10-3a4233c84b58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding code output, we get our two tests passing just like
    they did before. Now we were to change `44` to some other value that would throw
    an error like `40`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We save the file, and we''ll get an error and the `expect` library will generate
    useful error messages for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06d5d04c-a118-49b5-9667-36c1cba16ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: It's saying that we Expected 44 to be 40\. Clearly that's not the case, so an
    error gets thrown. I'll change this back to `44`, save the file, and all of our
    tests will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining multiple assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can also chain together multiple assertions. For example, we could assert
    that the value that comes back from `add` is a number. This can be done using
    another assertion. So let''s head into the docs and take a look. Inside Chrome,
    we''ll scroll down through the assertion docs list. There are a lot of methods.
    We''ll be exploring some of them. In this case, we''re looking for `toBeA`, the
    method that takes a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72f449b0-2275-49a4-b133-aeb0a0b2aa54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This takes the string type and it uses the `typeof` operator to assert that
    the value is of a certain type. Here we''re expecting `2` to be a number. We can
    do that exact same thing over in our code. Inside Atom, right after `toBe`, we
    can chain on another call, `toBeA`, followed by the type. This could be something
    like a string, it could be something like an object, or in our case, it could
    be a number, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll open up the Terminal so we can see the results. It''s currently hidden.
    Save the file. Our tests will rerun and we can see they''re both passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c4f3131-3392-4529-b3f5-08f8ae8a8513.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use a different type, something that was going to cause the test to
    fail for example string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then get an error message, Expected 44 to be a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148b632f-b576-400e-86d7-7674d0c50863.png)'
  prefs: []
  type: TYPE_IMG
- en: This is really useful. It'll help us clean up our errors really quickly. Let's
    change the code back to number and we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple assertions for the square function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''d like to do the same thing for our tests for square a number function.
    We''ll use `expect` to assert that the response is indeed the number `9` and that
    the type is a number. We''ll use these same two assertions we do with the `add`
    function. First, we need to do to delete the current square `if` condition code,
    since we will not be using that anymore. As shown in the following code, we''ll
    make some expectations about the `res` variable. We''ll expect it to be the number
    `9`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save the file and make sure the test passes, and it does indeed pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b487bf1-d06d-434b-a50b-8f9c765b1ac0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we''ll assert the type using `toBeA`. Here, we''re checking that the type
    of the return value from the `square` method is a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we save the file, we get both of our tests still passing, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b72f471-5ee4-4ee0-bf06-c9a76ac72b6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now this is just a small test as to what `expect` can do. Let's create a bogus
    test case that will explore a few more ways we can use `expect`. We'll not be
    testing an actual function. We'll just play around with some assertions inside
    of the it callback.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring usage of expect with bogus test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the bogus test, we''ll make a new test using the `it` callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put whatever we want in here, it''s not too important. And we''ll pass
    in an arrow function (`=>`) as our callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as we''ve seen already, one of the most fundamental assertions you''ll
    make is you''re just going to check for equality. We want to check if something
    like the response variable equals something else, like the number `44`. Inside
    `expect`, we can also do the opposite. We can expect that a value like `12` does
    not equal, using `toNotBe`. And then we can assert that it doesn''t equal some
    other value, like `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The two aren''t equal, so when we save the file over in the Terminal, all three
    tests should be passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/870d8673-50d1-4c10-8a66-f07723443dc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I set that equal to the same value, it''ll not work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get an error, Expected 12 to not be 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cc4d4d4-50a6-40ce-9c22-8e3c5e3abf73.png)'
  prefs: []
  type: TYPE_IMG
- en: Now `toBe` and `toNotBe` work great for numbers, strings, and Booleans, but
    if you're trying to compare arrays or objects, they will not work as expected
    and we can prove this.
  prefs: []
  type: TYPE_NORMAL
- en: Using toBe and toNotBe to compare array/objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with removing the current code by commenting it out. We''ll leave
    it around so we use it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll `expect` an object with the `name` property set to `Andrew`, `toBe`,
    and we''ll assert that it is another object where the name property is equal to
    `Andrew`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use `toBe`, just like we did with `number`, checking if it is the same
    as another object where name equals `Andrew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we save this, you might think the test will pass, but it doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57f7879d-4325-48a3-8fb6-66d5fce52a11.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding output, we see that we expected the two names to be
    equal. When objects are compared for equality using the triple equals, which is
    what `toBe` uses, they'll not be the same because it's trying to see if they're
    the exact same object, and they're not. We've created two separate objects with
    the same properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using the toEqual and toNotEqual assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To check if the two names are equal, we''ll have to use something different.
    It''s called `toEqual` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save the file now, this will work. It''ll rip into the object properties,
    making sure they have the same ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b3cc75-0879-4062-9987-aef09129e358.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same thing goes for `toNotEqual`. This checks if two objects are not equal.
    To check this, we''ll go ahead and change the first object to have a lowercase
    a in `andrew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the test passes. They are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51524f8b-6f39-41df-a287-bae020478cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we do equality with our objects and arrays. Now another really useful
    thing we have is `toInclude`.
  prefs: []
  type: TYPE_NORMAL
- en: Using toInclude and toExclude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `toInclude` assertion checks if an array or an object includes some things.
    Now if it's an array, we can check if it includes a certain item in the array.
    If it's an object, we can check if it includes certain properties. Let's run through
    an example of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll `expect` that an array with the numbers `2`, `3`, and `4` inside the
    `it` callback has the number `5` inside and we can do that using `toInclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toInclude` assertion takes the item. In this case, we''ll check if the
    array has `5` inside. Now clearly it doesn''t, so this test will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be047123-f90a-43e9-9bfd-353d07cf9a68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get the message, Expected [ 2, 3, 4] to include 5\. That does not exist.
    Now we change this to a number that does exist, for example `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll rerun the test suite and everything will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a4a5f75-7093-4d79-ae04-57d0e31a12fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, along with `toInclude`, we have `toExclude` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will check if something does not exist, for example the number `1`, which
    is not in the array. If we run this assertion, the test passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76187806-132d-4519-9569-5e31fe3216ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same two methods, `toInclude` and `toExclude`, work with objects as well.
    We can play with that right on the next line. I''ll `expect` that the following
    object has something on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and create an object that has a few properties. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: We''ll set it equal to any name, let''s say `Andrew`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age`: We''ll set that equal to age, say `25`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`: We''ll set that equal to any location, for example `Philadelphia`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will look like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s say we want to make some assertions about particular properties,
    not necessarily the entire object. We can use `toInclude` to assert that the object
    has some properties and that those property values equals the value we pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the `age` property. Let''s say we only care about the age. We
    can assert that the object has an `age` property equal to `25` by typing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn''t matter that there''s a `name` property. The `name` property could
    be any value. That is irrelevant in this assertion. Now let''s use the value,
    `23`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will fail as shown here since the value is not correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb2f5516-e01c-49e7-9ffd-db74c5328603.png)'
  prefs: []
  type: TYPE_IMG
- en: We expected the `age` property to be `23`, but it was indeed `25`, so the test
    fails. The same thing goes with the `toExclude` assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we can save our test files. This checks if the object does not have a
    property age equal to `23`. It does indeed not have that, so the test passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/917b02e0-062b-4e65-bb6b-338229c4ec58.png)'
  prefs: []
  type: TYPE_IMG
- en: This is just a quick taste as to what expect can do. For a full list of features,
    I recommend diving through the documentation. There's a ton of other assertions
    you can use, things like checking if a number is greater than another number,
    if a number is less than or equal to another number, all sorts of math-related
    operations are included as well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the setName method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s wrap up this section with some more testing. Over in `utils.js`,
    we can make a new function, one that we''ll be testing, `module.exports.setName`.
    The `setName` function is will take two arguments. It''ll take a `user` object,
    some fictitious user object with some generic properties, and it''ll take `fullName`
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The job of `setName` will be to rip apart `fullName` into two parts—the first
    name and the last name—by splitting it on the space. We'll set the two properties,
    first name and last name, and return the `user` object. We'll fill out the function
    then we'll write the test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is split the name into a `names` array, `var names`
    will be that array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It''ll have two values, assuming there''s only one space inside of the name.
    We''re assuming someone types their first name, hits a space, and types their
    last name. We''ll set this equal to `fullName.split` and we''ll split on the space.
    So I''ll pass in an empty string with a space inside it as the value to split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a `names` array where the first item is the `firstName` and the
    last item is the `lastName`. So we can start updating the `user` object. `user.firstName`
    will equal the first item in the `names` array and we''ll grab the index of `0`,
    which is the first item. We''ll do something similar for last name, `user.lastName`
    equals the second item from the `names` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re all done, we have the names set, and we can return the `user` object
    `using return` user, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `utils.test` file, we can now kick things off. First, we''ll comment
    out our `it(''should expect some values'')` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty great for documentation. You can always explore it later if you
    forget how things work. We'll create a new test that should verify first and last
    names are set.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a `user` object. On that `user` object, we want to set some properties
    such as `age` and `location`. Then we'll pass the variable `user` into the `setName`
    method. That'll be the first argument defined in the `utils.js` file. We'll pass
    in a string. The string with `firstName` followed by a space followed by `lastName`.
    Then we'll get the result back and we'll make some assertions about it. We want
    to assert the returning object includes using the `toInclude` assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, we''ll call it to make the new test case. We''ll
    be testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `it`, we can now provide our second argument, which will be our callback
    function. Let''s set that to an arrow function (`=>`) and now we can make the
    `user` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `user` object will have a few properties. Let''s add something like `location`,
    setting that equal to `Philadelphia`, and then set an `age` property, setting
    that equal to `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll call the method we defined over in `utils.js`, the `setName` method.
    We''ll do that on the next line, creating a variable called `res` to store the
    response. Then we''ll set that equal to `utils.setName` passing in the two arguments,
    the `user` object and `fullName`, `Andrew Mead`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now at this point, the result should be what we expect. We should have the `firstName`
    and `lastName` properties. We should have the `location` property and the `age`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you know a lot about JavaScript, you might know that objects are passed
    by reference, so the `user` variable has actually been updated as well. That is
    expected. Both `user` and `res` will have the exact same value. We can actually
    go ahead and prove that using an assertion. We''ll `expect` that `user` equals
    using `toEqual` the `res`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside Terminal, we can see the test does indeed pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40134642-c54b-48fa-b144-c17a57ca1977.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s delete `expect(user).toEqual(res);`. Now, we want check if the `user`
    object or the `res` object includes certain properties. We''ll check using `expect`
    that the `res` variable has some properties using `toInclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties we''re looking for are `firstName` equal to what we would expect
    that to be, `Andrew`, and `lastName` equal to `Mead`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the assertions that should be made in order to verify that `setName`
    is working as expected. If I save the file, the `test` suite reruns and we do
    indeed get the passing tests as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da39513e-fd35-4ed0-a94a-7bc08925cbb0.png)'
  prefs: []
  type: TYPE_IMG
- en: We have three of them and it took just 10 milliseconds to run.
  prefs: []
  type: TYPE_NORMAL
- en: And with this in place, we now have an assertion library for our `test` suite.
    That's fantastic because writing test cases just got way easier, and the whole
    goal of the chapter is to make testing approachable and easy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll start looking at how we can test more complex asynchronous
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to test asynchronous functions. The process
    of testing asynchronous functions isn't that different from synchronous ones,
    like what we've done already, but it is a little different so it justifies its
    own section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the asyncAdd function using the setTimeout object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick things off, we''ll make a fake `async` function using `setTimeout`
    to simulate a delay inside `utils.js`. Just below where we make our `add` function,
    let''s make one called `asyncAdd`. It''ll essentially have the same features,
    but it''ll use `setTimeout` and it''ll have a callback to simulate a delay. Now
    in the real world, this delay might be a database request or an HTTP request.
    We''ll be dealing with that in the following chapters. For now though, let''s
    add `module.exports.asyncAdd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take three arguments, as opposed to the two the `add` function took,
    `a`, `b`, and `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what''s going to make the function asynchronous. Eventually, once the
    `setTimeout` is up, we''ll call the callback with the sum, whether it''s one plus
    three being four, or five plus nine being fourteen. Next up, we can put the arrow
    in arrow function (`=>`) and open and close our curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the arrow function (`=>`), as mentioned, we''ll be using `setTimeout`
    to create the delay. We''ll pass in a callback and we''ll pass in our `setTimeout`.
    Let''s go with 1 second in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by default, if our tests take longer than 2 seconds, Mocha will assume
    that is not what we wanted and it''ll fail. That''s why we''re using 1 second
    in this case. Inside our callback, we can call the actual `callback` argument
    with the sum `a + b`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We now have an `asyncAdd` function and we can start writing a test for it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test for the asyncAdd function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of the `utils.test` file, just under our previous test for `utils.add`,
    we''ll add a new one for `asyncAdd`. The test setup will look really similar.
    We will be calling `it` and passing in a string as the first argument and a callback
    as the second argument. Then we''ll add our callback, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the callback, we can get started calling `utils.asyncAdd`. We''ll call
    it using `utils.asyncAdd` and we''ll pass in those three arguments. We''ll use
    `4` and `3`, which should result in `7`. And we''ll provide the callback function,
    which should get called with that value, the value being `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the callback arguments, we would expect something like `sum` to come
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Making assertion for the asyncAdd function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can start making some assertions about that `sum` variable using the
    `expect` object. We can pass it into `expect` to make our assertions, and these
    assertions aren''t going to be new. It''s stuff we''ve already done. We''ll `expect`
    that the `sum` variable equals, using `toBe`, the number `7`. Then we''ll check
    that it''s a number, using `toBeA`, inside quotes, `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now obviously if it is equal to `7` that means it is a number, but we're using
    both just to simulate exactly how chaining will work inside of our expect calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our assertions in place, let''s save the file and run our
    test and see what happens. We''ll run it from Terminal, `npm run test-watch` to
    start up our `nodemon` watching script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our tests will run and the test does indeed pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a5061b7-3cbd-41cd-9253-c2c8d0a81782.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only problem is that it''s passing for the wrong reasons. If we change
    `7` to `10` and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the test is still going to pass. Right here, you see we have
    four tests passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ef4f4cd-2e72-43a1-aaa9-b21931ccd1d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the done argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the reason this test is passing is not because the assertion in `utils.test.js`
    is valid. It's passing because we have an asynchronous action that takes 1 second.
    This function will return before the `async` callback gets fired. When I say function
    returning, I'm referring to the `callback` function, the second argument to `it`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is when Mocha thinks your test is done. This means that these assertions
    never run. The Mocha output has already said our test passes before this callback
    ever gets fired. What we need to do is tell Mocha this will be an asynchronous
    test that''ll take time. To do this, all we do is we provide an argument inside
    the callback function we pass to it. We''ll call this one `done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have the `done` argument specified, Mocha knows that means we have
    an asynchronous test and it''ll not finish processing this test until `done` gets
    called. This means we can call `done` after our assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, our test will now run. The function will return right after
    it calls `async.Add`, but that's OK because we have `done` specified. About a
    second later, our callback function will fire. Inside the `asyncAdd` callback
    function, we'll make our assertions. This time the assertions will matter because
    we have `done` and we haven't called it yet. After the assertions we call done,
    this tells Mocha that we're all done with the test. It can go ahead and process
    the result, letting us know whether it passed or failed. This will fix that error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I save the file in this state, it''ll rerun the tests and we''ll see that
    our test should `async.Add` two numbers will indeed fail. Inside Terminal, let''s
    open up the error message, we have Expected 7 to be 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/858b39b4-9141-4f4f-85d0-db38d9be3d0d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is exactly what we thought would happen the first time around when we didn't
    use `done`, but as we can see, we do need to use `done` when we're doing something
    asynchronous inside of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can change this expectation back to `7`, save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This time around things should work as expected after 1 second delay as it
    runs this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/752973ad-70d3-4cf5-a5ea-d9694f49feeb.png)'
  prefs: []
  type: TYPE_IMG
- en: It can't report right away because it has to wait for done to get called. Notice
    that our total test time is now about a second. We can see that we have four tests
    passing. Mocha also warns us when a test takes a long time because it assumes
    that's not expected. Nothing inside Node, even a database or HTTP request, should
    take even close to a second, so it's essentially letting us know that there's
    probably an error somewhere inside of your function—it's taking a really, really
    long time to process. In our case though, the one second delay was clearly set
    up inside of `utils` so there's no need to worry about that warning.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we now have a test for our very first asynchronous method.
    All we had to do is add a `done` as an argument and call it once we were done
    making our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous testing for the square function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's create an asynchronous version of the `square` method as we did with
    the synchronous one. In order to get started, we'll define the function first
    and then we'll worry about writing that test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the async square function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `utils` file, we can get started next to the `square` method creating
    a new one called `asyncSquare`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'It''ll take two arguments: the original argument which we called `x`, and the
    `callback` function that''ll get called after our 1-second delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can finish up the arrow function (`=>`) and we can start working on
    the body of `asyncSquare`. It''ll look pretty similar to the `asyncAdd` one. We''ll
    call `setTimeout` passing in a callback and a delay. In this case, the delay will
    be the same; we''ll go with 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can actually call the callback. This will trigger the `callback` function
    that got passed in and we''ll pass in the value `x` times `x`, which will properly
    square the number passed in place of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Writing test for asyncSquare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now inside the `test` file, things are indeed passing, but we haven''t added
    a test for the `asyncSquare` function so let''s do that. Inside the `utils.test`
    file, the next thing you needed to do was call `it`. Next to `it` for testing
    the `asyncAdd` function, let''s call `it` to make a new test for this `asyncSquare`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll provide the callback function that''ll get called when the
    test actually executes. And since we are testing an `async` function, we''ll put
    `done` in the callback function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell Mocha to wait until `done` is called to decide whether or not
    the test passed. Next, we can now call `utils.asyncSquare` passing in a number
    of our choice. We''ll use `5`. Next up, we can pass in a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the final result. In the arrow function (`=>`), we''ll create
    a variable to store that result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can start making our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Making assertions for the asyncSquare function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The assertions will be done using the `expect` library. We''ll make some assertions
    about the `res` variable. We''ll assert that it equals, using `toBe`, the number
    `25`, which is `5` times `5`. We''ll also use `toBeA` to assert something about
    the type of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we want to make sure that the `square` is indeed a number, as
    opposed to a Boolean, string, or object. With this in place, we do need to call
    `done` and then save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, if you don''t call `done`, your test will never finish. You might
    find that every once in a while you''ll get an error like this inside the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b050421f-a3c1-451c-bf59-a522f76a0edd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''re getting an error timeout, the 2,000 milliseconds has exceeded. This
    is when Mocha cuts off your test. If you see this, this usually means two things:'
  prefs: []
  type: TYPE_NORMAL
- en: You have an `async` function that never actually calls the callback, so you're
    call to done never gets fired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You just never called `done`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see this message, it usually means there's a small typo somewhere in
    the `async` function. To overcome this, either fix things in the method (`utils.js`)
    by making sure the callback is called, or fix things in the test (`utils.test.js`)
    by calling `done`, and when you save the file you should now see all of your tests
    are passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we have 5 tests passing and it took 2 seconds to do that. This
    is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80634d18-e725-4f62-9bbc-0c7b819f8df0.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a way to test synchronous functions and asynchronous functions.
    This will make testing a lot more flexible. It'll let us test essentially everything
    inside of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into testing the synchronous and asynchronous functions.
    We looked into basic testing. We explored the testing framework, Mocha. Then,
    we look into using assertion libraries in testing Node modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how we can test our Express apps.
  prefs: []
  type: TYPE_NORMAL
