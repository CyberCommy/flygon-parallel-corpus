- en: Mobile-First React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to use the `react-bootstrap` package. This
    package provides mobile-first React components by leveraging the Bootstrap CSS
    framework. It's not the only option available for doing mobile-first React, but
    it's a good choice, and it brings together two of the most popular technologies
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: I'll start with the motivation for adopting a mobile-first design strategy.
    Then you'll spend the rest of this chapter implementing a few `react-bootstrap`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind mobile-first design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile-first design is a strategy that treats mobile devices as the primary
    target for user interfaces. Larger screens, such as laptops or big monitors, are
    secondary targets. This doesn't necessarily mean that the majority of users are
    accessing your app on their phones. It simply means that mobile is the starting
    point for scaling the user interface geometrically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when mobile browsers first appeared it was customary to design
    the UI for normal desktop screens, and then to scale down to smaller screens when
    necessary. The approach is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b280ba0f-34ce-4d9d-8ad7-ba20ff26b511.png)'
  prefs: []
  type: TYPE_IMG
- en: The idea here is that you design the UI with larger screens in mind so that
    you can fit as much functionality as possible onto the screen at once. When smaller
    devices are used, your code has to either use a different layout or different
    components on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: This is very limiting for a number of reasons. First, it's very difficult to
    maintain code that has lots of special-case handling for different screen resolutions.
    Second, and the more compelling argument against this approach, is that it's next
    to impossible to provide a similar user experience across devices. If large screens
    have a ton of functionality displayed all at once, you simply cannot replicate
    this on smaller screens. Not only is there less real estate, but the processing
    power and network bandwidth of smaller devices are limiting factors as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mobile-first approach to UI design tackles these issues by scaling the
    UI up, instead of trying to scale it down, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a0669383-dc7c-41c3-816f-5666d856f7aa.png)'
  prefs: []
  type: TYPE_IMG
- en: This approach never used to make sense because you would be limiting the capabilities
    of your application; there weren't many tablets or phones around. This is not
    the case today, where the expectation is that users can interact with applications
    on their mobile devices without any issues. There are a lot more of them now,
    and mobile browsers are quite capable of handling anything you throw at them.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've implemented your application functionality in a mobile context,
    scaling it up to larger screen sizes is a relatively easy problem to solve. Now,
    let's take a look at how to approach mobile-first in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-bootstrap components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's possible to implement mobile-first React user interfaces by rolling
    your own CSS, I would recommend against doing this. There are a number of CSS
    libraries that handle the seemingly endless edge cases for you. In this section,
    I'll introduce the `react-bootstrap` package—React components for Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: The `react-bootstrap` package exposes a number of components that serve as a
    thin abstraction layer between your application and Bootstrap HTML/CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement some examples now. Another reason I'm showing you how to work
    with `react-bootstrap` components is that they're similar to `react-native` components,
    which you'll learn about starting in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The idea with the following examples is not in-depth coverage of `react-bootstrap`,
    or Bootstrap itself for that matter. Rather, the idea is to give you a feel for
    what it's like to work with mobile-first components in React by passing them state
    from containers and so on. For now, take a look at the `react-bootstrap` documentation
    ([http://react-bootstrap.github.io/](http://react-bootstrap.github.io/)) for specifics.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important aspect of a mobile-first design is the navigation. It's especially
    difficult to get this right on mobile devices because there's barely enough room
    for feature content, let alone tools to move from feature to feature. Thankfully,
    Bootstrap handles much of the difficulty for you.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn how to implement two types of navigation. You'll
    start with toolbar navigation, and then you'll build a sidebar navigation section.
    This makes up part of the UI skeleton that you'll start with. What I find really
    useful about this approach is that, once the navigation mechanisms are in place,
    it's easy to add new pages and to move around in the app as I build it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `Navbar.` This is a component found in most applications
    and is statically positioned at the top of the screen. Within this bar, you''ll
    add some navigation links. Here''s what the JSX for this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the navigation bar looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6ecf6e39-4aed-4963-be2c-94291f0e21b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The `<Navbar.Header>` component defines the title of the application and is
    placed to the left of the navigation bar. The links themselves are placed in the
    `<Nav>` element and the `pullRight` property aligns them to the right side of
    the navigation bar. You can see that, instead of using `<Link>` from the `react-router`
    package, you're using `<LinkContainer>` and `<IndexLinkContainer>`. These components
    come from the `react-router-bootstrap` package. They're necessary to make Bootstrap
    links work properly with the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<Nav>` element is wrapped in a `<Navbar.Collapse>` element and the header
    contains a `<Navbar.Toggle>` button. These components are necessary to collapse
    the links into a drop-down menu for smaller screens. Since it''s based on the
    browser''s width, you can just resize your browser window to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/54cb73bc-0763-4256-8a2a-629cc125783b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The links that were displayed are now collapsed into a standard menu button.
    When this button is clicked, the same links are displayed in a vertical fashion.
    This works much better on smaller devices. But with larger screens, having all
    navigation displayed in the top navigation bar might not be ideal. The standard
    approach is to implement a left-hand sidebar with navigation links stacked vertically.
    Let''s implement this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<Col>` element is the container for the `<Nav>` and you''ve added your
    own class name to it. You''ll see why in a moment. Inside the `<Nav>` element,
    things look exactly the same as they do in the navigation toolbar, with link containers
    and menu items. Here''s what the sidebar looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16781823-18a2-4b58-a9be-8e3eb1e93751.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the reason that we needed to add that custom `sidebar` class name to the
    containing element was so that we can hide it completely on smaller devices. Let''s
    take a look at the CSS involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This CSS, along with the overall structure of this example, is adapted from
    this Bootstrap example: [http://getbootstrap.com/examples/dashboard/](http://getbootstrap.com/examples/dashboard/).
    The idea behind this media query is that if the minimum browser width is `768px`,
    then show the sidebar in a fixed position. Otherwise, hide it completely because
    we''re on a smaller screen.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have two navigation components collaborating with one another
    to change how they're displayed based on the screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common UI element in both mobile and desktop contexts is rendering lists
    of items. This is easy enough to do without the support of a CSS library, but
    libraries help keep the look and feel consistent. Let''s implement a list that''s
    controlled by a set of filters. First, you have the component that renders the
    `react-bootstrap` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, you have the `<ButtonGroup>` and the `<Button>` elements. These are the
    filters that the user can apply to the list. By default, only todo items are displayed.
    But, they can choose to filter by done items, or to show all items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list itself is a `<ListGroup>` element with `<ListGroupItem>` elements
    as children. The item renders differently, depending on the `done` state of the
    item. The end result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/49c26dbd-7540-41ed-aa20-2a38446132a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can toggle the done state of a list item simply by clicking on the Done
    button. What''s nice about the way this component works is that if you''re viewing
    todo items and mark one as done, it''s taken off the list because it no longer
    meets the current filter criteria. The filter is re-evaluated because the component
    is re-rendered. Here''s what an item that''s marked as done looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/71702a3c-8322-42ce-a9dd-9a75f44f6bad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s take a look at the container component that handles the state of
    the filter buttons and the item list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This component has four pieces of state and four event handler functions. Three
    pieces of state do nothing more than track which filter button is selected. The
    `filter` state is the callback function that's used by `<FilteredList>` to filter
    the items. The tactic is to pass a different filter function to the child view,
    based on the filter selection.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section of the chapter, you'll implement some form components
    from `react-bootstrap`. Just like the filter buttons you created in the preceding
    section, form components have state that needs to be passed down from a container
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even simple form controls have many moving parts. First, you''ll learn
    about text inputs. There''s the input itself, but there''s also the label, the
    placeholder, the error text, the validation function, and so on. To help glue
    all these pieces together, let''s create a generic component that encapsulates
    all of the Bootstrap parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two key advantages to this approach. One is that, instead of having
    to use `<FormGroup>`, `<FormControl>`, `<HelpBlock>`, and so on, you just need
    your `<Input>` element. Another advantage is that only the `type` property is
    required, meaning that `<Input>` can be used for simple and complex controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this component in action now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one component used to create all of the necessary Bootstrap pieces
    underneath. Everything is passed in through a property. Here''s what this form
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e57f86f6-a57a-43b2-bacf-3c959d110b81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at the container component that controls the state of these
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The event handlers for the inputs are part of the state that get passed to
    `InputsForm` as properties. Now let''s take a look at some checkboxes and radio
    buttons. You''ll use the `<Radio>` and the `<Checkbox>` react-bootstrap components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The radio buttons toggle the `enabled` state of the checkbox and the checkbox
    toggles the `enabled` state of the radios. Note that, although the two `<Radio>`
    elements are in the same `<FormGroup>`, they need to have the same `name` property
    value. Otherwise, you''ll be able to select both radios at the same time. Here''s
    what this form looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70854800-97b6-4343-92ee-aca2cff405d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s look at the container component that handles the state of the
    radios and the checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the concept of mobile-first design. You had a
    brief overview of why you might want to use the mobile-first strategy. It boils
    down to the fact that scaling mobile designs up to larger devices is much easier
    than scaling in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned what this means in the context of a React application. In
    particular, you want to use a framework such as Bootstrap that handles the scaling
    details for us. You then implemented several examples using components from the
    `react-bootstrap` package.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the first part of this book. You're now ready to tackle React
    projects that live on the web, including mobile browsers! Mobile browsers are
    getting better, but they're no match for the native capabilities of mobile platforms.
    Part 2 of this book teaches you how to use React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should React developers consider the mobile-first approach to designing
    their applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because most users are on mobile devices and it isn't worthwhile to think about
    larger displays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because targeting mobile devices as the primary display for your application
    ensures that you can handle mobile devices and scaling up to larger devices is
    easier than the other way around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't make sense. You should target larger displays first and scale down
    your application for mobile devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're using a library such as `react-bootstrap`, you don't even need to
    think about mobile-first concepts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does `react-router` integrate well with `react-bootstrap`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. Although you'll want to use the **`react-router-bootstrap`** package to
    make sure that you can add links to the **`NavItem`** and **`MenuItem`** components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you should just use regular links in your `react-bootstrap` components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, but you should consider writing your own abstractions so that all types
    of `react-bootstrap` buttons work with the `Link` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you go about rendering lists of items using `react-bootstrap`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap a `<ul>` element with a `<ListGroup>` component from `react-bootstrap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just use a `<ul>` and apply Bootstrap classes to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **`ListGroup`** and **`ListGroupItem`** components from **`react-bootstrap`.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you create an abstraction for `react-bootstrap` form components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `react-bootstrap` form components are lacking in functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because there are many related components that you need to use for basic inputs
    and creating this abstraction makes life easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this is the only way to get input validation to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information you can check out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://react-bootstrap.github.io/](https://react-bootstrap.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://getbootstrap.com/](https://getbootstrap.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
