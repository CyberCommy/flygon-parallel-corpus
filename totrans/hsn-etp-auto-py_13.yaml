- en: Ansible for System Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore one of the popular automation frameworks used
    by thousands of network and system engineers called *Ansible*, Ansible is used
    to administrate servers and network devices over multiple transport protocols
    such as SSH, Netconf, and API  in order to deliver a reliable infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: We will start first by learning the terminologies used in ansible, how to construct
    an inventory file that contains the infrastructure access details, Building a
    robust Ansible playbook using features like conditions, loops, and template rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible belongs to the configuration management class of software; it is used
    to manage the configuration life cycle on multiple different devices and servers,
    making sure that the same steps are applied on all of them and help to create
    Infrastructure as a code (IaaC) environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and its terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ansible on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible in ad hoc mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create your first playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Ansible conditions, handlers, and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Ansible facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Ansible template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is an automation tool and a complete framework that provides an abstraction
    layer based on Python tools. Originally, it was designed to handle task automation.
    This task might be executed  on a single server or on thousands of servers and
    ansible will handle them without any problem; later, Ansible's scope extended
    to network devices and cloud providers. Ansible follows the concept of `idempotency`,
    wherein Ansible instructions can run the same task multiple times and always give
    the same configuration on all devices at the end, reaching a desired state with
    minimal changes. For example, if we run Ansible to upload a file to a specific
    group of servers, then run it again, Ansible will first validate if the file already
    exist in the remote destination as a result a previous execution or not. if it
    exist, then the ansible won't upload it
  prefs: []
  type: TYPE_NORMAL
- en: again. This feature called **idempotency**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect of Ansible is that it is agentless. Ansible doesn''t require
    any agents to be installed in the servers before it runs tasks. It leverages the
    SSH connection and Python standard libraries to execute tasks on remote servers
    and return the output to the Ansible server. Also, it doesn''t create a database
    to store remote machine information, but depends on a flat text file called `inventory`
    to store all required server information, such as IP addresses, credentials, and
    infrastructure categorization. The following is an example of a simple inventory
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we group together servers that perform the same functions in our
    infrastructure (such as database servers, in a group called `[db-servers]`; the
    same goes for `[web-servers]`). Then, we define a special group, called `[all]`,
    that combines both groups, in case we have a task targeted to all of our servers.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `children`, in `[all:children]`, means that the entries inside the
    group are also groups that contain hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible's **ad hoc** mode allows users to execute tasks directly from the Terminal,
    towards the remote servers. Let's suppose that you want to update specific packages
    on specific types of servers, such as databases or web backend servers, to resolve
    a new bug. At the same time, you don't want to go all the way to developing a
    complex playbook to execute a simple task. By leveraging the ad hoc mode in Ansible, you
    can execute any command on the remote servers by typing it on the Ansible host
    Terminal. Even some modules can be executed in the Terminal; we will see that
    in the *Using Ansible in ad hoc mode* section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible package is available on all major Linux distributions. In this section,
    we will install it onto both Ubuntu and CentOS machines. The Ansible 2.5 release
    was used at the time of developing this book, and it provides support for both
    Python 2.6 and Python 2.7\. Also, starting from version 2.2, Ansible provides
    a tech preview for Python 3.5+.
  prefs: []
  type: TYPE_NORMAL
- en: On RHEL and CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to have the EPEL repository installed and enabled before installing
    Ansible. To do so, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, proceed with the Ansible package installation, as shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, make sure that your system is up to date, and add the Ansible channel.
    Finally, install the Ansible package itself, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more installation flavors, you can check the official Ansible website ([http://docs.Ansible.com/Ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine](http://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can validate your installation by running `Ansible --version` to check
    the installed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00164.jpeg)The Ansible configuration files are usually stored
    in `/etc/Ansible`, with the filename `Ansible.cfg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible in ad hoc mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible ad hoc mode is used when you need to execute simple operations on remote
    machines, without creating complex and persistent tasks. This is where a user
    usually starts when they first work on Ansible, before performing advanced tasks
    in a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the ad-hoc command requires two things. First, you will need the
    host or group from the inventory file; secondly, you will need the Ansible module
    that you want to execute towards the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define our hosts and add the CentOS and Ubuntu machines in a
    separate group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `hosts`, under `/root/` or your home directory in the `AutomationServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, run the `Ansible` command with the `ping` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` argument will accept the inventory file that we added, while the `-m`
    argument will specify the name of the Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command, you will get the following output, indicating a
    failure in connecting to the remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This happened because the remote machines are not inside of the `known_hosts`
    of the Ansible server; it can be solved through two methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is SSHing to them manually, which will add the host fingerprint
    to the server. Or, you can completely disable host key checking in the Ansible
    configuration, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the `Ansible` command, and you should get successful output from the
    three machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `ping` module in Ansible does not perform the ICMP operation against the
    device. It actually tries to log in to the device by using the SSH with provided
    credentials; if the login succeeds, it will return the `pong` keyword to the Ansible
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful module is `apt`, or `yum`, which is used to manage the package
    on either an Ubuntu or CentOS server. The following example will install the `apache2`
    package on the Ubuntu machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The state in the `apt` module can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `absent` | Removes the package from the system. |'
  prefs: []
  type: TYPE_TB
- en: '| `present` | Makes sure that the package is installed on the system. |'
  prefs: []
  type: TYPE_TB
- en: '| `latest` | Ensures that the package is in the latest version. |'
  prefs: []
  type: TYPE_TB
- en: You can access the Ansible module documentation by running `Ansible-doc <module_name>`;
    you will see the full options, with examples, for the module.
  prefs: []
  type: TYPE_NORMAL
- en: The `service` module is used to manage operation and current status of the 
    service. You can change the service status to either `started`, `restarted` or
    `stopped` in the `state` option and ansible will run the appropriate command to
    change the status. In the meantime, you can configure whether service is enabled
    at boot time or disabled by configuring the `enabled` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can restart the service by providing the service name, with the `state`
    set as `restarted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way to run Ansible in ad hoc mode is to pass the command directly
    to Ansible, using not the built-in modules but the `-a` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even reboot the servers by running the `reboot` command; but this time,
    we will only run it against the CentOS servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you will need to run the command (or the module) using a different
    user. This will be useful when you run a script on a remote server with specific
    permissions assigned to a user different than the SSH user. In that case, we will
    add the `-u`, `--become`, and `--ask-become-pass` (`-K`) switches. This will make
    Ansible run the command with the provided username and prompt you for the user''s
    password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How Ansible actually works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is basically written in Python, However it use it's own DSL (Domain
    Specific Language). You can write using this DSL and ansible will convert it to
    Python on remote machines to execute tasks. So, it first validates the task syntax
    and copies the module from the Ansible host to the remote server, and then executes
    it on the machine itself over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result from the execution is returned back to the Ansible host in a `json`
    format, so you can match any returned values by knowing its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of network devices where Python is installed on the **Network Operating
    System **(**NOS**), Ansible uses either an API or `netconf`, if the network device
    supports it (such as Juniper and Cisco Nexus); or, it just executes commands using
    the paramiko `exec_command()` function, and returns the output to the Ansible
    host. This can be done by using the `raw` module, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating your first playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the magic party can begin. An Ansible playbook is a set of commands (called
    tasks) that need to be executed in order, and it describes the desired state of
    the hosts after execution finishes. Think of a playbook as a manual that contains
    a set of instructions for how to change the state of an infrastructure; each instruction
    depends on many built-in Ansible modules to perform the tasks. For example, you
    may have a playbook that is used to build web applications that consist of SQL
    servers, to act as backend databases and nginx web servers. The playbook will
    have a list of tasks to perform against each group of servers, to change their
    states from `No-Exist` to `Present`, or to `Restarted` or `Absent`, if you want
    to delete the web app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of having the playbook, over the ad hoc commands is that you can
    use it to configure and set up your infrastructure everywhere. The same procedure
    used to create the dev environment will be used in the production environment.
    A playbook is used to create the automation workflow that runs on your infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Playbooks are written with YAML, which we discussed in [Chapter 6](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f),
    *Configuration Generator with Python and Jinja2*. A playbook consists of multiple
    plays, executed against a set of hosts that are defined in the inventory file.
    The hosts will be converted to a Python `list`, and each item inside the list
    will be called a `play`. In the preceding example, the `db-servers` tasks are
    some of the plays, and are executed against the `db-servers` only. During playbook
    execution, you can decide to run all of the plays in the file, only a specific
    play, or tasks with specific tags, regardless of which play they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our first playbook, to get the look and feel of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple playbook, with a single `play` that contains two `tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `openssh-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `sshd` service after installation, and make sure that it's available
    at the boot time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to apply this to a specific host (or a group of hosts). So, we
    set the `hosts` to be `CentOS-servers`, defined previously in the inventory file,
    and we also set the `remote_user` to be the root, to ensure that the tasks after
    it will be executed with root permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The tasks will consist of the names and the Ansible modules. The name is used
    to describe the task. It's not mandatory to provide names for your tasks, but
    it's recommended, in case you need to start the execution from a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the Ansible module, which is mandatory. In our example, we
    used the core module `yum` to install the `openssh-server` package onto the target
    servers. The second task has the same structure, but this time, we will use another
    core module, called `service`, to start and enable the `sshd` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: A final note is to watch the indentation for different components inside of
    Ansible. For example, the names of the tasks should be on the same level, while
    the `tasks` should align with the `hosts` on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the playbook in our automation server and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the playbook is executed on `centos-machine01`, and the tasks
    are executed sequentially, as defined in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: YAML requires that you preserve the indentation level and don't mix between
    the tabs and spaces; otherwise, it will give an error. Many text editors and IDEs
    will convert the tab to a set of white spaces. An example of that option is shown
    in the following screenshot, in the notepad++ editor preferences:![](../images/00167.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ansible conditions, handlers, and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the chapter, we will look at some of the advanced features in
    the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Designing conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible playbook can execute tasks (or skip them) based on the results of
    specific conditions inside the task—for example, when you want to install packages
    on a specific family of operating systems (Debian or CentOS), or when the operating
    system is a particular version, or even when the remote hosts are virtual, not
    bare metal. This can be done by using the `when` clause inside of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Let's enhance the previous playbook and limit the `openssh-server` installation
    to only CentOS based systems, so that it does not give an error when it hits an
    Ubuntu server that uses the `apt` module, not `yum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the following two sections to our `inventory` file, to group
    the CentOS and Ubuntu machines in the `infra` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will redesign the tasks inside of the playbook to have the `when`
    clause, which limits task execution to only CentOS based machines. This should
    read as `if the remote machine is CentOS based, then I will execute the task;
    otherwise, skip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the playbook first gathers the facts about the remote machines (we
    will discuss that later in this chapter), and then checks the operating system.
    The task will be skipped when it hits an `ubuntu-machine01`, and it will run normally
    on the CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also have multiple conditions that need to be true in order to run
    the task. For example, you can have the following playbook, which validates two
    things—first, that the machine is based on Debian, and second, that it is a virtual
    machine, not a baremetal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this playbook will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible `when` clause also accepts expressions. For example, you can check
    whether a specific keyword exists in the returned output (that you saved using
    the register flag), and, based on that, execute the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following playbook will validate the OSPF neighbor status. The first task
    will execute `show ip ospf neighbor` on the routers and register the output in
    a variable called `neighbors`. The next task will check for `EXSTART` or `EXCHANGE`
    in the returned output; if found, it will print a message back to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can check the facts commonly used in the `when` clause at [http://docs.Ansible.com/Ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts](http://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts).
  prefs: []
  type: TYPE_NORMAL
- en: Creating loops in ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides many ways to repeat the same task inside a play, but with
    a different value each time. For example, when you want to install multiple packages
    on a server, you don''t need to create a task for each package. Rather, you can
    create a task that installs a package and provides a list of package names to
    the task, and Ansible will iterate over them until it finishes the installation.
    To accomplish this, we will need the `with_items` flag inside of the task that
    contains a list, and the variable `{{ item }}`, which serves as a placeholder
    for the items in the list. The playbook will leverage the `with_items` flag to
    iterate over a set of packages and provide them to the `yum` module, which requires
    the name and state of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can hardcode the value of the state to be `present`; in that case, all of
    the packages will be installed. However, in the previous case, `with_items` will
    provide the two elements to the `yum` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook''s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Trigger tasks with handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay; you have installed and removed a series of packages in your system. You
    have copied files to/from your server. And you have changed many things in the
    server by using an Ansible playbook. Now, you need to restart a few other services,
    or add some lines to the files, to complete the configuration of the service.
    So, you should add a new task, right? Yes, that's correct. However, Ansible provides
    another great option, called **handlers**, which will not automatically execute
    when it hits (unlike tasks), but will rather be executed only when it is called.
    This provides you with the flexibility to call them upon the execution of tasks
    inside the play.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers have the same alignment as the hosts and tasks, and are located at
    the bottom of each play. When you need to call a handler, you use the `notify`
    flag inside of the original task, to determine which handler will be executed;
    Ansible will link them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will write a playbook that installs and configures
    the KVM on the CentOS servers. The KVM requires a few changes after installation,
    such as loading the `sysctl`, enabling the `kvm` and `802.1q` modules, and loading
    the `kvm` at `boot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice the usage of `notify` after the installation task. When the task runs,
    it will notify three handlers in sequence, so that they will execute. The handlers
    will run after the task has successfully executed. That means that if the task
    has failed to run (for example, the `kvm` package was not found, or there's no
    internet connection to download it), there will be no changes to your system,
    and `kvm` will not be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Another awesome feature of the handler is that it's only run when there's a
    change in the task. For example, if you rerun the task, Ansible won't install
    the `kvm` package since it's already installed; it won't call any handlers, as
    it doesn't detect any changes in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a final note about two modules: `lineinfile` and `command`. The
    first module is actually inserting or deleting lines from configuration files
    by using regular expressions; we used it in order to insert the `kvm` into `/etc/modules`,
    to automatically boot the KVM when the machine starts. The second module, `command`,
    is used to execute a shell command directly on the device and return the output
    to the Ansible host.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ansible facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is not only used to deploy and configure remote hosts. It can be used
    to gather all kinds of information and facts about them. The facts collection
    can take significant amount of time to collect everything from a busy system,
    but will provide a full view of the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The facts that are gathered can be used inside the playbook later, to design
    a task condition. For example, we used the `when` clause to limit the `openssh`
    installation to only CentOS-based systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable/disable fact gathering in the Ansible plays by configuring `gather_facts`
    on the same level as hosts and tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to gather facts and print them in Ansible is to use the `setup`
    module in the ad hoc mode. The returned results are in the form of nested dictionaries
    and lists, to describe the remote target facts, such as the server architecture,
    memory, networking settings, OS version, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can get to a specific value from the facts by using either a dot notation
    or square brackets. For example, to get the IPv4 address for `eth0`, you can use
    either  `Ansible_eth0["ipv4"]["address"]` or `Ansible_eth0.ipv4.address`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Ansible template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last piece of working with Ansible is understanding how it handles the template.
    Ansible uses the Jinja2 template, which we discussed in [Chapter 6](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f),
    *Configuration Generator with Python and Jinja2*. It fills the parameters with
    either Ansible facts or the static values provided in the `vars` section, or even
    with the result of a task stored using the `register` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will build an Ansible playbook that gathers the
    previous three cases. First, we define a variable called `Header` in the `vars`
    section, holding a welcome message as a static value. Then, we enable the `gather_facts`
    flag, to get all possible information from the target machine. Finally, we execute
    the `date` command, to get the current date in the server and store the output
    in the `date_now` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The template module that was used in the preceding playbook will accept a Jinja2
    file named `index.j2`, located in the same directory of the playbook; it will
    then provide all of the values for the jinj2 variables from the three sources
    we discussed previously. Then, the rendered file will be stored in a path provided
    by the `dest` option, inside the template module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `index.j2` will be as follows. It will be a simple HTML page
    that leverages the jinja2 language to generate a final HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this playbook will result in installing the nginx web server on the
    CentOS machine, and adding an `index.html` page to it. You can access the page
    by using the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00170.gif)'
  prefs: []
  type: TYPE_IMG
- en: You can also utilize the template module to generate network device configurations.
    The jinja2 templates used in [Chapter 6](https://cdp.packtpub.com/hands_on_enterprise_automation_with_python/wp-admin/post.php?post=322&action=edit#post_33), *Configuration
    Generator with Python and Jinja2,* which generated the `day0` and `day1` configurations
    for the router, can be reused inside of the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a very powerful tool, used to automate IT infrastructure. It contains
    many modules and libraries that cover almost everything in system and network
    automation, making software deployment, package management, and configuration
    management very easy. While Ansible can execute a single module in ad hoc mode,
    the real power of Ansible is in writing and developing playbooks.
  prefs: []
  type: TYPE_NORMAL
