- en: Chapter 7. Network Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network scalability is concerned with structuring an application in such a way
    that as more demands are placed on the application, it can adjust to handle the
    stress. Demands can come in the form of more users, an increased number of requests,
    more complicated requests, and changes in network characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several areas of concern listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Server capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network bandwidth and latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability can be achieved by adding more servers, using an appropriate number
    of threads, improving the performance of the execution environment, and increasing
    the network bandwidth to eliminate bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more servers will help by enabling load balancing between servers. However,
    if the network bandwidth or latency is the issue, then this will not help much.
    There is only so much that can be pushed through a network pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are frequently used to improve the performance of a system. Using an
    appropriate number of threads for a system allows some threads to execute while
    other threads are blocked. A blocked thread may be waiting for IO to occur or
    for a user to respond. Allowing other threads to execute while some are blocked
    can increase application throughput.
  prefs: []
  type: TYPE_NORMAL
- en: The execution environment includes the underlying hardware, the operating system,
    the JVM, and the application itself. Each of these areas is a candidate for improvement.
    We will not address the hardware environment as that is beyond our control. The
    same is true of the operating system. While some performance improvements can
    be achieved, we will not address these areas. JVM parameters that can affect network
    performance will be identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine code improvement opportunities. Most of our discussion is concerned
    with the use of threads because we have more control over this architectural feature.
    We will illustrate several approaches to improve the scalability of an application
    in this chapter. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threaded server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures and callables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selector (TCP/UDP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore the details of using simple threads/pools because you may encounter
    them in your work and may not be able to use some of the newer technologies due
    to platform limitations. Thread pools offer the advantage of reusing threads in
    many situations. Futures and callables are a thread variation where data can be
    passed and returned from a thread. Selector allows multiple channels to be handled
    by a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded server overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chief advantage of a multithreaded server is that long-running client requests
    will not block the server from accepting other client requests. If a new thread
    is not created, then the current request will be processed. It is only after the
    request has been processed that new requests can be accepted. Using a separate
    thread for a request means that connections and their associated requests can
    be processed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a multithreaded server, there are several of ways of configuring
    the threads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread-per-request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread-per-connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread-per-object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the thread-per-request model, each request that arrives at the server is
    assigned a new thread. While this is a simple approach, it can result in the creation
    of a large number of threads. In addition, each request will often mean that a
    new connection will be created.
  prefs: []
  type: TYPE_NORMAL
- en: This model works nicely in an environment where the previous client request
    does not need to be retained. For example, if the server's sole purpose is to
    respond to a request for a specific stock quote, then a thread does not need to
    be aware of any previous requests.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is illustrated in the following figure. Each client request sent
    to the server is assigned to a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multithreaded server overview](img/B04915_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the thread-per-connection model, a client connection is maintained for the
    duration of the session. A session consists of a series of requests and responses.
    A session is terminated either through a specific command or after a time-out
    period has elapsed. This approach allows state information to be maintained between
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is illustrated in the following figure. The dash line indicates
    that multiple requests from the same client are handled by the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multithreaded server overview](img/B04915_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The thread-per-object approach queues associated requests with a specific object
    that can handle the request. The object and its methods are placed in a thread
    that handles requests one at a time. Requests are queued with the thread. While
    we will not demonstrate this approach here, it is often used with thread pools.
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating and deleting connections can be expensive. If a client
    submits several requests, then opening and closing a connection becomes expensive
    and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the problem of too many threads, a pool of threads is frequently used.
    When a request needs to be processed, the request is assigned to an existing unused
    thread to handle the request. Once the response has been sent, then the thread
    can be used for other requests. This assumes that state information does not need
    to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-request approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Network Programming"),
    *Getting Started with Network Programming*, we illustrated a simple multithreaded
    echo server. This approach is reintroduced here to provide a foundation for the
    use of threads in the remainder of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-request server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, the server will accept requests for prices when given the name
    of a part. The implementation will use the `ConcurrentHashMap` class that supports
    concurrent access to the part name and price. In a multithreaded environment,
    concurrent data structures, such as the `ConcurrentHashMap` class, handle operations
    without the potential for data corruption. Also, this map is an example of caching,
    which can be useful in improving the performance of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the declaration of the server as follows. The map is declared
    as static because only one instance is needed for the server. The static initialization
    block initializes the map. The `main` method will use the `ServerSocket` class
    to accept requests from a client. They will be handled in the `run` method. The
    `clientSocket` variable will hold a reference to the client socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method follows where the server socket waits for a client request
    and then creates a new thread, passing the client socket to the thread to process
    it. Messages are displayed showing the connection being accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` method processes the request, as shown next. An input stream is obtained
    from the client socket, and the part name is read. The map''s `get` method uses
    this name to retrieve a price. An input stream sends the price back to the client,
    and the progress of the operation is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's develop a client for the server.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-request client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client application, as shown next, will connect to the server, send a request,
    wait for a response, and then display the price. For this example, the client
    and the server reside on the same machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how the client and the server interact.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-request applications in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server first, which will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-Threaded Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client application. The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axle request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 238.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will then display the following output. You will note that the **Client
    Thread Started** output follows the **Listening for a client connection** output.
    This is because there is a slight delay before the thread starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: The client thread started, processed the request, and then terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the client application just before the close operation
    to send a second price request to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the client is executed, you will get the following output. The response
    for the second string is null. This is because the server''s response thread has
    terminated after the first request was answered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axle request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 238.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wheel request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle multiple requests using this approach, you will need to reopen the
    connection and send out separate requests. The following code illustrates this
    approach. Remove the code segment that sent the second request. Add the following
    code to the client after the socket is closed. In this sequence, the socket is
    reopened, the IO streams are recreated, and the message is re-sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the client is executed, it will produce the following output, which reflects
    the two requests and their response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axle request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 238.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wheel request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 86.3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, we will get the following output. Two threads were created
    to handle the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-Threaded Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Wheel and returned a price of $86.30**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: The opening and closing of the connections can be expensive. In the next section,
    we will address this type of problem. However, if only single requests are made,
    then the thread-per-request will work.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-per-connection approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this approach, a single thread is used to handle all of the client's requests.
    This approach will require that the client send some sort of notification that
    it has no further requests. In lieu of an explicit notification, a timeout may
    need to be set to automatically disconnect the client after a sufficient period
    of time has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-connection server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the server''s `run` method by commenting out the bulk of the try block
    where the request is handled and the response is sent to the client. Replace it
    with the following code. In the infinite loop, the command request is read. If
    the request is `quit`, then the loop is exited. Otherwise, the request is handled
    in the same way as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is all that needs to be modified in the server.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-connection client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the client, replace the code after the buffered reader has been created
    with the following code. This will send three requests to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Only a single connection is opened for all three requests.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-connection applications in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the client is executed, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axle request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 238.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wheel request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 86.3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, the following output is generated. You will note that only
    one thread was created to handle the multiple requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-Threaded Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Wheel and returned a price of $86.30**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a more efficient architecture for when a client makes multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thread pools are useful when the number of threads that are created need to
    be limited. Using a pool not only controls how many threads are created, but it
    can also eliminate the need to create and destroy threads repeatedly, an often
    expensive operation.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts a thread pool. Requests are assigned to threads
    in the pool. Some thread pools will create new threads if there are no unused
    threads available. Others will restrict the number of threads available. This
    may result in some requests being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Thread pools](img/B04915_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will demonstrate thread pools using the `ThreadPoolExecutor` class. This
    class also provides methods that deliver status information regarding thread execution.
  prefs: []
  type: TYPE_NORMAL
- en: While the `ThreadPoolExecutor` class possesses several constructors, the `Executors`
    class provides an easy way of creating instances of the `ThreadPoolExecutor` class.
    We will demonstrate two of these methods. First, we will use the `newCachedThreadPool`
    method. The pool created by this method will reuse threads. New threads will be
    created when needed. However, this can result in too many threads being created.
    The second method, `newFixedThreadPool`, creates a fixed-size pool of threads.
  prefs: []
  type: TYPE_NORMAL
- en: The ThreadPoolExecutor class characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an instance of this class is created, it will accept new tasks, which are
    passed to the thread pool. However, the pool will not close down automatically.
    If idle, it will wait until new tasks are submitted. To terminate the pool, either
    the `shutdown` or `shutdownNow` method needs to be called. The latter method shuts
    down the pool immediately and will not process pending tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThreadPoolExecutor` class has a number of methods that provides additional
    information. For example, the `getPoolSize` method returns the current number
    of threads in the pool. The `getActiveCount` method returns the number of active
    threads. The `getLargestPoolSize` method returns the maximum number of threads
    that were in the pool at one time. There are several other methods that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Simple thread pool server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server that we will use to demonstrate a thread pool will return a price
    of a part when given the name of a part. Each thread will access a `ConcurrentHashMap`
    instance that holds the part information. We use the concurrent version of the
    hash map as it may be accessed from multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThreadPool` class is declared next. The `main` method uses a `WorkerThread`
    class to perform the actual work. In the `main` method, the `newCachedThreadPool`
    method is called to create a thread pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a try block is used to catch and handle any exceptions that may occur.
    Within the try block, a server socket is created and its `accept` method blocks
    until a client connection is requested. When a connection is established, a `WorkerThread`
    instance is created using the client socket, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine the `WorkerThread` class that is shown next. The `ConcurrentHashMap`
    instance is declared where a string is used as the key and the object that is
    stored is a float. The hash map is initialized in a static initializer block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The class''s constructor assigns the client socket to the `clientSocket` instance
    variable for later use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` method processes the request. An input stream is obtained from the
    client socket and used to get the part name. This name is used as the argument
    of the hash map''s `get` method to obtain the corresponding price. This price
    is sent back to the client, and a message is displayed showing the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to discuss the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Simple thread pool client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application uses the `Socket` class to establish a connection to the server.
    Input and output streams are used to send and receive responses. This approach
    was discussed in [Chapter 1](ch01.html "Chapter 1. Getting Started with Network
    Programming"), *Getting Started with Network Programming*. The client application
    follows. A connection is established with the server and a request for a part's
    price is sent to the server. The response is obtained and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to see how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: The thread pool client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server application first. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread Pool Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client. It will produce the following output where a request
    for an axle price is sent, and then a response of `238.5` is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axle request sent**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response: 238.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, you will see output similar to the following one. The thread
    is created, and the request and response data is displayed. The thread then terminates.
    You will note that the name of the thread is preceded by the string "packt". This
    is the name of the package for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task created: packt.WorkerThread@33909752**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start a second client, the server will produce output similar to the
    following one. You will note that a new thread is created for each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread Pool Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task created: packt.WorkerThread@33909752**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to a Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task created: packt.WorkerThread@3d4eac69**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening for a client connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request for Axle and returned a price of $238.50**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Connection** **Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker Thread Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: Thread pool with Callable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `Callable` and `Future` interfaces provides another approach to support
    multiple threads. The `Callable` interface supports threading where a thread needs
    to return a result. The `Runnable` interface's `run` method does not return a
    value. For some threads, this can be a problem. The `Callable` interface possesses
    a single method, `call`, which returns a value and can be used instead of the
    `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` interface is used in combination with a `Callable` object. The
    idea is that the `call` method is invoked and the current thread continues performing
    some other task. When the `Callable` object is complete, then a `get` method is
    used to retrieve the results. This method will block if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Callable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the `Callable` interface to supplement the `WorkerThread` class
    that we created earlier. Instead of placing the part name hash map in the `WorkerThread`
    class, we will move it to a class called `WorkerCallable` where we will override
    the `call` method to return the price. This is actually extra work for this application,
    but it illustrates one way of using the `Callable` interface. It demonstrates
    how we can return a value from the `Callable` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkerCallable` class, that is declared next, uses the same code to create
    and initialize the hash map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will initialize the part name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `call` method is shown next. The map obtains the price, which we display
    and then return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `WorkerThread` class by removing the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following code. A new `WorkerCallable` instance is created
    using the part name that was requested by a client. The `call` method is immediately
    invoked and will return the corresponding part''s price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The application will produce the same output as before, except that you will
    see messages indicating that the `WorkerCallable` class's `call` method was executed.
    While another thread is created, we will block until the `call` method returns.
  prefs: []
  type: TYPE_NORMAL
- en: This example does not fully demonstrate the power of this approach. The `Future`
    interface will improve on this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Future
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Future` interface represents the results of a completed `call` method.
    With this interface, we can invoke a `Callable` object and not wait for it to
    return. Assume that the process of computing a part price is more involved than
    just looking it up in a table. It is conceivable that multiple steps may be required
    to calculate a price, each of which may be involved and may take a bit of time
    to complete. Also assume that these separate steps can be performed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the previous example with the following code. We create a new `ThreadPoolExecutor`
    instance to which we will assign two `Callable` objects representing a two-step
    price determination process. This is done using the `submit` method, which returns
    a `Future` instance. The implementation of the `call` methods returns `1.0` and
    `2.0` respectively to keep the example simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following try block, which uses the `get` method to obtain the
    two parts of the price. These are used to determine the price for the part. If
    the corresponding `Callable` object has not completed, then the `get` method will
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When this code is executed, you will get a price of 3.0 for the parts. The combination
    of the `Callable` and `Future` interfaces provides an easy to use this technique
    to handle threads that return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HttpServer executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the `HTTPServer` class in [Chapter 4](ch04.html "Chapter 4. Client/Server
    Development"), *Client/Server Development*. When the HTTP Server receives a request,
    by default, it uses the thread that was created when the `start` method is called.
    However, it is possible to use a different thread. The `setExecutor` method specifies
    how these requests are assigned to threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument of this method is an `Executor` object. We can use any of several
    implementations for this argument. In the following sequence, a cached thread
    pool is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the number of threads that are used by the server, we can use a
    fixed thread pool of size `5`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This method must be called before the `start` method of `HTTPServer` is called.
    All requests are then submitted to the executor. The following is duplicated from
    the `HTTPServer` class that was developed in [Chapter 4](ch04.html "Chapter 4. Client/Server
    Development"), *Client/Server Development*, and shows you the use of the `setExecutor`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The server will execute the same way as it did before, but it will use a cached
    thread pool instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using a selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A selector is used in an NIO application and allows one thread to handle multiple
    channels. The selector coordinates multiple channels and their events. It identifies
    those channels that are ready for processing. If we were to use a thread per channel,
    then we will find ourselves switching between threads frequently. This switching
    process can be expensive. Using a single thread to handle multiple channels avoids
    some of this overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts this architecture. A thread is registered with
    a selector. The selector will identify the channels and events that are ready
    for processing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a selector](img/B04915_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A selector is supported by two primary classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector`: This provides the primary functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey`: This identifies the types of events that are ready for processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use a selector, perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register channels with the selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a channel for use when it becomes available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine each of these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no public `Selector` constructors. To create a `Selector` object,
    use the static `open` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is also an `isOpen` method to determine if a selector is open and a `close`
    method to close it when it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `register` method registers a channel with a selector. Any channel that
    is registered with a selector must be in a nonblocking mode. For example, a `FileChannel`
    object cannot be registered because it cannot be placed in a nonblocking mode.
    Use the `configureBlocking` method with `false` as its argument to place the channel
    in a nonblocking mode, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `register` method is as follows. This is a method of the `ServerSocketChannel`
    and SocketChannel classes. In the following example, it is used with a `SocketChannel`
    `instance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Channel` class''s `register` method possesses three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The selector to register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event type of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data to be associated with the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event type specifies the type of channel events that an application is interested
    in handling. For example, we may only want to be informed of an event if the channel
    has data that is ready to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four event types that are available, as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Event type constants | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Connect | `SelectionKey.OP_CONNECT` | This indicates that the channel has
    successfully connected to a server |'
  prefs: []
  type: TYPE_TB
- en: '| Accept | `SelectionKey.OP_ACCEPT` | This indicates that a server socket channel
    is ready to accept connection requests from a client |'
  prefs: []
  type: TYPE_TB
- en: '| Read | `SelectionKey.OP_READ` | This indicates that the channel has data
    ready to be read |'
  prefs: []
  type: TYPE_TB
- en: '| Write | `SelectionKey.OP_WRITE` | This indicates that the channel is ready
    for write operations |'
  prefs: []
  type: TYPE_TB
- en: 'These types are referred to as interest sets. In the following statement, the
    channel is associated with the read interest type. The method returns a `SelectionKey`
    instance, which contains a number of useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are multiple events of interest, then we can create a combination
    of these using the OR operator as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SelectionKey` class possesses several properties that will help in working
    with channels. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interest set**: This contains the events of interest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready set**: This is the set of operations that the channel is ready to handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: The `channel` method returns the channel that is associated with
    a selection key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector**: The `selector` method returns the selector that is associated
    with the selection key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attached objects**: Further information can be attached using the `attach`
    method. The `attachment` method is used later to access this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `interestOps` method returns an integer representing the events of interest,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will use this to process the events.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which events are ready, we can use any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`readOps`: This returns an integer containing the ready events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAcceptable`: This indicates that the accept event is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isConnectable`: This indicates that the connection event is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReadable`: This indicates that the read event is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isWritable`: This indicates that the write event is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see these methods in action.
  prefs: []
  type: TYPE_NORMAL
- en: Using the selector to support a time client/server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a time server to illustrate the use of the `Selector` class
    and related classes. This server and the time client are adapted from the time
    server and client applications that were in [Chapter 3](ch03.html "Chapter 3. NIO
    Support for Networking"), *NIO Support for Networking*. The focus here will be
    on the use of the selector. The channel and buffer operations will not be discussed
    here as they were covered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The channel time server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time server will accept connections to client applications and send the
    current date and time to the clients every second. A client may not receive all
    of these messages as we will discover when we discuss the client.
  prefs: []
  type: TYPE_NORMAL
- en: The time server uses an internal static class, `SelectorHandler`, to handle
    the selector and send messages. This class implements the `Runnable` interface
    and will be the selector's thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` method, the server socket accepts new channel connections and
    registers them with the selector. The `Selector` object is declared as a static
    instance variable, as shown next. This allows it to be accessed from the `SelectorHandler`
    thread and the main application thread. Sharing this object will result in potential
    synchronization problems, which we will address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the `main` method. A server socket channel is created that
    uses port `5000`. Exceptions are caught in a try block, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The selector is created, and a thread for the `SelectorHandler` instance is
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An infinite loop will accept new connections. A message is displayed indicating
    that a connection has been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With a good channel, the `configureBlocking` method is called, the selector
    is woken up, and the channel is registered with the selector. A thread may be
    blocked by the `select` method. Using the `wakeup` method will cause the `select`
    method to immediately return, which allows the `register` method to unblock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once a channel has been registered with a selector, we can start processing
    events that are associated with that channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SelectorHandler` class will use the selector object to identify events
    as they occur and associate them with specific channels. Its `run` method does
    all of the work. As shown next, an infinite loop uses the `select` method to identify
    events as they occur. The `select` method uses an argument of `500`, which specifies
    a timeout of 500 milliseconds. It returns an integer specifying how many keys
    are ready to be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `select` method times out, it will return a value of `0`. When this
    happens, we display a message to that effect, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are keys ready, then the `selectedKeys` method will return this set.
    An iterator is then used to process each key one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `SelectionKey` instance is checked to see which event type has occurred.
    In the following implementation, only the writeable events are processed. After
    processing, the thread sleeps for one second. This will have the effect of delaying
    the sending of a date and time message by at least one second. The `remove` method
    is needed to remove an event for the iterator list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a writeable event, then the date and time is sent, as shown next.
    The `channel` method returns the channel for the event, and the message is sent
    to that client. A message is displayed showing that the message has been sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With the server ready, we will develop our client application.
  prefs: []
  type: TYPE_NORMAL
- en: The date and time client application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client application is almost identical to the one that was developed in
    [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"), *NIO Support for
    Networking*. The main difference is that it will request the data and time at
    random intervals. This effect will be seen when we use multiple clients with our
    server. The application''s implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to see how the server and client work together.
  prefs: []
  type: TYPE_NORMAL
- en: The date and time server/client in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, start the server. It will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Server started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**About to select ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No tasks available**'
  prefs: []
  type: TYPE_NORMAL
- en: '**About to select ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No tasks available**'
  prefs: []
  type: TYPE_NORMAL
- en: '**About to select ...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No tasks available**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence will repeat itself until a client connects to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start up the client. On the client side, you will get output similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date: Wed Oct 07 17:55:43 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date: Wed Oct 07 17:55:45 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date: Wed Oct 07 17:55:47 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date: Wed Oct 07 17:55:49 CDT 2015**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, you will see output reflecting the connection and then
    the requests, as shown next. You will note that the port number, `58907`, identifies
    this client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Date: Wed Oct 07 17:55:43 CDT 2015 to: java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: Date: Wed Oct 07 17:55:45 CDT 2015 to: java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up a second client. You will see a similar connection message but with
    a different port number. One possible connection message that follows is showing
    a client with port number `58908`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket channel accepted - java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1:58908]**'
  prefs: []
  type: TYPE_NORMAL
- en: You will then see date and time messages being sent to both clients.
  prefs: []
  type: TYPE_NORMAL
- en: Handling network timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is deployed in the real world, new network problems can
    occur that were not present when this application was developed on a LAN. Problems,
    such as network congestion, slow connections, and the loss of a network link can
    result in delays or loss of messages. It is important to detect and handle network
    timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: There are several socket options which provide some control over socket communications.
    The `SO_TIMEOUT` option is used to set a timeout for read operations. If the specified
    amount of time elapses, then a `SocketTimeoutException` exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following statement, the socket will expire after three seconds have
    elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The option must be set before a blocking read operation occurs. A timeout of
    zero will never time out. Handling timeouts is an important design consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined several approaches to address the scalability of
    applications. Scalability refers to the ability of an application to compensate
    for increased loads placed on it. While our examples focused on applying these
    techniques to servers, they are equally applicable to clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduced three threading architectures, and we focused on two of them:
    thread-per-request and thread-per-connection. The thread-per-request model creates
    a new thread for each request that arrives at a server. This is suitable for situations
    where a client will make a single or possibly a few requests at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: The thread-per-connection model will create a thread to handle multiple requests
    from a client. This avoids having to reconnect to the client multiple times and
    having to incur the cost of multiple thread creations. This approach is good for
    clients who need to maintain a session and possibly state information.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pools support an approach that avoids creating and destroying threads.
    A collection of threads is managed by a thread pool. Threads that are not being
    used can be repurposed for a different request. The size of thread pools can be
    controlled and, thus limited depending on the requirements of the application
    and the environment. The `Executor` class was used to create and manage thread
    pools.
  prefs: []
  type: TYPE_NORMAL
- en: The NIO's `Selector` class was illustrated. This class makes it easier to work
    with threads and NIO channels. Channels and channel-related events are registered
    with a selector. When an event, such as a channel becoming available for a read
    operation, occurs, the selector provides access to the channel and the event.
    This allows a single thread to manage several channels.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly re-examined the `HttpServer` class that was introduced in [Chapter
    4](ch04.html "Chapter 4. Client/Server Development"), *Client/Server Development*.
    We demonstrated how easy it is to add a thread pool to improve the server's performance.
    We also examined the nature of network timeouts and how to handle them. These
    can occur when the network fails to support timely communication between applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore network security threats and how we can
    address them.
  prefs: []
  type: TYPE_NORMAL
