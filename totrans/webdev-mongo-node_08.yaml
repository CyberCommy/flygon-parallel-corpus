- en: Creating a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your application is complete and ready for the world to see, you can
    start thinking of ways to make it more popular. What if you want to allow external
    systems access rights to your data in a way such that they can mass produce inserts
    to your website without the need for users to visit the actual website?
  prefs: []
  type: TYPE_NORMAL
- en: One example that comes to mind almost immediately is how users of another website,
    say [www.facebook.com](http://www.facebook.com), could upload an image to Facebook
    and have it automatically uploaded to your website as well.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to make a scenario like this possible is **by** providing an API
    to your data and the code that gives external developers access to a suite of
    tools that will allow them to perform actions without the need to interact with
    the actual web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will review the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a few basic tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic API server and sample JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to `GET` requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data with `POST` and `PUT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing data with `DELETE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming external APIs from Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) is a set of tools that a
    system makes available so that unrelated systems or software have the ability
    to interact with each other. Typically, a developer uses an API when writing software
    that will interact with a closed, external software system. The external software
    system provides an API as a standard set of tools that all developers can use.
    Many popular social networking sites provide developers access to APIs to build
    tools to support those sites. The most obvious examples are Facebook and Twitter.
    Both have a robust API that provides developers with the ability to build plugins
    and work with data directly, without them being granted full access, as a general
    security precaution.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see with this chapter, providing your own API is not only fairly
    simple, but it also empowers you to provide your users with access to your data.
    You also have the added peace of mind of knowing that you are in complete control
    over what level of access you can grant, what sets of data you can make read-only,
    and what data can be inserted and updated.
  prefs: []
  type: TYPE_NORMAL
- en: What is a RESTful API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is a fancy way of saying CRUD
    over HTTP. What this means is, when you use a REST API, you have a uniform means
    to create, read, and update data using simple HTTP URLs with a standard set of
    HTTP verbs. The most basic form of a REST API will accept one of the HTTP verbs
    at a URL and return some kind of data as a response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a REST API `GET` request will always return some kind of data, such
    as JSON, XML, HTML, or plain text. A `POST` or `PUT` request to a RESTful API
    URL will accept data to create or update. The URL for a RESTful API is known as
    an endpoint, and when working with these endpoints, it is typically said that
    you are consuming them. The standard HTTP verbs used while interfacing with REST
    APIs include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This retrieves data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This submits data for a new record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This submits data to update an existing record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This submits a date to update only specific parts of an existing record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This deletes a specific record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, RESTful API endpoints are defined in a way such that they mimic the
    data models and have semantic URLs that are somewhat representative of the data
    models. What this means is that to request a list of models, for example, you
    would access an API endpoint of `/models`. Likewise, to retrieve a specific model
    by its ID, you would include that in the endpoint URL via `/models/:Id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample RESTful API endpoint URLs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://myapi.com/v1/accounts`: This returns a list of accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://myapi.com/v1/accounts/1`: This returns a single account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'by `Id: 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST http://myapi.com/v1/accounts`: This creates a new account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (data submitted as a part of the request)
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT http://myapi.com/v1/accounts/1`: This updates an existing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'account by `Id: 1` (data submitted as part of the request)'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://myapi.com/v1/accounts/1/orders`: This returns a list of orders
    for account `Id: 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://myapi.com/v1/accounts/1/orders/21345`: This returns the details
    for a single order by `Order Id: 21345` for account `Id: 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not a requirement that the URL endpoints match this pattern; it's just
    common convention.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Postman REST Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, there are a few tools that will make life much easier
    when you're working directly with APIs. The first of these tools is called Postman
    REST Client, and it's a Google Chrome application that can run right in your browser
    or as a standalone, packaged application. Using this tool, you can easily make
    any kind of request to any endpoint you want. The tool provides many useful and
    powerful features that are very easy to use, and best of all, free!
  prefs: []
  type: TYPE_NORMAL
- en: Installation instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postman REST Client can be installed in two different ways, but both require
    Google Chrome to be installed and running on your system. The easiest way to install
    the application is by visiting the chrome web store at [https://chrome.google.com/webstore/category/apps](https://chrome.google.com/webstore/category/apps).
  prefs: []
  type: TYPE_NORMAL
- en: Perform a search for Postman REST Client, and multiple results will be returned.
    There is the regular Postman REST Client that runs as an application built into
    your browser, and then a separate Postman REST Client (packaged app) that runs
    as a standalone application on your system in its own dedicated window. Go ahead
    and install your preference. If you install the application as the standalone
    packaged app, an icon to launch it will be added to your dock or task bar. If
    you install it as a regular browser app, you can launch it by opening a new tab
    in Google Chrome, going to Apps, and finding the Postman REST Client icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve installed and launched the app, you should be presented with
    an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e209a66f-205d-4b6f-9152-451bac3c6017.png)'
  prefs: []
  type: TYPE_IMG
- en: A quick tour of Postman REST Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Postman REST Client, we're able to submit REST API calls to any endpoint
    we want, as well as modify the type of request. Then, we can have complete access
    to the data that's returned from the API, as well as any errors that might have
    occurred. To test an API call, enter the URL to your favorite website in the Enter
    request URL here field and leave the dropdown next to it as `GET`. This will mimic
    a standard `GET` request that your browser performs anytime you visit a website.
    Click on the blue Send button. The request is made and the response is displayed
    at the bottom half of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, I sent a simple `GET` request to [http://kroltech.com](http://kroltech.com)
    and the HTML was returned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/031838ab-08cc-417a-953b-2e7e02b08ead.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we change this URL to that of the RSS feed URL for my website, you can see
    the XML returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a46abbf-4451-4c57-88c8-da53ae7b65ac.png)'
  prefs: []
  type: TYPE_IMG
- en: The XML view has a few more features, as it exposes the sidebar to the right
    that gives you a glimpse at the tree structure of the XML data. Not only that,
    but you can now see a history of the requests we've made so far along the left
    sidebar. This is great when we're performing more advanced `POST` or `PUT` requests
    and don't want to repeat the data setup for each request while testing an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample API endpoint that I submitted a `GET` request to that returns
    the JSON data in its response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73ef80fc-6eaa-45f2-a52d-d7113694ca57.png)'
  prefs: []
  type: TYPE_IMG
- en: A really nice thing about making API calls to endpoints that return JSON using
    Postman Client is that it parses and displays the JSON in a very nicely formatted
    way, and each node in the data is expandable and collapsible.
  prefs: []
  type: TYPE_NORMAL
- en: The app is very intuitive, so make sure you spend some time playing around and
    experimenting with different types of calls to different URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JSONView Chrome extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one other tool I want to talk to you about that (while extremely minor),
    is actually a really big deal. The `JSONView` Chrome extension is a very small
    plugin that will instantly convert any `JSONView` directly into a more usable
    JSON tree via the browser (exactly like in Postman Client). Here is an example
    of pointing to a URL that returns JSON from Chrome before `JSONView` is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cb7b1f-43fd-4a44-9381-869432df87ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is that same URL after `JSONView` has been installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb010a96-c449-4d0d-8ea3-fb00adeb656e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should install the `JSONView` Google Chrome extension the same way you
    installed Postman REST Client: access the Chrome Web Store and perform a search
    for `JSONView`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the tools to be able to easily work with and test API endpoints,
    let's take a look at writing your own and handling the different request types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a super basic Node.js server using Express that we''ll use to
    create our own API. Then, we can send tests to the API using Postman REST Client
    to see how it all works. In a new project workspace, first install the `npm` modules
    that we''re going to need in order to get our server up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `package.json` file for this project has been initialized and
    the modules installed, let''s create a basic server file to bootstrap an Express
    server. Create a file named `server.js` and insert the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of this should look familiar to you. In the `server.js` file, we are requiring
    the express, body-parser, and underscore modules. We're also requiring a file
    named `movies.json`, which we'll create next.
  prefs: []
  type: TYPE_NORMAL
- en: After our modules are required, we set up the standard configuration for an
    Express server with the minimum amount of configuration needed to support an API
    server. Notice that we didn't set up Handlebars as a view-rendering engine because
    we aren't going to be rendering any HTML with this server, just pure JSON responses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sample JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the sample `movies.json` file that will act as our temporary
    data store (even though the API we build for the purpose of demonstration won''t
    actually persist data beyond the app''s life cycle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a really simple JSON list of a few of my favorite movies. Feel
    free to populate it with whatever you like. Boot up the server to make sure you
    aren''t getting any errors (note that we haven''t set up any routes yet, so it
    won''t actually do anything if you try to load it via a browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Responding to GET requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a simple `GET` request support is fairly simple, and you''ve already
    seen this before in the app we built. Here is some sample code that responds to
    a `GET` request and returns a simple JavaScript object as JSON. Insert the following
    code in the `routes` section where we have the `// TO DO: Setup endpoints ...`
    comment waiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like how we set up `viewModel` in [Chapter 5](8bd15cd0-997d-46b5-89ce-aa2b001cd890.xhtml),
    *Templating with Handlebars*, we create a basic JavaScript object that we can
    then send directly as a JSON response using `res.json` instead of `res.render`.
    Let''s tweak the function a little bit and change it so that it responds to a
    `GET` request against the root URL (that is `/`) route and returns the JSON data
    from our `movies` file. Add this new route after the `/test` route added previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `res` (response) object in Express has a few different methods to send data
    back to the browser. Each of these ultimately falls back on the base `send` method,
    which includes `header` information, `statusCodes`, and so on. `res.json` and
    `res.jsonp` will automatically format JavaScript objects into JSON and then send
    them using `res.send`. `res.render` will render a template view as a string and
    then send it using `res.send` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that code in place, if we launch the `server.js` file, the server will
    be listening for a `GET` request to the `/` URL route and will respond with the
    JSON data of our movies collection. Let''s first test it out using the Postman
    REST Client tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4a24349-089d-4720-b0ab-4d714a59e095.png)'
  prefs: []
  type: TYPE_IMG
- en: '`GET` requests are nice, because we could have just as easily pulled that same
    URL via our browser and received the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d767d05b-f1aa-490f-a2ba-7e921f3e4c42.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we're going to use Postman for the remainder of our endpoint testing,
    as it's a little more difficult to send `POST` and `PUT` requests using a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data - POST and PUT requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to allow those using our API to insert or update data, we need
    to accept a request from a different HTTP verb. When inserting new data, the `POST`
    verb is the preferred method to accept data and know it's for an insert. Let's
    take a look at some code that accepts a `POST` request and data along with the
    request, inserts a record into our collection, and returns the updated JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following block of code after the route you added for `GET` previously
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in the `POST` function is check to make sure the required
    fields were submitted along with the actual request. Assuming our data checks
    out and all the required fields are accounted for (in our case, every field),
    we insert the entire `req.body` object into the array as is, using the array''s
    `push` function. If any of the required fields aren''t submitted with the request,
    we return a 500 error message instead. Let''s submit a `POST` request to the same
    endpoint this time using the Postman REST Client. (Don''t forget to make sure
    your API server is running with node `server.js`.):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edc4584d-4582-4d35-bd86-cae7b3268bb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we submitted a `POST` request with no data, so you can clearly see the
    500 error response that was returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daaa2ebd-7dfa-4776-abb6-b49a1d6e2571.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we provided the actual data using the `x-www-form-urlencoded` option
    in Postman and provided each of the name/value pairs with some new custom data.
    You can see from the results that the STATUS was 200, which is a success, and
    the updated JSON data was returned as a result. Reloading the main `GET` endpoint
    in a browser yields our original movies collection with the new one added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/232bb26a-3061-4a1b-9d5c-806a814d39b9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`PUT` requests will work in almost exactly the same way, except traditionally,
    the `Id` property of the data is handled a little differently. In our example,
    we are going to require the `Id` attribute as a part of the URL and not accept
    it as a parameter in the data that''s submitted (since it''s usually not common
    for an `update` function to change the actual `Id` of the object it''s updating).
    Insert the following code for the `PUT` route after the existing `POST` route
    you added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code again validates that the required fields are included with the data
    that was submitted along with the request. Then, it performs an `_.each` loop
    (using the `underscore` module) to look through the collection of movies and find
    the one whose `Id` parameter matches that of the `Id` included in the URL parameter.
    Assuming there''s a match, the individual fields for that corresponding object
    are updated with the new values that were sent with the request. Once the loop
    is complete, the updated JSON data is sent back as the response. Similarly, in
    the `POST` request, if any of the required fields are missing, a simple 500 error
    message is returned. The following screenshot demonstrates a successful `PUT`
    request updating an existing record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c7e516c-e684-49f3-b85b-6481333dca58.png)'
  prefs: []
  type: TYPE_IMG
- en: The response from Postman, after including the value `1` in the URL as the `Id`
    parameter, which provides the individual fields to update as `x-www-form-urlencoded`
    values, and finally sends as `PUT`, shows that the original item in our movies
    collection is now the original Alien (not Aliens, its sequel, as we originally
    had).
  prefs: []
  type: TYPE_NORMAL
- en: Removing data - DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final stop on our whirlwind tour of the different REST API HTTP verbs is
    `DELETE`. It should be no surprise that sending a `DELETE` request should do exactly
    what it sounds like. Let''s add another route that accepts `DELETE` requests and
    deletes an item from our movies collection. Here is the code that takes care of
    the `DELETE` requests, which should be placed after the existing block of code
    from the previous `PUT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will loop through the collection of movies and find a matching item
    by comparing the values of `Id`. If a match is found, the array `index` for the
    matched item is held until the loop is finished. Using the `array.splice` function,
    we can remove an array item at a specific index. Once the data has been updated
    by removing the requested item, the JSON data is returned. Notice that in the
    following screenshot the updated JSON that''s returned is in fact no longer displaying
    the original second item we deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d16f1ce3-2968-47fe-9bf2-b64f1256f94c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `~` use in JavaScript! That's a little bit of JavaScript black magic! The
    tilde (`~`) in JavaScript will bit flip a value. In other words, it will take
    a value and return the negative of that value incremented by one, that is `~n
    === -(n+1)`. Typically, the tilde is used with functions that return `-1` as a
    false response. By using `~` on `-1`, you are converting it to `0`. If you were
    to perform a Boolean check on `-1` in JavaScript, it would return `true`. You
    will see that `~` is primarily used with the `indexOf` function and `jQuery's
    $.inArray()`; both return `-1` as a `false` response.
  prefs: []
  type: TYPE_NORMAL
- en: All of the endpoints defined in this chapter are extremely rudimentary, and
    most of these should never see the light of day in a production environment! Whenever
    you have an API that accepts anything other than `GET` requests, you need to be
    sure to enforce extremely strict validation and authentication rules. After all,
    you are basically giving your users direct access to your data.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming external APIs from Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will undoubtedly be a time when you want to consume an API directly from
    within your Node.js code. Perhaps your own API endpoint needs to first fetch data
    from some other, unrelated third-party API before sending a response. Whatever
    the reason, the act of sending a request to an external API endpoint and receiving
    a response can be done fairly easily by using a popular and well-known `npm` module
    called `request`. The `request` module was written by Mikeal Rogers and is currently
    the third most popular (and most relied upon) `npm` module, after `async` and
    `underscore`.
  prefs: []
  type: TYPE_NORMAL
- en: Request is basically a super simple HTTP client, so everything you've been doing
    with Postman REST Client so far is basically what `Request` can do, only the resulting
    data is available to you in your Node code, as well as the response status codes
    and/or errors, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming an API endpoint using request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a neat trick and actually consume our own endpoint as if it was some
    third-party external API. First, we need to ensure we have `request` installed
    and can include it in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, edit `server.js` and make sure you include `request` as a required module
  prefs: []
  type: TYPE_NORMAL
- en: 'at the start of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add a new endpoint after our existing routes, which will be an endpoint
    accessible in our server via a `GET` request to `/external-api`. This endpoint,
    however, will actually consume another endpoint on another server, but for the
    purposes of this example, the other server is actually the same server we're currently
    running!
  prefs: []
  type: TYPE_NORMAL
- en: The `request` module accepts an options object with a number of different parameters
    and settings, but for this particular example, we only care about a few. We're
    going to pass an object that has a setting for the URL of the endpoint we want
    to consume. After the request is made and a response is received, we want an inline
    `callback` function to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following block of code after your existing list of `routes` in `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `callback` function accepts three parameters: `error`, `response`, and
    `body`. The `response` object is like any other response that Express handles
    and has all of the various parameters as such. The third parameter, `body`, is
    what we''re really interested in. That will contain the actual result of the request
    to the endpoint that we called. In this case, it is the JSON data from our main
    `GET` route we defined earlier that returns our own list of movies. It''s important
    to note that the data returned from the request is returned as a string. We need
    to use `JSON.parse` to convert that string to actual, usable JSON data.'
  prefs: []
  type: TYPE_NORMAL
- en: We manipulate the data that came back from request to suit our needs. In this
    example, we took the master list of movies and just returned a new collection
    that consists of only the `Title` and `Rating` of each movie and sorts the results
    by the top scores.
  prefs: []
  type: TYPE_NORMAL
- en: Load this new endpoint by pointing your browser to `http://localhost:3500/external-api`,
    and you can see the newly transformed JSON output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example that''s a little more real-world. Let''s
    say that we want to display a list of similar movies for each one in our collection,
    but we want to look up that data somewhere, such as on [www.imdb.com](http://www.imdb.com).
    Here is the sample code that will send a `GET` request to IMDB''s JSON API, specifically
    for the word `aliens`, and returns a list of related movies by the `Title` and
    `Year`. Go ahead and place this block of code after the previous route for `external-api`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at this new endpoint in a browser, we can see that the JSON
    data that''s returned from our `/imdb` endpoint is actually retrieving and returning
    data from some other API endpoint itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fef410ca-67ab-4945-b33a-8473a3893aaa.png)'
  prefs: []
  type: TYPE_IMG
- en: The JSON endpoint I am using for IMDB isn't actually from their API, but rather
    what they use on their home page when you type in the main Search box. This would
    not really be the most appropriate way to use their data, but it's more of a hack
    to show this example. In reality, to use their API (like most other APIs), you
    would need to register and get an API key that you would use so that they could
    properly track how much data you were requesting on a daily or hourly basis. Most
    APIs will require you to use a private key with them for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a brief look at how APIs work in general, the RESTful
    API approach to semantic URL paths and arguments, and how we create a bare bones
    API.
  prefs: []
  type: TYPE_NORMAL
- en: We used Postman REST Client to interact with the API by consuming endpoints
    and testing the different types of request methods (`GET`, `POST`, `PUT`, and
    so on). You also learned how to consume an external API endpoint by using the
    third-party node module `request`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will revisit our original application as we implement
    best practices by introducing testing in Node.js. We'll take a look at popular
    testing frameworks and write tests for the application to prove that our code
    works as expected.
  prefs: []
  type: TYPE_NORMAL
