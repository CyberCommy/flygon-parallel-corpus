- en: Deploying and Operating AWS Networking Resources with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud is one technology that is transforming multiple industries. It is
    having a significant impact on the overall infrastructure of IT, how applications
    are deployed, and how they are architected to be adopted for the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: AWS is one of the main cloud providers. It provides multiple networking resources
    and services to build scalable and highly available networking designs to house
    applications on the AWS cloud.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main pillars of cloud adoption is automation and how quickly we can
    deploy workloads. Each cloud provider has its own automation capabilities. In
    the case of AWS, this is a service called CloudFormation, which enables us to
    describe the AWS infrastructure using **Infrastructure as Code (IaC)** and to
    deploy the infrastructure on the AWS cloud. However, Ansible's advantage, when
    compared to CloudFormation, is its ability to describe/deploy resources across
    all cloud providers, including AWS. This allows us to have a consistent tool to
    deploy our workload in a multi-cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible provides multiple modules to interact with the AWS cloud to provision
    and control the different resources within.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the deployment of the basic network services
    offered by AWS, which allow us to build a scalable network design in AWS. We will
    use the following sample AWS network design in our illustration and outline how
    to build this network using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d065f4c6-ed9e-4e54-8ea5-41f207c8e462.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The main recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the AWS SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Ansible inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating to your AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying VPCs using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying subnets using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying IGWs using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling routing within a VPC using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying network ACLs using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment validation using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning AWS resources using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GitHub code used in this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch7_aws](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch7_aws)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the software releases that this chapter is based on:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3ckoAFe](https://bit.ly/3ckoAFe)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the AWS SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to install the Python libraries required
    by Ansible to start interacting with the AWS orchestration system. This step is
    mandatory as these Python libraries must be installed on the Ansible control machine
    in order for all of the Ansible AWS modules to work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have sudo access on the machine in order to install the required
    Python libraries. Furthermore, you need to have the `python-pip` package installed
    since we will be using **pip** to install the required Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test any Ansible AWS module to check whether the required Python library
    is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `boto` and `boto3` packages, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python SDK libraries that interact with the AWS orchestration system API
    are `boto` and `boto3`. These python packages must be present on the Ansible control
    machine since, with Ansible, all the AWS modules rely on one of these python packages
    to operate. We can check whether this package is already installed on the system
    using the preceding first step to run any AWS module (`aws_az_facts`, for example)
    using the `ansible` command. If the `boto3` library is not present, we will get
    an error message informing us that `boto3` is not installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can install the `boto` and `boto3` packages using the Python pip program
    using the `pip3` command, which will install the packages and all the dependencies
    needed to install and run the package correctly. At this stage, we have all that
    we need to run all the Ansible AWS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build an Ansible inventory to describe
    the infrastructure network setup that we will build across the AWS public cloud.
    This is a mandatory step in order to define all of our VPCs across all the regions
    where we will deploy our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `ch7_aws` folder and create a `hosts` file inside it, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ansible.cfg` file inside `ch7_aws` with the contents shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the host's Ansible inventory file and we now need to declare our
    VPCs as nodes in our inventory, similarly to how we define a network node. The
    only exception is that a VPC doesn't have a management IP address, so we don't
    specify the `ansible_host` argument for those VPCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the following groups in our inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: A US group, which groups all the VPCs in the United States
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An EU group, which groups all the VPCs in Europe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prod_vpcs`, which groups all of our production VPCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to define the `ansible.cfg` file with all the configuration options
    that we used in all the previous recipes. We need to specify the vault password
    file that includes the encryption password that we will use to encrypt all of
    our sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating to your AWS account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to create the credentials required to programmatically
    authenticate to our AWS account and how to secure these credentials using Ansible
    Vault. This is a mandatory step in order to be able to run any Ansible modules
    in all the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible controller must have internet access and the Ansible inventory must
    be set up as outlined in the previous recipe. Also, the user performing these
    steps must have the required access privileges on the AWS account to be able to
    create new users.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new user using **IAM** with Programmatic access, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b76fd29a-d093-464f-a7d7-235fdf2f6fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Assign the correct IAM policy to this new user, which allows them to create
    all the networking resources that it should manage (or a full access policy, for
    simplicity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/becb5c59-a184-499f-8bca-d4c0bb95a62b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finish creating the user and, on the last page, the Add user wizard will display
    the access key ID and the secret access key in a `.csv` file to download. These
    parameters will be used to authenticate to the AWS API for this account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0d4fa659-b2a1-4ad1-bf41-e6c1d687e015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Encrypt the access key ID and secret access key using Ansible Vault, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `group_vars` inside `ch7_aws` and create the `all.yml` file inside `group_vars`.
    Populate the `all.yml` file with the passwords encrypted using the `ansible-vault`
    in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to ensure that a user account has programmatic access to the
    AWS console through the API. In order for a user to authenticate to the AWS API,
    the user must be assigned two passwords, which are generated by AWS during user
    creation or when the user requests to change their password. These two passwords
    are the access key ID and the secret access key. These two passwords are only
    visible and available upon creation and AWS provides them in a CSV file that you
    can download. Furthermore, we need to ensure that this user has the correct IAM
    permission to create the necessary resources (the VPC, subnets, routing tables,
    and so on). So, in our example, this new user is assigned the administrator policy,
    which gives them full access to the AWS account to create any resources (such
    as EC2 instances, VPCs, subnets, and so on). The steps that we have outlined to
    create a new user are optional if a user already has programmatic access and the
    required IAM privileges; we have just demonstrated this for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the secrets generated by AWS for this account in the CSV file
    in plain text, we can take these passwords and encrypt them using Ansible Vault
    and store them in the `group_vars/all.yml` file so that we can use these credentials
    when we are creating all the resources for our VPCs. We store these secrets into
    the `aws_access_key` and `aws_secret_key_id` parameters after they have been encrypted
    by the `ansible-vault encrypt_string` command. Ansible Vault uses the Vault password
    file that we have declared in the `ansible.cfg` file and this file has the encryption
    password that we will use to encrypt all of these passwords.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will outline how to use these encrypted variables that
    we have created to authenticate to the AWS console when creating VPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying VPCs using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to deploy AWS VPCs using Ansible. AWS VPCs
    are the foundational networking construct in AWS and they can be thought of as
    a virtual data center within the cloud that the administrator creates within their
    AWS account. In order to start building any other infrastructure-related services
    within AWS, a VPC must first be created. We will outline how to describe all the
    required VPCs and how to automate their creation using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect to the AWS API, the AWS control machine must be connected to the
    internet. The AWS account must also be prepared, as outlined in the previous recipe,
    with the required AWS credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `us.yml` and `eu.yml` files under the `group_vars` directory and
    populate these files with the AWS region name definitions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `eu_prod_vpc.yml` and `us_prod_vpc.yml` files under the `host_vars`
    directory and populate them with the VPC parameters, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook, `pb_aws_net_build.yml`, and populate it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS has a global presence and it segregates each part of its infrastructure
    in each part of the world into Regions. An AWS Region is a collection of AWS facilities
    in a part of the world and each Region in AWS is considered to be an isolated
    fault domain with its own orchestration and management systems. So, when we are
    creating a VPC, we need to specify which region we will deploy this VPC into,
    so we need to describe this information in our Ansible variables. In our case,
    we specify the AWS Region for all of our VPCs in the US as `us-east-1` and all
    of our VPCs in the EU as `eu-west-1`. This is achieved by defining the `aws_region`
    variable under the `eu.yml` and `us.yml` files and under the `group_vars` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic of the AWS Region is critical for most of the services in AWS that
    are region-specific, and all of the networking constructs that we will build are
    all region-specific. For almost all the AWS Ansible modules, we need to specify
    the AWS Region in order to initiate the correct API call to the correct API endpoint
    in the designated region. This is because the API endpoint for each region has
    a different FQDN. For more information regarding AWS endpoints for all of the
    services in AWS in all of the regions, use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to declare the variables for each VPC under the `host_vars` directory
    and create a YAML file for each of our VPCs. We need to specify the VPC name,
    prefix, and the tags that should be assigned to the VPC. Finally, we need to create
    the Ansible playbook to build our infrastructure and use a new option within the
    playbook, which is the environment. This option creates temporary environment
    variables (`AWS_ACCESS_KEY` and `AWS_SECRET_KEY`) during the playbook's execution.
    These environment variables have their values set to the same values as the `aws_access_key`
    and `aws_secret_key_id` variables that we defined in the `group_vars/all.yml`
    file. This makes the values contained within these environment variables present
    during the playbook execution so that the AWS modules within each task can use
    this information to authenticate all the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: We can create the VPCs on the AWS cloud using the `ec2_vpc_net` Ansible module and
    we can specify the AWS Region where this VPC will be deployed using the `region`
    attribute. We need to define its IP prefix, name, and any associated tags. All
    this information is derived from the variables that we have defined in the `host_vars`
    file for this VPC.
  prefs: []
  type: TYPE_NORMAL
- en: As the module creates the VPC, it returns all of the information for the VPC
    that was created, and we can save this information in a new variable called `create_vpc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet of the data returned by the VPC creation task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot outlines the VPC created on AWS from the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce9fe352-24df-4cf8-ae3c-ea589e06d8d0.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the `ec2_vpc_net` module and the other parameters
    available within this module, use the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_net_module.html](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_net_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying subnets using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to deploy subnets within our AWS VPCs using
    Ansible. Subnets are a fundamental networking construct within AWS in order to
    provide more resiliency for applications deployed on the AWS cloud. This extra
    resiliency is achieved by the fact that subnets can be mapped to different availability
    zones. Using this logic, we can provide high availability for our deployment by
    spreading our resources into different availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability and the VPCs must
    already be provisioned as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `host_vars/eu_prod_vpc.yml` file with the subnet''s data, as shown
    here. The same is done for `host_vars/us_prod_vpc.yml` to include all of the subnet''s
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_aws_net_build.yml` playbook and populate it with the new task
    to build the subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The availability zone is the construct that provides resiliency for the physical
    infrastructure within an AWS Region. In order to use availability zones efficiently,
    we need to map our infrastructure within a VPC to be allocated to different availability
    zones within a region. This is accomplished using AWS subnets.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample deployment, we use two subnets spread across two availability
    zones in order to provide high availability for our network setup. We declare
    the subnets that we will deploy within each VPC using the `vpc_subnets` variable.
    These variables include the CIDR that we will use within each subnet (which must
    be a subset of the VPC CIDR), the availability zone that we want this subnet to
    be attached to, and, finally, the tags that we want to assign to this subnet.
    We build the availability zone's name using the AWS Region plus a suffix (`a`,
    `b`, `c`, and so on). This is the naming convention that AWS uses to name the
    availability zones within a region.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create subnets in AWS, we need to associate a subnet with its parent
    VPC. In order to do this, we need to specify the `vpc-id` parameter during the
    API call to create the subnet. This `vpc-id` is a unique identifier that AWS assigns
    to a VPC during its creation. We get this value from the VPC creation task that
    was executed to create the VPC and we saved the output of this task to the `vpc_create` variable. We
    can use this variable to retrieve the ID of the VPC and assign it to the `vpc-id`
    variable using the `set_fact` module.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can build the subnets using the `ec2_vpc_subnet` module to create
    the necessary subnets within each VPC and loop over the `vpc_subnets` data structure
    in order to build all the required subnets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the subnets that are correctly provisioned on
    the AWS cloud in our `US_Prod` VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/add19306-d6c3-4727-a6b5-ffe0a79bce24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the tags assigned to this subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d16e8772-1fb9-42aa-8db6-077df168efe8.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the `ec2_vpc_subnet` module and the other parameters
    available within this module, use the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_subnet_module.html#ec2-vpc-subnet-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_subnet_module.html#ec2-vpc-subnet-module)'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying IGWs using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to deploy **Internet Gateways** (**IGWs**)
    to our AWS VPCs using Ansible. IGWs are our exit points from our VPC to the internet
    in order to reach a public external destination. Since we are building a public-facing
    service, we need to have internet reachability from our VPC. This is accomplished
    by the IGW construct in the AWS cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability and the VPCs must
    already be provisioned, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `eu_prod_vpc.yml` file with the IGW data, as shown here, and do
    the same for `us_prod_vpc.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_aws_net_build.yml` playbook and populate it with the new task
    to build the IGW nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IGW network construct is our exit point from our VPC to reach public destinations
    across the internet. The IGW is attached to the VPC and it provides internet connectivity
    to any resource located within the VPC (such as EC2 or RDS instances). In order
    to create an IGW, we need to specify the VPC that this IGW will be attached to.
    So, we need the ID for the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous recipe, we get the VPC ID when we create the
    VPC and we can save this variable using a separate task. We can use the value
    of this variable during the IGW's creation. We can use the `ec2_vpc_igw` module
    to create the IGW and specify the region that we want this IGW deployed into.
    We can also specify the VPC ID that the IGW will be attached to. Finally, we can
    specify the tags that we will allocate to the IGW node. The IGW tags are optional,
    but they are critical when using automated deployment since they allow us to reference
    the objects that we have created. We will outline the use of tags when we discuss
    deployment validation and fact collection in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: When we deploy a new IGW, the `ec2_vpc_igw` module returns the IGW parameters
    that were provisioned inside AWS. One particular parameter that is important is
    `igw-id`. This parameter uniquely identifies the IGW node that was provisioned
    and we must use it when we reference the IGW in any operation related to this
    IGW node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet of the IGW parameters returned by `ec2_vpc_igw`,
    which we captured in the `vpc_igw_create` variable for the IGW node in `us_prod_vpc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous task, we captured the `gateway-id` variable returned by `ec2_vpc_igw`
    and stored it in a new variable, called `igw_id`, which we will use in subsequent
    tasks when referencing the IGW node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the IGW node that was provisioned and attached
    to the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54d15f07-43e2-430d-847e-7a069061b1d3.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the `ec2_igw_vpc` module and the other parameters
    available within this module, use the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_igw_module.html#ec2-vpc-igw-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_igw_module.html#ec2-vpc-igw-module)'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling routing within a VPC using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to adjust the routing inside an AWS VPC
    in order to control the traffic forwarding within the subnets inside a VPC. Controlling
    the routing within a VPC allows us to customize the VPC design and how the traffic
    is forwarded within the VPC, as well as how to exit the VPC to external destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability and the VPCs must
    already be provisioned as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `eu_prod_vpc.yml` file with the routing table data, as shown here,
    and do the same for `us_prod_vpc.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_aws_net_build.yml` playbook and populate it with the following
    tasks to attach the route table to the VPC that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook and populate it with the following tasks to update the
    route table with the required routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have managed to set up the VPC, the subnets, and the
    IGW. However, although the IGW node is connected to the internet and it is attached
    to the VPC, none of the traffic within the VPC will use the IGW node since the
    routing table associated with the VPC is still not updated and there is no route
    to point the IGW.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a snippet of the default routing table for `us_prod_vpc` before
    changing the route table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88194edb-9160-4aed-89c0-038edf8fd015.png)'
  prefs: []
  type: TYPE_IMG
- en: AWS VPCs have a default route table that is assigned to the VPC and to all the
    subnets that don't have a specific route table associated with them. So, by default,
    all the subnets within the VPC are associated with the VPC's default route table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot that shows that the subnets created within `us_prod_vpc`
    are associated with the default route table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4040a00e-1a9f-44d6-83a6-f2bee739de17.png)'
  prefs: []
  type: TYPE_IMG
- en: In the VPC definition that we have declared for each of our VPCs, we included
    a new data structure called `route_table`, which includes all the information
    we need to adjust the routing table for our VPC and associate all the subnets
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: The first task that we will execute in this recipe is getting the ID for the
    default route table that is associated with the VPC that we have created. We will
    use the `ec2_vpc_route_table_facts` module to get the facts for the route table
    and supply the VPC ID to uniquely identify the VPC. We can store the ID for the
    default route table in the new variable: `rt_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet outlines the route table facts that we retrieved from
    the `ec2_vpnc_facts` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the ID of the route table associated with the VPC, we can use the
    `ec2_vpc_route_table` module to adjust the routing table for the default route
    table associated with the VPC. We must supply the VPC and route table IDs to uniquely
    identify the exact route table that we want to modify. We can specify the routes
    that we want to inject in the routing table and the subnets that we want to associate
    with this route table. We can inject the default route and point it toward the
    IGW that we created in the previous recipe using `igw-id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the routing table for our VPC after adjusting
    the routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a82b74fa-453e-47b5-97df-a525aea13d33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot outlines how the two subnets that we have in the VPC
    are now associated with this default route table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d09225ae-3fd7-40a3-91d6-87f500e492a3.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the multiple modules to interact with the routing
    table of the AWS VPC and the associated modules, use the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_route_table_module.html#ec2-vpc-route-table-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_route_table_module.html#ec2-vpc-route-table-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_route_table_facts_module.html#ec2-vpc-route-table-facts-module ](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_route_table_facts_module.html#ec2-vpc-route-table-facts-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying network ACLs using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to deploy **network ACLs** (**NACLs**) on
    AWS. NACLs are one of the security solutions available in AWS to secure computer
    resources deployed in the AWS cloud. In this recipe, we will outline how to describe
    and automate the deployment of NACLs in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability to reach the AWS
    API endpoints, and the VPCs and subnets must already be provisioned, as per the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `eu_prod_vpc.yml` file with the NACL definition data, as shown here,
    and do the same for `us_prod_vpc.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_aws_net_build.yml` playbook and populate it with the following
    task to create the NACLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS NACLs are stateless ACLs that have the ability to allow or deny IP traffic
    based on L3 and L4 IP address information. They are enforced on the subnet level
    and are associated with subnets in order to protect all the resources provisioned
    on a subnet. They can block traffic in the ingress (traffic entering the subnet)
    or egress (traffic exiting the subnet) direction. The rules within an NACL are
    processed based on the rule number, so the first matching rule will be applied
    to the traffic flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'All subnets have a default NACL attached and AWS sets up the following rules
    for the default NACL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On ingress, all traffic is permitted. The following screenshot outlines the
    rules applied to the default NACL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/817ad855-1518-4a40-8850-0851b7082f72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On egress, all traffic is permitted. The following screenshot outlines the
    rules applied to the default NACL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/bb1f7bbc-d33e-4668-97af-4edfc69b03ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our sample setup, we will apply an NACL on all of our subnets that enforces
    the following security policy:'
  prefs: []
  type: TYPE_NORMAL
- en: All TCP traffic to ports `80` and `443` must be allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other traffic should be dropped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, there is a `DENY` rule at the end of any NACL that drops all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `network_acls` data structure that holds the NACL definitions
    and all the required fields to set up the required NACLs on all of our subnets
    in both the EU and US regions. In this data structure, we need to define the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: This is the name of the NACL and it serves as an identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subnets`: This defines the subnets that should be associated with this NACL.
    We use the data in our `vpc_subnets` definition to construct this list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress_rules`: This defines all the rules that should be applied as part
    of this NACL in the ingress direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engress_rules`: This defines all the rules that should be applied as part
    of this NACL in the egress direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a new task within our playbook using `ec2_net_nacl` to provision
    the NACL and attach it to all of our subnets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the new NACL deployed in the `EU_prod` VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/84b0059f-fdba-41d5-a1bf-dedb5864da28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot outlines the subnets associated with our NACL in the
    `EU_prod` VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4efc85f3-9834-413c-926b-40016ac74cf1.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the `ec2_net_nacl` Ansible module and the different
    parameters supported by this module, consult the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_nacl_module.html](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_nacl_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment validation using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to collect the operational state of the
    different networking components within AWS, such as VPCs and subnets, and how
    to check that our deployment is being implemented as per our design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability and all the networking
    components that we have outlined in the previous recipes should be in place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `pb_vpc_validate.yml` playbook and populate it with the tasks
    to validate the VPC build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following tasks to collect the facts for the AWS
    subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to validate the state of the AWS
    subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a new playbook to collect the VPC and subnet''s facts using the `ec2_vpc_net_facts`
    and `ec2_vpc_subnet_facts` Ansible modules. We can collect the data returned from
    these modules and use the `assert` module to validate the state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the name assigned to the VPC is provisioned as per our design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the CIDR block assigned to the VPC is deployed as per our design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the CIDR assigned to the subnets is provisioned correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the subnet is provisioned in the correct availability zone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can perform all of the preceding validation by comparing the operational
    state returned by the facts modules with the metadata that we have defined for
    each VPC in either of the `group_vars` or `host_vars` variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ec2_vpc_net_facts` task, we used the `filters` parameter to select our
    VPC based only on its `Name` tag. By default, this module will return the facts
    for all of the VPCs within this region.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ec2_vpc_subnet_facts` task, we used the `filters` parameter to only
    retrieve the subnets data for our VPC, since by default this module will return
    all the subnets' facts for all of our VPCs within the region.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the modules for fact collection for the different
    network resources in AWS, use the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_net_facts_module.html#ec2-vpc-net-facts-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_net_facts_module.html#ec2-vpc-net-facts-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_subnet_facts_module.html#ec2-vpc-subnet-facts-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_subnet_facts_module.html#ec2-vpc-subnet-facts-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/ec2_vpc_igw_facts_module.html#ec2-vpc-igw-facts-module](https://docs.ansible.com/ansible/latest/modules/ec2_vpc_igw_facts_module.html#ec2-vpc-igw-facts-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning resources on AWS using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to decommission a complete network within
    AWS with all the associated network resources. This outlines how we can easily
    build and tear down resources on the cloud with a simple playbook execution using
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must have internet reachability and all the networking
    components that we have outlined in the previous recipes should be in place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `pb_delete_vpc.yml` playbook with the following tasks to collect
    the facts for the VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following tasks to remove all the subnets and
    IGW nodes within the VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to remove all the NACLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the final task to remove all the VPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can start our new playbook with a collection of facts for our VPC to get
    the VPC ID for our deployed VPC. Once we have this information, we can start to
    delete the resources. However, the order in which we delete the resources is important.
    We need to remove any dependent resources first, so we must remove the subnets
    before we can remove the VPC. So, for example, if there are EC2 instances attached
    to the subnet, we must remove these EC2 instances before we can remove the subnets.
    So, in our case, we need to remove the subnets, then the IGW node, and then, finally,
    remove the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: In all of these tasks, we are using the same exact modules that we have outlined
    in the previous recipes. The only change is that we are setting the state to be
    absent and we are supplying the required VPC ID to uniquely identify the VPC that
    we need to remove the required resources from.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we start removing the resources within the VPC, we are validating
    first whether a VPC ID is present. If the resources have already been deleted
    and we run the playbook again, the deletion step would be skipped since no VPC
    ID would be retrieved by the `facts` task.
  prefs: []
  type: TYPE_NORMAL
