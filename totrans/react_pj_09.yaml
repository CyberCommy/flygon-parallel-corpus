- en: Build an Animated Game Using React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the projects that you've created in this book focused on displaying
    data and making it possible to navigate between pages. In the previous chapter,
    you explored some of the differences between creating a web and a mobile application.
    One other difference when building a mobile application is that your users expect
    animations and gestures since they make using the application easy and familiar.
    This is something that you'll focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll add animations and gestures to a React Native application
    using the Animated API from React Native, a package called Lottie, and Expo's
    `GestureHandler`. Together, they make it possible for us to create applications
    that make the best use of a mobile's interaction methods, which is perfect for
    a game such as *Tic-Tac-Toe*. Also, the application will show a leaderboard with
    the high scores for this game next to the game interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this game, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the React Native Animated API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced animations with Lottie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling native gestures with Expo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating an animated *Tic-Tac-Toe* game build with
    React Native and Expo, which uses the Animated API to add basic animations, Lottie
    for advanced animations, and Gesture Handler from Expo to handle native gestures.
    The starting point will be creating an application with the Expo CLI that has
    basic routing implemented in it, so that our users can switch between the game
    interface and an overview of the high scores for this game.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 1.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch9-initial](https://github.com/PacktPublishing/React-Projects/tree/ch9-initial)[. The
    complete source code can also be found on GitHub: ](https://github.com/PacktPublishing/React-Projects/tree/ch10-initial)[https://github.com/PacktPublishing/React-Projects/tree/ch9.](https://github.com/PacktPublishing/React-Projects/tree/ch9)
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device. Alternatively, you can install
    either Xcode or Android Studio on your computer to run the application on a virtual
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out the initial project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application that you''ll be working on in this chapter has already been
    built for you, but we will need to complete it by adding features such as animations
    and transitions. After downloading or cloning the project, you''ll need to move
    into the root directory of the project, where you can run the following command
    to install the dependencies and start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will start Expo and give you the ability to start your project from the
    Terminal or from your browser. In the Terminal, you can either use the QR Code
    to open the application on your mobile device or select to open the application
    in a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter whether you''ve opened the application on a virtual or physical device,
    at this point, the application should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/84ec8568-59b9-490c-85a6-8fded3613a7a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application consists of three screens: `Start`, `Game`, and `LeaderBoard`.
    The first screen is `Start`, where the game can be started by clicking the green
    button. This will lead to the `Game` screen, which is set up as a modal. The `Start`
    screen uses tab navigation, from which you can also visit the `LeaderBoard` screen,
    which is where the scores of the players will be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure for this React Native application is as follows. This
    structure is similar to the projects we''ve created already in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `assets` directory, you''ll find the two images: one that will be used
    as the application''s icon on the Home screen once you''ve installed this application
    on your mobile device, and one that will serve as the splash screen that is displayed
    when you start the application. A Lottie animation file has also been placed here,
    which you''ll use later on in this chapter. The configurations for your application,
    for example, the App Store, are placed in `app.json`, while `babel.config.js` holds
    specific Babel configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file
    is being imported and returned within a Context Provider that was created in the
    `context/AppContext.js` file. In `AppContainer`, all the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application. In the `utils` directory, you can find the logic for
    the game, that is, the functions that will fill the slots of the *Tic-Tac-Toe*
    board and determine which player won the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the components for this game are located in the `Screens` and `Components` directories,
    where the former holds the components that are rendered by the `Start`, `Game`,
    and `LeaderBoard` routes. The child components for these screens can be found
    in the `Components` directory, which has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The most important components in the preceding structure are `Board`, `Slot`,
    and `Filled`, since they construct most of the game. `Board` is rendered by the
    `Game` screen and holds some logic for the game, while `Slot` and `Filled` are
    components that are rendered on this board. The `Actions` component returns two `Button`
    components so that we can either navigate away from the `Game` screen or restart
    the game. `Player` displays the name of the player whose turn it is, or the player
    that has won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animated Tic-Tac-Toe game application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile games often have flashy animations that make the user want to keep playing
    and make the game more interactive. The *Tic-Tac-Toe* game that is already functioning
    uses no animations so far and just has some transitions that have been built in
    with React Navigation. In this section, you'll be adding animations and gestures
    to the application, which will improve the game interface and make the user feel
    more comfortable while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Using the React Native Animated API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to use animations in React Native and one of those is
    to use the Animated API, which can be found in the core of React Native. With
    the Animated API, you can create animations for `View`, `Text`, `Image`, and `ScrollView`
    components from `react-native` by default. Alternatively, you can use the `createAnimatedComponent` method
    to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the simplest animations you can add is fading an element in or out by
    changing the value for the opacity of that element. In the *Tic-Tac-Toe* game
    you created previously, the slots were filled with either a green or blue color,
    depending on which player filled that slot. These colors already show a small
    transition since you''re using the `TouchableOpacity` element to create the slot.
    However, it''s possible to add a custom transition to this by using the Animated
    API. To add an animation, the following code blocks must be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file in the `src/Components/Slot` directory and calling
    it `Filled.js`. This file will contain the following code, which will be used
    to construct the `Filled` component. Inside this file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This component displays a `View` element and is styled using a styling object
    that's using the JSS syntax, which is the default for React Native. This element
    can be used to fill in another element since its position is absolute with 100%
    width and 100% height. It also takes the `filled` prop so that we can set the
    `backgroundColor` and determine whether the component is displayed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import this component into the `Slot` component and display it once
    the slot has been filled by any of the players. Instead of setting the background
    color for the `SlotWrapper` component, you can pass the color that belongs to
    player one or two to the `Filled` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever you click on a slot, nothing visible will change since you''ll
    need to change the clickable element from a `TouchableOpacity` element to a `TouchableWithoutFeedback` element
    first. That way, the default transition with the opacity will be gone, so you
    can replace this with your own. The `TouchableWithoutFeedback` element can be
    imported from `react-native` and should be placed around a `View` element, which
    will hold the default styling for the slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, the slot that you've just pressed on will be immediately filled in with
    the color you've specified in the `backgroundColor` field for the `Filled` component,
    without any transition whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recreate this transition, you can use the Animated API, which you''ll use
    to change the opacity of the `Filled` component from the moment it''s rendered
    by a slot. Therefore, you need to import `Animated` from `react-native` in `src/Components/Slot/Filled.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A new instance of the Animated API starts by specifying a value that should
    be changed during the animation that we created with the Animated API. This value
    should be changeable by the Animated API in your entire component, so you can
    add this value to the top of the component. This value should be created with
    a `useState` Hook since you want this value to be changeable later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This value can now be changed by the Animated API using any of the three animations
    types that are built-in. These are `decay`, `spring`, and `timing`, where you''ll
    be using the `timing` method from the Animated API to change the animated value
    within a specified time frame. The Animated API can be triggered from any function
    that is, for example, linked to an `onPress` event or from a life cycle method.
    Since the `Filled` component should only be displayed when the slot is filled,
    you can use a life cycle method that is triggered when the `filled` prop component
    is changed, that is, a `useEffect` Hook with the `filled` prop as a dependency.
    The styling rule for the display can be removed since the component will have
    an `opacity` of `0` when the `filled` prop is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `timing` method takes the `opacityValue` that you've specified at the top
    of your component and an object with the configuration for the Animated API. One
    of the fields is `toValue`, which will become the value for `opacityValue` when
    the animation has ended. The other field is for the field's duration, which specifies
    how long the animation should last.
  prefs: []
  type: TYPE_NORMAL
- en: The other built-in animation types next to `timing` are `decay` and `spring`.
    Where the `timing` method changes gradually over time, the `decay` type has animations
    that change fast in the beginning and gradually slow down until the end of the
    animation. With `spring`, you can create animations that move a little outside
    of its edges at the end of the animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you only need to change the `View` element into an `Animated.View`
    element and add the `opacity` field and the `opacityValue` value to the `style`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you press any of the slots, the `Filled` component will fade in,
    since the opacity value transitions for 500 ms. This will make a filled slot look
    as follows for both players when you run the application in either the iOS simulator
    or a device that runs on iOS. On Android, the application should look similar,
    since no platform-specific styling has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2db00402-f380-40e3-acbc-389e11cac37f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Something else you can do to make the animation appear smoother is add an `easing`
    field to the `Animated` object. The value for this field comes from the `Easing`
    module, which can be imported from `react-native`. The `Easing` module has three
    standard functions: `linear`, `quad`, and `cubic` Here, the `linear` function
    can be used for smoother timing animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this last change, the animation is complete and the game interface already
    feels smoother since the slots are being filled using your own custom animation.
    In the next part of this section, we will combine some of these animations to
    make the user experience for this game even more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Combining animations with the Animated API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the transition by changing the opacity of the `Filled` component is already
    an improvement to the game interface. But there are more animations we can create
    to make the game's interaction even more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things we can do is add a fade-in animation to the size of the `Filled` component.
    To make this animation work well with the fading in animation we''ve just created,
    we can use the `parallel` method from the Animated API. This method will start
    the animations that are specified within the same moment. To create this effect,
    we need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this second animation, you want the `Filled` component to not only have
    a color that fades in, but also a size that is fading in. To set an initial value
    for the opacity, you have to set an initial value for the size of this component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Animated.timing` method that you created in the `useEffect` Hook needs
    to be wrapped inside an `Animated.parallel` function. That way, you can add another
    animation that changes the size of the `Filled` component later on. The `Animated.parallel` function
    takes an array of the `Animated` method as a parameter and must be added like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next to the `parallel` function, three other functions help you with animation
    composition. These functions are `delay`, `sequence`, and `stagger`, and can also
    be used in combination with each other. The `delay` function starts any animation
    after a predefined delay, the `sequence` function starts animations in the order
    you've specified and waits until an animation is resolved before starting another
    one, and the `stagger` function can start animations both in order and parallel
    with specified delays in-between.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `parallel` function, you need to add the Animated API''s `spring` method,
    which animates the size of the `Filled` component. This time, you won''t be using
    a `timing` method, but a `spring` method, which adds a little bounce effect to
    the end of the animation. An `Easing` function is also added to make the animation
    look a little smoother:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `spring` animation will change the value of `scaleValue` from `0` to `1` and
    create a little bounce effect at the end of the animation. `scaleValue` must also
    be added to the `style` object for the `Animated.View` component for the animation
    to become effective. `scaleValue` will be added to the `scale` field within the
    `transform` field, which will change the size of the `Filled` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you click on any of the slots, the `Filled` component won't only fade in
    by changing the opacity but also by changing its size. The bounce effect at the
    end of the animation adds a nice touch to the fading effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you click on the slot that depicts the winner of the game, the
    animation doesn''t have enough time to end while the winning state is rendered
    by the component. Therefore, you will also need to add a timeout to the function
    that sets the winner of the game. This function can be found in `src/Screens/Game.js`,
    where you can add a constant that sets the number of ms the animation should last
    for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also wrap the functions that set the winner in a `setTimeout` function,
    which delays the execution of these functions by the same amount of time the animation
    lasts for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `ANIMATION_DURATION` constant is exported, you can import this constant
    in the `src/Components/Slot/Filled.js` file and use this same constant for the
    actual animation. That way, if you change the duration of the animation at some
    point, you won''t have to make any changes to other components for these changes
    to be visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the slots now being filled in with an animated `Filled` component
    that executes two parallel animations, when you click on any of them, the functions
    that set the winner of the game will wait until the slot is filled before firing.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will show how to handle even more advanced animations, such
    as displaying animated graphics when any of the two players win. For this, we'll
    use the Lottie package since it supports more functionalities than the built-in
    Animated API.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced animations with Lottie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React Native Animated API is great for building simple animations, but building
    more advanced animations can be harder. Luckily, Lottie offers a solution for
    creating advanced animations in React Native by making it possible for us to render After
    Effects animations in real time for iOS, Android, and React Native. Lottie can
    be installed as a separate package using `npm`, but it is also available from
    Expo. Since Lottie is still part of Expo's experimental features, you can use
    it by retrieving it from the `DangerZone` namespace. Therefore, it is currently
    best to install Lottie from `npm` and import it in the files where you want to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: When using Lottie, you don't have to create these After Effects animations yourself;
    there's a whole library full of resources that you can customize and use in your
    project. This library is called `LottieFiles` and is available at `https://lottiefiles.com/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you''ve already added animations to the slots of the board game, a nice
    place to add more advanced animations would be the screen that is displayed when
    either of the players wins the game. On this screen, a trophy can be displayed
    instead of the board since the game has ended. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Lottie, run the following command, which will install Lottie
    and its dependencies and add it to your `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation process has completed, you can proceed by creating a
    component that will be used to render the After Effects animations that have been
    downloaded as Lottie files. This component can be created in the new `src/Components/Winner/Winner.js` file.
    In this file, you will need to import React and, of course, Lottie from `lottie-react-native`,
    which you''ve just installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The imported `Lottie` component can render any Lottie file that you either
    create yourself or that is download from the `LottieFiles` library. In the `assets` directory,
    you will find a Lottie file that can be used in this project called `winner.json`.
    This file can be rendered by the `Lottie` component when you add it to the source,
    and the width and height of the animation can be set by passing a style object.
    Also, you should add the `autoPlay` prop to start the animation once the component
    renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will now start rendering the trophy animation in any of the
    screens where you''ll include this component. Since this animation should be displayed
    instead of the board when either of the players wins the game, the `Board` component
    would be a good place to add this component as you can then use the wrapper styling
    for the board. The `Board` component can be found in the `src/Components/Board/Board.js` file,
    and is where you can import the `Winner` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `return` function of this component, you can check whether the `winner`
    prop is `true` or `false` and, depending on the outcome, display either the `Winner` component
    or iterate over `slots`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `Board` component receives the `winner` prop with the `true` value,
    instead of the board, the user will see the trophy animation being rendered. An
    example of how this will look when you''re running the application with the iOS
    simulator or on an iOS device can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f18f00c-3355-4980-ad61-29b0ccf1944c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In case you find the speed of this animation too fast, it''s possible to change
    this by combining the Animated API with Lottie. The `Lottie` component can take
    a `progress` prop that determines the speed of the animation. When passing a value
    that is created by the Animated API, you can tweak the speed of the animation
    to your own needs. Adding this to the Lottie animation can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you''ll need to import `Animated` and `Easing` (which you''ll use later
    on) and create a new value using `Animated` and the `useState` Hook at the top
    of your component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Within a `useEffect` Hook, you can create the `Animated.timing` method, which
    will set the `progressValue` over a time frame that you indicate using the `duration`
    field. The animation should start as soon as the component renders, so the dependency
    array for the Hook should be empty. You can also add the `Easing.linear` function
    to the `easing` field to make the animation run smoother:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `progressValue` value can be passed to the `Lottie` component, which
    will result in a different behavior for the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, the animation is being slowed down. Instead of the default 3,000 ms, the
    animation will take 4,000 ms to play from beginning to end. In the next section,
    you'll add even more complexity to the user experience of this application by
    handling gestures that are available on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Handling gestures with Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gestures are an important feature of mobile applications as they will make the
    difference between a mediocre and a good mobile application. In the *Tic-Tac-Toe*
    game you've created, several gestures could be added to make the game more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, you used the `TouchableOpacity` element, which gives the user feedback
    after they press this element by changing the element. Another element that you
    could have used for this was the `TouchableHighlight` element. Just like`TouchableOpacity`,
    it can be pressed by the user, but, instead of changing the opacity, it highlights
    the element. These feedback or highlight gestures give the user an impression
    of what happens when they make decisions within your application, leading to improved
    user experience. These gestures can be customized and added to other elements
    as well, making it possible to have custom Touchable elements as well.
  prefs: []
  type: TYPE_NORMAL
- en: For this, you can use a package called `react-native-gesture-handler`, which
    helps you access native gestures on every platform. All of these gestures will
    be run in the native thread, which means you can add complex gesture logic without
    having to deal with the performance limitations of React Native's gesture responder
    system. Some of the gestures it supports include tap, rotate, drag, and pan gestures.
    Any project that's created with the Expo CLI can already use `GestureHandler`
    from `react-native-gesture-handler` without you having to manually install the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use gestures directly from React Native, without having to use
    an additional package. However, the gesture responder system that React Native
    currently uses doesn't run in the native thread. Not only does this limit the
    possibilities of creating and customizing gestures, but you can also run into
    cross-platform or performance problems. Therefore, it's advised that you use the
    `react-native-gesture-handler` package, but this isn't necessary for using gestures
    in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Handling tap gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first gesture we will implement is a tap gesture, which will be added to
    the `Slot` component, to give the user more feedback on their actions. Instead
    of filling the slot when the user taps it, the user will already receive some
    feedback when the tap event is started and receive feedback when the event is
    completed. Here, we''ll use the `TouchableWithoutFeedback` element from `react-native-gesture-handler`,
    which runs in the native thread, instead of the `TouchableWithoutFeedback` element
    from `react-native`, which uses the gesture responder system. Replacing the `react-native`
    component with the one from `react-native-gesture-handler` can be done by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchableWithoutFeedback` can be imported from `react-native-gesture-handler` at
    the top of the `src/components/Slot.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to change anything in the return function since `TouchableWithoutFeedback`
    uses the same props as the one from `react-native`. When you tap the slot, nothing
    will change. This is because the slot will be filled by the `Filled` component,
    which shows an animation once it appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you tap any of the slots and hold your finger on it, the `handleOnPress` function
    won''t be called yet. Only when you complete the tap gesture by removing your
    finger will the gesture end and the `handleOnPress` function will be called. To
    start the animation when you start the tap gesture by touching the slot, you can
    use the `onPressIn` callback from `TouchableWithoutFeedback`. Once the tap event
    starts, a value needs to be passed to the `Filled` component that indicates it
    should start the animation. This value can be created with the `useState` Hook,
    so you already have a function that can be called to change this value. The `handleOnPress` function
    should be called when the tap event ends by removing your finger from the element.
    You can do this using the `onPressOut` callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Filled` component in the `src/Components/Slot/Filled.js` file, you
    need to check for the `start` prop and start the animation once this prop has
    a value of `true`. Since you don''t want to start the entire animation when the
    value for `start` is `true`, only the animation that changes `opacityValue` will
    start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the animation that changes the opacity can be removed from the `useEffect` Hook
    that''s checking for the `filled` prop. This `useEffect` Hook only handles the
    animation that changes the scale. The initial `scaleValue` should be changed because,
    otherwise, the size of the component will be equal to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you tap any of the slots after making these changes, the `timing` animation
    will be started and a square will appear in the slot, which indicates that the
    slot is being tapped. Once you release your finger from this slot, the square
    will change in size and fill in the rest of the slot as the `spring` animation
    starts, which happens when the `onPress` function changes the value for `filled`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing tap gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the slot has different animations, depending on the state of the tap event,
    which can be useful if the user has second thoughts about which slot to select.
    The user may remove their finger from the selected slot, in which case the tap
    event will follow a different flow of states. You can even determine whether the
    user should click on the slot for a longer time to make the selection definitive
    or maybe double-tap the slot just like liking a picture on some social media applications.
  prefs: []
  type: TYPE_NORMAL
- en: To create more complex tap gestures such as these, you need to know that the
    tap event goes through different states. `TouchableWithoutFeedback` uses `TapGestureHandler` under
    the hood and can go through the following states: `UNDETERMINED`, `FAILED`, `BEGAN`, `CANCELLED`, `ACTIVE`,
    and `END`. The naming of these states is pretty straightforward and, usually,
    the handler will have the following flow: `UNDETERMINED > BEGAN > ACTIVE > END
    > UNDETERMINED`. When you add a function to the `onPressIn` callback on the `TouchableWithoutFeedback` element,
    this function is called when the tap event is in the `BEGAN` state. The `onPressOut` callback
    is invoked when the state is `END`, while the default `onPress` callback responds
    to the `ACTIVE` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these complex gestures, you can use the `react-native-gesture-handler` package
    by handling the event state yourself, rather than the declarative way of using
    a touchable element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TapGestureHandler` can be imported from `react-native-gesture-handler` and lets
    you create customized touchable elements that have gestures that you can define
    yourself. You''ll need to import the `State` object from `react-native-gesture-handler`,
    which holds the constants you''ll need to use to handle checking for the state
    of the tap event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of event handlers such as `onPress`, the `TouchableWithoutFeedback` element
    has a callback called `onHandlerStateChange`. This function will be called every
    time the state of `TapGestureHandler` changes, which is, for example, when the
    element is tapped. By using `TapGestureHandler` to create the touchable element,
    you no longer need the `TouchableWithoutFeedback` element. The functionality of
    this element can be moved to the new element that you''ll create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`onHandlerStateChange` takes the `onTap` function, which you still need to
    create, and checks for the current state of the tap event. When the tap event
    is in the `BEGAN` state, which is similar to the `onPressIn` handler, the animation
    from `Filled` should start. The completion of the tap event has the `END` state and
    is like the `onPressOut` handler, where you''ll call the `handleOnPress` function,
    which changes the value for the prop regarding the player that tapped the slot.
    The `setStart` function will be called to reset the state that starts the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When you tap any of the slots and hold your finger on it, the `handleOnPress` function
    won't be called. Only when you complete the tap gesture by removing your finger
    will the gesture end and the `handleOnPress` function be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'These gestures can be customized even more since you can use composition to
    have multiple tap events that respond to each other. By creating so-called **cross-handler
    interactions**, you can create a touchable element that supports a double-tap
    gesture and a long-press gesture. By setting and passing down a ref that''s been
    created with the React `useRef` Hook, you can let the gesture handlers from `react-native-gesture-handler`
    listen to the state life cycle of other handlers. That way, you can sequence events
    and respond to gestures like a double-tap event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the ref, you need to place the `useRef` Hook at the top of your component
    and pass this ref to `TapGestureHandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to set the number of taps that are needed to start and complete
    the tap gesture. You don''t have to make any changes to the `onTap` function since
    the first time you tap the element, the state of the tap event will be `BEGAN`.
    Only after you''ve tapped the element twice will the tap event state change to
    `END`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To fill a slot, a user has to tap `TapGestureHandler` two times for the tap
    event to complete. However, you can also call a function when `TapGestureHandler`
    is tapped once by adding another `TapGestureHandler` that takes the existing one
    as its child. This new `TapGestureHandler` should wait for the other handler to
    have the double-tap gesture, which it can check using `doubleTapRef`. The `onTap` function
    should be renamed to `onDoubleTap` so that you have a new `onTap` function that
    will handle the single tap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on a slot just once, the animation will start, since `TapGestureHandler`
    will be in the `BEGAN` state. The animation on the double-tap gesture should only
    start when the state is `ACTIVE` instead of `BEGAN`, so the animation won''t start
    on just a single tap. Also, by adding a `setTimeout` to the functions that are
    called when the tap gesture has ended, the animation will look smoother since
    both animations will otherwise occur too soon after each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to having a double-tap gesture to fill a slot, having a long-press gesture
    could also improve the user''s interaction. You can add a long-press gesture by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `LongPressGestureHandler` from `react-native-gesture-handler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On this handler, you can set the minimal duration of the long-press gesture
    and set the function that should be called after this time frame has passed. The
    `LongPressGestureHandler` handler has a state life cycle, that you can use together
    with the `onDoubleTap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you only want to create a long-press gesture, you can use the `onLongPress` event
    handler, which is available on the touchable elements from `react-native` and `react-native-gesture-handler`.
    It's advised that you use the touchable elements from `react-native-gesture-handler` as
    they will run in the native thread, instead of using the React Native gesture
    responder system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe not all of your users will understand that they need to use a long-press
    gesture to fill a slot. Therefore, you can use the `onTap` function, which is
    called on a single tap, to alert the user about this functionality. For this,
    you can use the `Alert` API, which works for both iOS and Android and uses the
    native alert message from either of these platforms. In this alert, you can add
    a small message for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will show an alert when the user doesn't use the long-press to make a move
    on the board, thus making it more understandable for them. With these final additions,
    the game interface has been improved even more. Not only will users see animations
    based on their actions, but they'll also be notified about which gestures they
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added animations and gestures to a simple *Tic-Tac-Toe*
    game that was built with React Native and Expo. The animations were created using
    the React Native Animated API and Lottie, which is available from the Expo CLI
    and as a separate package. We also added basic and more complex gestures to the
    game, which runs in the native thread thanks to the `react-native-gesture-handler` package.
  prefs: []
  type: TYPE_NORMAL
- en: Animations and gestures provide a clear improvement to the user interface of
    your mobile application, and there's even more we can do. Still, our application
    will also need to request and display data to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we used GraphQL alongside React. We will build upon this in the
    next chapter. The project that you'll create in the next chapter will explore
    handling real-time data in a React Native application using WebSockets and GraphQL
    using Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various Lottie files: [https://lottiefiles.com/](https://lottiefiles.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on the Animated API: [https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
