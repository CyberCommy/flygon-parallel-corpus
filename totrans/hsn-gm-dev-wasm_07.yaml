- en: Collision Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our spaceships can fly around and shoot at each other, but nothing
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collision detection** is used in the vast majority of video games to determine
    whether game objects intersect. There are a large number of methods for detecting
    collisions between different game objects. Various methods can work better in
    different situations. There is also a trade-off between the amount of computation
    time and how accurate our collision detection will be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter07/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)[ment-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collider objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding colliders to our game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of 2D collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I could write an entire book on the kinds of 2D collision detection available
    to us, let alone the number available for collision detection in 3D. I have written
    several TypeScript tutorials on how to use different detection techniques, both
    basic and sophisticated at [https://www.embed.com/typescript-games/basic-collision-detection.html](https://www.embed.com/typescript-games/basic-collision-detection.html),
    but, in this book, we will stick to using a combination of some of the more basic
    collision techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Circle collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic kind of collision detection is **circle** or **distance** collision
    detection. If we treat all of our colliders like little circles with a radius
    and a position, we can calculate the distance between the two locations and see
    whether that distance is less than the sum of our radii. This form of collision
    detection is high-speed, but precision is limited. If you look at the projectile
    in our game, this method works pretty well. Our spaceships, on the other hand,
    don''t fit neatly into a circle. We can adjust the radius of our circle collider
    on any given ship to give slightly different results. When circle collision detection
    works, it can be very efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d6fab86-e4bd-4a7c-9d6c-f8dcd049fe88.png)[Circle collision hit test]'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rectangle** collision detection is another fast collision detection method.
    In many cases, it may be faster than circle collision detection. A rectangle collider
    is defined by an *x* and a *y* coordinate that is the position of the top left
    corner of our rectangle, as well as a width and a height. Detecting a rectangle
    collision is pretty straightforward. We look for an overlap on the *x* axis between
    the two rectangles. If there is an overlap on the *x* axis, we then look for an
    overlap on the *y* axis. If we have an overlap on both axes, there is a collision.
    This technique works pretty well for a lot of old-school video games. Several
    classic games released on the Nintendo Entertainment System used this method of
    collision detection. In the game we are writing, we are rotating our sprites,
    so using traditional non-oriented collision detection will not be useful for us.'
  prefs: []
  type: TYPE_NORMAL
- en: A short refresher on trigonometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, our collision detection algorithms start to get a lot more complicated.
    You may remember some of the concepts from your high school trigonometry class,
    but some basic trigonometry is very important for many collision detection algorithms.
    Even our circle collision detection that we discussed earlier relies on the Pythagorean
    theorem, so, in reality, unless you are doing simple non-oriented rectangle collision
    detection, at least a tiny amount of trigonometry is required. Trigonometry is
    the study of triangles in mathematics. Most games use what's called a **Cartesian
    coordinate system**. If you're not familiar with that phrase, *Cartesian coordinate
    system* means we have a grid with an *x* and a *y* coordinate (for a 2D game).
  prefs: []
  type: TYPE_NORMAL
- en: The word *Cartesian* means Rene Descartes invented it—the "*I think; therefore,
    I am"* guy who had a lot of great ideas in mathematics and a lot of stupid ideas
    in philosophy (ghost in the machine…yuck!).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few key concepts we have to remember from our trigonometry classes
    in high school, and they all have to do with right triangles. A right triangle
    is a triangle with a 90-degree angle in it. That is a handy thing when you''re
    working with a Cartesian coordinate system because your *x* and *y* axes happen
    to form a right angle so any line between two points that do not share either
    an *x* or a *y* coordinate could be considered the hypotenuse (long side) of a
    right triangle. There are a few ratios we also need to remember; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sine - Y / Hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cosine - X / Hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tangent - Y / X*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you remember SOHCAHTOA? (Pronounced "*Sock-Ah-Toe-Ah*")
  prefs: []
  type: TYPE_NORMAL
- en: 'That was meant to remind you of the following versions of the trigonometry
    ratios:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sine - Opposite / Hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cosine - Adjacent / Hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tangent - Opposite / Adjacent*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this formulation, the *opposite* side of the triangle is the *y* axis, and
    the adjacent side of the triangle is the *x* axis. If you remember SOHCAHTOA,
    you may have an easier time remembering these ratios. If not, just open this book
    back up or use Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b577127-7c70-4995-b1fc-94ff8c9025ff.png)[SOHCAHTOA]'
  prefs: []
  type: TYPE_NORMAL
- en: Some people have been taught the phrase "*Some Old Horse Came A-Hoppin' Through
    Our Alley."* I'm not sure if that is helpful. I find it more difficult to remember
    than SOHCAHTOA, but that's a matter of opinion. So, if imagining a horse that
    hops like a rabbit around some city's back alley is your bag, then, by all means,
    use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember earlier in this book we used the angle the ship was rotated
    with the `sin` and `cos` math library functions to figure out how fast our ship
    was moving on the *x* axis and the *y* axis. Those functions return the ratio
    for a given angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concept we need to know is the **dot product** between two **unit vectors**.
    A unit vector is a vector with a length of 1\. The dot product between two unit
    vectors is just the cosine of the angle between those two unit vectors. The closer
    the dot products are to 1, the closer the angle between the two vectors is to
    0 degrees. If the dot product is close to 0, the angles between the two vectors
    are close to 90 degrees, and if the dot product between the two angles is close
    to -1, the angle between the two vectors is near 180 degrees. Dot products between
    different vectors are very useful in both collision detection and in-game physics.
    Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82871b59-db4d-4e5d-b1f9-62e36b1075f3.png)[The dot product of two normalized
    vectors]'
  prefs: []
  type: TYPE_NORMAL
- en: Line collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the first thing we need to do is talk about the difference between a line
    and a line segment. We define a line using two points. That line continues after
    the points to infinity. A line segment terminates at the two points and does not
    continue indefinitely. Two lines that are not parallel will always intersect somewhere.
    Two non-parallel line segments may or may not intersect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, in games, we are interested in knowing whether two line
    segments intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6e81faa-2b8e-49df-b571-e6f1037363e4.png)[Line versus line segment]'
  prefs: []
  type: TYPE_NORMAL
- en: It is relatively easy to determine whether a line intersects with a line segment.
    All you have to do is see whether the two points of the line segments are on opposite
    sides of your line. Since a line is infinite, that means your line segment has
    to intersect with your line somewhere. If you want to find out whether two line
    segments intersect, you can do it in two stages. First, find out whether line
    segment A intersects with an infinite line B. If they do intersect, then find
    out whether line segment B intersects with the infinite line A. If this is true
    in both cases, the line segments intersect.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the next question is, how do we know mathematically whether two points
    are on the opposite sides of a line? To do that, we are going to use the previously
    discussed dot product and something called a **vector normal**. A vector normal
    is just a 90-degree rotated version of your vector. See the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4af90a66-08e0-48b0-9908-f3459639475b.png)'
  prefs: []
  type: TYPE_IMG
- en: A vector and that vector's normal
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need the vector that has an origin at the same point but has a direction
    aiming at point 1 of our line segment. If the dot product of those two vectors
    is a positive value, that means the point is on the same side of the line as the
    normalized vector. If the dot product is a negative value, that means the point
    is on the opposite side of the line to our normal vector. If the line segment
    intersects, that means one point has a positive dot product and the other side
    has a negative dot product. Since multiplying two negative numbers and two positive
    numbers both give you a positive result and multiplying a negative and a positive
    number gives you a negative result, multiply the two dot products together and
    see whether the resulting value is negative. If it is, the line segment intersects
    with the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0ad57a9-0d05-4ef3-a8bd-ffd8a4b47b63.png)[Determining whether two points
    are on the opposite side of a line]'
  prefs: []
  type: TYPE_NORMAL
- en: Compound colliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **compound collider** is when a game object uses multiple colliders to determine
    whether there was a collision. We are going to use compound circle colliders on
    our ship to improve the accuracy of our ship collision detection while still providing
    the increased speed of using circle colliders. We will cover our player's ship
    and our enemy ship with three circles. Our projectiles are a circle shape, so
    using a circle for those is entirely natural. There is no reason you need to limit
    compound colliders to using only one shape of collider. Internally, a compound
    collider could mix circle colliders with rectangle colliders or any other type
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a hypothetical compound collider made up of a circle
    and two rectangle colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d0dbfbf-0bad-4e75-b06e-531557aea8f6.png)[A compound collider composed
    of three basic colliders]'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement a basic circle collision
    detection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing circle collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start by implementing circle collision detection because it
    is the fastest collision detection method available. It also fits well with our
    projectiles, which will be the most common kind of collider in our game. It will
    not do a great job on our ships, but later, we can improve that situation by implementing
    a compound collider that will use multiple circle colliders for each spaceship
    instead of just one. Because we only have two spaceships, this will give us the
    best of both worlds in our collision detection: the speed of circle collision
    detection, along with the accuracy of some of our better collision detection methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a `Collider` class definition into our `game.hpp` file
    and creating a new `collider.cpp` file where we can define the functions used
    by our `Collider` class. Here''s what our new `Collider` class will look like
    in the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code we are putting in the `collider.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Collider` class is a pretty simple circle collider. As we discussed earlier,
    a circle collider has an *x* and a *y* coordinate and a radius. The `HitTest`
    function does a pretty simple distance test to see whether the two circles are
    close enough to touch each other. We do this by squaring the *x* distance and
    squaring the *y* distance between the two colliders, which gives us the distance
    squared between the two points. We could take the square root to determine the
    actual distance, but a square root is a relatively slow function to perform, and
    it's much faster to square the sum of the radii to compare.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to talk about class inheritance briefly. If you look back
    at our code from earlier, we have a `PlayerShip` class and an `EnemyShip` class.
    These classes share most of their attributes. They all have *x* and *y* coordinates,
    *x* and *y* velocity, and many other attributes that are identical. Many of the
    functions use the same code copied and pasted. Instead of having this code defined
    twice, let''s go back and create a `Ship` class that has all of the features that
    are common to our `PlayerShip` and `EnemyShip` classes. Then, we can refactor
    our `EnemyShip` and `PlayerShip` classes to inherit from our `Ship` class. Here
    is our new `Ship` class definition that we are adding to `game.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line, `Ship class: public Collider`, tells us that `Ship` will inherit
    all of the public and protected members of the `Collider` class. We are doing
    this because we would like to be able to perform a hit test. The `Collider` class
    also now defines the `m_X` and `m_Y` attribute variables that keep track of the
    *x* and *y* coordinates of our object. We have moved everything common to our
    `EnemyShip` and `PlayerShip` classes into the `Ship` class. You will notice that
    we have one virtual function, `virtual void Move() = 0;`. This line tells us that
    we will have a `Move` function in all classes that inherit from `Ship`, but we
    will need to define `Move` inside those classes instead of directly in the `Ship`
    class. That makes `Ship` an **abstract class**, which means that we cannot create
    an instance of `Ship`, but, instead, it is a class from which other classes will
    inherit.'
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance, abstract classes, and virtual functions are all a part of
    a style of programming known as **Object-Oriented Programming** (**OOP**). C++
    was created in 1979 by Bjarne Stroustrup to add OOP to the C programming language.
    If you're not familiar with OOP, there are hundreds of books that go into great
    detail on this topic. I will only be able to cover it in a cursory manner in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to modify the `PlayerShip` and `EnemyShip` classes in the
    `game.hpp` file to remove all of the methods and attributes we have moved into
    the parent `Ship` class. We will also modify these classes so that they inherit
    from `Ship`. Here is the new version of the class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a `ship.cpp` file and define all of the methods that will
    be common to `EnemyShip` and `PlayerShip`. These methods were in both `PlayerShip`
    and `EnemyShip` previously, but now we can have them all in one place. Here is
    what the `ship.cpp` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only real difference between the versions of these classes that were in
    the `player_ship.cpp` and the `enemy_ship.cpp` files are that, instead of `PlayerShip::`
    or `EnemyShip::` in front of each of the function definitions, we now have `Ship::`
    in front of the function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to need to modify `player_ship.cpp` and `enemy_ship.cpp`
    by removing all of the functions that we now have defined inside the `ship.cpp`
    file. Let''s take a look at what the `enemy_ship.cpp` file looks like broken into
    two parts. The first part is the `#include` of our `game.hpp` file and the `EnemyShip`
    constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of our `enemy_ship.cpp` file we have the `Move` and `AIStub`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have seen what is in the `enemy_ship.cpp` file, let''s take a look
    at what the new `player_ship.cpp` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify the `Move` function in our `ProjectilePool` class so that,
    every time it moves a `Projectile`, it also tests to see whether it hit one of
    our ships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For right now, we are only going to print to the console when either the player
    or the enemy collides with a projectile. That will tell us whether our collision
    detection is working correctly. In later sections, we will add animations to destroy
    our ships when they collide with the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last change we need to make to the `Launch` function on our `Projectile`
    class. When we launch a projectile from our ships, we give the projectile an x
    and a y position and an *x* and *y* velocity based on the direction the ship was
    facing. We need to take that direction and move the starting point of the projectile.
    That is to prevent the projectile from hitting the ship that launched it by moving
    it out of the collision detection circle for the ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will detect when our ship collides with a projectile
    and run an explosion animation.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a spaceship on collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are detecting collisions between the projectiles and the spaceships,
    it would be nice to do something more interesting than printing a line to the
    console. It would be nice to have a little explosion animation for our projectiles
    and our ships when they hit something. We can add an animation associated with
    each of these objects as they are destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of loading multiple sprites for each frame of the animation as we did
    in a previous chapter, I'm going to introduce the concept of **sprite sheets**.
    Instead of loading a single projectile frame and a single ship frame for each
    of our spaceships, we will load a sprite sheet for each that includes not only
    the undamaged version of each but a destruction sequence that we will animate
    through when any of these objects are destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Having three different sprite sheets in this example is done for convenience
    only. When you decide how to pack your sprite sheets for production, there are
    several considerations that you must take into account. You will most likely want
    to break out your sprite sheets based on when you will need them. You may have
    a series of sprites you need that are common to all levels of the game. You may
    choose to break out the sprites based on the level. You also need to take into
    consideration that, for performance reasons WebGL requires power-of-2 sized sprite
    files. That may impact your decisions concerning what sprites to pack into what
    sprite sheets. You may also consider purchasing a tool such as Texture Packer
    to pack sprites for you more quickly than you could do by hand.
  prefs: []
  type: TYPE_NORMAL
- en: We have created three sprite sheets to replace the three sprites we were using.
    These `Sprites` are `FranchiseExp.png` to replace `Franchise.png`, `BirdOfAngerExp.png`
    to replace `BirdOfAnger.png`, and `ProjectileExp.png` to replace `Projectile.png`.
    We are going to need to make some tweaks to the `Projectile` class, `Ship` class,
    `EnemyShip` class, `PlayerShip`, and the `ProjectilePool` class, as well as the
    `game_loop` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by modifying the game loop to keep track of the game''s
    timing data. We must remove some code from the `PlayerShip::Move` function inside
    the `player_ship.cpp` file. This code existed from [Chapter 4](f14c80d0-2d87-45b1-96ab-a3305ad35c50.xhtml),
    *Sprite Animations in WebAssembly with SDL*, where we discussed the basics of
    animating a sprite by animating `PlayerShip`. We must delete the following code
    from the first several lines of `PlayerShip::Move`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gets the current time and calculates all of our time-related information
    we use for speed adjustments and animation timing. We probably should have moved
    this code to the game loop a few chapters ago, but better late than never. The
    following is the code for the new `game_loop` function in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Strictly speaking, we did not have to make this change, but it makes more sense
    to have the game timing code within the game loop. Now that we have changed our
    game loop, we are going to modify the `Projectile` class. Here are the changes
    to the class definition we must make from within the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need to modify the `c_SpriteFile` variable to point to the new sprite sheet
    PNG file instead of the single sprite file. We need to increase the size of its
    width and height. To make space for the explosion, we will make all frames in
    the sprite sheet 16 x 16 instead of 8 x 8\. We also need a source rectangle. When
    each sprite has used an entire file, we could pass in `null` to `SDL_RenderCopy`,
    and the function would render the entire contents of the sprite file. Now we only
    want to render one frame, so we need a rectangle that will start at 0,0 and render
    the width and height of 16\. The sprite sheets we have created are **horizontal
    strip sprite sheets**, meaning that every frame is laid out in order and placed
    horizontally. To render a different frame of our animation, we will only need
    to modify the `.x` value inside our source rectangle. The final attribute we added
    is to the public section and is the `m_CurrentFrame` attribute. That tracks which
    frame in the animation we are currently on. We will keep our current frame at
    0 when we are not rendering the explosion animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to modify a few functions on the `Projectile` class. These
    functions are the `Projectile::Move` function and the `Projectile::Render` function
    inside of the `projectile.cpp` file. Here is the new version of the `Projectile::Move`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The top section of the `Move` function is all new. If the current frame is not
    `0`, we will run through the animation until it ends and then deactivate our projectile,
    sending it back to the projectile pool. We do this by subtracting the time since
    the app last ran the game loop. That is the value stored in the `diff_time` global
    variable. The `m_NextFrameTime` attribute variable stores the number of milliseconds
    until we switch to the next frame in our series. Once the values are below 0,
    we increment our current frame and reset `m_NextFrameTime` to the number of milliseconds
    we want between each new frame of our animation. Now that we have incremented
    the current animation frame, we can check to see whether it is greater than or
    equal to the frame number of the last frame in this animation (in this case, 4).
    If so, we need to deactivate the projectile and reset the current frame to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that we have made the changes we need to make to the `Move()` function,
    here are the changes we must make to the `Projectile::Render()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first change to the `Render` function is the addition of the `src` rectangle
    to the `SDL_RenderCopy` call, as well as setting its *x* value immediately above
    that call. Each frame in our sprite sheet is 16 pixels wide, so setting the *x*
    value to `16 * m_CurrentFrame` will select a different 16 x 16 sprite from the
    sprite sheet. The width and height of that rectangle will always be 16, and the
    *y* value will always be 0 because we placed the sprites into this sprite sheet
    as a horizontal strip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to make some modifications to the `Ship` class definitions
    inside the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We modified the width and height constants to reflect the new sprite size of
    32 x 32 pixels as it appears in our sprite sheet. We also must add a source rectangle
    to the `Projectile` class. Inside our public attributes section, we have added
    a few variables to track the alive or dead status of the ship, `(m_Alive)`; the
    current frame the game is rendering, `(m_CurrentFrame)`; and the time in milliseconds
    until we render the next frame, `(m_NextFrameTime)`. Next, we will make the necessary
    modifications to the `ship.cpp` file. We need to modify the `Ship::Render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the function, we have added code to check to see whether the
    ship is currently alive. If it is not, we do not want to render the ship, so we
    return. Later on, we set the source rectangle *x* value to 32 times the current
    frame with the line: `src.x = 32 * m_CurrentFrame;`. That changes our render to
    render a different 32 x 32 block of pixels from our sprite sheet based on the
    frame we want to render. Lastly, we must pass that `src` rectangle into the call
    to `SDL_RenderCopyEx`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have modified the `Ship` class, we will change the `EnemyShip`
    class definition and the `PlayerShip` class definition to use our sprite sheet
    PNG files instead of the old single sprite files. Here are the modifications to
    those two class definitions inside the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only changes made to these class definitions are to the values of the `c_SpriteFile`
    constant in each class. The `c_SpriteFile` constant in the `PlayerShip` class
    was modified from `"sprites/Franchise.png"` to `"sprites/FranchiseExp.png"`, and
    the `c_SpriteFile` constant in `EnemyShip` was modified from `"sprites/BirdOfAnger.png"`
    to `"sprites/BirdOfAngerExp.png"`. Now that we have made that change, these classes
    will use the sprite sheet `.png` files instead of the original sprite files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have modified the definitions for these classes, we must change
    the `Move` functions for each of them. First, we will revise the `EnemyShip::Move`
    function inside the `enemy_ship.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two places where the code must be changed. First, we do not want
    to do any of the `Move` function''s work if the enemy ship is not alive, so we
    added this check at the beginning of the function to return if the ship is not
    alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we needed to add the code to check whether we needed to run the death
    animation. We do this if the current frame is greater than 0\. The code in this
    section is similar to what we did for the projectile to run its death animation.
    We subtract the time between frames, `(diff_time)`, from the next frame time,
    `(m_NextFrameTime)`, to determine whether we need to increment the frame. When
    this value drops below 0, the frame is ready to change by incrementing `m_CurrentFrame`,
    and we reset the `m_NextFrameTime` countdown timer by setting it to the number
    of milliseconds we want between each frame, `(ms_per_frame)`. If our current frame
    hits the end of our frame sprite sheet, `(++m_CurrentFrame >= 8)`, then we set
    the enemy ship to no longer be alive, `(m_Alive = false)`. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will make the same changes to the `PlayerShip::Move` function within
    the `player_ship.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in our `EnemyShip::Move` functions, we add a check to see whether
    the player is alive with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And we also add some code to run the death animation if our current frame is
    greater than 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is modify the collision detection code we added
    earlier to the `ProjectilePool::MoveProjectiles` function to run the death animation
    for a ship and a projectile if the two collide. Here is the new version of `ProjectilePool::MoveProjectiles`
    inside of the `projectile_pool.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inside of this code, every time we move a projectile, we do a hit test against
    that projectile and the player as well as a hit test between that projectile and
    the enemy. If either the ship or the projectile is running its death animation
    (`m_CurrentFrame == 0` is false), then we do not need to run the hit test because
    the ship or the projectile has already been destroyed. If the hit test returns
    true, then we need to set the current frame of both the projectile and the ship
    to 1 to begin the destruction animation. We also need to set the next frame time
    to the number of milliseconds until the frame changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added all of this new code, the ship and the enemy ship will
    run an explosion animation that destroys the ship when hit. The projectiles will
    also explode instead of just disappearing. The circle colliders are fast but not
    very precise. In the *Implementing compound circle colliders* section, we will
    learn the modifications we need to make to use multiple circle colliders on a
    single ship. That will give us collisions that look more accurate than simple
    circles.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers in memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly's memory model piggybacks on the asm.js memory model, which uses
    a large typed `ArrayBuffer` to hold all of the raw bytes to be manipulated by
    the module. A JavaScript call to `WebAssembly.Memory` sets up the module's memory
    buffer in 64 KB **pages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *page* is a block of linear data that is the smallest unit of data that can
    be allocated by an operating system, or, in the case of WebAssembly, a virtual
    machine. For more information on memory pages, see the Wikipedia Page: [https://en.wikipedia.org/wiki/Page_%28computer_memory%29](https://en.wikipedia.org/wiki/Page_%28computer_memory%29).'
  prefs: []
  type: TYPE_NORMAL
- en: A WebAssembly module can only access data from within this `ArrayBuffer`. That
    prevents malicious attacks from WebAssembly that create a pointer to a memory
    address outside the browser's sandbox. Because of this design, WebAssembly's memory
    model is just as safe as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will be using C++ pointers in our `collider` object.
    If you are a JavaScript developer, you may not be familiar with **pointers**.
    A pointer is a variable that holds a memory location instead of the value directly.
    Let''s look at a little bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have created a `VAR1` variable and given it a value of 1\.
    In the second line, we use `int*` to create a pointer called `POINTER`. We then
    initialize that pointer to the address of `VAR1` using the `&` character, which,
    in C++, is known as the **address of operator**. This operator gives us the address
    of the `VAR1` that we declared earlier. If we then want to change `VAR1`, we can
    do so using the pointer instead of directly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Putting the `*` in front of `POINTER` tells C++ to set the value in the memory
    address where `POINTER` is pointing; `*` when used in this way is called the **dereference
    operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to learn more about pointers in C++ and how they work, the
    following article goes into a good deal of detail on the subject: [http://www.cplusplus.com/doc/tutorial/pointers/](http://www.cplusplus.com/doc/tutorial/pointers/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement compound circle colliders for collision
    detection on our spaceships.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing compound circle colliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our collision detection is working, and we have our ships and projectiles
    exploding on a collision, let''s see how we can make our collision detection better.
    We chose circle collision detection for two reasons: the collision algorithm is
    fast, and it is simple. We could do better, however, by merely adding more circles
    to each ship. That will increase our collision detection time by a factor of *n*,
    where *n* is the average number of circles we have on each ship. That is because
    the only collision detection we do is between the projectiles and the ships. Even
    so, we don''t want to go overboard with the number of circles we choose to use
    for each ship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the player ship, the front of the spaceship is covered well by the basic
    circle. However, we could get much better coverage of the back of the player''s
    spaceship by adding a circle to each side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb6abb5f-7d27-4e56-a72b-f41d7f92dde3.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Our player ship compound collider]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The enemy ship is the opposite. The back of that spaceship is covered pretty
    well by a default circle, but the front could use some better coverage, so, for
    the enemy ship, we will add some additional circles in front:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45d21650-582a-4d43-9686-a132f6146e36.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Our enemy ship compound collider]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is change the `Collider` class to include information
    from the parent of our collider. Here is the new version of the `Collider` class
    definition inside our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have added three-pointers to attributes of the parent of our `Collider` class.
    These will point to the *x* and *y* coordinates, as well as the `Rotation` of
    the collider's parent, which will either be the enemy ship, the player ship, or
    `NULL`. We will initialize those values to `NULL` in our constructor, and if the
    value is null, we will not modify the behavior of our collider. If, however, those
    values are set to something else, we will call the `CCHitTest` function to determine
    whether there is a collision. This version of the hit test will adjust the position
    of the collider to be relative to its parent's position and rotation before doing
    the collision test. Now that we have made the changes to the collider's definition,
    we will make changes to the functions inside the `collider.cpp` file to support
    the new compound colliders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is modify our constructor to initialize the new pointers
    to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a new function to add to our `collider.cpp` file, the `CCHitTest` function,
    which will be our compound collider hit test. This version of the hit test will
    adjust the *x* and *y* coordinates of our collider to be relative to the position
    and rotation of our parent ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing this function does is take the sine and cosine of the parent''s
    rotation and use that rotation to get a rotated version of *x* and *y* in the
    variables, `rx` and `ry`. We then adjust that rotated *x* and *y* position by
    the parent''s *x* and *y* position, before calculating the distance between the
    two collider *x* and *y* positions. After we add this new `CCHitTest` function,
    we need to modify the `HitTest` function to call this version of the hit test
    if the parent values are set. Here is the latest version of `HitTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a function to set all of these values called `SetParentInformation`.
    Here is the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To take advantage of these new kinds of colliders, we need to add a new vector
    of colliders into the `Ship` class. The following is the new class definition
    for `Ship` in the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two differences between this version and the previous version of
    the `Ship` class. The first is the addition of the `m_Colliders` vector attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change is the new `CompoundHitTest` function added at the bottom
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For the change to our class, we will need to add a new function to our `ship.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This `CompoundHitTest` function is a pretty simple function that loops over
    all of our additional colliders and performs a hit test on them. This line creates
    a vector of collider pointers. We will now modify our `EnemyShip` and `PlayerShip`
    constructors to add some colliders into this vector. First, we will add some new
    lines to the `EnemyShip` constructor inside the `enemy_ship.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that we added creates new colliders and sets the parent information
    for those colliders as pointers to the *x* and *y* coordinates, as well as the
    radius to the addresses of those values inside of this object. We set the `m_X`
    and `m_Y` values for this collider relative to the position of this object, and
    then we push the new colliders into the `m_Colliders` vector attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now do something similar for the `PlayerShip` constructor inside the
    `player_ship.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to change our projectile pool to run the collision detection on
    these new compound colliders in our ships. Here is the modified version of the
    `MoveProjectiles` function inside the `projectile_pool.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Because we continue to inherit `Collider` in our `Ship` class, we still will
    perform a regular hit test on our player and enemy ships. We have added a call
    to `CompoundHitTest` in our `Ship` class that loops over our `m_Colliders` vector
    and performs a collision hit test on each of the colliders in that vector.
  prefs: []
  type: TYPE_NORMAL
- en: Our compound collider solution is not generalized, and, for the most part, neither
    is our collision detection. We are only detecting collisions between our ships
    and our projectiles. We are not currently performing any collision detection between
    our ships. To have a generalized approach to collision detection, we would need
    to implement spacial segmenting. That would prevent the number of collision checks
    from growing exponentially with each additional collider added to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling collider.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command we use to compile our `collider.html` file is similar to our compile
    command in the last chapter. We will need to add a new `collider.cpp` file into
    the command line, but other than that it should be the same. Here is the command
    you use to compile `collider.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have `collider.html` compiled, we can serve it from our web server
    of choice, or run it with `emrun`, and load it into a web browser. Here is what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72206918-5f5b-4dac-8585-fb42d096df04.png)[The enemy spaceship explodes
    when hit by a projectile]'
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  prefs: []
  type: TYPE_NORMAL
- en: I did not take a screenshot of the entire browser as I have in previous screenshots
    of the game because I wanted to zoom in on the player ship destroying the enemy
    ship. As you can see, we now have colliders that can detect when a projectile
    collides with a spaceship and can destroy that spaceship when the collision happens
    by running an explosion animation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Circle colliders are what we need right now. They are fast and efficient, and,
    for a simple game such as this, you might be able to get away with not doing anything
    more sophisticated. We added in a compound collider to demonstrate how this simple
    modification could significantly increase the accuracy of your collider. We will
    need to add more collision detection methods later in this book. In the future,
    we will be adding asteroids and a star to our game, and we will be creating an
    **AI** (**Artificial Intelligence**) agent to navigate our game and attack our
    player. This agent will eventually need to know whether it has a line of sight
    with the player so that line collision detection will become more important. Our
    agent will also want to quickly scan the area close to it to see whether there
    are any asteroids it must avoid. For this feature, we will be using rectangle
    collision.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of collision detection techniques for 2D games, and we
    have only scratched the surface in this chapter. We learned how to implement some
    basic circle colliders and compound colliders, and we added code that detects
    collisions between the projectiles in our game and the player and enemy spaceships.
    These kinds of colliders are fast and relatively easy to implement, but they are
    not without their drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback you may notice with simple colliders such as the ones we have implemented
    is that, if two objects pass each other with a high enough relative velocity,
    it is possible they could pass through each other without colliding. That is because
    our objects have a new position calculated every frame, and they do not continuously
    move from point A to point B. If it takes one frame to move from point A to point
    B, the object effectively teleports between the two points. If there was a second
    object in between those two points, but we are not colliding with that object
    when at either point A or point B, the object collision is missed. That should
    not be a problem in our game because we will be keeping our maximum object velocities
    relatively low. It is, however, something to keep in mind when writing your games.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be building a tool to help us to configure **particle
    systems**.
  prefs: []
  type: TYPE_NORMAL
