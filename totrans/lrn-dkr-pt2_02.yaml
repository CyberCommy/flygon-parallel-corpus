- en: Chapter 2. Handling Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explained stimulating and sustainable concepts,
    which showed the Docker's way of crafting futuristic and flexible application-aware
    containers. We discussed all the relevant details of producing the Docker containers
    in multiple environments (on-premise as well as off-premise). Using these techniques,
    you can easily replicate these features in your own environments to get a rewarding
    experience. Therefore, the next step for us is to understand the container's life
    cycle aspects in a decisive manner. You will learn the optimal utilization of
    containers of our own as well as those of other third-party containers in an effective
    and risk-free way. Containers are to be found, assessed, accessed, and leveraged
    toward bigger and better applications. There are several tools that have emerged
    to streamline the handling of containers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dig deeper and describe the critical aspects of container
    handling at length. A number of practical tips and execution commands for the
    leveraging of containers will also be discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Clarifying the Docker terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Docker images and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The meaning of the Docker registry and its repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Hub Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with an interactive container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the changes inside the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling and housekeeping the Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images from containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching a container as a daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clarifying the Docker terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make this chapter substantially simpler to understand and to minimize any
    kind of ambiguity, the frequently used terms will be explained in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images and containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker image** is a collection of all of the files that make up a software
    application. Each change that is made to the original image is stored in a separate
    layer. To be precise, any Docker image has to originate from a base image according
    to the various requirements. Additional modules can be attached to the base image
    for deriving the various images that can exhibit the preferred behavior. Each
    time you commit to a Docker image you are creating a new layer on the Docker image,
    but the original image and each pre-existing layer remains unchanged. In other
    words, images are typically of the read-only type. If they are empowered through
    the systematic attachment of newer modules, then a fresh image will be created
    with a new name. The Docker images are turning out to be a viable base for developing
    and deploying the Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A base image has been illustrated here. Debian is the base image, and a variety
    of desired capabilities in the form of functional modules can be incorporated
    on the base image for arriving at multiple images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker images and containers](graphics/B03936_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every image has a unique `ID`, as explained in the following section. The base
    images can be enhanced such that they can create the parent images, which in turn
    can be used for creating the child images. The base image does not have any parent,
    that is, the parent images sit on top of the base image. When we work with an
    image and if we don't specify that image through an appropriate identity (say,
    a new name), then the `latest` image (recently generated) will always be identified
    and used by the Docker engine.
  prefs: []
  type: TYPE_NORMAL
- en: As per the Docker home page, a Docker image has a read-only template. For example,
    an image could contain an Ubuntu operating system, with Apache and your web application
    installed on it. Docker provides a simple way for building new images or of updating
    the existing images. You can also download the Docker images that the other people
    have already created. The Docker images are the building components of the Docker
    containers. In general, the base Docker image represents an operating system,
    and in the case of Linux, the base image can be one of its distributions, such
    as Debian. Adding additional modules to the base image ultimately dawns a container.
    The easiest way of thinking about a container is as the read-write layer that
    sits on one or more read-only images. When the container is run, the Docker engine
    not only merges all of the required images together, but it also merges the changes
    from the read-write layer into the container itself. This makes it a self-contained,
    extensible, and executable system. The changes can be merged by using the Docker
    `docker commit` subcommand. The new container will accommodate all the changes
    that are made to the base image. The new image will form a new layer on top of
    the base image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will tell you everything clearly. The base image is the
    **Debian** distribution, then there is an addition of two images (the **emacs**
    and the **Apache** server), and this will result in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker images and containers](graphics/B03936_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each commit invariably makes a new image. This makes the number of images go
    up steadily, and so managing them becomes a complicated affair. However, the storage
    space is not a big challenge because the new image that is generated is only comprised
    of the newly added modules. In a way, this is similar to the popular object storage
    in the cloud environments. Every time you update an object, there will be a new
    object that gets created with the latest modification and then it is stored with
    a new `ID`. In the case of object storage, the storage size balloons significantly.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker layer** could represent either read-only images or read-write images.
    However, the top layer of a container stack is always the read-write (writable)
    layer, which hosts a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the preceding diagram, it is clear that the read-write layer is the container
    layer. There could be several read-only images beneath the container layer. Typically,
    a container originates from a read-only image through the act of a `commit`. When
    you `start` a container, you actually refer to an image through its unique `ID`.
    Docker pulls the required image and its parent image. It continues to pull all
    the parent images until it reaches the base image.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker Registry** is a place where the Docker images can be stored in order
    to be publicly found, accessed, and used by the worldwide developers for quickly
    crafting fresh and composite applications without any risks. Because all the stored
    images would have gone through multiple validations, verifications, and refinements,
    the quality of those images will be really high. Using the Docker `push` command,
    you can dispatch your Docker image to the Registry so that it is registered and
    deposited. As a clarification, the registry is for registering the Docker images,
    whereas the repository is for storing those registered Docker images in a publicly
    discoverable and centralized place. A Docker image is stored within a Repository
    in the Docker Registry. Each Repository is unique for each user or account.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker Repository** is a namespace that is used for storing a Docker image.
    For instance, if your app is named `helloworld` and your username or namespace
    for the Registry is `thedockerbook` then, in the Docker Repository, where this
    image would be stored in the Docker Registry would be named `thedockerbook/helloworld`.
  prefs: []
  type: TYPE_NORMAL
- en: The base images are stored in the Docker Repository. The base images are the
    fountainheads for realizing the bigger and better images with the help of a careful
    addition of new modules. The child images are the ones that have their own parent
    images. The base image does not have any parent image. The images sitting on a
    base image are named as parent images because the parent images bear the child
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we demonstrated the typical `Hello World!` example
    by using a `busybox` image. Now there is a need for a close observation of the
    output of the `docker pull` subcommand, which is a standard command for downloading
    the Docker images. You would have noticed the presence of the `busybox:latest`
    text in the output text, and we will explain this mystery in a detailed manner
    by bringing in a small twist to the `docker pull` subcommand by adding the `-a`
    option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprisingly, you will observe that the Docker engine downloads a few more
    images with the `-a` option. You can easily check the images that are available
    on the Docker host by running the `docker images` subcommand, which comes in handy,
    and it reveals more details with respect to `:latest` and the additional images
    that are downloaded by running this command. Let us run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the list of images, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Evidently, we have five items in the preceding list, and to gain a better understanding
    of those, we need to comprehend the information that is printed out by the Docker
    images subcommand. Here is a list of the possible categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`REPOSITORY`: This is the name of the repository or image. In the preceding
    example, the repository name is `busybox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAG`: This is the tag associated with the image, for example `buildroot-2014.02`,
    `ubuntu-14.04`, `latest`. One or more tags can be associated with one image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ubuntu-`* tagged images are built by using the `busybox-static` Ubuntu
    package and the `buildroot-`* tagged images are built from scratch by using the
    `buildroot` tool-chain.
  prefs: []
  type: TYPE_NORMAL
- en: '`IMAGE ID`: Every image is associated with a unique `ID`. The image `ID` is
    represented by using a 64 Hex digit long random number. By default, the Docker
    images subcommand will only show 12 Hex digits. You can display all the 64 Hex
    digits by using the `--no-trunc` flag (for example: `sudo docker images --no-trunc`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATED`: Indicates the time when the image was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIRTUAL SIZE`: Highlights the virtual size of the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be wondering how, in the preceding example, a single `pull` command
    with the `-a` option was able to download five images, even though we had only
    specified one image by the name of `busybox`. This happened because each Docker
    image repository can have multiple variants of the same image and the `-a` option
    downloads all the variants that are associated with that image. In the preceding
    example, the variants are tagged as `buildroot-2013.08.1`, `ubuntu-14.04`, `ubuntu-12.04`,
    `buildroot-2014.02` and `latest`. A closer observation of the image IDs will reveal
    that both `buildroot-2014.02` and `latest` share the image ID `4986bf8c1536`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Docker always uses the image that is tagged as `latest`. Each image
    variant can be directly identified by qualifying it with its tag. An image can
    be tag-qualified by appending the tag to the repository name with a `:` that is
    added between the tag and the repository name (`<repository>:<tag>`). For instance,
    you can launch a container with the `busybox:ubuntu-14.04` tag, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker pull` subcommand will always download the image variant that has
    the `latest` tag in that repository. However, if you choose to download an image
    variant other than the latest, then you can do so by qualifying your image with
    the tag name by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Docker Hub Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, when you ran the `docker pull` subcommand, the `busybox`
    image got downloaded mysteriously. In this section, let's unravel the mystery
    around the `docker pull` subcommand and how the Docker Hub immensely contributed
    toward this unintended success.
  prefs: []
  type: TYPE_NORMAL
- en: The good folks in the Docker community have built a repository of images and
    they have made it publicly available at a default location, `index.docker.io`.
    This default location is called the Docker index. The `docker pull` subcommand
    is programmed to look for the images at this location. Therefore, when you `pull`
    a `busybox` image, it is effortlessly downloaded from the default registry. This
    mechanism helps in speeding up the spinning of the Docker containers. The Docker
    Index is the official repository that contains all the painstakingly curated images
    that are created and deposited by the worldwide Docker development community.
  prefs: []
  type: TYPE_NORMAL
- en: This so-called cure is enacted to ensure that all the images stored in the Docker
    index are secure and safe through a host of quarantine tasks. There are proven
    verification and validation methods for cleaning up any knowingly or unknowingly
    introduced malware, adware, viruses, and so on, from these Docker images. The
    digital signature is a prominent mechanism of the utmost integrity of the Docker
    images. Nonetheless, if the official image has been either corrupted, or tampered
    with, then the Docker engine will issue a warning and then continue to run the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the official repository, the Docker Hub Registry also provides
    a platform for the third-party developers and providers for sharing their images
    for general consumption. The third-party images are prefixed by the user ID of
    their developers or depositors. For example, `thedockerbook/helloworld` is a third-party
    image, wherein `thedockerbook` is the user ID and `helloworld` is the image repository
    name. You can download any third-party image by using the `docker pull` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the preceding repository, the Docker ecosystem also provides a mechanism
    for leveraging the images from any third-party repository hub other than the Docker
    Hub Registry, and it provides the images hosted by the local repository hubs.
    As mentioned earlier, the Docker engine has been programmed to look for images
    in `index.docker.io` by default, whereas in the case of the third-party or the
    local repository hub, we must manually specify the path from where the image should
    be pulled. A manual repository path is similar to a URL without a protocol specifier,
    such as `https://`, `http://` and `ftp://`. Following is an example of pulling
    an image from a third party repository hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Searching Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the previous section, the Docker Hub repository typically
    hosts both the official images as well as the images that have been contributed
    by the third-party Docker enthusiasts. At the time of writing this book, more
    than 14,000 images (also called the Dockerized application) were available for
    the users. These images can be used either as is, or as a building block for the
    user-specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can search for the Docker images in the Docker Hub Registry by using the
    `docker search` subcommand, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The search on `mysql` will list 400 odd images, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding search output excerpts, the images are ordered
    based on their star rating. The search result also indicates whether or not the
    image is official. In order to stay in focus, in this example, we will show only
    two images. Here, you can see the official version of `mysql`, which pulls a `147`
    star rating image as its first result. The second result shows that this version
    of the `mysql` image was published by the user `tutum`. The Docker containers
    are fast becoming the standard for the building blocks of the distributed applications.
    A dynamic repository of the Docker images will be realized with the help of the
    enthusiastic contribution of several community members across the globe. The Repository-based
    software engineering will make it easier for users and programmers to quickly
    code and assemble their projects. The official repositories can be freely downloaded
    from the Docker Hub Registry, and these are curated images. They represent a community
    effort that is focused on providing a great base of images for applications, so
    that the developers and the system administrators can focus on building new features
    and functionalities, while minimizing their repetitive work on commodity scaffolding
    and plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the search queries in the Docker Hub Registry and the discussions with
    many of the developer community members, the Docker company, which spearheaded
    the Docker movement so powerfully and passionately, came to the conclusion that
    the developer community wanted pre-built stacks of their favorite programming
    languages. Specifically, the developers wanted to get to work as quickly as possible
    writing code without wasting time wrestling with environments, scaffolding, and
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Working with an interactive container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we ran our first `Hello World!` container to get a feel
    of how the containerization technology works. In this section, we are going to
    run a container in an interactive mode. The `docker run` subcommand takes an image
    as an input and launches it as a container. You have to pass the `-t` and `-i`
    flags to the docker run subcommand in order to make the container interactive.
    The `-i` flag is the key driver, which makes the container interactive by grabbing
    the standard input (`STDIN`) of the container. The `-t` flag allocates a pseudo-TTY
    or a pseudo terminal (terminal emulator) and then assigns that to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are going to launch an interactive container by
    using the `ubuntu:14.04` image and `/bin/bash` as the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `ubuntu` image has not been downloaded yet, if we use the `docker
    pull` subcommand, then we will get the following message and the `run` command
    will start pulling the `ubuntu` image automatically with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as the download is completed, the container will be launched along
    with the `ubuntu:14.04` image. It will also launch a bash shell within the container,
    because we have specified `/bin/bash` as the command to be executed. This will
    land us in a bash prompt, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding bash prompt will confirm that our container has been launched
    successfully, and it is ready to take our input. If you are wondering about the
    Hex number `742718c21816` in the prompt, then it is nothing but the hostname of
    the container. In the Docker parlance, the hostname is the same as the container
    `ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly run a few commands interactively, and then confirm that what
    we mentioned about the prompt is correct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding three commands, it is quite evident that the prompt was composed
    by using the user ID, the hostname, and the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use one of the niche features of Docker for detaching it from the
    interactive container and then look at the details that Docker manages for this
    container. Yes, we can detach it from our container by using the *Ctrl* + *P*
    and *Ctrl* + *Q* escape sequence. This escape sequence will detach the TTY from
    the container and land us in the Docker host prompt `$`, however the container
    will continue to run. The `docker ps` subcommand will list all the running containers
    and their important properties, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker ps` subcommand will list out the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINER ID`: This shows the container `ID` associated with the container.
    The container `ID` is a 64 Hex digit long random number. By default, the `docker
    ps` subcommand will show only 12 Hex digits. You can display all the 64 digits
    by using the `--no-trunc` flag (for example: `sudo docker ps --no-trunc`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMAGE`: This shows the image from which the Docker container has been crafted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND`: This shows you the command executed during the container launch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATED`: This tells you when the container was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATUS`: This tells you the current status of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PORTS`: This tells you if any port has been assigned to the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAMES`: The Docker engine auto-generates a random container name by concatenating
    an adjective and a noun. Either the container `ID` or its name can be used to
    take further action on the container. The container name can be manually configured
    by using the `--name` option in the `docker run` subcommand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having looked at the container status, let''s attach it back to our container
    by using the `docker attach` subcommand as shown in the following example. We
    can either use the container `ID` or use its name. In this example, we have used
    the container name. If you don''t see the prompt, then press the *Enter* key again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker allows attaching with a container any number of times, which proves
    to be very handy for screen sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker attach` subcommand takes us back to the container prompt. Let''s
    experiment a little more with the interactive container that is up and running
    by using these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the bash exit command is issued to the interactive container, it
    will terminate the bash shell process, which in turn will stop the container.
    As a result, we will land on the Docker Host's prompt `$`.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking changes inside containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we demonstrated how to craft a container taking `ubuntu`
    as a base image, and then running some basic commands, such as detaching and attaching
    the containers. In that process, we also exposed you to the `docker ps` subcommand,
    which provides the basic container management functionality. In this section,
    we will demonstrate how we can effectively track the changes that we introduced
    in our container and compare it with the image from which we launched the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s launch a container in the interactive mode, as we had done in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the directory to `/home`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create three empty files by using the `touch` command as shown in
    the following code snippet. The first `ls -l` command will show that there are
    no files in the directory and the second `ls -l` command will show that there
    are three empty files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker engine elegantly manages its filesystem and it allows us to inspect
    a container filesystem by using the `docker diff` subcommand. In order to inspect
    the container filesystem, we can either detach it from the container or use another
    terminal of our Docker host and then issue the `docker diff` subcommand. Since
    we know that any `ubuntu` container has its hostname, which is a part of its prompt,
    and it is also the container''s `ID`, we can directly run the `docker diff` subcommand
    by using the container `ID` that is taken from the prompt, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the given example, the `docker diff` subcommand will generate four lines,
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output indicates that the `/home` directory has been modified,
    which has been denoted by `C,` and the `/home/abc`, `/home/cde` and the `/home/fgh`
    files have been added, and these are denoted by `A`. In addition, `D` denotes
    deletion. Since we have not deleted any files, it is not in our sample output.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Docker containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have discussed a few practical examples for clearly articulating
    the nitty-gritty of the Docker containers. In this section, let us introduce a
    few basic as well as a few advanced command structures for meticulously illustrating
    how the Docker containers can be managed.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker engine enables you to `start`, `stop`, and `restart` a container
    with a set of `docker` subcommands. Let's begin with the `docker stop` subcommand,
    which stops a running container. When a user issues this command, the Docker engine
    sends SIGTERM (-15) to the main process, which is running inside the container.
    The **SIGTERM** signal requests the process to terminate itself gracefully. Most
    of the processes would handle this signal and facilitate a graceful exit. However,
    if this process fails to do so, then the Docker engine will wait for a grace period.
    Even after the grace period, if the process has not been terminated, then the
    Docker engine will forcefully terminate the process. The forceful termination
    is achieved by sending SIGKILL (-9). The **SIGKILL** signal cannot be caught or
    ignored, and so it will result in an abrupt termination of the process without
    a proper clean-up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s launch our container and experiment with the `docker stop` subcommand,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Having launched the container, let''s run the `docker stop` subcommand on this
    container by using the container `ID` that was taken from the prompt. Of course,
    we have to use a second screen or terminal to run this command, and the command
    will always echo back to the container `ID`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we switch to the screen or terminal, where we were running the container,
    we will notice that the container is being terminated. If you observe a little
    more closely, you will also notice the text `exit` next to the container prompt.
    This has happened due to the SIGTERM handling mechanism of the bash shell, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take it one step further and run the `docker ps` subcommand, then we
    will not find this container anywhere in the list. The fact is that the `docker
    ps` subcommand, by default, always lists the container that is in the running
    state. Since our container is in the stopped state, it has been comfortably left
    out of the list. Now, you might ask, how do we see the container that is in the
    stopped state? Well, the `docker ps` subcommand takes an additional argument `-a`,
    which will list all the containers in that Docker host irrespective of its status.
    This can be done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at the `docker start` subcommand, which is used for starting
    one or more stopped containers. A container could be moved to the stopped state
    either by the `docker stop` subcommand or by terminating the main process in the
    container either normally or abnormally. On a running container, this subcommand
    has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s `start` the previously stopped container by using the `docker start`
    subcommand, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `docker start` subcommand will not attach to the container.
    You can attach it to the container either by using the `-a` option in the `docker
    start` subcommand or by explicitly using the `docker attach` subcommand, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the `docker ps` and verify the container''s running status,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `restart` command is a combination of the `stop` and the `start` functionality.
    In other words, the `restart` command will `stop` a running container by following
    the precise steps followed by the `docker stop` subcommand and then it will initiate
    the `start` process. This functionality will be executed by default through the
    `docker restart` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: The next important set of container-controlling subcommands are `docker pause`
    and `docker unpause`. The `docker pause` subcommands will essentially freeze the
    execution of all the processes within that container. Conversely, the `docker
    unpause` subcommand will unfreeze the execution of all the processes within that
    container and resume the execution from the point where it was frozen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having seen the technical explanation of `pause and unpause`, let''s see a
    detailed example for illustrating how this feature works. We have used two screen
    or terminal scenarios. On one terminal, we have launched our container and used
    an infinite while loop for displaying the date and time, sleeping for 5 seconds,
    and then continuing the loop. We will run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our little script has very faithfully printed the date and time every 5 seconds
    with an exception at the following position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we encountered a delay of 25 seconds, because this is when we initiated
    the `docker pause` subcommand on our container on the second terminal screen,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we paused our container, we looked at the process status by using the
    `docker ps` subcommand on our container, which was on the same screen, and it
    clearly indicated that the container had been paused, as shown in this command
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We continued on to issuing the `docker unpause` subcommand, which unfroze our
    container, continued its execution, and then started printing the date and time,
    as we saw in the preceding command, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We explained the `pause` and the `unpause` commands at the beginning of this
    section. Lastly, the container and the script running within it had been stopped
    by using the `docker stop` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Housekeeping containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many of the previous examples, when we issued `docker ps -a` we saw the many
    stopped containers. These containers could continue to stay in the stopped status
    for ages, if we chose not to intervene. At the outset, it may look like a glitch,
    but in reality, we can perform operations, such as committing an image from a
    container, restarting the stopped container, and so on. However, not all the stopped
    containers will be reused, and each of these unused containers will take up the
    disk space in the filesystem of the Docker host. The Docker engine provides a
    couple of ways to alleviate this issue. Let's start exploring them.
  prefs: []
  type: TYPE_NORMAL
- en: 'During a container startup, we can instruct the Docker engine to clean up the
    container as soon as it reaches the stopped state. For this purpose, the `docker
    run` subcommand supports an `--rm` option (for example: `sudo docker run -i -t
    --rm ubuntu:14.04 /bin/bash`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other alternative is to list all the containers by using the `-a` option
    of the `docker ps` subcommand and then manually remove them by using the `docker
    rm` subcommand, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Two `docker` subcommands, that is, `docker rm` and `docker ps`, could be combined
    to automatically delete all the containers that are not currently running, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, the command inside the back quotes will produce a
    list of the full container IDs of every container, running or otherwise, which
    will become the argument for the `docker rm` subcommand. Unless forced with the
    `-f` option to do otherwise, the `docker rm` subcommand will only remove the container
    that is not in the running state. It will generate the following error for the
    running container and then continue to the next container on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Building images from containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have crafted a handful of containers by using the standard base images
    `busybox` and `ubuntu`. In this section, let us see how we can add more software
    to our base image on a running container and then convert that container into
    an image for future use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take `ubuntu:14.04` as our base image, install the `wget` application,
    and then convert the running container to an image by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch an `ubuntu:14.04` container by using the `docker run` subcommand, shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Having launched the container, let''s quickly verify if `wget` is available
    for our image or not. We have used the `which` command with `wget` as an argument
    for this purpose and, in our case, it returns empty, which essentially means that
    it could not find any `wget` installation in this container. This command is run
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s move on to the next step which involves the `wget` installation.
    Since it is a brand new `ubuntu` container, before installing `wget`, we must
    synchronize with the `ubuntu` package repository, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `ubuntu` package repository synchronization is over, we can proceed
    toward installing `wget`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Having completed the `wget` installation, let''s confirm our installation of
    `wget` by invoking the `which` command with `wget` as an argument, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Installation of any software would alter the base image composition, which
    we can also trace by using the `docker diff` subcommand introduced in *Tracking
    changes inside containers* section of this chapter. From a second terminal or
    screen, we can issue the `docker diff` subcommand, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command would show a few hundred lines of modification to the
    `ubuntu` image. This modification includes the update on package repository, `wget`
    binary, and the support files for `wget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s move to the most important step of committing the image. The
    Docker `commit` subcommand can be performed on a running or a stopped container.
    When commit is performed on a running container, the Docker engine will pause
    the container during the `commit` operation in order to avoid any data inconsistency.
    We strongly recommend performing the `commit` operation on a stopped container.
    We can commit a container to an image by the `docker commit` subcommand, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have committed our image by using the name `learningdocker/ubuntu_wget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step by step, we saw how to create an image from a container. Now, let''s quickly
    list the images of our Docker host and see if this newly created image is a part
    of the image list by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding `docker images` subcommand output, it is quite evident that
    our image creation from the container has been quite successful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to create an image from the containers by using
    a few easy steps, we would encourage you to predominantly use this method for
    testing purposes. The most elegant and the most recommended way of creating an
    image is to use the `Dockerfile` method, which will be introduced in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a container as a daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already experimented with an interactive container, tracked the changes
    that were made to the containers, created images from the containers and then
    gained insights in the containerization paradigm. Now, let's move on to understanding
    the real workhorse of the Docker technology. Yes that's right. In this section,
    we will walk you through the steps that are required for launching a container
    in the detached mode; in other words, we will learn about the steps that are required
    for launching a container as a daemon. We will also view the text that is generated
    in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker run` subcommand supports an option `-d`, which will launch a container
    in a detached mode, that is, it will launch a container as a daemon. For the purpose
    of illustration, let''s resort to our date and time script, which we used in the
    `pause and unpause` container example, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker logs` subcommand is used for viewing the output generated by our
    daemon container, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the knowledge that is gained in the post-implementation
    phases, primarily regarding the operational aspect of the Docker containers. We
    started the chapter by clarifying important terms, such as images, containers,
    registry, and repository, in order to enable you to acquire an unambiguous understanding
    of the concepts illustrated thereafter. We explained how to search for the images
    in the Docker repository. We also discussed the operation and handling of the
    Docker containers, how to track the changes inside the containers, how to control
    and housekeep the containers. In an easy-to-grasp manner, we will explain the
    process of the Docker image building in the next chapter.
  prefs: []
  type: TYPE_NORMAL
