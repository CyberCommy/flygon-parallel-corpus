- en: Chapter 7. Assessment of Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the techniques of assessing different types
    of devices. We will also look at the methods of testing weak filters during our
    testing engagement. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Assessing routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking the firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying firewall rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tricks of penetrating filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with a methodology to assess what devices are in
    place and how they are protected; it is important to discover the level of skill
    of the administrator that we are going up against. A hardened and well-configured
    environment will present a significant challenge. However, our job as professional
    testers is to accept the challenge, see what we can discover, and draft a report
    of the findings.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will encounter from the testing position of an external attacker
    is most likely a router. There is a chance it will be an appliance, but since
    we work mainly from the standpoint of building ranges for testing, it is unlikely
    we will be able to carry around a device with us. We have shown places to get
    devices earlier in the book; so, if you have the luxury of this, you can build
    your own stationary lab from the information we have provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external architecture we built in the last chapter is our foundation for
    all of the testing we will practice. An example of our layered architecture is
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous diagram shows our entire external architecture, and the first thing
    that we encounter is the router; therefore, it is the first device we will use
    to perform our testing against.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have done in the past throughout the book, we want to concentrate on
    the area of the architecture that we will deal with at the given point of time;
    consequently, for this section, the architecture we will focus on is in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To prepare for this testing, start up your virtual machines for the Router and
    Kali Linux distributions. We will use Kali to carry out the testing of the router.
    After the machines have powered on, log in to both of them with the required usernames
    and passwords that you created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Router machine, you have to start the router, open a terminal window,
    and then enter `dynamips –H 7200` to start the router. Once it starts, you need
    to load the configuration file by opening another terminal window and entering
    `dynagen config.net`. Once the configuration loads, enter `console R1` and access
    the running router and type `en` to enter the privileged mode on the router at
    the router prompt. At this point, we enter `show ip int brief` to show the configuration
    of the router interfaces. The output should be similar to that shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As before, we want to make sure our interfaces are in a state of line and protocol
    `up` as shown in the previous screenshot. Once we have established this, we will
    turn our attention to other matters.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Kali distribution, there are a number of tools we can use when we
    perform testing of our ranges; one of the most popular ones is the network mapping
    tool Nmap. Open a terminal window on Kali and conduct a scan against the router
    interface that is connected to the VMnet8; if you have configured your machine
    to match what we use in the book, you will enter `nmap -sS 192.168.177.10 –n`
    to conduct the scan.
  prefs: []
  type: TYPE_NORMAL
- en: This conducts an SYN or half-open scan of the target, which in this case is
    the f0/0 interface of the router. The `n` option tells Nmap not to do name lookups
    and helps our scan complete faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results of this scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For those of you reading this, you are most likely aware that we have 65536
    possible ports and the tool Nmap is only looking at 1000 of them in the scan.
    This is the default setting for Nmap, so we can change this to scan all the ports,
    and we will do that now. Enter `nmap -sS –p 0-65535 192.168.177.10 –n` to scan
    all the ports possible. If the discovered service is the one you want to attack,
    then you can skip the scan of the entire port range.
  prefs: []
  type: TYPE_NORMAL
- en: This scan will take a long time to complete; you can get a live update by pressing
    the Space bar at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this very long scan completes, there will be only one port open on the
    router, and as such, this serves as our one vector of attack against the router
    itself. An example of the scan when it''s halfway through is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the scan takes a very long time to complete,
    and we especially do not like the fact that the total time taken is increasing.
    This is because the scan has to send packets to all 65536 ports. There are methods
    to speed up the scan, but we will not worry about that here. Since we only have
    one port open on the router, and as such, this is the one vector we have for an
    attack, we can connect to it and see what the response will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that this is just a default configuration of a router,
    and no hardening or anything has taken place; yet, we really do not have much
    attack surface to deal with. We do have the advantage that this is an old IOS
    version of the Cisco software and that might help us going forward, but we will
    try some basic things first. Since there is a port 23 for telnet open, we can
    connect to it and see what the results of the connection are. In a terminal window
    on Kali, enter `telnet 192.168.177.10` to connect to the telnet service on the
    router; an example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The good news is there is a service running on the port and we can connect
    to it; the bad news is the password has never been set, and as such, we cannot
    access the port for long. Another method to connect to the port is to use the
    tool Netcat, and we will try that now to see if there is any difference in the
    results. In the terminal window, enter `nc 192.168.177.10 23` to connect to the
    service with the Netcat tool and see if we have any better luck; an example of
    the result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we don't really get anything of value, so we move on to another
    method. First, we need to realize we are kind of cheating since we know that there
    is only a virtual router. This, of course, is not how it is going to be when you
    do an actual test; therefore, we need to look at how we can determine that we
    are dealing with a router. To do this, we have to look at the network traffic
    at the packet level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anytime we want to know what we are dealing with, always look at it at the packet
    level. Fortunately, we have a great tool included in the Kali distribution, and
    that is Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window in Kali and enter `wireshark &` to start the tool. When
    the tool comes up, you start a capture on the interface that is connected to the
    VMnet8 switch, which should be eth0\. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have verified your settings, click on **Start** to start the capture
    on the eth0 interface. Once the capture has started, conduct another scan against
    the router and review the results in Wireshark. An example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, this is a router that has an access control
    list in place; any time you see an ICMP destination unreachable with the message
    communication administratively filtered, you know you have a router that you will
    encounter. An example of the ACL scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what do we do now? We know there is a router in place, and it has an access
    control list. You will also notice that the results returned now will have an
    ACL in place and will only show one port as being closed. Where did our telnet
    go? The telnet port was open because there was no ACL on that router, but as soon
    as you apply the ACL, the rules are set to the default deny, and as such, all
    that you will see open are the things that the administrator explicitly allowed.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reality of testing. We are fortunate that this administrator has
    not blocked the ICMP reply messages, so we can at least identify that we have
    a router in place. The next thing we can attempt is to see what Nmap tells us
    about the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Nmap tool, we can try to do an enumeration scan. To do this, we can
    use the `–A` option, so we will try this now. In the terminal window, enter the
    `nmap –A 192.168.177.10` command to see what we can gather from the router. An
    example of the results from this scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As it turns out, even the enumeration scan is not of much help. This is because
    the router does not provide much help to the tool. Again, we know that we will
    run into a router, and this is why we have started with it. We see that the port
    80 reports are being closed, so let us investigate this further. An important
    thing to maintain anytime you do your testing is to capture the traffic in Wireshark
    and see how the target responds at the packet level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know we have a port 80 response, we can use it as our next attempt
    to get information. In your terminal window, enter `nmap –sS –p 80 192.168.177.10`
    to direct the scan at the port that provides us with a response; in your Wireshark
    display, you may want to set a filter of `tcp.port == 80` to concentrate on the
    traffic that we send. An example of the results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing Wireshark display (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows us that when we connect to port 80, we get an RST and ACK packet;
    this means the port is closed in accordance with **Request For Comment** (**RFC**).
    Before we continue, a word about RFCs: if you want to master the art of testing,
    especially at the packet level, you need to be familiar with them; however, as
    many of you reading this will more than likely know, they are not exciting to
    read. A site that can help you with information on RFCs is the Network Sorcery
    site; it has excellent information on all the protocols and other network data,
    and it is highly recommended that you spend some time reviewing them when you
    are not sure how something works. You can find the site at [http://www.networksorcery.com/](http://www.networksorcery.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The area you want to focus on is the RFC Sourcebook; an example of the information
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ok, it is time to get back to the task at hand. Why is it that Nmap shows only
    port 80, and no other ports, as closed? We used Wireshark to determine that the
    port responds with RST and ACK flag when a SYN packet is sent to it, so what shall
    we do next?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we can try a few other things to see what the response to the
    port is. We know that the port reports as closed; so, let''s try the HTTPS port
    and see what kind of response we get. In your Wireshark filter, you enter `tcp.port
    == 443`, and it is also a good idea to restart your packet capture. Navigate to
    **Capture** | **Restart** to clean up all the traffic you have collected. In your
    terminal window, enter `nmap –sS –p 443 192.168.177.10` to probe the HTTPS port
    443\. Once the scan reaches completion, note the results. An example of the results
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the previous screenshot, the port is not reported in a
    closed state, but in a filtered state; why the difference? First, let''s look
    at the results in Wireshark. An example of the results from Wireshark is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see from the previous screenshot, there is no response from the target
    now, and that is why Nmap reports it as filtered; so, we see that port 80 generates
    a response and port 443 does not, which tells us that there is some form of rule
    for the port 80 traffic and not for the port 443 traffic. These are the things
    we should be documenting so that when we see it again, we have an idea of what
    is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more attempt to make, and then we will move on to try and get more
    results to go against a router. According to RFC 793, when a port sends a packet
    that contains an illegal flag combination, it should not respond if it is open,
    and it should respond with a packet with the RST flag set if it is closed. We
    will attempt this now. In your terminal window, enter `nmap –sX –p 80 192.168.177.10`
    to send an illegal flag packet to the port; in this case, this is a Christmas
    tree scan. Once the scan is complete, do the same scan again to port 443; enter
    `nmap –sX –p 80 192.168.177.10` and compare the results. An example of the result
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what have we been able to determine? From the previous screenshot, we see
    that the machine that serves as a router does appear to follow RFC 793; this can
    help reduce the possible devices since some vendors such as Microsoft and OpenBSD
    UNIX do not follow RFC. We could also make the assumption that since the majority
    of the market runs Cisco routers, this is probably what we deal with. Unfortunately,
    thus far, we really do not know much about the device flavor, but we do know that
    it runs an ACL and it has a rule in it for port 80.
  prefs: []
  type: TYPE_NORMAL
- en: We have pretty much exhausted the Nmap scan options to go directly against the
    router interface. We will attempt more with the tool when we go through the device;
    for now we will just test the device, and of course, document the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more thing to do before we move on to the next step, and that is
    to verify our assumptions. When we scan with Nmap, port 80 shows as closed, and
    when we try the port 443, we get a filtered report. We assumed that this is because
    there must be some rule in place for port 80 in the ACL. Well, we never want to
    assume, we want to make sure our assumptions are right; therefore, our best option
    is to add a rule for another port and see what happens. We will do that now. In
    your router, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *Z*, and then enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we now have a rule to allow both our port
    80 traffic as well as our port 22 traffic. It is worth noting that since we have
    just entered the rule, there are no matches for it like the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to test our theory. In your Kali distribution, enter `nmap
    192.168.177.10 –n` in the terminal window to conduct a default scan with Nmap.
    As has been discussed earlier, the `n` option will hopefully speed up our scan.
    Once the scan is over, review the results; an example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mission successful! We have now proven that when a router (in this case, a Cisco
    router) has a rule in place for a port, it will respond for that port. We now
    have the information that in this instance there are two ports open; therefore,
    we have two potential vectors to provide us access to the router for our attack.
    We are now ready to move on and try and find ways to attack the router device.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Kali distribution is a penetration testing toolkit, and more than
    likely, someone has come across Cisco routers before, we can turn to it and see
    what it may have to assist us with continuing our testing of the router. In fact,
    not only are there tools within the distribution for Cisco, but it also has its
    own menu item!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kali Linux, navigate to **Applications** | **Kali Linux** | **Vulnerability
    Analysis** | **Cisco Tools**, and display the possible tools which are contained
    within the distribution that works with Cisco routers. An example is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen displaying the possible tools which are contained within the distribution
    that works with Cisco routers (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: As the previous screenshot shows, there are a number of tools to use when we
    encounter a Cisco device. From here, it is largely a matter of experimentation,
    or as we like to say, trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to start is at the top, so we will now take a look at the first
    tool, the cisco-auditing-tool. Once you select it, a window will open and provide
    the options for the tool, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you review the output from the tool, it really is not of much help; where
    is the command to run the tool? Unfortunately, this will sometimes happen in the
    Kali Linux distribution. If we get lucky, we will at least be in the directory
    so that we can figure it out. In your terminal window, enter `ls` followed by
    `pwd` to display the directory we are in, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you review the previous screenshot and your output from the tool, do you
    get lucky? No, it seems the menu didn''t put us in the right directory, it left
    us in the `root` directory. So, what do we do now? Well, we can try a number of
    options, but for now we will not spend too much time on them; we will only look
    at a couple. This is Linux, so we could try the main page; we will do this now.
    In the terminal window, enter `man cisco-auditing-tool` to see if there is a main
    page available. We can probably use a better command name to find it, but we really
    do not have much to go on, so we will just try a few options. An example of this
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, as the previous screenshot shows, we are not doing very well here, and
    this is the reason we will go through the process because this will often be the
    case. So, what do we do now? Well, it is time to bring in the Internet, and after
    a search of the Internet, we discover that the tool in Kali Linux uses the `CAT`
    file. So, we will try that now. In your terminal window, enter `CAT` to see what
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, as the previous screenshot shows, we have found the command for the
    tool. As we review the options, we see that the first option is for a single host;
    so, since we have one device that we target, we will start with that. We will
    enter `CAT –h 192.168.177.10` and observe the output. An example is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output of the previous screenshot, it is obvious that this tool looks
    for telnet port 23 to open, so we know that is not the case. However, we can document
    this tool as one to revisit when we have telnet open.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to try another tool. This is the process when we are testing;
    we want to look at all the different tools and methods to work against the targets
    that we test; therefore, it is imperative that you document what does and does
    not work as it will save you a lot of time when you go against the actual targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tool we will look at, and also the next tool on the list, is the Cisco
    global exploiter. An example of the options for this tool is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we review the options for the tool, we see that the majority of them require
    the web server or the telnet service to be available. Since we know this is not
    the case, we can move on to the next option. However, remember to document the
    tool requirements so that you can test it at another time. We could turn off our
    access list, and then turn the options on for our testing. However, in most cases,
    an administrator is not going to turn these on and they are not on by default.
    They used to be, but like most things in security, they have tightened that up
    and it is no longer the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue trying the different tools, but we will save you the time.
    When we scanned the router, we were not able to find out much information about
    it, so the ACL is pretty much stopping us from discovering much. So, to prove
    this we will now remove the ACL and see if it helps us at all. In your Cisco router,
    enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *Z*, and then execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to verify that the ACL is no longer on the interface. An example of
    this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have cleared the ACL, we can attempt another scan with Nmap. We
    can do a normal default scan, but we will start with the enumeration scan; therefore,
    in the terminal window of Kali Linux, enter `nmap –A 192.168.177.10 –n` and scan
    the target. An example of the results is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wow! What a difference that made! Now, if we can get our targets to not have
    an ACL configured, we can uncover a wealth of information about the target, but
    you will more than likely encounter an ACL, so how do you approach it? Well, in
    the initial discovery, you can ask for the information, and they may provide it.
    You can also try at different locations; while it is very common for the external
    interface to be protected, this is much less common for the inside interface.
    So, in some cases, this will be the best option to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: From here, you will note the different results and then document what works
    and what does not work; furthermore, you will note the different configuration
    changes that you can make and how these changes impact the results. In fact, you
    should now run all of the tools in Kali, and see what the difference is without
    the ACL in place; as always, document your findings.
  prefs: []
  type: TYPE_NORMAL
- en: We can always attack the router if we find something to go on, but more importantly,
    it is the fact that the router is a protection device on the inside that our way
    forward is to see how to get through the router; this is what we will do later
    in the chapter. For now, we want to discuss what the results are when we encounter
    someone using a Linux machine or another device as their router and filtering
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have pretty much exhausted working with a router that we may encounter
    as a perimeter device, it is time to look at the results if and when we encounter
    an environment that uses iptables as its router and to provide ACL capability.
    To do this, we need to bring up the virtual machine we configured iptables on
    in [Chapter 4](ch04.html "Chapter 4. Identifying Range Architecture"), *Identifying
    Range Architecture*. You may want to suspend the machine that we have been using
    as our router to avoid conflicts and system resources. We will revisit the machine
    and the router device later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your virtual machine has come up, log into it with the required credentials
    and open a terminal window. In the terminal window, enter `iptables –L` to display
    the current configuration, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that we have a rule set for the http traffic, so now we know that we
    want to scan the machine using our Kali Linux machine. In your Kali Linux machine,
    open a terminal window and enter `nmap 192.168.177.15` to scan the iptables eth0
    interface. An example of the results of this scan is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous screenshot that shows the results of our scan, we know that
    we have ssh and port 111 open. This is a notable difference from when we scanned
    the router because the iptables are running on the machine; therefore, the results
    will show what is open on the machine. This provides us with some avenue of attack,
    but the problem is we do not have a true test of the iptables rules. This is because
    we are not concerned with the iptables rules; this scan only scanned the interface
    of the machine and had nothing to do with our iptables rules. With the router,
    we had an interface we could scan. Since we do not have that here, we only scan
    the machine; but this is a good way to determine whether you will encounter a
    machine acting as router or an actual router device.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we do now? Well, we have a couple of options. Since ssh is open,
    we could try to brute force it, or if we know we have ports open, it will help
    Nmap do a better job with enumeration. So, we will try that now. In the terminal
    window, enter `nmap –A 192.168.177.15` to do the enumeration scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a portion of this output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of a portion of the output (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: From the previous screenshot, we see that we do have additional information.
    Again, this is because we are just looking at the machine that iptables is on,
    and not the rules. We have a couple of things we can do to get the iptables rules
    involved, but we will save this for later in the chapter. Based on what we see
    here, is there anything else we can do? The answer is yes. We see that we have
    the OpenSSH version, so we can use the techniques we discussed throughout the
    book and try to find any vulnerabilities that may be available for this version
    of SSH. We can do a search on the Internet. As of this writing, there are a couple
    of mentions of Version 6.0 having some denial of service vulnerabilities, but
    since that is rarely asked for in a penetration testing scope of work, we will
    not address them here, and you are welcome to experiment on your own.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing to do before we move on is to look at the traffic at the packet
    level. Start your Wireshark tool by entering `wireshark &` in a terminal window
    in Kali Linux. When the tool opens, start a capture on your eth0 interface by
    navigating to **eth0** | **Capture**. Once the capture has started, run your Nmap
    scan in another terminal window, and then review the results in Wireshark. Since
    we really just want to see if there are any messages to show that we encounter
    in a filter, you can enter a display filter. We will do this now. In the filter
    window, enter `icmp` to see if any ICMP traffic was sent by the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing if any ICMP traffic was sent by the target (the cropped text
    is not important)
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot does show some ICMP, but you will notice none of these
    are the type of ICMP we would have seen if a filter was in place. The packet 1702
    is the response in accordance with the RFC for a **User Datagram Protocol** (**UDP**)
    port that is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more filter that we will apply to close out this section. As testers,
    it is important that we get to the data as expeditiously as we can, and this is
    where the power of the Wireshark filters come in. However, before we do this,
    is there something we have missed? Hopefully, you will remember that Nmap only
    scans 1000 ports by default, and as such, we don''t scan all the ports. You have
    probably already scanned the ports; as a reminder, we use the `-p` option for
    port scanning, and you should scan all ports so that your testing results are
    more complete. Once you have completed your scan, there will be several packets
    in Wireshark that you will have to look through. So, to make our job easier, enter
    the following in the filter window in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have entered the filter, click on **Apply** to apply the filter. Now,
    all the packets that have the SYN and ACK flags set will be displayed; therefore,
    you now have a quick reference of what ports are open on the target. An example
    of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing a quick reference of what ports are open on the target (the cropped
    text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to see the port numbers and not the names of the protocol that
    is usually assigned to that port, you can change this in the settings of Wireshark.
    Navigate to **Edit** | **Preferences** | **Name Resolution** and remove the check
    mark under the **Resolve transport names**. An example of this is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assessing routers](img/477-1_07-33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is all we will do with the iptables machine for now. As we mentioned, we
    will revisit this when we actually start testing against the rule set. We were
    able to do this with the router device, but we will do it in conjunction with
    our testing through the router ACL with the iptables machine.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating switches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another device we will most likely encounter is the switch. Since a switch is
    a unicast device and only floods all ports with broadcast traffic, when we are
    up against one, we want to try and create a situation where the switch will either
    forward packets incorrectly to the wrong destination that we hope is us or get
    the switch to flood all information out all ports, in effect becoming a hub.
  prefs: []
  type: TYPE_NORMAL
- en: The attacks we want to look at are called layer two attacks. While it is true
    that there are switches that operate all the way up to layer seven of the **Open
    System Interconnect** (**OSI**) model, we will focus on the more traditional approach
    that operates at layer two.
  prefs: []
  type: TYPE_NORMAL
- en: MAC attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a number of years, we enjoyed the luxury of being able to flood a switch
    using an excellent tool known as **macof**. You can read more about it at [http://linux.die.net/man/8/macof](http://linux.die.net/man/8/macof).
    You may still have some success with the macof tool, but it usually only works
    when you encounter a switch that is from before the year 2006\. We want to flood
    a switch to turn it into a hub, so we can intercept traffic for a potential attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do encounter an older switch, macof can flood the average **Content
    Addressable Memory** (**CAM**) table in 70 seconds. Since it is quite common to
    encounter an older switch, it is important to at least look at how the tool is
    used. We have the macof tool available to us in the Kali Linux distribution. In
    the Kali machine, navigate to **Applications** | **Kali Linux** | **Stress Testing**
    | **Network Stress Testing** | **macof** to open the macof tool, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MAC attacks](img/477-1_07-34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the macof tool, and as is common in the Kali Linux distribution,
    there is an output showing the usage of the tool. An example of the tool usage
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MAC attacks](img/477-1_07-35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the usage of the tool is pretty straightforward.
    Again, this is a tool you can use when you encounter an older switch. We will
    now look at another attack against the switch at layer two.
  prefs: []
  type: TYPE_NORMAL
- en: VLAN hopping attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next attack we will look at is the technique of hopping across a VLAN. A
    number of administrators make mistakes when it comes to configuring their switches,
    and as a result of this, we can sometimes hop across the VLAN. We use a VLAN hop
    to access assets that are not available to the VLAN assigned to the host.
  prefs: []
  type: TYPE_NORMAL
- en: In a VLAN hop, we take advantage of the fact that a trunk has access to all
    VLANs. To carry out the attack, we must spoof the switch with trunking protocol
    signaling. For this to work, the switch has to be configured to allow us to accomplish
    this. The default setting on this is at **auto** that will allow our attack to
    work. If the spoof works, we will have access to all of the VLANs on the network.
  prefs: []
  type: TYPE_NORMAL
- en: GARP attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Gratuitous Address Resolution Protocol** (**GARP**) attacks are carried
    out against the fact that the ARP has no authentication, and as a result of this,
    you can successfully spoof an ARP address. The process is to send out a GARP that
    is sent to the broadcast address, and some operating systems will overwrite an
    existing ARP entry even if the entry has been statically entered.
  prefs: []
  type: TYPE_NORMAL
- en: All of these attacks are possible, but we will not be able to build and test
    them on the range for the most part unless we build an actual stationary range.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we want to attack the firewall, like we did earlier when we encountered
    the router. Our success will be determined by the administrator and how they have
    configured their environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the **Smoothwall** firewall that we created, and we will attack
    it from the red interface that is connected to the VMnet2 switch. We will use
    the same process we used against the router and see what we can discover when
    we go against the firewall. Our testing range is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous diagram shows, we will just concentrate on the external interface
    of the Smoothwall machine. The first thing we want to do is to use our popular
    network scanning tool Nmap and see what we can discover from the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have our Kali Linux distribution connected to the VMnet2 switch.
    An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have verified your settings in the Kali machine, log in and enter
    `ifconfig eth0` in your Smoothwall machine to display the information for the
    IP address of the machine, since we need this to enter into our tool. An example
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the IP address, we are ready to conduct our scan. In your
    Kali Linux machine, enter `nmap –A 10.2.0.131` to scan the eth0 interface of the
    Bastion Host machine. If your IP address is different, then you will enter that
    as the target. An example of a portion of the results is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we really do not have much to go on. We see that there is only one
    port open on the machine, and since the case is that there is not enough for the
    Nmap tool to attempt a fingerprint of the operating system, we need to look at
    the packet level. Start Wireshark on Kali by entering `wireshark &`, and start
    a packet capture on the eth1 interface. Once you have the packet capture started,
    run the Nmap scan again, and then review the scan in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a portion of the scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of a portion of the scan (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: As you review the previous screenshot, you see that the **ident** port does
    respond as being closed. Virtually, all of the other ports do not respond, so
    at least we have something to go on. This is because the Smoothwall installation
    is registered if there is an Internet connection, and the identity is controlled
    over port 113.
  prefs: []
  type: TYPE_NORMAL
- en: As we worked through this chapter, there was one thing that we discovered during
    our scan of the router; it is the use of ICMP error messages, so we want to see
    if there are any ICMP messages being returned by the Smoothwall machine. It is
    always a good idea to start with a fresh capture, so in Wireshark, navigate to
    **Capture** | **Restart** to start a new capture on the interface. To make your
    task easier, enter a filter of ICMP and click on **Apply**. Then, return to your
    terminal window, run the Nmap scan again, and observe the results in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We do have the ICMP traffic, and this could assist us in determining whether
    we will encounter a firewall. Next, we will want to know what port is responding
    with the ICMP message. We know that according to RFC 793, this is a valid response
    for a UDP port that is closed. So, we need to determine if this is a UDP port
    that responds, or if it is a TCP. We will run our scan again and only look at
    TCP traffic, and we will do that by entering `nmap –sS 10.2.0.131` and observing
    Wireshark during the scan. An example of the results is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the firewall](img/477-1_07-42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the results (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: From the previous screenshot, we see that the TCP port causes the response,
    and therefore, it does not follow the RFC. We can now conclude that we have a
    firewall in place, and we can try to attack it or get through it.
  prefs: []
  type: TYPE_NORMAL
- en: This again is the reality of testing; we can find a firewall, and unless we
    gain something about the firewall, it can be difficult, if not impossible, to
    successfully attack it. In this case, if we did not have the advantage of knowing
    this is the Smoothwall firewall, we would pretty much be in the dark as to what
    type of firewall we encountered.
  prefs: []
  type: TYPE_NORMAL
- en: You are welcome to continue to try and get information about the firewall so
    that you can attack it, but we will move on because having worked with the Smoothwall
    firewall for a number of years, it is much easier to discover ways through it
    or use some form of social engineering to get access behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the firewall rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we earlier identified what port had a rule on it for the router;
    this is a technique you want to continue to practice with on your ranges, but
    we have not looked specifically at the firewall itself. We need to see what the
    firewall allows and blocks if we want to be able to get through it successfully.
    As has been mentioned before, this can be a significant challenge, and more often
    than not, we are limited to using the ports that are open to get through the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that a router is a form of a stateless firewall, and we showed
    that an Nmap scan of the router that has an ACL applied on it will show the ports
    that have a rule set. We not only discussed it, but we went on and proved it.
    We will take this one step further, first with our router, and then with our iptables
    and Smoothwall firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to look at what traffic is allowed to pass through the stateless firewall.
    Since we have already done this with the scan earlier, we will just briefly look
    at another method of testing the rules. We will work with the design shown in
    the following screenshot in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have the second network that is represented
    by the VMnet2 switch, so start up the required machines and log in to them. In
    your router machine, open a terminal window and enter the following commands to
    get your dynamips machine running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you open a terminal window for each command and also navigate to the
    `/opt` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your router starts, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your settings as shown. There is an access list on the interface; if
    there isn''t one, then you have to put one on. We covered the steps earlier in
    this chapter, in case you need help. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see from the previous screenshot that we do have an ACL on this interface,
    so we are ready to do some testing. The first thing we have to do is to verify
    our routing. If it is not set up, then we need to create the routes. Again, this
    is something we have already done, so we will not cover the steps here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to set the route on the Kali machine and OWASP machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your routing is set up, you should be able to access the web server of the
    **OWASP** machine. Use Netcat or telnet to verify you can connect to the machine;
    here, we will use Netcat. In the Kali Linux machine, enter `nc 10.3.0.132 80`
    in a terminal window and verify you can connect to the port; if you are successful,
    then the routing is configured and working. Once you have connected, enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the routing is set up, we are ready to start testing the rules. We will
    start with an Nmap scan. Enter `nmap 10.2.0.132` and review the results; we will
    now scan across the router so the ACL is in play. An example of the results is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the previous screenshot, we see that since we are now going across the
    ACL, we actually get a result of the port that''s allowed through the stateless
    firewall. We will look at one more, and then move on to testing the others. We
    can also use the tool **Hping** to look at a rule. In the terminal window on Kali,
    enter `hping3 –S –p 80 10.2.0.132` and note the results. Now, we want to enter
    the command for a port we know is not open. Enter `hping3 –S –p 22 10.2.0.132`
    and note the results. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on what we have seen, it is quite easy to determine the rules of a stateless
    filter, but what about an actual firewall? We will look at the iptables reaction
    first. Shut down or suspend your router, and bring up your iptables machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have to tweak our routing to point to the right interface, and we also have
    to enable IP forwarding if it is not on in the iptables machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your routing and forwarding set up, you are ready to test the
    rules across the iptables. In your Kali machine, perform the test with either
    Netcat or Nmap to see if you have routing to port 80 of the OWASP machine. Alternatively,
    you can open a browser and try it that way too. An example of the browser method
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once again, now that we have the routing set up, we are ready to test across
    the iptables rule set. As we have done before, we will start our testing with
    Nmap. In Kali, enter `nmap 10.2.0.132` and review the results. An example of the
    results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we should do the same thing as we did before using the Hping tool, but
    we will save you the trouble. Iptables is not going to respond in the same way
    the router did; iptables will not respond at all when it is filtering something.
    As we have stated many times, this is what testing is all about: you create a
    lab environment, apply different settings and configurations, and see what works
    and does not work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to look at the Smoothwall firewall. Since we are testing
    across the firewall, we have a couple of options based on our design. We can test
    across the router, and then across the firewall. However, during testing, we want
    to make things as simple as possible. So, we will test directly across the firewall;
    an example of our network design for this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we have to establish our routing. We now target the VMnet3 switch,
    and as such, we have to route to that network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not required to turn on IP forwarding here since the Smoothwall machine
    takes care of it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to note the IP address of the metasploitable machine. When we set the
    machine up earlier in the book, we set a DHCP server on the VMnet3 switch; therefore,
    the machine should have picked up an address at the time of the boot. To determine
    the IP address, you need to log in to the machine and enter `msfadmin` and a password
    of `msfadmin`. Once logged in, enter `ifconfig` and display the interface information.
    An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the address is different from what you created, then you may have to modify
    it to match the address that is on the target machine. Again, we covered this
    earlier, so we will not cover it again here. To prevent this, you can configure
    the address to be static and assigned at boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reminder: you will have to add the route in the metasploitable machine; to
    do this, you will need to use the `sudo` command. The command to add the route
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your routing is set, you can test it using any of the methods discussed
    previously. An example of testing using telnet is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready to test across the firewall with the target as the destination.
    As we have done before, the easiest way to do it is to use our tool Nmap. Additionally,
    we want to run Wireshark and make a comparison to see if there are any differences
    from what we saw when we scanned the machine directly. In your Kali machine, enter
    `nmap 10.3.0.128` to scan the target. Remember that if you have a different IP
    address, you will need to enter that. An example of the Nmap scan is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, there really is not much difference between
    the tests done on Wireshark and the Smoothwall machine. As you may recall, when
    we examined the results at the packet level, we discovered that the Smoothwall
    machine responded at times with an ICMP message; it was a destination-unreachable
    type of message and the code was port unreachable. An example of the ICMP messages
    from the scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the firewall rules](img/477-1_07-54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the ICMP messages from the scan (the cropped text
    is not important)
  prefs: []
  type: TYPE_NORMAL
- en: As the previous screenshot shows, we do have the ICMP messages, so this is something
    we can make a note of. In the discovery phase, if we find a client with the Smoothwall
    firewall, we will have data on how to proceed against it. You are welcome to continue,
    test data, and see what you can discover; as always, remember to document everything.
    For our purposes, we have achieved the objective of this section, and we are ready
    to move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tricks to penetrate filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on what we discovered in this chapter, you saw that when we encounter
    a device, our success at targeting it or even targeting through it is limited
    by the amount of work the administrator has taken to make the device as restrictive
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, there are times when administrators make mistakes, and that is
    part of our job as professional security testers. We have to find these existing
    mistakes and document them so that the client can fix them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that we continue to see is weak filtering rules, and this
    is something that has been around for a long time. Despite the new products, we
    can still find weak filtering rules when we are testing; therefore, the last section,
    before we end this chapter, will deal with detecting these.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first weak filters we will create and then test, so that we can document
    the results, will be those that are often encountered in a stateless filter, and
    that is a router. We will use our Dynamips virtual machine, and the target will
    be the OWASP machine. In your router machine, open a terminal window and enter
    the following commands to get your Dynamips machine running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, this time we run the command in the background to avoid having
    to open another terminal window; it is up to you if you want to use separate windows.
    We need to create a weak rule, then we will carry out a number of techniques and
    see which one we can use to get additional information from the target that is
    behind the filter. Once your router starts, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *Z*, and then enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a weak filter rule in place, and this is quite common when testing.
    Some administrators will add a rule for the return traffic and allow all traffic
    coming from a certain port to get through. We use port 80 here, but it is most
    commonly found on port 20, 53, and 67\. Microsoft has had weaknesses in its firewall
    and has been known to allow all traffic with port 88 (Kerberos) as a source port
    to get through the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added a new rule to our router, and if we do some research, we see that
    there are techniques to penetrate a firewall, so we will try one of them now.
    The first one we want to try is the fragmentation scan, so enter `nmap –f 10.2.0.132`
    in Kali to direct a fragmented scan at the target. An example of the results is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, this scan has not even detected the one port that is open, so we can document
    that and move on. As has been mentioned, there are a number of scans that can
    be attempted, and your success will vary depending on the administrator you are
    up against. We will look at one more, and you are encouraged to explore other
    methods on your own. You can find a listing of a number of techniques at [http://pentestlab.wordpress.com/2012/04/02/nmap-techniques-for-avoiding-firewalls/](http://pentestlab.wordpress.com/2012/04/02/nmap-techniques-for-avoiding-firewalls/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next one we will look at is the technique that will usually provide you
    the most success, and it is the one we mentioned earlier. A common weakness in
    filters is a rule that allows return traffic from a certain port. Fortunately,
    with Nmap, we have a source port scan option, so we can always direct our traffic
    from a specific port. We want to conduct our scan and use this option. In your
    Kali terminal window, enter `nmap –g 80 10.2.0.132`. The `g` option will direct
    the traffic to come from the port entered, in this case, port 80\. An example
    of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Success! We now have additional detail about the target that is behind the filter;
    therefore, we can carry out our normal testing methodology against it now, as
    long as we generate our traffic from source port 80.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can reach all of the ports open on the machine behind the filter, let
    us investigate this further. We could try a vulnerability scanner, but for the
    most part they are not designed to go through filters, so we will have to manually
    pull the information from the services running on the target, and see if we can
    find something that might be a vector for us to attack, assuming we can send our
    attack from port 80\. This is something we will have to research further.
  prefs: []
  type: TYPE_NORMAL
- en: First, we want to see what is running on these ports, so we can use Nmap to
    grab the banner from these ports.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use Netcat to get past the filter and reach the target with the
    option `-p` to come from a specific source port. This is left as an exercise for
    the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use a number of different scan techniques to get the service information
    from the target; we will use one of the older ones that is still effective and
    faster than some of the newer ones. In your Kali machine terminal window, enter
    `nmap -g 80 –sV 10.2.0.132` to grab the banner of the services. An example is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of interest in the previous screenshot is the fact that the scan shows that
    port 139 and 145, which are normally found on the Windows platforms, are open.
  prefs: []
  type: TYPE_NORMAL
- en: From here, the process is to look for vulnerable versions of services, or even
    the operating system, and then try to leverage the vulnerability with an exploit.
    To carry this out, we will use another machine for testing, and that machine is
    the Kioptrix distribution from [http://www.kioptrix.com/blog/](http://www.kioptrix.com/blog/).
    There are a number of distributions we can download from the site. We will use
    the **Level 1** version. The process is to open the virtual machine and connect
    it to the VMnet2 network in the settings; by doing this, we have a machine we
    can test against.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the virtual machine settings is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the machine boots up, we need to determine the IP address assigned by the
    DHCP server. We can do this by scanning the VMnet2 subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `nmap –g 20 –sP 10.2.0.100-200` in the terminal window on your Kali machine
    to conduct a ping sweep scan against the VMnet2 network. We have the luxury of
    knowing the start and end IP range for the DHCP server, so we will use that here
    to speed up the scan. An example of the scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see that we have three targets in our results, and we know that the 132 machine
    is the OWASP, and the 135 machine is our Kali machine; therefore, our target of
    interest is the 140 machine. This again is all possible because of the weak filter
    configuration on the router. Once we find a way through it, we will continue to
    use it. We need to know what services are running on our target, so enter `nmap
    –g 80 –sV 10.2.0.140` to display the service information from the target. We know
    that this target machine is not a Windows machine, but we have what looks like
    Windows ports open on the target.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the case, we can draw the conclusion that samba is running on
    the machine. There have been a number of samba vulnerabilities; we can conduct
    a research on them and try to see if we are successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered a number of techniques for finding vulnerabilities, and we will
    save you some trouble by looking at some of the samba exploits that are available.
    If you enter `msfconsole` to bring up the metasploit tool, it will take some time
    to get the program to come up, and once it does, we want to use the excellent
    search capability; enter `search samba`. An example of a portion of the results
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have a number of exploits that are available;
    we want to select the ones that have a rating of great or better as that will
    provide the most chance of success. Having said that, there is no guarantee of
    success, but that is the reality of exploitation. So, which one do you pick? Well,
    we have discussed the concept of research, and that is how you find out which
    one will work best for you. We will save you time for this one; enter the following
    in your metasploit window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the Kali machine as the connection for the reverse shell, and we use
    the port 123 for it to come to us on. It is often not checked as it egresses out,
    and as such, will usually work very well. This exploit will fail because there
    is no source port that the traffic is coming from. An example is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the exploit cannot get to the target. Well,
    we know that we have a way to get to the target and that involves setting the
    traffic to come from a specific source port, so what do we do? Well, fortunately
    the creators of metasploit provide us a method to do this, but it is not well
    known, and in fact is not well documented, so it could disappear anytime; therefore,
    it is always good to keep old virtual machines around in case something that we
    liked disappears. The option we are referring to is the `CPORT` option; so enter
    the following command in the metasploit tool to send all of the traffic to the
    target from a source port of 80:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter the exploit to attempt it again. An example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tricks to penetrate filters](img/477-1_07-63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, if your exploit fails, it is not uncommon, and an option is to set the
    network flat and then try the exploit. Unfortunately, there is nothing guaranteed
    here. The main thing is you know the technique to discover when a filter is present,
    and know methods to try and penetrate the filter.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to do is to attempt the same process and methodology against
    the iptables machine. The results are very similar; therefore, we will leave that
    as a homework assignment for those of you who want to practice it. As always,
    document all of your findings and continue to experiment and learn.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a systematic step-by-step process for when we performed
    assessments against a variety of devices. We started the chapter with the router
    device, and then we moved on to the switches. Following the routers and switches,
    we moved on to a discussion on what to do when we encounter firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Once we learned how to deal with a number of different devices, we moved on
    to methods to identify the filtering rules that are in place. We discovered how
    and when a scan is conducted against certain devices, they will respond not in
    accordance with the standards as set forth in the RFC; furthermore, we were able
    to discover that when there is a rule in place on a device, it is common for that
    one port to have a response that provides us with additional details on how to
    proceed against that device.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter with a discussion on tricks to penetrating filters,
    and we looked at using a fragmentation scan; however, this did not provide much
    success. Then, we looked at the powerful technique of source port scanning, and
    in fact, this was very successful in allowing us to enumerate additional information
    about the target; furthermore, we showed how if the source port weakness is found,
    we have options to carry an attack coming out from a specific source port.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. You now have a sound process and methodology for
    when you encounter devices. As we discussed in the chapter, there will be many
    times when you will struggle to find ways through the devices, but this is part
    of professional security testing, and it is the time when you will learn the most.
    In fact, the more you struggle the more you will learn, in most cases. Always
    remember to document all the things that you observe. This is a habit that a prudent
    and professional tester will deploy when building and testing their virtual labs.
    In the next chapter, we will take a look at how we architect an IDS/IPS range.
  prefs: []
  type: TYPE_NORMAL
