- en: Let's Move It, Move It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to control motors and servos. Using DC motors
    will help with projects where you need to control the wheels on a vehicle. The
    servos can help in your projects that need to control robotic arms to move around.
    Both of these devices will give us a way to create mechanical motion. Depending
    on what motion you are trying to create in your project, you may want to choose
    one over the other. How each of them functions, and where they are best suited,
    will be covered in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use what you have learned to
    create projects that move around in all sorts of interesting ways. This opens
    up a whole new set of possibilities in terms of the types of projects that you
    will be able to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuning a servo to the correct pulse width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the actuation range of a servo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the angle of a servo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweeping a servo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a servo with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling multiple servos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning on a DC motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the speed and direction of a DC motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a DC motor with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files from this chapter can be found in the `Chapter08` folder in the
    GitHub repository at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the recipes in this chapter will make use of the Circuit Playground
    Express library, which will typically get imported in the first few lines of the
    script, with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This library will help us to interact with the buttons and switches that come
    with the board. There is another library that will be imported in many of the
    recipes in this chapter, using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This library will help us to interact with the CRICKIT board, so that we can
    control the servos and DC motors.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes involving servos in this chapter expect the two servos to be connected
    to servo port 1 and servo port 2\. When connecting the servo cables, make sure
    the yellow wire is facing outward from the board.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in the chapter involving a DC motor expect the motor to be attached
    to driver 1 of the motor connections. The two wires can be attached to the two
    connectors in either direction. All that will happen is the direction of rotation
    will be flipped, depending on which way the wires are connected.
  prefs: []
  type: TYPE_NORMAL
- en: DC motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DC motors take DC electricity and turn that energy into rotational motion.
    This is usually achieved through the use of electromagnets that drive the motion
    as their magnetic fields change. The following illustration shows how the internals
    of this type of motor appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7e20f54-d436-4531-935c-a447b0e69f25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: https://commons.wikimedia.org/wiki/File:Ejs_Open_Source_Direct_Current_Electrical_Motor_Model_Java_Applet_(_DC_Motor_)_80_degree_split_ring.gif'
  prefs: []
  type: TYPE_NORMAL
- en: DC motors work great in applications in which you need rotational motion at
    high speeds. They would be suitable for operating fans or wheels on a remote control
    car.
  prefs: []
  type: TYPE_NORMAL
- en: Servos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servos are more complicated than DC motors and are more suitable for a situations
    in which you need more control over the exact position of something attached to
    the servo. A servo will usually contain a DC motor, gears, control circuits, and
    a sensor to detect the exact position of the servo. All these components come
    together in a device that lets you have more precise control over the exact angle
    that the servo is pointing at.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a disassembled servo in which you can see the DC
    motor, gears, and circuitry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56c95a65-31f3-4d92-b461-fef2e17f8338.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: https://commons.wikimedia.org/wiki/File:Exploded_Servo.jpg'
  prefs: []
  type: TYPE_NORMAL
- en: Servos work great in applications in which you need exact control over the angle
    of a certain part; for example, where you need to control the angle of a robotic
    arm or the angle of a rudder on a boat.
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit CRICKIT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Adafruit CRICKIT is a board that lets you control many different types of
    motors from a variety of hardware. Different CRICKIT models support the Raspberry
    Pi and the FeatherWing set of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the CRICKIT for Circuit Playground Express.
    The following image shows what the CRICKIT looks like before you attach the Circuit
    Playground Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85d7a456-6976-4701-87f7-9b2d93851462.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect these 2 devices together, you will require 6 hexagonal brass standoffs
    that will each be screwed into both devices with 12 screws. The following image
    shows what these standoffs and screws look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e653d71-9c57-45b1-8bb8-c6cd11104b30.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have connected the two boards using these screws and standoffs, your
    two boards should look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a01b9e38-edd4-4b3c-b7b4-00329a6e6fb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to four separate servos can be attached to the board. Micro, mini, and standard
    servos are all supported. The servo''s three-pin connector should be connected
    to one of the available servo slots, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0823559f-3f26-4a54-9ad8-6c5b24c87980.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to two DC motors can be attached to the board. Each motor will be connected
    to two pins. The pairs of pins for each of the two motor connections are shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec85cdb2-810f-47ab-a9e4-60f7cc8125cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: Once the two devices are connected, you can power each one on and connect the
    Circuit Playground Express to your computer using a USB cable, in the same way
    that we did in the previous chapters of this book. Once connected, you will need
    to flash the firmware with an image that has support for the CRICKIT hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the UF2 file used in this chapter is for version 3.1.2 of CircuitPython
    that has CRICKIT support, and is called `adafruit-circuitpython-circuitplayground_express_crickit-3.1.2.uf2`.
  prefs: []
  type: TYPE_NORMAL
- en: For details on how to flash the board with this firmware, please follow the
    instructions in [Chapter 1](1c277918-6daf-4a83-8a06-6012ceda9ac1.xhtml), *Getting
    Started with MicroPython*, regarding how to flash the microcontroller firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Where to buy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses a number of components, which can all be purchased from the
    Adafruit online retailer.
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit CRICKIT for Circuit Playground Express can be purchased directly
    from Adafruit ([https://www.adafruit.com/product/3093](https://www.adafruit.com/product/3093)).
    It can also be purchased from other online retailers, such as Pimoroni.
  prefs: []
  type: TYPE_NORMAL
- en: The Circuit Playground Bolt-On Kit can be purchased directly from Adafruit ([https://www.adafruit.com/product/3816](https://www.adafruit.com/product/3816)).
    This kit includes the six hexagonal standoffs and 12 screws that are needed to
    attach the two boards together. The servo used in this chapter can be purchased
    directly from Adafruit ([https://www.adafruit.com/product/169](https://www.adafruit.com/product/169)).
  prefs: []
  type: TYPE_NORMAL
- en: The DC motor used in this chapter can be purchased directly from Adafruit ([https://www.adafruit.com/product/3777](https://www.adafruit.com/product/3777)).
    Adafruit also sells a number of optional wheel attachments, but none are required
    to follow along with the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The CRICKIT can be powered by a three-AA battery holder, which can be purchased
    directly from Adafruit ([https://www.adafruit.com/product/3842](https://www.adafruit.com/product/3842)).
    The benefit of this power supply, as compared to others, is its portability and
    low cost.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning a servo to the correct pulse width
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servos can have their arms rotated to specific angles by sending them different
    electrical pulses. The angle that the arm moves to will be controlled by the width
    of the electrical pulse. Before setting these angles, each servo must first be
    configured with the correct minimum and maximum width settings.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to do that. This configuration will be required
    whenever you want to use servos in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have imported the necessary libraries and have defined the
    minimum and maximum pulse width values we want for this specific set of servos.
    The following block of code will configure the servo connected to the first port
    with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to move the servo to the lowest angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will move the arm to the middle position, exactly
    between the lowest and highest values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold down your finger on touch pad A1 while running the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file, and, when executed,
    it will move servo 1 to the lowest angle for 3 seconds, and then move it to the
    middle range angle for 60 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `crickit` object will be the way we can interact with all the servos and
    DC motors connected to the board. Each servo connection is numbered, so that you
    can control multiple servos through attributes on this single object. After saving
    the values for the minimum and maximum pulse widths in constants, we then apply
    these settings to the first servo motor by calling `set_pulse_width_range`.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the value of the angle attribute on the first servo, which will
    move the servo into angle 0\. We pause for 3 seconds by calling the `sleep` method
    before changing the angle to 90, using the same angle attribute.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servo motors from different manufacturers will expect different settings for
    the minimum and maximum pulse widths. You can usually find the correct settings
    for a particular servo by checking the product's data sheet. The settings used
    in this recipe are specific to the servo models described at the start of the
    chapter. You can change these settings as required if you decide to use a different
    set of servos. The Python library for controlling the servos also lets you configure
    these settings for each servo. This lets you attach different servos with different
    settings at the same time by configuring each one separately.
  prefs: []
  type: TYPE_NORMAL
- en: The pulse widths are sometimes provided in milliseconds, and sometimes in microseconds.
    Just convert them to microseconds, as they are the units expected in this Python
    module. The servo used in this recipe was described as using 0.75 ms to 2.25 ms
    for its pulse width, which, when converted to microseconds, becomes 750 to 2,250.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the components found in servos can be found at [http://developer.wildernesslabs.co/Hardware/Reference/Peripherals/Servos/](http://developer.wildernesslabs.co/Hardware/Reference/Peripherals/Servos/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of the inner workings of servos can be found at [https://www.pc-control.co.uk/servo_control.htm](https://www.pc-control.co.uk/servo_control.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the actuation range of a servo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servos vary in the range of motion their arms have. For the angles, you make
    a request in your software to map correctly to the angles the servo actually moves
    in; you need to configure the servo with its actuation range. Once configured,
    you will be able to accurately move the arms connected to servos into their correct
    positions. This is an important step in configuring any project you plan to use
    servos in. If you don't do this, you will face a number of strange surprises where
    the servo arms keep moving to the wrong positions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The pulse widths are now configured for the servo. Execute the following block
    of code to move the servo to its lowest position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make note of the current position of the arm before running the next block
    of code. Run the next block of code to move the servo to the highest angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Measure the angle between these two positions. You should find the angle to
    be 160 degrees. Run the next block of code to return the servo to angle 0 and
    configure the actuation range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code, and the software angle and the real-world angle
    should both be 160 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will move servo 1 to the lowest angle for 3
    seconds, and then move it to an angle of 160 degrees for 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first few lines of code will configure the pulse width settings for the
    servo. The angle will be set to 0 for 3 seconds before the actuation range is
    configured to the correct value for this specific servo as a value of 160 degrees.
    After this configuration, when the angle in the software is set as 160 degrees,
    the real-world movement should also be 160 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as pulse widths vary between servos, so does the range of motion. Most
    servos won't give you a full 180 degrees of motion. One way to discover these
    settings is to not configure the actuation range, and then move the servo to 0
    degrees and 180 degrees in your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use a protractor to physically measure the angle moved by the
    servo. Once you have measured this value, you can then use this angle as the value
    for the actuation range. The following image shows the servo in this chapter being
    measured with a protractor at the lowest angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b83778d-0608-40c5-9646-16e51b8b2edc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the protractor has been put in place, the servo is moved to the highest
    angle. The following image shows the protractor measuring the angle as 160 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fd941b7-5863-4341-b671-6722501ab59f.png)'
  prefs: []
  type: TYPE_IMG
- en: Protractors are the weapon of choice when you want to make accurate angle measurements
    in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Some details on setting the actuation range can be found at [https://learn.adafruit.com/using-servos-with-circuitpython/circuitpython](https://learn.adafruit.com/using-servos-with-circuitpython/circuitpython).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion of the range of motion of servos can be found at [https://learn.sparkfun.com/tutorials/hobby-servo-tutorial](https://learn.sparkfun.com/tutorials/hobby-servo-tutorial).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the angle of a servo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a correctly configured servo, you will be able to move the servo
    arm to exact angle positions. This recipe will move a servo to a number of angles
    and show what happens when you try to move servos to angles beyond their allowed
    range of motion.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the power to move servos to specific angles, we can start incorporating
    them into our projects to control robotic arms or to move other servo attachments
    to specific positions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The servo should now be at the lowest angle. Execute the following block of
    code to move the servo to its highest position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to see what happens when you go past the maximum angle
    range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to return the servo to angle 0 and configure
    the actuation range to 160 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to see that 180 degrees is now considered an
    angle beyond the servo''s range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code, and the servo should move to its highest angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file, and, when executed,
    it will move the servo to angles of 0, 45, 90, and 160, with a three-second delay
    between each movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first few lines of code will configure the pulse width settings and actuation
    range for the servo. Then, 4 different angles will be set on the servo. The angles
    are 0, 45, 90, and 160 degrees. After each angle is set, a delay of 3 seconds
    is applied by calling the `sleep` function on the time module.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we experimented to see what would happen when we tried to set
    the angles on the servo both when the actuation range had not been configured,
    and once it had been configured. The default setting for the actuation range is
    180 degrees. That is why, in all cases, a value of 190 degrees would be rejected.
    Once we configured the actuation range to 160, values such as 180 would, of course,
    be rejected, as they would be outside this range.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very helpful that the servo library has these checks, because if they weren’t
    performed, bugs in your software application that set servo angles outside of
    the correct range could damage your servo. Also, throwing a `ValueError` exception
    with a clear exception message makes it easier to debug applications that have
    these bugs in them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A project that controls the angles of servos using the CRICKIT can be found
    at [https://learn.adafruit.com/crickit-powered-owl-robot](https://learn.adafruit.com/crickit-powered-owl-robot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of creating motion with a servo and CircuitPython can be found at
    [https://learn.adafruit.com/hello-world-of-robotics-with-crickit](https://learn.adafruit.com/hello-world-of-robotics-with-crickit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweeping a servo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a script that continually moves
    a servo from the lowest to the highest angle and back again, in a sweeping motion.
    In some ways, the code is similar to the light animations that we have seen in
    previous chapters, as we will change the output of the board with time delays
    between each change to create an animated visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of servos, though, it is the attached arm that will become animated
    with a sweeping motion. The approach used in this recipe can be adapted to any
    number of projects in which you want some servo attachments to continually sweep
    from one position to another.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, the required Python libraries should be imported, and the different
    settings should be defined as constants for our script. Execute the following
    block of code to initialize the servo and move it to its lowest position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to sweep the servo from angle `0` to `160`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to sweep the servo from angle `160` to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file, and, when executed,
    it will continually sweep the motor from angle `0` to `160`, and then back to
    `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, a function called `init` is defined, which expects the name of the servo
    to initialize as its first argument. When this function is called, it will set
    the minimum and maximum pulse widths, set the angle to 0, and set the actuation
    range. Next, a function called `sweep` is defined. This function expects the first
    argument to be the servo to control, and the second argument to be an integer
    with the value `1` or `-1`, indicating the direction of the sweep.
  prefs: []
  type: TYPE_NORMAL
- en: A value of `1` will make the the angle increase, while a value of `-1` will
    make the angle decrease. The first part of the sweep function will retrieve the
    current value of the servo's angle and type cast it to an integer and store it
    in a variable called `angle`. A loop is started, which will continue until the
    value of the angle has exceeded the allowed range of 0 to 160\. In each iteration
    of the loop, the current angle is printed, and then the angle is applied to the
    servo before a sleep is applied; then, the angle is changed by the defined step
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function is then defined, which, when called, will initialize the
    servo and move it to angle 0\. Then, an infinite loop is started to perform two
    actions during each loop iteration. It will first call the sweep function to increase
    the angle from 0 to 160\. Then, it will call the sweep function again, but this
    time, to reduce the angle from 160 to 0.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as possible, no values are hardcoded in the `init` and `sweep` functions.
    Most of the values are provided as configurable constants set at the top of the
    script, or as arguments received as the function is called. This will make it
    much easier to tune the script for servos with other settings. You can also easily
    change the amount the angle changes during each `sweep` iteration and the speed
    at which the sweep is completed by increasing and lowering the values in these
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: The program has also been broken into 3 different functions, in order to improve
    readability and encourage the reuse of different blocks of code into other projects.
    One of the interesting and relatively unique features of the Python programming
    language, which is fully supported in the MicroPython and CircuitPython editions,
    is the ability to chain comparison operations. This feature is used in the `sweep`
    function to check that the angle is between 0 and 160.
  prefs: []
  type: TYPE_NORMAL
- en: In other languages, you would usually have to express this using an `and` operator
    combined with two comparison operators. In Python, however, you can just chain
    the two comparison operators to achieve the same result in a more concise and
    readable way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation describing how comparisons can be chained can be found at [https://docs.python.org/3/reference/expressions.html#comparisons](https://docs.python.org/3/reference/expressions.html#comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the CRICKIT library can be found at [https://circuitpython.readthedocs.io/projects/crickit/en/latest/](https://circuitpython.readthedocs.io/projects/crickit/en/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling servos with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the two push buttons on the Circuit
    Playground Express to control the angle of a servo. The script in this recipe
    will increase the servo angle each time push button A is pressed, and will decrease
    the angle each time push button B is pressed. These types of scripts are very
    useful whenever you want to create a project where people can directly control
    servos using different input controls, such as push buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial imports are done, and we are ready to define our functions. The
    following block of code will define and call a function to initialize the servo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to move the servo by 10 degrees and inspect the value
    of angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to move the servo again, by another 10 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to reduce the angle of the servo by 10 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The script, once executed, will move the servo to a lower or higher angle each
    time push buttons A and B are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After global constants and a servo initialization function are defined, we then
    continue to define two other functions. The `move` function accepts the servo,
    the current angle, and the movement direction as its three arguments. The expected
    new angle is then calculated based on the current angle step amount and the direction
    of movement. If this new angle is within the acceptable angle range, then its
    value is printed and applied to both the `servo` and the `angle` variable. Finally,
    the value of the `angle` variable is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function that is defined and then called at the bottom of the script
    implements the main event loop. The `servo` variable is initialized and the `angle`
    variable is set to `0` before an infinite loop is started. During each iteration
    of the loop, if push button A is pressed, then the `move` function will be called
    to increase the servo angle. Then, push button B is checked, and, if it's pressed,
    the `move` function will be called to decrease the servo angle. Finally, a `sleep`
    function is applied at the end of each iteration of this loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This basic event loop allows us to react to user input by moving the servo in
    different directions. We can extend the logic of this script in many directions.
    We could reduce the step angle from 10 to 1, for example, to get very fine control
    of the servo and change the angle by one degree at a time. We could also reduce
    the delay to speed up the movement in reaction to each button press. We could
    take the base script and add code that controls the pixels, in addition to the
    servo angles, as you press each push button.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A project that controls servos with push buttons can be found at [https://learn.adafruit.com/universal-marionette-with-crickit](https://learn.adafruit.com/universal-marionette-with-crickit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the `servo` objects can be found at [https://github.com/adafruit/Adafruit_Circuitpython_Motor](https://github.com/adafruit/Adafruit_Circuitpython_Motor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling multiple servos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to combine the use of the push buttons and
    slide switch to control multiple servos. Essentially, we will use the push buttons
    to control the angle of a specific servo. We will then use the slide switch to
    select which of the two connected servos we want to control.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe builds on some of the past recipes and adds additional data structures
    and controls to manage the additional logic that is required to control multiple
    servos. This recipe will be very useful whenever you need to find ways to control
    more than one servo at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial imports are done, and we have defined the `init` function to help
    initialize the servos. The following block of code will set up some data structures
    that will keep track of our angles and servos:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will initialize all the servos in our servos list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to set the switch variable, based on the slide switch
    position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to move the selected servo by 10 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to inspect the angle''s data structure before and after
    a call to the `move` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the slide switch position and run the following block of code to update
    the selected servo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to see how calling the `move` function moves
    the other servo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Executing this script will move different servos, depending on the position
    of the slide switch and the presses on the push buttons.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After global constants and a servo initialization function are defined, we will
    then continue to define two other functions. The `move` function follows the same
    structure that you saw in the previous recipe. The `main` function, however, has
    been expanded to have additional data structures and logic to handle dealing with
    multiple servos and the slide switch.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, a list called `servos` is created to point to the two
    servos to be controlled. A list called `angles` will keep track of the angles
    for each servo. Each servo is then initialized before entering into an infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: During each loop iteration, the value of the switch is converted from a Boolean
    value to the integer value 0 or 1\. This will allow us to switch control between
    the two servos. Then, depending on whether push button A or B is pressed, the
    `move` function is called, provided with the correct `servo` object and angle.
    Finally, `sleep` is applied at the end of each loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have combined three input controls and two output servos
    in a way that makes interacting with the board a natural process. Part of the
    reason for this is that different physical input controls lend themselves to be
    mapped to different logical controls.
  prefs: []
  type: TYPE_NORMAL
- en: A slide switch is ideal for switching between two options, so it makes sense
    to use a slide switch when selecting between two servos. Push buttons work well
    when you want to repeatedly increase or reduce a value through repeated button
    presses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of interacting with the slide switch can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/slide-switch](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/slide-switch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of Adafruit CRICKIT-related components can be found at [https://www.adafruit.com/category/972](https://www.adafruit.com/category/972).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning on a DC motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to control a DC motor using the Circuit Playground
    Express and CRICKIT board. DC motors are simpler to interact with than servos,
    since they don't need any initial configuration. This recipe will give you the
    basic skills required to turn DC motors on and off for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The DC motor connected to the board should now start rotating at full speed.
    Run the following block of code to stop the DC motor from rotating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will stop and start the motor with a one-second
    delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This script, when executed, will start an infinite loop that keeps starting
    and stopping the motor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DC motors differ from servos, and therefore, they require less code and interaction
    to get them moving. After the library imports, an infinite loop is started.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the loop, the `dc_motor_1` attribute on the `crickit` object
    is accessed. This object will let us interact with any DC motors connected to
    the first motor connection on the board. The `dc_motor_1` exposes an attribute
    called `throttle` that we can use to turn the motor on and off. If we set the
    value to `1`, the motor starts, and a value of `0` switches off the motor.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the throttle is first set to `1` to turn the motor on; a `1` second
    sleep is applied before the motor is turned off, and another sleep of `1` second
    is applied. The loop then starts again, repeating the process.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DC motors are different than the servos in a number of ways, as demonstrated
    in this recipe. It is true that they are easier to get started with than servos,
    since they don't need any initial configuration. On the flip side, however, they
    don't provide any precise control of the exact position you’d like to put the
    motor in.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, things that DC motors are capable of doing that servos
    can't, such as a complete 360-degree rotational motion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on using DC motors with the CRICKIT board can be found at [https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/circuitpython-dc-motors](https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/circuitpython-dc-motors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of chassis that can be used to house the DC motors can be found at
    [https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/recommended-chassis](https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/recommended-chassis).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the speed and direction of a DC motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to control both the speed and the rotational
    direction of a specific DC motor. You will see that providing a positive or negative
    value to the throttle will let us control whether the motor will turn clockwise
    or counterclockwise. We can also provide fractional values to the throttle to
    control the power the motor is run at.
  prefs: []
  type: TYPE_NORMAL
- en: When you use DC motors to control wheels on a MicroPython-powered, computer-controlled
    vehicle, the techniques in this recipe will be very useful. They will let you
    speed the car up or slow it down. You can also use them to make the car go in
    reverse or come to a full stop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it....
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The DC motor will now run at 50% of its full speed. The following line of code
    will run the motor at a quarter of its full speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will move the motors in the opposite direction,
    at full speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to stop the motor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the following block of code will define and call a function
    that will change the speed and direction of the motor from one direction to the
    opposite direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This script, when executed, will move the motor from one direction to the other,
    over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `change_throttle` function is defined, which will perform the bulk of the
    work in this recipe. It expects to receive the motor to control, the starting
    value for the throttle, and finally, the amount the throttle should be changed
    during each iteration. The function will initialize the `throttle` variable to
    the specified start value.
  prefs: []
  type: TYPE_NORMAL
- en: Then, a `for` loop will be started that will go from the lowest to the highest
    value of the throttle. It first prints the current throttle, and then applies
    the value of the `throttle` variable to the motor. The throttle is incremented
    and rounded to one decimal place. A delay is then applied before the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function will enter into an infinite loop that calls the `change_throttle`
    function twice during each iteration. The first call will move the throttle value
    from `-1.0` to `1.0`, in increments of `0.1`. The second call will move the throttle
    value from `1.0` to `-1.0`, in increments of `-0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be used to demonstrate running the motors at different speeds
    and different directions. It creates an almost visual animation, where you can
    see the motors slowing down and speeding up. You can see them moving at maximum
    speed in one direction, and then slowing down to move to the maximum speed in
    the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: There are all sorts of creative experiments you can do to extend this recipe
    to new functionality. You could, for example, attach two wheels to the DC motor
    to make it move like a remote control car. You could configure the light sensor
    to react to a flashlight by
  prefs: []
  type: TYPE_NORMAL
- en: speeding up the motor. Or, you could attach something else to the DC motor that
    turned based on a certain schedule. You could control the timing of when the motor
    is turned on, using the time module used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A project that uses both servos and DC motors with the CRICKIT board can be
    found at [https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/bubble-bot](https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/bubble-bot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on how to wire and control DC motors with the CRICKIT board can be found
    at [https://learn.adafruit.com/make-it-move-with-crickit/use-a-continuous-dc-motor-now](https://learn.adafruit.com/make-it-move-with-crickit/use-a-continuous-dc-motor-now).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a DC motor with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use push buttons to increase and decrease the speed
    of the DC motor. We can use the same script to change the direction of rotation
    with the push buttons. Essentially, one push button will make the motor increase
    speed in one direction, and the other push button will make the motor move more
    in the other direction. In this way, we can use the pair of push buttons to set
    a range of speeds in either direction and to bring the motor to a full stop.
  prefs: []
  type: TYPE_NORMAL
- en: As the script is run, the current speed and direction will be printed to the
    screen. This recipe can be useful in any project in which you want to have user
    input translated into motion. You could, for example, create a project in which
    you attach a pulley to a DC motor and use the push buttons to raise and lower
    the pulley.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The DC motor speed is set at `0` throttle. The following block of code will
    define a `move` function and call it three times, with parameters to increase
    the speed to 30% strength:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will call the `move` function three times, to reduce
    the speed until the motor comes to a full stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will call the `move` function three more times,
    in the negative direction, to set the motor to 30% strength in the opposite direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will call the `move` function three times in a
    direction that takes the motor from the opposite direction down to a full stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be inserted into the `main.py` file, and, when executed,
    it will move the motor from one direction to the other, in response to presses
    on the push buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `move` function is defined to control changes in the direction of movement
    on the motor. It can be called to either increase or decrease the movement in
    a specific rotational direction. The function takes the motor object, the current
    throttle, and the desired direction of movement. The new throttle value is calculated,
    and, if it is found to be within the acceptable range of the motor, the value
    will then be printed and applied to the motor.
  prefs: []
  type: TYPE_NORMAL
- en: The latest value of the throttle is then returned so that the main event loop
    can keep track of it. The `main` function contains an infinite loop, which acts
    as the main event loop. In this loop, presses on push button A will increase the
    motor's speed in one direction, and presses on push button B will increase the
    motor's speed in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe provided the basic building blocks for taking user-generated input
    and generating output using DC motors. You can expand on this recipe in a similar
    way to others so that the slide switch will let you control more than one DC motor
    with the same script.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the step value in the script to make the motors change speed
    and direction faster. Or, maybe you would like to reduce the step value, giving
    you more fine-grained control over the speed, at the cost of additional button
    presses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A motor pulley that is compatible with the DC motors used in this chapter can
    be found at [https://www.adafruit.com/product/3789](https://www.adafruit.com/product/3789).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project that uses DC motors with the CRICKIT board to control a pulley can
    be found at [https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/marble-madness](https://learn.adafruit.com/adafruit-crickit-creative-robotic-interactive-construction-kit/marble-madness).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
