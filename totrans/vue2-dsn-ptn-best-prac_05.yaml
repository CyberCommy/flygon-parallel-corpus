- en: Secured Communication with Vue.js Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't need to look far before noticing component-driven architecture in
    modern web applications nowadays. Development needs have changed in a short space
    of time with the web going from a simple document viewer to hosting complex applications
    with significantly large code bases. Therefore, the ability to create reusable
    components makes our lives as front-end developers much easier as we can encapsulate
    core functionality into singular blocks, reducing overall complexity, allowing
    for better separation of concerns, collaboration, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be taking the preceding concepts and applying them
    to our Vue applications. By the end of this chapter, you will have achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create your own Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A greater understanding of Single File Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create styles specific to each component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to register components both locally and globally, and an understanding
    of *why* to select one over the other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to communicate between parent and child components using props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to communicate *across* the application using a global Event Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to use slots to make your components more flexible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start off by looking at *Your first Vue component.*
  prefs: []
  type: TYPE_NORMAL
- en: Your first Vue component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that we''ve been using components all along inside of our Vue
    applications! Using the `webpack-simple` template, we have support for **Single
    File Components** (**SFC**), which is essentially just a template, script, and
    style tag with a `.vue` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re using the Vetur extension for Visual Studio Code, we''re able to
    type `scaffold` and hit *Tab*, this then creates an SFC that can be used inside
    of our project. If we overwrite `App.vue` with an empty component, by our current
    definition it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50fc5112-77cf-4a01-b677-652be6042fff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s it! Sort of. We''ve still got to add some functionality to our component,
    and if we were creating a new file (that is, not using the default `App.vue` component),
    register it somewhere to be used. Let''s see this in action by creating a new
    file under `src/components/FancyButton.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `FancyButton` component is simply a button that says `''Hello World!''`
    and has a tiny bit of styling. Immediately, we need to be thinking about things
    that we can do to make this more scalable:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow for an input on this component to change the button text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we're styling the `button` element (or even if we had added classes), we
    need a way to stop the styles leaking out into the rest of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register this component so that it can be used globally throughout the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register this component so that it can be used locally within a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the easiest one, registering the component so it can be used
    within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Registering components globally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create components and register them globally with the following interface:
    `Vue.component(name: string, options: Object<VueInstance>)`. Although it isn''t
    required, when naming our components it''s important to adhere to the naming conventions
    set by the W3C Custom Elements specification ([https://www.w3.org/TR/custom-elements/#valid-custom-element-name](https://www.w3.org/TR/custom-elements/#valid-custom-element-name)),
    that is, all-lowercase and it must contain a hyphen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of our `main.js` file, let''s register our `FancyButton` component by
    first importing it from the appropriate path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we can register the component using `Vue.component`, which can
    be seen in bold, making the resulting code inside of `main.js` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Tada! Our component has now been registered globally. Now... how do we use
    this inside of our `App.vue` component? Well, remember the tag that we specified?
    We just add that to the `template` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the results of our hard work (zoomed in to 500%):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd7723c0-2989-49a4-a855-663dcf1121d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Scoped styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great! What happens if we add another button element? As we styled the `button`
    element directly with CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we head over to our browser we can see each of the buttons that we have
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/604d7493-d3d5-436a-880b-63d7fa46c240.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Uh oh! This other button isn''t a `fancy-button`, so why is it getting the
    styles? Thankfully, stopping the styles from leaking outside of the component
    is simple, all we need to do is add the `scoped` attribute to the `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The scoped attribute isn't part of Vue by default, this comes from our Webpack
    `vue-loader`. You'll notice that after adding this, the button styles are specific
    to our `fancy-button` component only. If we look at the differences between the
    two buttons in the following screenshot, we can see that one is merely a button
    and the other is styling a button with a randomly generated data attribute. This
    stops the browser from applying the styles to both button elements in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using scoped CSS within Vue, keep in mind that rules created within the
    component won''t be accessible globally across the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fa8f269-da22-4751-a067-7e77a88331e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Registering a component locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also register our components locally within our application. This can
    be done by adding it specifically to our Vue instance, for example, let''s comment
    out the global registration within `main.js` and then navigate to `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before adding any code into our app component, notice that our button has disappeared
    now that we''re no longer globally registering it. To register this locally, we''ll
    need to first import the component similar to how we did before and then add this
    to a `component` object within the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our button has now appeared on screen again. When deciding where to register
    your components, think about how often they may need to be used throughout the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Component communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now got the ability to create reusable components that allow us to encapsulate
    functionality within our project. In order to make these components usable, we'll
    need to give them the ability to communicate with oneanother. The first thing
    we'll be looking at is one way communication with component properties (referred
    to as "props").
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of component communication is to keep our features distributed, loosely
    coupled, and in turn make our application easier to scale. To enforce loose coupling,
    you should not attempt to reference parent component(s) data within the child
    component and it should be passed using `props` only. Let''s take a look at making
    a property on our `FancyButton` that changes the `button` text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we''re able to bind to the `buttonText` value inside of our template
    as we''ve created ourselves a `props` array that contains string or object values
    for each component property. Setting this can be done with kebab case as an attribute
    on the component itself, this is required as HTML is case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1fe36d71-ca38-4d17-b80d-6200a13f6a7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can further configure our property values by instead setting them as an
    object. This allows us to define things such as defaults, types, validators, and
    so on. Let''s do this with our `buttonText` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we''re ensuring that we can only pass String types into this property.
    We can also check against other types, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to web component good practices, sending primitive values to props
    is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, this is running the `instanceof` operator against the property
    so it could also run a check against constructor types, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02c1a8f7-dd5b-4275-9888-7f65a618fbfd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the same time, we can also check for multiple types using the array syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we're setting the default text to be `FancyButton!`, which means that
    by default, if this property wasn't set, it'd have that value. We've also set
    required equal to true, meaning that any time we create a `FancyButton` we have
    to include the `buttonText` property.
  prefs: []
  type: TYPE_NORMAL
- en: This is currently a contradiction in terms (that is, default value and required),
    but there are times where you'd want a default value where the property isn't
    required. Finally, we're adding a validation function to this to specify that
    any time we set this property, it has to have a string length greater than three.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know whether a property validation has failed? In development mode,
    we can check our development console and we should have a corresponding error.
    For example, if we forget to add the `buttonText` property on our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7bbf0577-2965-4753-b81a-366e98da34bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re making great progress. We now have a component that can accept input,
    be registered globally or locally, has scoped styles, validation, and more. Now
    we need to give it the ability to fire events back to its parent component to
    communicate whenever the `FancyButton` button is clicked, this is done by editing
    the code for the `$emit` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we''ve attached the `clicked` function to the click event of
    the button, meaning that whenever it is selected we''re emitting the `buttonClicked`
    event. We can then listen for this event within our `App.vue` file, where we add
    our element to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how at this point we're using `@buttonClicked="eventListener()"`. This
    uses the `v-on` event to call the `eventListener()` function any time the event
    is emitted, subsequently logging the message to the console. We've now demonstrated
    the ability to send and receive events between two components.
  prefs: []
  type: TYPE_NORMAL
- en: Sending event values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the event system even more powerful, we can also pass values along
    to our other component. Let''s add an input box to our `FancyButton` component
    (perhaps we need to rename it or think about separating the input into its own
    component!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to do is pass along the message value with our `$emit` call.
    We can do this inside of the `clicked` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can then capture the event as an argument to the `eventListener`
    function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing to do at this point is also match up the expected parameters
    for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should then get the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ede1eca-f3fc-49d7-9b60-9ef5042cb653.png)'
  prefs: []
  type: TYPE_IMG
- en: We've now got the ability to truly send events between a parent and child component,
    along with any data we may want to send along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Event Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we''re looking to create an application wide events system (that is, without
    strictly parent to child component), we can create what''s known as an Event Bus.
    This allows us to "pipe" all of our events through a singular Vue instance, essentially
    allowing for communication past just parent and child components. As well as this,
    it''s useful for those not looking to use third-party libraries such as `Vuex`,
    or smaller projects that are not handling many actions. Let''s make a new playground
    project to demonstrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Start off by creating an `EventsBus.js` inside the `src` folder. From here
    we can export a new Vue instance that we can use to emit events like before with
    `$emit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create our two components, `ShoppingInput` and `ShoppingList`.
    This will allow us to both input a new item as well as display a list of inputted
    items on our shopping list starting with our `ShoppingInput` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The key take away from this component is that we''re now importing `EventBus`
    and using `$emit` instead of using this, changing our application''s event system
    from being component-based to application-based. We can then watch for changes
    (and the subsequent values) from any component we want using `$on`. Let''s look
    at this with our next component, `ShoppingList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Looking at our `ShoppingList` component we can see the use of `$on`, this allows
    us to listen for the event named `addShoppingItem` (the same event name as we
    emitted, or any other event you're looking to listen for). This returns the item,
    which we're then able to log out to the console or do anything else at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put this all together inside of our `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're defining both of our components, and listening for the `addShoppingItem`
    event inside of our created lifecycle hook. Just as before, we get the `itemName`,
    which we can then add to our array. We can pass the array through to another component
    as a prop, such as the `ShoppingList` to be rendered on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we wanted to stop listening to events (either entirely or per event)
    we can use `$off`. Inside of `App.vue`, let''s make a new button that shows this
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create the `stopListening` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to stop listening to all events, we could simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've now created an events system that would allow us to communicate
    with any of our components regardless of the parent/child relationship. We're
    able to send events and listen to them via the `EventBus`, giving us a lot more
    flexibility with our component data.
  prefs: []
  type: TYPE_NORMAL
- en: Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we''re composing our components, we should consider how they''ll be used
    by ourselves and our team. Using slots allows us to dynamically add elements to
    the component with varying behavior. Let''s see this in action by making a new
    playground project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then go ahead and create a new component named `Message` (`src/components/Message.vue`).
    We can then add something specific to this component (such as the following `h1`)
    as well as a `slot` tag that we can use to inject content from elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then registered our component inside of `App.vue` and placed it inside
    of our template, we''d be able to add content inside of the `component` tag like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, everything inside the `message` tag is being placed inside of
    the `slot` within our `Message` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5e0e881f-2107-4293-be22-e51d09c8a94d.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how we're seeing I'm part of the Message component! with each declaration
    of the `Message` component, this shows that even though we're injecting content
    into this space, we can still show template information specific to the component
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst we're able to add content into the slots, we may want to add default
    content that shows when we don't add anything ourselves. This means we don't have
    to add content every time, and if we want to, we can override it in that circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we add default behavior to our slots? That''s quite simple! All we need
    to do is add our element(s) in between the `slot` tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we therefore add another `message` element, but this time without any markup
    inside, we''d get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we head to our browser we can see that our messages display as expected
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa5a2942-93ea-4bdb-92e8-832840de3cef.png)'
  prefs: []
  type: TYPE_IMG
- en: Named slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also take this a step further with named slots. Let's say our `message`
    component wanted both a `date` and `messageText` input, one of which is a slot
    and the other a property of the component. Our use case for this would be that
    perhaps we want to display the date differently, add varying bits of information,
    or not even show it at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our message component becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note of the `name="date"` attribute on our `slot` tag. This allows us
    to dynamically place our content at runtime in the correct locations. We can then
    build out a small chat system to show this in action, let''s ensure we have `moment`
    installed in our project prior to continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You may remember using `moment` in [Chapter 4](5293b70a-2322-4da9-bd9e-244bdec437bf.xhtml),
    *Vue.js Directives*, we''ll also be reusing the `Date` pipe that we created earlier.
    Let''s upgrade our `App.vue` to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here? Inside of our template we''re iterating over our `messageList`
    and creating a new message component each time a new message is added. Inside
    of the component tag we''re expecting the `messageText` to appear (as we''re passing
    it as a prop and the markup is defined inside the Message component), but we''re
    also dynamically adding the date using a `slot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6f662a6-2aca-4b6a-9232-96ddf8f48212.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happens if we remove `slot="date"` from our h2? Does the date still show?
    Nope. This is because when we only use named slots, there are no other places
    for the slot to be added. It would only appear if we changed our `Message` component
    to take in an unnamed slot like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given us the power to create reusable components that can communicate
    with one another. We've looked at how we can register components globally throughout
    the project, or locally to a specific instance, giving us flexibility and appropriate
    separation of concerns. We've seen just how powerful this can be with examples
    that range from the addition of simple properties to complex validations and defaults.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to be investigating how we can create **better
    UI.** We'll be looking more at directives such as `v-model` in the context of
    forms, animations, and validation.
  prefs: []
  type: TYPE_NORMAL
