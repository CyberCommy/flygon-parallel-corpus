- en: Chapter 4. Building the Untangle Game with Canvas and Drawing API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One new highlighted feature in HTML5 is the Canvas element. We can treat the
    canvas element as a dynamic area that we can draw graphics and shapes on with
    scripts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Images in websites have been static for years. There is animation gif but it
    cannot interact with its visitors. Canvas is dynamic. We draw and modify the context
    in canvas dynamically through JavaScript drawing API. We can also add interaction
    to the canvas and thus make games.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the past two chapters, we have discussed DOM-based game development with
    CSS3 and few HTML5 features. In the coming two chapters, we will focus on using
    new HTML5 features to create games. In this chapter, we will take a look at a
    core feature, canvas, and some basic drawing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTML5 canvas element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a circle in canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines in the canvas element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with drawn objects in canvas with mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting line intersection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Untangle puzzle game with canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Untangle puzzle game is a game where players are given circles with some
    lines connecting them. The lines may intersect the others and the players need
    to drag the circles so that no line intersects anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot previews the game that we are going to achieve through
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Untangle Game with Canvas and Drawing API](img/1260_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So let's start making our canvas game from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTML5 Canvas Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'W3C community states that the canvas element and the drawing functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: A resolution-dependent bitmap canvas, which can be used for rendering graphs,
    game graphics, or other visual images on the fly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The canvas element contains context for drawing and the actual graphics and
    shapes are drawn by the JavaScript drawing API.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a circle in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start our drawing on canvas from the basic shape—circle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Drawing color circles on canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's set up the new environment for the example. That is an HTML file
    that will contain the canvas element, a jQuery library to help us on JavaScript,
    a JavaScript file containing the actually drawing logic, and a style sheet.![Time
    for action Drawing color circles on canvas](img/1260_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following HTML code into the `index.html`. It is a basic HTML document
    containing the canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use CSS to set the background color of the canvas inside `untangle.css:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `html5games.untangle.js` JavaScript file, we put a jQuery `ready` function
    and draw a color circle inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `index.html` file in a web browser and we will get the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Drawing color circles on canvas](img/1260_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a simple canvas **context** with circles on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are not many settings for the canvas element itself. We set the width
    and height of the canvas, same as we have a fixed the dimensions of a real drawing
    paper. Also, we assign an ID attribute to the canvas for easier reference again
    in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Putting fallback content when the web browser does not support canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not every web browser supports the canvas element. Especially, those aged old
    version ones. The Canvas element provides an easy way to provide **fallback content**
    if the canvas element is not supported. Anything inside the canvas open and close
    tag is the fallback content. This content is hidden if the web browser supports
    the element. Browsers that don't support canvas will instead display that fallback
    content. It is good practice to provide useful information in the fallback content.
    For instance, if the canvas purpose is a dynamic picture, we may consider placing
    a`<img>` alternative there. Or we may also provide some links to modern web browsers
    for the visitor to upgrade their browser easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we provided a sentence inside the canvas element. This sentence
    is hidden from any browsers that support the canvas element. It will show to the
    visitor if their browsers do not support the new HTML5 canvas feature. The following
    screenshot shows the old version of Internet Explorer displaying the fallback
    content instead of drawing the canvas element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting fallback content when the web browser does not support canvas](img/1260_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing circles and shapes with canvas arc function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no circle function to draw a circle. Canvas drawing API provides a
    function to draw different arcs, including the circle. The Arc function accepts
    following arguments
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| X | The center point of the arc in x axis. |'
  prefs: []
  type: TYPE_TB
- en: '| Y | The center point of the arc in y axis. |'
  prefs: []
  type: TYPE_TB
- en: '| radius | The radius is the distance between the center point and the arc
    perimeter. When drawing a circle, a larger radius means a larger circle. |'
  prefs: []
  type: TYPE_TB
- en: '| startAngle | The starting point is an angle in radian. It defines where to
    start drawing the arc on the perimeter. |'
  prefs: []
  type: TYPE_TB
- en: '| endAngle | The ending point is an angle in radian. The arc is drawn from
    the position of the starting angle to this end angle. |'
  prefs: []
  type: TYPE_TB
- en: '| counter-clockwise | This is a Boolean indicating the arc from `startingAngle`
    to `endingAngle` drawn in a clockwise or counter-clockwise direction.This is an
    optional argument with the default value false. |'
  prefs: []
  type: TYPE_TB
- en: Converting degree to radians
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The angle arguments used in the arc function are in **radian** instead of **degree**.
    If you are familiar with the degrees angle, you may need to convert the degree
    into radians before putting the value into the arc function. We can convert the
    angle unit by using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following graph contains some common angle values in both degree and radian
    units. The graph also indicates the position of the angle value for us to easily
    pick the starting angle and ending angle argument when drawing arc in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting degree to radians](img/1260_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to be clearer on drawing different arcs with the starting angle and
    ending angle, let's draw some arcs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Drawing different arcs with arc function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do some experiments on using the `arc` function by giving different
    starting and ending angles:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` file we just used to draw the circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the circle drawing code by using the following arcs drawing codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to test it in a web browser. There should be six different half
    circles and arcs on the canvas as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Drawing different arcs with arc function](img/1260_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used different `startAngle` and `endAngle` arguments in the arc function
    to draw six different arc shapes. These arc shapes demonstrate how the arc function
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the degrees and radians relationship circle and take a look at
    the top half circle. The top half circle begins at angle 0 and ends at angle π,
    and the arc is drawn in an counter-clockwise direction. If we take a look at the
    circle, it looks like the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And if we start at angle 210 degrees and end at angle 120 degrees, in a clockwise
    direction, we will get the following arc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which arc command we can use to draw the following arc?![Pop quiz](img/1260_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2, true);
  prefs: []
  type: TYPE_NORMAL
- en: b. ctx.arc(300, 250, 50 , Math.PI*3/2, Math.PI/2);
  prefs: []
  type: TYPE_NORMAL
- en: c. ctx.arc(300, 250, 50 , Math.PI*3/2, 0, true);
  prefs: []
  type: TYPE_NORMAL
- en: d. ctx.arc(300, 250, 50 , Math.PI*3/2, 0);
  prefs: []
  type: TYPE_NORMAL
- en: Executing the path drawing in canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are calling the arc function or other path drawing functions, we are
    not drawing the path immediately on the canvas. Instead, we are adding it into
    a list of the paths. These paths will not be drawn until we execute the drawing
    command.
  prefs: []
  type: TYPE_NORMAL
- en: There are two drawing executing commands. One command for filling the paths
    and the other for drawing the stroke.
  prefs: []
  type: TYPE_NORMAL
- en: 'We fill the paths by calling the `fill` function and draw the stroke of the
    paths by calling the `stroke` function, which we will use later when drawing lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Beginning a path for each style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fill` and `stroke` function fills and draws the paths on canvas but it
    does not clear the list of paths. Take the following code snippet as an example.
    After filling our circle with red color, we add other circles and fill it with
    green. What happens to the code is both the circles are filled with green color,
    instead of only the new circle being filled by green color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is because when calling the second `fill` command, the list of paths in the
    canvas contain both circles. Therefore, the `fill` command fills both circles
    with green and overrides the red color circle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this issue, we want to ensure we call `beginPath` before drawing
    a new shape every time.
  prefs: []
  type: TYPE_NORMAL
- en: '`beginPath` empties the list of paths so next time we call the `fill` and `stroke`
    command, it will only apply to all paths after the last `beginPath`.'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just discussed a code snippet where we intend to draw two circles with
    one in red color and the other in green. The code turns out drawing both circles
    in green color. How can we add a `beginPath` command to the code so that it draws
    one red circle and one green circle correctly?
  prefs: []
  type: TYPE_NORMAL
- en: Closing a path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `closePath` function will draw a straight line from the last point of the
    latest path to the first point of the path. That is closing the path. If we are
    only going to fill the path and not going to draw the stroke outline, the `closePath`
    function does not affect the result. The following screenshot compares the result
    on a half circle with one calling `closePath` and the other not calling `closePath:`
  prefs: []
  type: TYPE_NORMAL
- en: '![Closing a path](img/1260_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do we need to use the `closePath` function on the shape we are drawing if we
    just want to fill the color and not draw the outline stroke?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes, we need the `closePath` function.
  prefs: []
  type: TYPE_NORMAL
- en: b. No, it does not care if we have the `closePath` function.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the circle drawing in function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a circle is a common function that we will use a lot. It is better to
    create a function for drawing a circle instead of entering several code lines
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Putting the circle drawing code into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make a function for the circle drawing and draw some circles on the
    canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the original code in the JavaScript file with the following code. It
    basically puts the circle drawing code we just used into a function and uses a
    for-loop to randomly place five circles on the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open the HTML file in the web browser to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Putting the circle drawing code into a function](img/1260_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code of drawing circles is executed after the page is loaded and ready.
    We used a loop to draw several circles in random places on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In game development, we often use `random` functions. We may want to randomly
    summon a monster for the player to fight, we may want to randomly drop a reward
    price when the player makes progress, and we may want a random number to be the
    result of rolling a dice. In this code, we place the circles randomly in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a random number in JavaScript, we use the `Math.random()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There is no argument in the `random` function. It always returns a floating
    number between 0 and 1\. The number is equal or bigger than 0 and smaller than
    1.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways to use the `random` function. One way is to generate
    random numbers within a given range. The other way is generating a true or false
    value
  prefs: []
  type: TYPE_NORMAL
- en: '| Usage | Code | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Getting a random integer between A and B | Math.floor(Math.random()*B)+A
    | `Math.floor()` function cuts the decimal point of the given number.Take `Math.floor(Math.random()*10)+5`
    as an example.`Math.random()` returns a decimal number between 0 to 0.9999….`Math.random()*10`
    is a decimal number between 0 to 9.9999….`Math.floor(Math.random()*10)` is an
    integer between 0 to 9.Finally, `Math.floor(Math.random()*10) + 5` is an integer
    between 5 to 14. |'
  prefs: []
  type: TYPE_TB
- en: '| Getting a random Boolean | (Math.random() > 0.495) | `(Math.random() > 0.495)`
    means there is 50 percent false and 50 percent true.We can further adjust the
    true/false ratio.`(Math.random() > 0.7)` means there is almost 70 percent false
    and 30 percent true. |'
  prefs: []
  type: TYPE_TB
- en: Saving the circle position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are developing a DOM-based game, such as the games we built in previous
    chapters, we often put the game objects into DIV elements and access them later
    in code logic. It is a different story in canvas-based game development.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access our game objects after they are drawn on the canvas, we need
    to remember their states ourselves. Lets say now we want to know how many circles
    are drawn and where they are, and we will need an array to store their position.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Saving the circle position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `circle` object definition code at the top of the JavaScript
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need an array to store the circles position. Add a new array to the
    `untangleGame` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After drawing every circle on the canvas, we save the position of the circle
    into the `circles` array. Add the highlighted line after calling the `drawCircle`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we can test the code in the web browser. There is no visual difference between
    this code and the last example when drawing random circles on canvas. It is because
    we are saving the circles but have not changed any code that affects the appearance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saved the position and color of each circle. This is because we cannot directly
    access the drawn object in canvas. All lines and shapes are drawn on the canvas
    and we cannot access the lines or shapes as individual objects. The drawn items
    are drawn on a canvas. We cannot just move a house in an oil painting, the same
    way we cannot directly manipulate any drawn items in the canvas element.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a basic class definition in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is **object-oriented programming** language. We can define some object
    structure for our use. The `Circle` object provides a data structure for us to
    easily store a collection of x and y positions and the radii.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the `Circle` object, we can create a new `Circle` instance with
    an x, y, and radius value by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more detail usage on object-oriented programming JavaScript, please read
    the Mozilla Developer Center in the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](http://https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have drawn several circles randomly on the canvas. They are in the same style
    and same size. How about we randomly draw the size of the circles? And fill the
    circles with different colors? Try modifying the code and play with the drawing
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have several circles here, how about connecting them with lines? Let's
    draw a straight line between each circle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Drawing straight lines between each circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `index.html` we have just used in the circle drawing example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the wordings **drawing circles in Canvas** to **drawing lines in Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to add the line drawing code on top of our existing circles drawing
    code. Replace the original code with the following. The modified code is highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Test the code in the web browser. We should see there are lines connected with
    each randomly placed circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Drawing straight lines between each circle](img/1260_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the way we saved the circles position, we have an array to save every
    line segment we draw. We declare a line class definition to store some essential
    information of a line segment. That is, we save the start and end point and the
    thickness of the line.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the line drawing API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some drawing APIs for us to draw and style the line stroke
  prefs: []
  type: TYPE_NORMAL
- en: '| Line drawing functions | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MoveTo | The `Moveto` function is like holding the pen in our hand and moving
    it on top of the paper without touching it with the pen. |'
  prefs: []
  type: TYPE_TB
- en: '| LineTo | This function is like putting the pen down on the paper and drawing
    a straight line to the destination point. |'
  prefs: []
  type: TYPE_TB
- en: '| lineWidth | `LineWidth` sets the thickness of the strokes we draw afterwards.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Stroke | `stroke` is the function to execute the drawing. We set up a collection
    of `moveTo, lineTo`, or styling functions and finally call the `stroke` function
    to execute it on canvas. |'
  prefs: []
  type: TYPE_TB
- en: We usually draw lines by using the `moveTo` and `lineTo` pairs. Just like in
    the real world, we move our pen on top of the paper to the starting point of a
    line and put down the pen to draw a line. Then, keep on drawing another line or
    move to the other position before drawing. This is exactly the flow in which we
    draw lines on canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just demonstrated drawing a simple line. We can set different line styles
    to lines in canvas. For more line styling detail, please read the styling guide
    in W3C ([http://dev.w3.org/html5/2dcontext/#line-styles](http://dev.w3.org/html5/2dcontext/#line-styles))
    and Mozilla Developer Center ([https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors](https://developer.mozilla.org/En/Canvas_tutorial/Applying_styles_and_colors)).
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with drawn objects in canvas with mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have shown that we can draw shapes in canvas dynamically based on
    our logic. There is one part missing in the game development that is, input.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine now we can drag the circles around on the canvas, the connected lines
    will follow the circles. In this section, we will add mouse events to the canvas
    to make our circles **draggable.**
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Dragging the circles in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with our previous code. Open the `html5games.untangle.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need a function to clear all the drawing in the canvas. Add the following
    function to the end of the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remove the line drawing code in the jQuery `ready` function. We are going to
    separate it into two parts, the line data and the drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following function that assigns lines to connect each circle. These
    lines will be drawn later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the mouse event listener code to the jQuery `ready` function. The following
    code is how the function looks now. The highlighted code is the mouse event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the `gameloop` function that is responded to draw the updated circles
    and lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Open `index.html` in a web browser. There should be five circles with lines
    connecting them. Try dragging the circles. The dragged circle will follow the
    mouse cursor and the connected lines will follow too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Dragging the circles in canvas](img/1260_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set up three mouse event listeners in the jQuery `ready` function. They
    are the mouse down, move, and up events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the mouse position in the canvas element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can get the mouse cursor position relative to the element in the mouse event
    from the `layerX` and `layerY` property. The following shows the code snippet
    we used in our code example. The `|| 0` is to make the result 0 when the `layerX`
    or `layerY` is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we need to explicitly set the position property of the element
    in order to get the correct `layerX` and `layerY` property.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting mouse events on circles in canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After discussing the difference between DOM-based development and Canvas-based
    development, we cannot directly listen to the mouse events of any drawn shapes
    in the canvas. There is no such thing. We cannot monitor the event on any drawn
    shapes in the canvas. We can only get the mouse event of the canvas element and
    calculate the relative position of the canvas. Then we change the states of the
    game objects according to the mouse position and finally redraw it on canvas.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know we are clicking on a circle?
  prefs: []
  type: TYPE_NORMAL
- en: We can use the **point-in-circle** formula. That is to check the distance between
    the center point of the circle and the mouse position. The mouse clicks on the
    circle when the distance is less than the circle radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following formula to get the distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph shows that when the distance between the center point and
    the mouse cursor is smaller than the radius, the cursor is in the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting mouse events on circles in canvas](img/1260_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code we used explains how we can apply the distance checking
    to know whether the mouse cursor is inside the circle in the mouse down event
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we know that the mouse cursor is pressing the circle in canvas, we mark
    it as the targeted circle to be dragged on the mouse move event. During the mouse
    move event handler, we update the target dragged circle's position to the latest
    cursor position. When the mouse is up, we clear the target circle's reference.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we directly access an already drawn shape in the canvas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes
  prefs: []
  type: TYPE_NORMAL
- en: b. No
  prefs: []
  type: TYPE_NORMAL
- en: Which method can we use to check whether a point is inside a circle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The coordinate of the point is smaller than the coordinate of the center
    of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: b. The distance between the point and the center of the circle is smaller than
    the circle radius.
  prefs: []
  type: TYPE_NORMAL
- en: c. The x coordinate of the point is smaller than the circle radius.
  prefs: []
  type: TYPE_NORMAL
- en: d. The distance between the point and the center of the circle is bigger than
    the circle radius.
  prefs: []
  type: TYPE_NORMAL
- en: Game loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 2, *Getting Started with DOM-based Game Development*, we discussed
    the game loop approach. In the Ping Pong game in Chapter 2, the **game loop**
    manipulates the keyboard input and updates the position of the DOM-based game
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the game loop is used to redraw the canvas to present the later game states.
    If we do not redraw the canvas after changing the states, say the position of
    the circles, we will not see it.
  prefs: []
  type: TYPE_NORMAL
- en: It is like refreshing the image on television. The TV refreshes the screen 12
    times per second. We also redraw the canvas scene several times a second. In each
    redraw, we draw the game state on canvas based on the current circle position.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we drag the circle, we redraw the canvas. The problem is the already drawn
    shapes on canvas won''t disappear automatically. We will keep adding new paths
    to the canvas and finally mess up everything on the canvas. The following screenshot
    is what will happen if we keep dragging the circles without clearing the canvas
    on every redraw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing the canvas](img/1260_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have saved all game statuses in the JavaScript, we can safely clear
    the entire canvas and draw the updated lines and circles with the latest game
    status. To clear the canvas, we use the `clearRect` function provided by canvas
    drawing API. The `clearRect` function clears a rectangle area by providing a rectangle
    clipping region. It accepts the following arguments as the clipping region:'
  prefs: []
  type: TYPE_NORMAL
- en: ctx.clearRect(x,context.clearRect(x, y, width, height)
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x | The top left point of the rectangle clipping region, in x-axis. |'
  prefs: []
  type: TYPE_TB
- en: '| y | The top left point of the rectangle clipping region, in y-axis. |'
  prefs: []
  type: TYPE_TB
- en: '| width | The width of the rectangle region. |'
  prefs: []
  type: TYPE_TB
- en: '| height | The height of the rectangle region. |'
  prefs: []
  type: TYPE_TB
- en: 'The `x` and `y` set the top left position of the region to be cleared. The
    `width` and `height` defines how much area is to be cleared. To clear the entire
    canvas, we can provide (0,0) as the top left position and the width and height
    of the canvas to the `clearRect` function. The following code clears all drawn
    things on the entire canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we clear a portion of the canvas by using the `clearRect` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes
  prefs: []
  type: TYPE_NORMAL
- en: b. No
  prefs: []
  type: TYPE_NORMAL
- en: Does the following code clear things on the drawn canvas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: a. Yes
  prefs: []
  type: TYPE_NORMAL
- en: b. No
  prefs: []
  type: TYPE_NORMAL
- en: Detecting line intersection in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have draggable circles and connected lines on the canvas. Some lines intersect
    others and some do not. Imagine now we want to distinguish the intersected lines.
    We need some mathematics formula to check them and bold those intersected lines.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Distinguishing the intersected lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s increase the thickness of those intersected lines so we can distinguish
    them in the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the `thinLineThickness` setting as the default line thickness. We add
    the following code to define a thickness for bold lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the code more reusable and readable, we want to isolate the
    line intersection logic from the game logic. We create a function to check whether
    the given two lines intersect. Add the following functions to the end of the JavaScript
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a function to check whether our lines intersect and mark that
    line in bold. Add the following new function to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we update the line intersection by adding the following function call
    in two places. One after connecting our circles and the other in the mouse move
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: updateLineIntersection();
  prefs: []
  type: TYPE_NORMAL
- en: It is time to test the intersection in the web browser. When viewing the circles
    and lines in canvas the lines with intersection should be thicker than those without
    intersection. Try dragging the circles to change the intersection relationship
    and the lines will become thin or thick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Distinguishing the intersected lines](img/1260_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just added **line intersection** checking code to our existing circle
    dragging example. The line intersection code involves some mathematical formula
    to get the **intersection point** of two lines and checks whether the point is
    inside the line segment we provide. Let's look at the mathematics part and see
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether two line segments intersect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the intersection equation we learnt from geometry, with two given
    lines in general form, we can get the intersection point.
  prefs: []
  type: TYPE_NORMAL
- en: What is **general form?** In our code, we have the starting point and ending
    point of a line in x and y coordinates. This is a **line segment** because it
    is just a segment part of the line in mathematics. A general form of a line is
    represented by `Ax + By = C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph explains the line segment on a line in general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining whether two line segments intersect](img/1260_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can transform the line segment with point 1 in x1, y1 and point 2 in x2,
    y2 into general form by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a line equation `AX+BY = C` where `A, B, C` are known and `X` and
    `Y` are unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are checking two lines intersecting. We can transform both lines into general
    form and get two line equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By putting the two general form equations together, X and Y are two variables
    that are unknown. We can then solve these two equations and get the intersection
    point of X and Y.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `A1 * B2 - A2 * B1` is zero, then two lines are parallel and there is no
    intersection point. Otherwise we get the interception point by using the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The intersection point of the general forms only provides that the two lines
    are not parallel to each other and will intersect each other at some point. It
    does not guarantee the intersection point is on both line segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graphs show two possible results of the intersection point and
    the given line segments. The intersection point is not in between both line segments
    in the left graph, in this case, the two line segments are not intersected to
    each other. In the right-hand side graph, the point is in between both line segments
    so these two line segments intersect to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining whether two line segments intersect](img/1260_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we need another function named `isInBetween` to determine if a provided
    value is in between the beginning and ending value. Then we use this function
    to check whether the intersection point from the equation is in between both line
    segments that we are checking.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the result of the lines intersection, we draw the thick line to
    indicate those intersected lines.
  prefs: []
  type: TYPE_NORMAL
- en: Making the untangle puzzle game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created an interaction canvas we can drag the circles and the
    lines connecting the circles intersecting with other lines. How about we make
    it a game? There are some pre-defined circles and lines and our aim is to drag
    the circles so that there are no lines intersecting with others. This is called
    an **untangle puzzle game**.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Making the untangle puzzle game in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the game logic to our line intersection code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `index.html` file in text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s set the title as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to display the current level and the progress to the player. Add
    the following code after the canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<p>Puzzle <span id="level">0</span>, Completeness: <span id="progress">0</span>%</p>'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` JavaScript file to add the game logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the variable info, the `untangleGame`. It stores the current level of the
    game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need some pre-defined level data for the players to play. It is a collection
    of data defining where the circles are placed and how they connect to each other
    initially. Add the following level data code to the `untangleGame` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When starting on each level, we need to set up the initial level data. To help
    make the code more readable, we create a function. Add the following code to the
    end of the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a game with several levels. We need to check whether the player solves
    the puzzle in the current level and jumps to the next puzzle. Add the following
    function to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We update the original mouse up event handler to check whether the player completes
    the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are going to draw the circles based on the level data instead of drawing
    them randomly. Therefore, we delete the circle drawing code in the jQuery `ready`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the place we deleted the circle drawing code in the jQuery `ready` function,
    we add the following code to set up the circles level data for game loop to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: setupCurrentLevel();
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update the `connectCircles` function to connect circles based on the
    level data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need another function to update the game progress. Add the following function
    to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to update the level progress in the following mouse move event
    handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Save all files and test the game in the browser. We can drag the circles and
    the line thickness will indicate if it is intersected with other lines. During
    the mouse dragging, the level completeness percentage should change when more
    or less line intersections are detected. If we solve the puzzle, that is no lines
    are intersected, the game will jump to the next level. When the game reaches the
    last level, it will keep showing the last level again. It is because we have not
    yet added the game over screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Making the untangle puzzle game in canvas](img/1260_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have added the game logic to our canvas so that we can play our circle dragging
    code that was created throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the variables we added to the `untangleGame` object. The following
    table lists the description and usage of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| circleRadius | The radius setting of all drawing circles. |'
  prefs: []
  type: TYPE_TB
- en: '| thinLineThickness | The line thickness when drawing thin lines. |'
  prefs: []
  type: TYPE_TB
- en: '| boldLineThickness | The line thickness when drawing bold lines. |'
  prefs: []
  type: TYPE_TB
- en: '| circles | An array to store all drawn circles in the canvas. |'
  prefs: []
  type: TYPE_TB
- en: '| lines | An array to store all drawn lines in the canvas. |'
  prefs: []
  type: TYPE_TB
- en: '| targetCircle | Keeping track of the circle that we are dragging. |'
  prefs: []
  type: TYPE_TB
- en: '| levels | Stores all initial data of each level in the JSON format. |'
  prefs: []
  type: TYPE_TB
- en: '| currentLevel | A number to remember the current level. |'
  prefs: []
  type: TYPE_TB
- en: Defining the leveling data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each level, we have an initial position of the circles for the untangle
    puzzle. The level data is designed as an array of objects. Each object contains
    every level data. Inside every level data, there are three properties: level number,
    circles, and lines connecting the circles. The following table shows the properties
    in each level data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level property | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| level | The level number of the object. | This is a number in each level
    object to let us easily know which level we are in. |'
  prefs: []
  type: TYPE_TB
- en: '| circles | An array of circles'' position in the level. | This defines how
    the circles are placed initially when the level is set up. |'
  prefs: []
  type: TYPE_TB
- en: '| relationships | An array of relationships defining which circles connect
    to each other. | There are some lines connecting the circles in each level. We
    design the line connections so that there is a solution in each level. The line
    relationship defines which circle connects to which circle. For example, the following
    code means circle 1 is connected to circle 2:{"connectedPoints" : [1,2]} |'
  prefs: []
  type: TYPE_TB
- en: After every level data is defined well with our custom structure
  prefs: []
  type: TYPE_NORMAL
- en: Determining level-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The level is complete when there are no lines intersecting with each other.
    We loop through each line and see how many lines are thin. Thin lines mean they
    are not intersected with others. We can use the thin lines to all line ratios
    to get the percentage of the level of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then simply determine the level has been completed when the progress
    is 100 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Displaying current level and completeness progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a sentence below the canvas game describing the current level status
    and progress. It is used for displaying the game status to the players so they
    know that they are making progress in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the jQuery HTML function that we discussed in Chapter 2, *Getting Started
    with DOM-based Game development*, to update the completeness progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have only defined three levels in the example untangle puzzle game. It is
    not fun enough to play with three levels. How about adding more levels to the
    game? If you cannot come up a level, try searching similar untangle games on the
    Internet and get some inspiration on the leveling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about drawing shapes and creating interaction
    with the new HTML5 canvas element and the drawing API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing different paths and shapes in canvas, including circles, arcs, and lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding mouse events and interaction with the drawn paths in the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging drawn paths in the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking line intersection with the help of mathematics formulas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an untangle puzzle game in which players need to drag the circles so
    the connecting lines are not intersected by each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about basic drawing functions in the canvas and drawing
    API, use them to create a puzzle solving game in canvas. We're ready to learn
    some advanced drawing techniques in canvas. In the next chapter, we will enhance
    our untangle puzzle game with more canvas drawing APIs, such as drawing text,
    drawing images, and drawing gradients.
  prefs: []
  type: TYPE_NORMAL
