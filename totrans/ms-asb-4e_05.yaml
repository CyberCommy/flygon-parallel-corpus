- en: '*Chapter 4*: Ansible and Windows – Not Just for Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of the work on Ansible has been performed on Linux OSes; indeed,
    the first two editions of this book were based entirely around the use of Ansible
    in a Linux-centric environment. However, most environments are not like that,
    and, at the very least, are liable to have at least some Microsoft Windows server
    and desktop machines. Since the third edition of this book was published, much
    work has gone into Ansible to create a really robust cross-platform automation
    tool that is equally at home in both a Linux data center and a Windows one. There
    are fundamental differences in the way Windows and Linux hosts operate, of course,
    and so it should come as no surprise that there are some fundamental differences
    between how Ansible automates tasks on Linux, and how it automates tasks on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover those fundamentals in this chapter, so as to give you a rock-solid
    foundation to begin automating your Windows tasks with Ansible, specifically covering
    the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible from Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Windows hosts for Ansible control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Windows authentication and encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating Windows tasks with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running Ansible 4.3 or newer. Almost any flavor of Linux should do; for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless stated otherwise, and on Ansible 4.3.
  prefs: []
  type: TYPE_NORMAL
- en: Where Windows is used in this chapter, the example code was tested and run on
    Windows Server 2019, version 1809, build 17763.1817\. Screenshots of the Windows
    Store were taken from Windows 10 Pro, version 20H2, build 19042.906.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code that accompanies this chapter can be downloaded from GitHub
    at this URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3B2zmvL](https://bit.ly/3B2zmvL).'
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible from Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you browse the official installation documentation for Ansible, you will
    find a variety of instructions for most mainstream Linux variants, Solaris, macOS,
    and FreeBSD. You will note, however, that there is no mention of Windows. There
    is a good reason for this – for those interested in the technical detail, Ansible
    makes extensive use of the POSIX `fork()` syscall in its operations, and no such
    call exists on Windows. POSIX compatibility projects, such as the venerable Cygwin,
    have attempted to implement `fork()` on Windows, but sometimes this does not work
    correctly even today. As a result, despite there being a viable Python implementation
    for Windows, Ansible cannot be run natively on this platform without the presence
    of this important syscall.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that, if you are running recent versions of Windows 10, or
    Windows Server 2016 or 2019, installing and running Ansible is now incredibly
    easy thanks to **Windows Subsystem for Linux** (**WSL**). There are now two versions
    of this technology, the original WSL release (which was featured in the third
    edition of this book), and the newer **WSL2**. **WSL2** is, at the time of writing,
    only available on Windows 10, version 1903 (or higher) with build 18362 (or higher).
    Both of these technologies allow Windows users to run unmodified Linux distributions
    on top of Windows without the complications or overheads of a virtual machine
    (though peer under the hood and you'll see that **WSL2** runs on top of Hyper-V,
    albeit in a seamless manner). As such, these technologies lend themselves perfectly
    to running Ansible, as it can be installed and run with ease and with a reliable
    implementation of the `fork()` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pause to take a look at two important points before we move on. First
    of all, WSL or WSL2 are only required to run Ansible from Windows to control other
    machines (running any OS) – they are not required to control a Windows machine
    with Ansible. We'll see more about this later in the chapter. Secondly, don't
    let the lack of an official build of WSL2 for Windows Server impede you – if you
    have Windows bastion hosts, and wish to run Ansible from them, it is as home on
    **WSL** as it is on **WSL2**. At the time of writing, there is talk of **WSL2**
    being available for the latest Insider Previews of Windows Server; however, as
    I anticipate most readers will be looking for a stable, production-ready solution,
    we will focus more on **WSL** than **WSL2** in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The official Ansible installation documentation can be found at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Checking your build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WSL is only available on specific builds of Windows, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows 10—version 1607 (build 14393) or later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that you will require build 16215 or later if you want to install Linux
    through the Microsoft Store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do want to use WSL2, you will need version 1903 or later (build 18362
    or later) of Windows 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only 64-bit Intel and ARM versions of Windows 10 are supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2016 version 1803 (build 16215) or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2019 version 1709 (build 16237) or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily check your build and version number in PowerShell by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are running an earlier version of Windows, running Ansible is still possible,
    either through a virtual machine or via Cygwin. However, these methods are beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling WSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have verified your build, enabling WSL is easy. Simply open PowerShell
    as an administrator and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation completes successfully, you will be able to select and
    install your preferred Linux distribution. A number are available, but for running
    Ansible, it makes sense to choose one of those listed in the official Ansible
    installation instructions, such as Debian or Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Linux under WSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a recent enough build of Windows 10, then installing your preferred
    Linux is as easy as opening the Microsoft Store and searching for it. For example,
    search for `Ubuntu` and you should find it easily. *Figure 4.1* shows the latest
    LTS build of Ubuntu available for download in the Microsoft Store on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – One of the Linux distributions available for WSL and WSL2 in
    the Microsoft Store app on Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – One of the Linux distributions available for WSL and WSL2 in the
    Microsoft Store app on Windows 10
  prefs: []
  type: TYPE_NORMAL
- en: To install Ubuntu under WSL, simply click on the **Get** button and wait for
    the installation to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running Windows 10, but a supported build earlier than 16215, or
    indeed any supported build of Windows Server 2016/2019, then the installation
    of Linux is a slightly more manual process. First of all, download your preferred
    Linux distribution from Microsoft—for example, Ubuntu 20.04 can be downloaded
    using the following PowerShell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successfully downloaded, unzip the `Ubuntu.appx` file—this can be unzipped
    to any location provided that it is on the system (boot) drive, normally `C:`.
    If you want to keep your Linux distribution private, it can be unzipped somewhere
    within your profile directory, otherwise, you can unzip the file anywhere on the
    system drive. For example, the following PowerShell commands would unzip the archive
    into `C:\WSL\`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once completed, you can launch your newly installed Linux distribution using
    the executable named after the distribution itself. In the case of our Ubuntu
    example, you would run the following through Explorer (or your preferred method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time you run your newly installed Linux distribution, whether it
    was installed through the Microsoft Store or installed manually, it will initialize
    itself. As part of this process, it will ask you to create a new user account.
    Please note that this account is independent of your Windows username and password,
    so be sure to remember the password you set here! You will need it every time
    you run commands through `sudo` (for example), although, as with any Linux distribution,
    you can customize this behavior through `/etc/sudoers` if you wish. This is demonstrated
    in *Figure 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The WSL Ubuntu terminal output during its first run'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The WSL Ubuntu terminal output during its first run
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have Linux running under WSL. From here, you should
    follow the standard installation process for Ansible, and you can run it from
    your Linux subsystem just as you would on any other Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Windows hosts for Ansible control using WinRM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have talked about running Ansible itself from Windows. This is helpful,
    especially in a corporate environment where perhaps Windows end user systems are
    the norm. However, what about actual automation tasks? The good news is that,
    as already stated, automation of Windows with Ansible does not require WSL. One
    of Ansible's core premises is to be agentless, and that remains just as true for
    Windows as for Linux. It is fair to assume that almost any modern Linux host will
    have SSH access enabled, and similarly, most modern Windows hosts have a remote
    management protocol built in, called WinRM. Ardent followers of Windows will know
    that Microsoft has, in a more recent edition, added both the OpenSSH client and
    server packages, and since the last edition of this book was published, experimental
    support for these has been added to Ansible. For security reasons, both of these
    technologies are disabled by default, and so, in this part of the book, we walk
    through the processes for enabling and securing WinRM for remote management with
    Ansible. We will also take a brief look at setting up and using OpenSSH Server
    on Windows – however, as support for this by Ansible is currently experimental
    and carries a number of warnings about stability and backward-incompatible changes
    in future releases, most users will wish to use WinRM, especially in stable production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let's get started on looking at automating tasks on Windows
    hosts using WinRM in the next part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: System requirements for automation with Ansible using WinRM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of WinRM by Ansible means a wide array of support for Windows versions
    new and old—under the hood, just about any Windows version that supports the following
    will work:'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 4.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In practice, this means that the following Windows versions can be supported,
    provided the preceding requirements are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Desktop**: Windows 7 SP1, 8.1, and 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: Windows Server 2008 SP2, 2008 R2 SP1, 2012, 2012 R2, 2016, and
    2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the older OSes listed previously (such as Windows 7 or Server 2008) did
    not ship with .NET 4.0 or PowerShell 3.0, and these will need to be installed
    before they can be used with Ansible. As you would expect, newer versions of PowerShell
    are supported, and, equally, there may be security patches for .NET 4.0\. As long
    as you can meet these minimum requirements, you should be fine to start automating
    Windows tasks with Ansible, even in business settings where older OSes are still
    dominant.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an older (but supported) version of PowerShell such as 3.0,
    be aware that a bug exists in WinRM under PowerShell 3.0 that limits the memory
    available to the service, which, in turn, can cause some Ansible commands to fail.
    This is resolved by ensuring KB2842230 is applied to all hosts running PowerShell
    3.0, so do be sure to check your hotfixes and patches if you are automating tasks
    in Windows via PowerShell 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the WinRM listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once all the system requirements have been met, as detailed previously, the
    task that remains is to enable and secure the WinRM listener. With this achieved,
    we can actually run Ansible tasks against the Windows host itself! WinRM can run
    over both HTTP, and HTTPS protocols, and, while it is quickest and easiest to
    get up and running over plain HTTP, this leaves you vulnerable to packet sniffers
    and the potential for sensitive data to be revealed on the network. This is especially
    true if basic authentication is being used. By default, and perhaps unsurprisingly,
    Windows does not allow remote management with WinRM over HTTP or using basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, basic authentication is sufficient (for example, in a development
    environment), and if it is to be used, then we will definitely want to enable
    HTTPS as the transport for WinRM! However, later in the chapter, we will look
    at Kerberos authentication, which is preferable, and also enables the use of domain
    accounts. For now though, to demonstrate the process of connecting Ansible to
    a Windows host with a modicum of security, we will enable WinRM over HTTPS using
    a self-signed certificate, and enable basic authentication to allow us to work
    with the local `Administrator` account.
  prefs: []
  type: TYPE_NORMAL
- en: 'For WinRM to function over HTTPS, a certificate must exist that has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `CN` value matching the hostname
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Server Authentication (1.3.6.1.5.5.7.3.1)` in the **Enhanced Key Usage** field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, this should be generated by a central **certificate authority** (**CA**)
    to prevent man-in-the-middle attacks and similar—more on this later. However,
    to provide all readers with an example they will be able to test out, we will
    generate a self-signed certificate. Run the following command in PowerShell to
    generate a suitable certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `New-SelfSignedCertificate` command is only available on newer versions
    of Windows—if it is not available on your system, consider using the automated
    PowerShell script provided by Ansible available at [https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1](https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1).
  prefs: []
  type: TYPE_NORMAL
- en: 'This should yield something like that shown in *Figure 4.3* —make a note of
    the certificate thumbprint, as you will need it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Creating a self-signed certificate for the WinRM HTTPS listener
    using PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Creating a self-signed certificate for the WinRM HTTPS listener
    using PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: 'With the certificate in place, we can now set up a new WinRM listener with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When successful, that command sets up a WinRM HTTPS listener on port `5986`
    with the self-signed certificate we generated earlier. To enable Ansible to automate
    this Windows host through WinRM, we need to perform two more steps—open up this
    port on the firewall and enable basic authentication so that we can test using
    the local `Administrator` account. This is achieved with the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output from the previous commands similar to that shown in *Figure
    4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Creating and enabling access to the WinRM HTTPS listener in
    PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Creating and enabling access to the WinRM HTTPS listener in PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: 'These commands have been broken out individually to give you an idea of the
    process involved in setting up a Windows host for Ansible connectivity. For automated
    deployments and systems where `New-SelfSignedCertificate` isn''t available, consider
    using the `ConfigureRemotingForAnsible.ps1` script available on the official Ansible
    GitHub account, which we referenced earlier in this section. This script performs
    all the steps we completed previously (and more), and can be downloaded and run
    in PowerShell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are many other ways to roll out the required configuration of WinRM for
    Ansible, including via Group Policy, which will almost certainly be preferable
    in corporate environments. The information provided in this section of the chapter
    should by now have provided you with all the fundamentals you need to set up WinRM
    in your environment, ready to enable Ansible management of your Windows hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Ansible to Windows using WinRM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once WinRM is configured, getting Ansible talking to Windows is fairly straightforward,
    provided you bear two caveats in mind—it expects to use the SSH protocol, and
    if you don't specify a user account, it will attempt to use the same user account
    that Ansible is being run under to connect. This is almost certainly not going
    to work with a Windows username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that Ansible requires the `winrm` Python module installed to connect
    successfully. This is not always installed by default, so it is worth testing
    for it on your Ansible system before you start working with Windows hosts. If
    it is not present, you will see something like the error shown in *Figure 4.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A simple test for the presence of the winrm Python module on
    Ubuntu Server 20.04'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – A simple test for the presence of the winrm Python module on Ubuntu
    Server 20.04
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see this error, you will need to install the module before proceeding
    any further. There may be a prepackaged version available for your OS—for example,
    on Ubuntu Server 20.04, you can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If a packaged version is not available, install it directly from `pip` using
    the following command. Note that in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from an Earlier Ansible Versions*, we discussed the use of Python virtual
    environments for installing Ansible – if you have done this, you must be sure
    to activate your virtualenv, and then run the following command without `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once this is complete, we can test to see whether our earlier WinRM configuration
    work was successful. For SSH-based connectivity, there is an Ansible module called
    `ansible.builtin.ping`, which performs a full end-to-end test to ensure connectivity,
    successful authentication, and a usable Python environment on the remote system.
    Similarly, there exists a module called `win_ping` (from the `ansible.windows`
    collection), which performs an analogous test on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my test environment, I would prepare an inventory as follows to connect
    to my newly configured Windows host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the connection-specific variables beginning `ansible_` that are being set
    in the `windows:vars` section of the playbook. At this stage, they should be fairly
    self-explanatory, as they were covered in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, but, in particular, note the
    `ansible_winrm_server_cert_validation` variable, which needs to be set to `ignore`
    when working with self-signed certificates. Obviously, in a real-world example,
    you would not leave the `ansible_password` parameter in clear text—it would either
    be placed in an Ansible vault or prompted for upon launch by using the `--ask-pass`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate-based authentication is also possible with WinRM, which carries
    with it more or less the same benefits and risks as SSH key-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous inventory (with appropriate changes for your environment
    such as hostname/IP addresses and authentication details), we can run the following
    command to test connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see some output like that shown in *Figure 4.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Testing Windows host connectivity over WinRM using Ansible''s
    ansible.windows.win_ping module'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Testing Windows host connectivity over WinRM using Ansible's ansible.windows.win_ping
    module
  prefs: []
  type: TYPE_NORMAL
- en: That completes a successful end-to-end setup of an Ansible host to a Windows
    one! From such a setup, you can author and run playbooks just as you would on
    any other system, except that you must work with Ansible modules that specifically
    support Windows. Next, we will work on improving the security of our connection
    between Ansible and Windows, before finally moving on to some examples of Windows
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Windows authentication and encryption when using WinRM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established the basic level of connectivity required for Ansible
    to perform tasks on a Windows host using WinRM, let's dig deeper into the authentication
    and encryption side of things. In the earlier part of the chapter, we used the
    basic authentication mechanism with a local account. While this is fine in a testing
    scenario, what happens in a domain environment? Basic authentication only supports
    local accounts, so clearly we need something else here. We also chose not to validate
    the SSL certificate (as it was self-signed), which again, is fine for testing
    purposes, but is not best practice in a production environment. In this section,
    we will explore options for improving the security of our Ansible communications
    with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible, in fact, supports five different Windows authentication mechanisms
    when WinRM is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**: Supports local accounts only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate**: Supports local accounts only, conceptually similar to SSH
    key-based authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kerberos**: Supports AD accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NTLM**: Supports both local and AD accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CredSSP**: Supports both local and AD accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that Kerberos, NTLM, and CredSSP all provide message encryption
    over HTTP, which improves security. However, we have already seen how easy it
    is to set up WinRM over HTTPS, and WinRM management over plain HTTP is not enabled
    by default anyway, so we will assume that the communication channel is already
    encrypted. WinRM is a SOAP protocol, meaning it must run over a transport layer
    such as HTTP or HTTPS. To prevent remote management commands being intercepted
    on the network, it is best practice to ensure WinRM runs over the HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Of these authentication methods, the one that interests us most is Kerberos.
    Kerberos (for the purpose of this chapter) effectively supersedes NTLM for Ansible
    authentication against Active Directory accounts. CredSSP provides another mechanism,
    but there are also security risks relating to the interception of clear-text logons
    on the target host that are best understood before it is deployed—in fact, it
    is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to configuring Kerberos, a brief note about certificate authentication.
    Although initially, this might seem appealing, as it is effectively passwordless,
    current dependencies in Ansible mean that the private key for the certificate
    authentication must be unencrypted on the Ansible automation host. In this regard,
    it is actually more secure (and wiser) to place the password for either a basic
    or Kerberos authentication session in an Ansible vault. We have already covered
    basic authentication, and so we will focus our efforts on Kerberos here.
  prefs: []
  type: TYPE_NORMAL
- en: As Kerberos authentication only supports Active Directory accounts, it is assumed
    that the Windows host to be controlled by Ansible is already joined to the domain.
    It is also assumed that WinRM over HTTPS has already been set up, as discussed
    earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these requirements in place, the first thing we have to do is install
    a handful of Kerberos-related packages on the Ansible host itself. The exact packages
    will depend upon your chosen OS, but on Red Hat Enterprise Linux/CentOS 8, it
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu 20.04, you would install the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'Package requirements for Kerberos support on a wider range of OSes are available
    in the Ansible documentation for Windows Remote Management: [https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html](https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these packages, we also need to install the `pywinrm[kerberos]`
    Python module. Availability of this will vary—on Red Hat Enterprise Linux/CentOS
    8, it is not available as an RPM, so we need to install it through `pip` as follows
    (again, if you have used a Python Virtual Environment, be sure to activate it
    and run the `pip3` command without `sudo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that `gcc` is needed by `pip3` to build the module—this can be removed
    afterward if no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Next, ensure that your Ansible server can resolve your AD-related DNS entries.
    The procedure for this will vary according to the OS and network architecture,
    but it is vital that your Ansible controller must be able to resolve the name
    of your domain controller and related entries for the rest of this procedure to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have configured your DNS settings for your Ansible control host, next,
    add your domain to `/etc/krb5.conf`. For example, my test domain is `mastery.example.com`,
    and my domain controller is `DEMODEM-O5NVEP9.mastery.example.com`, so the bottom
    of my `/etc/krb5.conf` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the capitalization—this is important! Test your Kerberos integration using
    the `kinit` command with a known domain user account. For example, I will test
    the integration with my test domain using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful test should look like the one shown in *Figure 4.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Testing Kerberos integration between an Ubuntu Ansible control
    host and a Windows domain controller'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Testing Kerberos integration between an Ubuntu Ansible control
    host and a Windows domain controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a Windows host inventory—note that it is almost identical
    to the one we used in our basic authentication example; only this time, we have
    specified the Kerberos domain after the username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test connectivity just like before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – An Ansible connectivity test using the ansible.windows.win_ping
    module'
  prefs: []
  type: TYPE_NORMAL
- en: and Kerberos authentication
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – An Ansible connectivity test using the ansible.windows.win_ping
    module and Kerberos authentication
  prefs: []
  type: TYPE_NORMAL
- en: Success! The previous result shows successful end-to-end connectivity with Windows,
    including successful authentication with a domain account using Kerberos, and
    access to the WinRM subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: A note on accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, WinRM is configured to only allow management by members of the
    local `Administrators` group on a given Windows host. This does not have to be
    the administrator account itself—we have used this here for demonstration purposes.
    It is possible to enable the use of less privileged accounts for WinRM management,
    but their use is likely to prove limited, as most Ansible commands require a degree
    of privileged access. Should you wish to have a less privileged account available
    to Ansible via WinRM, run the following command on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running this command opens a Windows dialog box. Use this to add and grant (as
    a minimum) the `Read` and `Execute` privileges to any user or group you wish to
    have WinRM remote management capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate validation over WinRM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been ignoring the self-signed SSL certificates used in WinRM
    communication—obviously, this is less than ideal, and it is quite straightforward
    to get Ansible to validate SSL certificates if they are not self-signed.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this if your Windows machines are members of a domain
    is to use **Active Directory Certificate Services** (**ADCS**)—however, most businesses
    will have their own certification process in place through ADCS, or another third-party
    service. It is assumed, in order to proceed with this section, that the Windows
    host in question has a certificate generated for remote management, and that the
    CA certificate is available in Base64 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did earlier on the Windows host, you will need to set up an HTTPS
    listener, but this time using the certificate signed by your CA. You can do so
    (if not already completed) using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, replace the `FilePath` certificate with the one that matches the
    location of your own certificate. If you need to, you can delete any previously
    created HTTPS WinRM listener with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using the thumbprint from the imported certificate, create a new listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now to the Ansible controller. The first thing to do is to import the CA certificate
    for the WinRM listener into the CA bundle for your OS. The method and location
    for this will vary between OSes, but, on Ubuntu Server 20.04, you can place the
    Base64-encoded CA certificate in `/usr/share/ca-certificates/`. Note that in order
    to be recognized, the CA file must have the `.crt` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this has been done, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Select `Yes` when asked if you want to trust certificates from new certificate
    authorities, and ensure that your new certificate filename is selected in the
    list presented on the next screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to tell Ansible where to find the certificate. By default,
    Ansible uses the Python Certifi module and will use the default path for this
    unless we tell it otherwise. The above process updates the CA bundle, located
    in `/etc/ssl/certs/ca-certificates.crt`, and luckily, we can tell Ansible where
    to find this in the inventory file. Note the two further changes to the inventory
    file as shown in the following code—first of all, we have now specified the full
    hostname for the Windows host rather than the IP address, as the inventory hostname
    must match the `CN` value on the certificate for full validation to occur. Also,
    we have removed the `ansible_winrm_server_cert_validation` line, which means all
    SSL certificates are now implicitly validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our ping test again, we should now see `SUCCESS`, as shown in *Figure
    4.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Ansible ping test using Kerberos authentication and SSL validation
    to a Windows domain controller over WinRM'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Ansible ping test using Kerberos authentication and SSL validation
    to a Windows domain controller over WinRM
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we could improve our certificate generation to remove the `subjectAltName`
    warning, but for now, this demonstrates Ansible connectivity to Windows, with
    Kerberos authentication to a domain account and full SSL validation. This completes
    our look at setting up WinRM, and should provide you with all the fundamentals
    you need to set up Windows hosts in your infrastructure for automation with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of this chapter, we will take a look at setting up the newly
    supported OpenSSH server on Windows to enable Ansible automation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Windows hosts for Ansible control using OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft has made great strides in supporting and embracing the open source
    community, and has added a number of popular open source packages to their OSes.
    One of the most notable as far as Ansible automation is concerned is the venerable
    and incredibly popular OpenSSH package, which comes in both client and server
    flavors.
  prefs: []
  type: TYPE_NORMAL
- en: Support for automating tasks on Windows using SSH as the transport rather than
    WinRM was added in Ansible 2.8 – however, it should be noted that there are many
    warnings about this support in the official Ansible documentation – support is
    described as experimental, and users are warned that things might change in the
    future in a way that is not backward compatible. In addition, developers expect
    to uncover more bugs as they continue their testing.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, we have put a lot of effort into describing the setup of
    WinRM for automating Windows hosts with Ansible. Nonetheless, this chapter would
    not be complete without a look at enabling Ansible automation for Windows using
    OpenSSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSH Server for Windows is supported on Windows 10 version 1809 and later,
    and also Windows Server 2019\. If you are running an older version of Windows,
    you have two choices – either stay with WinRM as your communication protocol (after
    all, it is built in and easy to configure once you know how), or manually install
    the Win32-OpenSSH package – this process is described in detail here, and should
    support anything from Windows 7 onward: [https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH](https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH).
    Given the active development of this package, readers are advised to refer to
    this documentation if they want to install OpenSSH Server on an older version
    of Windows as the instructions might have changed by the time the book gets to
    print.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you are running one of the newer versions of Windows, installing
    the OpenSSH Server is a simple matter. Using a PowerShell session with Administrator
    privileges, first of all, use the following command to query the available `OpenSSH`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this command should look something like that in *Figure 4.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Showing available OpenSSH installation options in PowerShell
    on Windows Server 2019'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Showing available OpenSSH installation options in PowerShell on
    Windows Server 2019
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this output, run the following command to install the OpenSSH Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following commands to ensure the SSH server service starts at
    boot time, that it is started, and that a suitable firewall rule exists to allow
    SSH traffic to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If an appropriate firewall rule isn''t present, you can add one in with a command
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the OpenSSH server for Windows defaults to `cmd` for its shell. This
    is fine for interactive tasks, but most of the native Ansible modules for Windows
    are written to support PowerShell – you can change the default shell for the OpenSSH
    server by running the following command in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these tasks complete, we can finally test our `ansible.windows.win_ping`
    module just as we did before. Our inventory file will look a little different
    from the WinRM one – the following one should serve as a suitable example for
    your testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are no longer concerned with certificate validation or port numbers
    as we are using SSH over the default port, `22`. In fact, apart from the username
    and password (which you could easily specify as command-line arguments to the
    `ansible` command just as we did earlier in this book), the only inventory variable
    that needs setting is `ansible_shell_type`, which will default to a Bourne-compatible
    shell unless we tell it otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `win_ping` module uses PowerShell when testing connectivity, enabling us
    to use our previous ad hoc command to test our new SSH connectivity to Windows.
    Simply run this command (which should look familiar by now!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we have now used a completely different communication protocol,
    the output from this command is exactly the same, and should look like the following
    *Figure 4.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Testing Ansible integration with Windows using SSH as the transport
    mechanism'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Testing Ansible integration with Windows using SSH as the transport
    mechanism
  prefs: []
  type: TYPE_NORMAL
- en: Thus, integrating Ansible with Windows hosts is really quite simple to set up
    – just be sure to keep your eyes on the release notes and porting guides for newer
    Ansible releases in case things change in some non-compatible way. However, I
    think you'll agree that integrating Ansible with Windows using OpenSSH is simple
    to set up. Of course, you can set up SSH key authentication in a similar manner
    to that on any other SSH-based host to ensure you can run playbooks without the
    need for user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in demonstrating aspects of Windows integration with Ansible through both
    WinRM and SSH, we have only used the Ansible `ansible.windows.win_ping` module
    to test connectivity. Let's build on this by wrapping up the chapter with some
    simple example playbooks to help you get started on creating your own Windows
    automation solutions with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Windows tasks with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list of the Windows modules included with Ansible 4.3 is available at the
    following link, and it must be noted that, although you can use all the familiar
    Ansible constructs with Windows hosts such as `vars`, `handlers`, and `blocks`,
    you must use Windows-specific modules when defining tasks. The introduction of
    collections means it is quite easy to locate them, and the `ansible.windows` collection
    is a great place to start. This contains all the Windows-specific modules you
    were used to using in Ansible 2.9 and earlier: https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-windows.'
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the chapter, we will run through a few simple examples of Windows
    playbooks to highlight a few of the things you need to know when writing playbooks
    for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Picking the right module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you were running Ansible against a Linux server, and wanted to create a
    directory and then copy a file into it, you would use the `ansible.builtin.file`
    and `ansible.builtin.copy` Ansible modules, in a playbook that looks something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, on Windows, this playbook would fail to run, as the `ansible.builtin.file`
    and `ansible.builtin.copy` modules are not compatible with PowerShell or cmd,
    regardless of whether you use WinRM or SSH as your communication protocol with
    the Windows machine. As a result, an equivalent playbook to perform the same task,
    but on Windows, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following differences between the two playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.windows.win_file` and `ansible.windows.win_copy` are used in place
    of the `ansible.builtin.file` and `ansible.builtin.copy` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended in the documentation for the `ansible.windows.win_file` and
    `ansible.windows.win_copy` modules to use a backslash (`\`) when dealing with
    remote (Windows paths).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue to use forward slashes (`/`) on the Linux host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use single quotes (not double quotes) to quote paths that contain spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is always important to consult the documentation for the individual modules
    used in your playbooks. For example, reviewing the `ansible.windows.win_copy`
    module documentation, it recommends using the `ansible.windows.win_get_url` module
    for large file transfers because the WinRM transfer mechanism is not very efficient.
    Of course, if you are using the OpenSSH server in place of WinRM, this may not
    apply – at the time of writing, the documentation for this module has not been
    updated to take account of this.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, if a filename contains certain special characters (for example,
    square braces), they need to be escaped using the PowerShell escape character, [PRE34]
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Install package'
  prefs: []
  type: TYPE_NORMAL
- en: 'win_package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: ''c:\temp\setupdownloader_`[aaff`].exe'''
  prefs: []
  type: TYPE_NORMAL
- en: 'product_id: {00000000-0000-0000-0000-000000000000}'
  prefs: []
  type: TYPE_NORMAL
- en: 'arguments: /silent /unattended'
  prefs: []
  type: TYPE_NORMAL
- en: 'state: present'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Install Acrobat Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'chocolatey.chocolatey.win_chocolatey:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: adobereader'
  prefs: []
  type: TYPE_NORMAL
- en: 'state: present'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Create a directory using PowerShell'
  prefs: []
  type: TYPE_NORMAL
- en: 'ansible.windows.win_shell: New-Item -Path C:\Mastery -ItemType Directory'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Create a directory using cmd.exe'
  prefs: []
  type: TYPE_NORMAL
- en: 'ansible.windows.win_shell: mkdir C:\MasteryCMD'
  prefs: []
  type: TYPE_NORMAL
- en: 'args:'
  prefs: []
  type: TYPE_NORMAL
- en: 'executable: cmd'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: c) `"`
  prefs: []
  type: TYPE_NORMAL
- en: d) `/`
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Ansible playbooks must be changed depending on whether you are using WinRM
    or SSH communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
