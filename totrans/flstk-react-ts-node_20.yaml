- en: '*Chapter 17*: Deploying an Application to AWS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application, once finalized, must be deployed before it can be used. We have
    many options to choose from, including using our own infrastructure. These days,
    however, most companies prefer to use the services of a cloud provider in order
    to reduce their IT-related expenditures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about deploying our application to **Amazon Web
    Services.** (**AWS**) is, of course, the standard when it comes to Cloud providers.
    We'll be setting up our application services Redis, Postgres, and NGINX on top
    of a Linux VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ubuntu Linux on AWS Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Redis, Postgres, and Node on Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and deploying our app on NGINX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a solid understanding of web technologies. Although it can
    take years to become a senior-level developer, you should now feel comfortable
    with TypeScript, JavaScript, React, Express, and GraphQL. In this chapter, we
    will once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is again available at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap17` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do some basic setup on your development machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Chap17` folder and then copy the `super-forum-server` and `super-forum-client`
    folders from the source code of the `Chap15` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `node_modules` and `package-lock.json` get copied over, then delete those
    folders and files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, terminal into the `Chap17/super-forum-server` folder and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, terminal into the `Chap17/super-forum-client` folder and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Ubuntu Linux on AWS Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll learn about selecting and setting up an Ubuntu Linux
    server on an AWS VM. I''ll assume you know how to create an AWS account already.
    The process is fairly straightforward, as an existing Ubuntu Linux image will
    already be available to use. Let''s start:'
  prefs: []
  type: TYPE_NORMAL
- en: After we log in, the screenshot shown here will be the current AWS portal. Note
    that these screens change frequently, so your view may be different:![Figure 17.1
    – AWS Portal home
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – AWS Portal home
  prefs: []
  type: TYPE_NORMAL
- en: We can see the **Launch a virtual machine** link. Select it and you will get
    to this next screen:![Figure 17.2 – Initial VM screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – Initial VM screen
  prefs: []
  type: TYPE_NORMAL
- en: Let's select the image for **Ubuntu 20.04 LTS**. This is the latest **Long Term
    Support** version of Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Once selected, you should see the following screen:![Figure 17.3 – VM instance
    type selector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 – VM instance type selector
  prefs: []
  type: TYPE_NORMAL
- en: I have gone ahead and selected a lower-end image with 1 vCPU and 2 GB of memory.
    Note that EBS is an AWS-specific performance optimization for storage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's keep things simple by keeping the default settings and select the **Review
    and Launch** button at the bottom of the screen after making our selection.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the major details of what I have selected:![Figure 17.4 – Initial provisioning
    screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 – Initial provisioning screen
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the **Launch** button at the bottom to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will see the following prompt:![Figure 17.5 – Select an existing key
    pair dialog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 – Select an existing key pair dialog
  prefs: []
  type: TYPE_NORMAL
- en: This screen creates a set of encryption keys for use with SSH, one for you and
    one for AWS, so we can remote terminal into the VM. Download these files and keep
    them secure. Click the **Launch Instances** button to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You must keep your pem file somewhere safe and accessible. You will not be able
    to download it again.
  prefs: []
  type: TYPE_NORMAL
- en: Once complete, you should see the **Launch Status** screen. Just click on the
    **View Instances** button at the bottom to continue to the portal:![Figure 17.6
    – VM setup complete screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.6 – VM setup complete screen
  prefs: []
  type: TYPE_NORMAL
- en: This will be your VM instance portal:![Figure 17.7 – VM portal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.7 – VM portal
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Instance ID** and you will get the **Instance summary** screen:![Figure
    17.8 – Instance summary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.8 – Instance summary
  prefs: []
  type: TYPE_NORMAL
- en: You can see quick facts, such as the running instance state, the public IP address,
    and the public DNS name.
  prefs: []
  type: TYPE_NORMAL
- en: Near the top-right corner of this screen, you will see the **Connect** button.
    Click it to get the **Connect to instance** screen:![Figure 17.9 – Connect to
    instance screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.9 – Connect to instance screen
  prefs: []
  type: TYPE_NORMAL
- en: 'The first tab is **EC2 Instance Connect**, which is a terminal provided for
    us by AWS. Click the **Connect** button and we will see a terminal to our Ubuntu
    server inside our browser, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10 – AWS EC2 Instance Connect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.10 – AWS EC2 Instance Connect
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional interface we can use if SSH is not working for some reason.
    For this demonstration, I will use the SSH interface.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your **Connect to instance** screen and select the third tab, **SSH
    client**. You should see something like this. Of course, your values will be unique:![Figure
    17.11 – SSH how to instructions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.11 – SSH how to instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample of how I ran these instructions on my own terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.12 – First SSH terminal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.12 – First SSH terminal
  prefs: []
  type: TYPE_NORMAL
- en: First, I changed the permissions of my local pem file as per the AWS instructions.
    Then, I ran SSH as shown. Note that I used `ubuntu` as the username, your VM should
    also be the same, and I used `DNS name` for my server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If this does not work for you, try opening your network inbound rules for SSH
    to be **Source Anywhere**. If that, too, does not work, you can also revert to
    using the terminal provided by AWS, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our setup of Ubuntu Linux. Let's install Redis next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Redis, Postgres, and Node on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will install our main requirements onto our Linux server.
    We already covered the setup and configuration of Redis in [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208),
    *Setting Up a Session State Using Express and Redis*, but let's do it one final
    time since we will now all have the same underlying OS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will install our Redis server and configure it for our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On your terminal, log in to the server and run these two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is complete, open the `redis.conf` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Find the `requirepass` entry, uncomment it, and then add your own password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The password in the source code folder's `super-forum-server/dev-config/.env`
    file for the `REDIS_PASSWORD` variable must match the password you entered in
    your `redis.conf` file. We will be including the files in the `dev-config` folder
    later when we do our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, find the `supervised` entry and set it to a value of `systemd`. This allows
    Ubuntu to control Redis via its `init` system, which uses a command called `systemctl`.
    Now, save and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s restart our Redis server to take the new settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to stop the service, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to start the service, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this command, it will show whether Redis is running properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.13 – Redis status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.13 – Redis status
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we installed Redis onto our Ubuntu server and turned on the
    ability to start and stop the server as desired. We will now continue by installing
    Postgres.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Postgres
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s install Postgres for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use `apt` again. Run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's check that it's working by running the command shown in this screenshot:![Figure
    17.14 – The psql command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.14 – The psql command
  prefs: []
  type: TYPE_NORMAL
- en: The `postgres` role shown in the command is the global admin account created
    by default in Postgres. We are basically making our logged-in Linux account act
    as if it is the `postgres` account temporarily by using `-i` in the command. `-u`
    indicates which role we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are not using `pgAdmin` because we get the same capabilities using the `psql`
    command-line tool, and enabling `pgAdmin` with AWS is cumbersome and difficult.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we are running as the `postgres@<your ip>` user, as was shown in the
    screenshot. If we were not running as Postgres, we would need to prefix any Postgres
    commands with `sudo -u postgres`. But since we are running as the role of Postgres,
    we can just run the command as shown in *Figure 17.13*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `createuser –-interactive` command creates a new user based on a series
    of prompts. Run this command and answer the prompts as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.15 – createuser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.15 – createuser
  prefs: []
  type: TYPE_NORMAL
- en: I've set the username to `superforumsvc`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll give our new user a password like this:![Figure 17.16 – Setting a
    new user password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.16 – Setting a new user password
  prefs: []
  type: TYPE_NORMAL
- en: First, I enable the command-line tool, `psql`. Then I enter a SQL query to change
    the `superforumsvc` user's password.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I cut off the end after the keyword password, which shows what the
    password is, but it should be in single quotes like this, **'<your password>'**.
    Obviously, you'll want to create your own password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the database for the app. First, exit the `psql` command
    and then create the database like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add our `ThreadCategory` default to our database. In the `super-forum-server`
    project, you will find the `utils/InsertThreadCategories.txt` file. Therein are
    the `Categories` we''ve been using. Of course, you can add your own `Categories`
    if you like as well. Here''s a sample of my insert attempt for a category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.17 – Inserting ThreadCategory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.17_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.17 – Inserting ThreadCategory
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it fails the first few times. So, let's dig through this. First,
    you must be on the correct database. So, again use `\c` to do that. Note that
    the database name is case-sensitive. Then, make sure your table and field names
    have double quotes around them. For the `psql` command line, do not use the `pgAdmin`
    only.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for our Postgres setup. Next, let's set up Node.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s install Node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run this to check and you should see the version number of your Node installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Your node version should be *at least* version 12 or higher. If not, you''ll
    need to run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run this command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s install NPM by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to install a way to manage our Node server, that is, to shut it
    down and autorestart it. So, we will use `pm2`, which is currently one of the
    most popular ways of managing Node. Notice we use the `-g` switch to install it
    globally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we reviewed how to set up our core service dependencies: Redis,
    Postgres, and Node. We are now ready to begin setting up the actual server using
    NGINX.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and deploying our app on NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will install and configure our app for using NGINX. NGINX
    is a very popular high-performance web server, reverse proxy, and load balancer.
    It is respected for its strong performance and also its capabilities to handle
    different configurations for sites using multiple servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use it to serve two sites. One will serve our React client, and the
    other will serve our GraphQL Express server. All of our site traffic will be going
    to NGINX first and then it will redirect those requests to the appropriate part
    of our application. Let''s start by installing NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH into your server, as shown previously in the *Setting up Ubuntu Linux on
    AWS Cloud* section and run these commands to install NGINX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that NGINX is installed, let''s create a folder to store our server files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Setting up super-forum-server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create the build and deployment process for our server
    code. It is good to have a standardized process for deployment so that your deployments
    are consistent and reliable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start copying our files, we need to do some basic setup and a
    build of our server project. Open the `super-forum-server` project in VSCode.
    If you look at the `package.json` file''s scripts section, you will see that we
    have a new script called `build`. This will compile our server code and package
    it appropriately for distribution into the `dist` folder. Now, in order to get
    this command to work, we will need to install some NPM packages globally first.
    Run the following command on your developer machine, *not the Ubuntu server*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, there seems to be some sort of bug with the latest Express NPM
    packages, so we will need to install one more NPM package dependency. Run this
    command on your development machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note one thing. In the `super-forum-server/src/index.ts` file, I've added a
    new function, `loadEnv`, near the top of the file. This file will deal with relative
    path differences of the `.env` file between your development and server environments,
    using the Node `__dirname` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I've also tweaked the `super-forum-server/dev-config/ormconfig.js` file so that
    it uses `__dirname` for the path to the TypeORM entities.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: We have enabled the `synchronize` field in `ormconfig.js` to be `true`. This
    setting is for development deployments only. Do not use this setting in production,
    since it can trigger unwanted database changes. For production, you should use
    a pre-made database and then deploy that directly, with the `synchronize` setting
    set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK. Let''s now try running our build script. Run this command on your development
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try copying our `dist` folder to our server. On the terminal of
    your development machine, run this command with configurations appropriate to
    you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Log back in to your Ubuntu SSH session and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command will open all access temporarily so that we can copy our files.
    We will close it back up after our copy has happened to reduce security risks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, copy the files by using the same `scp` command from your development terminal.
    For example, here's my command, run from my developer machine, after opening permissions:![Figure
    17.20 – Scp copy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.20_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.20 – Scp copy
  prefs: []
  type: TYPE_NORMAL
- en: Now, check that all the configuration files were copied onto the server by looking
    in the `server` folder, as follows:![Figure 17.21 – Server folder check
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.21_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Again, the precise paths will be different for your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should close our permissions back up again with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This permission gives the owner full access, but gives others only execute and
    read access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If we fall down the rabbit hole of security optimizations, we could end up writing
    another book. Since this will be a development server that will probably be thrown
    away, let's focus on the main tasks for now. Once you're ready to go live to production
    with your billion-dollar app, you'll need to exercise some due diligence on security
    or, better yet, hire someone with at least 10 years' experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on our SSH terminal session on the Ubuntu server, cd into the `/var/www/superforum/server`
    folder and then run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will, of course, install all the dependencies for our Node app server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set up our `pm2` system so that it will control our Node server.
    Run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, copy and paste this command starting at `sudo`, and then run it on your
    SSH session of your Ubuntu server. Once run, you should see something like this:![Figure
    17.23 – Result of pm2 startup running
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.23_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.23 – Result of pm2 startup running
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to start our Node server as follows:![Figure 17.24 – Node server
    started
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.24_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.24 – Node server started
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now save this as part of pm2''s startup list by running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once run, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.25 – pm2 save run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.25_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.25 – pm2 save run
  prefs: []
  type: TYPE_NORMAL
- en: By doing this save operation, our Node server will now start automatically whenever
    our server is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created a process to build, deploy, and start our Node server.
    Having configured this setup, we can be sure that it will be repeatable as we
    update our code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up super-forum-client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, so now we have to do a similar process for our client-side project. You
    should have the `super-forum-client` already copied over to your `Chap17` folder,
    as that''s the first thing we did at the start of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to your SSH terminal session on your Ubuntu server and create
    the folder for the client project like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go back to your development terminal in the `super-forum-client` project
    folder so that we can do the client build and deploy. First, we need to do a minor
    tweak to our project. You saw that our server project uses an `.env` file for
    settings. We don''t need anything that involved our client project. However, we
    should be able to at least set the GraphQL server URL as required, depending on
    the deployment environment. Therefore, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `index.ts` with VSCode and update the `ApolloClient` code like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Open the `package.json` file and look at the scripts section. You should see
    a new script called `build-dev` that sets the `REACT_APP_GQL_URL` variable. Feel
    free to create multiple versions of this script for your own needs with differing
    variable values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, now let''s run the `build-dev` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to open the server''s client folder temporarily so that we
    can do our copy. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can deploy our client-side build files. From your development terminal,
    run this command, with your own proper paths of course:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.27 – Copying client files to the server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.27_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.27 – Copying client files to the server
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, undo the permissions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Configuring NGINX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All right. We have done a lot of configuring of our server build, so now we
    can continue by configuring our installed NGINX server:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to have NGINX start when starting the system in our Ubuntu server. Run
    the command shown on your SSH terminal and then authenticate as shown:![Figure
    17.28 – Enabling NGINX start when the system boots
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.28_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.28 – Enabling NGINX start when the system boots
  prefs: []
  type: TYPE_NORMAL
- en: Now, check that NGINX is running with the `status` command shown here:![Figure
    17.29 – NGINX status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.29_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.29 – NGINX status
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to open Port 80 on our AWS VM firewall. Open the browser to the
    AWS portal and then select **Security Groups**, under the **Network & Security**
    menu. Then you'll see this:![Figure 17.30 – Security Groups
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.30_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.30 – Security Groups
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the non-default group and you'll see the screen shown in the following
    screenshot. Notice **Inbound rules** near the bottom:![Figure 17.31 – Networking
    tab; adding an inbound port rule
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.31_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.31 – Networking tab; adding an inbound port rule
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Edit inbound rules** button and then, on that next screen, click
    the **Add rule** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that''s selected, you should see this screen shown in *Figure 17.32*.
    Add the new inbound rule for HTTP, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.32 – New HTTP inbound rule'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.32_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.32 – New HTTP inbound rule
  prefs: []
  type: TYPE_NORMAL
- en: By selecting **0.0.0.0/0** as the source, you are allowing any IP addresses,
    which is what we want. Now, save the rule by clicking the **Save rules** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the local Ubuntu firewall is not enabled. However, if it is enabled,
    we also need to let traffic through to NGINX on the firewall. If necessary, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, clearly our NGINX is installed and working. So now we need to make it serve
    up our site. Note that there appears to be a bug in NGINX for dealing with very
    long domain names, like the one I received after registering on AWS. Therefore,
    for our website, we will use the IP address instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NGINX has two options for setting up sites. One allows us to use the configuration
    file in the `/etc/nginx/conf.d` folder. The other, called Server Blocks, uses
    the `/etc/nginx/sites-available` folder. We will use the `conf.d` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now this is what your file should contain, again with your own folder paths
    and domain name:![Figure 17.35 – New NGINX conf file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.35_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.35 – New NGINX conf file
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget the concluding semi-colon on each line. Without it, you will get
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '`server_name` is the domain name or IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: '`root` is the folder that contains our HTML file.'
  prefs: []
  type: TYPE_NORMAL
- en: '`location / is` the root of our website.'
  prefs: []
  type: TYPE_NORMAL
- en: '`location /graphql` is where our GraphQL server lives. We are using `proxy_pass`
    to redirect calls to `http://<domain or ip>/graphql` to our `http://localhost:5000/graphql`
    server (our Node server).'
  prefs: []
  type: TYPE_NORMAL
- en: '`<prefix>_timeout` fields are to prevent Error 503 Gateway Timeout issues,
    which can sometimes happen with NGINX.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to test that our config changes are OK by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.36 – NGINX config file status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.36_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see whether our app on the browser comes up. First, let''s stop
    our Node server and restart it without using `pm2`, so that we can see any errors
    that might be occurring. Run these commands on your Ubuntu SSH terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.37 – First run of the Node server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.37_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.37 – First run of the Node server
  prefs: []
  type: TYPE_NORMAL
- en: Again, your IP address will be different, and possibly your paths if you changed
    them. If you see errors instead, go to the troubleshooting section later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open your browser and go to your IP address as given by AWS. Then, click
    on the **Register** button and let's register a new user, as shown next:![Figure
    17.38 – Registering a new user test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.38_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.38 – Registering a new user test
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the values as you see fit and click the **Register** button. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.39 – Registration success'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.39_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.39 – Registration success
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to confirm our new user. Run these commands on the Ubuntu SSH terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just confirm that all of our users are registered. Once the commands
    are complete, you should see a confirmation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.40 – Confirm registered users'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.40_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.40 – Confirm registered users
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try and log in with our new user:![Figure 17.41 – Logged-in test3
    user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.41_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.41 – Logged-in test3 user
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, currently we have no data, so now we''ll add one thread post, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.42 – First post'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.42_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.42 – First post
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is now our home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.43 – Home screen following the first post'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.43_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.43 – Home screen following the first post
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We're done!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we finalized our setup of our application using NGINX and all
    of our other services. Congratulations! You've done a phenomenal job and have
    gotten through an enormous amount of highly technical material.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up and using cloud services can be a great deal more complex than just
    using a server on your own network. Here are some basic tips for dealing with
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Any time you update client files, you must restart NGINX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any time you update the server files, you must restart the Node server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always verify that your `.env` settings are correct and match the names you
    chose during setup; for example, the name of your Postgres database, its username,
    and password. Also make sure that the path to your `.env` file is correct and
    is being picked up by the Node server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure the `PG_ENTITIES` and `PG_ENTITIES_DIR` variables have the correct
    paths. For our current app, this would be the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PG_ENTITIES="/repo/**/*.*"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`PG_ENTITIES_DIR="/repo"`'
  prefs: []
  type: TYPE_NORMAL
- en: If these are not set properly, you may get an error, such as `No repository
    for <Entity Name> was found`.
  prefs: []
  type: TYPE_NORMAL
- en: If you edit your `.env` file on your server, make sure it is **not** being overwritten
    during the deploy process. In other words, don't edit your file on the server!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use the `sudo nginx -t` command after updating any `.conf` files for
    NGINX and then restart the NGINX service once configuration changes are complete.
    If you do get an error, make sure all of your configuration lines end with a semi-colon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're making changes in your development environment and testing them there,
    make sure you have set the `NODE_ENV` environment variable to development. You'll
    need to set this permanently or else it will disappear on reboot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGINX has a common error of `504 Gateway Timeout`. Make sure your timeout configurations
    are sufficient. You'll have to play with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that very long domain names seem to be an issue in NGINX. For testing purposes,
    see whether using the IP address works. If it does, and the domain does not, you
    then know your issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we cemented our knowledge of web development with React, Node,
    and GraphQL by finally deploying our application to the cloud. Learning how to
    deploy our app onto the AWS Cloud is extremely valuable since it is currently
    the most popular and widely used cloud service. Also, doing this with NGINX was
    the right move since NGINX is very performant and extremely popular in the Node
    community.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you so much for joining me on this journey. As a developer, there is always
    something new to learn and try. But you have taken a huge step by gaining an understanding
    of some of the most important and key web technologies. You now have all the tools
    you need in order to create real, full stack, cutting-edge web applications. Again,
    congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: I wish you continued success.
  prefs: []
  type: TYPE_NORMAL
