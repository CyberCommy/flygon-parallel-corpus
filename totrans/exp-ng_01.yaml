- en: Architectural Overview and Building a Simple App in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't matter if you are new to AngularJS or new to Angular. If you want
    to quickly develop great web apps with rich UIs and with the features of Angular
    components, templates, and services, you need to master Angular, and this book
    is for you.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is a JavaScript framework that enables developers to build web and mobile
    applications. Applications built with Angular can target any device, such as mobiles,
    tablets, and desktops. Angular is not an incremental version of AngularJS. It
    was completely rewritten with improved Dependency Injection, dynamic loading,
    and simpler routing, and recommends that developers use TypeScript and leverage
    OOPS, static typing, generics, and lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss architecture, let's see what's new in Angular. The primary
    focus of Angular is mobiles, as it is important to consider the performance and
    loading time of the application on a mobile phone. Many modules are decoupled
    from the Angular core, leaving only the modules that are definitely core; removing
    unwanted modules from Angular core leads to better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Angular targets ES6 and leverages TypeScript as a development script language
    that enables compile time checks for types, rather than at runtime. TypeScript
    provides additional information about classes when instantiating them by annotating
    metadata to the classes. You can also use ES5 and Dart as the development language.
    There is an improved version of Dependency Injection that supports child injectors
    and instance scope. Router was rewritten completely and the component router was
    introduced. The Component Directive, the Decorator Directive, and the Template
    Directive are supported in Angular. The $scope has been completely removed from
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of Angular comprises **Modules**, **Components**, **Templates**,
    **Metadata**, **Directives**, and **Services**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32caa67c-98c9-4d0b-bf2f-36f862ab6133.png)'
  prefs: []
  type: TYPE_IMG
- en: NgModules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular framework has various libraries that are grouped as modules in order
    to build an application. Angular applications are modular in nature and are constructed
    by assembling various modules. Modules may have components, services, functions,
    and/or values. Some modules may have a collection of other modules and are known
    as library modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular packages, such as `core`, `common`, `http`, and `router` that are prefixed
    with `@angular` comprise many modules. We import what our application needs from
    these library modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import `Http` and `Response` from the library module, `@angular/http`.
    `@angular/http` refers to a folder in the Angular package. Any module defined
    to be exported can be imported into another module by referring to the filename
    of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: this import statement was introduced in ES2015 and is used to import
    objects or function that are exported from other modules or scripts'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can also refer to the folder as we referred to `@angular/http`.
    This can be achieved by adding an `index.ts` file to the folder and adding the
    code to export modules from the folder. This is a best practice suggested by Angular''s
    style guide and is called the barrel technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the export statement in the `index.ts` found in `@angular/http`. The
    statement means that it exports all the modules in HTTP and that they can be imported
    to our application wherever needed.
  prefs: []
  type: TYPE_NORMAL
- en: When we write an Angular application, we start by defining an `AppComponent`
    (not necessarily with the same name) and exporting it.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A component is a class that has properties and methods to be used in the view.
    These properties and methods exposed to view enable the view to interact with
    components. We code logic that supports the view in the component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43c035d9-7a54-4859-9299-d8eb48f73541.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, next is a component class book that has a `properties` title and
    author and a `getPubName` method that returns the name of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: We will be using TypeScript in all our examples in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of a component is managed by Angular according to user interactions
    with the application. We can also add an `event` method that will be fired according
    to the state changes of the component. These `event` methods are known as life
    cycle hooks and are optional.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn in detail about components in [Chapter 5](57d46335-212e-47fc-b817-828b7f684476.xhtml),
    *Implementing Angular Routing and Navigation*.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates can be thought of as a representation of a component that is visualized
    according to the UI/UX needs of an application. A component will have a template
    associated with it. The template is responsible for displaying and updating data
    according to user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d2f3477c-a8d3-4260-8393-bf9ef72718aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a simple template that displays the title and author of a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the title and author values wrapped in curly braces will be supplied by
    the associated component instance.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss templates and their syntax in detail in [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can be turned into a component by annotating it with `@Component` and
    passing the necessary metadata, such as `selector`, `template`, or `templateUrl`.
    Angular considers a class as a component only after attaching metadata to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5ede5bd-7d8a-412f-ad70-7076b5d69a58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s revisit the `BookComponent` class we defined earlier. Angular does not
    consider this class as a component unless we annotate it. TypeScript leverages
    the ES7 feature by providing a way to decorate a class with metadata as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have decorated the `BookComponent` class with `@Component` and attached
    metadata selector and `templateUrl`. It means that, wherever Angular sees the
    special `<book-detail/>` tag in the view, it will create an instance of `BookComponent`
    and render the view assigned to `templateUrl`, which is `book.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator provided by TypeScript is a function that takes configuration parameters
    that are used by Angular to create an instance of the component and render the
    associated view. Configuration parameters may also have information about directives
    and providers, which will be made available by Angular when the component is created.
  prefs: []
  type: TYPE_NORMAL
- en: Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data Binding is one of the core responsibilities of developers when writing
    code to bind data to the user interface and update changing data according to
    user interactions with the user interface. Angular has reduced the burden of writing
    large amounts of code to handle Data Binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59d7cea0-56cd-4202-8001-837ecfaf9461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Angular handles Data Binding by coordinating with templates and components.
    The templates provide instructions to Angular on how and what to bind. There are
    two types of binding in Angular: globally One-way Data Binding and Two-way Data
    Binding. One-way Data Binding deals with either binding data from the component
    to the DOM or from the DOM to the component. Two-way Data Binding deals with both
    sides of communication, that is, the component to the DOM and the DOM to the component.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `book.title` wrapped in double curly braces deals with One-way Data Binding.
    The value of book title, if available in the component instance, will be displayed
    in the view. `book.author`, assigned to the `ngModel` property of the input element,
    deals with Two-way Data Binding. If the component instance has a value in the
    author property, then it will be assigned to the input elements, and if the value
    is changed by the user in the input control, then the updated value will be available
    in the component instance.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn in detail about Data Binding in [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A directive is instructions or guidelines for rendering a template. A class
    decorated with `@Directive` to attached metadata is called a directive. There
    are three types of directive supported by Angular, namely Component Directive,
    Structural Directive, and Attribute Directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/691c7928-e999-4ce4-bc82-fa0b8b6c6c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A component is one form of a directive with a template that is decorated with
    `@Component`: it is actually an extended `@Directive` with a template feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Structural Directives manipulate the DOM elements and alter their structure
    by adding, removing, and replacing DOM elements. The following code snippet uses
    two Structural Directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `div` element has a `*ngFor` directive that iterates through the books
    collection object and replaces the title of each book.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Attribute Directive helps to update the behavior or the appearance of an
    element. Let''s use the Attribute Directive to set the font size of a paragraph.
    The following code snippet shows an HTML statement implemented with an Attribute
    Directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement a class annotated with `@Directive` along with the selector
    for the directive. This class should be implemented with the instructions on the
    behavior of the directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, Angular will look for elements with the `[myFontsize]` directive and sets
    the font size to `16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is necessary to pass the `myFontSize` directive to the declarations metadata
    of `@NgModule` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss directives in detail in [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml),
    *Creating Directives and Implementing Change Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services are user-defined classes used to solve problems. Angular recommends
    only having template-specific codes in components. A component''s responsibility
    is to enrich the UI/UX in the Angular application and delegate business logic
    to services. Components are consumers of services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db5db7b5-cee5-43bd-bdf5-a54751faacbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Application-specific or business logic such as persisting application data,
    logging errors, and file storage should be delegated to services, and components
    should consume the respective services to deal with the appropriate business or
    application-specific logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02804b2d-fc90-43cf-819d-ee823fb3f51a.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, we can have a service called `BookService` that deals with inserting
    new books, editing or deleting existing books, and fetching a list of all the
    books available.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more about services in [Chapter 11](3fdebb29-fbfb-4c2e-9985-d5b7771fcffa.xhtml),
    *Implementing Angular Pipes*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an instance of a class is created, supplying the required dependencies
    of that class for it to function properly is called Dependency Injection. Angular
    provides a modern and improved version of Dependency Injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51888c08-2111-4385-90e5-fcbc57d1ed80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Angular, the injector maintains the containers to hold the instances of
    the dependencies and serves them as and when required. If the instance of a dependency
    is not available in the container, then the injector creates an instance of the
    dependency and serves it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4e33b01c-c3c2-4235-8a42-7d7bbe5fe6cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As stated earlier, components have logic that is related to templates and mostly
    consume services to perform business logic. So, components depend on services.
    When we write code for components, we create a parameter constructor that takes
    the service as an argument. It means that creating an instance of the component
    depends on the service parameter in the constructor. Angular requests that the
    injector provide the instance of the service in the parameter of the constructor
    of the component. The injector will serve the instance of the requested service,
    if available; otherwise, it creates a new one and serves it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `:` symbol comes from TypeScript and is not Angular
    syntactical sugar. The `private` keyword is also from TypeScript and enables assigning
    the passed constructor to the class instance automatically. The type information
    is used to infer the type to be injected. The `BookComponent` has a dependency
    to `BookService` and is injected in the constructor. So when an instance of the
    `BookComponent` is created, Angular will also make sure the instance of `BookService`
    is readily available for the `BookComponent` instance to consume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The injector has knowledge of the dependencies to be created from providers
    that are configured with the required dependency types when bootstrapping the
    application or when decorating the components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet adds `BookService` as a provider to the bootstrap
    function. The injector will create an instance of `BookService` and keep it available
    in the container for the entire application to inject whenever it''s requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet adds `BookService` as a provider in the metadata
    of the component. The injector will create an instance of `BookService` when it
    encounters a request to create an instance of `BookComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss Dependency Injection and hierarchical Dependency Injection in
    detail in [Chapter 12](998d521f-cf30-4688-9763-12878fcd23e9.xhtml), *Implementing
    Angular Services.*
  prefs: []
  type: TYPE_NORMAL
- en: Basics of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript and is an open source language developed
    by Microsoft. Code written in TypeScript will be compiled to JavaScript and executed
    on any browser or server running `Node.js`. TypeScript is actually a type of JavaScript.
    TypeScript helps to improve the quality of code you write in JavaScript. If we
    use external libraries, we need to use type definition files for the imported
    libraries. Type definition files provide JavaScript tooling support and also enable
    compile time checks, code refactoring, and variable renaming support by inferring
    the structure of the code. TypeScript is evolving and keeps adding additional
    features aligned with the ES2016 specification and later.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various editors available on the market that write TypeScript code
    and compile them using a TypeScript compiler. These editors take care of compiling
    your TypeScript into JavaScript. Some popular editors are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emacs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebStorm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also download TypeScript as a `Node.js` package by executing the following
    command in the Node.js command-line tool to install TypeScript globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To transpile the TypeScript code into JavaScript, you can execute the following
    command in the command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `tsc` is the TypeScript compiler that converts a TypeScript file into
    a JavaScript file. `mytypescriptfile` is the name of your TypeScript code file
    and `.ts` is the extension of the TypeScript file. On executing the `tsc` command,
    it generates a `.js` file with the same name as the `.ts` source file.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Visual Studio Code editor for our sample code demos in this
    chapter. Let us see basic features of TypeScript with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore some of the basic types in TypeScript and how to use them. Basic
    types include primitive types such as number, string, boolean, and array in TypeScript.
    JavaScript only validates types during runtime, but TypeScript validates variable
    types during compile time and greatly reduces the possibility of typecast issues
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Number type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The number type represents floating point values. It can hold values such as
    decimal, binary, hexadecimal, and octal literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type is a very simple type that can hold either of two values,
    true or false. This Boolean type is used to maintain the state in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `isSaved` variable of type Boolean is assigned with the value true.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The string data type can hold a sequence of characters. Declaring and initializing
    the string variable is very simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared a variable named `authorName` as a string, and it is assigned
    the value `Rajesh Gunasundaram`. TypeScript supports surrounding the string value
    with either a double quotes (") or single quotes (').
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The array data type is meant to hold a collection of values of specific types.
    In TypeScript, we can define arrays in two ways, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement declares an array variable of the number type using square brackets
    ([]) after the data type number, and it is assigned with a series of even numbers
    from 2 to 10\. The second way to define array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This statement uses the generic array type, which uses the Array keyword followed
    by angle brackets (<>) that wrap the number data type.
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The enum data type will have a named set of values. We use enumerators to give
    user-friendly names to constants that identify certain values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `Day` enum variable, which holds a series of values that represent
    each day of the week. The second statement shows how to access a particular enum
    value in a day and assign it to another variable.
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The any data type is a dynamic data type that can hold any value. TypeScript
    throws compile time errors if you assign a string variable to an integer variable.
    If you are not sure about what value a variable is going to hold and you would
    like to opt out of compiler-checking for the type in the assignment, you can use
    the any data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used an array of the any type so that it can hold any type, such as
    numbers, strings, and booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Void is actually nothing. It can be used as the return type of a function to
    declare that this function will not return any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is an extensible template that is used to create objects with member
    variables to hold the state of the object and member functions that deal with
    the behavior of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript only supports function-based and prototype-based inheritance to
    build reusable components. ECMAScript 6 provides the syntactic sugar of using
    classes in supporting object-oriented programming. However, not all browsers understand
    ES6 and we need transpilers, such as TypeScript, that compile the code down to
    JavaScript and target ES5, which is compatible with all browsers and platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Customer` class has three members: a name property, a constructor, and
    a `logCustomer` method. The last statement outside the customer class creates
    an instance of the customer class using the `new` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is an abstract type that defines the behavior of a class. An interface
    is a contract that abstracts the implementation. An interface provides a type
    definition for an object that can be exchanged between clients. This enables the
    client to only exchange an object that is complied with the interface type definition.
    Otherwise, we get a compile time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, interfaces define contracts for an object within your code and
    the code outside your project. Let''s see how to use TypeScript with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The type checker verifies the `addCustomer` method call and examines its parameter.
    `addCustomer` expects an object with the name property of the string type. But
    the client that calls `addCustomer` is passed an object with two parameters, `id`
    and `name`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: However, the compiler does not check the `id` property as it is not available
    in the parameter type of the `addCustomer` method. It only matters for the compiler
    that the required properties are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the method applying `interface` as a parameter type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared the `Customer` interface with the name parameter, and we modified
    the `addCustomer` signature to accept the parameter of the type `Customer` interface.
    The remaining statements are same as in the previous code snippet. The compiler
    only checks for the shape of the object as TypeScript implements the structural
    type system. It will not check whether the object we are passing implements the
    `Customer` interface. It only looks for the `name` property of the `string` type
    in the parameter and then allows it, if it's present.
  prefs: []
  type: TYPE_NORMAL
- en: Optional properties using an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some scenarios, we may want to pass values only for minimal parameters.
    In such cases, we can define the properties in an interface as optional properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the bonus property has been defined as an optional property by concatenating
    a question mark (?) at the end of the name property.
  prefs: []
  type: TYPE_NORMAL
- en: Function type interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw how to define properties in interfaces. Similarly, we can also
    define function types in interfaces. We can define function types in interfaces
    by just giving the signature of the function with the return type. Note that,
    in the following code snippet, we have not added the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have `AddCustomerFunc` ready. Let''s define an interface variable called
    `AddCustomerFunc` and assign a function of the same signature to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter name in the function signature can vary, but not the data type.
    For example, we can alter the `fn` and `ln` function parameters of the string
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, if we change the data type of the parameter or the return type of the function
    here, the compiler will throw an error about the parameter not matching or the
    return type not matching with the `AddCustomerFunc` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Array type interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also define an interface for array types. We can specify the data type
    for the index array and the data type to the array item as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript supports two types of index: number and string. This array type
    interface also stipulates that the return type of the array should match the declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: Class type interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class type interfaces define the contract for classes. A class that implements
    an interface should meet the requirement of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The class type interface only deals with public members of the class. So, it
    is not possible to add private members to the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Extending interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interfaces can be extended. Extending an interface makes it share the properties
    of another interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Employee` interface extends the `Manager` interface and shares its
    `hasPower` with the `Employee` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid type interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hybrid type interfaces are used when we want to use the object both as a function
    and an object. We can call an object like a function if it implements a hybrid
    type interface, or we can use it as an object and access its properties. This
    type of interface enables you to use an interface as an object and a function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the concept of inheriting behaviors from another class or object.
    It helps to achieve code reusability and build a hierarchy in relationships of
    classes or objects. Also, inheritance helps you to cast similar classes.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, by targeting ES5, doesn't support classes, and so class inheritance
    is impossible to implement. However, we can implement prototype inheritance instead
    of class inheritance. Let's explore inheritance in ES5 with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a function named `Animal` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a function named `Animal` with two methods: `sleep` and `eat`.
    Now, let''s extend this `Animal` function using the prototype as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an instance of `Animal` and call the extended function,
    `bark`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Object.Create` method to clone a prototype of the parent and
    create a child object. Then, we can extend the child object by adding methods.
    Let''s create an object named `Dog` and inherit it from `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s clone the prototype of `Animal` and inherit all the behavior in
    the `Dog` function. Then, we can call the `Animal` method using the `Dog` instance,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw how to implement an inheritance in JavaScript using a prototype.
    Now, we will see how an inheritance can be implemented in TypeScript, which is
    basically ES6 inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, similar to extending interfaces, we can also extend a class
    by inheriting another class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are able to access the methods of `SimpleCalculator` using the instance
    of `ComplexCalculator` as it extends `SimpleCalculator`.
  prefs: []
  type: TYPE_NORMAL
- en: Private and public modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, all members in a class are `public` by default. We have to add
    the `private` keyword explicitly to control the visibility of the members, and
    this useful feature is not available in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the `SimpleCalculator` class, we defined `x` and `y` as private
    properties, which will not be visible outside the class. In `ComplexCalculator`,
    we defined `x` and `y` using parameter properties. These `Parameter` properties
    will enable us to create and initialize a member in one statement. Here, `x` and
    `y` are created and initialized in the constructor itself without writing any
    further statements inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also implement getters and setters to the properties to control accessing
    them from the client. We can intercept a process before setting a value to a property
    variable or before getting a value of the property variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, the setter for the `name` property ensures that the customer name can
    be updated. Otherwise, it shows an alert message to the effect that it is not
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Static properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These properties are not instance-specific and are accessed by a class name
    instead of using the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared a static variable called `bonusPercentage` that is accessed
    using the class name `Customer` in the `calculateBonus` method. This `bonusPercentage`
    property is not instance-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a powerful and dynamic language. With dynamic programming in JavaScript,
    we need to structure and organize the code so that it will make its maintainability
    easier and also enable us to easily locate the code for a specific functionality.
    We can organize code by applying a modular pattern. Code can be separated into
    various modules, and relevant code can be put in each module.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript made it easier to implement modular programming using the module
    keyword. Modules enable you to control the scope of variables, code reusability,
    and encapsulation. TypeScript supports two types of module: internal and external
    modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create namespaces in TypeScript using the namespace keyword as follows.
    All the classes defined under namespace will be scoped under this namespace and
    will not be attached to the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `Product` class available for access outside the `namespace`, we
    need to add an `export` keyword when defining the `Product` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also share namespaces across files by adding a reference statement at
    the beginning of the code in the referring files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript also supports modules As we deal with a large number of external
    JavaScript libraries, this modularity will really help us organize our code. Using
    the import statement, we can import modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just imported the previously created module, Inventory, created an
    instance of `Product` and assigned it to the variable `p`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript, which follows the ES5 specs, does not support classes and modules.
    However, we tried to scope variables and modularity using functional programming
    in JavaScript. Functions are the building blocks of an application in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though TypeScript supports classes and modules, functions play a key role in
    defining a specific logic. We can define both named functions and anonymous functions
    in JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, we define functions with the type of the parameters and the
    return type using function arrow notation, which is also supported in ES6, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Optional and default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say, for example, we have a function with three parameters, and sometimes we
    may only pass values for the first two parameters in the function. In TypeScript,
    we can handle such scenarios using the optional parameter. We can define the first
    two parameters as normal and the third parameter as optional, as given in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, `middleName` is the optional parameter, and it can be ignored when calling
    the `function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to set default parameters in a function. If a value is
    not supplied to a parameter in the function, we can define it to take the default
    value that is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, `middleName` is the default parameter that will have `No Middle Name`
    by default if the value is not supplied by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Rest parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the rest parameter, you can pass an array of values to the function.
    This can be used in scenarios where you are not sure about how many values will
    be supplied to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, note that the `restOfClient` rest parameter is prefixed with an ellipsis
    (...), and it can hold an array of strings. In the caller of the function, only
    the value of the first parameter that is supplied will be assigned to the `firstClient`
    parameter, and the remaining values will be assigned to `restOfClient` as array
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generics are very useful for developing reusable components that can work against
    any data type. So, the client that consumes this component will decide what type
    of data it should act upon. Let''s create a simple function that returns whatever
    data is passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need individual methods to process each data type. We can
    implement them in a single function using the any data type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to generics. However, we don't have control over the return
    type. If we pass a number and we can't predict whether the number will be returned
    or not by the function, the return type can be of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics offers a special variable of type `T`. Applying this type to the function
    as follows enables the client to pass the data type they would like this function
    to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the client can call this function for various data types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that the data type to be processed is passed by wrapping it in angle brackets
    (<>) in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Generic interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also define generic interfaces using the `T` type variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a generic interface and the `myFunc` variable of the `GenericFunc`
    type, passing the number data type for the `T` type variable. Then, this variable
    is assigned with a function named `func`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to generic interfaces, we can also define generic classes. We define
    classes with a generic type in angle brackets (<>) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the generic class is instantiated by passing the generic data type as
    number. So, the add function will process and add two variables of type number
    passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators enable us to extend a class or object by adding behaviors without
    modifying code. Decorators wrap the class with extra functionality. Decorators
    can be attached to a class, property, method, parameter, and accessor. In ECMAScript
    2016, decorators are proposed to modify the behavior of a class. Decorators are
    prefixed with the `@` symbol and a decorator name that resolves to a function
    called at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the authorize function, and it can be used
    as the `@authorize` decorator on any other class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class decorators are declared above the class declaration. Class decorators
    can observe, modify, and replace a class'' definition that it is decorated by
    applying to the constructor of that class. The signature of `ClassDecorator` in
    TypeScript is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Consider a `Customer` class; we would like that class to be frozen. Its existing
    properties should not be removed or new properties should not be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a separate class that can take any object and freeze it. We can
    then decorate the customer class with `@freezed` to prevent adding new properties
    or removing the existing properties from the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class takes four arguments in the `firstname` and `lastname`
    constructors. The following are the code snippets of the function written for
    the `@freezed` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, the freezed decorator takes `target`, which is the `Customer` class that
    is being decorated, and freezes it when it gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: Method decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method decorators are declared before the method declaration. This decorator
    is used to modify, observe, or replace a method definition and is applied to the
    property descriptor for the method. The following code snippet shows a simple
    class with an applied method decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Hello` class has the `increment` method that increments a number supplied
    to its parameter. Note that the `increment` method is decorated with the `@logging`
    decorator to log input and output of the increment method. The following is the
    code snippet of the `logging` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The method decorator function takes three arguments: `target`, `key`, and `value`.
    `target` holds the method that is being decorated; `key` holds the name of the
    method being decorated; and `value` is the property descriptor of the specified
    property if it exists on the object.'
  prefs: []
  type: TYPE_NORMAL
- en: The logging method gets invoked when the increment method is called and it logs
    the value to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Accessor decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessor decorators are prefixed before the accessor declaration. These decorators
    are used to observe, modify, or replace an accessor definition and are applied
    to the property descriptor. The following code snippet shows a simple class with
    the applied accessor decorator applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, we decorate the get accessor of `firstname` and `lastname` with
    `@logging` and pass `boolean` to enable or disable logging. The following code
    snippet shows the function for the `@logging` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `logging` function sets the Boolean value to the logging property descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Property decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Property decorators are prefixed to property declarations. They actually redefine
    the property decorated by adding extra behavior. The signature of `PropertyDecorator`
    in the TypeScript source code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a code snippet of a class with a property decorator applied
    to a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `firstname` property is decorated with the `@hashify` property
    decorator. Now, we will see the code snippet of the `@hashify` property decorator
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_value` holds the value of the property that is being decorated. Both
    getter and setter functions will have access to the variable `_value` and here
    we can manipulate the `_value` by adding extra behaviors. I have concatenated
    # in the getter to return a hash-tagged `firstname`. Then we delete the original
    property from the class prototype using the `delete` operator. A new property
    will be created with the original property name with the extra behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameter decorators are prefixed to parameter declarations, and they are applied
    to a function for a class constructor or a method declaration. The signature of
    `ParameterDecorator` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the `Customer` class and use a parameter decorator to decorate
    a parameter in order to make it required and validate whether the value has been
    served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the name parameter has been decorated with `@logging`. The parameter
    decorator implicitly takes three inputs, namely `prototype` of the class that
    has this decorator, the `name` of the method that has this decorator, and the
    `index` of the parameter that is being decorated. The `logging` function implementation
    of the parameter decorator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here, `target` is the class that has the decorator, `key` is the function name,
    and `index` contains the parameter index. This code just logs `target`, `key`,
    and `index` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I assume that you have installed Node.js, npm, and Visual Studio Code and are
    ready to use them for development. Now let us create an Angular application by
    cloning the Git repository and performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Node.Js` command prompt and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Open the cloned `my-angular` application using Visual Studio Code. This command
    will clone the Angular quickstart repository and creates an Angular application
    named my-angular for you with all the boilerplate codes required.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5da2b9fa-3474-4251-8eb6-9debbfc749e9.png)Folder structure of the
    my-angular application.'
  prefs: []
  type: TYPE_NORMAL
- en: The folder structure and the boilerplate code are organized according to the
    official style guide in [https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html).
    The `src` folder has the code files related to application logic, and the `e2e`
    folder has the files related to end-to-end testing. Don't worry about other files
    in the application now. Let's focus on `package.json` for now
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `package.json` file, and it will have information about the configurations
    of the metadata and project dependencies. Here is the content of the `package.json`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to run the `npm install` command in a command window, navigating
    to the `application` folder to install the required dependencies specified in
    `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0b300ed3-b49c-4a93-98da-6389bc785f06.png)Execute the npm command
    to install dependencies specified in package.json.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will have all the dependencies added to the project under the `node_modules`
    folder, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a27dbcd1-b21b-474b-9b5a-0f19338af727.png)Dependencies under the
    `node_modules` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this application. To run it, execute the following command
    in the command window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Running this command builds the application, starts the lite server, and hosts
    the application onto it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any browser and navigate to `http://localhost:3000/`; and you will get
    the following page displayed, which is rendered through our Angular application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bd1dcf5-d898-42c8-a473-4f0ac641b844.png)Activating the debug window
    in Visual Studio Code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now walk through the content of `index.html`. Here is the content of
    `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Notice that scripts are loaded using `System.js`. `System.js` is the module
    loader that loads modules during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Voila! Finally, our first Angular app is up-and-running. So far, we have seen
    how to create an Angular application by cloning the official quickstart repository
    from GitHub. We ran the application and saw it in the browser successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! This has been a great introduction, hasn't it? We started by learning about
    Angular's architecture. We discussed various artifacts of Angular's architecture.
    Then we dived into the basics of TypeScript. We have seen basic types with examples.
    We have also learned about writing classes, using interfaces, and implementing
    them in classes. We have also learned about inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about structuring our code by using modules and namespaces.
    We have also covered some advanced topics of TypeScript such as modifiers, accessors,
    static properties, generics, and decorators
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we created a simple application using Angular and TypeScript. This
    chapter has equipped you with what you need to develop Angular applications using
    TypeScript with the syntactic sugar it has provided.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss migrating AngularJS apps to Angular.
  prefs: []
  type: TYPE_NORMAL
