- en: Tips and Tricks with Cheat Sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we have collected some tips and tricks to help you on
    your scripting journey. First, we'll touch on some subjects that are important,
    but weren't directly referenced in our earlier chapters. Then, we'll show you
    some practical shortcuts for the command line, which should help you improve your
    speed when doing Terminal work. Finally, we will end with a cheat sheet for the
    most important interactive commands we have discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands will be introduced in this chapter: `history` and `clear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: General tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line shortcuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cheat sheet for interactive commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this chapter consists mostly of tips, there are no scripts as we have
    seen in earlier chapters. To really get a feeling for these tricks, you should
    try them out yourself. As a final goodbye, your Ubuntu virtual machine can serve
    you well this one last time!
  prefs: []
  type: TYPE_NORMAL
- en: General tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first part of this chapter, we'll describe a few things we could not
    place properly in others parts of the book. With the exception of the first subject,
    *arrays*, both `history` and `alias` are not really used in a scripting context
    so we elected to present them here. But first, arrays!
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you come from a developer background or have dabbled in programming, you
    will have (probably) come across the term *array*. If we needed to explain arrays
    in a single sentence, it would look like this: Arrays allow us to store a *collection
    of data* *of the same type*. To make this a little less abstract, we''ll show
    you how we can create an *array of strings* in Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this string array, we place four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: This
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to print the string in the first place in the array, we need to
    specify that we want the *zeroth position* with the `echo ${array[0]}` syntax.
    Remember, as is common in IT, the first item in a list is often found at the 0th
    position. Now, look at what happens if we try to grab the fourth position, and
    thus the fifth value (that is not there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Weirdly enough, even though we're asking for the value in a position of the
    array that does not exist, Bash does not consider this an error. If you did the
    same in some programming languages, such as Java, you'd see an error akin to `**ArrayIndexOutOfBoundsException**`.
    As you can see after the exit status of `0`, if we want to print *all the values
    in the array*, we use the asterisk (as a wildcard).
  prefs: []
  type: TYPE_NORMAL
- en: In our scripting example, to keep it a little simpler, we've used *whitespace
    delimited strings* when we needed to create a list (for reference, look at the
    script `**for-simple.sh**` from [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),* Conditional
    Testing and Scripting Loops* again). In our experience, for most purposes, this
    is often easier to work with and powerful enough. Should this not seem the case
    for your scripting challenges, however, remember that such a thing as arrays in
    Bash exist and that, perhaps, these might work for you.
  prefs: []
  type: TYPE_NORMAL
- en: The history command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very powerful and cool command in Bash is `history`. Simply put, by default,
    Bash *will store a history of all the commands you type*. These are saved up to
    a certain threshold, and for our Ubuntu 18.04 installation this is 1,000 commands
    *in memory* and 2,000 commands *on disk*. Every time you do a clean exit/logout
    of your terminal, Bash will write the command history from memory to disk, taking
    both limits into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive (a little) deeper, let''s take a look at our personal history
    for the `**reader**` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though our history is very interesting, it is not interesting enough to
    print it fully here. Often, if you use this in practice, it can easily become
    an overload of information as well. We suggest you use the `history` command in
    the following manners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`history | less`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`history | grep sed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you pipe it to `less`, you'll end up with a nice pager that you can scroll
    through leisurely and use the search function in. When you exit it using `**q**`,
    you will be back at your uncluttered Terminal. If you're looking for a specific
    command (such as `sed`), you could also pipe the output of `history` through the
    `grep` command to make a course filter. If that's still too rough, consider adding
    `| less` behind the `grep` to make use of the pager once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for history is found in a few environment variables, which
    are often set in your `**~/.bashrc**` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you see the two defaults we had already announced (and which, if you
    want, can be edited!). For the others, `man bash` will inform you about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: HISTCONTROL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HISTFILE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HISTTIMEFORMAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to give those a quick read. Do not underestimate how convenient the
    `history` command can be; you will most certainly find yourself *almost* remembering
    how you used a command before, and if you remember enough you can use `history`
    to find out what you did so you can do it again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bash allows you to create your own aliases for commands. We''ve seen this introduced
    in [Chapter 14](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml), *Scheduling and Logging*,
    but for day-to-day tasks, it is worth exploring a little bit further. The syntax
    is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this syntax, `alias` is the command, `name` is how the `alias` will be called
    by you on the Terminal, and `value` is what is actually called when you call the
    `alias`. For interactive work, this could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the alias `message`, which actually does `echo "Hello world!"` for
    us when called. For those of you with a little bit more experience, you''ve no
    doubt been using the "command" `ll` for some time now. As you might (or might
    not) remember, this is a common default `alias`. We can print currently set aliases
    with the `-p` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, by default we have some aliases set and the one we just created
    is there as well. What is even more interesting, is the fact that we can use `alias`
    to *override a command*, such as `ls` above. All the times we used `ls` in the
    book''s examples, we''ve actually been executing `ls --color=auto`! The same goes
    for `grep`, as the print clearly shows. The `ll` alias quickly allows us to use
    common, almost essential flags for `ls`. However, you would do well to realize
    that these aliases are distribution-specific. Take a look at the `ll` alias on
    my Arch Linux host machine for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is different from our Ubuntu machine. At the very least, that begs the
    question: where are these default aliases set? If you remember our explanation
    about `**/etc/profile**`, `**/etc/bash.bashrc**`, `**~/.profile**`, and `**~/.bashrc**`
    (in [Chapter 14](8655ccc6-3da6-415c-b0cb-37b543e67049.xhtml), *Scheduling and
    Logging* ), we know that these files are the most likely candidates. From experience,
    you can expect most aliases to be in the `**~/.bashrc**` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you have commands that you often use, or flags that you would like to include
    "by default," you can edit your `**~/.bashrc**` file and add as many `alias` commands
    as you like. Any commands in the `.bashrc` file are run when you log in. If you
    want to make an alias available system-wide, the `**/etc/profile**` or `**/etc/bash.bashrc**`
    files would be better choices to include your `alias` command in. Otherwise, you'd
    have to edit the personal `.bashrc` files of all users, current and future (which
    is not efficient, so you shouldn't even consider this).
  prefs: []
  type: TYPE_NORMAL
- en: Command-line shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the convenience of the commands in the first part of this chapter,
    there is another type of time-saver, which does not necessarily need to be discussed
    in the context of shell scripting, but is still such a great asset that we''d
    feel bad if we did not share it with you: command-line shortcuts.'
  prefs: []
  type: TYPE_NORMAL
- en: Fun with exclamation marks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exclamations marks are normally used to give text some emphasis, but under
    Bash they are actually a `shell` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the term "shell keyword" does not really give us a great indication of
    what it does, there are multiple things we can accomplish with the exclamation
    mark. One we have already seen: if we want to negate a `test`, we can supply the
    exclamation mark within the check. If you''d like to verify this on your Terminal,
    try the following with either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the exclamation mark reverses the exit status: true becomes
    false, and false becomes true. Another cool feature of the exclamation mark is
    that a double exclamation mark will be substituted on the command line with the
    full previous command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure you''re clear about what you''re repeating, the command is printed
    to stdout alongside the output of the command. What''s more, we can also choose
    which part of the command to repeat by using numbers and a colon in combination
    with an exclamation mark. As always, `0` is reserved for the first argument, `1`
    for the second, and so on. A good example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows that we used `**!:1**` to substitute the second
    word of the previous command. Note that if we repeat this for the `ls -l file`
    command, the second word is actually the `-l` flag of the `ls` command, so don't
    assume only full commands are parsed; this is a simple whitespace delimited index.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one killer feature with exclamation marks, as far as we''re concerned:
    the `!$` construct. It is the same type of substitution, and as you might guess
    from how `**$**` works in `vim`, it substitutes the last word of the previous
    command. While this might not seem like that big a deal, take a look at how often
    the last word of the previous command is something you can reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, when copying a file you want to edit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you start using it in practice, you'll find that this trick applies to
    so many commands that it will start saving you time almost immediately. In these
    examples, the names were short, but if we're talking long pathnames, we'd either
    have to take our hands away from the keyboard to do a copy/paste with the help
    of our mouse, or type everything again. And why would you, when a simple `**!$**`
    does the trick?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way this can quickly become a lifesaver, there is one extremely
    good example of when to use `**!!**`. Take a look at the following situation,
    which everyone has encountered or will encounter sooner or later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you forget to add a `sudo` in front of your command (because it is a privileged
    command or manipulates a privileged file), you can either:'
  prefs: []
  type: TYPE_NORMAL
- en: Type the whole command again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste the command using the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the up arrow, followed by the Home key, and type `sudo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or simply type `sudo !!`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should be clear which is the shortest and easiest, and thus has our preference.
    Do realize that with this simplicity also comes responsibility: if you try to
    remove files you should not remove, and you''re quickly using `sudo !!` without
    fully thinking it through, your system could be gone in an instant. The warning
    still stands: when interacting as `**root**` or with `sudo`, always think twice
    before running a command.'
  prefs: []
  type: TYPE_NORMAL
- en: Running commands from the history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final thing we find noteworthy to describe in regards to exclamation marks
    is interacting with the history. As you learned just a few pages ago, the history
    saves your commands. With the exclamation mark, you can quickly run commands from
    your history: either by supplying the number of the command (for example, `!100`)
    or by entering part of the command (for example: `!ls`). In our experience, these
    functions are not used as much as the *reverse search* we''ll explain shortly,
    but it is still good to be aware of this functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this looks in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By supplying the number, `!1100` ran the command `date` again. You should realize
    that the history, once it reaches its maximum, will change. The command that is
    today equal to `!1100` might next week be a different command altogether. In practice,
    this is considered a risky move and is often best avoided, because you do not
    get a confirmation: you see what is being executed, while it is running (or probably,
    it is done by the time you have seen what you ran). You can only be sure if you
    check the history first, and in that case you''re not saving any time, only using
    extra.'
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting, though, is repeating a command based on the command itself,
    such as `!ls` shows. It is still somewhat risky, especially if used in combination
    with destructive commands such as `rm`, but if you're sure what the last command
    was that matches your exclamation mark query, you should be relatively safe (especially
    for nondestructive commands such as `cat` or `ls`). Again, before you start incorporating
    this practice into your daily life, be sure to keep reading until we've explained
    reverse searching. At that point, we expect/hope that those are much more interesting
    to you, and then you can file away the information here as *good to know*.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next class of shortcuts we want to discuss is *keyboard shortcuts*. In
    contrast to the previous commands and shell keywords, these are simply key combinations
    that modify things on the command line. The combinations we''re discussing all
    work by using the *CTRL* key as a modifier: you hold down *CTRL* and press another
    key, for example the *t*. We''ll describe this as *CTRL+t*, as we have done in
    the rest of the book as well. Speaking of `**CTRL+t**`, this is actually the first
    shortcut we''d like to address! You can use `CTRL+t` when you''ve made a *typo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the terminal is modified, it is kind of hard to get an accurate representation
    for these pages. We''ve included a comment between the lines, to show what we
    do and what changes when we do it. However, in your Terminal, you will only ever
    see one line. Go ahead and try it out. By pressing *CTRL+t*, you can swap the
    last two characters around as often as you''d like. Do note that it takes whitespace
    into account as well: if you''ve already pressed the spacebar, you''ll swap the
    whitespace with the last letter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you start using this shortcut, you will soon realize that swapping two letters
    is a much more common occurrence than you might initially expect. As with most
    things in Bash, this functionality is present because people use it, so you do
    not need to feel bad about yourself if this happens to you a bit too often! At
    least with this shortcut, you'll be able to mitigate the errors quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `**CTRL+l**` shortcut (lowercase *L*), which is actually a shortcut
    for a command: `clear`. The functionality of clear is almost as simple as the
    name of the command: `clear` - *clear the terminal screen* (from `man clear`).
    This is actually a shortcut (and by extension, a command) that we use extensively
    for every Terminal session. As soon as you get to the *bottom* of your Terminal
    emulator screen, with a lot of clutter above, you might notice this isn''t as
    nice to work with as the empty Terminal you start with (our personal opinion,
    perhaps shared by you). If you want to clear this up, you can either use the *CTRL+l*
    shortcut, or simply type the command `clear`. When you clear your Terminal, the
    output is not gone: you can always scroll up (often via mouse wheel or *SHIFT+page-up*)
    to see what was cleared. But at least your cursor is on a nice, clean screen at
    the top!'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a shortcut for the `exit` command, `**CTRL+d**`. Not only does
    this work great for when you want to *exit an SSH session*, but it works for many
    other interactive prompts as well: a great example for this is `at` (in reality,
    you *need* to use *CTRL+d* to exit from the `at` prompt, as `exit` will just be
    interpreted as a command to run!). As you know, `**CTRL+c**` sends a cancel to
    a running command (technically a SIGINT, as there are many intensities of cancel/kill
    under Linux), so be sure not to confuse *CTRL+d* with *CTRL+c*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to navigation, there are two CTRL-based shortcuts which are often
    easier to reach than their alternatives: `**CTRL+e**` and `**CTRL+a**`. `**CTRL+e**`
    moves the cursor to the end of the line, in a similar way to what the END key
    accomplishes. As you might expect, `**CTRL+a**` does the reverse: it functions
    as an alternative to the HOME key. Especially for those of you that are proficient
    in touch typing, these shortcuts are faster than moving your right hand away from
    the home row to find the *END*/*HOME* keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and pasting from the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common thing to do with GUI-based systems is cutting and pasting text.
    You'll select text, often with the mouse, and either use the right mouse button
    to copy and paste, or hopefully you've found the good old `**CTRL+c**` and `**CTRL+v**`
    (for Windows, Command key for macOS). As we explained before and reminded you
    of two paragraphs ago, *CTRL+c* under Linux is definitely not a *copy*, but a
    *cancel*. Similarly, *CTRL+v* will most likely not paste text either. So, how
    then, under Linux, do we copy and paste?
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, if you''re using SSH and a Terminal emulator from within a GUI
    desktop, you have the right mouse button available to accomplish this (or, if
    you''re feeling really fancy, pressing the middle mouse button often defaults
    to paste as well!). You can select text from somewhere on the internet, for example,
    copy it, and paste it into your Terminal emulator with either button. However,
    we always strive to optimize our processes, and as soon as you need to grab the
    mouse, you''re losing valuable time. For text you have already copied, there is
    (for most Terminal emulators!) a shortcut to paste: `**SHIFT+insert**`. Just so
    you know, this paste shortcut is not limited to Linux or most Terminal emulators:
    it seems to be pretty universal, working on Windows and Linux with GUIs as well.
    Personally, we have replaced *CTRL+v* almost completely with *SHIFT+insert* for
    our pasting needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, if we can paste in this manner, there must also be a similar way
    for copying. This is very similar: instead of *SHIFT+insert*, copying can be done
    with `**CTRL+insert**`. Again, this is not limited to Linux or Terminals: it works
    just fine on Windows as well. For those of us working with Linux and Windows,
    replacing *CTRL+c* and *CTRL+v* with *CTRL+insert* and *SHIFT+insert* ensures
    that we are always properly copying and pasting, no matter what environment we''re
    working in. Personally, we use Linux at home but Windows at work, which means
    our time is spent about 50/50 between the operating systems: trust us, it is very
    nice to have shortcuts that always work!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the method above still sort of relies on having a mouse. Most of the time
    (think more than 95%, depending on your job) this will be the case, but sometimes
    you will simply not have a mouse (when connected directly to a Terminal of a server
    in a data center, for example). Fortunately for us, there are three shortcuts
    that work in Bash and will allow us to cut and paste directly on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**CTRL+w**`: Cut the word before the cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**CTRL+u**`: Cut everything on the line before the cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**CTRL+y**`: Paste everything that was cut (using the two commands above,
    not the general OS clipboard!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides being able to cut and paste, *CTRL+w* is also great to remove a single
    whole word from the command line. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Something that tends to happen is giving an incorrect final argument to a command.
    If you want to revise this real quickly, a simple *up-arrow* followed by a *CTRL+w*
    will place the previous command minus the final argument back on your Terminal.
    Now, you just have to give it the correct argument to run it again. Alternatively,
    you could either:'
  prefs: []
  type: TYPE_NORMAL
- en: Retype the whole command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll, copy and paste using the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Up-arrow* followed by a number of backspaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our experience, a double keystroke is always faster than all other possible
    solutions. Only if the last argument was a single character would using *up-arrow*
    and *backspace* be *equally fast*, which is kind of a stretch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the previous example, we did not actually only *remove* the final argument,
    we actually *cut* it. When you cut an argument, it gives you the ability to *paste*
    it back again. As stated, this is a Bash-specific clipboard which is not tied
    to the system clipboard; while you might think that paste is always done with
    *SHIFT+insert*, in this case we use *CTRL+y* for the Bash-specific clipboard.
    The best example to show this is with a full line cut, using `**CTRL+u**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is, for us, a typical scenario in which we are one step ahead of ourselves.
    We have already typed a command we need to execute, but before we press *ENTER*
    we realize we forgot to do something that needs to be done before our current
    command can succeed. In this scenario, we use `**CTRL+u**` to cut the entire command,
    continue with the prerequisite command, and when we're ready we paste the line
    with `**CTRL+y**` again. Again, you might think this will not happen to you, but
    you might be surprised at how often you will encounter this precise pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As far as keyboard shortcuts go, we believe we have saved the best for last.
    Out of all the time-savers we have so far introduced, this is by far the coolest
    as far as we''re concerned: *reverse searching*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A reverse search allows you to go back through your history, and search for
    a string within your executed commands. You can think of this as similar to `history
    | grep cat`, but much more interactive and much faster. To enter the reverse search
    prompt, the keys `**CTRL+r**` are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Please go ahead and give it a try. It is hard to get these interactive prompts
    down on paper, so we hope the comments above give a good indication of how a reverse
    search works. You can reverse search all the way up to the beginning of your history.
    If, at that point, you press *CTRL+r* again, you''ll see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This signifies to you that there are no more matches for reverse search to find.
    At this point, or before if you think you're taking too long, you can always press
    *CTRL+c* to stop reverse searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast with the `!ls` syntax, reverse search will not start looking for
    the keywords only from the beginning of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that it is both more powerful (it just matches anywhere in the command)
    and more complicated to use (it does not match just the command). However, if
    you''re smart about this and you just want commands, you can always use a well-placed
    whitespace to make sure situations like the example above do not happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While we'd love to talk more about reverse searching, the only true way for
    you to learn it properly is to start using it. Rest assured, if you get proficient
    in its use (and also know when to stop searching and just type in the command
    you're looking for), you'll be sure to impress your peers with your efficient
    Terminal work!
  prefs: []
  type: TYPE_NORMAL
- en: Cheat sheet for interactive commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to end this book with a simple cheat sheet used for interactive
    commands. Getting proficient in Bash is a matter of practice. However, over the
    years, we have found ourselves stumbling upon new ways to use commands, or flags
    we weren't aware of, that made our lives much easier. Even during the writing
    of this book, we encountered things we did not know about before that were pretty
    helpful. In the process of writing about commands and constructs, you are looking
    more closely at manual pages and resources than you do when you're simply using
    them in your day-to-day business.
  prefs: []
  type: TYPE_NORMAL
- en: Please take advantage of these cheat sheets, as they include not only the basic
    syntax but also flags and tips we think are great to know about (we wish we'd
    found them earlier in our career)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of scope for these cheat sheets are things such as find/locate, redirection,
    tests, and loops: these have (hopefully) been adequately described in their own
    respective chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These commands are used for navigation.
  prefs: []
  type: TYPE_NORMAL
- en: cd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change the shell working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | cd [dir] |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`cd`: Navigate to the home directory (as specified in HOME).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd -`: Navigate back to the previous directory (as saved in OLDPWD).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: ls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | List directory contents. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | ls [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`ls -a`: Do not ignore entries starting with dots (. and ..).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -l`: Use a long listing format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -h`: With `-l` and/or `-s`, print human readable sizes (for example, 1K
    234M 2G).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -R`: List subdirectories recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -S`: Sort by file size, largest first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -t`: Sort by modification time, newest first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -ltu`: Sort by, and show, access time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -Z`: Print any security context of each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: pwd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Print name of current/working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | pwd [OPTION]... |'
  prefs: []
  type: TYPE_TB
- en: File manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These commands are used for file manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: cat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Concatenate files and print on the standard output. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | cat [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`cat` or `cat -`: With no FILE, or when FILE is -, read standard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat -n`: Number all output lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Page through text one screen at a time using a pager. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | less [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`less -S`: Chop long lines. Lines do not wrap around, but can be seen with
    the left-right arrow keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`less -N`: Show line numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change file timestamps and/or create empty files. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | touch [OPTION]... FILE... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`touch <non-existent-file>`: Create an empty file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: mkdir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Make directories. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | mkdir [OPTION]... DIRECTORY... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`mkdir -m750 <dirname>`: Create directory with specified octal permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir -Z`: Set SELinux security context of each created directory to the default
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: cp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Copy files and directories. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | cp [OPTION]... SOURCE... DIRECTORY |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`cp -a`: Archive mode, preserve all permissions, links, attributes and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp -i`: Prompt before overwrite (overrides a previous `-n` option).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp -r` and `cp -R`: Copy directories recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp -u`: Copy only when the SOURCE file is newer than the destination file
    or when the destination file is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: rm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Remove files or directories. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | rm [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`rm -f`: Ignore nonexistent files and arguments, never prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm -i`: Prompt before every removal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm -I` (capital i): Prompt once before removing more than three files, or
    when removing recursively; less intrusive than -i, while still giving protection
    against most mistakes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm -r` and `rm -R`: Remove directories and their contents recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: mv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Move (rename) files. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | mv [OPTION]... SOURCE... DIRECTORY |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`mv -f`: Do not prompt before overwriting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mv -n`: Do not overwrite an existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mv -u`: Move only when the SOURCE file is newer than the destination file
    or when the destination file is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: ln
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Make links between files. Defaults to hard links. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | ln [OPTION]... [-T] TARGET LINK_NAME |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`ln -s`: Make symbolic links instead of hard links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ln -i`: Prompt whether to remove destinations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: head
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Output the first part of files. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | head [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`head`: Print the first 10 lines of each FILE to standard output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head -n20` or `head -20`: Print the first NUM lines instead of the first 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head -c20`: Print the first NUM bytes of each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head -q`: Never print headers giving file names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: tail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tail` command has the same options as `head`, but as seen from the end
    of the file instead of the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | Output the last part of files. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | tail [OPTION]... [FILE]... |'
  prefs: []
  type: TYPE_TB
- en: Permissions and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These commands are used for permission and ownership manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change file mode bits. Can be specified as either rwx or
    octal mode. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | chmod [OPTION]... OCTAL-MODE FILE... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`chmod -c`: Like verbose but report only when a change is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod -R`: Change files and directories recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod --reference=RFILE`: Copy the mode from a reference file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: umask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Set file mode creation mask. Since this is a *mask*, it
    is the reverse of a normal octal mode. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | umask [octal-mask] |'
  prefs: []
  type: TYPE_TB
- en: chown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change file owner and group. Only executable with root
    permissions. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | chown [OPTION]... [OWNER][:[GROUP]] FILE... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`chown user: <file>`: Change ownership to the user and their default group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown -c`: Like verbose, but report only when a change is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown --reference=RFILE`: Copy the ownership from a reference file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown -R`: Operate on files and directories recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: chgrp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change group ownership. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | chgrp [OPTION]... GROUP FILE... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`chgrp -c`: Like verbose, but report only when a change is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chgrp --reference=RFILE`: Copy the group ownership from a reference file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chgrp -R`: Operate on files and directories recursively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Execute a command as another user. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | sudo [OPTION]... |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`sudo -i`: Become the root user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo -l`: List the allowed (and forbidden) commands for the invoking user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo -u <user> <command>`: Run a <command> as the specified <user>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo -u <user> -i`: Login as the specified <user>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: su
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Change user ID or become superuser. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | su [options] [username] |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`sudo su -`: Switch to root user. Requires sudo, optionally with your own password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`su - <user>`: Switch to <user>. Requires password entry for <user>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: useradd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Create a new user or update default new user information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | useradd [options] LOGIN |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`useradd -m`: Create the user''s home directory if it does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useradd -s <shell>`: The name of the user''s login shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useradd -u <uid>`: The numerical value of the user''s ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useradd -g <group>`: The group name or number of the user''s initial login
    group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: groupadd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Create a new group. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | groupadd [options] group |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`groupadd -g <gid>`: The numerical value of the group''s ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupadd -r`: Create a system group. These have GIDs which are (normally)
    lower than users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: usermod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Description** | Modify a user account. |'
  prefs: []
  type: TYPE_TB
- en: '| **Syntax** | usermod [options] LOGIN |'
  prefs: []
  type: TYPE_TB
- en: '| **Practical uses** |'
  prefs: []
  type: TYPE_TB
- en: '`usermod -g <group> <user>`: Change the primary group of the <user> to <group>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod -aG <group> <user>`: Add the <user> to the <group>. For the user,
    this will be a supplementary group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod -s <shell> <user>`: Set the login shell for the <user>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod -md <homedir> <user>`: Move the <user>s home directory to <homedir>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this final chapter with general tips and tricks. This part of the
    chapter dealt with arrays, the `history` command, and the ability to use `alias`
    to set up aliases for your favorite commands and their flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continued with keyboard shortcuts. We started that part by talking about
    exclamation marks and how versatile their use can be in Bash: it is used for negation
    of exit codes, substituting parts of previous commands, and even for running commands
    from history by matching either the line number or line content. After that, we
    showed how a few interesting keyboard shortcuts for Bash allow us to save some
    time on common operations and usage patterns (such as typos and forgotten intermediate
    commands). We saved the best keyboard shortcut for last: reverse searches. These
    allow you to interactively go through your personal history to find just the right
    command to execute again.'
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter and the book with a cheat sheet for most of the commands
    we introduced in this book. This cheat sheet contains the basic syntax for all
    commands, as well as our favorite flags and combinations with regards to the commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `history` and `clear`.'
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have managed to make it this far: thank you for reading our book. We
    hope you enjoyed reading it as much as we enjoyed creating it. Keep on scripting
    and learning: practice makes perfect!'
  prefs: []
  type: TYPE_NORMAL
