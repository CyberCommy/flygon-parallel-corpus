- en: Chapter 6. Web Application Vulnerability Assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Running vulnerable web applications in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using w3af for vulnerability assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Nikto for web server assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Skipfish for vulnerability assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Proxy to intercept HTTP traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Intruder for customized attack automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Sequencer to check the session randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vulnerability assessment phase is the process of finding vulnerabilities on
    target machines.
  prefs: []
  type: TYPE_NORMAL
- en: Performing vulnerability assessment simultaneously on web applications and the
    network together can be more useful as you will correlate different vulnerabilities
    and information gathered from network infrastructure and other protocols, such
    as SSH, telnet, databases, SNMP, SMB, and FTP. This will give you a better understanding
    of the purpose of the specific web application and its use within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: However, to make things easier for the audience, we will specifically cover
    tools and techniques to perform vulnerability assessments on web applications.
    The recipes in this chapter are structured to enable you to find all the tools
    and techniques required for scanning and locating vulnerabilities within a web
    application in one place.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability assessment phase is like a preparation phase in which we will
    find the vulnerabilities. To ensure that we find all the possible vulnerabilities
    lying within an application, a comprehensive test has to be performed. However,
    at times, using automated scanning tools generates false positives. For a successful
    pentest, it is of utmost importance that we remove all the false positives using
    the manual vulnerability assessment approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not run the tools demonstrated in this chapter against public websites that
    are not your own and are not on your own servers. In this case, we have set up
    three vulnerable web applications over the cloud in order to demonstrate the tools/techniques
    in this chapter. *Be careful!*
  prefs: []
  type: TYPE_NORMAL
- en: These web applications are OWASP bricks, Damn Vulnerable Web Application (DVWA),
    and WordPress Version 2.2 (Vulnerable!).
  prefs: []
  type: TYPE_NORMAL
- en: These applications are vulnerable by design and hence we do not suggest that
    you install these web applications directly on your server or even on your local
    desktop/laptop. For the purpose of demonstration, we have installed these three
    vulnerable web applications in one Docker container and hosted it on the Docker
    hub for you to pull and use. Check out the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Running vulnerable web applications in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we downloaded Docker and ran a hello-world example
    container. In this recipe, we will download a Docker container that we have prepared
    for you to download and use. It''s an already configured and ready-to-use container
    that has three vulnerable web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP bricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Damn vulnerable web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress 2.2 (Vulnerable!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    or VMware and an Internet connection. This recipe is closely based on the previous
    recipe; it is highly recommended that you follow the previous recipe before moving
    on to this recipe. If you already have Docker installed on your Kali, you can
    directly start with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and pull the Docker container image, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will see the different layers being downloaded, as shown in the following
    screenshot:![How to do it...](img/image_06_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the container image has been downloaded successfully, you will see a screen
    similar to what is shown in the following screenshot:![How to do it...](img/image_06_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the downloaded Docker container image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On running the preceding command, you will see the following output:![How to
    do it...](img/image_06_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see the same output, it means that your Docker container is up and running.
    Keep this terminal running and do not close it and do not press *Ctrl* + *C*.
    Pressing *Ctrl* + *C* will stop the running container; for now, keep it running
    and minimize the terminal so that you don't close it accidently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the vulnerable web applications installed on this container, you will
    first need to find out the current IP address of the running container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find out the current IP address of the running container, you will first
    need to list the running container in a new terminal window using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, copy the container ID and type the following command (remember that your
    container ID will be different from the one shown in this output) using the container
    ID shown in your output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output will be as shown in the following screenshot:![How to do it...](img/image_06_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will be a very long output; in order to find out the IP address quickly,
    you can use the following command as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output is as shown in the following screenshot:![How to do it...](img/image_06_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown, `172.17.0.2` (please note that your IP address could be different
    from the one shown here.) is the IP address the container is running with; to
    see the vulnerable web applications installed on this container, copy this IP
    address and open this on your browser, as shown in the following screenshot:![How
    to do it...](img/image_06_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, you will see that Apache server is up
    and running and you can see three different folders for each different web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving forward, from the next recipe onward, we will be using these applications
    for web application vulnerability assessment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we pulled a preconfigured Docker image from the Docker hub,
    and then we ran the downloaded image, listed the running containers, and tried
    finding out the IP address of the running container using container ID in order
    to view the installed vulnerable web applications on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Using W3af for vulnerability assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use W3af to find vulnerabilities within
    a target web application. W3af is a web application attack and audit framework.
    The project's goal is to create a framework to help you secure your web applications
    by finding and exploiting all web application vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and type `w3af_gui`; the w3af window will be as shown in the
    following screenshot:![How to do it...](img/image_06_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OWASP_TOP10** option from the profile selector in the left-hand
    side panel. Enter the target URL, as shown in the following screenshot:![How to
    do it...](img/image_06_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **auth** menu, click on the **detailed** plugin, and enter the username
    and password (only for HTTP form credentials) and all other required parameters
    and then click on **Save**, as shown in the following screenshot:![How to do it...](img/image_06_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **output** and expand it and select all output formats; in our case,
    we will check all for demonstration purposes, as shown in the following screenshot:![How
    to do it...](img/image_06_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, click on the button next to the start button; on clicking it, the
    following window will open, and it will ask whether you know **target_os** and
    **target_framework** and save the details, as shown in the following screenshot:![How
    to do it...](img/image_06_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all these steps are done, simply click on the **Start** button and the
    scan will begin, as shown in the following screenshot:![How to do it...](img/image_06_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the scan has started, you can traverse the tabs and click on **Results**
    and start seeing the vulnerabilities appear as and when they are discovered, as
    shown in the following screenshot:![How to do it...](img/image_06_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **URL** subtab, where you can see all the URLs discovered
    and drawn in the form of a nice sitemap, as shown in the following screenshot:![How
    to do it...](img/image_06_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While your scan is running, you can still see the latest plugins running and
    the vulnerabilities found over in the log window, as shown in the following screenshot:![How
    to do it...](img/image_06_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the scan is completed, the results will be saved in the directory from
    where you run w3af. In our case, we invoked from the default path, that is, `/root/`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used `w3af_gui` and configured various plugins, started an
    authenticated scan on a vulnerable web application hosted in a Docker container
    at IP `http://172.17.0.2/dvwa/login.php` , and demonstrated how w3af will work
    while performing a real-life vulnerability assessment. W3af's capability is not
    limited to vulnerability assessment. It can also leverage sqlmap-, RFI-, and Metasploit-like
    tools and can be used to perform exploitation as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nikto for web server assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about Nikto and its web server scanning capabilities.
    Nikto is an open source (GPL) web server scanner that performs comprehensive tests
    against web servers for multiple items, including over 6,700 potentially dangerous
    files/programs, checks for outdated versions of over 1,250 servers, and also checks
    for version-specific problems on over 270 servers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and type `Nikto`, Nikto will display its help and switches
    available for use (you can also use the main Nikto for a detailed description
    of each switch), as shown in the following screenshot:![How to do it...](img/image_06_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start a scan, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let Nikto do its work and wait for it to complete; when it is complete, the
    console shows the following output:![How to do it...](img/image_06_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we had Nikto perform a scan on a web server and web application
    hosted locally in a Docker container at `http://172.17.0.2/wordpress/`. The `-host`
    switch is to specify the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, like any other tool, Nikto also shows some false positives that need
    to verified manually by visiting the detected links from the tool and URL's. But
    stay assured; running Nikto is worth your time as it always surprises you by finding
    something unique and new to your list of findings.
  prefs: []
  type: TYPE_NORMAL
- en: Using Skipfish for vulnerability assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use Skipfish. Skipfish is entirely written
    in C. It is highly optimized to handle HTTP requests. Skipfish can handle 2,000
    requests per second, as mentioned at [http://tools.kali.org/web-applications/skipfish](http://tools.kali.org/web-applications/skipfish)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal. To start `Skipfish`, you have to mention the output directory
    name. If the output directory does not exist, it will automatically create the
    directory and save the results. To start Skipfish, type the following command
    in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before Skipfish starts scanning, it shows the list of tips on the screens, which
    helps you understand how Skipfish will behave for this specific scan:![How to
    do it...](img/image_06_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Skipfish starts, it will start showing the scan details, the number of
    requests sent, and other details on the screens, as shown in the following screenshot:![How
    to do it...](img/image_06_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the scan is complete, compile everything and create the HTML report in
    that folder. This will show the following output on the screen:![How to do it...](img/image_06_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the mentioned output directory and open the HTML in the browser, as shown
    in the following screenshot:![How to do it...](img/image_06_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Skipfish is written in C language, it is one of the most efficient tools
    in terms of handling HTTP traffic. Skipfish is capable of running authenticated
    scans as well using `--auth-form`, `--auth-user`, and `-auth-password` switches.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Skipfish takes all the URLs as the scope; if there is any page or
    URL that is not in your scope of testing, you will explicitly mention using the
    `-X` switch to let Skipfish know that it need not be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: In case of authenticated scans, you can mention logout links using the `-X`
    switch in order to ensure that Skipfish accidently doesn't crawl on that as well
    and ends up scanning the host with the logged out session.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Proxy to intercept HTTP traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the Burp Proxy to intercept our browser traffic
    and manipulate the parameters on the go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To start Burp, go to **Menu** | **Kali Linux** | **Applications** | **burpsuite**
    and click on the **Start burpsuite**, as shown in the following screenshot:![How
    to do it...](img/image_06_024.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also open Firefox and navigate to **Edit Menu** | **Preferences** | **Advance
    Tab** | **Network** | **Settings** and set the proxy as `127.0.0.1` and the port
    as `8080`, as shown in the following screenshot:![How to do it...](img/image_06_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and go to **Burp** | **Proxy**, as shown in the following screenshot:![How
    to do it...](img/image_06_026.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, come back to the Firefox window and open `http://172.17.0.2/dvwa/login.php`
    and press *Enter*; the moment you press *Enter*, the request will be intercepted
    by Burp, as shown in the following screenshot:![How to do it...](img/image_06_027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Forward** to let go of any requests that are being intercepted and
    let the login page load. Enter the username and password in the field and click
    on **Submit**, as shown in the following screenshot:![How to do it...](img/image_06_028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Burp** window. As you can see, the submit request gets intercepted
    here and can be manipulated in a raw form or in the parameter form:![How to do
    it...](img/image_06_029.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we simply configured a web browser to a proxy running on our
    own local machine on port `8080` before it connects to the Internet. As we open
    any URL in our browser, it redirects all the traffic to the Burp running on port
    `8080`, where you can manipulate any request before it leaves your system.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy applications are usually used to bypass client-side restrictions in web
    applications in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Intruder for customized attack automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can use Burp Intruder to perform application
    login bruteforce and directory bruteforce. The intruder can be used in any scenario
    where bruteforcing needs to done and can be customized as per your requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Damn Vulnerable Web Application** page in the browser and traverse
    to the **Brute Force** section, as shown in the following screenshot:![How to
    do it...](img/image_06_030.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Intercept the request using Burp, as shown in the following screenshot:![How
    to do it...](img/image_06_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown earlier, send this request to the intruder within Burp, select the
    **Intruder** tab, and then select the **Positions** subtab, as shown in the following
    screenshot:![How to do it...](img/image_06_032.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use intruder to bruteforce a common username and password, we will need to
    select only username and password; the rest of the highlighted parameters can
    be cleared by selecting them and clicking on the **Clear $** button, which will
    ensure that bruteforcing will happen only on selected parameters and not on all
    the parameters selected by default.![How to do it...](img/image_06_033.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Burp Intruder has four attack types, which are sniper, battering ram, pitchfork,
    and cluster bomb. It's set to sniper by default. Change it to battering ram.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we have parameters selected for bruteforcing, we need to set the payloads;
    for that, we will traverse the payload tab and set the payload set as **1** from
    the dropdown. Just to demonstrate how it works, we will enter a small list of
    usernames, as shown in the following screenshot:![How to do it...](img/image_06_034.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select the payload set as **2** and set the payload for the second parameter,
    as shown in the following screenshot:![How to do it...](img/image_06_035.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the **Options** tab; this is important because we need some kind of
    proof that bruteforcer has been able to detect a valid attempt, so for that, we
    will need to see an error message in case of wrong credentials and a message in
    case of correct credentials. Open the browser and enter the wrong password, as
    shown in the following screenshot:![How to do it...](img/image_06_036.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of incorrect credentials, it shows the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/image_06_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Go to **Options** | **Grep Match Section** and remove all string patterns and
    add the **Welcome to the password protected area admin** pattern, which will indicate
    that the credentials are valid, as shown in the following screenshot:![How to
    do it...](img/image_06_038.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Intruder** tab in the top-left corner and click on **Start
    attack**, as shown in the following screenshot:![How to do it...](img/image_06_039.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once started, intruder will try all possible combinations from these two payload
    lists and the grep match will show when there is any match with that in the response,
    as shown in the following screenshot:![How to do it...](img/image_06_040.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used Burp Intruder and highly customized it for the specific
    bruteforce attack. Intruder capabilities are more than that. You can use this
    if you find SQL Injections as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Sequencer to test the session randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the Burp Sequencer tool to check the
    randomness of the session token in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running on Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the application in the browser and intercept the request using Burp, as
    shown in the following screenshot:![How to do it...](img/image_06_041.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to analyze the response for the request, forward this request, and capture
    the response from the server, as shown in the following screenshot:![How to do
    it...](img/image_06_042.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the server has set up `Set-Cookie PHPSESSIONID`, in order to analyze this
    session token, we need to send it to the sequencer, as shown in the following
    screenshot:![How to do it...](img/image_06_043.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the Burp Sequencer. To check the randomness, Burp needs to know the
    location cookie in the request and then we will have start the live capture, as
    shown in the following screenshot:![How to do it...](img/image_06_044.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To perform the session randomness analysis, Burp requires at least 100 min.
    At least 100 PHPSessionID's at minimum to start analyzing:![How to do it...](img/image_06_045.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the **Overall result** section shows information about the randomness
    of `PHPSESSID` within the sample of 462 requests. You can save the values of `PHPSESSID`
    to a file **Save tokens** button, as shown in the following screenshot:![How to
    do it...](img/image_06_046.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attacker can easily impersonate a users session over the application, if
    session tokens are easy to guess and not sufficiently random. In this recipe,
    we used the Burp Sequencer tool to import the session ID from the Burp proxy and
    run the analysis on it. This Sequencer can be used in other cases where we have
    to deal with tokens such as CSRF. Sequencer can also be used to check the randomness
    of CSRF tokens in a similar manner as well.
  prefs: []
  type: TYPE_NORMAL
