- en: Writing Code for the Browser
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 为浏览器编写代码
- en: There are some specific operations we can do when we work with React and the
    browser. For example, we can ask our users to enter some information using forms,
    and in this chapter, we will look at how we can apply different techniques to
    deal with forms. We can implement  **uncontrolled  components**  and let the fields
    keep their internal states, or we can use  controlled  ones, where we have full
    control over the state of the fields.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React和浏览器时，我们可以进行一些特定的操作。例如，我们可以要求用户使用表单输入一些信息，在本章中，我们将看看如何应用不同的技术来处理表单。我们可以实现**不受控制的组件**，让字段保持其内部状态，或者我们可以使用**受控组件**，在这种情况下，我们完全控制字段的状态。
- en: In this chapter, we will also look at  how  events in React work and how the
    library implements some advanced techniques to give us a consistent interface
    across different browsers. We will look at some interesting solutions that the
    React team has implemented to make the event system very performant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将看看React中的事件是如何工作的，以及该库如何实现一些高级技术，为我们提供一个在不同浏览器中具有一致接口的解决方案。我们将看看React团队实现的一些有趣的解决方案，使事件系统非常高效。
- en: After events, we will jump into  refs  to look at how we can access the underlying
    DOM nodes in our React components. This represents a powerful feature, but it
    should be used carefully because it breaks some of the conventions that make React
    easy to work with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件之后，我们将跳转到 refs，看看我们如何在React组件中访问底层DOM节点。这代表了一个强大的功能，但应该谨慎使用，因为它会破坏一些使React易于使用的约定。
- en: After refs, we will look at  how  we can implement animations easily  with the
    React add-ons and third-party libraries such as  `react-motion`. Finally, we will
    learn how easy it is to work with **Scalable Vector Graphics** (**SVG**) in React,
    and how we can create dynamically configurable icons for our applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 refs 之后，我们将看看如何使用React附加组件和第三方库（如`react-motion`）轻松实现动画。最后，我们将学习在React中使用**可伸缩矢量图形**（**SVG**）有多么容易，以及如何为我们的应用程序创建动态可配置的图标。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Using different techniques to create forms with React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的技术在React中创建表单
- en: Listening to DOM events and implementing custom handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听DOM事件并实现自定义处理程序
- en: A way of performing imperative operations on DOM nodes using refs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 refs 在DOM节点上执行命令式操作的一种方式
- en: Creating simple animations that work across different browsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建在不同浏览器中都有效的简单动画
- en: The React way of generating SVG
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成SVG的React方式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您将需要以下内容：
- en: Node.js 12+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 12+
- en: Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书的GitHub存储库中找到本章的代码：[https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter07)。
- en: Understanding and implementing forms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并实现表单
- en: In this chapter, we are going to learn how to implement forms with React. As
    soon as we start building a real application with React, we need to interact with
    the users. If we want to ask for information from our users within the browser,
    forms are the most common solution. Due to the way the library works and its declarative
    nature, dealing with input fields and other form elements is non-trivial with
    React, but as soon as we understand its logic, it will become clear. In the next
    sections, we are going to learn how to use uncontrolled and controlled components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled components
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uncontrolled components are like regular HTML form inputs for which you will
    not be able to manage the value yourself but instead, the DOM will take care of
    handling the value and you can get this value by using a React ref. Let's start
    with a basic example—displaying a  form  with an input field and a Submit button.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is pretty straightforward:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we run the preceding snippet in the browser, we will see exactly what we
    expect—an input field in which we can write  something  and a clickable button.
    This is an example of an uncontrolled component, where we do not set the value
    of the input field, but we let the component manage its own internal state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Most likely, we want to do something with the value of the element when the
    Submit button is clicked. For example, we may want to send the data to an API
    endpoint.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We can do this easily by adding an  `onChange`  listener (we will talk more
    about event listeners later in this chapter). Let's look at what it means to add
    a listener.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the `handleChange` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The event listener is receiving an event object, where the  target  represents
    the field that generated the event, and we are interested in its value. We start
    by just logging it because it is important to proceed with small steps, but we
    will store the value into the state soon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the form:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we render the component inside the browser and type the word `React` into
    the form field, we will see something like the following inside the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `handleChange` listener is fired every time the value of the input changes.
    Therefore, our function is called once for each typed character. The next step
    is to store the value that's entered by the user and make it available when the
    user clicks the Submit button.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'We just have to change the implementation of the handler to store it in the
    state instead of logging it, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting notified of when the form is submitted is very similar to listening
    to the change event of the input field; they are both events that are called by
    the browser when something happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the  `handleSubmit`  function, where we just log the value. In
    a real-world scenario, you could send the data to an API endpoint or pass it to
    another component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This handler is pretty straightforward; we just log the value currently stored
    in the state. We also want to overcome the default behavior of the browser when
    the form is submitted, to perform a custom action. This seems reasonable, and
    it works very well for a single field. The question now is, what if we have multiple
    fields? Suppose we have tens of different fields?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a basic example, where we create each field and  handler  manually  and
    look at how we can improve it by applying different levels of optimization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new form with first and last name fields. We can reuse the
    `Uncontrolled` component and add some new states:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We initialize the two fields inside the state and we define an event handler
    for each one of the fields as well. As you may have noticed, this does not scale
    very well when there are lots of fields, but it is important to understand the
    problem clearly  before moving to a more flexible solution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we implement the new handlers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also have to change the submit handler a little bit so that it displays
    the first and the last name when it gets clicked:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we render the form:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are ready to go: if we run the preceding component in the browser, we will
    see two fields, and if we type  `Carlos`  into the first one and  `Santana`  into
    the second one, we will see the full name displayed in the browser console when
    the form is submitted.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Again, this works fine, and we can do some interesting things this way, but
    it does not handle complex scenarios without requiring us to write a lot of boilerplate
    code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can optimize it a little bit. Our goal is to use a single
    change  handler  so that we can add an arbitrary number of fields without creating
    new listeners.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the component and let''s change our states:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We may still want to initialize the values, and later in this section, we will
    look at how to provide prefilled values for the form.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the interesting bit is the way in which we can modify the  `onChange`  handler
    implementation to make it work  in different fields:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we have seen previously, the `target` property of the event we receive represents
    the input field that has fired the event, so we can use the name of the field
    and its value as variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们接收到的事件的`target`属性代表了触发事件的输入字段，因此我们可以使用字段的名称和其值作为变量。
- en: 'We then have to set the name for each field:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须为每个字段设置名称：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's it! We can now add as many fields as we want without creating additional
    handlers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们可以添加任意多个字段而不需要创建额外的处理程序。
- en: Controlled components
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件
- en: A controlled component is a React component that controls the values of input
    elements in a form by using the component state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 受控组件是一个通过使用组件状态来控制表单中输入元素的值的React组件。
- en: Here we are going to  look  at how we can prefill the form fields with some
    values, which we may receive from the server or as props from the parent. To understand
    this concept  fully, we will start again from a very simple stateless function
    component, and we will improve it step by step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看看如何使用一些值预填充表单字段，这些值可以来自服务器或作为父级传递的props。为了充分理解这个概念，我们将从一个非常简单的无状态函数组件开始，然后逐步改进它。
- en: 'The first example shows a predefined value inside the input field:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显示了输入字段中的预定义值：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this component inside the browser, we realize that it shows the default
    value as expected, but it does not let us change the value or type anything else
    inside it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行此组件，我们会意识到它按预期显示默认值，但不允许我们更改值或在其中输入其他任何内容。
- en: The reason it does this is  that  in React, we declare what we want to see on
    the screen, and setting a fixed-value attribute always results in rendering that
    value, no matter what other actions are taken. This is unlikely to be a behavior
    we want in a real-world application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它这样做的原因是，在React中，我们声明了我们想要在屏幕上看到的内容，并且设置一个固定值属性总是导致渲染该值，无论采取了什么其他操作。这不太可能是我们在现实世界应用程序中想要的行为。
- en: 'If we open the console, we get the following error message. React itself is
    telling us that we are doing something wrong:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开控制台，会得到以下错误消息。React本身告诉我们我们在做一些错误的事情：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, if we just want the input field to have a  default  value and we want
    to be able to change it by typing, we can use the  `defaultValue`  property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想让输入字段具有默认值，并且希望能够通过输入更改它，我们可以使用`defaultValue`属性：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this way, the field is going to show `Hello React` when it is rendered,
    but then the user can type anything inside it and change its value. Now let''s
    add some states:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当渲染时，该字段将显示`Hello React`，但用户可以在其中输入任何内容并更改其值。现在让我们添加一些状态：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The handlers are the same as the previous ones:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序与之前的相同：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In fact, we will use the `value` attributes of the input fields to set their
    initial values, as well as the updated one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将使用输入字段的`value`属性来设置它们的初始值，以及更新后的值：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first time the form is rendered, React uses the initial values from the
    state as the value of the input fields. When the user types something into the
    field, the `handleChange` function is called and the new value for the field is
    stored  in  the state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次渲染表单时，React使用状态中的初始值作为输入字段的值。当用户在字段中输入内容时，将调用`handleChange`函数，并将字段的新值存储在状态中。
- en: When the state changes, React re-renders the component and uses it again to
    reflect the current values of the input fields. We now have full control over
    the values of the fields, and  we  call this pattern  **controlled components**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态改变时，React会重新渲染组件并再次使用它来反映输入字段的当前值。现在我们完全控制字段的值，并且我们称这种模式为**受控组件**。
- en: In the next section, we are going to work with events, which are a fundamental
    part of React to handle data coming from forms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Events**  work in a slightly different  way  across various browsers. React
    tries to abstract the way events work and give developers a consistent interface
    to deal with. This is a great feature of React because we can forget about the
    browsers we are targeting and write event handlers and functions that are vendor-agnostic.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: To offer this feature, React introduced the concept of the **synthetic event**.
    A synthetic event is an object that wraps the original event object provided by
    the browser, and it has the same properties, no matter where it is created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: To attach an event listener to a node and get the event object when the event
    is fired, we can use a simple convention that recalls the way events are attached
    to the DOM nodes. In fact, we can use the word  `on`  plus the camelCased event
    name (for example,  `onKeyDown`) to define the callback to be fired when the events
    happen. A popular convention is to name the event handler functions after the
    event name and prefix them using  `handle`  (for example,  `handleKeyDown`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen this pattern in action in the previous examples, where we were
    listening to the  `onChange`  event of the form fields. Let''s reiterate a basic
    event listener example to see how we can organize multiple events inside the same
    component in a nicer way. We are going to implement a simple button, and we start,
    as usual, by creating a component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we define the event handler:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see here, we are doing a very simple thing: we just check the type
    of the event object we receive from React and the type of native event attached
    to it. We expect the first to return  `false`  and the second to return  `true`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'You should never need to access the  original  native event, but it is good
    to know you can do it if you need to. Finally, we define the button with the  `onClick`  attribute
    to which we attach our event listener:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, suppose we want to attach a second handler to the button that listens
    to the double-click event. One solution would be to create a new separate handler
    and attach it to the button using the `onDoubleClick` attribute, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that we always aim to write less boilerplate and avoid duplicating
    code. For that reason, a common practice is to write a  **single event handler**  for
    each component, which can  trigger  different actions according to the event type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is described in a collection of  patterns  by Michael Chan:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the generic event handler:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The generic event handler receives the event object and switches on the event
    type to fire the right action. This is particularly useful if we want to call
    a function on each event (for example, analytics) or if some events share the
    same logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we attach the new event listener to the `onClick` and `onDoubleClick`
    attributes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From this point on, whenever we need to create a new event handler for the same
    component, instead of creating a new method and binding it, we can just add a
    new case to the switch.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: A couple more interesting things to know about events in  React  are that synthetic
    events are reused and that there is a  **single global handler**. The first concept
    means that we cannot store a synthetic event and reuse it later because it becomes
    null right after the action. This technique is very good in terms of performance,
    but it can be problematic if we want to store the event inside the state of the
    component for some reason. To solve this problem, React gives us a  `persist`  method
    on the synthetic events, which we can call to make the event persistent so that
    we can store it and retrieve it later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The second very interesting implementation detail is again about performance,
    and it is to do with the way React attaches the event handlers to the DOM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use the `on` attribute, we are describing to  React  the behavior
    we want to achieve, but the library does not attach the actual event handler to
    the underlying DOM nodes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: What it does instead attaches a single event handler to the  root  element,
    which listens to all the events, thanks to  **event bubbling**. When an event
    we are interested in is fired by the browser, React calls the handler on the specific
    components on its behalf. This technique is called  **event delegation**  and
    is used for  memory  and speed optimization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we are going to explore React refs and see how we can take
    advantage of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Exploring refs
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons people love  React  is that it is declarative. Being declarative
    means that you just describe what you want to be displayed on the screen at any
    point in time and React takes care of the communications with the browser. This
    feature makes React very easy to reason about and very powerful at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: However, there might be some cases where you need to access the underlying DOM
    nodes to perform some imperative operations. This should be avoided because, in
    most cases, there is a more React-compliant solution to achieve the same result,
    but it is important to know that we have the option to do it and to know how it
    works so that we can make the right decision.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to create a simple form with an input element and a button,
    and we want it to behave in such a way that when the button is clicked, the input
    field gets focused. What we want to do is call the  `focus`  method on the input
    node, the actual DOM instance of the input, inside the browser's window.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a component called `Focus`; you need to import `useRef` and create
    an `inputRef` constant:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we implement the `handleClick` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we are referencing the `current` attribute of `inputRef` and
    calling the `focus` method on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand where it comes from, you just have to check the implementation
    of `render`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here comes the core of the logic. We create a form with an input element inside
    it and we define a function on its `ref` attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The callback we defined is called when the component gets mounted, and the element
    parameter represents the DOM instance of the input. It is important to know that,
    when the component gets unmounted, the same callback is called with a `null` parameter
    to free the memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing in the callback is storing the reference of the element to
    be able to use it in the future (for example, when the `handleClick` method is
    fired). Then, we have the button with its event handler. Running the preceding
    code in a browser will show the form with the field and the button, and clicking
    on the button will focus the input field, as expected.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, in general, we should try to avoid using refs because
    they force the code to be more imperative, and they become harder to read and
    maintain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Implementing animations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When  we  think about UIs and the browser, we must surely think about animations
    as well. Animated UIs are more pleasant for users, and they are a very important
    tool to show users that something has happened or is about to occur.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This section does not aim to be an exhaustive guide to creating animations and
    beautiful UIs; the goal here is to provide you with some basic information about
    the common solutions we can put in place to animate our React components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For a UI library such as React, it is crucial to provide an easy way for developers
    to create and manage animations. React comes with an add-on, called  `react-addons-css-transition-group`,
    which is a component that helps us build animations in a declarative way. Again,
    being able to perform operations declaratively is incredibly powerful, and it
    makes the code much easier to reason about and share with the team.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to apply a simple fade-in effect to text with the React add-on,
    and then  we  will perform the same operation using  `react-motion`, a third-party
    library that makes creating complex animations even easier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do to start building an animated component is to
    install the add-on:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have done that, we can import the component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we just wrap the component to which we want to apply the animation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, there are some props that need explaining.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: First, we are declaring the `transitionName` prop. `ReactCSSTransitionGroup`  applies
    a class with the name of that property to the child element so that we can then
    use CSS transitions to create our animations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: With a single class, we cannot easily create a proper animation, and that is
    why the transition group applies multiple classes according to the state of the
    animation. In this case, with the  `transitionAppear`  prop, we are telling the
    component that we want to animate the children when they appear on the screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: So, what the library does is apply the  `fade-appear`  class (where  `fade`  is
    the value of the  `transitionName`  prop) to the component as soon as it gets
    rendered. On the next tick, the  `fade-appear-active` class is applied so that  we  can
    fire our animation from the initial state to the new one, using CSS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We also have to set the  `transitionAppearTimeout`  property to tell  React  the
    length of the animation so that it doesn't remove elements from the DOM before
    animations are completed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The CSS to make an element fade-in is as follows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the opacity of the element in the initial state:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we define our transition using the second class, which starts as soon
    as it gets applied to the element:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are transitioning the opacity from  `0.01`  to  `1`  in  `500ms`  using the
    `ease-in` function. This is pretty easy, but we can create more complex animations,
    and we can also animate different states of the component. For example, the  `*-enter`  and  `*-enter-active`  classes
    are applied when a new element is added as a child of the transition group. A
    similar thing applies to  remove  elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next section, we are going to check out the most popular library to
    create animations in React:  `react-motion`, which is maintained by Cheng Lou.
    It provides a very clean and easy-to-use API that gives us a very powerful tool
    to create any animations.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: React Motion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React Motion** is an animation library for React applications that make it
    easy to create and implement realistic animations. As soon as the complexity of
    the animations grows, or when  we  need animations that depend on other animations,
    or when we need to apply some physics-based behavior to our components (which
    is a bit more advanced), we will realize that the transition group is not helping
    us enough, so we may consider using a third-party library.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we first have to install it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the installation is successfully completed, we need to import the `Motion`
    component and the `spring` function. `Motion` is the component we will use to
    wrap the elements we want to animate, while the function is a utility that can
    interpolate a value from its initial state to the final one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s look at the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are a lot of interesting things here. First, you may have noticed that
    this component uses the function as a child pattern (see  *Chapter 4,* *Exploring
    Popular Composition Patterns*), which is a pretty powerful technique to define
    children that receive values at runtime.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can see that the  `Motion`  component has two attributes: the first
    one is  `defaultStyle`, which represents the initial `style` attribute. Again,
    we set the opacity to  `0.0.1`  to hide the element and start the fade.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `style` attribute represents the final style instead, but we do not set
    the value directly; instead, we use the `spring` function so that the value is
    interpolated from the initial state to the final one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration of the `spring` function, the child function receives the
    interpolated style for the given point in time and, just by applying the received
    object to the `style` attribute of the component, we can see the transition of
    the opacity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This library can do some more cool stuff, but the first things to learn about
    are the basic concepts, and this example should clarify them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to compare the two different approaches of the transition
    group and `react-motion` to be able to choose the right one for the project you
    are working on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in our next section, we are going to see how we can work with SVG in
    React.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SVG
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, one of the most interesting techniques we can  apply  in
    the browser to draw icons and graphs is  **Scalable Vector Graphics**  (**SVG**).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: SVG is  great  because it is a declarative way of describing vectors and it
    fits perfectly with the purposes of React. We used to use icon fonts to create
    icons, but they have well-known problems, with the first being that they are not
    accessible. It is also pretty hard to position icon fonts with CSS, and they do
    not always look beautiful in all browsers. These are the reasons we should prefer
    SVG for our web applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: From a React point of view, it does not make any difference if we output a  `div`  or
    an SVG element from the `render` method, and this is what makes it so powerful.
    We also tend to choose SVG because we can easily modify them at runtime using
    CSS and JavaScript, which makes them an excellent candidate for the functional
    approach of React.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: So, if we think about our components as a function of their props, we can easily
    imagine how we can create self-contained SVG icons that we can manipulate by passing
    different props to them. A common way to create SVG in a web app with React is
    to wrap our vectors into a React component and use the props to define their dynamic
    values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example where we draw a blue circle, thus creating
    a React component that wraps an SVG element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we can easily use a stateless functional component that wraps
    the SVG markup, and it accepts the same props as SVG does.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'An example usage is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can obviously use the full power of React and set some default parameters
    so that, if the circle icon is rendered without props, we still show something.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define the default color:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is pretty powerful when we build UIs, especially in a team where we share
    our icon set and we want to have some default values in it, but we also want to
    let other teams decide their settings without having to recreate the same SVG
    shapes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, we prefer to be more strict and fix some values to keep
    consistency. With React, this is a super simple task.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can wrap the base circle component into `RedCircle`, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the color is set by default and it cannot be changed, while the other
    props are transparently passed to the original circle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two circles, blue and red, that are generated
    by React using SVG:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/024940fd-bb15-47bd-8457-f738b7cd573a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: We can apply this technique and create different variations of the circle, such
    as `SmallCircle` and `RightCircle`, and everything else we need to build our UIs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different things we can do when we target
    the browser with React, from form creation to events, and animations to SVG. Also,
    we learned how to use the new `useRef` Hook. React gives us a declarative way
    to manage all the aspects we need to deal with when we create a web application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In case we need it, React gives us access to the actual DOM nodes in a way that
    means we can perform imperative operations with them, which is useful if we need
    to integrate React with an existing imperative library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about CSS and inline styles, and it will clarify what
    it means to write CSS in JavaScript.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
