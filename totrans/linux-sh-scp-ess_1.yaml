- en: Chapter 1. The Beginning of the Scripting Journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix, Unix-like, or Linux-based OS provide a lot of powerful features to work
    upon. Among them, the most powerful and important feature is executing a wide
    range of commands to perform a task quickly and easily; for example, `ls`, `cat`,
    `sort`, `grep`, and so on. We will come to know about a subset of commands and
    usages throughout this book. In order to run a command, we need an interface that
    is widely known as **shell**.
  prefs: []
  type: TYPE_NORMAL
- en: Shell is a program that acts as an interface between the users (we) and the
    OS kernel (Linux, Unix, and so on). Understanding in terms of Windows OS, shell
    serves a similar purpose DOS does. Different shells are available for Unix, Unix-like,
    or Linux OS. Some of the popular shells are Bourne shell (sh), C shell (csh),
    Korn shell (ksh), Bourne Again shell (bash), and Z shell (zsh).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will be using Linux OS and Bourne Again shell, popularly known
    by its acronym `bash`. Linux-based systems generally have `bash` already installed.
    In case `bash` is not installed, try installing the bash package from your distribution''s
    package manager. In order to know which shell currently your Linux console is
    using, run the following command in terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding ouput, we see that the `CMD` column has value `bash`. This
    means, we are currently using `bash` shell in our current console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your console is not using the `bash` shell, then you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, your shell will be `bash` now. To make `bash` as a default login shell,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now set with `bash` shell and ready to learn shell scripting in detail.
    Shell scripts are nothing but plain text files with a series of commands that
    are run by `bash` in a specified order. Writing shell scripts is very useful when
    you have to perform a series of tasks by running various commands, as `bash` will
    read each line from a script file and run it without any need of user intervention.
    The general file extension used for shell scripts are `.sh`, `.bash`, `.zsh`,
    `.ksh`, and so on. Rather than using a file extension for shell scripts, it''s
    preferred to keep a filename without extension and let an interpreter identify
    the type by looking into shebang (`#!`). Shebang is used in scripts to indicate
    an interpreter for execution. It is written in the first line of a script file,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It means use the `bash` shell to execute a given script. To run a shell script,
    make sure it has execute permission. To provide execute permission to an owner
    of a file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `foo` is the shell script file. After running this command, `foo` will
    have execute permission for the owner of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to proceed further on learning shell scripting concepts in
    detail. Each topic and subtopic covered in the chapters with examples will lead
    us progressively towards a good shell script programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk broadly about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World in shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define variables of choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builtin shell variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell expansions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct commands using eval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make bash behave using set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World in shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we learn a new programming language, we first learn how to write the
    Hello World program in it. It is the best way to know and interact with a new
    language. This also helps in confirming that the basic environment for a program
    in a given language has been set up and you are good to dive deep inside this
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can print the output of commands in console in an interactive way. Console
    is also known as a standard input and output stream. To print anything in a `bash`
    console, use the `echo` command followed by what is to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, put the text to be printed in double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also put the text to be printed in single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `printf` command in shell programming for printing. The
    `printf` command also supports formatted printing, similar to what we have in
    C programming language— the `printf( )` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after the output, we see the command prompt (`$`) because `printf` doesn''t
    add a default newline after execution while echo does. So, we have to explicitly
    add the newline `(\n`) in the `printf` statement to add a newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the C `printf( )`, we can specify formatted printing in `bash`.
    The syntax of `bash` `printf` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`FORMAT` is a string that describes the format specifications and is specified
    within double quotes. `ARGUMENTS` can be the value or a variable corresponding
    to format specification. Format specification consists of the percentage (`%`)
    sign followed by format specifier. Format specifiers are explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Format specification | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%u` | This prints an unsigned integer value |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` or `%d` | This prints an associated argument as a signed number |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | This prints an associated argument as a floating point number |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | This prints an unsigned octal value |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | This prints a string value |'
  prefs: []
  type: TYPE_TB
- en: '| `%X` | This prints an unsigned hexadecimal value (0 to 9 and A to F) |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | This prints an unsigned hexadecimal value (0 to 9 and a to f) |'
  prefs: []
  type: TYPE_TB
- en: 'The following examples demonstrate how to use format specification for printing
    different data type format in shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also optionally specify a modifier in format specification to align
    an output to provide better formatting to the output. Format modifiers are placed
    between `%` and the format specifier character. The following table explains format
    modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Format Modifiers | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| N | This is any number that specifies a minimum field width. |'
  prefs: []
  type: TYPE_TB
- en: '| . | This is used together with field width. The field doesn''t expand when
    the text is longer. |'
  prefs: []
  type: TYPE_TB
- en: '| - | This is the left-bound text printing in the field. |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | This is used to fill padding with zeros (0) instead of whitespaces. By
    default, padding is done with whitespaces. |'
  prefs: []
  type: TYPE_TB
- en: 'The following example demonstrates how to use format modifiers to improve printing
    formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's make it scripted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interactive printing is good if we have to print one or two lines, but for a
    lot of printing, it's good and preferred to write a script file. A script file
    will contain all the instructions and we can run a script file to perform the
    needed task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a `bash` script file that makes use of the `echo`
    and `printf` commands and print messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first line in `bash` script represents the path of the interpreter used.
    The second line is a comment line telling the filename of a script file. In shell
    script, we use `#` to add a comment. Furthermore, the `echo` command will print
    strings written within double quotes. For the rest, we have used `printf` to print
    formatted output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this script, we will first provide execute permission to a user/owner
    of this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the script file in console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after running this script will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s make it scripted](img/4335_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Define variables of choice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to write a simple hello world shell script. Next, we will be
    getting familiar with variables in shell and how to define and use variables in
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Nomenclature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable name can be a combination of alphanumeric and underscore. Also,
    the name of the variable can''t start with a number. The variable names in shell
    script are case-sensitive. Special characters, such as *, -, +, ~, ., ^, and so
    on, are not used in variable names because they have a special meaning in shell.
    The following table illustrates the correct and incorrect ways of naming a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Correct variable names | Incorrect variable names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| variable | 2_variable |'
  prefs: []
  type: TYPE_TB
- en: '| variable1 | 2variable |'
  prefs: []
  type: TYPE_TB
- en: '| variable_2 | variable$ |'
  prefs: []
  type: TYPE_TB
- en: '| _variable3 | variable*^ |'
  prefs: []
  type: TYPE_TB
- en: Assigning a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can assign a value to a variable by using an assignment (`=`) operator and
    followed by a value. While assigning a variable value, there shouldn''t be any
    space before and after the assignment operator. Also, a variable can''t be declared
    alone; it has to be followed by its initial value assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, it's quite easy to declare and assign a value to a variable in shell script.
    You don't have to worry about the data type of a variable on the left-hand side.
    Whatever value you provide on the right-hand side, the variable stores that value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access a variable value, use a dollar sign (`$`) operator followed by a
    variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this script will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the value of a variable using the `unset` keyword in `bash`.
    Using `unset` to a variable deletes and resets it to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after running this script will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's clear that we used unset on a fruit variable, so when we try to access
    a variable fruit after unsetting it in line no. 8, it prints nothing. The `quantity`
    variable still retains its value because we haven't used unset on it.
  prefs: []
  type: TYPE_NORMAL
- en: Constant variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also create the `constant` variable in `bash` whose value can''t be
    changed. The `readonly` keyword is used to declare a constant variable. We can
    also use `declare -r` followed by a variable name to make it constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after running this script will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From the error message, it's clear that we can't change the value of a constant
    variable, and also we can't unset the value of the constant variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading variables from a user input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can ask the user to provide input using the `read` shell built in command.
    The number of inputs to be given by a user is equivalent to the number of arguments
    provided to `read`. The value inserted by a user is stored in respective parameters
    passed to `read`. All parameters act as variables in which the corresponding user
    input value is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `read` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If no variable in an argument is specified, the input value by a user will be
    stored in the inbuilt variable `REPLY` and can be accessed further using `$REPLY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read a user input in its input variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read a value from user input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read multiple values from user input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read only the `n` characters and don''t wait for the user to input a
    complete line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can prompt the user a message before reading user input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Hiding an input character when reading in console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows the `read` command''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of running the `read.sh` script in `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `find` command has been used to search for the filename in the specified
    path. The detailed discussion of the command `find` will be done in [Chapter 6](ch06.html
    "Chapter 6. Working with Files"), *Working with Files*.
  prefs: []
  type: TYPE_NORMAL
- en: Builtin shell variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Builtin shell variables are predefined and are global variables that we can
    use in our script at any point of time. These are reserved shell variables and
    some of them may have a default value assigned by `bash`. Some variables' value
    will depend upon your current shell environment setup. The different type of shell
    may have a few specific reserved variables to it. All builtin shell variables'
    name will be in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few reserved shell variables available in `bash` shell are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Shell variables available in bash | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BASH` | This is the absolute path of the current `bash` being invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `BASH_VERSION` | This is the version number of `bash` |'
  prefs: []
  type: TYPE_TB
- en: '| `BASHPID` | This is the process ID of the current `bash` process |'
  prefs: []
  type: TYPE_TB
- en: '| `EUID` | This is the effective user ID of the current user, which is assigned
    during startup |'
  prefs: []
  type: TYPE_TB
- en: '| `HOME` | This is the current user''s home directory |'
  prefs: []
  type: TYPE_TB
- en: '| `HOSTNAME` | This is the name of the current host |'
  prefs: []
  type: TYPE_TB
- en: '| `PATH` | This is the colon-separated list of directories where shell will
    look for commands |'
  prefs: []
  type: TYPE_TB
- en: '| `PPID` | This is the process ID of the shell''s parent |'
  prefs: []
  type: TYPE_TB
- en: '| `PWD` | This is the present working directory |'
  prefs: []
  type: TYPE_TB
- en: More shell variables can be found in `man bash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see what values these shell variables contain by printing its value
    in a shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this script, the output may vary depending upon what the value
    of these variables is set in your system. The sample output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The shell variables, such as `PWD`, `PATH`, `HOME`, and so on, are very useful
    and help in getting the information quickly by just echoing a value in it. We
    can also add or modify the value of some of shell variables, such as `PATH`, in
    order to add a custom path in which we want shell to look for commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the use-cases of modifying the `PATH` variable value is: suppose, I
    have compiled a source code that generates a few binaries such as, `foo` and `bar`.
    Now, if I want shell to search in that particular directory for command as well,
    then add this directory path in the `PATH` variable and we are done. The following
    small shell script example shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script will be somewhat as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We see from the output that a new `PATH` variable has my custom path added.
    From the next time, whenever I run the `foo` or `bar` commands with this custom
    `PATH` variable set, the absolute path of the `foo` and the `bar` command/binary
    won't be required. Shell will find out these variables by looking into its `PATH`
    variable. This is true only during the current session of shell. We will see this
    in [Chapter 5](ch05.html "Chapter 5. Customizing the Environment"), *Customizing
    Environment* in recipe, *Modifying a shell environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to other programming languages, shell programming also supports various
    types of operators to perform tasks. Operators can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Equal to an operator (`=`) is the assignment operator that is used to initialize
    or change the value of a variable. This operator works on any data such as a string,
    integer, float, array, and so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arithmetic operators are used for doing arithmetic operations on integers.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: + (plus)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- (minus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* (multiplication)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: / (division)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '** (exponentiation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '% (modulo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: += (plus-equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -= (minus-equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*= (multiplication-equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: /= (slash-equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%= (mod-equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To perform any arithmetic operation, we prefix the `expr` and `let` keywords
    before the actual arithmetic expression. The following example shows how to perform
    an arithmetic operation in `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after running this script will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators are also known as Boolean operators. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**!** (**NOT**), **&&** (**AND**), and **||** (**OR**)'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a logical operation returns a Boolean value as `true (1)` or `false
    (0)` depending upon the values of variable(s) on which the operation is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the useful use-case is: suppose that we want to execute a command if
    the first command or operation returns successfully. In this case, we can use
    the `&&` operator. Similarly, if we want to execute another command, irrespective
    of the first command that got executed or not, then we can use the || operator
    between two commands. We can use the ! operator to negate the true value. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cd` command is used to change the current path to the specified argument.
    Here, the `cd ~/Documents/` command will change the directory to `Documents if
    exists`. If it fails, then `ls` won''t get executed, but if `cd` to `Documents`
    succeeds, the `ls` command will display the content of `Documents directory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cat` command displays the content of `file.txt` if it exists. Irrespective
    of the `cat ~/file.txt` command execution, later the command that is `echo "Current
    Working directory $PWD"` will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By running the preceding commands, first it will try to change the directory
    to `/tmp/foo`. Here, `! cd /tmp/foo` means if change directory to `/tmp/foo` doesn't
    succeed, then run the second command, which is `mkdir /tmp/foo`. The `mkdir` command
    is used to create a new directory. As a result of proceeding command execution,
    directory `/tmp/foo` will be created if it doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since the `/tmp/foo` directory has been created, a successful change of the
    directory will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comparison operators compare two variables and check whether a condition is
    satisfied or not. They are different for integers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparison operators that are valid for integer variables (consider `a` and
    `b` as two integer variables; for example, `a=20, b=35`) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: -eq (is equal to) - `[ $a -eq $b ]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -ne (is not equal to) - [ $a -ne $b ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -gt (is greater than) - [ $a -gt $b ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -ge or >= (is greater than or equal to) - [ $a -ge $b ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -lt (is less than) - [ $a -lt $b ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -le (is less than or equal to) - [ $a -le $b ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: < (is less than) - (($a < $b))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <= (is less than or equal to) - (($a <= $b))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (is greater than) - (($a > $b))
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>= (is greater than or equal to) - (($a >= $b))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison operators that are valid for string variables (consider a and b
    as two string variables; for example, a="Hello" b="World") are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: = (is equal to); for example, `[ $a = $b ]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '!= (is not equal to); for example, [ $a != $b ]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: < (is less than); for example, [ $a \< $b ] or [[ $a \< $b ]] or (( $a \< $b
    ))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (is greater than); for example,[ $a \> $b ] or [[ $a > $b ]] or (( $a \> $b
    ))
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: -n (string is non-empty); for example,[ -n $a ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -z (string has zero length or null); for example,[ -z $a ]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell uses the `<` and `>` operators for redirection, so it should be used with
    an escape (`\`) if used under [ … ]. Double parentheses, (( ... )) or [[ … ]],
    doesn't need an escape sequence. Using [[ … ]] also supports pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the usage and examples of operators in more detail in [Chapter 3](ch03.html
    "Chapter 3. Effective Script Writing"), *Effective Script Writing*.
  prefs: []
  type: TYPE_NORMAL
- en: Shell expansions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with shell, we perform a lot of similar and repetitive tasks.
    For example, in the current directory, there are 100 files but we are interested
    only in shell script whose file extension is `.sh`. We can execute following command
    to view only shell script files in current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will show all the files ending with `.sh`. An interesting take away from
    here is the `*` wildcard. It means a match list of files whose name can be anything
    and that ends with `.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shell expands all wildcard patterns. A list of the latest wildcard patterns
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ~ (Tilde)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* (Asterisk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '? (Question mark)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ ] (Square brackets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{ } (Curly brackets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explain shell expansion for different wildcards, we will create a test folder
    in our `home` directory using the `mkdir` command containing different files mentioned
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `touch` command creates an empty file if it doesn''t exist. If a file exists,
    then the file timestamp changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding commands will create a test directory, and inside test
    directory creates files given as parameter to the `touch` command.
  prefs: []
  type: TYPE_NORMAL
- en: ~ (Tilde)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '~ (Tilde) gets expanded by `bash` when it is present at the beginning of an
    unquoted string. The expansion depends upon what `tilde-prefix` is used. Tilde
    prefixes are characters until the first unquoted (`/`) slash. Some of the `bash`
    expansions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~`: This is the user''s home directory; the value is set in the `$HOME` variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~user_name`: This is the home directory of the user''s `user_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~user_name`/`file_name`: This is the file/directory `file_name` in the user''s
    `user_name` home directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/file_name`: This is the file/directory `file_name` in the home directory
    that is `$HOME`/`file_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~+`: This is the current working directory; the value is set in the `$PWD`
    variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~-`: This is the old or last working directory; the value is set in the `$OLDPWD`
    variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~+/file_name`: This is the file/directory `file_name` in the current directory
    that is `$PWD/file_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~-/file_name`: This is the file/directory `file_name` in the old/last working
    directory that is `$OLDPWD/file_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* (Asterisk)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It matches zero or more characters. Take a test directory as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display all files as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the C source files as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Display files that have `a` in its name, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting files with an extension .txt as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '? (Question mark)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It matches any single character: ? (single question mark will match a single
    character), ?? (double question mark matches any two characters), and so on. Take
    a test directory as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will recreate files that were removed during the previous example, and
    also update the access and modification time of the existing files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get files whose name length is irrespective of what the extension file has:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Get files whose name length is 2 or 5:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete files whose name is four characters long:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Move files to the `/tmp` directory whose name is at least three characters
    long:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We see only two files in the test directory because the rest of the files were
    of the length 3 or more.
  prefs: []
  type: TYPE_NORMAL
- en: '[ ] (Square brackets)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Square brackets match any character from the characters mentioned inside the
    square brackets. Characters can be specified as a word or range.
  prefs: []
  type: TYPE_NORMAL
- en: 'A range of characters can be specified using - (hyphen). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[a-c]`: This matches a, b, or c'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[a-z]`: This matches any character from a to z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[A-Z]`: This matches any character from A to Z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[0-9]`: This matches any character from 0 to 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a test directory as an example and recreate files in a test directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Get files whose name starts with `a`, `b`, `c`, or `d` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Get files whose name starts with any letter and ends with a letter `o` or `h`,
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Get files that have at least the letter `o` twice in its name, with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`[!characters]` (Exclamation mark) is used to match a character that is not
    part of a charter set mentioned inside square brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get files that don''t have a number in its name, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '{ } (Curly brackets)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It creates multiple wildcard patterns to match. A brace expression may contain
    either a comma-separated list of strings, a range, or a single character.
  prefs: []
  type: TYPE_NORMAL
- en: 'A range can be specified by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{a..z}`: This matches all the charterer from a to z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{0..6}`: This matches numbers 0, 1, 2, 3, 4, 5 and 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a test directory as an example and recreate files in the test directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Get files that have the file extension `.sh` or `.c`, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy `bar.c` to `bar.html` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the number from `1` to `50` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 10 files that start with `hello` and has an extension `.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: To avoid shell expansion of a wildcard, use backslash (\) or write a string
    within a single quote (' ').
  prefs: []
  type: TYPE_NORMAL
- en: Construct commands using eval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `eval` command is a shell builtin command used to construct a command by
    concatenating arguments passed to `eval`. A concatenated command is further executed
    by shell and returns a result. If no arguments are given to `eval`, it returns
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `eval` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows the expansion of a variable to the name of another
    variable using `eval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example where `eval` can be useful is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `df` command shows a system disk''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script will give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Make bash behave using set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `set` command is a shell builtin command that is used to set and unset a
    value of the local variables in shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using set is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Some of the option values are `allexport`, `braceexpand`, `history`, `keyword`,
    `verbose`, and `xtrace`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `set` without any option displays the name and value of all shell variables
    and functions, in a format that can be reused as an input for setting and unsetting
    the currently set variables.
  prefs: []
  type: TYPE_NORMAL
- en: Exit on the first failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a shell script, by default, the next line is executed if an error occurs
    in the current line. Sometimes, we may want to stop running a script further after
    an error has been encountered. The `-e` option of `set` ensures to exit a script
    once any of the commands in a pipeline fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following shell script, `do_not_exit_on_failure.sh` doesn''t use `set`
    with the option `-e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this script, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the command after the error gets executed as well. In order to
    stop the execution after an error is encountered, use `set -e` in the script.
    The following script demonstrates the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the script has been terminated after encountering an error at
    the line number `7`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling/disabling symbolic link's resolution path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `set` with the `-P` option doesn''t resolve symbolic links. Following
    example demonstrate how we can enable or disable symbolic link resolution of `/bin`
    directory which is symbolic link of `/usr/bin/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Setting/unsetting variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `set` command to see all local variables accessible for the current
    process. The local variables are not accessible in the subprocess.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own variable and set it locally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a variable accessible to its subprocesses as well, use the `export`
    command followed by the variable to be exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This will export the `MYVARIABLE` variable to any subprocess that ran from
    that process. To check whether `MYVARIABLE` has exported or not, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To unset local or exported variables, use the `unset` command and it will reset
    the value of the variable to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you understood how to write simple shell script
    in bash by printing, echoing, and asking user input. You should now have a good
    understanding of defining and using variables in shell and what builtin shell
    variables exist. You are now familiar with what operators are available in shell
    and how they can create and evaluate their own expression. With information about
    wildcards available in this chapter, it makes work easier for you while you are
    dealing with similar kind of data or pattern. The shell builtin command `set`
    enables modifying shell variables easily.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has built a foundation for upcoming chapters. Now, in next chapter,
    you will get to know about standard inputs, outputs, and errors. Also, there will
    be a detailed coverage of how to use an output from commands and then filter/transform
    them to show the data according to your need.
  prefs: []
  type: TYPE_NORMAL
