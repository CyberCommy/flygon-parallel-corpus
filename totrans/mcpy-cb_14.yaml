- en: Building an Internet of Things (IoT) Weather Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create an internet-connected weather machine that will
    tell us the weather in random cities at the press of a button. In order to produce
    this working device, we will combine a number of concepts and technologies that
    we have covered in the book .
  prefs: []
  type: TYPE_NORMAL
- en: We'll use some of the networking techniques shown in [Chapter 12](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml),
    *Networking*, as well as the display logic shown in [Chapter 13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml),
    *Interacting with the Adafruit FeatherWing OLED*, covering how to interact with
    the FeatherWing OLED. These different technologies will be combined to create
    a device that responds to touch button events by fetching live weather data using
    RESTful APIs and presenting them on an **organic light-emitting diode** (**OLED**)
    display.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter can be a useful source of information to help you create internet-connected
    devices with MicroPython that are easy to interact with and will give a rich set
    of visual outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving weather data from the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to get a city's weather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly selecting cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Screen object for text handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to show a city's weather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing visual feedback when fetching weather data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to display the weather for a random city
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IoT button to show the weather around the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files of this chapter can be found in the `Chapter14` folder of the
    following GitHub repository: [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266 and the Assembled Adafruit
    FeatherWing OLED 128x32 OLED add-on for Feather. CircuitPython 3.1.2 was used
    for all the recipes in this chapter. You will need to apply the configuration
    described in the *Connecting to an existing Wi-Fi network* recipe from [Chapter
    10](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml), *Controlling the ESP8266*. The
    `wait_for_networking` function described in the *Creating a function to wait for
    internet connectivity* recipe from [Chapter 12](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml),
    *Networking*, will also be used in this chapter. You will also need to perform
    the steps described in [Chapter 13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml),
    *Interacting with the Adafruit FeatherWing OLED*.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter use the weather API service provided by Openweather.
    This service is free to use, but you must register and obtain an **API key** (**APPID**)
    to use the service. The API key will be needed to run the code in this chapter.
    You can visit [https://openweathermap.org/appid](https://openweathermap.org/appid) to
    get an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving weather data from the internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to connect to the internet using the ESP8266 and
    fetch live weather data using RESTful web services. The service that we will be
    using has up-to-date weather information for over 100,000 cities around the world.
    A very large amount of weather information for each location is provided, so this
    recipe will show how we can drill down to the items that are of most interest
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe can be useful in your projects whenever you need to pass different
    parameters to a RESTful call or when the returned results are very large and you
    need to find ways to navigate through these large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `API_URL` variable has now been defined, which we will use to access the
    weather API. In the next block of code, we define `APPID` and `city` to get weather
    data for. Make sure to replace the `APPID` value with your actual `APPID` value.
    We will now build the URL by combining these variables, which we we can then access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will connect to the weather API and retrieve the
    weather data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the response uses JSON format, so we can parse it and inspect
    how many top-level keys are in the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code inspects the parsed weather data. There is a lot of
    nested data, so it is difficult to digest in its current form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'MicroPython doesn''t have the `pprint` module. We will copy and paste the output
    of the data and run the following on a Python REPL on a computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code on the computer''s REPL, and we will get a more
    structured representation of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can return to the MicroPython REPL now and run the following lines of code
    to inspect the `main` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next lines of code will give us access to the temperature and humidity
    values of Berlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the wind section of the data with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can drill down further and get the wind speed value for the
    requested city.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After importing the `urequests` library, we define a number of variables so
    that we can proceed and prepare the URL to perform the API call. The `API_URL`
    is a fixed constant that will not change between calls to the web service. Then,
    we define a variable to store the API key and city values. These values are combined
    to make the final URL, which we then call using the `urequests` library's `get`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `return` response is parsed and the output is displayed. Because the data
    structure is so large, we use a trick to move this data to the REPL on a computer
    where we can use the `pprint` function and get a much clearer output format of
    the returned data. This makes it much easier to identify the different parts of
    the data structure and start accessing different data elements in the nested data
    structure. We then use the keys in the dictionary to access the humidity, temperature,
    and wind speed of the city of Berlin.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of API keys is widespread in the world of web services. This recipe
    is a great example of how we can take these keys and include them in our API calls
    so that they can be processed successfully. We also showed the trick of copying
    data structures from our MicroPython REPL to a Python REPL on a computer. This
    lets us bounce between these two worlds and access some modules, such as `pprint`,
    that are available on computers but not on MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `pprint` module can be found at [https://docs.python.org/3/library/pprint.html](https://docs.python.org/3/library/pprint.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on accessing weather data by city name can be found at [https://openweathermap.org/current#name](https://openweathermap.org/current#name).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to get a city's weather
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a function to connect to the weather API and
    fetch the weather data for a particular city. We don't want to hardcode values
    such as our API keys directly in our source code. So, this recipe will also show
    you how to create a JSON formatted configuration file that can store different
    settings, such as the API key. The application will then read in the values from
    this configuration file at boot up and use them for the calls to the weather web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will be particularly useful to you whenever you want to keep configuration
    values separate from your code base, whether it be for security reasons or to
    just tweak these settings more easily without changing your application's source
    code. This can also help you in your own projects to organize the API calls into
    reusable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `CONF_PATH` variable defines the location of our JSON configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following content should be put into the `conf.json` file on the board''s
    root folder. Replace the value of `APPID` with your actual `APPID` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code defines a function that will read and parse the settings
    provided in your configuration file. The values of these settings are then returned
    to the calling function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now call the `get_conf` function and store its results into a variable
    called `conf`. The value of `APPID` is retrieved and saved into a variable for
    future use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code defines a function that receives a city name and
    performs the weather API call for that city and returns the parsed weather data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code calls the `get_weather` function for the city of London
    and stores the result in a variable called `data`. A number of different data
    fields are then accessed and printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The next block of code should be put into the `main.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will connect to the weather API and print out
    a number of retrieved data elements for the city of London.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main script first calls `wait_for_networking` to ensure that networking
    is up and running before making any API calls. It then retrieves the applications
    configuration data by calling `get_conf`, which parses the JSON data stored in
    the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `APPID` is then accessed from the configuration settings. An API
    call is then made using the `get_weather` function. This function receives the
    `APPID` value and name of the city to fetch information on. With these two values,
    it can prepare the URL and make the API call.
  prefs: []
  type: TYPE_NORMAL
- en: The results are then parsed and returned to the `main` function. The data structure
    is then accessed to get a number of values from the returned API call and print
    them out with their associated labels.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows a generic technique to store values such as your API keys
    outside your source code. JSON is a useful file format for storing configuration
    values, particularly when working with MicroPython, since it has built-in support
    for parsing this file format. Some applications also use the popular `.ini` file
    format for configuration files, which has support in the Python standard library.
    This Python module is not available as part of the main libraries in MicroPython,
    so it's best to avoid it in your MicroPython projects when you can.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `json` module can be found at [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `configparser` module used to parse INI files can be found
    at [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly selecting cities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `random` module to randomly select cities from
    a fixed list of cities. We first create a global variable called `CITIES` to store
    these values. We can then use a specific function in the `random` module that
    is for the specific purpose of selecting random items from a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will then loop 10 times and make a random selection from the list
    of cities and output details of the selected city. This recipe will be particularly
    useful to you whenever you have a project that needs to select a certain option
    randomly from a fixed list of values. You might, for example, create a dice-rolling
    MicroPython project that should choose from the values one to six on each roll.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now defined a list of cities that we can make a random selection from.
    The next code shows one of the simplest ways of getting random data from the `random`
    Python module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For our purposes, we can use the `choice` function, as it will randomly select
    an item from a list. The following block of code uses this method to randomly
    select three cities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will loop 10 times and print out a randomly selected
    city in each iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will print out 10 randomly selected cities.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first import the `random` module that will be used to perform the random
    selection of cities. The `random` function is called repeatedly to verify that
    we can get random numbers from the module. We have created a variable called `CITIES`,
    which is our list of cities that we want to make random selections from. The `choice`
    function in the `random` module is then used to pick a random choice from this
    list. The `main` function provides a demonstration of this logic by calling the
    `choice` function 10 times and printing out the results of each call.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter only needs random numbers to be chosen to create a level of unpredictability
    in the operation of the weather machine. Because of this, we don't need to worry
    about the quality of the random numbers being generated. If, however, we need
    random numbers for the purpose of some cryptographic operation, then we would
    need to be more careful of how these numbers are generated. We would also need
    to go into detail in terms of how the random number generator is initialized with
    a call to the `seed` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `choice` function can be found at [https://docs.python.org/3/library/random.html#random.choice](https://docs.python.org/3/library/random.html#random.choice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `seed` function can be found at [https://docs.python.org/3/library/random.html#random.seed](https://docs.python.org/3/library/random.html#random.seed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Screen object for text handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a `Screen` object that will make it easier to
    write a multi-line output to the FeatherWing OLED display. The weather machine
    that we are building will want to take advantage of the multi-line output capabilities
    of the OLED display.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this output, this recipe will create an object that receives multi-line
    text and will properly position the text in its associated *x* and *y* coordinates.
    You will find this recipe useful for any projects where you are writing text content
    to the display frequently and want an automatic way to handle the multi-line output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have imported the necessary modules and created a variable called `MESSAGE`
    that we will use to generate multi-line output messages. The next block of code
    will create the basic structure of the `Screen` object with a constructor that
    receives the `oled` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following lines of code, we create an object to interact with the display
    and an instance of the `Screen` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add a method to the `Screen` object that will be responsible for
    writing the multi-line text to the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create a `Screen` object and call its `write` method. You should see
    the `''hello''` text appear on the display now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code will print a multi-line message to the display that
    takes up three lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to display 10 different multi-line messages on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `screen.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will print out 10 multi-line blocks of text
    to the OLED display.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `screen` object takes a single argument to its constructor. This argument
    is the `oled` variable, which will let us interact with the display. A reference
    to this object is saved, and then all the pixels on the display are cleared. It
    also defines a method called `write`. This method receives a string, which can
    be a single or multi-line piece of text.
  prefs: []
  type: TYPE_NORMAL
- en: The display is then cleared and the text is broken up into a list of strings,
    each representing a single line of output. These lines are looped through and
    written each to their correct row. Once all lines have been processed, the `show`
    method is called on the display to render the content on the screen. The `main`
    function in this recipe sets up the `screen` object and then sends one simple
    `hello` message to the display. It then loops 10 times and generates a set of
    multi-line messages, which are displayed on the screen one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design of the `Screen` object is similar to the design of other files, such
    as objects, in Python. The `sys` Python module, for example, has a `stdout` object,
    which has a `write` method that lets you write text output to the screen. Packaging
    complex interactions, such as *x*, *y* positioning for text placement into a separate
    object, will often make the rest of the code simpler and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `stdout` object can be found at [https://docs.python.org/3/library/sys.html#sys.stdout](https://docs.python.org/3/library/sys.html#sys.stdout).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on file objects that expose the `write` methods can be found at
    [https://docs.python.org/3/glossary.html#term-file-object](https://docs.python.org/3/glossary.html#term-file-object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to show a city's weather
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a function that takes the name of a city, looks
    up its weather information, and then display a portion of this information on
    the OLED display. To achieve this, the function in this recipe will combine different
    pieces from the recipes covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to outputting to the OLED, it will also print out the same information
    to standard output to facilitate debugging. This recipe can be useful to you when
    you want to see how a project such as weather machine can be broken into separate
    pieces that all call one another in a structured design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the needed modules, we create a new variable called `WEATHER`
    that stores the template, which we will use to output the weather information
    to the display. Run the next block of code to set up the screen object and get
    the `APPID` value for the API calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following lines of code, we define the `show_weather` function that
    takes the screen, `APPID`, and the city name, and weather information for that
    city will be fetched and displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to call the `show_weather` function for the city
    of Tokyo. The text you see on the standard output should also be displayed on
    the OLED display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the following block of code, it will loop through all the cities
    and display their weather information on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will loop through all the city names and
    display their weather information on the OLED display.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `show_weather` function does most of the heavy lifting in this recipe. When
    called, it first collects the weather data by calling the `get_weather` function.
    It then takes this information and populates a dictionary called `data` with three
    values. The values are the city name, its temperature, and its wind speed.
  prefs: []
  type: TYPE_NORMAL
- en: These values are then filled into the `WEATHER` template, which acts as a template
    to control how this information is presented on the screen. The generated text
    is then both outputted to the standard output display as well as being displayed
    on the OLED display. The main function will configure a number of variables so
    that the API calls can be made and the screen can be updated. Then, it loops through
    the list of cities and calls `show_weather` for each one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a lot of options when it comes to string templates. What is used
    in this recipe is the string formatting function that is built into both Python
    and MicroPython, making it an ideal choice. It's usually a good idea to keep your
    templates in their own variables, as was done in this recipe. This makes it easier
    to change labels and to visualize what the intended result will look like.
  prefs: []
  type: TYPE_NORMAL
- en: The `show_weather` function outputs the same text on both the standard output
    and the OLED display. One of the powerful aspects of dealing with textual output
    is that you can replicate the same output on many devices. You could extend this
    further and keep a record of every screen update in a text log file to help with
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on Python string formatting can be found at [https://docs.python.org/3.4/library/string.html#string-formatting](https://docs.python.org/3.4/library/string.html#string-formatting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `Template` object can be found at [https://docs.python.org/3.4/library/string.html#template-strings](https://docs.python.org/3.4/library/string.html#template-strings).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing visual feedback when fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will enhance the code in the last recipe in such a way as
    to add visual feedback each time we start the operation of fetching the weather
    data for a particular city. The first part of this recipe is to take some measurements
    to find out how slow the `show_weather` function is. This will give us a sense
    of whether the function is slow enough that it would be visible to a user.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will use the `invert` feature on the display to provide immediate visual
    feedback that we have started fetching weather data. This recipe will help you
    as a real-life example of the performance challenges you can face with the hardware
    constraints of microcontrollers and how you can overcome them at times to provide
    some sort of feedback to the users of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. The approach of measuring execution time and inverting colors are
    based on what was covered in the *Inverting colors on the display* recipe in [Chapter
    13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml), *Interacting with the Adafruit
    FeatherWing* *OLED*. It will be helpful to first review that recipe before continuing
    with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `measure_time` function has now been defined. Before continuing, be sure
    to paste all the function definitions, module imports, and global variables from
    the `main.py` file in the previous recipe into the REPL. Then, run the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need to measure the execution time of the `show_weather`
    function. Run the next block of code to take three measurements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From these measurements, we can see that each call takes about 2 seconds of
    execution time. We will now add to calls to the `invert` method at the start and
    end of the `show_weather` function, as shown in the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code, when executed, will provide visual feedback at
    the start and end of the `show_weather` function''s execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will loop through each city and call the
    `show_weather` function with the new inverted color visual feedback.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `measure_time` function helped us measure how long the execution took for
    the `show_weather` function. This function is fetching data from the internet,
    parsing it, and then performing a number of screen operations to display it. The
    measured execution time was around 2 seconds. Microcontrollers, compared to desktop
    computers, have limited computational power. Operations like these on a desktop
    would take a few hundred milliseconds, but on a microcontroller can take longer.
    Because of this noticeable execution time, we have enhanced the `show_weather`
    function by inverting the colors at the very start of its execution. This color
    inversion will be shown within a few milliseconds and will be displayed before
    any other processing is done. Then, at the end of the execution, the inverted
    colors are returned back to their normal state to indicate that the function has
    completed its execution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a later recipe, when we connect the push button to the `show_weather` function,
    visual feedback will become very important. A 2 second delay in a screen update
    is very visible and users will lead some sort of visual feedback to indicate the
    machine is performing an operation as opposed to being stuck. The `invert` method
    shown in this recipe is perfect for this purpose and doesn't require very much
    additional code to achieve its result.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Details on human perceptual abilities from a usability perspective can be found
    at [https://www.nngroup.com/articles/response-times-3-important-limits/](https://www.nngroup.com/articles/response-times-3-important-limits/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on software usability can be found at [https://www.interaction-design.org/literature/topics/usability](https://www.interaction-design.org/literature/topics/usability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to display the weather for a random city
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a function that will select a random city and
    display its weather information on the screen each time it is called. The function
    will use the `choice` function from the `random` module to select a random city,
    and then it will use the `show_weather` function to display the weather information
    for that city.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe can be useful to you whenever you are in a situation where you want
    to add some randomness to a project so that there is a greater level of unpredictability
    in the interaction with that device. This can create some unexpected and surprising
    behavior in your projects that make them more interesting to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check for the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show_random_weather` function has now been defined. Before continuing,
    be sure to paste all the function definitions, module imports, and global variables
    from the `main.py` file in the previous recipe into the REPL. Then, run the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code and the weather of a random city will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now loop three times and call the `show_random_weather` function to
    test its functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will loop three times and select a random
    city in each iteration, which will have its weather information displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `show_random_weather` function expects two arguments as its input. The screen
    and `APPID` are needed as input arguments to make the needed API calls and update
    the screen contents. The `choice` function of the `random` module is called on
    the `CITIES` list to select a random city. Once this city is selected, its weather
    can be fetched and displayed using the `show_weather` function. The `main` function
    in this recipe loops three times and calls the `show_random_weather` function
    in each `for` loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is one of the last remaining pieces of the internet-connected weather
    machine. We have built and tested each piece of this application to confirm that
    each one goes before building additional logic on the previous layer. All the
    code and logic of this recipe is self-contained in its own function, which improves
    code readability and also helps with troubleshooting. If any errors occur, it
    will be easier to troubleshoot by knowing exactly which function the exception
    was raised in.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on interacting with displays on MicroPython details can be found
    at [https://learn.adafruit.com/micropython-displays-drawing-shapes](https://learn.adafruit.com/micropython-displays-drawing-shapes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on a microcontroller project using the Adafruit FeatherWing OLED
    can be found at [https://learn.adafruit.com/digital-display-badge](https://learn.adafruit.com/digital-display-badge).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IoT button to show the weather around the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will add the final touch to our internet-connected weather
    machine. We will take the bulk of code introduced in the recipes throughout this
    chapter and add an `event` loop to our `main` function so that we can react to
    button press events by displaying the weather of random cities around the world.
    This recipe will provide you with a good example of how you can add an `event`
    loop to an existing code base to create user interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the steps required in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pin` object is now imported so that we can interact with the board''s
    push buttons. Before continuing, be sure to paste all the function definitions,
    module imports, and global variables from the `main.py` file in the previous recipe into
    the REPL. Then run the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `button` variable can now read the state of push button A. Run the next
    block of code to detect whether push button A is currently being pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'While pressing push button A, execute the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to prepare the `screen` and `APPID` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will start an `event` loop. Each time you press
    push button A, the weather of a random city should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will kick off an `event` loop that will fetch
    and display the weather of a random city each time push button A is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function in this recipe creates a `Pin` object called `Button` that
    will be connected to push button A. We can use this `button` variable to poll
    the state of the push button. We then show the weather for a random city so that
    the starting state of the application is the weather being shown on the display.
    Then, an `infinite` loop is started, which will be our `event` loop to process
    any push button events. In each loop, we check whether push button A is pressed.
    If it is, then the `show_random_weather` function is called to display the weather
    of a random city on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe reacts to a single push button to show random weather. We could
    connect push button B and C to our main `event` loop and have them produce other
    functionalities. Push button A might change the city while B and C could let you
    scroll and see more weather information relating to the currently selected city.
    The next photograph shows what the internet-connected weather machine looks like
    when showing weather information on the city of Tokyo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0b499f3-126b-47ee-b061-1ca6896c55dc.png)'
  prefs: []
  type: TYPE_IMG
- en: This recipe could also be changed to fetch and display any information from
    web services. You could fetch the latest news headlines and display them, or display
    a random joke from a RESTful joke API. The sky is the limit to what you can do
    with a multi-line text display and internet connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on using the `PULL_UP` setting with buttons on MicroPython can
    be found at [https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs](https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on a RESTful jokes API can be found at [http://www.icndb.com/api/](http://www.icndb.com/api/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
