- en: '*Chapter 13*: Files, Streams, and Serialization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programming is all about processing data that could come from various sources,
    such as local memory, disk files, or from a remote server over the network. Most
    data has to be persisted for either a long time or indefinitely. It has to be
    available between different application restarts or shared between multiple applications.
    Whether the storage is plain text files or various types of databases, whether
    they are local, from the network, or a cloud, whether the physical location is
    hard disk drives, solid state drives, or USB sticks, all data is preserved in
    a filesystem. Different platforms have different types of filesystems, but they
    all work with the same abstractions: paths, files, and directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look at the functionalities that .NET provides for working
    with filesystems. The main topics that will be covered in this chapter are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the `System.IO` namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing and deserializing XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing and deserializing JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to create, modify, and
    delete files and directories. You will have also learned how to read from and
    write to files with different kinds of data (including binary and text). Lastly,
    you will have learned how to serialize objects to XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by exploring the `System.IO` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the System.IO namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET frameworks provide classes as well as other helper types such as enumerations,
    interfaces, and delegates that help us work with the `System.IO` namespace in
    the Base Class Library. The complete list of types is rather long, but the following
    tables show the most important of these grouped into several categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important classes for working with *filesystem objects* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important classes for working with *streams* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the previous table, the concrete classes in this list come
    in pairs: a reader and a writer. Typically, these are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BinaryReader` and `BinaryWriter` are used to explicitly serialize and deserialize
    primitive data types to or from binary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamReader` and `StreamWriter` are used for handling character-based data,
    with different encodings, from text files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringReader` and `StringWriter` have similar interfaces and purposes as the
    previous pair, although they work on strings and string buffers and not streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between the classes in the previous table is shown in the
    following simplified class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – A class diagram of stream classes as well as reader and writer
    classes mentioned previously'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – A class diagram of stream classes as well as reader and writer
    classes mentioned previously
  prefs: []
  type: TYPE_NORMAL
- en: From this diagram, you can see that only `FileStream` and `MemoryStream` are
    actually stream classes. `BinaryReader` and `StreamReader` are adapters that read
    data from a stream, while `BinaryWriter` and `StreamWriter` write data to a stream.
    All these classes require a stream to create an instance (the stream is passed
    as an argument to the constructor). On the other hand, `StringReader` and `StringWriter`
    don't work on streams at all; instead, they read and write from a string or string
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operations with the filesystem objects or streams throw exceptions when
    errors occur. The most important of these exceptions are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections of this chapter, we will look at some of these classes
    in detail. For now, we will start with the `Path` class.
  prefs: []
  type: TYPE_NORMAL
- en: Working with paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`System.IO.Path` is a static class that performs operations on strings, representing
    the path of a filesystem object (a file or a directory). None of the class methods
    verify whether the string represents the path of a valid file or directory. However,
    members that accept an input path verify that the path is well formed; otherwise,
    they throw an exception. This class can handle paths for different platforms.
    The format of a path such as the presence of a root element or the path separator
    is platform-dependent and is determined by the platform that the application is
    running on.'
  prefs: []
  type: TYPE_NORMAL
- en: A path can be *relative* or *absolute*. An absolute path is one that fully specifies
    the location. On the other hand, a relative path is a partial location determined
    by the current location, which can be retrieved with a call to the `Directory.GetCurrentDirector()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the members of the `Path` class are static. The most important ones are
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see how this works, we can consider the following example, where we''re
    using various methods of the `Path` class to print information about the `c:\Windows\System32\mmc.exe`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A screenshot of executing the previous sample that prints information
    about a path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – A screenshot of executing the previous sample that prints information
    about a path
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` class contains a method called `Combine()` and it is recommended
    to use it for composing a new path from two or more paths. There are four overloads
    of this method; these overloads take two, three, four paths, or an array of paths
    as input arguments. To understand how this works, we will look at the following
    examples, where we are concatenating two paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the result of the concatenation is `c:\temp\sub\data.txt`,
    which properly includes a path separator between `temp` and `sub`, which was not
    present in any of the two input paths. In the second example, the result of the
    concatenation of the three paths is `c:\temp\sub\..\log.txt`. Notice that the
    path is properly composed, but not resolved to the actual path, that is, `c:\temp\log.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods listed earlier, there are several other static methods
    in the `Path` class, a few of them intended for working with temporary files.
    These are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at an example of working with temporary paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, `path1` will contain a path such as `C:\Users\Marius\AppData\Local\Temp\w22fbbqw.y34`,
    although the file name (including extension) will change with each execution.
    Also, this path is not created on disk, unlike the second example, where the `C:\Users\Marius\AppData\Local\Temp\tmp8D5A.tmp`
    path is actually representing a newly created file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Screenshot of the sample demonstrating the use of the GetRandomFileName()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Screenshot of the sample demonstrating the use of the GetRandomFileName()
    and GetTempFileName() methods
  prefs: []
  type: TYPE_NORMAL
- en: There are two important differences between these two temporary paths—the first
    one uses a cryptographically strong method for generating the name, while the
    second uses a much simpler algorithm. On the other hand, `GetRandomFileName()`
    returns a name with a random extension, while `GetTempFileName()` always returns
    a path with a filename with the `.TMP` extension.
  prefs: []
  type: TYPE_NORMAL
- en: To verify whether a path exists and perform operations such as creating, moving,
    deleting, or opening a directory or file, we must use other classes from the `System.IO`
    namespace. We'll look at these classes in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `System.IO` namespace contains two classes for working with directories
    (`Directory` and `DirectoryInfo`), and two for working with files (`File` and
    `FileInfo`). `Directory` and `File` are `DirectoryInfo` and `FileInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter two are derived from the `FileSystemInfo` base abstract class, which
    provides members that are common for manipulating both files and directories.
    The most important of these members are the properties listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important members of the `DirectoryInfo` class, excluding the ones
    inherited from the base class, which were listed in the preceding table, are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the most important members of the `FileInfo` class, excluding the
    ones inherited from the base class, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_08_01.jpg)![](img/Chapter_13_Table_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have looked at the classes available for handling filesystem objects
    and their most important members, let's look at some examples of using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we will use an instance of `DirectoryInfo` to print information
    about a directory (in this example, `C:\Program Files (x86)\Microsoft SDKs\Windows\`),
    such as name, parent, root, creation time, and attributes, as well as the names
    of all its subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from executing this code is as follows (notice this will differ
    on each machine that executes the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Screenshot of the previous sample displaying directory information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Screenshot of the previous sample displaying directory information
  prefs: []
  type: TYPE_NORMAL
- en: '`DirectoryInfo` also allows us to create and delete directories, which is what
    we will do in the next example. First, we create the `C:\Temp\Dir\Sub` directory.
    Second, we create the subdirectory hierarchy, `sub1\sub2\sub3`, relative to the
    previously directory. Lastly, we delete the most inner directory, `sub3`, from
    the `C:\Temp\Dir\Sub\sub1\sub2` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `CreateSubdirectory()` method returns a `DirectoryInfo` instance
    that represents the most inner subdirectory created, which, in this case, is `C:\Temp\Dir\Sub\sub1\sub2\sub3`.
    Therefore, when invoking `Delete()` on this instance, only the `sub3` subdirectory
    is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the same functionality using the `Directory` static class and
    its `CreateDirectory()` and `Delete()` methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `Delete()` will delete the `C:\Temp\Dir\Sub\sub1\sub2\sub3`
    subdirectory, but only if it is empty. The second call will delete the `C:\Temp\Dir\Sub`
    subdirectory and all its content (files and subdirectories) in a recursive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will list all the executable files that start with
    the letter `T` from a given directory (in this case, `C:\Program Files (x86)\Microsoft
    SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\`). For this, we''ll use the `GetFiles()`
    method providing the proper filter. This method returns an array of `FileInfo`
    objects and we print information about the file using different properties of
    this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from executing this code sample could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – A screenshot of the program listing executables that start
    with the letter T from a given directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – A screenshot of the program listing executables that start with
    the letter T from a given directory
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the information about the file, we used the `FileInfo` class, as mentioned
    previously. `Name`, `Length`, and `Attributes` are only some of the properties
    this class provides. Others include the extension and file times. An example of
    using them is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the output will vary on each machine, it should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Detailed file information displayed with the help of the FileInfo
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Detailed file information displayed with the help of the FileInfo
    class
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use what we have learned so far to create a function that writes the
    content of a directory recursively to the console and while doing so, also indents
    the names of the files and directories as it navigates deeper in the directory
    hierarchy. Such a function could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed with the path of the project directory as input, it prints the
    following output to the console (the following screenshot is a snippet of the
    complete output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Partial output of the program that prints, recursively, the
    content of a specified directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Partial output of the program that prints, recursively, the content
    of a specified directory
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, we used both `GetFiles()` and `EnumerateFile()`, as
    well as `EnumerateDirectories()`. These two sets of methods, the ones prefixed
    with `Get` and the ones prefixed with `Enumerate`, are similar in the sense that
    they return a collection of files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: However, they differ in one key aspect—the `Get` methods return an array of
    objects, while the `Enumerate` methods return an `IEnumerable<T>` that allows
    clients to start iterating before all the filesystem objects are retrieved and
    also consume only what they want. These methods could, therefore, be a better
    alternative in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the examples so far were focused on getting file and directory information,
    although we did create and delete directories. We can use the `File` and `FileInfo`
    classes to create and delete files. For instance, we can use `File.Create()` to
    create a new file or open and overwrite an existing file, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`File.Create()` returns a `FileStream` that, in this example, is then used
    to create a `StreamWriter` that allows us to write the text `This is a demo` to
    the file. The stream is then disposed and the file handle is properly closed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested only in writing text or binary data, you can use static
    members of the `File` class, such as `WriteAllText()`, `WriteAllLines()`, or `WriteAllBytes()`.
    These have multiple overloads, allowing you, for instance, to specify text encoding.
    There are also asynchronous counterparts, `WriteAllTextAsync()`, `WriteAllLinesAsync()`,
    and `WriteAllBytesAsync()`. All these methods overwrite the current content of
    the file if it already exists. If you are interested in preserving the content
    and appending to its end, then you can use the `AppendAllText()` and `AppendAllLines()`
    methods and their asynchronous counterparts, `AppendAllTextAsync()` and `AppendAllLinesAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to write and append text to an existing file
    using some of the methods mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call, `WriteAllText()`, will write `This is a demo` to the file,
    overwriting any content. The second call, `AppendAllText()`, will append `1st
    line` without adding any new lines. The third call, `AppendAllLines()`, will write
    each string to the file, adding a new line after each. Therefore, after executing
    this code, the content of the file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to writing content to a file, reading is also possible using the `File`
    class and its `ReadAllText()`, `ReadAllLines()`, and `ReadAllBytes()` methods.
    As with the write methods, there are also asynchronous versions, `ReadAllTextAsync()`,
    `ReadAllLinesAsync()`, and `ReadAllBytesAsync()`. An example of using some of
    these methods is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After executing this code, the `text` variable will contain the entire text
    read from the file. On the other hand, `lines` will be an array with two elements,
    the first being `This is a demo1st line2nd line` and the second being `3rd line`.
  prefs: []
  type: TYPE_NORMAL
- en: Plain text is not the only kind of data we would usually write to a file, and
    files are not the only storage systems for data. Sometimes, we might be interested
    in reading and writing from and to pipes, networks, local memory, or others. To
    handle all of this, .NET provides *streams*, which is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Stream`, which provides support for reading from and writing to a stream.
    On the other hand, the streams are conceptually grouped into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileStream`, `MemoryStream`, and `NetworkStream` to implement backing stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedStream`, `CryptoStream`, `DeflateStream`, and `GZipStream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`, `int`, `double`, etc.), text, XML data, and so on. Adaptors provided
    by .NET include `BinaryReader` and `BinaryWriter`, `StreamReader` and `StreamWriter`,
    and `XmlReader` and `XmlWriter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows, conceptually, the stream architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – A conceptual diagram of the stream''s architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – A conceptual diagram of the stream's architecture
  prefs: []
  type: TYPE_NORMAL
- en: Discussing all the stream classes pictured in the preceding diagram is beyond
    the scope of this book. However, in this section, we will focus on the `BinaryReader`/`BinaryWriter`
    and `StreamReader`/`StreamWriter` adapters, as well as the `FileStream` and `MemoryStream`
    backing store streams.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the stream classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, the base class for all stream classes is the `System.IO.Stream`
    class. This is an abstract class that provides methods and properties for reading
    and writing from and to a stream. Many of these are abstract and are implemented
    in derived classes. The following are the most important methods of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some of the operations listed have asynchronous companions, which are suffixed
    with the word `Async` (such as `ReadAsync()` or `WriteAsync()`). The read and
    write operations advance the pointer that indicates the position in the current
    stream with the number of bytes read or written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Stream` class also provides several useful properties that are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The class that represents a backing store stream for a file is called `FileStream`.
    This class is derived from the abstract `Stream` class and implements the abstract
    members. It supports both synchronous and asynchronous operations and can be used
    for opening, reading, writing, and closing not only disk files but other operating
    system objects, such as pipes and the standard input and output. The asynchronous
    methods are useful for performing time-consuming operations without blocking the
    main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileStream` class supports random access to a file. The `Seek()` method
    allows us to move the position of the current pointer for reading/writing within
    the stream. When changing the position, you must specify a byte offset and a seek
    origin. The byte offset is relative to the seek origin, which can be the beginning,
    the current position, or the end of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The class provides many constructors for creating an instance of the class.
    You can supply a file handle (either as an `IntPtr` or a `SafeFileHandle`) or
    a file path, as well as a file mode (which determines how the file should be opened),
    file access (which determines how the file should be accessed – for reading, writing,
    or both), and file share (which determines how other file streams can access the
    same file) in various combinations. Listing all these constructors is impractical
    here but we will see several examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The class that represents a backing store for memory is called `MemoryStream`
    and is also derived from `Stream`. Most of the members of this class are implementations
    of the abstract members of the base class. However, the class features several
    constructors that allow us to create either a **resizable stream** (initially
    empty or with a specified capacity) or a **non-resizable stream** from an array
    of bytes. Memory streams created from an array of bytes cannot be expanded or
    shrunk and can be writeable or read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FileStream` class allows us to read and write a sequence of bytes from/to
    a file. It operates with raw data such as `byte[]`, `Span<byte>`, or `Memory<byte>`.
    We can obtain a `FileStream` object using static methods of the `File` class or
    non-static methods of the `FileInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see how this works using the following example, where we write four
    bytes to the file located at `C:\Temp\data.raw` and then we read the entire content
    of the file and print it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the first part, we use `File.Create()` to open a file for writing. If the
    file does not exist, then it is created. If the file exists, then its content
    will be overwritten. The `FileStream.Write()` method is used to write the content
    of the byte array to the file. The stream will be flushed to the file and the
    file handle will be closed when the `FileStream` object is disposed of at the
    end of the `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second part, we use `File.OpenRead()` to open the file that was previously
    written, but this time for reading. We allocate an array large enough to receive
    the entire content of the file and use `FileStream.Read()` to read its content.
    The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – The content of created binary file displayed to the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.9_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – The content of created binary file displayed to the console
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling raw data can be cumbersome. For this reason, .NET provides stream
    adapters that allow us to handle higher-level data. The first pair of adapters
    is `BinaryReader` and `BinaryWriter`, which provide support for reading and writing
    primitive types and strings in binary format. An example of using these two is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We first open a file with `File.Create()` that returns `FileStream`. This stream
    is used as an argument for the constructor of the `BinaryWriter` stream adapter.
    The `Write()` method is overloaded for all the primitive types (`char`, `bool`,
    `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`,
    and `decimal`), as well as for `byte[]`, `char[]`, and `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we reopen the same file, but for reading using `File.OpenRead()`.
    The `FileStream` object returned by this method is used as an argument to the
    constructor of the `BinaryReader` stream adapter. This class has a set of reading
    methods, one for each primitive type, such as `ReadBoolean()`, `ReadChar()`, `ReadInt16()`,
    `ReadInt32()`, `ReadDouble()`, and `ReadDecimal()`, as well as methods for reading
    a `byte[]` – `ReadBytes()`, a `char[]` - `ReadChars()`, and strings—R`eadString()`.
    You can see some of these methods used in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: By default, both `BinaryReader` and `BinaryWriter` handle strings using the
    *UTF-8 encoding*. However, they both have overloaded constructors that allow us
    to specify another encoding using the `System.Text.Encoding` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these two adapters can be used for processing strings, using them
    for reading and writing text files can be cumbersome because of a lack of support
    for features such as line handling. To handle text files, the `StreamReader` and
    `StreamWriter` adapters should be used. By default, they process text as UTF-8
    encoded, but their constructors allow us to specify a different encoding. In the
    following example, we write text to a file and then read it back and print it
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `File.CreateText()` method opens a file for writing (either creating or
    overwriting it) and returns an instance of the `StreamWriter` class that uses
    UTF-8 encoding. The `WriteLine()` method writes a string to the file and then
    adds a new line. There are overloaded versions of `WriteLine()` but also overloaded
    `Write()` methods that can write a `char`, `char[]`, or `string` without adding
    a new line after.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we use the `File.OpenText()` method to open the previously
    written text file for reading. This returns a `StreamReader` object that reads
    UTF-8 text. The `ReadLine()` method is used to read the content line by line in
    a loop until the end of the stream. The `EndOfStream` property is used to check
    whether the current stream position reached the end of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `File.OpenText()` method, we could use `File.Open()`,
    which allows us to specify the opening mode, file access, and sharing. We could
    rewrite the reading part shown earlier as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we need a stream to handle temporary data. Using files can be cumbersome
    and also adds unnecessary overhead to the I/O operations. For this purpose, memory
    streams are the most suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Working with memory streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **memory stream** is a backing store for local memory. Such a stream is useful
    for operations when we need temporary storage for transforming data. Examples
    can include XML serialization or data compression and decompression. We will look
    at these two operations in the upcoming code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `Serializer<T>` class shown in the following code contains two methods—`Serialize()`
    and `Deserialize()`. The former takes a `T` object, uses `XmlSerializer` to generate
    an XML representation of it, and returns the XML data as a string. The latter
    takes a string containing XML data and uses `XmlSerializer` to read it and create
    a new object of type `T` from it. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The memory stream created in the `Serialize()` method is resizable. It is initially
    empty and grows as needed. However, the one created in the `Deserialize()` method
    is non-resizable because it is initialized from an array of bytes. This stream
    is used for read-only purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `MemoryStream` class implements the `IDisposable` interface because it derives
    from `Stream`, which implements `IDisposable`. However, `MemoryStream` has no
    resources to dispose of and, therefore, the `Dispose()` method does nothing. Calling
    it explicitly has no effect on the stream. Therefore, it is not necessary to wrap
    a memory stream variable in a `using` statement, as we did in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following implementation of an `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can serialize and deserialize instances of this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of executing this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – An XML-serialized Employee object displayed to the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – An XML-serialized Employee object displayed to the console
  prefs: []
  type: TYPE_NORMAL
- en: 'The other example we mentioned when a memory stream is handy is in the *compression
    and decompression of data*. The `GZipStream` class from the `System.IO.Compression`
    namespace is a stream decorator that supports compression and decompression of
    streams using the GZip data format specification. A `MemoryStream` object is used
    as a backing store for the `GZipStream` decorator. The static `Compression` class
    shown here provides two methods that compress and decompress an array of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this helper class to compress a string to an array of bytes and
    then decompress it back to a string. Such an example is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from executing this sample code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – A screenshot with the result of compressing and decompressing
    a text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – A screenshot with the result of compressing and decompressing
    a text
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how to simply serialize and deserialize XML. We
    will elaborate on this topic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen how we can use the `XmlSerializer` class,
    from the `System.Xml.Serialization` namespace, to serialize and deserialize data.
    This class is handy for serializing objects to XML and deserializing XML to objects.
    Although, in the previous example, we used a memory stream to serialize, it actually
    works with any stream; moreover, it also works with the `TextWriter` and `XmlWriter`
    adapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample shows a modified `Serializer<T>` class, where we specify
    the path of a file where the XML document is to be written to or read from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this new implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of XML serialization using this code is a document with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`XmlSerializer` works by serializing all the public properties and fields of
    a type to XML. It uses some default settings such as types becoming nodes and
    properties and fields becoming elements. The name of a type, property, or field
    becomes the name of the node or element and the value of a field or property its
    text. It also adds default namespaces (which you can see in the preceding code).
    However, it is possible to control the way serialization is performed using attributes
    on types and members. Such an example is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Serializing an instance of this `Employee` class implementation would produce
    an XML document such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used several attributes here, `XmlType`, `XmlAttribute`, and `XmlElement`,
    but the list is long. The following table lists the most important XML attributes
    and what they do. These attributes are available in the `System.Xml.Serialization`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The way the `XmlSerializer` class works is that, at runtime, it generates serialization
    code for each type in a temporary serialization assembly every time the application
    runs. In some cases, this can be a performance issue that can be avoided by generating
    these assemblies in advance. The `Sgen.exe`) can be used to generate these assemblies.
    If your assembly that contains serialization code is called `MyAssembly.dll`,
    the generated serializing assembly will be called `MyAssembly.XmlSerializer.dll`.
    This tool is deployed as part of the Windows SDK.
  prefs: []
  type: TYPE_NORMAL
- en: You can also generate an XML schema (an XSD document) from classes or classes
    from an existing XML schema using the `xsd.exe`). This tool is distributed as
    part of the Windows SDK or with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible issue with `XmlSerializer` is that it serializes a single .NET object
    to an XML document (of course, the object can be complex and contain other objects
    and arrays of objects). If you have two separate objects that you want to write
    to the same document, it does not work properly. Let''s imagine that we also have
    the following class, representing a department in a company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We might want to write an XML document containing an employee and a department.
    Using `XmlSerializer` will not work properly. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We could try to use the following code for serializing an employee and a department
    to the same XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML document that is generated to the disk file will have the content shown
    in the following code. This is not valid XML because it has multiple document
    declarations and does not have a single root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work, we''d have to create an additional type that would contain
    an employee and a department, and we would have to serialize an instance of this
    type. This extra object will be serialized as the root element of the XML document.
    We will demonstrate this with the following example (notice that we have an extra
    property called `Version` here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output is a well-formed XML document that is listed in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To allow further control for reading and writing XML, the .NET base class library
    contains two classes called `XmlReader` and `XmlWriter` that provide a fast, non-cached,
    forward-only way to read or generate XML data from or to a stream or file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `XmlWriter` class can be used to write XML data to a stream, file, text
    reader, or string. It provides features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating characters and XML names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that an XML document is well-formed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for CLR types so that you don't need to manually convert everything
    to a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 and BaseHex encoding for binary data to be written in the XML document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `XmlWriter` class contains many methods; some of these methods are listed
    in the following table. Although this list only includes the synchronous method,
    all of them have asynchronous companions such as `WriteElementStringAsync()` for
    `WriteElementString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While using `XmlWriter`, it is possible to specify various settings such as
    encoding, indentation, how attributes should be written (on a new or the same
    line), omitting the XML declaration, and others. These settings are controlled
    using an instance of the `XmlWriterSettings` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows an example of using `XmlWriter` to create an XML
    document that contains an employee and a department as a part of a root element
    called `Data`. In fact, the result is the same as from the previous example, except
    that no namespaces are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have used the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `XmlWriterSettings` to set encoding to UTF-8 and enable indentation
    of the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlWriter.Create()` to create an instance of an implementation of the `XmlWriter`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various methods of the `XmlWriter` class to write XML data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of `XmlSerializerNamespaces` to control the generated namespaces.
    In this example, we added an empty scheme and namespace, which results in no namespaces
    written to the XML document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances of the `XmlSerializer` class to simplify the serialization of the
    `Employee` and `Department` objects to the XML document. This is possible because
    the `Serialize()` method can take an `XmlWriter` as a destination for the XML
    document it generates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The companion class for `XmlWriter` is `XmlReader`. This class allows us to
    move through XML data and read its content but in a forward-only manner, which
    means you cannot go back from a given point. The `XmlReader` class is an abstract
    one, just like `XmlWriter`, and there are concrete implementations such as `XmlTextReader`,
    `XmlNodeReader`, or `XmlValidatingReader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for most scenarios, you should use `XmlReader`n. To create an instance
    of it, use the static `XmlReader.Create()` method. The class contains a long list
    of methods and properties, a few of them listed in the following table. Just like
    in the case of `XmlWriter`, `XmlReader` has both synchronous and asynchronous
    methods. Only some from the first category are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_14_01.jpg)![](img/Chapter_13_Table_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When creating an instance of `XmlReader`, you can specify a set of features
    that you want to enable, such as schemas that should be used to perform validation,
    ignoring comments or white spaces, validation of type assignment, and others.
    The `XmlReaderSettings` class is used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use `XmlReader` to read the content of the XML
    document written earlier and display a representation of its content to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of executing this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – A screenshot with the content of the XML document read from
    disk and displayed on the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – A screenshot with the content of the XML document read from disk
    and displayed on the console
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several key points from this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an instance of `XmlReaderSettings` to tell `XmlReader` to ignore
    comments and white spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used `XmlReader.Create()` to create a new instance of an implementation of
    `XmlReader` that reads XML data from a file with the specified path..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Read()` method is used in a loop to read the XML document node by node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use properties such as `NodeType`, `Name`, and `Value` to check the type
    of each node, its name, and its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many details concerning handling XML data with `XmlReader` and `XmlWriter`,
    as well as serialization using `XmlSerializer`. Discussing all these here would
    take too much time. We recommend that you use additional resources, such as the
    official documentation, to learn more about these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to handle XML data, let's look at JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, **JavaScript Object Notation (JSON)** has become the de facto
    standard for data serialization, not only for web and mobile but also for desktop.
    .NET did not provide a proper library for serializing and deserializing JSON;
    therefore, developers have resorted to third-party libraries. One of these libraries
    is **Json.NET** (also known as **Newtonsoft.Json**, after its creator, Newton-King).
    This has become the preferred library for most .NET developers and a dependency
    of ASP.NET Core. However, with the release of .NET Core 3.0, Microsoft is providing
    its own JSON serializer, known as **System.Text.Json**, after the namespace where
    it is available. In this last part of this chapter, we will look at these two
    libraries and see some of their capabilities and how they compare to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Using Json.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Json.NET is currently the most widely used .NET library for JSON serialization
    and deserialization. It''s a high-performance, easy-to-use, open source library,
    available as a NuGet package called **Newtonsoft.Json**. This is, in fact, by
    far, the most downloaded package on NuGet. Some of the features it provides are
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple APIs for most common serialization and deserialization scenarios with
    `JsonConvert`, which is a wrapper over `JsonSerializer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More fine-grained control over the serialization/deserialization process with
    `JsonSerializer`. This class can write text to or read text from a stream, directly
    via `JsonTextWriter` and `JsonTextReader`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to create, modify, parse, and query JSON using `JObject`, `JArray`,
    and `JValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to convert between XML and JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to query JSON with JSON Path, an XPath-like query language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation of JSON with JSON Schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for `BsonReader` and `BsonWriter`. This is a binary-encoded serialization
    of JSON-like documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will explore several common serialization and deserialization
    scenarios using Json.NET. For this purpose, we will use the following implementation
    of an `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Although the library is rich in functionalities, covering them all here is beyond
    the scope of this book. We recommend reading the online documentation for Json.NET
    that'[s available at https://www.newt](https://www.newtonsoft.com/json)onsoft.com/json.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting a string that contains the JSON serialization of an `Employee` object
    is straightforward, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `JsonConvert.SerializeObject()` will produce minified JSON, which
    does not contain indentation and white spaces. The result of the preceding code
    is the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is suitable for transferring data over a network, such as when
    communicating with a web service, because the size is smaller, it''s harder to
    read by a human. If you want the JSON document to be readable, you should use
    indentation. This can be specified by providing formatting options, available
    with the `Formatting` enumeration. An example of this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Indentation is not the only serialization option we can specify. In fact, there
    are many options you can set using the `JsonSerializerSettings` class, which can
    be provided as an argument to the `SerializeObject()` method. For instance, we
    might want to skip serializing properties or fields of reference, or nullable
    types that are set to `null`. Examples include `HireDate` and `Telephones`, which
    are of the `DateTime?` and `List<string>` types, respectively. This can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of serializing the `employee` object we used in the previous examples
    is shown in the following listing. You will notice that `HireDate` and `Telephones`
    are no longer present in the resulting JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option that can be specified for serialization controls how default
    values are handled. `DefaultValueHandling` is an enumeration that specifies how
    members with default values should be serialized or deserialized. By specifying
    `Ignore`, you enable the serializer to skip from the output the members whose
    value is the same as their type''s default value (`0` for numeric types, `false`
    for `bool`, and `null` for reference and nullable types). The default value that
    is ignored can actually be changed with the use of an attribute, called `DefaultValueAttribute`,
    being specified on the member. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the resulting JSON is even simpler, as shown in the following listing.
    This is because the `IsOnLeave` and `Status` properties are set to their default
    value, which is `false` and `EmployeeStatus.Active`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned earlier the attribute called `DefaultValueAttribute`. You may
    have noticed a couple of other attributes, `JsonIgnoreAttribute` and `JsonConverterAttribute`,
    being used in the declaration of the `Employee` class. The serialization can be
    controlled with attributes, and the library supports both standard .NET serialization
    attributes (such as `SerializableAttribute`, `DataContractAttribute`, `DataMemberAttribute`,
    and `NonSerializedAttributes`) and built-in Json.NET attributes. When both are
    present, the built-in Json.NET attributes take precedence over the others. The
    built-in Json.NET attributes are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of these attributes, we have used `JsonIgnoreAttribute` to indicate that the
    `LastModified` property of the `Employee` class should not be serialized and `JsonConverterAttribute`
    to indicate that the `Status` property should be serialized using the `StringEnumConverter`
    class. The result is that this property will be serialized as a string (with the
    values `Active` or `Inactive`) and not as a number (with the values `0` or `1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JsonConvert.SerializeObject()` method returns a string. It is possible
    to serialize and deserialize using streams, such as a file or a memory stream.
    To do so, however, we must use the `JsonSerializer` class. This class has overloaded
    methods called `Serialize()` and `Deserialize()`, as well as a series of properties
    that allow us to customize the serialization. The following example shows how
    we can use the class to serialize the employee object we used so far to a text
    file on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We specified that we want to use indentation and skip the members that are
    `null` or have a value that is the type''s default value. The result of serialization
    is a text file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite process of deserialization is also straightforward. Using `JsonSerializer`,
    we can read from the text file we created earlier. For this purpose, we use `JsonTextReader`,
    which is a companion class for `JsonTextWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Deserialization from a string is also possible and straightforward using the
    `JsonConvert` class. The overloaded `DeserializeObject()` method is used for this
    purpose, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Although widely used, the Json.NET library has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The .NET `string` type uses UTF-16 encoding, yet most network protocols, including
    HTTP, use UTF-8\. Json.NET converts between these two, which affects performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a third-party library, and not a component of the Base Class Library (or
    the Foundation Class Library), you may have projects with dependencies on different
    versions. ASP.NET Core used Json.NET as a dependency, which sometimes leads to
    version conflicts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not leverage new .NET types such as `Span<T>`, which are designed to
    increase performance in some scenarios, such as when parsing text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To overcome these issues, Microsoft has provided its own implementation of a
    JSON serializer, which we will look at in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using System.Text.Json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the new JSON serializer shipped with .NET Core. It replaces Json.NET
    in ASP.NET Core, for which an integration package is now available. If you are
    targeting .NET Framework or .NET Standard, you can still use **System.Text.Json**,
    which is available as a NuGet package, also called **System.Text.Json**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new serializer performs better than Json.NET mainly for two reasons: it
    uses `Span<T>` and UTF-8 natively (therefore avoiding transcoding between UTF-8
    and UTF-16). According to Microsoft, this serializer offers speed-ups of 1.3x
    to 5x over Json.NET, depending on the scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the APIs were inspired by Json.NET and the transition from Json.NET
    is seamless for simple scenarios, like the ones we saw in the previous section
    of this chapter. The following example shows how we can serialize an `Employee`
    object into a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks very similar to Json.NET and it also produces minified JSON, which
    you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, serialization can be customized by providing various options, such
    as indentation, handling of null values, naming policy, trailing commas, ignoring
    read-only properties, and others. Such options are provided with the `JsonSerializerOptions`
    class. An example with indentation and skipping null values is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `Employee` class used in these examples is almost
    identical to the one from the previous section. Let''s take a look at the following
    code and try to spot the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We again used the `JsonIgnoreAttribute` and `JsonConverterAttribute` attributes
    to specify that the `LastModified` property should be skipped and that the `Status`
    property should be serialized as a string and not a number. The only difference
    is the type of converter that we used here, which is called `JsonStringEnumConverter`
    (while with Json.NET it was called `StringEnumConverter`). However, these are
    not the `System.Text.Json.Serialization` namespace. These attributes are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_13_Table_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From this table, we can see that the **System.Text.Json** serializer does not
    support serializing and deserializing fields, which is something Json.NET does.
    If this is something that you need, you must either change the field to a property,
    provide a property for the field, or resort to a serializer that supports fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more control over what is written or read, you can use the `Utf8JsonWriter`
    and `Utf8JsonReader` classes. These provide high-performance APIs for forward-only,
    no-cached, writing, or read-only reading of UTF-8 encoded JSON text. In the following
    example, we will use `Utf8JsonWriter` to write a JSON document to a file on disk
    containing an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of executing this code is a text file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the JSON document generated here, we can use `Utf8JsonReader`. However,
    this reader does not work with streams but with views of raw data in the form
    of `ReadOnlySpan<byte>` or `ReadOnlySequence<byte>`. This reader allows us to
    read the data token by token and process it accordingly. An example is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of executing this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The **System.Text.Json** serializer is more complex than what the examples here
    may show. We recommend that you read the online documentation to better familiarize
    yourself with its APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Json.NET** and **System.Text.Json** are not the only JSON serializers for
    .NET, nor the most performant. If JSON performance is key for your application,
    you might want to use either **Utf8Json** (available [at https://github.com/neuecc/Utf8](https://github.com/neuecc/Utf8Json)Json)
    or **Jil** (available [at https://github.com/kevin-montrose](https://github.com/kevin-montrose/Jil)/Jil),
    which outperform both serializers that we looked at in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with an overview of the `System.IO` namespace and looked
    at the capabilities it provides for working with the filesystem. We then learned
    about handling paths and filesystem objects. We saw how we can create, edit, move,
    delete, or enumerate files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how to read and write data from and to disk files with the
    help of streams. We looked at different kinds of streams and learned about writing
    and reading to and from file and memory streams using different stream adapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we looked at data serialization and learned
    how to serialize and deserialize XML and JSON. For the latter, we explored the
    Json.NET serializer, which is the most popular .NET library for JSON, and `System.Text.Json`,
    the new .NET library for JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will address a different topic called error handling.
    You will learn about error codes and exceptions and what best practices for handling
    errors are.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the most important classes in the `System.IO` namespace for working
    with filesystem objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the recommended method for concatenating paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you retrieve the path for the temporary folder of the current user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `File` and `FileInfo` classes? What about
    the difference between `Directory` and `DirectoryInfo`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What methods can you use to create directories? What about enumerating directories?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three categories of streams in .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base class for the stream classes in .NET and what functionalities
    does it provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What encoding do `BinaryReader` and `BinaryWriter` assume by default for strings?
    How can this be changed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you serialize objects of the `T` type to XML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the JSON serializer shipped with .NET Core and how do you use it to
    serialize objects of a `T` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
