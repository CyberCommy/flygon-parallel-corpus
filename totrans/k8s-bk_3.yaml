- en: '3: Installing Kubernetes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll take a look at a few different ways to install Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Things have changed a lot since I wrote the first edition of the book in July
    2017\. Back then, installing Kubernetes was hard. These days it’s a lot easier!
    In fact, we’re approaching the point where we can just *ask for a Kubernetes cluster,
    and get one* . This is especially true with *hosted Kubernetes services* like
    Azure Kubernetes Service (AKS) and Google Kubernetes Engine (GKE).
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of *hosted Kubernetes services* , more and more people are choosing
    to use hosted Kubernetes services, and with things like *GKE On-Prem (https://cloud.google.com/gke-on-prem/)*
    , it’s looking increasingly likely that a large number of Kubernetes clusters
    will be built and managed via the major cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of this in mind, ask yourself the following question before building
    your own Kubernetes cluster: *Is building and managing your own Kubernetes cluster
    the best use of your time and effort?* If the answer isn’t a resounding **“Yes!”**
    , I strongly suggest you consider a hosted service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we’ll look at the following installation types:'
  prefs: []
  type: TYPE_NORMAL
- en: Play with Kubernetes (PWK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Desktop: local development cluster on your laptop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minikube: local development cluster on your laptop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Kubernetes Engine (GKE): production-grade hosted cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kops: Install your own cluster on AWS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubeadm: Manual installation with kubeadm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of quick things to point out before diving in…
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, there are a lot of other ways to install Kubernetes. The ones we’re
    covering here are the ones I think will be most helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a *hosted Kubernetes service* is one where the control plane (masters)
    is managed by the platform. For example, AKS, EKS, and GKE are all hosted Kubernetes
    services where the management of the control plane is taken care of by the platform
    (you aren’t responsible). 2018 saw a huge increase in use of hosted Kubernetes
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Time to look at some installs.
  prefs: []
  type: TYPE_NORMAL
- en: Play with Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Play with Kubernetes (PWK) is free, and is a great way to get your hands on
    a Kubernetes cluster without having to install any software on your own kit. All
    you need is a computer, an internet connection, and an account on Docker Hub or
    GitHub. In my opinion, it’s the fastest and easiest way to get your hands on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: However, it has limitations. For starters, it’s a time-limited playground -
    you get a lab that lasts for 4 hours. It also lacks some integrations with external
    services such as cloud-based load-balancers. However, limitations aside, it’s
    a great tool and I use it all the time!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Point your browser at http://play-with-k8s.com
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login with your GitHub or Docker Hub account and click `Start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `+ ADD NEW INSTANCE` from the navigation pane on the left of your browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be presented with a terminal window in the right of your browser. This
    is a Kubernetes node (`node1` ).
  prefs: []
  type: TYPE_NORMAL
- en: Run a few commands to see some of the components pre-installed on the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As the output shows, the node already has Docker and `kubectl` (the Kubernetes
    client) pre-installed. Other tools including `kubeadm` are also pre-installed.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that although the command prompt is a `$` , we’re actually
    running as `root` . We can confirm this by running `whoami` or `id` .
  prefs: []
  type: TYPE_NORMAL
- en: Use the `kubeadm` command to initialize a new cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you added a new instance in step 3, PWK gave you a short list of commands
    to initialize a new Kubernetes cluster. One of these was `kubeadm init...` . The
    following command will initialize a new cluster and configure the API server to
    listen on the correct IP interface.
  prefs: []
  type: TYPE_NORMAL
- en: You may be able to specify the version of Kubernetes to install by adding the
    `--kubernetes-version` flag to the command. The latest versions can be seen at
    https://github.com/kubernetes/kubernetes/releases. Not all versions work with
    PWK.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have a brand new single-node Kubernetes cluster! The node
    that we executed the command from (`node1` ) is initialized as the *master* .
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `kubeadm init` gives you a short list of commands it wants
    you to run. These will copy the Kubernetes config file and set permissions. You
    can ignore these, as PWK has already configured them for you. Feel free to poke
    around inside of `$HOME/.kube` .
  prefs: []
  type: TYPE_NORMAL
- en: Verify the cluster with the following `kubectl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output shows a single-node Kubernetes cluster. However, the status of the
    node is `NotReady` . This is because we haven’t configured the *Pod network* yet.
    When you first logged on to the PWK node, you were given a list of three commands
    to configure the cluster. So far, we’ve only executed the first one (`kubeadm
    init...` ).
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the Pod network (cluster networking).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the second command from the list of three commands that were printed on
    the screen when you first created `node1` (this will be a `kubectl apply` command).
    Paste it onto a new line in the terminal. In the book, the command may wrap over
    multiple lines and insert backslashes (`\` ). You should remove any backslashes
    that occur at the right-edge of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Verify the cluster again to see if `node1` has changed to `Ready` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that the *Pod network* has been initialized and the control plane is `Ready`
    , you’re ready to add some worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `kubeadm join` command from the output of the `kubeadm init` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you initialized the new cluster with `kubeadm init` , the final output
    of the command listed a `kubeadm join` command to use when adding nodes. This
    command includes the cluster join-token, the IP socket that the API server is
    listening on, and other bits required to join a new node to the cluster. Copy
    this command and be ready to paste it into the terminal of a new node (`node2`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Click the `+ ADD NEW INSTANCE` button in the left pane of the PWK window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be given a new node called `node2` .
  prefs: []
  type: TYPE_NORMAL
- en: Paste the `kubeadm join` command into the terminal of `node2` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The join-token and IP address will be different in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Switch back to `node1` and run another `kubectl get nodes`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Your Kubernetes cluster now has two nodes - one master and one worker node.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add more nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have a fully working Kubernetes cluster that you can use
    as a test lab.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth pointing out that `node1` was initialized as the Kubernetes *master*
    , and additional nodes will join the cluster as *nodes* . PWK usually puts a blue
    icon next to *masters* and a transparent one next to *nodes* . This helps you
    identify which is which.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, PWK sessions only last for 4 hours and are obviously not intended for
    production use.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In my opinion, *Docker Desktop* is the best way to get a local development cluster
    on your Mac or Windows laptop. With a few easy steps, you get a single-node Kubernetes
    cluster that you can develop and test with. I use it nearly every day.
  prefs: []
  type: TYPE_NORMAL
- en: It works by creating a virtual machine (VM) on your laptop and starting a single-node
    Kubernetes cluster inside that VM. It also configures your `kubectl` client to
    be able to talk to the cluster. Finally, you get a simple GUI that allows you
    to perform basic operations such as switching between all of your `kubectl` contexts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** A kubectl context is a bunch of settings that the `kubectl` command
    uses so that it knows which cluster to issue commands to.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Point your web browser to `www.docker.com` and choose `Products` > `Docker Desktop`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the download button for either Mac or Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may need to login to the Docker Store. Accounts are free, and so is the
    product.
  prefs: []
  type: TYPE_NORMAL
- en: Open the installer and follow the simple installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installer is complete you’ll get a whale icon on the Windows task bar,
    or the menu bar on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Click the whale icon (you may need to right-click it), go to `Settings` and
    enable Kubernetes from the `Kubernetes` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can open a terminal window and see your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you now have a local development cluster!
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Minikube is another option if you’re a developer and need a local Kubernetes
    development environment on your laptop. Like *Docker Desktop* , you get a local
    VM running a single-node Kubernetes cluster for development. It’s not for production!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** I’ve had mixed results with Minikube. It’s great when it works, but
    sometimes it’s hard to get working. For this reason, I prefer Docker Desktop for
    Mac and Windows.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can get Minikube for Mac, Windows, and Linux. We’ll take a quick look at
    Mac and Windows, as this is what most people run on their laptops.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Minikube requires virtualization extensions enabled in your system’s
    BIOS.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Installing Minikube on Mac
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s probably a good idea to install `kubectl` (the Kubernetes client) before
    you install Minikube. You’ll use this later to issue commands to the Minikube
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Use Brew to install `kubectl`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This puts the kubectl binary in `/usr/local/bin` and makes it executable.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the install worked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve installed the `kubectl` client, let’s install Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Use Brew to install Minikube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Provide your password if prompted.
  prefs: []
  type: TYPE_NORMAL
- en: Use Brew to install the **hyperkit** lightweight hypervisor for Mac.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other Hypervisor options are available - VirtualBox and VMware Fusion - but
    we’re only showing hyperkit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Start Minikube with the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube start` is the simplest way to start Minikube. Specifying the `--vm-driver=hyperkit`
    flag will force it to use the **hyperkit** hypervisor instead of VirtualBox.'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a Minikube instance up and running on your Mac!
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube on Windows 10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section we’ll show you how to use Minikube on Windows using Hyper-V
    as the virtual machine manager. Other options exist, but we’re not showing them
    here. We’ll also be using a PowerShell terminal opened with Administrative privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before installing Minikube, let’s install the `kubectl` client. There are a
    couple of ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Chocolaty package manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading via your web browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Chocolaty, you can install it with the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you are not using Chocolaty, you can install `kubectl` using your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Point your web browser to https://kubernetes.io/docs/tasks/tools/install-kubectl/
    and click the `Install kubectl binary using curl` option. Click the `Windows`
    tab. Copy and paste the URL into your web browser - this will download the `kubectl`
    binary. Be sure that you just copy and paste the URL and not the full `curl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once the download is complete, copy the `kubectl.exe` file to a folder in your
    system’s `%PATH%` .
  prefs: []
  type: TYPE_NORMAL
- en: Verify the installation with a `kubectl version` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have `kubectl` , you can proceed to install Minikube for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser to the Minikube Releases page on GitHub
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: https://github.com/kubernetes/minikube/releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click `minikube-installer.exe` from beneath the latest version of Minikube.
    This will download the 64-bit Windows installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the installer and click through the wizard accepting the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure Hyper-V has an external vSwitch .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Hyper-V Manager (`virtmgmt.msc` ) and go to `Virtual Switch Manager...`
    . If there is no Virtual Switch configured with the following two options, create
    a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Connection type = External network`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Allow management operating system to share this network adapter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the remainder of this section we’ll assume that you have Hyper-V configured
    with an external vSwitch called `external` . If yours has a different name, you
    will need to substitute the name of yours in the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Minikube version with the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use the following command to start a local Minikube instance running Kubernetes
    version 1.12.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command assumes a Hyper-V vSwitch called `external` and uses backticks “`”
    to allow the command to span multiple lines for readability.
  prefs: []
  type: TYPE_NORMAL
- en: It can take a while to download and start the cluster the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Verify the installation by checking the version of the Kubernetes master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the target machine actively refuses the network connection with an `Unable
    to connect to the server: dial tcp...` error, this is most likely a network-related
    error. Make sure that your vSwitch is configured correctly, and that you specified
    it correctly with the `--hyperv-virtual-switch` flag. `kubectl` talks to Kubernetes
    inside the `minikube` Hyper-V VM over port 8443.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve got a fully working Minikube cluster up and running
    on your Windows 10 PC.
  prefs: []
  type: TYPE_NORMAL
- en: You can now type `minikube` on the command line to see a full list of minikube
    sub-commands. A good one to try might be `minikube ip` which will give you the
    IP address that the Minikube cluster is operating on.
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl` to verify the Minikube install
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `minikube start` operation configures a *kubectl context* so that you can
    use `kubectl` against your new Minikube environment. Test this by running the
    following `kubectl` command from the same shell that you ran `minikube start`
    from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Great, your kubectl context is set to Minikube. This means `kubectl` commands
    will be sent to the Minikube cluster.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth pointing out that `kubectl` can be configured to talk to any Kubernetes
    cluster by setting different contexts - you just need to switch between contexts
    to send commands to different clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `kubectl get nodes` command to list the nodes in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s a single-node Minikube cluster ready to use!
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `minikube ip` command to get the IP address of your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Minikube cluster
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We spun up the Minikube cluster with a single `minikube start` command. We can
    stop it with a `minikube stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Stopping a Minikube keeps all the config on disk. This makes it easy to start
    it up again and pick things up from where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: To blow it away completely - leaving no trace - use the `minikube delete` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Running a particular version of Kubernetes inside of Minikube
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Minikube lets you use the `--kubernetes-version` flag specify the version of
    Kubernetes you want to run. This is useful if you need to match the version of
    Kubernetes used in your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The following command will start a Minikube cluster running Kubernetes version
    1.10.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run another `kubectl get nodes` command to verify the version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Bingo!
  prefs: []
  type: TYPE_NORMAL
- en: That’s Minikube! A great way to spin up a simple Kubernetes cluster on your
    Mac or PC. But it’s not for production!
  prefs: []
  type: TYPE_NORMAL
- en: Google Kubernetes Engine (GKE)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Google Kubernetes Engine is a *hosted Kubernetes* service that runs on the
    Google Cloud (GCP). Like most *hosted Kubernetes* services, it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: A fast and easy way to get a production-grade Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A managed control plane (you do not manage the *masters* )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Itemized billing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning:** GKE and other hosted Kubernetes services are not free. Some services
    might provide a *free tier* or an initial amount of *free credit* . However, generally
    speaking, you have to pay to use them.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Configuring GKE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To work with GKE you’ll need an account on the Google Cloud with billing configured
    and a blank project. These are all simple to setup, so we won’t spend time explaining
    them here - for the remainder of this section we’ll be assuming you have these.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will walk you through configuring GKE via a web browser.
    Some of the details might change in the future, but the overall flow will be the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: From within the Console of your Google Cloud Platform (GCP) project, open the
    navigation pane on the left-hand side and select `Kubernetes Engine` > `Clusters`
    . You may have to click the three horizontals bars at the top-left of the Console
    to make the navigation pane visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Create cluster` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will start the wizard to create a new Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard currently offers a few templated options. This may change in the
    future, but the overall flow will be the same. Choose a template (`Your first
    cluster` or `Standard cluster` will probably be good options to choose from).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the cluster a meaningful name and description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose whether you want a `Regional` or `Zonal` cluster. Regional is newer and
    potentially more resilient - your masters and nodes will be distributed across
    multiple zones but still accessible via a single highly-available endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the Region or Zone for your cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Cluster Version` . This is the version of Kubernetes that will run
    on your master and nodes. You are limited to the versions available in the drop-down
    list. Choose an up-to-date version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can select the number and size of your worker nodes under the `Node pools`
    section. This allows you to chose the size and configuration of your worker nodes,
    as well as how many. Larger and faster nodes incur higher costs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are building a Regional cluster, the number you specify will be the number
    of nodes **in each zone** , not the total number.
  prefs: []
  type: TYPE_NORMAL
- en: Leave all other options with default values and click `Create` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also click the `More` link to see a long list of other options you can
    customize. It’s worth taking a look at these, but we won’t be discussing them
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Your cluster will now be created!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GKE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a cluster, it’s time to have a quick look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you’re logged on to the GCP Console and are viewing `Clusters` under
    `Kubernetes Engine` .
  prefs: []
  type: TYPE_NORMAL
- en: The clusters page shows a high-level overview of the Kubernetes clusters you
    have in your project. Figure 3.1 shows a single 3-node cluster called `gke1` .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1](Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1
  prefs: []
  type: TYPE_NORMAL
- en: Click the cluster name to drill in to more detail. Figure 3.2 shows a screenshot
    of some of the detail you can view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2](Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the `> CONNECT` icon towards the top of the web UI (not shown in Figure
    3.2) gives you a command you can run on your laptop to configure your local `gcloud`
    and `kubectl` tools to talk to your cluster. Copy this command to your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: For the following step to work, you will need to download and install the Google
    Cloud SDK from `https://cloud.google.com/sdk/` . This will download several utilities,
    including the `gcloud` and `kubectl` command-line utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and paste the long `gcloud` command into it. This will configure
    your `kubectl` client to talk to your new GKE cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Run a `kubectl get nodes` command to list the nodes in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You know how to create a production-grade Kubernetes cluster
    using Google Kubernetes Engine (GKE). You also know how to inspect it and connect
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Be sure to delete your GKE cluster as soon as you are finished
    using it. GKE, and other hosted K8s platforms, may incur costs even when they
    are not in use.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Installing Kubernetes on AWS with `kops`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`kops` is short for Kubernetes Operations. It’s a *highly-opinionated* cluster
    bootstrapping tool that makes installing Kubernetes on supported platforms *relatively
    simple* .'
  prefs: []
  type: TYPE_NORMAL
- en: By *highly opinionated* , we mean it’s limited in how much you can customize
    the installation. If you need a highly-customized cluster you should look at `kubeadm`
    .
  prefs: []
  type: TYPE_NORMAL
- en: By *relatively simple* , we mean it’s easier than compiling the binaries yourself
    :-D There are still parts that can be complicated if you’re not already experienced
    in those areas. For example, `kops` is extremely opinionated when it comes to
    DNS configuration - if you get the DNS wrong you’ll be in a world of pain! Fortunately
    it supports gossip-based installations that don’t use DNS. This is intended for
    development use-cases where the additional hassle of configuring DNS isn’t needed.
  prefs: []
  type: TYPE_NORMAL
- en: Kops currently supports bootstrapping a cluster on AWS and GCE. Other platforms
    might be supported in the future.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the `kops` command-line tool is only available on Mac
    and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need all of the following to bootstrap a cluster with `kops` :'
  prefs: []
  type: TYPE_NORMAL
- en: An AWS account and a decent understanding of AWS fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest version of the `kops` binary for your OS (Mac or Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `awscli` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The credentials of an AWS account with the following permissions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEC2FullAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonRoute53FullAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonS3FullAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IAMFullAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonVPCFullAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following examples are from a Linux machine, but it works the same on a
    Mac (and possibly Windows in the future).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show both installation options:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gossip
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The gossip-based installation is the simplest, and is ideal for situations where
    private DNS domains are not available. It’s also ideal for AWS locations, such
    as China, where Route53 isn’t available.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS installation is more involved and requires a top-level-domain, as well
    as a sub-domain delegated to AWS Route53\. The DNS examples in this chapter use
    a domain called `tf1.com` that is hosted with a 3rd party provider such as GoDaddy.
    It has a subdomain called `k8s` that is delegated to Amazon Route53\. If you’re
    following along with the DNS examples you will need your own working domains.
  prefs: []
  type: TYPE_NORMAL
- en: Download and install `kubectl`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Mac, the download and installation is a simple `brew install kubernetes-cli`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The following procedure is for a Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following command to download the latest `kubectl` binary to your home
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The command is a single command, but is quite long and will wrap over multiple
    lines in the book. This process might introduce backslashes at the edge of the
    printed page that are not part of the command and will need to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Make the downloaded binary executable and move it to a directory in your `PATH`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run a `kubectl` command to make sure it’s installed and working.
  prefs: []
  type: TYPE_NORMAL
- en: Download and install `kops`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For Mac, you just need to run `brew install kops` .
  prefs: []
  type: TYPE_NORMAL
- en: Use the following procedure for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Download the `kops` binary with the following `curl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command should be issued on one line and have no backslashes `\` in it.
    It also has the version of the `kops` tool embedded in the URL, you can change
    this. See https://github.com/kubernetes/kops/releases for the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Make the downloaded binary executable and move it to a directory in your system’s
    `PATH` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Run a `kops version` command to verify the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Install and configure the AWS CLI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can install the AWS CLI tool on Mac OS using the `brew install awscli` .
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how to install the AWS CLI from the default app
    repos used by Ubuntu 18.04\. The installation method will obviously be different
    if you’re using a different Linux distro.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to install the AWS CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the `aws configure` command to configure your instance of the AWS CLI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need the credentials of an AWS IAM account with *AmazonEC2FullAccess*
    , *AmazonRoute53FullAccess* , *AmazonS3FullAccess* , *IAMFullAccess* , and *AmazonVPCFullAccess*
    to complete this step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create a new S3 bucket for kops to store configuration and state information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kops requires cluster names to be valid DNS names. We’ll use the name `cluster1.k8s.tf1.com`
    in these examples. You will have to use a different name in your environment.
    Let’s quickly break-down how it works. The example assumes I own a domain called
    `tf1.com` , and that I’ve delegated a sub-domain called `k8s` to AWS Route53\.
    Within that sub-domain I can create clusters with whatever names I like. In the
    example, we’ll create a cluster called `cluster1` . This will make the fully-qualified
    domain name for the cluster `cluster1.k8s.tf1.com` . I’ve created `NS` records
    in the parent `tf1.com` domain to point to the `k8s` hosted domain in Route53\.
    `tf1.com` is fictional and only being used in these examples to keep the command-line
    arguments short.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on creating a gossip-based cluster, you will need to use a cluster
    name that ends with `.k8s.local` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: List your S3 buckets and `grep` for the name of the bucket you created. This
    will prove that the bucket created successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tell **kops** where to find its config and state - this will be the S3 bucket
    created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Create a new cluster with one of the following `kops create cluster` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first command creates the cluster using gossip instead of DNS. To work with
    gossip the cluster name **must** end with `.k8s.local` .
  prefs: []
  type: TYPE_NORMAL
- en: The second command creates the cluster with DNS and assumes a working DNS configuration
    as previously explained.
  prefs: []
  type: TYPE_NORMAL
- en: You will need a copy of your AWS public key for the command to work. In the
    examples, the key is called `np-k8s.pub` and is in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The command is broken down as follows. `kops create cluster` tells **kops**
    to create a new cluster. `--cloud=aws` tells it to create the cluster in AWS using
    the AWS provider. `--zones=eu-west-1b` tells **kops** to create the cluster in
    the eu-west-1b zone. If creating the cluster with DNS, the `--dns-zone` flag tells
    it to use the delegated zone. We name the cluster with the `--name` flag - remember
    to end your cluster name with “.k8s.local” if creating with gossip. `--ssh-public-key`
    tells it which key to use. Finally, the `--yes` flag tells **kops** to go ahead
    and deploy the cluster. If you omit the `--yes` flag, a cluster config will be
    created but it will not be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: It may take a few minutes for the cluster to deploy. This is because **kops**
    is creating the AWS resources required to build the cluster. This includes things
    like a VPC, EC2 instances, launch configs, auto scaling groups, security groups
    etc. After it has built the AWS infrastructure, it also has to build the Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cluster is deployed you can validate it with the `kops validate cluster`
    command. It may take a while for the cluster to completely come up, so be patient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You now know how to create a Kubernetes cluster in AWS using
    the `kops` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your cluster is up and running you can issue `kubectl` commands against
    it. It might also be worth having a poke around in the AWS console to see some
    of the resources that `kops` created.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Be sure to delete your cluster when you’re finished using it.
    Clusters running on cloud platforms may incur costs even when they are not actively
    being used.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Deleting a Kubernetes cluster in AWS with `kops`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use the `kops delete cluster` command to delete the cluster you just
    created. This will also delete all of the AWS resources that were created to support
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The following command will delete the cluster created in the previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Installing Kubernetes with `kubeadm`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll see how to install Kubernetes using `kubeadm` .
  prefs: []
  type: TYPE_NORMAL
- en: One of the best things about `kubeadm` is that you can use it to install Kubernetes
    nearly anywhere - laptop, bare metal in your data center, even on public clouds.
    It also does a lot more than just install Kubernetes - you can upgrade, manage,
    and query your clusters too. It’s often said that `kubeadm` is `kubectl` for clusters
    - a great tool for building **and** managing Kubernetes clusters. Anyway, `kubeadm`
    is a core Kubernetes project and has a promising future.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section are based on Ubuntu 18.04\. Some of the commands
    in the pre-reqs section will be different if you’re using a different Linux distro.
    However, the procedure we’re showing can be used to install Kubernetes on your
    laptop, in your data center, or even in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be walking through a simple example using three Ubuntu 18.04 machines
    configured as one master and two nodes as shown in Figure 3.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3](Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level plan will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the pre-requisites
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a new cluster with **node1** as the master
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Pod network
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **node2** and **node3** as worker nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All three nodes will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeadm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker** is the container runtime. Other runtimes exist, but we’ll go with
    Docker. `kubeadm` is the tool we’ll use the build the cluster, **kubelet** is
    the Kubernetes node agent, and `kubectl` is the Kubernetes command-line utility.'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-requisites
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following commands are specific to Ubuntu 18.04 and need to be ran on **all
    three nodes** . They set things up so that we can install the right packages from
    the right repos. Equivalent commands and packages exist for other flavors of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following two commands to get the latest versions of a few packages
    that will be required in later steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Download and install the following two repository keys. One of the repositories
    has the Kubernetes tools and the other has Docker. We’ll need these keys in later
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create, or edit, the following file and add the repo required to install the
    Kubernetes packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Add the following line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to install `kubeadm` , `kubectl` , and the `kubelet` . Use
    the following two commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you run the `apt-get install` command again you can see the versions that
    were installed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s install Docker…
  prefs: []
  type: TYPE_NORMAL
- en: Add the required fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now add the *stable* Docker repository. This is a single command with backslashes
    used to spread it over multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Install Docker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That’s the pre-reqs done.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a new cluster
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Initializing a new Kubernetes cluster with `kubeadm` is as simple as typing
    `kubeadm init` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The command pulls all required images and builds the cluster. When the process
    is complete, it spits out a few short commands that enable you to manage the cluster
    as a regular user. It also gives you the `kubeadm join` command that will let
    you add additional nodes to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! That’s a brand-new single-master Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Complete the process by running the commands listed in the output of the `kubeadm
    init` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: These commands may be different, or even no longer required in the future. However,
    they copy the Kubernetes config file from `/etc/kubernetes` into your home directory,
    and change the ownership to you.
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl` to verify that the cluster initialized successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Run the following `kubectl` command to find the reason why the cluster `STATUS`
    is showing as `NotReady` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This command shows all Pods in all namespaces - this includes system Pods in
    the system (kube-system) namespace.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, none of the `coredns` Pods are running. This is preventing the
    cluster from entering the `Ready` state, and is happening because we haven’t created
    the Pod network yet.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Pod network. The following example creates a multi-host overlay network
    provided by Weaveworks. Other options exist, and you do not have to go with the
    example shown here.
  prefs: []
  type: TYPE_NORMAL
- en: The command may wrap over multiple lines in the book. Any backslashes (`\` )
    at the edge of the printed page should be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Check if the status of the master has changed from `NotReady` to `Ready` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Great, the cluster is ready and the DNS Pods will now be running.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the cluster is up and running, it’s time to add some nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding worker nodes requires the cluster’s join token. You might remember that
    this was provided as part of the output when the cluster was first initialized.
    Scroll back up to that output, copy the `kubeadm join` command to the clipboard
    and then run it on **node2** and **node3** .
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The following must be performed on **node2** and **node3** and you
    must have already installed the pre-reqs (Docker, kubeadm, kubectl, and the kubelet)
    on these nodes.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the command on **node3** .
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that both nodes successfully registered by running another `kubectl
    get nodes` on the master.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You’ve manually built a 3-node cluster using `kubeadm` . But
    remember that it’s running a single master without H/A.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to poke around the cluster with `kubeadm` . You should also investigate
    ways `kubeadm` can install clusters with H/A managers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned how to install Kubernetes in a few different ways
    on a few different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how fast and simple it is to setup a Kubernetes cluster on Play with
    Kubernetes (PWK). We got a 4-hour playground without having to install anything
    on our laptop or in our own cloud.
  prefs: []
  type: TYPE_NORMAL
- en: We setup Docker Desktop and Minikube for a great developer experience on our
    laptops.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to spin up a managed/hosted Kubernetes cluster in the Google
    Cloud using Google Kubernetes Engine (GKE).
  prefs: []
  type: TYPE_NORMAL
- en: Then we looked at how to use the `kops` tool to spin up a cluster in AWS using
    the AWS provider.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter seeing how to perform a manual install using the `kubeadm`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways and places we can install Kubernetes. But the chapter is
    already long enough and I’ve pulled out way too much of my hair already :-D
  prefs: []
  type: TYPE_NORMAL
