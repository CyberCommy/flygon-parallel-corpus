- en: '[*Chapter 7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092): Building and
    Deploying a Spring Boot Application with the Cloud Code Plugin'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about Skaffold-supported container image
    builders and deployers. In this chapter, we will introduce you to Google's Cloud
    Code plugin, which is available with IDEs such as IntelliJ. We will create a Spring
    Boot application and use the Cloud Code plugin to deploy it to a local Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Google's Cloud Code plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and working with the IntelliJ Cloud Code plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Spring Boot application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizing and deploying a Spring Boot application using Cloud Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the Cloud
    Code plugin and how you can use it to accelerate the development life cycle of
    a Kubernetes application using an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
    or the IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code from this book's GitHub repository can be found at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter07](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Google's Cloud Code plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are working to develop or maintain cloud-native applications in today''s
    age, then it is a sort of unspoken truth that you need a set of tools or a tool
    to ease your development process. As developers, we typically do the following
    tasks in the inner development loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Download specific dependencies such as Skaffold, `minikube`, and `kubectl` to
    set up the local development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do a lot of context switching to view logs, documentation, and browse the cloud
    vendor-provided console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Skaffold is an excellent solution to this problem, would it not be nice
    to have everything clubbed into your IDE? For example, we can add a plugin that
    can do all these tasks and focus on the coding part. For this, we can use the
    **Google Cloud Code** extension, since it simplifies the development of cloud-based
    applications with your favorite IDE, such as IntelliJ, Visual Studio Code, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand some of the features that Cloud Code offers:'
  prefs: []
  type: TYPE_NORMAL
- en: Write, debug, and deploy Kubernetes application faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple IDEs, including JetBrains IntelliJ, Visual Studio Code,
    and Cloud Shell Editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple startup templates for different languages with best practices to start
    your development in no time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy your application with a single click on Google Kubernetes Engine
    or Cloud Run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently works with other Google Cloud Platform services, including Google
    Kubernetes Engine, Google Container Registry, and Cloud Storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improves the YAML file editing process with features such as code snippets and
    in-line documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in support for Skaffold to fasten your inner development loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy remote and local debugging of your applications running on Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in log viewer to view application logs in real time for your Kubernetes
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood what Cloud Code is and its features, let's try to
    install and use its startup templates to quickly deploy a Java application to
    the local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and working with the IntelliJ Cloud Code plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with the Cloud Code plugin, first, we need to download it. You
    can access the IntelliJ plugin marketplace to download it. Let''s learn how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: For Windows or Linux, navigate to **File** | **Settings** | **Plugins**, enter
    **Cloud Code** in the search area, and click on **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For macOS, navigate to **IntelliJ IDEA** | **Preferences** | **Plugins**, enter
    **Cloud Code** in the search area, and click on **Install**, as shown in the following
    screenshot:![Figure 7.1 – Installing Cloud Code from the IntelliJ marketplace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Installing Cloud Code from the IntelliJ marketplace
  prefs: []
  type: TYPE_NORMAL
- en: Once the download is completed, a welcome screen will pop up. Here, click on
    **Create a Kubernetes Sample App**, as shown in the following screenshot:![Figure
    7.2 – Cloud Code welcome page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Cloud Code welcome page
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, a **New Project** window will open. We need to select the
    **Java: Guestbook** project, as shown in the following screenshot, and click **Next**:![Figure
    7.3 – Selecting a pre-built Java Guestbook application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Selecting a pre-built Java Guestbook application
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, you will be asked to specify your container image repository.
    If you are using DockerHub, GCR, or any other image registry, then add those details
    and click on **Next**. For example, if you are using GCR, then enter something
    like `gcr.io/gcp-project-id`. Since we are using startup templates and the image
    name is already defined in Kubernetes manifests, we can leave that part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, enter the project name and click on **Finish**. The sample
    Java project will be downloaded to your default project location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a working project, click the **Run/Debug Configurations** dropdown
    and select **Edit Configurations**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Run/Debug Configurations** dialog box, select the **Develop on Kubernetes**
    configuration. Then, under **Run** | **Deployment**, select **Deploy to current
    context (minikube)**, as shown in the following screenshot:![Figure 7.4 – Setting
    Kubernetes's current context to Minikube
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Setting Kubernetes's current context to Minikube
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Apply** and **OK** to save your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, to run the application on the local Minikube cluster, click on the
    green run icon:![Figure 7.5 – Running the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Running the application
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained earlier, Cloud Code uses Skaffold. You should see the following
    output once the application has been deployed successfully to the local Minikube
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Deployment logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Deployment logs
  prefs: []
  type: TYPE_NORMAL
- en: You will receive a notification in the **Event Logs** section in IntelliJ. Click
    on **View** to access the local URLs of your deployed Kubernetes services:![Figure
    7.7 – Event logs notification
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.7_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Event logs notification
  prefs: []
  type: TYPE_NORMAL
- en: 'You can click on the **java-guestbook-frontend** URL to access the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Available services'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.8_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Available services
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following screen after accessing the `http://localhost:4503`
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – My Guestbook application landing page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.9_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – My Guestbook application landing page
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we installed the Cloud Code plugin and used the startup template
    provided to start with this plugin quickly. With our very minimal setup, we built
    and deployed a Java application to the local Kubernetes cluster. The following
    section will create a Spring Boot application that will display real-time air
    quality data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to WHO (https://www.who.int/health-topics/air-pollution), air pollution
    is killing approximately 7 million people worldwide every year. This is a cause
    of concern, not only for developed nations but developing nations as well. We
    should do everything we can to stop this from happening by taking strong measures.
    We, as technologists, can create solutions to make people aware about the air
    quality in their area. With this, people can take preventive measures such as
    wearing masks while they are out and keeping the elderly and kids at home if the
    air outside is toxic.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a Spring Boot application that will show real-time
    air quality data for your current location. We will use the API provided by Openaq
    (https://openaq.org/), a non-profit organization called Wikipedia of air quality
    data. It exposes many endpoints for real-time air quality data, but we will use
    the [https://api.openaq.org/v1/latest?country=IN](https://api.openaq.org/v1/latest?country=IN) URL
    for our Spring Boot application. Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we will start by downloading a working stub for our Spring Boot
    application using Spring Initializr by browsing [https://start.spring.io/](https://start.spring.io/).
    We will also add the following dependencies for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Spring Boot project Maven dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.10_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Spring Boot project Maven dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the dependencies that we''ve already discussed, we will also add
    the following Dekorate Spring Boot starter dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Dekorate (https://github.com/dekorateio/dekorate) is a tool that generates
    Kubernetes manifests for you automatically. It can detect if the application has
    a Spring Boot web dependency and automatically generates Kubernetes manifests
    during compilation and, by default, configures services, deployments, and probes.
    Optionally, in your main class, you can add the `@KubernetesApplication` annotation
    to add some customization. For example, you can provide the number of replicas,
    service type, ingress, and many other things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Dekorate generates Kubernetes manifests in `.json` or .`yml` format in the `target/classes/META-INF/dekorate`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the Kubernetes service manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the relevant part of the deployment Kubernetes manifest. As
    you can see, Dekorate has generated both liveness and readiness probes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the `AirQualityController` class, which has been annotated with the
    `@Controller` annotation. All the incoming HTTP requests to `/index` are handled
    by the `index()` method, which takes the country code, limit, page, and city name
    as input. The default values for these parameters are `IN`, `5`, `1`, and `Delhi`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the following code snippet, we have a method named `getAqiForCountry(),`
    that is called every time we request `/index`. This method also uses `RestTemplate`
    to fetch real-time air quality data from the endpoint, as mentioned in the `COUNTRY_AQI_END_POINT`
    variable, and returns an `AqiCountryResponse` object. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Code for real-time air quality data'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.11_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Code for real-time air quality data
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RestTemplate` class has been put in maintenance mode since version 5.0\.
    This means that only minor bug fixes will be allowed and that it will be removed
    in the future in favor of the `org.springframework.web.reactive.client.WebClient`
    class, which supports both synchronous and asynchronous operations. To use `WebClient`,
    you will have to add another dependency, such as `spring-boot-starter-webflux`.
    If you want to avoid having just one dependency, you can also use the new HTTP
    Client API, which was added in Java 11\. With this new API, we can send requests
    either synchronously or asynchronously. In the following synchronous blocking
    example, we are using the `send(HttpRequest, HttpResponse.BodyHandler)` method.
    This method blocks until the request is sent and a response is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient httpClient = HttpClient.newBuilder().build();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpRequest httpRequest = HttpRequest.newBuilder()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      .uri(URI.create("URL"))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      .GET()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`      .build();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpResponse<String> syncHttpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());`'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for asynchronous non-blocking, we can use the `sendAsync(HttpRequest,
    HttpResponse.BodyHandler)` method. It returns with a `CompletableFuture<HttpResponse>`
    that can be combined with different asynchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AqiCountryResponse` object contains the following data elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must do some sorting and return the data to the `index.html` page
    to render it on the UI. For the UI part, we have used the Spring Boot Thymeleaf
    dependency. Using the following logic, we can display the real-time air quality
    data inside a table on the `/index.html` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also created a static HTML table that specifies the air pollution levels,
    with colors assigned to them inside the same page. These colors make it easy for
    people to identify if pollution has reached an alarming level or not in their
    respective areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the application is ready. We can try it out by running it using
    the `mvn sprinboot:run` command. Let''s do that and see if we get the expected
    output. In the following screenshot, you can see that we have changed the default
    city to Mumbai and that we can view real-time air quality data for Mumbai:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Breathe – Real Time Air Quality Data for Mumbai'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.12_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Breathe – Real Time Air Quality Data for Mumbai
  prefs: []
  type: TYPE_NORMAL
- en: 'On the same page, we can see a table that contains information related to different
    AQI ranges and their severity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Air quality index'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.13_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Air quality index
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created a Spring Boot application that displays the real-time
    air quality data of a city in your country.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the Cloud Code plugin to containerize and deploy
    our application to our local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing and deploying a Spring Boot application using Cloud Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to containerize and deploy the Spring Boot application we created
    in the previous section. To containerize our Spring Boot application, we will
    use `jib-maven-plugin`. We''ve used this many times in previous chapters, so I
    will skip the setup for it here. We will deploy to a local Minikube cluster using
    `kubectl`. Let''s learn how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need a `skaffold.yaml` file in the root directory of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create an empty file named `skaffold.yaml` and use the Cloud Code auto-completion
    feature, as shown in the following screenshot, to generate a working `skaffold.yaml`
    file:![Figure 7.14 – Creating the skaffold.yaml file using Cloud Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.14_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Creating the skaffold.yaml file using Cloud Code
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a new schema version may be available. Cloud Code is smart enough
    to detect those changes and will suggest that you upgrade the schema as well,
    as shown in the following screenshot:![Figure 7.15 – Updating the schema version
    using Cloud Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.15_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Updating the schema version using Cloud Code
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final version of our `skaffold.yaml` configuration file.
    Here, you can see that we have used `jib` to containerize our application. We
    used `kubectl` for deployment, and the path we''ve used is the same as the one
    we used for Dekorate for our Kubernetes manifest generation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Soon after creating the `skaffold.yaml` configuration file, Cloud Code detects
    the change and suggests that we **Create Cloud Code Kubernetes Run Configurations**,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Creating run configurations using Cloud Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.16_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Creating run configurations using Cloud Code
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking this, under the **Run/Debug** configuration in IntelliJ, two new
    profiles will be created called **Develop on Kubernetes** and **Run on Kubernetes**:![Figure
    7.17 – Cloud Code profiles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.17_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – Cloud Code profiles
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our application in continuous development mode, choose **Develop on
    Kubernetes** from the dropdown. Cloud Code internally uses the `skaffold dev`
    command in this mode. It will do the following for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will start watching for changes in your source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will containerize our Spring Boot application using Jib. Since we are using
    a local Kubernetes cluster, Skaffold is smart enough not to push the image to
    the remote registry for a fast inner development loop. Instead, it will load the
    image to the local Docker daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will deploy the image to the Minikube cluster, port forward to port `8080`,
    and start streaming the logs in your IDE. The events logs in your IDE will show
    the service URL, which you can use to access your application. The output will
    be similar to what we saw in the previous section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Run on Kubernetes** option is similar to the `skaffold run` command. You
    can use this option to deploy when you want instead of doing so on every code
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have not done that, you can even use Cloud Code to deploy to
    a remote Kubernetes cluster. If your Kubernetes context is pointed toward a remote
    cluster such as GKE, then Cloud Code can do the deployment there as well. If you
    don't have a remote cluster, then Cloud Code can also help you create that.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Code has a good integration for running serverless workloads, as well
    as using Google's Cloud Run.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to containerize and deploy a Spring Boot application
    to a local Kubernetes cluster using Cloud Code. Now, let's summarize this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the Cloud Code plugin developed by Google
    to do a single-click deployment of your Kubernetes applications from your IDE.
    We started this chapter by explaining the various features of Cloud Code. In the
    example, we explained how we could use the startup templates provided by Cloud
    Code to write, build, and deploy your Java applications from your IDE. Then, we
    created a Spring Boot application that uses Dekorate to generate Kubernetes manifests
    at compile time. Finally, we containerized and deployed the Spring Boot application
    to a local Minikube cluster.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, you have discovered how you can use Cloud Code to increase your
    productivity while developing cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will talk about how we can deploy a Spring Boot application
    to the Google Kubernetes Engine.
  prefs: []
  type: TYPE_NORMAL
