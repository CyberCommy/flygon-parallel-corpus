- en: Dependency Injection with Method Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used a constructor to inject our dependencies. Doing
    so simplified our object and the life cycle of its dependencies. But what happens
    when our dependency is different for every request? This is where method injection
    comes in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of method injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying method injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of method injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service, as introduced
    in [Chapter 4](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Introduction to the
    ACME Registration Service*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Instructions on how to obtain the code and configure the sample service are
    available in the README file, found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch07/acme`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method injection is everywhere. You probably use it every day and you don''t
    even realize it. Have you ever written code like this?:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How about this?:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is method injection—the passing in of the dependency as a parameter to
    the request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the previous examples in more detail. The function signature
    for `Fprint()` is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the first parameter, `io.Writer`, is a dependency for this function.
    What makes this different from any other function call is the fact that the dependency
    provides an invocation context or data to the function call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, the dependency was required, as it is being used as the
    output destination. However, dependencies used in method injection are not always
    required. Sometimes the dependency is optional, as we can see in the following
    example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is not the actual implementation from the standard library; I have simplified
    it to highlight the critical parts. In the preceding example, `io.Reader` is optional,
    and as such, is protected by a guard clause.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: When applying method injection, the dependencies are specific to the current
    invocation, and we will frequently find ourselves needing guard clauses. To help
    us decide whether or not to include guard clauses, let's dive a little deeper
    into our examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In the `fmt.Fprint()` standard library implementation, there is no guard clause
    on `io.Writer`, meaning that supplying `nil` will cause the function to panic.
    This is because, without `io.Writer`, there is nowhere for the output to go.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: However, in the `http.NewRequest()` implementation, there is a guard clause
    because it is possible to make an HTTP request that does not contain a request
    body.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does that mean for the functions that we write? In most cases, we
    should avoid writing code that can cause a crash with a panic. Let''s implement
    a function whose purpose is similar to `Fprint()` and see whether we can avoid
    panics. Here is the first rough implementation (with panic):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's the first thing that comes to mind to avoid the panic caused by a `nil`
    writer?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add a guard clause and return an error when `io.Writer` is not supplied,
    as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While this still looks and feels like regular, valid Go code, we now have an
    error that only happens when we, the programmer, make a mistake. A much better
    option would be a *reasonable default,* as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This technique is called **defensive coding**. The central concept is that *it's
    better to continue working, even with a degraded experience, than to crash*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Although these examples have all been functions, method injection can be used
    with structs in precisely the same way. There is one caveat—do not save the injected
    dependency as a member variable. We are using method injection because the dependency
    provides function invocation context or data. Saving the dependency as a member
    variable causes it to be shared between calls, effectively leaking this context
    between requests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of method injection
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, method injection is used extensively in the
    standard library. It is also extremely useful when you want to write your own
    shared libraries or frameworks. Its usefulness does not stop there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**It is excellent with functions**—Everybody loves a good function, particularly
    those that follow the *Single responsibility principle* section, as discussed
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*. They''re simple, stateless, and can be highly reusable. Adding method
    injection to a function will increase its reusability by converting the dependency
    into an abstraction. Consider the following HTTP handler:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nice and simple. It builds a Go object and then writes the contents of the
    object to the response as JSON. It''s not hard to imagine that the next HTTP handler
    we write would also have the same final nine lines. So, let''s extract them to
    a function instead of copying and pasting:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's examine the inputs to the function; how can we make these more generic
    or abstract?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: While the JSON encoder only needs `io.Writer` and not the full `http.ResponseWriter`,
    we are also outputting the HTTP status codes. So, that is as good as we can do,
    short of defining our own interface. The second parameter is `*Animal`. In our
    function, what is the minimum we actually need?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We are only using `*Animal` as an input to the JSON encoder, and its function
    signature is
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`Encode(v interface{}) error`. So, we can reduce our param to match, giving
    us the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generally, I avoid using `interface{}` as its use leads to the code becoming
    littered with type casts and statements that make it harder to read. In this case,
    however, it's the best (and only) choice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other *interface segregation principle-*based examples in other chapters,
    it's often best to define the minimal possible interface alongside the function
    or method; alternatively if possible, use the appropriate minimalistic interface
    from the standard library (such as `io.Writer`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependencies act as data**—Because method injection requires the user to
    pass in the dependency with each call, this has some interesting side-effect on
    the relationship between the dependency and the usage. The dependency becomes
    part of the data in the request and can drastically change the results of the
    call. Consider the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A very innocuous and straightforward function, but see what happens when we
    supply a few different dependencies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Dependencies are request-scoped**—These dependencies, by definition, are
    being created and destroyed all of the time. Therefore, they are not good candidates
    for constructor injection or even monkey patching. We could, of course, create
    the object that uses the dependency every request too, but that would neither
    be performant nor always necessary.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an HTTP request handler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As an HTTP handler, the `ServeHTTP()` method will be called once for every incoming
    HTTP request. `LoadOrderHandler` depends on `OrderLoader`, in which we will inject
    our implementation `AuthenticatedLoader` using constructor injection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `AuthenticatedLoader` can be seen in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `AuthenticatedLoader` depends on a database connection pool;
    this is expensive to create, so we do not want to recreate it with every request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The `loadByOwner()` function accepts `Owner` using method injection. We are
    using method injection here as we expect `Owner` to vary with each request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: This example uses constructor injection for long-lived dependencies and method
    injection for request-scoped ones. In this way, we are not unnecessarily creating
    and destroying objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Assists with immutability, statelessness, and concurrency**—You might accuse
    me of overselling a little bit here, but after writing some very concurrent Go
    systems, I have found that objects that are stateless and/or immutable are less
    prone to concurrency-related problems. Method injection does not grant these features
    by itself but does make achieving them easier. By passing around the dependency,
    the ownership and scope of use are much clearer. Additionally, we do not need
    to concern ourselves with concurrent access to the dependency, as we would if
    it was a member variable.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Applying method injection
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to improve our ACME registration service by applying
    method injection with perhaps my favorite package in the entire Go standard library,
    the context package. Central to this package is the `Context` interface, which
    describes itself as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**A context carries a deadline, cancellation signal, and request-scoped values
    across API boundaries. Its methods are safe for simultaneous use by multiple goroutines**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: So, why do I love it so much? By applying method injection, with context as
    the dependency, I am able to build my processing logic in such a way that it can
    all be automatically canceled and cleaned up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the changes, let''s take a more in-depth look at the registration
    function provided by our sample service, and its interactions with external resources.
    The following diagram outlines the steps that are performed during a single call
    to the register endpoint:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f9cb019-ed60-4dc7-9616-0e5080a68a76.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'These interactions are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: User calls the register endpoint.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our service calls the **Exchange Rate Service**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our service saves the registration into the database.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s consider how these interactions could go wrong. Ask yourself the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: What can fail or become slow?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I want to react or recover from that failure?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are my users going to react to my failure?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering the interactions in our function, two problems immediately come
    to mind:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**Calls to the database can fail or become slow:** How can we recover from
    this? We could perform retries, but we have to be very careful about this. Databases
    tend to be more of a finite resource than a web service. As such, retrying requests
    could, in fact, degrade the performance of the database even further.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calls to the exchange rate service can fail or become slow:** How can we
    recover from this? We could automatically retry failed requests. This will reduce
    the occasions where we cannot load an exchange rate. Assuming the business approves,
    we could set up some default rates to use, instead of entirely failing the registration.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best change we could make to improve the stability of the system might surprise
    you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: We could simply not make the request at all. If we were able to change the registration
    process so that the exchange rate was not needed in this part of the processing,
    then it could never cause us problems.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that none of the aforementioned solutions are available to us in
    our (contrived) example. The only option we are left with is failure. What happens
    if loading the exchange rate takes so long that the user gives up and cancels
    their request? They are likely to assume the registration failed and hopefully
    try again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, our best course of action is to give up waiting for the exchange
    rate and not to process the registration any further. This is a process known
    as **stopping short**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Stopping short
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stopping short is the process of discontinuing the processing request (before
    it would otherwise finish) based on an external signal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, that external signal will be the cancelation of the user''s HTTP
    request. In Go, the `http.Request` object includes a `Context()` method; the following
    is an extract of the documentation for that method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，外部信号将是用户HTTP请求的取消。在Go中，`http.Request`对象包括一个`Context()`方法；以下是该方法文档的摘录：
- en: '**For incoming server requests, the context is canceled when the client''s
    connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP
    method returns**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传入的服务器请求，当客户端的连接关闭时，请求被取消（使用HTTP/2），或者当ServeHTTP方法返回时，上下文被取消。
- en: What does it mean when the request is canceled? Most importantly for us, it
    means that no one is waiting for the response.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求被取消时意味着什么？对我们来说最重要的是，这意味着没有人在等待响应。
- en: If the user has given up listening to the response, it is likely they will consider
    the request failed and will hopefully try again.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户放弃等待响应，他们很可能会认为请求失败，并希望再次尝试。
- en: How we should react to this situation depends on the feature we are implementing,
    but in many cases, mainly features related to loading or fetching data, the most
    effective response is to stop processing the request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何对这种情况做出反应取决于我们正在实现的功能，但在许多情况下，主要是与加载或获取数据相关的功能，最有效的响应是停止处理请求。
- en: For the register endpoint of our service, this is the option we have chosen.
    We are going to pass `Context` from the request through all of the layers of our
    code using method injection. If the user cancels their request, we will immediately
    stop processing the request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们服务的注册端点，这是我们选择的选项。我们将通过方法注入从请求中传递`Context`到我们代码的所有层。如果用户取消他们的请求，我们将立即停止处理请求。
- en: Now that we are clear on what we are trying to achieve, let's apply method injection
    to the layers of our service *from the inside out*. We need to start from the
    inside to ensure that our code and tests stay running during the refactor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们清楚我们要达到什么目标，让我们从内部开始将方法注入到我们服务的层中。我们需要从内部开始，以确保我们的代码和测试在重构过程中保持运行。
- en: Applying method injection to the data package
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到数据包
- en: A quick reminder, the `data` package is a **data access layer** (**DAL**) that
    provides simplified and abstracted access to the underlying MySQL database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒，`data`包是一个提供对底层MySQL数据库的简化和抽象访问的**数据访问层**（**DAL**）。
- en: 'The following is the current code for the `Save()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Save()`函数的当前代码：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By applying method injection, we get the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用方法注入，我们得到了以下结果：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we swapped the `Exec()` call for `ExecContext()` but have otherwise
    changed nothing. Because we have changed the function signature, we are also going
    to need to update our usage of this package to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将`Exec()`调用替换为`ExecContext()`，但其他方面没有改变。因为我们已经改变了函数签名，我们还需要更新对该包的使用如下：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will notice our use of `context.TODO()`; it is used here as a placeholder
    until we can refactor the `save()` method to use method injection as well. After
    updating the tests we broke with the refactor, we can proceed with the next package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用了`context.TODO()`；它在这里被用作占位符，直到我们可以将`save()`方法重构为使用方法注入为止。在更新了我们在重构过程中破坏的测试之后，我们可以继续进行下一个包。
- en: Applying method injection to the exchange package
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到exchange包
- en: The exchange package is responsible for loading the current currency exchange
    rate (for example, Malaysian Ringgit to Australian Dollars) from an upstream service.
    Similar to the data package, it provides simplified and abstracted access to this
    data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange`包负责从上游服务加载当前的货币兑换率（例如，马来西亚林吉特兑澳大利亚元），与数据包类似，它提供了对这些数据的简化和抽象访问。'
- en: 'The following are the relevant parts of the current code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前代码的相关部分：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first change is the same as the previous ones. Simple method injection
    on the `Do()` and `loadRateFromServer()` methods, changing these method signatures
    to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化与之前的相同。在`Do()`和`loadRateFromServer()`方法上进行简单的方法注入，将这些方法签名更改为以下内容：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, there is no `http.GetWithContext()` method, so we will need
    to build the request and set the context a slightly more verbose way, giving us
    the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有`http.GetWithContext()`方法，所以我们需要以稍微冗长的方式构建请求并设置上下文，得到以下结果：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we did previously, we will also need to use `context.TODO()` in the model
    layer that calls the `exchange` package until we have a chance to change them
    to method injection. With the two *bottom* software layers (the `data` and `exchange`
    packages) complete, we can move on to the next software layer, business layer,
    or model layer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们还需要在调用“exchange”包的模型层中使用`context.TODO()`，直到我们有机会将它们改为方法注入。完成了两个*底层*软件层（`data`和`exchange`包）后，我们可以继续进行下一个软件层、业务层或模型层。
- en: Applying method injection to the model layer (the Get, List, and Register packages)
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将方法注入应用到模型层（Get、List和Register包）
- en: 'Previously, in places where we called the `data` or `exchange` packages, we
    used `context.TODO()` to ensure the code could still compile and that our tests
    continued to do their job. It''s now time to apply method injection to the model
    layer and replace the `context.TODO()` calls with injected context. First, we
    change the `getPrice()` and `save()` methods to accept a context:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在我们调用`data`或`exchange`包的地方，我们使用`context.TODO()`来确保代码仍然可以编译，并且我们的测试继续发挥作用。现在是时候将方法注入应用到模型层，并用注入的上下文替换`context.TODO()`的调用。首先，我们将`getPrice()`和`save()`方法更改为接受上下文：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we can update the package''s public API function, `Do()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以更新包的公共API函数`Do()`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have *rolled up* the `Context` objects passed into the data and `exchange`
    package into a single, injected dependency; a dependency that we can extract from
    the `http.Request` in the REST package.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将传递给数据和`exchange`包的`Context`对象合并为一个单一的注入依赖项；这是一个我们可以从REST包中的`http.Request`中提取的依赖项。
- en: Applying the method injection of context to the REST package
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将上下文的方法注入到REST包中
- en: 'Finally, now for the key changes. First, we extract the context from the request:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在是关键的更改。首先，我们从请求中提取上下文：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we pass it down to the model:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其传递给模型：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After what feels like a lot of *too simple* changes, we are done applying method
    injection to all of the layers in our register endpoint.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了许多*太简单*的更改之后，我们已经将方法注入应用到了注册端点的所有层。
- en: Let's examine what we have achieved. Our processing is now tied to the execution
    context of the request. Therefore, when the request is canceled, we will immediately
    stop processing the request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们取得了什么成就。我们的处理现在与请求的执行上下文相关联。因此，当请求被取消时，我们将立即停止处理该请求。
- en: But why is this important? There are two reasons; the first and most important
    is user expectations. If the user canceled the request, either manually or via
    a timeout, they will see an error. They will conclude that the processing has
    failed. If we continue to process the request and manage to complete it, this
    will go against their expectations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但这为什么重要呢？有两个原因；第一个和最重要的是用户期望。如果用户取消了请求，无论是手动还是通过超时，他们将看到一个错误。他们会得出结论，处理已失败。如果我们继续处理请求并设法完成它，这将违背他们的期望。
- en: The second reason is more pragmatic; when we stop processing the request, we
    reduce the load on our server and our upstream. This freed-up capacity can then
    be used to handle other requests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因更加务实；当我们停止处理请求时，我们减少了服务器和上游的负载。这种释放的容量随后可以用于处理其他请求。
- en: When it comes to meeting user expectations, there is actually more we can do
    with the context package. We can add latency budgets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及满足用户期望时，上下文包实际上可以做更多的事情。我们可以添加延迟预算。
- en: Latency budgets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟预算
- en: As with a lot of IT terms, latency budgets can be used in a multitude of ways.
    In this case, we refer to the maximum time allowed for a call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多IT术语一样，延迟预算可以以多种方式使用。在这种情况下，我们指的是调用允许的最长时间。
- en: 'Translating that into our current refactoring, it refers to two things:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些转化为我们当前的重构，它涉及两件事：
- en: The maximum time allowed for the upstream (database or exchange rate service)
    call to complete
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许上游（数据库或汇率服务）调用完成的最长时间
- en: The maximum time allowed for our register API to complete
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的注册API允许的最长完成时间
- en: 'You can see how these two things are related. Let''s look at how our API response
    time is made up:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这两件事情是如何相关的。让我们看看我们的API响应时间是如何组成的：
- en: '*API response time = (exchange rate service call + database call + our code)*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*API响应时间 =（汇率服务调用+数据库调用+我们的代码）*'
- en: Assuming the performance of *our code* is mainly consistent, then our service
    quality is directly dependent on the speed of the upstream calls. This is not
    a very comfortable position to be in, so what can we do?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*我们的代码*的性能主要是一致的，那么我们的服务质量直接取决于上游调用的速度。这不是一个非常舒适的位置，那么我们能做什么呢？
- en: In the previous section, we examined these failures and some options, and decided
    that for the moment, we want to fail the request. What is the best failure we
    can offer our user? One that is both timely and informative.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们检查了这些失败和一些选项，并决定暂时要失败请求。我们能为用户提供的最好的失败是什么？一个及时而有信息的失败。
- en: 'To achieve this, we are going to use another feature of the `context.Context`
    interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`context.Context`接口的另一个特性：
- en: '`WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`'
- en: As you might have guessed, this method sets a timeout on the context. This timeout
    will act as a timer, causing the context to cancel should the latency budget (timeout)
    be exceeded. Then, because we have our stop short already in place, our request
    will cease processing and exit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，这种方法在上下文中设置了一个超时。这个超时将作为一个计时器，如果超过了延迟预算（超时），上下文将被取消。然后，因为我们已经设置了停止短路，我们的请求将停止处理并退出。
- en: First, let's apply this to our database call. In the next example, we will create
    a *sub-context* from the original context and give it a timeout. As contexts are
    hierarchical, the timeout we are applying will only apply to the sub-context and
    any contexts we create from it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将其应用到我们的数据库调用中。在下一个示例中，我们将从原始上下文中创建一个*子上下文*并为其设置一个超时。由于上下文是分层的，我们应用的超时只适用于子上下文和我们从中创建的任何上下文。
- en: 'In our case, we have decided that the latency budget for calls to the database
    will be 1 second, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们已经决定对数据库的调用的延迟预算为1秒，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s apply a latency budget to the exchange service call. To do this,
    we are going to use another feature of the `http.Request`, `Context()` method,
    documented as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将延迟预算应用到交换服务调用中。为此，我们将使用`http.Request`的另一个特性，`Context()`方法，文档如下：
- en: '**For outgoing client requests, the context controls cancellation**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于出站客户端请求，上下文控制取消**'
- en: 'To set the latency budget on our outgoing HTTP request, we will create another
    sub-context, as we did for the database, and then set that context into the request
    with the `WithRequest()` method. After these changes, our code looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的出站HTTP请求上设置延迟预算，我们将创建另一个子上下文，就像我们为数据库做的那样，然后使用`WithRequest()`方法将该上下文设置到请求中。在这些更改之后，我们的代码看起来像这样：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these changes in place, let''s revisit our API response time formula and
    consider the worst-case scenario – both calls take a fraction under 1 second but
    successfully complete, giving us this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，让我们重新审视我们的API响应时间公式，并考虑最坏的情况-两个调用都花了不到1秒的时间但成功完成，给我们这个：
- en: '*API response time = (~1 second + ~ 1 second + our code)*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*API响应时间 =（~1秒+ ~1秒+我们的代码）*'
- en: This gives us a maximum execution time of about 2 seconds. But what if we decide
    that the maximum response time we will allow ourselves is 1.5 seconds?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个大约2秒的最大执行时间。但是如果我们决定允许自己的最大响应时间是1.5秒呢？
- en: 'Thankfully, we can easily do this too. Earlier, I mentioned that contexts are
    hierarchical. All of our contexts are currently derived from the context in the
    request. While we cannot change the context that is part of the request, we can
    derive a context from it with our API''s latency budget and then pass that down
    to the data and exchange packages. The updated parts of the handler look like
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After a few simple changes, we have far more control over how our API performs,
    thanks to the context package and a little bit of method injection.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of method injection
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I do not have a long list of disadvantages for you; in fact, I have only two.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding parameters detracts from the UX**—This is a rather big one. Adding
    parameters to a method or function detracts from the UX of the function. As we
    saw in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding for User
    Experience*, a bad UX for a function can negatively impact its usability.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following struct:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code works; it gets the job done. But it's annoying to have to pass in
    the database every time. Beyond that, there is no guarantee that the code that
    calls `Load()` also maintains the database pool.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to consider is encapsulation. Does the user of these functions
    need to know that they depend on a database? Put yourself in the place of the
    user of the `Load()` function for a moment. What do you want to do and what do
    you know?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to load a person, and you know the ID of that person. You do not know
    (or care) where the data comes from. If you were designing the function for yourself,
    what would it look like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's succinct and easy to use, and none of the implementation details are leaking.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, we have so many parameters, it''s hard to separate the data from
    the non-request-scoped dependencies. If we extract those dependencies, we get
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While the UX is better in the second example, it's still rather cumbersome.
    The code could benefit from a different approach, such as composition.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited applicability**—As we have seen in this chapter, method injection
    is excellent with functions and request-scoped dependencies. While this use case
    does frequently crop up, method injection does not apply well to non-request-scoped
    dependencies, which is the bulk of use cases where we want to use **dependency
    injection** (**DI**).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined DI with method injection, perhaps the most
    ubiquitous of all forms of DI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to extracting dependencies from existing code, for the purposes
    of testing, it might be the method that first comes to mind. Please be careful
    with this, we do not want to introduce *test-induced damage.*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters to an exported API function for the sole purpose of testing
    undoubtedly damages UX code. Thankfully, there are some tricks available to us
    to avoid damaging our API. We can define member functions that only exist in test
    code. We can also use **Just-In-Time** (**JIT**) dependency injection, which we
    will examine in [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml), *Just-in-Time
    Dependency Injection*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the fantastic and powerful `context` package.
    You might be surprised to learn that there is even more value we can extract from
    this package. I encourage you to check out the Go blog ([https://blog.golang.org/context](https://blog.golang.org/context))
    and investigate this package for yourself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to apply a specific form of both constructor
    injection and method injection called **DI by config**. With it, we will finally
    untangle the `config` package from being depended on by just about every other
    package in our service, making our packages far more decoupled and increasing
    their reusability potential considerably.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the ideal use cases for method injection?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important not to save dependencies injected with method injection?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不保存使用方法注入注入的依赖关系很重要？
- en: What happens if we use method injection too much?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们过度使用方法注入会发生什么？
- en: Why is *stopping short* useful to the system as a whole?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么“停止短”对整个系统有用？
- en: How can latency budgets improve the UX for our users?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟预算如何改善用户体验？
