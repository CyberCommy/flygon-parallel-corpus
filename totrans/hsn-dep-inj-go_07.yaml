- en: Dependency Injection with Method Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used a constructor to inject our dependencies. Doing
    so simplified our object and the life cycle of its dependencies. But what happens
    when our dependency is different for every request? This is where method injection
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of method injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service, as introduced
    in [Chapter 4](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Introduction to the
    ACME Registration Service*.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch07).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions on how to obtain the code and configure the sample service are
    available in the README file, found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch07/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method injection is everywhere. You probably use it every day and you don''t
    even realize it. Have you ever written code like this?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How about this?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is method injection—the passing in of the dependency as a parameter to
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the previous examples in more detail. The function signature
    for `Fprint()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first parameter, `io.Writer`, is a dependency for this function.
    What makes this different from any other function call is the fact that the dependency
    provides an invocation context or data to the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, the dependency was required, as it is being used as the
    output destination. However, dependencies used in method injection are not always
    required. Sometimes the dependency is optional, as we can see in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is not the actual implementation from the standard library; I have simplified
    it to highlight the critical parts. In the preceding example, `io.Reader` is optional,
    and as such, is protected by a guard clause.
  prefs: []
  type: TYPE_NORMAL
- en: When applying method injection, the dependencies are specific to the current
    invocation, and we will frequently find ourselves needing guard clauses. To help
    us decide whether or not to include guard clauses, let's dive a little deeper
    into our examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the `fmt.Fprint()` standard library implementation, there is no guard clause
    on `io.Writer`, meaning that supplying `nil` will cause the function to panic.
    This is because, without `io.Writer`, there is nowhere for the output to go.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the `http.NewRequest()` implementation, there is a guard clause
    because it is possible to make an HTTP request that does not contain a request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does that mean for the functions that we write? In most cases, we
    should avoid writing code that can cause a crash with a panic. Let''s implement
    a function whose purpose is similar to `Fprint()` and see whether we can avoid
    panics. Here is the first rough implementation (with panic):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What's the first thing that comes to mind to avoid the panic caused by a `nil`
    writer?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add a guard clause and return an error when `io.Writer` is not supplied,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While this still looks and feels like regular, valid Go code, we now have an
    error that only happens when we, the programmer, make a mistake. A much better
    option would be a *reasonable default,* as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This technique is called **defensive coding**. The central concept is that *it's
    better to continue working, even with a degraded experience, than to crash*.
  prefs: []
  type: TYPE_NORMAL
- en: Although these examples have all been functions, method injection can be used
    with structs in precisely the same way. There is one caveat—do not save the injected
    dependency as a member variable. We are using method injection because the dependency
    provides function invocation context or data. Saving the dependency as a member
    variable causes it to be shared between calls, effectively leaking this context
    between requests.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, method injection is used extensively in the
    standard library. It is also extremely useful when you want to write your own
    shared libraries or frameworks. Its usefulness does not stop there.
  prefs: []
  type: TYPE_NORMAL
- en: '**It is excellent with functions**—Everybody loves a good function, particularly
    those that follow the *Single responsibility principle* section, as discussed
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*. They''re simple, stateless, and can be highly reusable. Adding method
    injection to a function will increase its reusability by converting the dependency
    into an abstraction. Consider the following HTTP handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice and simple. It builds a Go object and then writes the contents of the
    object to the response as JSON. It''s not hard to imagine that the next HTTP handler
    we write would also have the same final nine lines. So, let''s extract them to
    a function instead of copying and pasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let's examine the inputs to the function; how can we make these more generic
    or abstract?
  prefs: []
  type: TYPE_NORMAL
- en: While the JSON encoder only needs `io.Writer` and not the full `http.ResponseWriter`,
    we are also outputting the HTTP status codes. So, that is as good as we can do,
    short of defining our own interface. The second parameter is `*Animal`. In our
    function, what is the minimum we actually need?
  prefs: []
  type: TYPE_NORMAL
- en: We are only using `*Animal` as an input to the JSON encoder, and its function
    signature is
  prefs: []
  type: TYPE_NORMAL
- en: '`Encode(v interface{}) error`. So, we can reduce our param to match, giving
    us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generally, I avoid using `interface{}` as its use leads to the code becoming
    littered with type casts and statements that make it harder to read. In this case,
    however, it's the best (and only) choice.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other *interface segregation principle-*based examples in other chapters,
    it's often best to define the minimal possible interface alongside the function
    or method; alternatively if possible, use the appropriate minimalistic interface
    from the standard library (such as `io.Writer`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependencies act as data**—Because method injection requires the user to
    pass in the dependency with each call, this has some interesting side-effect on
    the relationship between the dependency and the usage. The dependency becomes
    part of the data in the request and can drastically change the results of the
    call. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A very innocuous and straightforward function, but see what happens when we
    supply a few different dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Dependencies are request-scoped**—These dependencies, by definition, are
    being created and destroyed all of the time. Therefore, they are not good candidates
    for constructor injection or even monkey patching. We could, of course, create
    the object that uses the dependency every request too, but that would neither
    be performant nor always necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an HTTP request handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As an HTTP handler, the `ServeHTTP()` method will be called once for every incoming
    HTTP request. `LoadOrderHandler` depends on `OrderLoader`, in which we will inject
    our implementation `AuthenticatedLoader` using constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `AuthenticatedLoader` can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `AuthenticatedLoader` depends on a database connection pool;
    this is expensive to create, so we do not want to recreate it with every request.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadByOwner()` function accepts `Owner` using method injection. We are
    using method injection here as we expect `Owner` to vary with each request.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses constructor injection for long-lived dependencies and method
    injection for request-scoped ones. In this way, we are not unnecessarily creating
    and destroying objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assists with immutability, statelessness, and concurrency**—You might accuse
    me of overselling a little bit here, but after writing some very concurrent Go
    systems, I have found that objects that are stateless and/or immutable are less
    prone to concurrency-related problems. Method injection does not grant these features
    by itself but does make achieving them easier. By passing around the dependency,
    the ownership and scope of use are much clearer. Additionally, we do not need
    to concern ourselves with concurrent access to the dependency, as we would if
    it was a member variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to improve our ACME registration service by applying
    method injection with perhaps my favorite package in the entire Go standard library,
    the context package. Central to this package is the `Context` interface, which
    describes itself as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A context carries a deadline, cancellation signal, and request-scoped values
    across API boundaries. Its methods are safe for simultaneous use by multiple goroutines**'
  prefs: []
  type: TYPE_NORMAL
- en: So, why do I love it so much? By applying method injection, with context as
    the dependency, I am able to build my processing logic in such a way that it can
    all be automatically canceled and cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the changes, let''s take a more in-depth look at the registration
    function provided by our sample service, and its interactions with external resources.
    The following diagram outlines the steps that are performed during a single call
    to the register endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f9cb019-ed60-4dc7-9616-0e5080a68a76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These interactions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: User calls the register endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our service calls the **Exchange Rate Service**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our service saves the registration into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s consider how these interactions could go wrong. Ask yourself the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: What can fail or become slow?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I want to react or recover from that failure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are my users going to react to my failure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering the interactions in our function, two problems immediately come
    to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calls to the database can fail or become slow:** How can we recover from
    this? We could perform retries, but we have to be very careful about this. Databases
    tend to be more of a finite resource than a web service. As such, retrying requests
    could, in fact, degrade the performance of the database even further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calls to the exchange rate service can fail or become slow:** How can we
    recover from this? We could automatically retry failed requests. This will reduce
    the occasions where we cannot load an exchange rate. Assuming the business approves,
    we could set up some default rates to use, instead of entirely failing the registration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best change we could make to improve the stability of the system might surprise
    you.
  prefs: []
  type: TYPE_NORMAL
- en: We could simply not make the request at all. If we were able to change the registration
    process so that the exchange rate was not needed in this part of the processing,
    then it could never cause us problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that none of the aforementioned solutions are available to us in
    our (contrived) example. The only option we are left with is failure. What happens
    if loading the exchange rate takes so long that the user gives up and cancels
    their request? They are likely to assume the registration failed and hopefully
    try again.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, our best course of action is to give up waiting for the exchange
    rate and not to process the registration any further. This is a process known
    as **stopping short**.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping short
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stopping short is the process of discontinuing the processing request (before
    it would otherwise finish) based on an external signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, that external signal will be the cancelation of the user''s HTTP
    request. In Go, the `http.Request` object includes a `Context()` method; the following
    is an extract of the documentation for that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For incoming server requests, the context is canceled when the client''s
    connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP
    method returns**'
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean when the request is canceled? Most importantly for us, it
    means that no one is waiting for the response.
  prefs: []
  type: TYPE_NORMAL
- en: If the user has given up listening to the response, it is likely they will consider
    the request failed and will hopefully try again.
  prefs: []
  type: TYPE_NORMAL
- en: How we should react to this situation depends on the feature we are implementing,
    but in many cases, mainly features related to loading or fetching data, the most
    effective response is to stop processing the request.
  prefs: []
  type: TYPE_NORMAL
- en: For the register endpoint of our service, this is the option we have chosen.
    We are going to pass `Context` from the request through all of the layers of our
    code using method injection. If the user cancels their request, we will immediately
    stop processing the request.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on what we are trying to achieve, let's apply method injection
    to the layers of our service *from the inside out*. We need to start from the
    inside to ensure that our code and tests stay running during the refactor.
  prefs: []
  type: TYPE_NORMAL
- en: Applying method injection to the data package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick reminder, the `data` package is a **data access layer** (**DAL**) that
    provides simplified and abstracted access to the underlying MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the current code for the `Save()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By applying method injection, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we swapped the `Exec()` call for `ExecContext()` but have otherwise
    changed nothing. Because we have changed the function signature, we are also going
    to need to update our usage of this package to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will notice our use of `context.TODO()`; it is used here as a placeholder
    until we can refactor the `save()` method to use method injection as well. After
    updating the tests we broke with the refactor, we can proceed with the next package.
  prefs: []
  type: TYPE_NORMAL
- en: Applying method injection to the exchange package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exchange package is responsible for loading the current currency exchange
    rate (for example, Malaysian Ringgit to Australian Dollars) from an upstream service.
    Similar to the data package, it provides simplified and abstracted access to this
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the relevant parts of the current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change is the same as the previous ones. Simple method injection
    on the `Do()` and `loadRateFromServer()` methods, changing these method signatures
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, there is no `http.GetWithContext()` method, so we will need
    to build the request and set the context a slightly more verbose way, giving us
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we did previously, we will also need to use `context.TODO()` in the model
    layer that calls the `exchange` package until we have a chance to change them
    to method injection. With the two *bottom* software layers (the `data` and `exchange`
    packages) complete, we can move on to the next software layer, business layer,
    or model layer.
  prefs: []
  type: TYPE_NORMAL
- en: Applying method injection to the model layer (the Get, List, and Register packages)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, in places where we called the `data` or `exchange` packages, we
    used `context.TODO()` to ensure the code could still compile and that our tests
    continued to do their job. It''s now time to apply method injection to the model
    layer and replace the `context.TODO()` calls with injected context. First, we
    change the `getPrice()` and `save()` methods to accept a context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can update the package''s public API function, `Do()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have *rolled up* the `Context` objects passed into the data and `exchange`
    package into a single, injected dependency; a dependency that we can extract from
    the `http.Request` in the REST package.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the method injection of context to the REST package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, now for the key changes. First, we extract the context from the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we pass it down to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After what feels like a lot of *too simple* changes, we are done applying method
    injection to all of the layers in our register endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine what we have achieved. Our processing is now tied to the execution
    context of the request. Therefore, when the request is canceled, we will immediately
    stop processing the request.
  prefs: []
  type: TYPE_NORMAL
- en: But why is this important? There are two reasons; the first and most important
    is user expectations. If the user canceled the request, either manually or via
    a timeout, they will see an error. They will conclude that the processing has
    failed. If we continue to process the request and manage to complete it, this
    will go against their expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is more pragmatic; when we stop processing the request, we
    reduce the load on our server and our upstream. This freed-up capacity can then
    be used to handle other requests.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to meeting user expectations, there is actually more we can do
    with the context package. We can add latency budgets.
  prefs: []
  type: TYPE_NORMAL
- en: Latency budgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with a lot of IT terms, latency budgets can be used in a multitude of ways.
    In this case, we refer to the maximum time allowed for a call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translating that into our current refactoring, it refers to two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum time allowed for the upstream (database or exchange rate service)
    call to complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum time allowed for our register API to complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see how these two things are related. Let''s look at how our API response
    time is made up:'
  prefs: []
  type: TYPE_NORMAL
- en: '*API response time = (exchange rate service call + database call + our code)*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the performance of *our code* is mainly consistent, then our service
    quality is directly dependent on the speed of the upstream calls. This is not
    a very comfortable position to be in, so what can we do?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we examined these failures and some options, and decided
    that for the moment, we want to fail the request. What is the best failure we
    can offer our user? One that is both timely and informative.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we are going to use another feature of the `context.Context`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`'
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, this method sets a timeout on the context. This timeout
    will act as a timer, causing the context to cancel should the latency budget (timeout)
    be exceeded. Then, because we have our stop short already in place, our request
    will cease processing and exit.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's apply this to our database call. In the next example, we will create
    a *sub-context* from the original context and give it a timeout. As contexts are
    hierarchical, the timeout we are applying will only apply to the sub-context and
    any contexts we create from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we have decided that the latency budget for calls to the database
    will be 1 second, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s apply a latency budget to the exchange service call. To do this,
    we are going to use another feature of the `http.Request`, `Context()` method,
    documented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For outgoing client requests, the context controls cancellation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the latency budget on our outgoing HTTP request, we will create another
    sub-context, as we did for the database, and then set that context into the request
    with the `WithRequest()` method. After these changes, our code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes in place, let''s revisit our API response time formula and
    consider the worst-case scenario – both calls take a fraction under 1 second but
    successfully complete, giving us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*API response time = (~1 second + ~ 1 second + our code)*'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a maximum execution time of about 2 seconds. But what if we decide
    that the maximum response time we will allow ourselves is 1.5 seconds?
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we can easily do this too. Earlier, I mentioned that contexts are
    hierarchical. All of our contexts are currently derived from the context in the
    request. While we cannot change the context that is part of the request, we can
    derive a context from it with our API''s latency budget and then pass that down
    to the data and exchange packages. The updated parts of the handler look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After a few simple changes, we have far more control over how our API performs,
    thanks to the context package and a little bit of method injection.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of method injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I do not have a long list of disadvantages for you; in fact, I have only two.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding parameters detracts from the UX**—This is a rather big one. Adding
    parameters to a method or function detracts from the UX of the function. As we
    saw in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding for User
    Experience*, a bad UX for a function can negatively impact its usability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code works; it gets the job done. But it's annoying to have to pass in
    the database every time. Beyond that, there is no guarantee that the code that
    calls `Load()` also maintains the database pool.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to consider is encapsulation. Does the user of these functions
    need to know that they depend on a database? Put yourself in the place of the
    user of the `Load()` function for a moment. What do you want to do and what do
    you know?
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to load a person, and you know the ID of that person. You do not know
    (or care) where the data comes from. If you were designing the function for yourself,
    what would it look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's succinct and easy to use, and none of the implementation details are leaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have so many parameters, it''s hard to separate the data from
    the non-request-scoped dependencies. If we extract those dependencies, we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: While the UX is better in the second example, it's still rather cumbersome.
    The code could benefit from a different approach, such as composition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited applicability**—As we have seen in this chapter, method injection
    is excellent with functions and request-scoped dependencies. While this use case
    does frequently crop up, method injection does not apply well to non-request-scoped
    dependencies, which is the bulk of use cases where we want to use **dependency
    injection** (**DI**).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined DI with method injection, perhaps the most
    ubiquitous of all forms of DI.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to extracting dependencies from existing code, for the purposes
    of testing, it might be the method that first comes to mind. Please be careful
    with this, we do not want to introduce *test-induced damage.*
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters to an exported API function for the sole purpose of testing
    undoubtedly damages UX code. Thankfully, there are some tricks available to us
    to avoid damaging our API. We can define member functions that only exist in test
    code. We can also use **Just-In-Time** (**JIT**) dependency injection, which we
    will examine in [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml), *Just-in-Time
    Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the fantastic and powerful `context` package.
    You might be surprised to learn that there is even more value we can extract from
    this package. I encourage you to check out the Go blog ([https://blog.golang.org/context](https://blog.golang.org/context))
    and investigate this package for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to apply a specific form of both constructor
    injection and method injection called **DI by config**. With it, we will finally
    untangle the `config` package from being depended on by just about every other
    package in our service, making our packages far more decoupled and increasing
    their reusability potential considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the ideal use cases for method injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important not to save dependencies injected with method injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if we use method injection too much?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is *stopping short* useful to the system as a whole?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can latency budgets improve the UX for our users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
