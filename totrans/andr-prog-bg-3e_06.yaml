- en: '*Chapter 6*: The Android Lifecycle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get familiar with the lifecycle of an Android app.
    At first, this might sound a bit strange, that a computer program has a lifecycle,
    but it will make sense soon.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle is the way that all Android apps interact with the Android OS.
    Just like the lifecycle of humans interacts with the world around them, we have
    no choice but to interact with it and must be prepared to handle different events
    without notice if we want our apps to survive.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the phases of the lifecycle that an app goes through from creation
    to destruction and how this helps us know where to put our Java code, depending
    on what we are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, in this chapter we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The life and times of an Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is method overriding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phases of the Android lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly we need to know and do to code our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lifecycle demonstration mini app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick look at code structure ready to get Java coding in the next chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start learning about the Android lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006).
  prefs: []
  type: TYPE_NORMAL
- en: The life and times of an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked a bit about the structure of our code; we know that we can write
    classes, and within those classes we have methods, and the methods contain our
    code, which gets things done. We also know that when we want the code within a
    method to run (be executed), we call that method by using its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*, First Contact:
    Java, XML, and the UI Designer*, we learned that Android itself calls the `onCreate`
    method just before the app is ready to start. We saw this when we output to the
    logcat and used the `Toast` class to send a pop-up message to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: What we will look at in this chapter is what happens throughout the lifecycle
    of every app we write – when it starts and ends as well as a few stages in between
    as well. And what we will see is that Android interacts with our app on numerous
    occasions, each time it is run.
  prefs: []
  type: TYPE_NORMAL
- en: How Android interacts with our apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It does so by calling methods that are contained within the `Activity` class.
    Even if the method is not visible within our Java code, it is still being called
    by Android at the appropriate time. If this doesn't seem to make any sense, then
    read on.
  prefs: []
  type: TYPE_NORMAL
- en: Did you ever wonder why the `onCreate` method had a strange-looking line of
    code just before it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here is that we are saying to Android, when you call `onCreate`,
    please use our overridden version because we have some things to do at that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you might remember the odd-looking first line of code in the `onCreate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is telling Android to call the original/official version of `onCreate`
    before proceeding with our overridden version. This is not just a quirk of Android
    – **method** **overriding** is built into Java.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many other methods that we can optionally override, and they
    allow us to add our code at appropriate times within the lifecycle of our Android
    app. Just as `onCreate` is called just before the app is shown to the user, there
    are more methods that are called at other times. We haven't seen them yet, we
    haven't overridden them yet, but they are there, they are called, and their code
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need to care about the methods of **our** app that Android calls
    whenever it wants is they control the very life and death of our code. For instance,
    what if our app allows the user to type an important reminder. Then, halfway through
    typing the reminder their phone rings, our app disappears, and the data (the reminder)
    is gone.
  prefs: []
  type: TYPE_NORMAL
- en: It is vital and thankfully quite straightforward that we learn when, why, and
    which methods Android will call as part of the lifecycle of our app. We can then
    know where we need to override methods to add our own code and where to add the
    real functionality (code) that defines our app.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the Android lifecycle, then we can move on to the ins and outs
    of Java and we will know exactly where to put the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: A simplified explanation of the Android lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever used an Android device, you have probably noticed it works
    quite differently from many other operating systems. For example, you could be
    using an app – say you're checking what people are doing on Facebook. Then, you
    get an email notification and you tap the notification to read it. Midway through
    reading the email, you might get a Twitter notification and because you're waiting
    on important news from someone you follow, you interrupt your email reading and
    change apps to Twitter with a touch.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the tweet, you fancy a game of Angry Birds but midway through
    the first fling, you suddenly remember that Facebook post. So, you quit Angry
    Birds and tap the Facebook icon.
  prefs: []
  type: TYPE_NORMAL
- en: Then you resume Facebook, probably at the exact same point you left it. You
    could have resumed reading the email, decided to reply to the tweet, or started
    an entirely new app.
  prefs: []
  type: TYPE_NORMAL
- en: All this backwards and forwards takes quite a lot of management on the part
    of the operating system, independently of the individual apps themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between, say, a Windows PC and Android in the context we have
    just discussed is this: with Android, although the user decides which app they
    are using, the OS decides when to close down (destroy) an application and **our
    user''s data** (like the hypothetical note) along with it. We just need to consider
    this when coding our apps. Just because we might write code to do some cool thing
    with our user''s input, it doesn''t mean that Android will let the code execute.'
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle phases demystified
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android system has multiple distinct phases that any given app can be in.
    Depending upon the phase, the Android system decides how the app is viewed by
    the user – or whether it is viewed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Android has these phases so it can decide which app is in current use and so
    that it can then give the right amount of resources, such as memory and processing
    power.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, as the user interacts with the device, for example, by touching
    the screen, Android must give the details of that interaction to the correct app.
    For instance, a drag-and-release movement in Angry Birds means taking a shot,
    but in a messaging app, it might mean delete a text message.
  prefs: []
  type: TYPE_NORMAL
- en: We have already raised the issue of when the user quits our app to answer a
    phone call; will they lose their progress/data/important note?
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a system that, when simplified a little for the purposes of explanation,
    means that every app on an Android device is in one of the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Being created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of phases will hopefully appear logical. As an example, the user presses
    the Facebook app icon and the app is **created**. Then it is **started**. All
    straightforward so far, but next on the list is **resuming**.
  prefs: []
  type: TYPE_NORMAL
- en: It is not as illogical as it might first appear if, for a moment, we can just
    accept that the app resumes after it starts and then all will become clear as
    we continue.
  prefs: []
  type: TYPE_NORMAL
- en: After **resuming,** the app is **running**. This is when the Facebook app has
    control of the screen and the greater share of system memory and processing power
    and is receiving the details of the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about our example when we switched from the Facebook app to the email
    app?
  prefs: []
  type: TYPE_NORMAL
- en: As we tap to go to read our email, the Facebook app will have entered the **paused**
    phase, followed by the **stopping** phase, and the email app will enter the **being**
    **created** phase, followed by **resuming**, then **running**.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to revisit Facebook, as in the scenario earlier, the Facebook app
    will probably skip being created and go straight to **resume** and then be **running**
    again, most likely exactly in the place we left it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at any time, Android can decide to **stop** then **destroy** an app.
    In which case, when we run the app again, it will need to be **created** at the
    first phase all over again.
  prefs: []
  type: TYPE_NORMAL
- en: So, had the Facebook app been inactive long enough, or perhaps Angry Birds had
    needed so many system resources that Android had **destroyed** the Facebook app,
    then our experience of finding the exact post we were previously reading might
    have been different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all this phase stuff is starting to get confusing, then you will be pleased
    to know that the only reasons to mention it are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You know it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We occasionally need to interact with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take things step by step when we do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know about the lifecycle phases, let's learn about how we can handle
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How we handle the lifecycle phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are programming an app, how do we interact with this complexity? The
    good news is that the Android code that was autogenerated when we created our
    first project does most of it for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed, we just don't see the methods that handle this interaction,
    but we do have the opportunity to **override** them and add our own code to that
    phase if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: This means we can get on with learning Java and making Android apps until we
    come to one of the occasional instances where we need to do something in one of
    the phases.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If our app has more than one activity, they will each have their own lifecycle.
    This doesn't have to complicate things and overall it will make things easier
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up is a quick explanation of the methods provided by Android, for our
    convenience, to manage the lifecycle phases. To clarify our discussion of lifecycle
    methods, they are listed next to their corresponding phases that we have been
    discussing. However, as you will see, the method names make it clear on their
    own where they fit in.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a brief explanation or suggestion for when we might use a given
    method and thereby interact during a specific phase. We will meet most of these
    methods as we progress through the book. We have of course already seen `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate`: This method is executed when the activity is being `setContentView`),
    graphics, and sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStart`: This method is executed when the app is in the **starting** phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume`: This method runs after `onStart` but can also be entered (most
    logically) after our activity is resumed after being previously paused. We might
    reload previously saved user data (such as an important note) from when the app
    was interrupted, perhaps by a phone call or the user running another app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause`: This occurs when our app is `onResume`. Activities always transition
    into a paused state when another UI element is displayed on top of the current
    activity (for example, a pop-up dialog) or when the activity is about to be stopped
    (for example, when the user navigates to a different activity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStop`: This relates to the `onCreate`, such as releasing system resources
    or writing information to a database. If we reach here, we are probably going
    to get destroyed sometime soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroy`: This is when our activity is finally being **destroyed**. There
    is no turning back from this phase. It''s our last chance to dismantle our app
    in an orderly manner. If we reach here, we will be going through the lifecycle
    phases from the beginning next time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram shows the likely flows of execution between the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 –  Flow of execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16773_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Flow of execution
  prefs: []
  type: TYPE_NORMAL
- en: All the method descriptions and their related phases should appear straightforward.
    The only real question is what about the running phase? As we will see when we
    write our code in the other methods/phases, the `onCreate`, `onStart`, and `onResume`
    methods will prepare the app, which then persists, forming the running phase.
    Then the `onPause`, `onStop`, and `onDestroy` methods will occur afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at these lifecycle methods in action with a mini app. We will
    do so by overriding them all and adding a `Log` message and a `Toast` message
    to each. This will visually prove the phases our app passes through.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle demo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will do a quick experiment that will help familiarize ourselves
    with the lifecycle methods our app uses as well as giving us a chance to play
    around with a bit more Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to start a new project and then we can add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Basic Activity** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the project **Lifecycle Demo**. Of course, the code is in the download
    bundle in the [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119) folder should
    you wish to refer to it or copy and paste it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for Android Studio to generate the project files and then open the `MainActivity.java`
    file in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have created a new project with all the default settings. We will only need
    the `MainActivity.java` file for this demonstration and will not be building a
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the lifecycle demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `MainActivity.java` file, find the `onCreate` method and add these two
    lines of code just before the closing curly `}` brace, which marks the end of
    the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire `onCreate` method should now look like this next code, where the
    highlighted code is the two lines we just added and the `…` is where we have skipped
    some lines of autogenerated code to make the book more readable. For the full
    code listing, check the `MainActivity.java` file in the download bundle. Here
    is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember you will need to use the *Alt* + *Enter* keyboard combination twice
    to import the classes needed for `Toast` and `Log.`
  prefs: []
  type: TYPE_NORMAL
- en: 'After the closing curly brace, `}`, of the `onCreate` method, leave one clear
    line and add the following five lifecycle methods and their contained code. Also
    note that it doesn''t matter in what order we add our overridden methods. Android
    will call them in the correct order regardless of the order in which we type them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, let's talk about the code itself. Notice that the method names all correspond
    to the lifecycle methods and phases we discussed earlier in this chapter. Notice
    that all the method declarations are preceded by the `@Override` line of code.
    Also see that the first line of code inside each method is `super.on...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly is going on here is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android calls our methods at the various times we have already discussed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Override` keyword shows that these methods replace/override the original
    version of the method that is provided as part of the Android API. Note that we
    don't see these overridden methods but they are there, and if we didn't override
    them these original versions would be called by Android instead of ours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `super.on...`, which is the first line of code within each of the overridden
    methods, then calls these original versions. So, we don't simply override these
    original methods in order to add our own code – we also call them, and their code
    is executed too.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For the curious, the keyword `super` is for super-class. We will explore method
    overriding and super classes in several chapters as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code that you added will make each of the methods output one `Toast`
    message and one `Log` message. However, the messages that are output vary, as
    can be seen by the text in between the double quote marks `""`. The messages that
    are output will make it clear which method produced them.
  prefs: []
  type: TYPE_NORMAL
- en: Running the lifecycle demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have looked at the code, we can play with our app and learn about
    the lifecycle from what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the app on either a device or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Watch the screen of the emulator and you will see the following appear one
    after the other as `Toast` messages on the screen: **In onCreate**, **In onStart**,
    and **In onResume.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the following messages in the logcat window. If there are too many messages,
    remember you can filter them by setting the **Log level** drop-down to **Info**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now tap the back button on the emulator or the device. Notice you get the following
    three `Toast` messages in exactly this order: **In onPause**, **In onStop**, and
    **In onDestroy**. Verify that we have matching output in the logcat window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, run a different app – perhaps the *Hello Android* app from[*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java,* (but any app will do) – by tapping its icon on the
    emulator/device screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now try the following: open the task manager on the emulator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)*, Exploring Android
    Studio and the Project Structure,* and the *Using the emulator as a real device*
    section for how to do this on the emulator if you are unsure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see all the recently run apps on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Lifecycle Demo** app and notice that the usual three starting messages
    are shown. This is because our app was previously destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, however, tap the **task manager** button again and switch to the **Hello
    Android** app. Notice that this time, only the **In onPause** and **In onStop**
    messages are shown. Verify that we have matching output in the logcat. The app
    has *not* been destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, again using the `onCreate` was not required to get the app running again.
    This is as expected because the app was not previously destroyed, merely stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's talk about what we saw when we ran the app.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the lifecycle demo app output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started the lifecycle demo app for the first time, we saw that the `onCreate`,
    `onStart`, and `onResume` methods were called. Then, when we closed the app using
    the `onPause`, `onStop`, and `onDestroy` methods were called.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we know from our code that the original versions of all these methods
    are also called because we are calling them ourselves with the `super.on...` code,
    which is the first thing we do in each of our overridden methods.
  prefs: []
  type: TYPE_NORMAL
- en: The quirk in our app's behavior came when we used the task manager to switch
    between apps – when switching away from the lifecycle demo, it was not destroyed
    and, subsequently, when switching back, it was not necessary to run `onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: Where's my Toast?
  prefs: []
  type: TYPE_NORMAL
- en: The opening three and closing three `Toast` messages are queued and the methods
    have already completed by the time they are shown. You can verify this by running
    the experiments again and will see that all three starting/closing log messages
    are output before even the second `Toast` message is shown. However, the `Toast`
    messages do reinforce our knowledge about the order, if not the timing.
  prefs: []
  type: TYPE_NORMAL
- en: It is entirely possible (but not that likely) that you got slightly different
    results when you followed the preceding steps. What we know for sure is that when
    our apps are run on thousands of different devices by millions of different users
    who have different preferences for interacting with their devices, Android will
    call the lifecycle methods at times we cannot easily predict.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what happens when the user exits the app by pressing the home button?
    When we open two apps one after the other and then use the back button to switch
    to the earlier app, will that destroy or just stop the app? What happens when
    the user has a dozen apps in their task manager and the operating system needs
    to destroy some apps that were previously only stopped; will our app be one of
    the "victims"?
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, test out all the preceding scenarios on the emulator. But
    the results will only be true for the one time you test it. It is not guaranteed
    that the same behavior will be shown every time and certainly not on every different
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last some good news! The solution to all this complexity is to follow a
    few simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your app ready to run in the `onCreate` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load your user's data in the `onResume` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save your user's data in the `onPause` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tidy up your app and make it a good Android citizen in the `onDestroy` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch out throughout the book for a couple of occasions when we might like to
    use `onStart` and `onStop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do what we mentioned above (we will see how over the course of the book),
    we can just stop worrying about all this lifecycle stuff and let Android handle
    it! There are a few more methods we can override as well. So, let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Some other overridden methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that there are two other autogenerated methods in the code
    of all our projects using the Basic Activity template. They are `onCreateOptionsMenu`
    and `onOptionsItemSelected`. Most Android apps have a pop-up menu so Android Studio
    generates one by default; including the basic code to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the XML that describes the menu in `res/menu/menu_main.xml` from
    the project explorer. The key line of XML code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This describes a menu **item** with the text **Settings**. If you run any of
    the apps built with the Basic Activity template we have created so far, you will
    see the button as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Settings button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16773_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Settings button
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tap the button, you will see it in action as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Settings option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16773_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Settings option
  prefs: []
  type: TYPE_NORMAL
- en: So, how do the `onCreateOptionsMenu` and `onOptionsItemSelected` methods produce
    these results?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onCreateOptionsMenu` method loads the menu from the `menu_main.xml` file
    with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is called by the default version of the `onCreate` method, which is why we
    don't see it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We will use the pop-up menu in [*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)*,*
    *Data Persistence and Sharing,* to switch between different screens of our app.
  prefs: []
  type: TYPE_NORMAL
- en: The `onOptionsItemSelected` method is called when the user taps the menu button.
    This method handles what will happen when an item is selected. Now nothing happens
    – it just `returns true`.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add `Toast` and `Log` messages to these methods to test out the
    order and timing I have just described. I just thought it was a good time to quickly
    introduce these two methods because they have been lurking around in our code
    without an introduction and I didn't want them to feel left out.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have seen how the Android lifecycle works and been introduced to a whole
    bunch of methods we can override to interact with the lifecycle, we had better
    learn the fundamentals of Java so that we can write some code to go in these methods
    as well as our own methods.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Java code – revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that each time we create a new Android project, we also
    create a new Java **package** as a kind of container for the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about and played around with `Log` and `Toast`. We have
    also used the `AppCompatActivity` class, but in a different manner to `Log` and
    `Toast`. You might remember the first line of code in all our projects so far,
    after the `import` statements, used the `extends` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we extend a class as opposed to just importing it, we are making it our
    own. In fact, if you take another look at the line of code, you can see that we
    are making a new class with a new name, `MainActivity.` but basing it on the `AppCompatActivity`
    class from the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `AppCompatActivity` class is a slightly modified version of the `Activity`
    class. It gives extra features for older versions of Android that would otherwise
    not be present. Everything we have discussed regarding `Activity` is equally true
    for `AppCompatActivity`. We will see some more variations in the `Activity` class
    as we progress. It is entirely possible that you have a different class in place
    of `AppCompatActivity`, dependent upon changes that have taken place since this
    was written. Updates of Android Studio will sometimes change the default `Activity`
    class that it uses when it creates a new project. If the name ends in `...Activity`,
    it doesn't matter because everything we have discussed and will discuss is equally
    true. I will just refer to this class simply as `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary:'
  prefs: []
  type: TYPE_NORMAL
- en: We can import classes to use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can extend classes to use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will eventually make our own classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The crucial point here is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes, in their various forms, are the foundations of every single line of
    code in Java. Everything in Java is or is part of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Our own classes and those written by others are the building blocks of our code
    and the methods within the classes wrap the functional code – the code that does
    the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write methods within the classes that we extend; as we did with `topClick`
    and `bottomClick` in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,*
    *First Contact: Java, XML, and the UI Designer*. Furthermore, we overrode methods
    that are already part of classes written by others – such as `onCreate` and `onPause`
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The only code, however, that we put in these methods was a few calls using `Toast`
    and `Log`. We aren't going to code the next killer app with just that. But now
    we can take some more steps.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing fragments and the lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably remember from [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer,* that the Java code in the Basic
    Activity template is not just contained in the `MainActivity.java` file. There
    are also the `FirstFragment.java` and `SecondFragment.java` files. These files,
    we learned, contain the code that controls what happens when the user navigates
    between the two screens of the Basic Activity template app. The code inside these
    two files is different in structure from the `MainActivity.java` file. Here is
    a quick peek at `FirstFragment.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I have omitted much of the code from this file because it is unnecessary for
    the purpose of this introductory discussion. A `Fragment` can, and in this app
    does, represent a screen from the app. The `Fragment` classes of this app and
    other apps that contain them are controlled by the `Activity` class(es). We will
    look closely at the `Fragment` class in [*Chapter 24*](B16773_24_ePub_RK.xhtml#_idTextAnchor411),
    *Design Patterns, Multiple Layouts, and Fragments*. The thing to notice here is
    that the `Fragment` class has an `onCreateView` method.
  prefs: []
  type: TYPE_NORMAL
- en: When our app uses one or more instances of the `Fragment` class, they will also
    be a part of the Android lifecycle and the `Fragment` class has its own set of
    lifecycle methods, of which `onCreateView` is one.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the OS lifecycle, the `Activity` class, and the `Fragment` class
    interact with each other will be explained in [*Chapter 24*](B16773_24_ePub_RK.xhtml#_idTextAnchor411)*,
    Design Patterns, Multiple Layouts, and Fragments*. It is just worth knowing for
    now that they are all interconnected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about the Android lifecycle and how the operating system calls
    set methods at set times.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen that it is not only us that can call our code. The operating
    system can also call the code contained within the methods we have overridden.
    By adding the appropriate code into the various overridden lifecycle methods,
    we can be sure that the right code will be executed at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do now is learn how to write some more Java code. In the next
    chapter, we'll start to focus on Java, and because we have such a good grounding
    already on Android, we will have no problem practicing and using everything we
    learn.
  prefs: []
  type: TYPE_NORMAL
