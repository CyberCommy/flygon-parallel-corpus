- en: Node and MongoDB Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dig in and start building a full-blown web application using Node
    and MongoDB, it's important that we review some of the basics. This chapter will
    give you a crash course on syntax and important topics. It is broken down into
    two parts, where the first half focuses on JavaScript or Node, and the second
    half covers MongoDB. You will gain insight into some of the more common and powerful
    tools available to you, and a lot of sample code will be reviewed to get you up
    to speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of the JavaScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node's package manager, npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a solid understanding of the syntax
    and how to use both Node and MongoDB. There's a lot to cover, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, Node.js is not just another language, but JavaScript. The
    language syntax and tools you used while coding JavaScript on the browser will
    work verbatim on the server. Node.js has additional tools that are only available
    on the server, but the language and syntax are again the same as JavaScript. I'm
    assuming you have a general understanding of the basic JavaScript syntax, but
    I will introduce JavaScript to you with a very brief primer on the language, just
    in case.
  prefs: []
  type: TYPE_NORMAL
- en: In general, JavaScript is a fairly simple language when it comes to syntax,
    and you only need to know a few important elements.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing es6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The es6, or ECMAScript, 2015 is a JavaScript language update for all types,
    values, object literals, properties, functions, and program syntaxes. The whole
    new semantics of es6 (which is similar to other languages like Java, C#, and so
    on) invites cross-platform developers to learn JavaScript with ease. Not only
    it improve the languages in syntactical aspects, it also provides new inbuilt
    tools, such as promises, proper tail calls, destructuring, modules, and so on.
    As we have already installed Node version 8, all the ECMAScript 6 features or
    es2017 till date are inclusive. If you are using a Node version less than 4.3.2,
    you will need to install trans-compilation tools like babel.js. We will be learning
    es6 by making a gradual implementation in code and a comparative study as well.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic thing you can do in pretty much any programming language is
    declare a variable. Unlike most other languages, JavaScript is a dynamically-typed
    language, which means when you declare a variable, its value can be of any type
    and can change during the course of its lifetime. However, in contrast, a strongly-typed
    language dictates that a variable defined as a `string` type must always be a
    string and must always have a value of a string. The strong typed feature is included
    in es6 which we are going to learn next. For now, to declare a variable in JavaScript,
    simply use the `var` keyword before your variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows how we declare variables and define them with
    initial values alongside their declarations. The `+` operator is used for string
    concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we use **camel** case for the variable names. It is not mandatory that
    you use camel case for variable naming, but it is more common in object-oriented
    languages to follow camel case as opposed to the underscore-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript won't complain if you forget to put a semicolon at the end of each
    statement. Instead, it will attempt to put the semicolons for you if there are
    proper statement terminations missing. This can lead to unexpected results. The
    rules of semicolon insertion are explained in this article at [http://bclary.com/2004/11/07/#a-7.9.1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, es6 has introduced two more keywords for variable declarations, namely
    `let` and `const`, has made JavaScript a lot more elegant. First, lets learn `const`
    by considering the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `const` is same as `var`. Declaring a variable with `const` makes
    itself immutable and it cannot be used for reassigning new content in itself.
  prefs: []
  type: TYPE_NORMAL
- en: One more distinction about the `const` keyword that it does not mean something
    is constant but it emphasizes one time assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It throws the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Well, Why is it needed? The recommended practice for coder is to keep things
    simple which means using a single variable to represent a single value for a time.
    However, we discussed about the dynamicity of the variable earlier which has its
    own advantages, sometimes there is need to represent a data which is immutable
    itself. Like store some credentials of server configuration or the Node packages
    itself. The usage can vary but will be applied with a single rule of one time
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: To study the `let` keyword, we need to know about the scope of variables first
    which is covered in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the scope of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the scope of variables is very important in JavaScript to gain
    a better hold of the language. Scope may be referred to as a bucket in which your
    variable or your function exists. Unlike Java and other popular languages, JavaScript
    follows function-level scoping as opposed to block-level scoping (which is now
    introduced in es6). So, this means that the variables you define will be limited
    to a scope that is bound to its parent function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding code, we can see the scope of the `inner` variable
    is limited to the parent function named `myFunction`. It won't be accessible outside
    it and will provide a `referenceError` notification. Also, the variables available
    in outer scopes are available in function scopes, and you don't need to make any
    extra effort to access them, as you have seen with the variable named `outer`
    in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to discuss in this context is the use of the `var` keyword.
    JavaScript won''t complain if you miss `var` while declaring a new variable. But
    things can get really bad if that happens. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, as the `var` keyword was skipped along with the variable declaration inside
    the inner function, JavaScript considered that this variable should be searched
    in its parent scopes, then attached it to the global scope, and ended up making
    it available everywhere. So, to avoid such issues with the code, it is always
    useful if you pass your code through code quality tools such as JSHint. The preceding
    code structure may have confused you, as it used self-invoked functions just to
    induce scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now with the arrival of es6, you can declare variables with the block scope
    rather than only the function scope. To understand the block level scoping, let''s
    go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference in preceding snippets is the declaration of variable `i`.
    The `i` variable is not accessible outside the `for` loop block.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details regarding `let` refer the link: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let)'
  prefs: []
  type: TYPE_NORMAL
- en: So that was all about scope of variables. JavaScript supports a number of data
    types. Let's take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data types are the base of any language. The data types available in JavaScript
    are
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol (new in es6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code, every variable we declare will contain values that belong to any
    of the preceding types. Number, String, and Boolean types are quite straightforward
    to understand. These comes under the primitive data types supported by the language.
    Here, one important point is to note that JavaScript has no distinction between
    integers or floating points at its type level.
  prefs: []
  type: TYPE_NORMAL
- en: Types such as array, function, regex, and date come under the object data type.
  prefs: []
  type: TYPE_NORMAL
- en: They are considered to be composite data types. So the functions that you define
  prefs: []
  type: TYPE_NORMAL
- en: in your code will also be nothing but objects.
  prefs: []
  type: TYPE_NORMAL
- en: Null and undefined are two special types supported by JavaScript. Null points
  prefs: []
  type: TYPE_NORMAL
- en: to a deliberate non-value, whereas undefined points to an uninitialized value.
    So, when you just declare a variable and haven't yet initialized it with a value,
    the variable will be of undefined type. Last but not least, es6 has introduced
    a new primitive data type of symbol. They are used for unique property keys and
    constants representative concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We are not using them in context of our book, however you can visit the following
    link for more details [http://exploringjs.com/es6/ch_symbols.html](http://exploringjs.com/es6/ch_symbols.html).
  prefs: []
  type: TYPE_NORMAL
- en: So before we understand various ways to define functions, arrays, and objects,
    lets go through operators and flows.
  prefs: []
  type: TYPE_NORMAL
- en: Operators and flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript supports similar control structures to other languages in the C family.
    Conditional statements are written with `if` and `else`, and you can chain together
    the statements using `else-if` ladders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Control statements can be written using `while`, `do-while`, `for`, and `switch`
    statements. One important thing to consider while writing conditions in JavaScript
    is to understand what equates to `true` and/or `false`. Any value greater or less
    than zero, not null, and not undefined equates to `true`. Strings such as `0`,
    `null`, `undefined`, or `empty` strings equate to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample examples using `while`, `do-while`, `for`, and `switch` statements
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Another important thing will be to understand the basic difference between
  prefs: []
  type: TYPE_NORMAL
- en: the comparisons using `==` and `===`. The `==` comparisons should be used where
  prefs: []
  type: TYPE_NORMAL
- en: 'the type of variable is not your concern; and if the data type of the variables
    also should be compared, then you should opt for a `===` comparison symbol as
    given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here in the code snippet, the first condition evaluates to true while the second
    doesn't. So while you code, it's always safer to depend on strict (`===`) equality
    checks as a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: It's always advised to run your code through code quality tools such as JSHint
    before you approve them for your application. You can automate the code quality
    checks via task runners such as Grunt so that each time we make a change in our
    code, the code quality tool runs and presents if there are any potential issues
    with the code that has been written.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript objects, the arrays and even functions we create fall into the
    same data type: `Object`. Declaring an object is a fairly straightforward process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You may add properties or attributes to this object, which may belong to any
    type. It means you can add arrays, functions, or even other objects as properties
    of this object. Adding a new property to this object can be done in any of the
    two ways shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example where we add arrays and functions as properties of
    this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that we defined a basic object called `person`
    and assigned it some properties and a function. It's important to note that the
    use of the `this` keyword in the `fullName` function. The `this` keyword refers
    to the object that the function is a part of. So via the `this` keyword, the function
    will be able to access the other properties that are part of the object it belongs
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the approach of adding properties after the object creation, we
    can also attach the initial object properties as part of its creation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are creating objects without specifying any class
    from which they should be created by using `{}`. So, this results in the creation
    of this new object from the `Object` base class from which other composite types
    such as arrays and functions are extended. So, when you use `{}`, it is equivalent
    to a new `Object()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the objects we create via the use of the object literal `{}` are instances
    of the `Object` class. To define custom classes for our application, we will need
    to use functions and prototypes. Mozilla has a fairly good tutorial on introducing
    this whole point, available at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
    The es6 has enhanced the object properties by adding various features as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost of all is **property shorthand**. Now with es6 we can assign
    property using a variable. Lets understand this using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the variable value is implicitly assigned to object
    property and there is no need to have a property specified while declaring an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The next amazing feature is computation of property key in object literals.
    To learn this feature, let's add a property to the preceding object called `book`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The es6 introduces us to one of the most awaited feature called the **template
    literals**. You may have noticed a kind of interpolation operation used in preceding
    snippets with placeholder `${}`. It is nothing but a concatenation of variable
    in string without using any operator, such as `+`. The template literal enhances
    the feature of readability in JavaScript which is quite essential. For more information
    follow the link [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the preceding code, we note that es6 enables us to perform any
    computation for property names using a square bracket. Lastly, we can follow an
    elegant feature of the method notation in the `object` property for all functions.
    This can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Always remember that objects are nothing but an address of a memory location
    and not actual storage. For instance, `firstName: ''Jason''` is stored in memory
    location with address `person.firstName`. Until now, we have learned about a single
    point of storage called as variables, moving further let''s learn multiple point
    of storage.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays work the same way in JavaScript as they do in pretty much any other
    language. They are zero indexed, and you can declare a variable as an empty array
    or a pre-populated array. You can manipulate the items in an array, and arrays
    are not fixed in length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To be more precise, you can consider arrays as extended child classes of the
    base `Object` class with extra implementations of `Array` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are first-class citizens in JavaScript. What this means is that a
    `function` by itself is an object, so it can be treated as such and extended with
    properties and additional functions to the base `Object` class. We will see a
    lot of situations where we pass functions as parameters to other functions and
    return functions from other function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will take a standard function (in this case, `myFunction`). We will
    assign this function a `timesRun` property, just like we do for any other object
    during its execution, and see how to refer to that property later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in the preceding example, by using the var keyword, we can
    define functions in the same way as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both methods are almost identical in the preceding sample code. The first method
    is the most common way to define a function, and is called the **named function
    approach**. The second method discussed here is the function expression approach,
    where you assign the unnamed function as a reference to a variable and keep it
    unnamed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The single most important difference between these two approaches is related
    to a concept called JavaScript **hoisting**. Basically, the difference is that
    when you adopt a function expression strategy, the function will not be available
    in its containing scope till the point, its definition statement gets executed.
    In the named function approach, regardless of the position you define it at, the
    function will be available throughout the containing scope as given in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample code snippet, `function one` can be invoked from anywhere
    in its parent scope. But `function two` will not be available before the point
    where its expression is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript hoisting is the process by which the function definitions and variable
    declarations are moved to the top of the containing scope by the JS interpreter
    before the script is executed. So, in the previous case of named functions, the
    definition was moved to the top of the scope. However, for the function expression,
    only the declaration of the variable moved to the top of the scope, setting it
    to undefined till the point in the script where it was actually executed. You
    can read more about the concept of hoisting at [http://code.tutsplus.com/tutorials/JavaScript-hoisting-explained--net-15092](http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092).
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions and callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you will need to use a temporary function that you don't necessarily
    want to declare ahead of time. In this type of scenario, you can use an anonymous
    function, which is simply a function that is declared at the time you need it.
    This is similar to the function expression context we explored earlier, with a
    simple difference that the function isn't assigned to a variable so it has no
    way of being referenced to later. The most common use of anonymous functions is
    when they are defined as a parameter to another function (most notably when used
    as a *callback*).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common places to use an anonymous function (which also acts
    as a callback even if you didn''t realize it) is with `setTimeout` or `setInterval`.
    These are two standard JavaScript functions that will execute code after a specified
    delay (in milliseconds) or repeat the execution of code after a specified delay.
    Here is an example of one of them, `setTimeout`, using an anonymous inline function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the anonymous function was passed as the first parameter to
    `setTimeout` because `setTimeout` expects a function. You can, if you desire,
    declare the function ahead of time as a variable and pass that to `setTimeout`
    instead of the inline anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous function just acts as a clean inline disposable function.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are important because one of the most powerful (and confusing) features
    of JavaScript is that it's asynchronous. This means that every line executes sequentially,
    but it doesn't wait around for code that might be taking longer than it should
    (even if by design). We have explored this via an example in the first chapter
    while looking into the asynchronous nature of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla has a detailed tutorial on JavaScript concepts, which we advise you
    to go through once you finish this chapter. The tutorial includes highly advanced
    concepts, such as closures, that were not covered in this chapter due to the depth
    of the topic. So refer to this Mozilla Development Network article at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is the standard syntax used when
    dealing with data in JavaScript as well as most other languages and web services.
    The basic premise of JSON is that it looks exactly like a standard JavaScript
    object with a few strict exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON is pure text. There are no data types with properties; that is, date values
    are stored as strings and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All names and string values must be in double quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be no functions as properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at a pretty standard JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you are at all familiar with XML, JSON is somewhat similar, except it is
    much easier to read and make sense out of. As described best by the ECMA, "*JSON
    is a text format that facilitates structured data interchange between all programming
    languages"*.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basics of JavaScript out of the way, let's focus on some of the basics
    of Node. We will start by understanding the node.js core architecture. The significance
    of different node features lies in its architecture and way it works. Let us study
    it carefully in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web application normally follows three tier web architecture consisting
    of client, web server, and data source. In our context, we have created a web
    app server using Node.js. As we discussed in [chapter 1](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml),
    *Welcome to JavaScript in The Full Stack*, Node.js follows a single threaded architectural
    model. To reduce the memory leak and understand asynchronousity while writing
    the code, we need to understand how Node.js works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts a visual representation of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adb24843-8871-4455-9c64-88a3da79ef3d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every processing component is sequenced in the following order"
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a request (consider an HTTP request).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chrome's v8 engine is a **just-in-time** (**JIT**) compiler. Once the request
    is received at the server, v8 converts the JavaScript code to the machine code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The C++ APIs within the Node.js core provide a binding for other system-level
    components. Binding is basically a wrapper library so that a code written in one
    language can communicate with a code written in another language. This API is
    responsible for emitting an event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the event is emitted, it is stored in the **event queue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **eventloop** is responsible for fetching the event from the queue and executing
    it in the callstack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an event requires an asynchronous operation to be done, such as using database
    files, it switches its execution context to another worker thread and gets executed.
    This is done by libuv. The libuv library is responsible for handling the asynchronous
    behavior of an event life cycle in the system. It is written in C. It maintains
    a pool of threads to handle asynchronous requests such as I/O and network-related
    operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the asynchronous operation is completed, it returns the callback. The callback
    remains in the event queue until the callstack gets empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the callstack is empty, the eventloop pulls the callback from the event
    queue and executes it in the callstack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventually, the event returns the data to the Node API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each loop, it performs a single operation. Though the operations are performed
    sequentially, this single-threaded mechanized eventloop is so fast that it provides
    an illusion of concurrency. A single thread can utilize a single core of the system;
    hence, it provides better performance and minimal response time to client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Event-driven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, one of the most powerful features of Node is that it is event-driven.
    This means that almost all the code you write in Node is going to be written in
    a way that is either responding to an event or is itself firing an event (which
    in turn will fire other code listening for that event).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code that we''ll write in a later chapter that handles
    connecting to a MongoDB server using Mongoose, a popular Node.js MongoDB **Object
    Document Mapper** (**ODM**) module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we tell our `mongoose` object to connect to the server provided as a
    string parameter to the function. Connecting will take an undetermined amount
    of time though, and we have no way of knowing how long. So, what we do is bind
    a listener to the `open` event on the `mongoose.connection` object. With the use
    of the on keyword, we are indicating that when the `mongoose.connection` object
    triggers an `open` event, it executes the anonymous function that was passed in
    as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we reviewed the idea of asynchronous JavaScript code in the browser
    using `setTimeout;` the principles apply more strongly in the world of Node. As
    you may be making a number of network-dependent connections to different REST
    API services, database servers, and anything else, it is important that your code
    can be executed smoothly and has proper callback usage in place whenever each
    service responds.
  prefs: []
  type: TYPE_NORMAL
- en: The module system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an effort to make the code as modular and reusable as possible, Node uses
    a module system that allows you to better organize your code. The basic premise
    is that you write a code fulfilling a single concern, and export this code using
    `module.exports` (or simply `exports`) as a module that serves that single purpose.
    Whenever you need to use that code elsewhere in your code base, you will require
    that module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using this system, it is simple to reuse the functionality in a module (in this
    case, the `dowork` module) in a number of other files. Furthermore, the individual
    files of a module act as a private namespace, which means every file defines a
    module and is executed separately. Any variables declared and used within the
    module file are private to that module and not exposed to any code that uses the
    module via `require()`. The developer has control over which part of module will
    be exported or not. Such implementation of modules is called as the **commonJs**
    modules pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude module system in Node.js, we need to learn about the `require`
    keyword. The `require` keyword accepts an address of a file as string and provides
    it to JavaScript engine to compile it into a method `Module._load`. The `Module._load`
    method is executed for first time, it actually loads from the exported file and
    further it is cached. Caching is done so as to reduce the number of file reads
    and can speed up your application significantly. In addition, when a module is
    loaded next time, it provides an instance of that loaded module from cache. This
    allows sharing of modules across the project with the state of singleton. At the
    end, the `Module._load` method returns the `module.exports` property of the addressed
    file on their respective execution.
  prefs: []
  type: TYPE_NORMAL
- en: The module system extends infinitely as well. Within your modules, you can require
    other modules and so on and so forth. Make sure while importing it, do not cause
    so called a **cyclic** dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cyclic or circular dependency is a situation when a module requires itself
    directly or indirectly. We can learn about this more from the discussion in the
    following link :'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js](https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js).'
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Node.js core literally has hundreds of modules available for you to use
    while writing your applications. These modules are already compiled into binary
    and are defined within Node.js source code. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like other languages, the Node.js core also provides an ability to interact
    with filesystem using the `fs` module. This module is equipped with different
    methods for performing different operations on file synchronously as well as asynchronously.
    Refer [chapter 1](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml). *Welcome to JavaScript
    in The Full Stack* to learn more about the difference of sync and async. The synchronous
    methods of `fs` are suffixed by the keyword Sync for instance `readFileSync`.
    For all reviewing the module in depth refer the following link : [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTTP module is one of the most important module in Node.js core. HTTP module
    provides functionality to implement an HTTP client as well as server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the minimum code required to create a basic server and a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Server** | **HTTP Client** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Considering the preceding code, once the module is required, we use an instance
    of the HTTP Object to either create a server or to request a server on the other
    side. The `createServer` method requires a callback as a parameter. This `callback`
    is called whenever the server is hit by an HTTP request. Further, it also provides
    a response object as a parameter to handle the response back accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Net
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding HTTP module is wired using the net module. According to documentation
    of the node.js api, the net module provides an asynchronous network API for creating
    stream-based TCP or IPC servers. This is one of the compiled binary library of
    core Node, which interacts with the internal C library called libuv. The libuv
    library is responsible for handling asynchronous request such as I/O and network-related
    operations. The best documentation to refer is Node''s own documentation: [https://nodejs.org/api/net.html](https://nodejs.org/api/fs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stream is one of the most significant module among the core modules. To
    define the stream in simple words, it is the flow of data received as small data
    chunks from a particular source. At the receiver''s end, it might neither have
    all the stream data nor it will have to fit it memory all at once. This allows
    us to handle a large amount of data with limited resources. We can visualize the
    stream by an analogy given by Dominic Denicola. According to him:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Streams are to asynchronous iterables as arrays are t synchronous iterables".'
  prefs: []
  type: TYPE_NORMAL
- en: Consider if we need to read a large file of data in the environment where multiple
    read/write operations takes place. In such cases, streams provides a powerful
    abstraction to handle the low-level I/O system calls while still providing performance
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The internal stream module should not be used directly so as to avoid the behavioral
    changes between Node versions. However, we can use the wrapper modules like readable-streams
    on the npm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although, streams are not extensively used in context of our book, it is one
    of the backbone feature of Node.js core used by its internal modules itself and
    has always been a big part of Node.js ecosystem. To learn more about streams follow
    the link: [https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/](https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definitely make sure to check out the online docs on Node at: [http://nodejs.org/api](http://nodejs.org/api),
    to see the full list of modules available in Node''s core and see plenty of sample
    code and explanations.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing modules using npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module system in Node is very powerful that consuming a third-party module
    written by other developers is a piece of cake. Node includes its own package
    manager called **npm**, which is a registry that currently contains over 475,000
    modules written in Node. These modules are completely open source and available
    to you via a few short commands. In addition, you can release your own personal
    modules via npm and allow anyone in the world to use your feature!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to include a popular web framework, `express`, in your
    project (the one we will be using later in this book). There are two simple steps
    required to download a module and use it in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Literally, it's that simple! From the command line of the folder
    where your project is located, simply execute `npm install package-name`, and
    the package will be downloaded from npm and stored in a folder called `node_modules`
    within your project. If you browse through the `node_modules` folder, you will
    find a folder for the package you installed, and within that folder, you will
    find the raw source code for the package itself. Once the package is downloaded,
    it's as simple as using `require()` within your code.
  prefs: []
  type: TYPE_NORMAL
- en: There may be times when you want to install a Node package globally, for example,
    when using a popular command-line build tool called Grunt.js. To install an npm
    package globally, simply include the `-g` or `--global` flag, and the module will
    be installed as a global executable instead. When installing npm packages globally,
    the source files for the package are not stored within the `node_modules` folder
    of a specific project, but instead within a `node_modules` folder in a system
    directory of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: A really powerful feature of npm is that it allows a quick, easy, and consistent
    way for other developers to boot up your code in their local environment. Node
    projects, typically, include a special file called `package.json` that contains
    information about the project as well as a list of all npm packages that the project
    depends on. A developer with a copy of your local code can simply execute `npm
    install` to have every dependency downloaded and installed locally using this
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The npm install flag `--save` or `--save-dev` is required if you want the dependency
    that you are installing to be saved to the `package.json` file. If you are starting
    a new project and don''t want to create a `package.json` file by hand, you can
    simply execute `npm init` and answer a few quick questions to get a default `package.json`
    file quickly set up. You can leave every question blank during `init` and accept
    the default values if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `dependencies` and `devDependencies` sections have `express` and `grunt`
    listed. The difference between these two sections is that the `dependencies` section
    is absolutely critical for the app to function properly and the `devDependencies`
    section has only packages that need to be installed for a developer to use during
    the development of the project (such as Grunt for various build steps, testing
    frameworks, and so on). If you are confused about the use of the `^` symbol in
    the package versions, it's used to update the dependency to the most recent minor
    version or patch version (the second or third number). `^1.2.3` will match any
    1.x.x release including 1.3.0, but will hold off on 2.0.0\. So, in our case `^3.5.1`
    of Express.js will look for the most recent minor version of express.js but will
    not take 4.0.0, as it's a major version.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since MongoDB is largely powered by JavaScript, the Mongo shell acts as a JavaScript
    environment. In addition to being able to execute regular Mongo queries, you can
    also execute standard JavaScript statements. Most of the items mentioned earlier
    in the JavaScript primer apply directly to the Mongo shell as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will primarily focus on the various ways to perform standard
    CRUD operations via the Mongo shell.
  prefs: []
  type: TYPE_NORMAL
- en: The Mongo shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access the Mongo shell, simply execute `mongo` from any terminal. The Mongo
    shell requires the `mongod` server to be currently running and available on the
    machine, as the first thing it does is connect to the server. Use the following
    command to access the Mongo shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, when you first launch Mongo, you are connected to the local server
    and set to use the `test` database. To display a list of all databases on the
    server, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch databases to any of those listed in the output of `show dbs`, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: An interesting thing to note is that if you use `use` on a database that doesn't
    exist,
  prefs: []
  type: TYPE_NORMAL
- en: 'one will be created automatically. If you are using an existing database and
    want to view a list of collections in the database, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case of my `chapter3` database, I had no existing collections since
    it was automatically generated as a new database for me. Collections in MongoDB
    are similar to the tables in a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are working with the `chapter3` database, which is a brand new database,
    there are currently no collections in it. You can use any collection (table) you
    want by simply referring to a new collection name with the `db` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing a `find` operation on an empty collection simply returns nothing.
    Let''s insert some data so we can experiment with some queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After we perform a simple insertion (basically of a JavaScript JSON object),
    we will perform another `find` operation on the collection and get our new record
    returned, this time with an additional `_id` field added. The `_id` field is Mongo's
    method for tracking a unique identifier for every document (record). We also chained
    the `pretty()` function to the end of the `find()`, which outputs the results
    a little more nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and insert a few more records, so you have some data to play with for
    the next section when we go over querying.
  prefs: []
  type: TYPE_NORMAL
- en: Querying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Querying and searching for documents in a MongoDB collection is pretty straightforward.
    Using the `find()` function by itself with no parameters will return every document
    in the collection. To narrow down the search results, you can provide a `JSON`
    object as the first parameter with as much or as little specific information to
    match against as you wish, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can include additional parameters to make the search more precise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With each result set, every field is included. If you want to only return a
    specific set of fields with the result, you can include `map` as the second parameter
    to `find()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `_id` field will always be included by default, unless you specifically
    state that you don't want it included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can use query operators to search for things that are within
    ranges. These include greater than (or equal to) and less than (or equal to).
    If you want to perform a search against a collection of homework, and you want
    to find every document with a score within the B range (80-89), you can execute
    the following search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use `regex` while performing a search to return multiple matching
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query will return every document that contains the word `Krol`.
    You can get as advanced as you want with `regex` statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that you are going to be returning multiple documents on a query
    and only want the first result, use `findOne()` in place of a regular `find()`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update a record, use the `update()` function, but include a find query as
    the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a bit of a catch here. If you perform a new `find({ name: ''Jason
    Krol'' })` operation, something strange happens. No data is returned. What happened?
    Well, the second parameter in the `update()` function is actually the new version
    of the complete document. Since, you only wanted to update the `website` field,
    what actually happened was that the document that was found was replaced with
    the new version that consists of only the `website` field. To reiterate, the reason
    this happens at all is because with NoSQL such as MongoDB, the document does not
    have a set number of fields (as a relational database does). To fix this problem,
    you should use the `$set` operator instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be a time when you want to update a document, but the document itself
    may or may not exist. What happens when the document does not exist, and you''d
    like a new one to be created instantly based on the updated values you provide?
    Well, there''s a handy function just for that. Pass `{upsert: true}` as the third
    parameter to the `update()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If we have a document with a `name` field that matches `Joe Smith`, the `website`
  prefs: []
  type: TYPE_NORMAL
- en: field will be updated (and the `name` field preserved). However, if we do not
    have
  prefs: []
  type: TYPE_NORMAL
- en: a matching document, a new one will be created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting documents works almost exactly like `find()`, except instead of finding
    and returning results, it deletes those documents that match the search criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the nuclear option, you can use the `drop()` function, which will
    remove every document in a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional learning with JavaScript, I suggest you check out some of the
    following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla Developer Network at [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secrets of the JavaScript Ninja*, *John Resig*, *Bear Bibeault*, *Manning*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning JavaScript Design Patterns*, *Addy Osmani*, *O''Reilly*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript: The Good Parts*, *Douglas Crockford*, *O''Reilly*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node API online documentation is going to be your best bet for fully understanding
    everything that's available within the Node core set of modules. The Node API
    docs can be found at [http://nodejs.org/api](http://nodejs.org/api).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is a great website that teaches Node using actual programming
    problems that you must solve. The emphasis with these exercises is to understand
    the nuts and bolts of how Node works and get down into the fundamentals of working
    with streams, asynchronous I/O, promises, and more. Node school can be found at
    [http://nodeschool.io](http://nodeschool.io).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the creators of MongoDB offer an amazing 7-8 week online training and
    certification program completely free of charge, where you will learn everything
    you need to be a true MongoDB master. This can be found at MongoDB University
    at [https://university.mongodb.com](https://university.mongodb.com).
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to dive in and start writing some real code!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you took a crash course on the basics of JavaScript, Node.js,
    and MongoDB. In addition, you learned about Node's package manager, npm. For further
    learning, additional resources were provided for JavaScript, Node.js, and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will write your first Node web server using Express.js
    and get started with creating a complete web application.
  prefs: []
  type: TYPE_NORMAL
