- en: Chapter 3. Numerical Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we reviewed some of the key mathematical models used
    to describe the behavior of the underlying assets of financial derivatives. We
    saw, in particular, how these models are used to describe the future behavior
    of these assets based on the information we have today. These models are generally
    expressed in terms of SDEs and **Partial Differential Equations (PDEs)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to describe the three main numerical methods
    used in the financial markets today in the context of financial derivatives. They
    are a way to use actual numerical values to the abstract mathematical formulas
    we saw in the previous chapter. These numerical methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monte Carlo** (**MC**) simulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binomial Trees** (**BT**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finite Difference Methods** (**FDM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of the Bento Box template, this chapter corresponds to box 3—numerical
    methods. There is a fourth family of methods, less frequently used, called **quadrature
    methods**, which are used for numerical integration. These will not be discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The Monte Carlo simulation method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monte Carlo simulation is named after the famous casino in the principality
    of Monaco. It is the most widely used numerical method to price financial derivatives
    in the industry because of its simplicity, flexibility, and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of the method is to construct a simulation engine that will allow
    us to predict a number of possible ways (or trajectories) in which the underlying
    assets can evolve in the future. These trajectories can be thought of as potential
    economic or financial scenarios. With MC simulation, we attempt to answer questions
    such as "given the observed price of Vodafone stock today, what could be the likely
    prices of the stock each day for the next month?"
  prefs: []
  type: TYPE_NORMAL
- en: As we cannot be certain of the future evolution of prices, our result needs
    to be based on probability, and, thus, we need large number of samples. Using
    the stochastic models that we saw in the previous chapter to simulate one possible
    trajectory, with MC simulation, we are going to simulate many possible trajectories
    and, for each, compute the payoff that the contract would have had if the prices
    had followed that specific path in future. Afterwards, we are going to take all
    these possible payoffs and compute their expected value, that is, the mean or
    average value. This will give us an estimate of how much this contract will be
    worth in the future.
  prefs: []
  type: TYPE_NORMAL
- en: MC simulation then allows us to compute the fair price of a financial derivative
    as its expected discounted payoff. This concept stems from the financial principle
    of fair pricing, which states that the price that a contract should have if the
    sum of the cash flows that we expect to receive are the same as the sum of the
    cash flows that we expect to pay. For more details on MC simulation, you are invited
    to refer to *Monte Carlo Methods in Financial Engineering*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have an intuition of why this is the case, consider the following
    simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have bought a plain vanilla European Call option contract at
    time *t=0*. This contract will give you a payoff of ![The Monte Carlo simulation
    method](img/00095.jpeg) at maturity *t=T*. Because the value of the underlying
    at maturity is uncertain, that is, *S_T* is a random variable, the payoff function
    *H(S_T)* is also uncertain. We can write that the expected value of the payoff
    function ![The Monte Carlo simulation method](img/00096.jpeg) is the expectation
    ![The Monte Carlo simulation method](img/00097.jpeg). In addition, in a European
    Call contract, we pay a premium today in order to have the right to exercise the
    option or not at maturity *t=T*. How much should we pay for the premium for this
    contract today?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said before, in a fair value setting, what we expect to receive should
    be equal to what we expect to pay. By putting all these cashflows together (positive
    indicating to be received, negative to be paid) we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amount paid at *t=0* is written as ![The Monte Carlo simulation method](img/00098.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amount to be received at *t=T* is written as ![The Monte Carlo simulation method](img/00099.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we now compute the present value of these cash flows, we get the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Monte Carlo simulation method](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In other words, it can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Monte Carlo simulation method](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The object of the MC simulation method is precisely to help us compute the expectation
    of the payoff ![The Monte Carlo simulation method](img/00102.jpeg); once you compute
    this, discount this value to obtain the premium of the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: This same idea can be generalized to more complex settings with many complex
    payoffs and underlyings.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm of the MC method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For European-type derivatives, MC simulation is composed of the following three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generate trajectories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simulate *M* trajectories for the evolution of the underlying from *t=0* to
    maturity *t=T*. In this step, we use the discretized version of SDE that describes
    the evolution of the underlying. In our case, we use GBM as SDE, which will allow
    us to take the value of the stock from its current value *S_0* to the value at
    maturity *t=T*. A discretized version is essentially an approximate version applicable
    to finite time steps rather than continuous time steps. For more details, please
    refer to *Monte Carlo Methods in Financial Engineering*. We discretize the life
    of the option contract in *N* steps, each of size *dt*, which can be succinctly
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the end of this step, we should have a vector of *M* values for *S_T*, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These represent a set of possible scenarios for the value of the underlying
    *S* at time *t=T*. We use GBM to generate multiple paths that will serve a prediction
    of where the value of *S_T* will be at maturity.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to compute the expectation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have the set of values of the underlying at maturity, we now need to
    compute the expectation of the payoff at maturity. So we take each of these values
    and compute the payoff for each value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding equation will give us a vector of payoffs. In order to compute
    the expectation, we need to simply take the average of the payoffs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now discount the expectation to the present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step is to discount the value of the payoff from maturity to the
    present time. In order to do this, we will use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can also use continuous compounding, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the MC method](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding equation will give us the value of the derivative ![Algorithm
    of the MC method](img/00108.jpeg). Note that in this case, we have assumed that
    there is no correlation between the interest rates and the price of stock. That
    is why we can neatly separate the two effects in the preceding equation. If the
    interest rates and the price of stock were correlated, then we will not be able
    to separate the discount factor and the expectation. This no-correlation assumption
    is standard for simple pricing models.
  prefs: []
  type: TYPE_NORMAL
- en: Example of the MC method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the example where we would like to price a six-month European Call
    option on Vodafone equity (VOD.L). The current equity price of Vodafone is £100.00,
    with a volatility of 20 percent and a strike of £100\. We assume that the stock
    pays no dividends. The current risk-free rate is 5 percent pa. How do we proceed
    to solve this problem using MC simulation? We proceed using the following three
    phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generate trajectories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We apply GBM to simulate the value of VOD.L stock from the spot price today
    *S_0 = £100.00*. For simplicity, we choose to discretize the life of the option
    from *t=[0,T]* into *N=5* time steps and to do *M=5* simulations using GBM in
    discrete terms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The five trajectories will thus be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00110.jpeg)![Example of the MC method](img/00111.jpeg)![Example
    of the MC method](img/00112.jpeg)![Example of the MC method](img/00113.jpeg)![Example
    of the MC method](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The prices of the stock at maturity will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to compute the expectation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each of the values of the underlyings, we now compute the payoffs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now use the specific form of the payoff to describe a European Call option
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We apply the following numbers to the preceding equation to get the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The expected value of the preceding calculation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now discount the expectation to the present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now use the following continuous compounding to discount the expected payoff
    we just calculated in step 2 in order to determine the value of the premium:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have used only five scenarios for our MC price. In practice,
    hundreds or even thousands of scenarios are required in order to obtain an acceptable
    error. Clearly, the more scenarios you use, the more accurate the approximation.
    It is possible to derive some error-bound formulas for the MC method and show
    the speed of convergence. For more details, the reader is invited to refer to
    *Monte Carlo Methods in Financial Engineering*. Putting together all the trajectories
    for the five MC scenarios, we obtain the table shown in the following screenshot.
    Here, we see that all the trajectories start at *S0=100* and lead to some final
    value *S5*. For each trajectory, we compute the payoff *H*, which is then averaged
    to compute its expected value. The result is then discounted to obtain the present
    value of the derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the MC method](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of the Monte Carlo simulation
  prefs: []
  type: TYPE_NORMAL
- en: The Binomial Trees method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Binomial Trees** (**BT**) can be traced to the work of (Cox, Ross, and Rubinstein
    1979). Like MC methods, they are based on the idea of how the discretization of
    stock prices can jump up or down. Unlike the MC methods, BT are not based on simulation
    of many possible paths, but on the construction of a single path of possible future
    prices that bifurcates at every node. These prices, as well as their associated
    probabilities, constitute the tree. Once this tree is built, the prices of the
    underlying at maturity can be determined, and the the payoff at maturity can be
    then computed and discounted to the present time in order to determine the premium
    of the derivative.'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm of the BT method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The BT method when applied to price derivatives is composed of three phases:
    the construction of the tree of prices (forward phase), the computation of the
    payoffs (maturity phase), and the discounting of the payoffs to the present time
    (backward phase). We will now explain the BT method in the simplified context
    of a two-step BT. This can be easily generalized to an *N* step tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we assume that the underlying can only go up or down in the
    next time step. So we specify the up factor *u* to describe how much the value
    today changes to a higher value and the down factor *d* to describe how much the
    value today changes to a lower value, such that the up value is *S(T)= u S(0)*,
    and the down value is *S(T)= d S(0)*. Furthermore, refer to "Option pricing: A
    simplified approach". The formula for the up and down values can be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the formula for the probabilities of going up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The probability of going down is ![Algorithm of the BT method](img/00124.jpeg).
    We can now proceed to construct our binomial tree in the following three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The first phase is the forward phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here we construct the tree. Like in MC simulation, time is discretized in steps
    *dt* from *t=0* to *t=T*. From one step *tp*, the next price of the underlying
    can either go up or down by a factor *u* or *d* as shown in the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00125.jpeg)![Algorithm of the BT method](img/00126.jpeg)![Algorithm
    of the BT method](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, the values of the tree at maturity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In general case, we proceed in a similar manner until we arrive at the maturity
    *T*, and we have *N+1* values for the variable *S*. We will calculate these values
    with the help of the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding equation in our case can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This entire process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second phase is the payoff phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this phase, we use the values of the underlying at maturity and for each
    of them, we compute the value of the payoff, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, the equation can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following in turn are the values of the option at maturity *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, the preceding equation can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The third phase is the backward phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this final phase, we take the values of the payoff at maturity and proceed
    in a backward manner. We move from the last node to the previous nodes, by computing
    the option value as the discounted expected payoff in the previous nodes using
    the weighted probabilities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, in the second step, the equations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00137.jpeg)![Algorithm of the BT method](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And, in the first step, the equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of the BT method](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The premium of the derivative, the option price, is the value ![Algorithm of
    the BT method](img/00140.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: Example of the BT method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the example where we would like to price a six-month European Call
    option on Rolls Royce equity (RR.L). The current equity price of the stock is
    £100.00, with a volatility of 30 percent p.a. and a strike of £90\. We assume
    the stock pays no dividends. The current risk-free rate is 5 percent pa. How do
    we proceed to solve this problem using BT?
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we divide the life of the option in two steps, thus *dt=0.25*.
    The tables in the following screenshot illustrate the numerical values for each
    of the three steps applied to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of Binomial Trees pricing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first compute the up and down factors as well as the up probability *p*.
    In numerical terms, these are calculated using the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the probabilities of going up and down respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00143.jpeg)![Example of the BT method](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With all these parameters, we can now proceed to construct our tree in three
    phases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first phase is the forward phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now construct the two levels of the tree as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00145.jpeg)![Example of the BT method](img/00146.jpeg)![Example
    of the BT method](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, the values of the tree at maturity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second phase is the payoff phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this phase, we use the values of the underlying at maturity, and for each
    of them, we compute the value of the payoff, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, the equation can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following in turn are the values of the option at maturity *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, the preceding equation can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The third phase is the backward phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this final phase, we take the values of the payoff at maturity and proceed
    in a backward manner. We move from the last node to the previous nodes, by computing
    the option value as discounted expected payoff in the previous nodes using the
    weighted probabilities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, in the second step, the equations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00152.jpeg)![Example of the BT method](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And in the first step, the equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the BT method](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Finite Difference method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Finite Difference (FD) method is a numerical technique that focuses directly
    on the approximate solution of a differential equation. As shown by (Black and
    Scholes 1973) for equity financial derivatives (contingent claims), the problem
    is expressed in terms of a **Partial Differential Equation** (**PDE**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea of FDM is to discretize a differential equation. The method
    transforms the derivatives in the differential equation into quantities or ratios
    that approximate the derivatives. These quantities are not any more infinitesimal
    but finite, that is, they have a finite length. This is the origin of the name
    of finite differences. For more details, the reader can refer to *The Mathematics
    of Financial Derivatives: A Student Introduction*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following illustration where a continuous function *f(X)* and
    the first derivative of the function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding function is also known as the **slope,** which is the ratio between
    the growth (or decrease) in the function with respect to the step size *dx*. Using
    the preceding finite difference allows us to calculate the slope of the *f(x)*
    function in terms of algebraic quantities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In quantitative finance, we encounter various types of PDEs. The most important
    is the Black-Scholes PDE, which is expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now consider solving this equation in a rectangular domain in the *S* and
    *t* axes. In the *S* axis, the domain is [a,b]. In the *t* axis the domain is
    [0,T]. This can be written mathematically as the domain ![The Finite Difference
    method](img/00157.jpeg). In the case of a European Call, it has a final condition
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following are the boundary conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rather than solving the Black-Scholes PDE directly (that is, using variables
    *S* and *t*) we will be following (Wilmott et al. 1995), and we are going to propose
    a change of variables. This will transform the original PDE into an equivalent
    PDE, which is easier to solve and in fact is the classical equation of heat diffusion.
    The change of variables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00160.jpeg)![The Finite Difference method](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding equations transform the Black-Scholes PDE into the classical
    equation of heat diffusion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the European Call payoff is transformed into the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Finite Difference method](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'where the parameter *k* is: ![The Finite Difference method](img/00164.jpeg).'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm of FDM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application of FDM to the preceding PDE requires the first derivative with
    respect to time and the second derivative with respect to *x*, which leads to
    the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of FDM](img/00165.jpeg)![Algorithm of FDM](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding approximations can be derived from a Taylor series expansion.
    See (Wilmott et al. 1995) as we did in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need to discretize the domain of the function to a discrete
    set of nodes. In the case of the BS equation, there will be *N* division's (or
    *N+1*) nodes in the spatial dimension and *M* division's (or *M+1*) nodes in the
    temporal dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now put together our previous approximations, we will obtain the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of FDM](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Solving for the term on the LHS of the preceding equation, we finally obtain
    the following discretized version of the PDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm of FDM](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Where in the preceding equation ![Algorithm of FDM](img/00169.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: 'The discretized version of the PDE can be solved iteratively in time, using
    the **explicit** or **forward** finite difference method (FDM) as it''s the simplest
    possible implementation of finite difference techniques for pricing options. We
    are now ready to follow the next phases to apply the FDM, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, discretize the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform this step both in space and time dimensions with time steps ![Algorithm
    of FDM](img/00170.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: Now approximate each of the derivatives with finite differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just as we have shown in the preceding section, we will apply the principle
    of transforming the continuous derivatives of the PDE into a finite approximation.
    This finite approximation will lead to algebraic equations. In literature, this
    set of equations is called a **stencil**.
  prefs: []
  type: TYPE_NORMAL
- en: Next collocate the stencil to all the nodes of the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now apply the stencil to all the nodes in the domain with the exception of
    the nodes that represent the initial and boundary conditions. For these nodes,
    we know the value is a priori, and, hence, it does not need to be computed.
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the solution in time with the stencil until we cover the full domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In explicit FDM, you simply advance and compute the values for the unknown function
    *u*. Note that in other forms of FDM (such as implicit FDM), we need to solve
    a system of equations via a matrix problem. Please refer to (Wilmott et al. 1995)
    for further details on implicit methods.
  prefs: []
  type: TYPE_NORMAL
- en: Example of the FD method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the example where we would like to price a six-month European Call
    option on Barclays equity (BARC.L). The current equity price of BARC is £75, with
    a volatility of 30 percent p.a. and a strike of £75\. We assume the stock pays
    no dividends. The current risk-free rate is 5 percent pa. How do we proceed to
    solve this problem using the FDM?
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that equity financial derivatives satisfy the Black-Scholes PDE when
    the stock is modelled using GBM. So we solve the heat diffusion equation we described
    in the previous section. As we did earlier, we apply the following four phases
    to solve our FDM problem:'
  prefs: []
  type: TYPE_NORMAL
- en: First discretize the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We divide the domain into *N* space divisions *dS* and *M* time divisions *dt*,
    thus *N=5* and *M=4*. We first apply these values both in space and time dimensions
    with time steps ![Example of the FD method](img/00170.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we obtain six points in time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Five points in space is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now approximate each of the derivatives with finite differences as follows.![Example
    of the FD method](img/00168.jpeg)In the preceding equation, ![Example of the FD
    method](img/00173.jpeg).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collocate the stencil to all the nodes of the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the initial condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, the following is the condition with numerical values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00174.jpeg)In the preceding equation, ![Example
    of the FD method](img/00175.jpeg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final boundary condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00176.jpeg) and ![Example of the FD method](img/00177.jpeg).'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the solution in time with the stencil until we cover the full domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the internal nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00168.jpeg)![Example of the FD method](img/00178.jpeg)![Example
    of the FD method](img/00179.jpeg)![Example of the FD method](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can arrange the numerical results from our algorithm as shown in the table
    in the following screenshot, using the transformed variables (upper table) or
    the original variables (lower table), where we can find that for *S=75* and *t=0*,
    the option price is *£4,20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of the FD method](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of Finite Difference pricing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of the three key numerical methods used
    to price financial derivatives today. For each of them, we have provided an algorithm
    and a numerical example. Further, more advanced features of these methods can
    be found in excellent textbooks by (Glasserman 2003), (Kloeden and Platen 1992),
    and (Wilmott et al. 1995) as mentioned in all the previously discussed sections.
  prefs: []
  type: TYPE_NORMAL
- en: Not all methods are applicable in all situations, just like the tools in a toolbox.
    Some methods are more effective to solve some specific problems. For example,
    with a binomial tree, it is simple to evaluate American options also, while for
    Monte Carlo, it is not so straightforward. Monte Carlo is more powerful in high-dimensional
    problems, while finite differences can be used effectively for low-dimensional
    problems.
  prefs: []
  type: TYPE_NORMAL
