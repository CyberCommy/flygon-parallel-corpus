- en: '*Chapter 8*: Understanding Variables and Aliases in Cypress'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started on how variables and aliases work in Cypress, it is important
    to understand what we covered in the previous chapters on how to write tests in
    Cypress, how to configure tests, and even how to use Cypress to write applications
    in the proper way by following a test-driven development approach. The background
    information provided in the previous chapters of this book will give you a good
    grounding as we dive into how variables and aliases work. By exploring what variables
    and aliases are, we will understand how we can create references in Cypress, which
    will ease our test writing process and the complexity of our tests. Understanding
    how to use variables and aliases will not only make you write better tests but
    also write tests that are easy to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on writing asynchronous commands to make use
    of the variables and aliases that Cypress comes bundled with. We will also understand
    how we can simplify our tests by using aliases and how we can utilize the aliases
    and the variables we create in different areas of our tests such as references
    to elements, routes, and requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Cypress variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Cypress aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will have a full understanding
    of how to utilize aliases and variables in your Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we recommend that you clone the repository containing the source
    code and all the tests that we will write in this chapter from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-08` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Cypress variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will focus on what variables are in Cypress, how they are used
    in tests, and their roles in tests, especially in the reduction of test complexity.
    We will also explore different areas where we can use Cypress variables to add
    readability to our tests. By the end of this section, you will be able to write
    tests using variables and also understand where variables should be used when
    writing your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how variables in Cypress work, it is important to understand
    how Cypress executes its commands. The following code block is a test that first
    selects a button and then selects an input element, then later clicks the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block illustrates a test that should first identify a button,
    then next identify a username input, and finally, click the button. However, the
    test and execution will not happen in the way that we would normally assume. In
    our assumptions, we might think that the first command will execute and return
    the results before the second command runs, then the third command will be the
    last to execute. Cypress utilizes JavaScript **asynchronous APIs**, which control
    how commands are executed in Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous APIs are implemented such that they provide the responses of
    commands or requests as they are received, and do not necessarily wait for one
    particular request to get a response before handling other requests. The APIs
    instead return the first response that was received and continue the execution
    of the responses that have not yet been received. The non-blocking mechanism of
    making requests and receiving responses ensures that different requests can be
    made at the same time, therefore making our application appear multi-threaded,
    while in reality, it is single-threaded in nature.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code block, Cypress executes the commands in an asynchronous
    order where the responses are not necessarily returned in the order in which the
    requests are made in our test. We can, however, force Cypress to execute our tests
    as we desire, and we will cover this in the next section as we explore **closures**
    in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Closures are created when Cypress bundles together test functions and references
    to the surrounding state of the functions. Closures are a JavaScript concept from
    which Cypress borrows heavily. A test closure in Cypress would therefore have
    access to the external scope of our test and also have access to its internal
    scope, which will be created by the test function. We refer to the local functional
    scope of the test as the **lexical environment**, as is the case in JavaScript
    functions. In the following code block, we can see what closures are in Cypress
    and how variables are utilized in the closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `$submitBtn` variable is created to access the response gotten from the
    `cy.get('#submit-button')` command. Using the variable that we just created in
    the test, we can access the value that was returned and interact with it, just
    like in a normal function. In this test, we have created a test closure function
    using the `$submitBtn` variable. The `.then()` function creates a **callback function**
    that enables us to nest other commands within the code block. The advantage of
    closures is that we can control how our tests execute commands. In our test, we
    can wait until all nested commands inside the `.then()` method execute before
    running any other commands in our test. The execution behavior is further described
    by our comments in the test code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions are functions passed inside other functions as arguments
    and are then invoked inside the outer function to complete an action. When commands
    inside our `.then()` function complete running, other commands outside the function
    will proceed with their execution routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we will explore how to write a test by using variables
    and ensuring that the code within the closure is executed first before any other
    code outside and after the closure begins execution. The test will add two to-do
    items, but before the addition of the second to-do item, we will use a closure
    to verify that the code within the closure was executed first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have added a to-do item to our to-do list,
    but before we add our second item, we validate that the added to-do item is indeed
    what we created. To achieve this, we use a closure and a callback function that
    needs to return `true` before our execution of the next command can proceed. The
    following screenshot shows the execution steps of our running test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Closures in Cypress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Closures in Cypress
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.1*, we can see that Cypress executed the command to get the added
    to-do item and asserted that the added to-do item was what we had in our list
    before executing the last command to add a new to-do item to our to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: Closures in Cypress cannot exist outside variables. To use closures, we need
    to utilize variables to pass the value received from our commands to the closure
    function, and utilizing variables is the only way to do this. In this code block,
    we have used a `$todoItem` variable to pass the value of the `cy.get()` command
    to the closure that asserts that the found to-do item is the exact item that we
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress utilizes variable scopes just as in JavaScript. In Cypress, users have
    the option of using `const`, `var`, and `let` identifiers to specify the scope
    of the variable declaration. In the following sections, we will see different
    scopes that can be utilized in a test.
  prefs: []
  type: TYPE_NORMAL
- en: Var
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `var` keyword is used to declare a function or a globally scoped variable.
    It is optional to provide the value to the variable for the purposes of initialization.
    A variable declared with the `var` keyword is executed before any other code is
    executed when it is encountered in a test function. It is possible to declare
    a variable in the global scope with the `var` keyword and overwrite it in the
    functional scope within our test function. The following code block shows a simple
    override of the globally scoped variable declared with the `var` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we declared an `a` variable in the global context of our
    tests, then later changed the global variable in our test. The newly changed variable
    will become the new value of our global `a` variable unless it is explicitly changed,
    as we did in the test. The `var` keyword therefore changes the global context
    of the variable, as it globally reassigns the value of the global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Let
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `let` variable declaration works in the same way that `var` declared variables
    work, with the exception that variables defined can only be available inside the
    scope in which they are declared. Yes, I know that sounds confusing! In the following
    code block, the two tests show a difference of scope declaration while using the
    `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second test, we have a test failure as the `let` keyword will only
    make the changed `a` variable available to the specific test that changed it,
    and not to the entire global scope of our test suite, as is the case with the
    `var` variable declaration. In the following screenshot, we can see that the test
    fails as it only picks the variable declared in the `describe` block and not the
    one in the previous tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The let keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The let keyword
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 8.2*, while writing tests, it is possible to make declarations
    of the same variable in different tests without affecting the scope of the declared
    variables, as each one will belong and have its own context and not affect the
    global context.
  prefs: []
  type: TYPE_NORMAL
- en: Const
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `const` keyword is used to declare objects and variables that are read-only
    and cannot be altered or reassigned once they have been declared. Variables assigned
    with the `const` keyword are "final" and can only be used in the state that they
    are in without their values being mutated or changed. In the following code block,
    we are trying to reassign a variable declared with the `const` keyword, which
    will then result in a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code block, given that the `a` variable is declared with `const`,
    it is immutable and therefore Cypress will fail with an error, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The const keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The const keyword
  prefs: []
  type: TYPE_NORMAL
- en: Just like in JavaScript, Cypress cannot reassign a variable that has been declared
    with a `const` keyword. Variables declared using `const` are those that do not
    need to be changed during the execution of a program, neither globally or locally
    within the test.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – Understanding Cypress variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about the utilization of variables in Cypress. We
    took a look at how variables are used in closures and also how they are declared
    with different scopes and contexts. Here, we also got to understand what variable
    scopes mean and how they can be used within tests. Now that we know what variables
    are and what they represent, we will dive into the use of aliases in Cypress tests
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Cypress aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases are a way to prevent the usage of `.then()` callback functions in our
    tests. We use aliases to create references or some kind of "memory" that Cypress
    can refer to, hence reducing the need for us to re-declare the items all over
    again. A common use of aliases is to avoid using callback functions in our `before`
    and `beforeEach` test hooks. Aliases provide a "clean" way to access the global
    state of a variable without the need for calling or initializing the variable
    in every single test. In this section, we will learn how to properly utilize aliases
    in our test execution and different scenarios where using aliases is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aliases come in handy in situations where one variable is utilized by more
    than one test in a test suite. The following code block shows a test where we
    want to verify that our to-do item does exist after we have added it to our to-do
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To externally use a variable declared in the `beforeEach` or `before` hooks,
    we used a callback function in the code block to access the variable, and later
    assert that the text of the variable created by our `beforeEach` method is the
    same to-do item that we are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the code is intended for demonstration purposes only and is
    not recommended for use when writing your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding test will definitely pass, it is an anti-pattern that Cypress
    aliases exist to solve. Aliases in Cypress exist to serve the following purpose
    in Cypress tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing object contexts between hooks and tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing element references in the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing route references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing request references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look into each of the uses of aliases and look at examples of how they
    can be used in the uses covered.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing contexts between test hooks and tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases can provide a "clean" way of defining variables and make them accessible
    to the tests without using callback functions in our test hooks, as was shown
    in the previous code block. To create an alias, we simply add the `.as()` command
    to what we are sharing, and the shared elements can then be accessed from Mocha''s
    context object using the `this.*` command. The contexts for each test are cleared
    after the test runs and so are the properties that our tests create in the different
    test hooks. The following code block shows the same test as the previous one to
    check whether a to-do item exists, but this time utilizing aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we can verify that Mocha has `this.todoItem` in
    its context and runs successfully, validating that the to-do item was indeed created.
    A further verification of the test can be done as shown in the following screenshot,
    which highlights the passing state of the Cypress test after the use of aliasing
    to reference the created to-do item in our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Context sharing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Context sharing
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.4*, we see that Cypress highlights the aliased text and shows how
    it is invoked in our test. Cypress prints out the aliased elements and commands
    that have been used, making it easy to identify and debug in the event of a failure
    and to trace what caused that failure in the aliased elements.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to use `this.*` with arrow functions in your Cypress tests
    as `this.*` will refer to the **lexical context** of the arrow function, and not
    that of Mocha's context. For any use of the `this` keyword, you will need to switch
    your Cypress tests to use regular `function () {}` syntax instead of `() => {}`.
  prefs: []
  type: TYPE_NORMAL
- en: Another great use of aliasing for sharing contexts is with Cypress fixtures.
    Fixtures are a feature that Cypress uses to provide mock data to be used in the
    tests. Fixtures are created in files and can be accessible in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures provide test data, and we utilize fixtures to provide data that is
    consistent with either the input that the application would expect or the output
    that it would generate when an operation is carried out. Fixtures are an easy
    way for us to provide data inputs to our tests without going through the hurdles
    of hardcoding the data in our tests or auto generating the data when our tests
    are running. With fixtures, we can also utilize the same set of test data for
    different tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we had a `todos fixture` that contained a list of all our created
    to-do items, we could have a test that is similar to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have aliased both the created to-do item and
    also the `todos.json` fixture file containing the created to-do items. We can
    utilize the to-do items' fixtures throughout all our tests, as we loaded the fixtures
    in the `beforeEach` hook of our tests. In this test, we accessed our first fixture
    value using `this.todo[0]`, which is the first object in our array of to-do items.
    To further understand how to work with fixtures and the exact files we are working
    with, take a look at the GitHub repository that we cloned at the beginning of
    this chapter, under `cypress/fixtures directory`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Cypress still works using asynchronous commands, and trying to access the `this.todos`
    outside the `beforeEach` hook will lead to a test failure as the test first needs
    to load the fixtures before it can utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'While sharing context, Cypress commands can also make use of a special `''@''`
    command, which eliminates the use of `this.*` when referring to the context of
    the declared aliases. The following code block shows the usage of `''@''` syntax
    when referring to Cypress aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we used the `cy.get()` command to eliminate the
    `this.*` syntax when accessing our fixture file, along with the need to use the
    old-style function declaration method. When we use `this.todos`, we are accessing
    the `todos` object synchronously, whereas when we introduce `cy.get('@todos')`,
    we are asynchronously accessing the `todos` object.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, when Cypress runs code synchronously, the commands are
    executed in the order in which they are called. On the other hand, when we run
    Cypress tests asynchronously, the responses from the executed commands are not
    returned in the order in which the commands were called, since the execution of
    the commands doesn't happen in the order in which they are called. In our case,
    `this.todo` will execute as a synchronous command, which will return `todo` object
    results in the order of execution, while `cy.get('@todos')` will behave like an
    asynchronous command and will return the `todo` object responses when they become
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing element references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases can also be used to access DOM elements for reuse. Making references
    to elements ensures that we do not need to redeclare DOM elements once they have
    been referenced by an alias. In the following code block, we will create an alias
    for the input element for adding a new to-do item, and later reference it when
    creating our to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This test shows the use of aliases to access elements in the DOM that have been
    stored as references. In the test, Cypress looks for our saved `'todoInput'` reference
    and uses it instead of running another query to find our input item.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing route references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use aliases to reference routes for an application under test. Routes
    manage the behavior of network requests, and by using aliases, we can ensure that
    proper requests are made, server requests are sent, and proper XHR object assertions
    are created when we make our requests. The following code block shows the usage
    of aliases when working with routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we have referenced our `todoItem` request as an alias. The
    route request will then check whether the form that we submitted has been submitted
    successfully and returns a response. When using aliases in routes, we do not have
    to keep referencing or calling the route, as Cypress will already have a stored
    response of the route from the alias that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing request references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like when ­­accessing route references with aliases, we can use Cypress
    to access Cypress requests and use the properties of the requests later. In the
    following code block, we identify a request for a specific comment and check the
    properties of the comment using aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The test makes an assertion on a specific comment and checks whether the assertion
    matches the ID of the comment. We have used an alias to reference the request
    URL in such a way that when running our tests, we just need to reference the URL
    that we have aliased without necessarily typing it in whole. The following screenshot
    of the running test shows how Cypress creates an alias that it later references
    while it is running the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Request references'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Request references
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the first `sixthComment` command is a command where
    Cypress is creating the alias, and the second is when the running test identifies
    the alias and asserts the expectation against the responses gotten from the aliased
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – Understanding Cypress aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we learned about aliases and how they are used to write "clean"
    code for our tests by providing a way for us to access and have references to
    requests, elements, routes, and commands that we may later require in our tests.
    We have also learned how Cypress aliases are accessed: either through the asynchronous
    method that utilizes the `@` symbol before the alias, or the synchronous method
    that directly accesses the aliased object using the `this` keyword. Finally, we
    learned how to utilize aliases in tests for referencing elements, enabling us
    to use aliased routes and requests in our tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about aliases and variables and how to utilize them
    in Cypress. We covered what variables are in Cypress tests, different types of
    variables and their scopes, and how to utilize them. We also covered how variables
    in Cypress assist in the creation of closures and how we create an environment
    that can only be accessed by the variables in addition to the global context accessible
    to the tests. Lastly, we looked at how we use aliases and the different contexts
    in which aliases are utilized. We learned how to reference aliases in tests, how
    to use them with elements, routes, and requests, and even for context sharing
    between test hooks and the tests themselves.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter, you have gained the skills of understanding how aliases and
    variables work, how aliases can be used in both asynchronous and synchronous scenarios,
    and how and when to create and implement the scope of variables in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you fully understand how aliases and variables work, we are ready for
    our next chapter in which we will understand how the test runner works. We will
    dive into different aspects of the test runner and how to interpret events happening
    on the test runner.
  prefs: []
  type: TYPE_NORMAL
