- en: Deploying an Isomorphic Go Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the automated end-to-end tests that we implemented in the last chapter,
    the IGWEB demo website now meets a baseline set of expected functionality. The
    time has come to free our Isomorphic Go web application out into the web. It's
    time to focus on deploying IGWEB to production.
  prefs: []
  type: TYPE_NORMAL
- en: Our exploration of Isomorphic Go production deployments will include deploying
    IGWEB as a static binary executable, along with static assets, to a standalone
    server (real or virtual) and deploying IGWEB as a multi-docker container application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying web applications is a vast subject, an ocean, worthy of the many books
    that are dedicated to covering this topic alone. Real-world web application deployments
    may include continuous integration, configuration management, automated testing,
    deployment automation tools, and agile team management. These deployments may
    also include multiple team members, fulfilling various roles in the deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The focus in this chapter will solely be on deploying an Isomorphic Go web application
    by a single individual. For the purpose of illustration, the deployment procedure
    will be performed manually.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain considerations that need to be made to successfully prepare
    an Isomorphic Go web application for production use, such as minifying the GopherJS
    produced JavaScript source file and ensuring that static assets are transferred
    to the web client with GZIP compression enabled. By keeping the emphasis of the
    material presented in this chapter on Isomorphic Go, it is left to the reader
    to adapt the concepts and techniques presented in this chapter for their own particular
    deployment needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How IGWEB operates in production mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an Isomorphic Go web application to a standalone server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an Isomorphic Go web application using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How IGWEB operates in production mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before proceeding to production deployment, we need to understand how the server-side
    web application, `igweb`, operates when it''s placed into production mode. Production
    mode can be turned on by setting the `IGWEB_MODE` environment variable with the
    value `"production"` before starting the `igweb` server-side application, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important behaviors that will take place when IGWEB runs in
    production mode:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript external `<script>` tag that includes the client-side application,
    inside the header partial template, will request the minified JavaScript source
    file located at `$IGWEB_APP_ROOT/static/js/client.min.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static assets for cogs (`cogimport.css` and `cogimport.js`) will not be generated
    automatically when the web server instance starts. Instead, the minified source
    files containing the bundled static assets for the CSS and JavaScript will be
    located at `$IGWEB_APP_ROOT/static/css/cogimports.min.css` and `$IGWEB_APP_ROOT/static/js/cogimports.min.js`,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than relying on the templates found in the `$IGWEB_APP_ROOT/shared/templates`
    folder, templates will be read from a single, gob encoded, template bundle file
    persisted on the disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to consider how the server-side web application responds to each
    one of these behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS-produced JavaScript source file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `funcs.go` source file where our template functions are defined,
    we introduce a new function called `IsProduction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function, meant to be used on the server-side, will return a value of `true` if
    the current operating mode is production, and `false` if it isn't. We can use
    this custom function within a template to determine from where the client-side
    JavaScript application should be obtained.
  prefs: []
  type: TYPE_NORMAL
- en: When operating in non-production mode, the `client.js` source file will be obtained
    from the server relative path of `/js/client.js`. In production mode, the minified
    JavaScript source file will be obtained from the server relative path of `/static/js/client.min.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the header partial template, we call the `productionmode` custom function
    to determine from which path to serve the client-side JavaScript source file,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering why we include different JavaScript source files (`client.js`
    versus `client.min.js`) between non-production mode and production-mode. Recall
    that in a development environment with `kick` running, the `client.js` and `client.js.map`
    source files get produced in the `$IGWEB_APP_ROOT/client` folder. Inside `igweb.go`,
    we registered handlers functions for routes that will map the `/js/client.js`
    path and the `/js/client.js.map` path to the respective source files in the `$IGWEB_APP_ROOT/client`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This provided us with the convenience that we could have `kick` automatically
    transpile the JavaScript code for us, the instant that we made a change to the
    application code. In non-production mode, we prefer not to minify the JavaScript
    source file so that we can get more detailed debug information through the web
    console, such as the panic stack trace (covered in [Appendix](416459e8-d23f-421d-a3fb-5c1c8da3afd8.xhtml),
    *Debugging Isomorphic Go*).
  prefs: []
  type: TYPE_NORMAL
- en: In production mode, there is no need to use `kick`. If you inspect the file
    size of the `client.js` source file, you will notice that it's approximately 8.1
    MB big! That sure is some serious sticker shock! In the next section, we'll learn
    how to cut that unwieldy file footprint down to size.
  prefs: []
  type: TYPE_NORMAL
- en: Taming the GopherJS-produced JavaScript file size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the production deployment process, we must issue the `gopherjs build`
    command, specifying the option to minify the produced JavaScript source file and
    to save the output of the JavaScript source file to a specified target location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must minify the produced JavaScript code to reduce its file size. As mentioned
    previously, the un-minified, JavaScript source file is 8.1 MB! We can further
    reduce the size of the source file to 2.9 MB by minifying it, running the `gopherjs
    build` command with the `-m` option and by specifying the `--tags` option with
    the value `clientonly` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `clientonly` tag, tells isokit to avoid transpiling source files that are
    not used by the client-side application. The `-o` option will place the produced
    output JavaScript source file in the specified target location.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to running the `gopherjs build` command, it's always a good idea to execute
    `clear_gopherjs_cache.sh` bash script found in the `$IGWEB_APP_ROOT/scripts` directory.
    It will clear project artifacts that have been cached from previous `gopherjs
    build` runs.
  prefs: []
  type: TYPE_NORMAL
- en: Serving a JavaScript source file that is nearly 3 MB large is still an untenable
    proposition for production needs. We can further cut down the size of transferring
    the file by enabling GZIP compression. Once the source file is sent using GZIP
    compression, the transfer file size will be approximately 510 KB. We will learn
    how to enable GZIP compression on the web server in the *Enabling GZIP compression* section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating static assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When deploying server-side Go web applications, it is commonplace to not only
    push out the binary executable file for the web server instance but also static
    asset files (CSS, JavaScript, template files, images, fonts, and so on) and template
    files. In traditional Go web applications, we would have to push out the individual
    template files to the production system, since traditional Go web applications
    would be dependent on having each individual file available in order to render
    the given template on the server-side.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are utilizing the concept of a template set persisted in-memory through
    the running application, there is no need to bring along the individual template
    files to the production environment. This is due to the fact that all we need
    to generate the in-memory template set is a single `gob` encoded template bundle
    file, which is persisted on disk in the `$IGWEB_APP_ROOT/static/templates` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the exported `StaticTemplateBundleFilePath` variable in the `isokit` package,
    we instruct isokit to generate the static template bundle file at the file path
    that we provide. Here''s the line in the `initializeTemplateSet` function in the `igweb.go` source
    file where we set the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable
    Components*, we learned that isokit bundles all of the JavaScript source files
    from all of the cogs into a single `cogimports.js` source file when the `igweb`
    application is first started. In a similar manner, all of the CSS stylesheets
    from all of the cogs are bundled into a single `cogimports.css` source file. When
    running IGWEB in non-production mode, the static assets are bundled automatically
    by calling the `isokit.BundleStaticAssets` function (shown in bold) in the `initailizeCogs`
    function found in the `igweb.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The automatic static assets bundling should not be utilized in a production
    environment, because the dynamic functionality that bundles the JavaScript and
    CSS is dependent on the server having an installed Go distribution with a configured
    Go workspace, and access to the source files for the cogs must be present in that
    Go workspace.
  prefs: []
  type: TYPE_NORMAL
- en: This immediately removes one of the advantages that Go comes with out of the
    box. Since Go produces statically linked binary executable files, we don't need
    to have a Go runtime installed on our production server in order to deploy our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run IGWEB in production mode, we can prevent the automatic static assets
    bundling by introducing the following code in the `initializeTemplateSet` function
    found in the `igweb.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We instruct isokit to use a static template bundle file, and we instruct isokit
    not to automatically bundle static assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the static assets (CSS, JavaScript, and the template bundle)
    that our Isomorphic Go web application requires, we can run `igweb` with the `--generate-static-assets
    flag` on a non-production system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce the necessary static assets, and then it will exit
    the `igweb` program. The implementation for this functionality can be found in
    the `generateStaticAssetsAndExit` function defined in the `igweb.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Three files will be created upon instructing `igweb` to generate the static
    assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$IGWEB_APP_ROOT/static/templates/igweb.tmplbundle` (template bundle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$IGWEB_APP_ROOT/static/css/cogimports.min.css` (minified CSS bundle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$IGWEB_APP_ROOT/static/js/cogimports.min.js` (minified JavaScript bundle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon performing a production deployment, the entire `$IGWEB_APP_ROOT/static`
    folder can be copied over to the production system, ensuring that the three aforementioned
    static assets will be made available on the production system.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have established how IGWEB will operate in production mode.
    Now, it's time to perform the most simplest of deployments—deploying an Isomorphic
    Go web application to a standalone server.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Isomorphic Go web application to a standalone server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For demonstrating a standalone Isomorphic Go deployment, we will be using a
    virtual private server (VPS) hosted on Linode ([http://www.linode.com](http://www.linode.com)).
    The procedure presented herein holds good for any other cloud provider, as well
    as the scenario where the standalone server happens to be a real server residing
    in your server room. The standalone deployment procedure that we will outline
    is performed manually to illustrate each step of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server in this demonstration, and the servers mentioned in subsequent demonstrations
    in this chapter will be running Ubuntu Linux version 16.04 LTS on Linode, a provider
    of **virtual private server (VPS)** instances. We will be running Linode's default
    stock image of Ubuntu 16.04 without making any kernel modifications.
  prefs: []
  type: TYPE_NORMAL
- en: When we issue any commands in this chapter prefaced with `sudo`, we assume that
    your user account is part of the sudoers group. If you are using the server's
    root account, you need not preface the command with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a less-privileged user called `igweb` by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the `adduser` command, you will be prompted to enter additional
    information for the `igweb` user and the password. If you are not prompted to
    enter the password for the user, you may set a password by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `igweb` application depends on two components to function properly. First,
    we need to install the Redis database. Second, we need to install `nginx`. We
    will be using `nginx` as a reverse proxy server, which will allow us to enable
    GZIP compression when serving static assets to the web client. As you will see,
    this makes a huge difference when it comes to the file size of the GopherJS-produced
    JavaScript source file (510 KB versus 3MB). *Figure 11.1* depicts the Linode VPS
    instance with the three key components, `igweb`, `nginx`, and `redis-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61f49e5a-74f7-42a8-939a-3006cb47bb45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The Linode VPS instance running igweb, nginx, and redis-server'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Redis database instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can follow the same procedure that was demonstrated in [Chapter 2](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml),
    *The Isomorphic Go Toolchain,* to install the Redis database. Before doing so,
    you should issue the following command to install the essential build tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed the Redis database, you should launch the Redis server
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `--daemonize` command-line argument allows us to run the Redis server in
    the background. The server will continue to run even after our session has ended.
  prefs: []
  type: TYPE_NORMAL
- en: You should secure the Redis installation by adding sufficient firewall rules
    to prevent external traffic from accessing port 6379, the default port of the
    Redis server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the NGINX reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the `igweb` web server instance, a Go application, can single-handedly
    fulfill the major needs to serve IGWEB, it is more advantageous to have the `igweb`,
    web server instance, sit behind a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: A reverse proxy server is a type of proxy server that will service a client
    request by dispatching the request to a designated destination server (in this
    case, `igweb`), get the response from the `igweb` server instance, and send the
    response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse proxies come in handy for several reasons. The most important reason
    for the immediate benefit of releasing IGWEB is that we can enable GZIP compression
    on the outbound static assets. In addition to that, reverse proxies also allow
    us to easily add redirect rules to control the flow of traffic as the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'NGINX is a popular high performance web server. We will be using `nginx` as
    the reverse proxy that sits in front of the `igweb` web server instance. *Figure
    11.2* depicts a typical reverse proxy configuration, where a web client will issue
    a HTTP request over port 80 and `nginx` will service the request by sending the
    HTTP request to the `igweb` server instance over port 8080, retrieving the response
    from the `igweb` server and sending the response back to the web client over port
    80:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fdfd999-0d8b-41d8-b393-5815a7bda632.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The reverse proxy configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a listing of the `nginx` configuration file, `nginx.conf`, that we
    will use to run `nginx` as a reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are two sections of settings that are of particular interest to us, the
    section to enable GZIP compression and the section for proxy settings.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling GZIP compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine the `nginx` configuration settings related to enable GZIP compression.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `gzip` directive to `on` to enable the gzipping of server responses.
  prefs: []
  type: TYPE_NORMAL
- en: The `gzip_min_length` directive allows us to specify the minimum length of a
    response that will be gzipped.
  prefs: []
  type: TYPE_NORMAL
- en: The `gzip_buffers` directive sets the number and size of buffers that are used
    to compress the response. We have specified that we will be using 16 buffers with
    a memory page size of 8K.
  prefs: []
  type: TYPE_NORMAL
- en: The `gzip_types` directive allows us to specify the MIME types that we should
    enable GZIP compression on in addition to *text/HTML*. We have specified the MIME
    types for plain text files, JavaScript source files, and CSS source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gzip_vary` directive is used to either enable or disable the *Vary: Accept-Encoding*
    response header. The *Vary: Accept-Encoding* response header instructs the cache
    to store a different version of the web page if there is a variation in the header.
    This setting is particularly important for web browsers that do not support GZIP
    encoding to receive the uncompressed version of the file properly.'
  prefs: []
  type: TYPE_NORMAL
- en: The `gzip_comp_level` directive specifies the level of GZIP compression that
    will be used. We have specified a value of 9, which is the maximum level of GZIP
    compression.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second section in the `nginx` configuration settings that is important is
    the reverse proxy settings.
  prefs: []
  type: TYPE_NORMAL
- en: We include the `proxy_pass` directive inside the `location` block with the value
    of the address and port of the web server. This specifies that all requests should
    be sent to the specified proxy server (`igweb`) located at `http://192.168.1.207:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to replace the IP address 192.168.1.207 shown in this example with
    the IP address of the machine that is running your `igweb` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse proxy will fetch the response from the `igweb` server instance and
    send it back to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: The `proxy_set_header` directive allows us to redefine (or append) fields to
    the request header that are passed on to the proxy server. We have included the
    *X-Forwaded-For* header so that the proxy server can identify the originating
    IP address of the web client that initiated the request.
  prefs: []
  type: TYPE_NORMAL
- en: To support the proper functioning of websockets (which the live chat feature
    depends on), we include the following proxy settings. First, we specify using
    the `proxy_http_version` directive that the server will be using HTTP version
    1.1\. The `"Upgrade"` and `"Connection"` headers are not passed to a proxied server
    by default. Due to this, we must send these headers to the proxy server using
    the `proxy_set_header` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `nginx` by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon installing `nginx`, the web server usually starts up by default. However
    if it doesn''t, we can start up `nginx` by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `nginx.conf` file found in the `$IGWEB_APP_ROOT/deployments-config/standalone-setup`
    folder can be placed in the production server's `/etc/nginx` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.3* depicts the 502 Bad Gateway error encountered when we attempt
    to access the `igweb.kamesh.com` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90fe7f2d-4a43-4cd6-afa4-5160595d45f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: The 502 Bad Gateway Error'
  prefs: []
  type: TYPE_NORMAL
- en: We get this server error because we haven't started `igweb` yet. To get `igweb`
    up and running, we first need to set up a place on the server where the `igweb`
    binary executable and the static assets will reside.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the IGWEB root folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IGWEB root folder is where the `igweb` executable and the static assets
    will reside on the production server. We use the following command to become the
    `igweb` user on the production server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an `igweb` folder in the home directory of the `igweb` user like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the directory that will contains the binary executable file for the
    `igweb` web server instance and the static assets that are required by the IGWEB
    demo website. Take note that the static assets will reside in the in the `~/igweb/static`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Cross compiling IGWEB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `go build` command, we can actually build binaries for different
    target operating systems, a technique known as **cross compiling**. For example,
    on my macOS machine, I can build a 64-bit Linux binary that we can push out to
    the standalone production server running Ubuntu Linux. Prior to building our binary,
    we specify the target operating system we want to build to by setting the `GOOS`
    environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `GOOS` environment variable to `linux`, we have specified that
    we wish to generate a binary file for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to specify that we want the binary to be a 64-bit binary, we set the
    `GOARCH` environment variable to specify the target architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `GOARCH` variable to `amd64`, we have specified that we want
    a 64-bit binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `builds` directory within our `igweb` folder by issuing the
    `mkdir` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This directory will serve as the depot containing `igweb` binary executables
    for various operating systems. For the purpose of this chapter, we'll only consider
    building a 64-bit Linux binary, but in the future we can accommodate builds for
    other operating systems, such as Windows, in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We issue the `go build` command and provide the `-o` argument to specify where
    the produced binary file should reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have instructed that the produced 64-bit Linux binary should be created in
    the `$IGWEB_APP_ROOT/builds` folder and that the name of the executable will be
    `igweb-linux64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that the produced binary is a Linux binary by issuing the `file`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From the result, we can see that the `go build` command has produced a `64-bit
    LSB` (Linux Standard Base) executable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in building Go binaries for other operating systems besides
    Linux, this link will provide you with a full list of all possible `GOOS` and
    `GOARCH` values: [https://golang.org/doc/install/source#environment](https://golang.org/doc/install/source#environment).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the deployment bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides shipping out the `igweb` executable file, we also need to ship the contents
    of the static folder, that holds all of IGWEB's static assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preparing the static assets for the deployment bundle consists of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling the client-side application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating the static assets bundles (template bundle, CSS, and JavaScript)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minifying the IGWEB CSS stylesheet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we transpile the client-side application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to generate the static assets bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The third, and final step, of preparing the deployment bundle consists of minifying
    the CSS stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the Go-based minifier by issuing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can minify IGWEB''s CSS stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With these items in place, we are now ready to create a deployment bundle,
    a tarball, which includes the `igweb` Linux binary along with the `static` folder.
    We create the tarball by issuing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the `scp` command to ship the bundle off to the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `scp` command will copy the tarball, `bundle.tgz`, to the `/tmp` directory
    on the server having the hostname `targetserver`. With the deployment bundle now
    placed on the server, it's time to get `igweb` up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the bundle and starting IGWEB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We move the template bundle that we had secure copied to the `/tmp` folder
    into the `~/igweb` folder and extract the contents of the tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After we are done extracting the contents of the `bundle.tgz` tarball, we remove
    the tarball file by issuing the `rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rename the binary file back to `igweb` using the `mv` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We had tacked on the `-linux64` to the name of the binary file in our local
    machine so that we could distinguish it from builds for other operating system/architecture
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have deployed the bundle to the production server. It's now
    time to run `igweb`.
  prefs: []
  type: TYPE_NORMAL
- en: Running IGWEB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to running the `igweb` executable, we must set the `$IGWEB_APP_ROOT`
    and `$IGWEB_MODE` environment variables on the production server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `$IGWEB_APP_ROOT` environment variable allows the `igweb` application
    to know the designated `igweb` directory that will contain dependent resources,
    such as static assets.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `$IGWEB_MODE` environment variable to `production` allows us to
    run the `igweb` application in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should add entries for these two environment variables in the `igweb` user''s
    `.bashrc` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can log out and log back in on the production server for the changes made
    to the `.bashrc` to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Running IGWEB in the foreground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start up the `igweb` web server instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 11.4* shows a screenshot of IGWEB running on a standalone server instance
    at the address [http://igweb.kamesh.com](http://igweb.kamesh.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e852eed5-74cf-40ee-927b-847e741cec07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: IGWEB running on a standalone server instance'
  prefs: []
  type: TYPE_NORMAL
- en: When we hit the *Ctrl* + *C* key combination to exit the `igweb` program, our
    web server instance comes to a grinding halt since it's been running in the foreground.
    NGINX will return the 502 Bad Gateway server error for any client request. We
    need a way to daemonize `igweb` so that it runs in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Running IGWEB in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `igweb` web server instance can run in the background using the `nohup`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `nohup` command is used to continue running the `igweb` program even after
    the current session has been terminated. On a Unix-like system, the `2>&1` construct
    means redirecting standard error (`stderr`) to the same place as the standard
    output (`stdout`). Log messages from the `igweb` program will be available for
    view by tailing the `/var/log/syslog` file. Finally, the last ampersand, `&`,
    in the command indicates running the program in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can stop the `igweb` process by first getting the **PID** (process ID):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output returned from running this command, the PID value will be right
    next to the name of the executable, `igweb`. Once we determine the PID of the
    process, we can stop the `igweb` process by killing it using the `kill` command
    and specifying the PID''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have placed the name `PID` in the preceding `kill` command for
    illustration purposes only. You will have to provide the `kill` command with the
    numeric value of the PID returned from running the `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running IGWEB with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach to running `igweb` works for the time being, but what if the server
    is rebooted? We need a means for the `igweb` program to be more resilient. It
    has to be able to start up again once the server comes back online, and `nohup`
    is not the suitable choice to accomplish this goal.
  prefs: []
  type: TYPE_NORMAL
- en: What we really need is a way to turn `igweb` into a system service. We can do
    exactly that with `sysytemd`, an init system, that is available with Ubuntu 16.04
    LTS. With `systemd`, we can initialize, manage, and track system services. It
    can be used while the system starts up or while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to run the following commands as the `root` user, since you need
    to be `root` in order to add a new system service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to turn `igweb` into a service, we create a unit file called `igweb.service`
    and place it in the `/etc/systemd/system` directory. Here''s the contents of the
    unit file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the file extension of `.service` indicates that we are creating a
    service unit that describes how to manage an application on the server. This includes
    performing actions such as starting or stopping the service, and if the service
    should be started on system startup.
  prefs: []
  type: TYPE_NORMAL
- en: The unit file is organized into multiple sections, where the start of each section
    is denoted with a pair of square brackets *[* and *]* with the name of the section
    enclosed between the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Section names in unit files are case sensitive!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section is the `[Unit]` section. This is used to define the metadata
    for the unit and how this unit relates to other units. Inside the `[Unit]` section
    we have specified a value for the `Description`, which is used to describe the
    name of the unit. For example, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we run it, the description we see for `nginx` is the description that was
    specified using the `Description` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Service]` section is used to specify the configuration of the service. The
    `USER` and `GROUP` directive specify what user and group the command should run
    as. We use the `Environment` directive to set the `$IGWEB_APP_ROOT` environment
    variable, and we use it again to set the `$IGWEB_MODE` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkingDirectory` directive sets the working directory for the executed
    command. The `ExecStart` directive specifies the full path to the command that
    is to be executed; in this case, we have provided the full path to the `igweb`
    executable file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Restart` directive is used to specify the circumstances that `systemd`
    will attempt to restart the service. By providing a value of *always*, we have
    specified that the service should always be running, and if for some reason it
    stops, it should be started up again.
  prefs: []
  type: TYPE_NORMAL
- en: The last section we've defined is the `[Install]` section. This section allows
    us to specify the behavior of a unit when it is enabled or disabled.
  prefs: []
  type: TYPE_NORMAL
- en: The `WantedBy` directive that is declared in this section tells `systemd` how
    a unit should be enabled, that is, at what system runlevel should the service
    run in when it is enabled. By setting the value for this directive to `multi-user.target`,
    we specify that this service has a system runlevel of 3 (multi-user mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime we introduce a new `systemd` service script or make changes to an existing
    one, we must reload the `systemd` daemon. We can do so by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify, that we want the `igweb` service to startup automatically on
    boot by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want the `igweb` service to startup automatically on boot, we
    can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start the `igweb` service by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can stop the `igweb` service by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have now completed the standalone deployment of `igweb`. It's amazing that
    we can run the `igweb` application without having to install Go on the target
    production system.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach is rather opaque to the DevOps crew that is tasked to
    keep IGWEB up and running. What I mean by *opaque* is that there's not much a
    DevOps engineer can ascertain by examining a static binary executable file and
    a bunch of static assets.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a more streamlined way to deploy IGWEB, a procedure that shows
    us all of the dependencies needed to launch an `igweb` instance from scratch.
    To achieve this goal, we need to dockerize IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Isomorphic Go web application using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides an overview of deploying `igweb` as a multi-container
    Docker application on the Linode cloud. Docker is a technology and a platform
    that allows us to run and manage multiple Docker containers on a single machine.
    You can think of a Docker container as a modular, lightweight virtual machine.
    We can make an application, such as `igweb`, instantly portable by packaging it
    as a Docker container. The application is guaranteed to run the same way inside
    the container, regardless of which environment it is run on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Docker at the following link: [https://www.docker.com](https://www.docker.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Most cloud providers offer support for Docker making it a very handy tool for
    cloud-based deployments. As you will see later in this chapter, deploying a multi-container
    Docker application on the Linode cloud is relatively easy.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before installing Docker on the production system, we first need to install
    some prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can issue the following command to install Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that Docker has been installed properly on the production system,
    you may issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You should see the version of Docker installed after running the command.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing IGWEB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process to dockerize `igweb` first involves creating a `Dockerfile`, a file
    that specifies instructions on how to create a Docker image. The Docker image
    will then be used to create a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: After having created the Dockerfile, we will be using the `docker-compose` tool
    to define and run multiple containers needed to power the IGWEB website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying `igweb` as a multi-container Docker application is a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Dockerfile` from which an IGWEB docker image can be created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the services that make up IGWEB in a `docker-compose.yml` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker-compose up` to start up the multi-container application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Dockerfile` describes what an `igweb` docker image should be made of. The
    file is located in the `deployments-config/docker-single-setup` folder. Let's
    examine the `Dockerfile` to examine how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FROM` instruction specifies the base parent image from which the current
    image is derived:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have specified that we will be using the base `golang` docker image.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `golang` docker image can be found at [https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MAINTAINER` instruction specifies the name of the maintainer of the `Dockerfile`
    along with their email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We have specified a group of `ENV` instructions which allow us to define and
    set all the required environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For the proper operation of the `igweb` application, we set the `$IGWEB_APP_ROOT`,
    the `$IGWEB_DB_CONNECTION`, `$IGWEB_MODE`, and the `$GOPATH` environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this block, we use `RUN` instructions to get the Go packages that are required
    by the `igweb` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the list of Go packages that are needed to get `igweb` up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `RUN` command installs a Go-based CSS/JavaScript minifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We use another `RUN` instruction to transpile the client-side Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This command is actually a combination of three sequential commands, where each
    command is separated using a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The first command changes directory into the `$IGWEB_APP_ROOT/client` directory. In
    the second command, we fetch any remaining required Go packages in the current
    directory and all sub-directories. The third command transpiles the Go code to
    a minified JavaScript source file, `client.min.js`, which is placed in the `$IGWEB_APP_ROOT/static/js`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `RUN` instruction builds and installs the server-side Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Take note that the `go install` command will not only produce the `igweb` binary
    executable file by performing a build operation, but it will also move the produced
    executable file to `$GOPATH/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We issue the following `RUN` instruction to generate the static assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This `RUN` instruction minifies IGWEB''s CSS stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ENTRYPOINT` instruction allows us to set the main command of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us the ability to run the image as if it were a command. We have
    set the `ENTRYPOINT` to the path of the `igweb` executable file: `/go/bin/igweb`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `EXPOSE` instruction to inform Docker the network port the container
    should listen in on at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We have exposed port `8080` of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being able to build a docker image using a `Dockerfile`, one of the
    most important benefits of this file is that it conveys meaning and intent. It
    can be treated as a first-class project configuration artifact to understand exactly
    what goes into building the isomorphic web application that is comprised of the
    server-side `igweb` application and the client-side application `client.min.js`.
    From looking over the `Dockerfile`, a DevOps engineer can readily ascertain the
    procedure to successfully build the entire isomorphic web application from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile for a closed source project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Dockerfile` that we presented works great for an open source project, but
    what would you do if your particular Isomorphic Go project is closed source? How
    could you still take advantage of running Docker in the cloud and keep your source
    code secure from view at the same time? We would need to make slight modifications
    to the `Dockerfile` to account for a closed-source project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a scenario where the `igweb` code distribution is closed source.
    Let's presume that we could not obtain it using the `go get` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also assume that you have created a tarball bundle of the closed source
    `igweb` project, including a closed-source friendly `Dockerfile` at the root of
    the project directory. You have secure copied the tarball from your local machine
    to the target machine, and you have extracted the tarball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes that we would need to make to the `Dockerfile`. First,
    we comment out the respective `RUN` instruction that gets the `igb` distribution
    using the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after the set of `RUN` instructions, we immediately introduce a `COPY`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This `COPY` instruction will recursively copy all files and folders within the
    current directory to the destination specified by `$IGWEB_APP_ROOT/.`. That's
    all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken an in-depth look at the anatomy of IGWEB's `Dockerfile`,
    we have to acknowledge the fact that the `igweb` web server instance cannot serve
    the IGWEB website by itself. It has certain service dependencies that we must
    account for, such as the Redis database for its data persistence needs and the
    NGINX reverse proxy for serving hefty static assets in a sensible gzipped manner.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a Docker container for Redis and another Docker container for
    NGINX. `igweb` is turning out to be a multi-container Docker application. It's
    time to turn our focus to `docker-compose`, the handy tool for defining and running
    multi-container applications.
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `docker-compose` tool allows us to define a multi-container Docker application
    and run it using a single command, `docker-compose up`.
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose` works by reading a `docker-compose.yml` file that contains
    specific instructions that not only describe the containers in the application,
    but also their individual dependencies. Let''s examine each section of the `docker-compose.yml`
    file for the multi-container `igweb` application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line of the file, we indicate that we will be using version 2
    of the Docker Compose configuration file format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the application''s services inside the `services` section. Each
    service (shown in bold) is given a name to indicate its role in the multi-container
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a service with the name `database`, which will be the container
    for the Redis database instance. We set the image option to `redis` to tell `docker-compose`
    to run a container based on the Redis image.
  prefs: []
  type: TYPE_NORMAL
- en: Right after that, we define a service with the name `webapp`, which will be
    the container for the `igweb` application. We use the `depends_on` option to explicitly
    state that the `webapp` service needs the `database` service to function. Without
    the `database` service up, the `webapp` service cannot be brought up.
  prefs: []
  type: TYPE_NORMAL
- en: We specify the `build` option to tell `docker-compose` to build an image based
    on the `Dockerfile` in the path specified. By specifying the relative path of
    `.`, we indicate that the `Dockerfile` that exists in the current directory should
    be used to build the base image.
  prefs: []
  type: TYPE_NORMAL
- en: We specify a value of `8080:8080` (HOST:CONTAINER) for the `ports` section to
    indicate that we want to open up port `8080` on the host and forward connections
    to port `8080` of the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the service with the name `reverseproxy`, which will be the
    container for the `nginx` reverse proxy server. We set the `depends_on` option
    to `webapp` to indicate that the `reverseproxy` service cannot be brought up without
    the `webapp` service being up. We've set the image option to `nginx` to tell `docker-compose`
    to run a container based on the `nginx` image.
  prefs: []
  type: TYPE_NORMAL
- en: In the `volumes` section, we can define our mount paths, in the form of HOST:CONTAINER.
    We have defined a single mount path where we have mounted the `nginx` configuration
    file, `nginx.conf`, located in the `./deployments-config/docker-single-setup`
    directory to the `/etc/nginx/nginx.conf` path inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `reverseproxy` service will be servicing HTTP client requests, we
    specify a value of `80:80` for the `ports` section to indicate that we want to
    open up port `80` (the default HTTP port) on the host and forward connections
    to port `80` of the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gone through the Docker Compose configuration file, it's time
    to start up `igweb` as a multi-container Docker application using the `docker-compose
    up` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We issue the following command to build the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of running the `docker-compose build` command (some part
    of the output has been omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After the build is complete, we can go ahead and run the multi-container `igweb`
    application by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 11.5* is a screenshot of IGWEB running as a multi-container application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c58f00f-245d-4d24-bf98-36e9fd4877f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: IGWEB running as a multi-container application'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the `docker-compose up` command, the command provides us live output
    of activity across all of the running containers. To exit the program, you can
    use the *Ctrl* + *C* key combination. Note that this will terminate the `docker-compose`
    program, which will shut down the running containers in a graceful manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, when starting the multi-container `igweb` application, you may
    specify the `-d` option to run in detached mode, which will run the containers
    in the background, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to bring the multi-container application down, you can issue the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make further changes to the `Dockerfile` or the `docker-compose.yml`
    file, you must run the `docker-compose build` command again to rebuild the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It's convenient to have the facility of `docker-compose up -d` to run the containers
    in the background, but by now, we know that it would be best to turn our multi-container
    Docker application into a `systemd` service.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the dockerized IGWEB service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the `systemd` service for the dockerized `igweb` is pretty straightforward.
    Here are the contents of the `igweb-docker.service` file, which should be placed
    in the production system''s `/etc/systemd/system` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the `[Unit]` section, we have set the `After` directive with the value `docker.service`.
    This indicates that the `docker` unit must be started before the `igweb-docker`
    unit. The `Requires` directive has also been set with the value `docker.service`.
    This indicates that the `igweb-docker` unit is dependent on the `docker` unit
    to successfully run. Failure to start the `docker` unit will result in a failure
    to start the `igweb-docker` unit.
  prefs: []
  type: TYPE_NORMAL
- en: In the `[Service]` section, we have set the `Type` directive to `oneshot`. This
    indicates that the executable we are launching is short-lived. It makes sense
    to use it because we will be running `docker-compose up` with the `-d` flag specified
    (detached mode) so that the containers run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: We have specified the `RemainAfterExit` directive in conjunction with the `Type`
    directive. By setting the `RemainAfterExit` directive to `yes`, we indicate that
    the `igweb-docker` service should be considered active even after the `docker-compose`
    process exits.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ExecStart` directive, we start the `docker-compose` process in detached
    mode. We have specified the `ExecStop` directive to indicate the command that
    is needed to stop the service.
  prefs: []
  type: TYPE_NORMAL
- en: In the `[Install]` section by setting the value for the `WantedBy` directive
    to `multi-user.target`, we specify that this service has a system runlevel of
    3 (multi-user mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that after placing the `igweb-docker.service` file in the `/etc/systemd/system`
    directory, we must reload the `systemd` daemon like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the dockerized `igweb` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You may use the `systemctl enable` command to specify that `igweb-docker` should
    be started on system startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take down the service by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've demonstrated how to run the `igweb` application as a multi-container
    Docker application hosted on the Linode cloud. Again, although we are using Linode,
    the procedure that we have demonstrated can be replicated on your preferred cloud
    provider of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy an isomorphic web application to the
    cloud. We presented how the `igweb` server-side application operates in production
    mode, showing you how external CSS and JavaScript source files were included by
    the application. We also showed you how to tame the file size of the JavaScript
    program produced by GopherJS. We showed you how to generate static assets for
    the application's template bundle along with the JavaScript and CSS that were
    to be used by the deployed cogs.
  prefs: []
  type: TYPE_NORMAL
- en: We first considered the deployment of an isomorphic web application to a standalone
    server. This consisted of adding an `igweb` user to the server, setting up the
    `redis-server` instance, setting up `nginx` as a reverse proxy with GZIP compression
    enabled, and setting up the `igweb` root folder. We also showed you how to cross
    compile Go code from the development system (64-bit macOS) to the operating system
    running on the production system (64-bit Linux). We guided you through the process
    of preparing a deployment bundle, and then we deployed the bundle to the production
    system. Finally, we showed you how to set up `igweb` as a `systemd` service so
    that it could easily be started, stopped, restarted, and automatically started
    on system startup.
  prefs: []
  type: TYPE_NORMAL
- en: We then focused our attention to the deployment of an isomorphic web application
    as a multi-container Docker application. We showed you how to install Docker on
    the production system. We walked you through the process of dockerizing `igweb`,
    which consisted of creating a `Dockerfile`, defining the services that make up
    IGWEB in a `docker-compose.yml` file, and running the `docker-compose up` command
    to start up IGWEB as a multi-container Docker application. Finally, we showed
    you how to set up the `igweb-docker systemd` script to manage `igweb` as a system
    service.
  prefs: []
  type: TYPE_NORMAL
