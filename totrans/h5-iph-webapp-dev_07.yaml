- en: Chapter 7. One-page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until this point we have developed individual pages with related static content.
    In this chapter we kick it up a notch by diving into one-page-application development.
    We've seen this in many of our web applications, including Pandora, Mint, and
    NPR. We'll cover the foundations of one-page-application development, from an
    introduction to MVC, Underscore, and Backbone to creating architecture with our
    sample application and utilizing the methods taught in the first section of this
    chapter. Once you complete this chapter you should have a solid understanding
    of concepts behind one-page-applications, which will allow you to continue to
    extend on this knowledge and help guide you on your way to building complex applications.
    So let's get started by first learning about MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: MVC Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to `Underscore.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to `Backbone.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a one-page application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller or MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model-View-Controller** (**MVC**) is a heavily used design pattern in programming.
    A design pattern is essentially a reusable solution that solves common problems
    in programming. For example, the **Namespace** and **Immediately-Invoked Function
    Expressions** are patterns that are used throughout this book. MVC is another
    pattern to help solve the issue of separating the presentation and data layers.
    It helps us keep our markup and styling outside of the JavaScript; keeping our
    code organized, clean, and manageable—all essential requirements for creating
    one-page-applications. So let''s briefly discuss the several parts of MVC, starting
    with models.'
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A model is a description of an object, containing the attributes and methods
    that relate to it. Think of what makes up a song, for example the track's title,
    artist, album, year, duration, and more. In its essence, a model is a blueprint
    of your data.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view is a physical representation of the model. It essentially displays
    the appropriate attributes of the model to the user, the markup and styles used
    on the page. Accordingly, we use templates to populate our views with the data
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controllers are the mediators between the model and the view. The controller
    accepts actions and communicates information between the model and the view if
    necessary. For example, a user can edit properties on a model; when this is done
    the controller tells the View to update according to the user's updated information.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The relationship established in an MVC application is critical to sticking
    with the design pattern. In MVC, theoretically, the model and view never speak
    with each other. Instead the controller does all the work; it describes an action,
    and when that action is called either the model, view, or both update accordingly.
    This type of relationship is established in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationships](img/1024OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram explains a traditional MVC structure, especially that the communication
    between the controller and model is two-way; the controller can send data to/from
    the model and vice versa for the view. However, the view and model never communicate,
    and there's a good reason for that. We want to make sure our logic is contained
    appropriately; therefore, if we wanted to delegate events properly for user actions,
    then that code would go into the view.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we wanted to have utility methods, such as a `getName` method that
    combines a user's first name and last name appropriately, that code would be contained
    within a user model. Lastly, any sort of action that pertains to retrieving and
    displaying data would be contained in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, this pattern helps us keep our code organized, clean, and efficient.
    In many cases this pattern can be directly applied, especially in many backend
    languages like Ruby, PHP, and Java. However, when we start applying this strictly
    to the frontend, we are confronted with many structural challenges. At the same
    time, we need this structure to create solid one-page-applications. The following
    sections will introduce you to the libraries we will use to solve these issues
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Underscore.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the libraries we will be utilizing in our sample application will be
    `Underscore.js`. Underscore has become extremely popular in the last couple of
    years due to the many utility methods it provides developers without extending
    built-in JavaScript objects, such as `String`, `Array`, or `Object`. While it
    provides many useful methods, the suite has also been optimized and tested across
    many of the most popular web browsers, including Internet Explorer. For these
    reasons, the community has widely adopted this library and continually supported
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Underscore is extremely easy to implement in our applications. In order to
    get Underscore going, all we need to do is include it on our page like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we include Underscore on our page, we have access to the library at the
    global scope using the `_` object. We can then access any of the utility methods
    provided by the library by doing `_.methodName`. You can review all of the methods
    provided by Underscore online ([http://underscorejs.org/](http://underscorejs.org/)),
    where all methods are documented and contain samples of their implementation.
    For now, let's briefly review some of the methods we'll be using in our application.
  prefs: []
  type: TYPE_NORMAL
- en: _.extend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extend` method in Underscore is very similar to the extend method we have
    been using from `Zepto` ([http://zeptojs.com/#$.extend](http://zeptojs.com/#$.extend)).
    If we look at the documentation provided on Underscore's website ([http://underscorejs.org/#extend](http://underscorejs.org/#extend)),
    we can see that it takes multiple objects with the first parameter being the destination
    object that gets returned once all objects are combined.
  prefs: []
  type: TYPE_NORMAL
- en: Copy all of the properties in the source objects over to the destination object,
    and return the destination object. It's in-order, so the last source will override
    properties of the same name in previous arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As an example, we can take a `Song` object and create an instance of it while
    also overriding its default attributes. This can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we log out the `Sample` object, we'll notice that it has inherited from the
    `Song` constructor and overridden the default attributes `track`, `duration`,
    and `album`. Although we can improve the performance of inheritance using traditional
    JavaScript, using an `extend` method helps us focus on delivery. We'll look at
    how we can utilize this method to create a base architecture within our sample
    application later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: _.each
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `each` method is extremely helpful when we want to iterate over an `Array`
    or `Object`. In fact this is another method that we can find in `Zepto` and other
    popular libraries like `jQuery`. Although each library''s implementation and performance
    is a little different, we''ll be using Underscore''s `_.each` method, so that
    we can stick within our application''s architecture without introducing new dependencies.
    As per Underscore''s documentation ([http://underscorejs.org/#each](http://underscorejs.org/#each)),
    the use of `_.each` is similar to other implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterates over a list of elements, yielding each in turn to an iterator function.
    The iterator is bound to the context object, if one is passed. Each invocation
    of iterator is called with three arguments: (element, index, list). If list is
    a JavaScript object, iterator''s arguments will be (value, key, list). Delegates
    to the native forEach function if it exists.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of using `_.each` with the code we created
    in the previous section. We''ll loop through the instance of `Sample` and log
    out the object''s properties, including track, duration, and album. Because Underscore''s
    implementation allows us to loop through an `Object`, just as easily as an `Array`,
    we can use this method to iterate over our `Sample` object''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from our log should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's extremely easy to use Underscore's `each` method with arrays
    and objects. In our sample application, we'll use this method to loop through
    an array of objects to populate our page, but for now let's review one last important
    method we'll be using from Underscore's library.
  prefs: []
  type: TYPE_NORMAL
- en: _.template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Underscore has made it extremely easy for us to integrate templating into our
    applications. Out of the box, Underscore comes with a simple templating engine
    that can be customized for our purposes. In fact, it can also precompile your
    templates for easy debugging. Because Underscore''s templating can interpolate
    variables, we can utilize it to dynamically change the page as we wish. The documentation
    provided by Underscore ([http://underscorejs.org/#template](http://underscorejs.org/#template))
    helps explain the different options we have when using templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiles JavaScript templates into functions that can be evaluated for rendering.
    Useful for rendering complicated bits of HTML from JSON data sources. Template
    functions can both interpolate variables, using <%= … %>, as well as execute arbitrary
    JavaScript code, with <% … %>. If you wish to interpolate a value, and have it
    be HTML-escaped, use <%- … %>. When you evaluate a template function, pass in
    a data object that has properties corresponding to the template's free variables.
    If you're writing a one-off, you can pass the data object as the second parameter
    to template in order to render immediately instead of returning a template function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Templating on the frontend can be difficult to understand at first, after all
    we were used to querying a backend, using AJAX, and retrieving markup that would
    then be rendered on the page. Today, best practices dictate we use RESTful APIs
    that send and retrieve data. So, theoretically, you should be working with data
    that is properly formed and can be interpolated. But where do our templates live,
    if not on the backend? Easily, in our markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the preceding script has an identified type for the browser, the browser
    avoids reading the contents inside this script. And because we can still target
    this using the ID, we can pick up the contents and then interpolate it with data
    using Underscore''s `template` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the page, would be the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the content from within the template would be prepended to the
    body and the data interpolated, displaying the properties we wish to display;
    in this case the title and album name of the song. If this is a bit difficult
    to understand, don't worry about it too much, I myself had a lot of trouble trying
    to pick up the concept when the industry started moving into one-page applications
    that ran off raw data (`JSON`).
  prefs: []
  type: TYPE_NORMAL
- en: For now, these are the methods we'll be using consistently within the sample
    application to be built in this chapter. It is encouraged that you experiment
    with the `Underscore.js` library to discover some of the more advanced features
    that make your life easier, such as `_.map`, `_.reduce`, `_.indexOf`, `_.debounce`,
    and `_.clone`. However, let's move on to `Backbone.js` and how this library will
    be used to create our application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Backbone.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add structure to our one-page application, we will be using `Backbone.js`,
    a light framework that helps us apply the MVC design pattern. `Backbone.js` is
    one of the many MVC-type frameworks that help frontend development stick to best
    practices of separating out the data from the views or in particular, the DOM.
    On top of that, our applications can become quite complex for one-page apps. `Backbone.js`
    helps alleviate these issues and gets us going quickly. So let's start with discussing
    how MVC applies to this framework.
  prefs: []
  type: TYPE_NORMAL
- en: MVC and Backbone.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many types of JavaScript frameworks that apply MVC differently, it
    is no different for Backbone. Backbone implements `Models`, `Views`, `Collections`,
    and `Routers`; it also includes an `Event`, `History`, and `Sync` system. As you
    can see, Backbone does not have a traditional Controller that was discussed earlier,
    but we can interpret `Views` as controllers. As per Backbone''s documentation
    ([http://backbonejs.org/#FAQ-mvc](http://backbonejs.org/#FAQ-mvc)):'
  prefs: []
  type: TYPE_NORMAL
- en: (…) in Backbone, the View class can also be thought of as a kind of controller,
    dispatching events that originate from the UI, with the HTML template serving
    as the true view.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This type of MVC implementation can be a bit confusing, however our sample application
    will help clear things up. For now let's dive into Backbone models, views, and
    collections. In the following sections we'll go over how each part of Backbone
    gets implemented and the parts we'll be using to build our application.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in any MVC pattern, the Model is critical, containing the data and logic,
    including properties, access controls, conversions, validations, and more. Keep
    in mind that we write models on a daily basis, and in fact we have created a number
    of models throughout this book (`MediaElement`, `Video`, `Audio`, and so on).
    Backbone models are similar to a boilerplate in that they provide utility methods
    that we would otherwise have to build ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created a `Song` model, the same as in the
    previous section, that has several properties (`track`, `duration`, and `album`)
    and methods (`get` and `set`). From there we create an instance of `Song` and
    use the methods created to get and set the `album` property. This is great; however,
    we needed to create those methods manually. That is not what we want to do; we
    already know we need those methods, so we just want to focus on the data and extending
    it. This is where Backbone models come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the following Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how quickly we get off the ground writing our applications.
    Behind the scenes, Backbone is a namespace and has a model object attached to
    it. Then, using Underscore's `extend` method, we return a copy of `Backbone.Model`,
    that has merged default properties attached to it, to the variable `SongModel`.
    Then we do the same as earlier, using `get` and `set`, with the desired output
    in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see it's pretty simple to get started using Backbone, especially
    if you just wanted a way to organize your data without building custom functionality
    for each and every application. Now let's look at views inside Backbone and how
    it can actually help us separate the data from our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone views are a bit different than models in such a way that they are
    more for convenience. If we look at the Backbone documentation and compare the
    *Views* and *Models* sections, we''ll find that Views are a bit more bare bones,
    but again are useful in organizing our applications. To see why these are still
    useful, let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Typically, this is how we would cache our elements on the page and delegate
    events for particular user interactions. However, what if this could be done with
    less setup work? In the following code, we transform the preceding code into a
    typical Backbone view setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Backbone takes care of the setup work for you. It caches the
    element selected and delegates the events for you behind the scenes. Literally,
    all you need to do on your end is the setup and quickly move on to the next step;
    now you''ll notice that your development time decreases while your efficiency
    increases, and this is just the preliminary steps into Backbone. Now, the magic
    happens when we connect the Model and View together. To see this in action, take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet we have finally connected a single model to one view.
    The way we have done this is by passing in the instance of the model into the
    instance of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, we associate the Model and the View. But we also need to do
    something with that Model, and usually we want to display the data associated
    with it. So in this example, we create an `initialize` method that gets called
    as a constructor. In this method, we use Backbone's built-in event system to track
    any changes associated with the Model's `track` property and call `updateSongTitle`
    accordingly. While we're at it, we change the context of the event handler by
    passing in `this` as the third parameter and then cache the element displaying
    the song's track.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, when you change the instance of the song's `track` property, the
    DOM updates accordingly. We now have the basics we need to build our application.
    But let's take a look at Backbone collections to understand how keeping track
    of our data increases the efficiency of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, up until this point we have worked with a single Model, which is great
    but in most cases we work with sets of data. This is why Backbone collections
    exist, to manage an ordered set of models. Backbone collections also tie into
    Underscore's methods, allowing us to work with these sets easily and efficiently
    with no setup work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This sample code is very similar to the code produced in the previous section.
    The difference here is that we have created a `SongCollection` that takes models
    of type `SongModel`. Then we create an instance of this collection, add 100 models
    to it via our `for` loop, and finally attach the collection to our View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our View has also changed in such a way that we have attached the `change`
    event to our collection, and created a more general listener that gets called
    whenever a Model is updated within the collection. Therefore, when we execute
    the following code the View lets us know that something was updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Server-side interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not easy seeing how a Backbone application connects to the server, especially
    since we have so much going on in the frontend code. But, if YOU take a look at
    the documentation provided on the Backbone.js website ([http://backbonejs.org/#Sync](http://backbonejs.org/#Sync)),
    we know that Models contain all the functionality for manipulating the data. In
    fact, Models connect to the database and can sync with it.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.sync is the function that Backbone calls every time it attempts to
    read or save a model to the server. By default, it uses (jQuery/Zepto).ajax to
    make a RESTful JSON request and returns a jqXHR. You can override it in order
    to use a different persistence strategy, such as WebSockets, XML transport, or
    Local Storage.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But, Models aren''t the only ones that can connect to the server. As the documentation
    continues to read, a model or collection can begin a sync request and interact
    with it accordingly. This is a bit different than a traditional MVC implementation,
    especially since collections and models can interact with the database. To better
    display Backbone''s implementation of MVC, the provided image helps display the
    relationship between the different types of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-side interactions](img/1024OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is pretty much what we have created previously; a view, model, and controller.
    The implementation is slightly different, but we can see that there is a clear
    separation between the presentation layer and data because the view never directly
    interacts with the database. If this is a bit confusing, it's because it is and
    is another level of complexity that, when understood, will help guide you to coding
    Zen.
  prefs: []
  type: TYPE_NORMAL
- en: You are now fully prepared to create a one-page application using `Underscore`,
    `Backbone`, and `Zepto`. But, there is a problem. These libraries help speed up
    our development and increase efficiency, but don't actually provide a solid structure
    for our applications. This is what we tackle in our sample application. Next,
    we will discuss architecture, implementation, and optimization needed for one-page
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now been introduced to `Underscore.js` and `Backbone.js`, and have a
    good understanding of what these libraries provide and how they help with application
    development. However, we still need a way of structuring our applications, so
    that they are easily extended and most importantly, managed. So in this part of
    the chapter, we'll start building out a sample application that ties everything
    together and gets you going on building out one-page applications quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Application architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our sample application will do two things. One, it will allow us to see user
    information, such as a profile and dashboard. Two, it will have a playlist of
    songs that can be listened to using the HTML5 Audio media element. We can think
    of these requirements as almost two applications: a user application for managing
    user data and another application that manages the playback of media. However
    they will be related, in such a way that the user will have a playlist of songs
    related to them.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic sample architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s begin implementing the preceding architecture. First, we know that there
    will be two applications, similar to our `App` objects, so let''s start by defining
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`js/Music/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js/User/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the JavaScript (`js`) folder, we should create the preceding two folders:
    `Music` and `User`. These two folders will contain the code for the User and Music
    applications accordingly. To help manage our backbone files, we''ll then create
    `models`, `views`, and `collections` folders for each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js/Music/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js/User/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great! Now we can start by creating a main JavaScript file that will contain
    the namespace for each application; each namespace being `User` and `Music` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '`js/Music/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Music.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js/User/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, most of our views are going to be the same with functionality that is
    very familiar. For example, there will be a global navigation bar that contains
    three links that will initiate a hide/show for each section, hiding the current
    section and showing the next. We don''t necessarily want to code the same thing
    over and over again, so it would be nice to have a base view that our applications
    can inherit from. To do this, we''ll create a folder called `views` within our
    `App` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`js/App/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseView.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, so this is basically our JavaScript framework for this sample application.
    Of course, there are other ways of setting this up, and perhaps they are even
    better—which is great. For our purpose, this fits the bill and helps demonstrate
    some structure within our applications. Now, let's start by looking at our markup.
  prefs: []
  type: TYPE_NORMAL
- en: Application markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's open up the `index.html` file pertaining to this chapter; it should be
    located at `/singlepage/index.html`. Now, if we haven't already done so, let's
    start by updating the global navigation of the site, which we have done previously
    for other chapters. If you need reference material, look at the previous chapter's
    finished source code, provided with this book, and update the markup as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our markup, when updated, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s begin modifying this code to fit our application. First, let''s
    start by adding in a `div` after the header with a class of `content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re done doing that let''s modify the scripts, by including our entire
    application that we created previously. This means we are including the `Music`
    and `User` application scripts, and the `BaseView`. The scripts section of our
    markup should then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have started the Backbone history API. Although we have not discussed
    this thoroughly, this is essential for keeping state in our applications. The
    details for the implementation of the History API in Backbone are beyond the scope
    of this book, but it is highly encouraged for those of you looking to harness
    the power of offline storage using Backbone. For now, keep in mind that this is
    essential for routing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now our markup is close to completion, but we are still left with what the
    rest of the application will be made of; and that is where templating will come
    in. The next step is to include the templates that will be required for our application,
    including the audio player view, playlist, song, dashboard, profile, and shared
    navigation views. So how does one specify a template on a static HTML page? Like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why this does not cause any errors in validation or code
    execution within the browser. Well to help clear things up, the `type` attribute
    of our `script` tag is a non-supported MIME type and because of this, the browser
    ignores all content within this `script` block ([http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare](http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare)).
    Because the code within the block doesn't get executed, we can include our HTML
    templates to be used later on. Keep in mind that we have attached an ID that we
    can use to target this element using Zepto. And also note the source for the audio
    element, specifically `<%= file %>`. This will be used by Underscore's `template`
    method to interpolate the data passed into the template itself. We'll get to that
    soon, but for now know that this is how we can set up our templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we now know how to create templates, so let''s implement the following
    templates right before the inclusion of our applications'' scripts. We can include
    the preceding template for the audio player, and after that we can include the
    following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the playlist view template we have some pretty interesting stuff going on.
    Take a look at the code after the `h1` tag. We see here the `template` method
    from Underscore's library; it is accepting one parameter that will be an HTML
    string of the template `#tmpl-user-nav`, which we have not defined yet, and the
    second parameter is an empty object. This example is showcasing the use of a template
    within a template, kind of Inception-like but hopefully not too scary. Remember
    that we mentioned there would be a global navigation included in our applications;
    the preceding method helps us code once—keeping our code clean, manageable, and
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our playlist still doesn''t contain a list of songs. That is because it
    will be dynamic and based on a dataset of songs; this is why we have an empty
    unordered list within the playlist view. But how will our songs look? Traditionally,
    we would just create a list (`li`) element in our JavaScript, but with templates
    we no longer need to do that—we can keep our markup outside our logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'See how easy it is now to keep your markup outside of your scripts? In this
    template, we are following the same basic principles: define a script block containing
    markup and create the markup that will then be interpolated to include the data
    we want. In this case, we want the track and artist to be output into their own
    elements. Now let''s create the user''s dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it''s the same as before. In fact we are repeating ourselves by using
    the same method in the playlist view to display the global navigation. By now,
    you have noticed that each template receives a specific ID, and that, for convention,
    we have defined the type of each `script` block according to its application,
    for example `tmpl/User` for the User application and `tmpl/Music` for the Music
    application. Let''s now take a look at the profile view that combines both the
    preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this view, we have the global navigation being printed out and data being
    interpolated. As you can see, there is no limit to what you can do in templates.
    But it can also be something as simple as the global navigation for our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this last example, there is nothing complicated happening, it is essentially
    the global navigation we have been expecting and it turns out—it's just markup.
    Now, you may be wondering why not create all of this in the DOM, hide it, and
    then populate it with the information you need using the built-in selector engines
    in `Zepto` or `jQuery`. And honestly, that is a great question to ask. But there
    is one main reason, performance. It is expensive to use these engines, even the
    built-in methods `querySelector` and `querySelectorAll`. We do not want to touch
    the DOM, because it is a heavy operation, especially for large-scale applications
    handling large data sets. And ultimately, it's messy to do DOM operations just
    for data population or storage. Just don't do it, it is a nasty habit to use the
    DOM for data and not a best practice throughout the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Our templates are complete, and that concludes the markup of our application.
    Now we move to the fun part, our scripts. The next part will be quite complex
    and pretty challenging, but I promise that when we're done, you'll be a pro at
    one-page applications and ready to create your own quickly. The first time around
    is always rough, but stick through it and you'll reap the rewards.
  prefs: []
  type: TYPE_NORMAL
- en: Application scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we'll go through the scripts needed to make our application
    work. We'll start with reviewing the `BaseView`, the view containing shared functionality
    in inherited views (`PlayListView`, `ProfileView`, and `DashboardView`). From
    there we'll create our Music and User applications, each having their relative
    models, views, and collections.
  prefs: []
  type: TYPE_NORMAL
- en: The BaseView
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s start looking at our scripts, beginning with the `BaseView` file we
    created under the `App` namespace (`js/App/views/BaseView.js`). In this file,
    we''ll create the `BaseView` class that will extend Backbone''s general `View`
    class. The `BaseView` will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This class follows the exact same pattern as the rest of the JavaScript we have
    written in previous chapters, the only differences here include the inclusion
    of `Backbone` and `Undescore` and the way we expose the `BaseView` class using
    `window.App.BaseView = BaseView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, bear with me here. We will be creating several methods that will be included
    in any object extending the `BaseView` class. These methods will include `show`,
    `hide`, `onProfileClick`, `onPlaylistClick`, `onDashboardClick`, and `onEditClick`.
    As you may have guessed, some of these methods will be event handlers that will
    navigate to certain parts of our application. Check out the following code for
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, you may notice that the objects written here have not been created, such
    as the `$template`, `User`, and `Music` objects. We'll return to this in a few
    steps, but keep in mind that `this.$template` will refer to the instance extending
    `BaseView`, and that the User and Music objects will be routers that will use
    the built-in backbone method called `navigate` to change our application's location
    in the URL and to store the history of the user's interaction. To better understand
    how this class, `BaseView`, gets used, let's start creating the code for the `Music`
    object in `Music.js` (`js/Music/Music.js`).
  prefs: []
  type: TYPE_NORMAL
- en: Music application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let's jump into creating the first part of our application, the music application.
    Both the music and user applications are separated to add a higher level of maintainability
    and reuse. Starting with the music application, we'll create the appropriate router,
    collection, model, and view.
  prefs: []
  type: TYPE_NORMAL
- en: The router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our music application begins with the `Music` class defined in our `Music.js`
    file located at `js/Music/`. In this file, we will extend Backbone''s `Router`
    class, containing the routes for our music application, a sample data object for
    use with our models and collections, and finally an event handler for when the
    playlist is requested. First, let''s start out with defining the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the pattern we have established with our `BaseView` class, we extend
    the `Router` class in `Backbone` and define some default routes. The two routes
    include a general playlist route and an alternative route containing the playlist
    and the track number. Both routes, when called, will invoke the `setupPlaylist`
    method that we will define next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if this code is a bit intimidating, it's actually pretty simple.
    First, we check if a `songCollection` object has been initialized with the instance
    of `Music`. If it hasn't then we create one, using a sample data object of songs—which
    we haven't created yet. Next, we do the same thing, checking if the `playListView`
    object has been created; if not we move on to creating it. Otherwise, we just
    show the playlist and the audio player associated with it. Lastly, we check if
    a track number has been passed in (related to the second route we created); if
    there is a track number, we update the `playListView` to reflect the track selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the initialization of the `playListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we haven''t officially created the `PlayListView` class, we can review
    how it gets initialized. In this case, we are attaching a property of `playListView`
    on the instance of `Music` with `this.playListView`. This property is going to
    be an instance of the `PlayListView` (`new PlayListView({})`). This new instance
    of `PlayListView` will accept a plain object that contains three properties: an
    element defined as `el`, a collection, and an instance of a `UserModel`, which
    has not been defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do here is include an `initialize` method that will
    create a sample data object (`this.songs`), and listen for when the playlist route
    is called. When we call the playlist route, or navigate to it, we want both the
    profile and dashboard to hide; we''ll do this manually within the `routes` listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so we have created the `initialize` method here, which gets called when
    an instance of `Music` is created. This is good, because in this method we take
    care of any setup work, such as creating the sample data object. The sample data
    object is an array of objects that will then be transformed into models by the
    `SongCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Looks familiar huh? Now we're tying up loose ends. We haven't created the `SongCollection`
    class yet, but as Backbone's documentation states, if an array is passed into
    a collection, it is automatically turned into the model specified in the collection
    (to be described in future steps).
  prefs: []
  type: TYPE_NORMAL
- en: The last thing this `initialize` method does, is define a listener on the route
    for playlist (`this.on('route:setupPlaylist', function() {});`). The event handler
    then hides the profile and dashboard if they have been created. Also, note that
    we have specified the route using `route:setupPlaylist`, but we could have easily
    listened to any route by just using `route`.
  prefs: []
  type: TYPE_NORMAL
- en: So I know this is a lot to digest, but we'll now connect the dots from this
    `Music` class, starting with collections then moving on to models and finally
    views. This class is the foundation for everything else that needs to get built
    in order to have a fully functional music application and provide the blueprint
    of our development.
  prefs: []
  type: TYPE_NORMAL
- en: The collection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The collection for our music application is simple. Following the basic template
    of what we've done previously, we will create a closure containing the `SongCollection`
    class. Then we will define the type of model the `SongCollection` should keep.
    And lastly, we'll expose the class to our `Music` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done implementing these requirements, our class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See how simple it was? Now we know that this collection only keeps track of
    models that are of type `SongModel` and that if passed an array, it will transform
    the contained objects into `SongModel` types. This is all this class will do for
    now. Of course, you are welcome to extend it and play around with the several
    methods, such as the comparator, this class can harness; but for now, this is
    all we need.
  prefs: []
  type: TYPE_NORMAL
- en: The model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our `SongModel` will describe the type of data we're trying to keep track of.
    This model will also contain a single method that will take a property of duration,
    in seconds, and return it in minutes. Of course, we have the option to prepare
    our model, when it has been initialized, but for now we'll keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SongModel`, when written, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can infer that the `SongModel` will have the attributes
    `duration`, `artist`, `added`, `track`, and `album`. Each will have a default
    value of an empty `String` or `0`. We can also notice that each model will have
    a method named `getDurationInMinutes` that can be invoked and would return the
    duration of that model in minutes. Again, the `SongModel` class follows the same
    basic architecture and best practices, returning itself to the `Music` object.
    Finally, we are ready to look at the views for this music application.
  prefs: []
  type: TYPE_NORMAL
- en: The view(s)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this part, we're going to review three separate views, including the play
    list, song, and audio player views. Each view renders an individual part of the
    music application, except for playlist, which renders both the audio player and
    each individual song. So, let's start with the playlist view.
  prefs: []
  type: TYPE_NORMAL
- en: The playlist view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We want the play list view to do a couple of things but we'll take it one step
    at a time. First, let's create the `PlayListView` class, which will extend our
    already created `BaseView` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want the `PlayListView` class to reference the proper template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By including a template as a property we can easily reference it using `this.template`.
    Keep in mind that we have not processed the template at this stage, we have simply
    used Underscore's `template` method to retrieve the markup. Next, we want to define
    an event listener for when the user clicks on a song.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this step we are telling the view to delegate all the events we've created
    to the view's element. In this event object, we are listening for a click event
    on an element with the class of `.view-song`. When this element is clicked, we
    want to invoke the `onSongClicked` event handler. Let's define this event handler
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The event handler defined in the preceding code toggles the active class and
    then tells the `Music` router to navigate to the playlist route, telling it to
    trigger the route event and pass in the track''s index. By doing this, our route
    is called, passed a track, and the playlist updates. However, we still do not
    have the `updateTrack` method defined. Let''s include the following method in
    our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the `updateTrack` method, and this is essentially telling the audio
    player''s view to render the track it has received. Unfortunately our code is
    still not ready to be run because we haven''t created this method. Also, the following
    method, `setActiveSong`, is not defined, so we need to do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `setActiveSong` method is now created and essentially toggles the active
    class depending on the URL''s track number. We could probably extrapolate and
    create a general toggle here for songs, but for now this meets the criteria. But
    we''re not done yet, we still need to initialize this class and render it appropriately.
    Let''s take a look at what the class now needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code completes the class, but before we move on let's take a look
    at what's going on here. First, we have defined an `initialize` method. This method
    will be invoked after the construction of an instance of this class, therefore
    the render method will also be called. Typically, in Backbone, the `render` method
    does exactly what the function is called—renders the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method defined does a few things; first it compiles our template
    using the model that was passed in. Earlier we saw the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, a new `UserModel` is created and passed into the `PlayListView`,
    and this instance is used to populate the playlist's template. Once the compilation
    is done, we attach the compiled template using Zepto's `append` method. What is
    it attaching it to, you ask? Well, the above initialization of this class is looking
    for an element with the class of `content`, which we defined after the header
    element on our page. Therefore, the `PlayListView` is going to attach itself to
    this `div` of class `content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the template is done being attached, we check if the audio player view
    has been created. If not, then we create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, once the check for the audio player view is made we get to the fun
    stuff. In this last part we loop through the collection that was sent over, which
    is an instance of `SongCollection` and the same data created in `Music.js`. As
    we loop through each model in the collection we create an instance of `SongView`
    each time, passing in the compiled template's unordered list element and passing
    it the current model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if that didn''t blow your mind, I''m not sure what could. Either way,
    I hope you''re still up for the challenge because we have two more views we need
    to look at: the `AudioPlayerView` and the `SongView`. Don''t lose hope though,
    we have passed the greatest challenge and are ready to ride the wave.'
  prefs: []
  type: TYPE_NORMAL
- en: The audio player view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We''re going to build our `AudioPlayerView` next. This view needs to pick up
    on the template we created earlier, populating it with the track number and loading
    it if we directly access the URL, for example `/#playlist/2`. We also need to
    override a method on the extended `BaseView`, the method that needs to be overwritten
    is `onDashboardClick`. This is because it requires we hide the playlist and then
    navigate to the dashboard. So at the very basic level, this class will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, all the requirements listed in the previous paragraph have been
    met with this base class for the `AudioPlayerView`. However, we need to render
    out this view, populating it with the data provided by the URL. To do this, we
    need to write our `render` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous `render` method we wrote for the playlist view, the
    `render` method checks if a file, a number, has been passed in. If it has we populate
    the audio element from our template with what was passed in. Next, we compile
    our template, then set the volume to `0.5` and attach the player right after the
    header of `PlayListView`. If we review how we initialized this class, we''ll notice
    that the audio player view delegates to the playlist view element (inside `PlayListView`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The song view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last part of our music application is the `SongView`. So let's quickly review
    the requirements for this and see its implementation. For this view, we again
    want to set our template. When we initialize this view we want to attach an event
    handler on the model passed in, so if the model is ever updated, the view renders
    automatically with the update. The `render` method of this view should essentially
    compile the template with the model's attributes and then attach itself to the
    element set for this view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done implementing the preceding requirements, the view should look
    somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we follow the standards set in previous view implementations.
    The only difference is the addition of the event listener on the model''s change
    event. Let''s remind ourselves of how this view gets initialized in `PlayListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now we fully understand how the music application works. At this point, our
    page could function just with this implementation; however, I don't recommend
    it since errors will come up because we haven't created the user application.
    But we now know that our routes define the actions in our application, views are
    the presentation layer that implements models and collections. Models are the
    heart of our application, containing all the data we need in a manageable fashion.
    And finally, collections help us manage larger data sets of our models and because
    we can pass these into the view, the view itself can manage the render of this
    data, which is ideal for large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next step of this process is to develop the user application, but hopefully
    things will be a bit easier. As we did in the last part, we'll start out with
    the router and work our way to the collection, model, and views.
  prefs: []
  type: TYPE_NORMAL
- en: User application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The user application will follow the same flow as the music application we created.
    Again, we'll cover the implementation of a router, model, and view. When we are
    done with this section we'll have subapplications that each run separately and
    increases the maintainability and efficiency of our one-page application.
  prefs: []
  type: TYPE_NORMAL
- en: The router
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our router for the user application will be very similar to the music application.
    We'll define the routes for the dashboard and profile. We will also take the time
    to create the homepage route of our one-page application. The route will contain
    the appropriate methods for setting up the dashboard and profile. It will also
    contain the homepage method, which will call the dashboard route. In the `initialize`
    method of the router we will listen to these routes and hide other views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we follow our standards, and create the base template
    for our user application. Next, let''s take a look at what the `initialize` method
    will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `initialize` method of our route meets the requirements we've listed by
    creating the event listeners for the routes we created. Each listener hides the
    sections we don't want to see, but how do we see the actual part of the application
    we want? Well, that's where the `setup` methods come in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These methods are pretty much the same. They do a check for whether the view
    has been created on the instance of the router (for example `this.dashboardView`
    and `this.profileView`), if it has we just show that view. However, if the view
    has not been created, we initialize the appropriate view and then call that `setup`
    method again (recursive), so that we can show it since the view now exists.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that we are creating a new `UserModel` that gets passed
    to many of our views. This is okay for now, since we want to test the meat of
    our application. But theoretically, one `UserModel` would be initialized and maintained
    throughout the application. Sounds like something you can tackle once you complete
    this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is include the homepage method for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Automatically, when you visit `/singlepage/index.html`, this route will be called.
    As defined in the `Backbone.js` library's documentation, an empty route refers
    to the home state of the application. Although we can define the `setupDashboard`
    method to be the callback, this is to illustrate that we can go from one route
    to another immediately when needed. Perhaps we could do some preprocessing here,
    or even create that single `UserModel` noted earlier?
  prefs: []
  type: TYPE_NORMAL
- en: The collection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we are only handling one user in this application, there won't be any
    need for creating a collection. Phew! You thought this would get a bit more difficult
    eh? Well, don't get your hopes up; we still have the model and view(s) to consider.
  prefs: []
  type: TYPE_NORMAL
- en: The model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As with any model in Backbone, we are just describing the data that will be
    handled throughout our application. This is no different for our `UserModel`,
    which will contain the default attributes of an instance and set the name of the
    person by combining the `first_name` and `last_name` attributes when it is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To meet these requirements, our `UserModel` will be defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That's really it for our model. We are just defining default values for our
    user and setting the name when an instance is created. Now we'll take a look at
    our `DashboardView` and `ProfileView`—the last two pieces for this application.
  prefs: []
  type: TYPE_NORMAL
- en: The view(s)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The user application will contain two views, including the `DashboardView` and
    `ProfileView`. As we have already established, each view extends the `BaseView`
    we created earlier. We'll need to make some changes in order to fit our experience,
    but overall this will be very similar to our music application view's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with our previously defined views, `DashboardView` will contain the template
    that will be used for the display of our dashboard, contain the events pertaining
    to this view and then render the template. What you'll notice here is that our
    events will use the event handlers defined in `BaseView`, because the `BaseView`
    event handlers meet the basic requirements of navigating to another view while
    the route listeners handle the hide functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The code for this view is fairly simple; we've seen this pattern before and
    are repeating it here. Because we've defined the event handlers in `BaseView`,
    we don't need to redefine them here. As for the `render` method, it checks for
    the creation of the template, and if it exists, it populates the template with
    the user's data, which we passed in when creating the instance of `DashboardView`
    in `User.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all we need to do for the dashboard view; like I promised, it''s fairly
    easy once the general setup is finished. Next let''s take a look at the final
    part of our application: the profile view.'
  prefs: []
  type: TYPE_NORMAL
- en: The profile view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our profile view will be exactly the same as the dashboard view in that we have
    a template, some events, and a `render` method. And just like before, we won't
    need to define the event handlers because the basic requirement of hiding a view
    is being taken care of by the `BaseView` we created at the beginning of this process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And that wraps everything up. If we run the page now, we get a fully accessible
    application that has the dashboard view as its default view. You can then interact
    with the application by navigating to the profile and playlist views. As you do
    so, the application changes the URL and keeps history of your activity, letting
    you go back and forward easily. Pretty neat, huh? Here are a couple of screenshots
    to showcase what the final application should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering about the styling for this application. Well lucky for
    you, the source code of this book has all of that written for you. We won't be
    going over the styling, since it doesn't really cover anything mobile specific
    and is more of a visual enhancement to display the applications we built here.
  prefs: []
  type: TYPE_NORMAL
- en: '![The profile view](img/1024OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot of the application running in the iOS simulator showcases the
    dashboard view of the application we've written. In this view, we see our regular
    header and footer, including the title of the book, and a select control as the
    navigation. Inside the content area we see our dashboard templates rendering John
    Doe's dashboard and links to the playlist, profile, and back to the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![The profile view](img/1024OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we are in the playlist and song views showcasing an audio control and the
    ability to switch between tracks. We can see the rendering of templates inside
    of templates (audio tracks inside of the playlist). With this example, we can
    see how separation of controls (models, views, and controllers) helps us distinguish
    logic from user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![The profile view](img/1024OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, we see an audio track selected and playing under the **Playlist**
    page. It might seem like there's not a lot going on, but behind the scenes we
    have created a reusable application that allows user interaction without a page
    refresh.
  prefs: []
  type: TYPE_NORMAL
- en: '![The profile view](img/1024OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this last screenshot, we see the profile view, displaying John Doe's short
    biography, age, and birth date. During the transition of playlist and profile
    we didn't see a page refresh, instead a content update. Analyzing the URL, we
    can see that history has been kept and thus, allowing us to use the native back
    button to maneuver through the one-page application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Give yourself a pat on the back; we have finally reached the end of this chapter!
    It's been a good ride, and hopefully not too bad. At this point you are now prepared
    to tackle the development of one-page applications. From understanding the MVC
    design pattern to implementation, utilizing libraries such as Backbone and Underscore,
    you can now go and extend on this foundation by developing complex applications
    that tie into APIs and create a dynamically beautiful experience for the user.
  prefs: []
  type: TYPE_NORMAL
