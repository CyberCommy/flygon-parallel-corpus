- en: Chapter 6. Diagnosing and Correcting Firewall Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered how to troubleshoot networking-related
    issues with commands such as `telnet`, `ping`, `curl`, `netstat`, `tcpdump`, and
    `ip`. You also learned how the **TCP protocol** works, as well as how domains
    are translated to IPs using **DNS**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will once again troubleshoot network-related issues; however,
    this time we will discover how Linux's software firewall `iptables` works and
    how to troubleshoot network issues generated by a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, was all about
    networking and how to troubleshoot a misconfigured network. In this chapter, we
    are going to extend that discussion to firewalls. While troubleshooting firewalls
    we are likely to use some of the same commands as [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, and repeat a
    lot of the same process. This is because anytime you are using a firewall to protect
    a system, you are blocking certain types of network traffic, a misconfiguration
    of the firewall can impact any network traffic for a system.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter in the same way we did the other chapters, by troubleshooting
    a reported issue.
  prefs: []
  type: TYPE_NORMAL
- en: Déjà vu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, our troubleshooting
    started after a developer called in and reported that the company's blog was reporting
    a database connectivity error. After troubleshooting, we found that this error
    was due to a misconfigured static route on the database server. Yet again, today
    (several days later), we receive a call from the same developer reporting the
    same issue.
  prefs: []
  type: TYPE_NORMAL
- en: When the developer goes to `http://blog.example.com`, he receives an error stating
    there is a database connectivity issue. *Not again!*
  prefs: []
  type: TYPE_NORMAL
- en: Since the first step in data collection is to duplicate the issue, the first
    thing we should do is to pull up the company blog on our own browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Déjà vu](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It seems, in fact, that the same error is showing yet again; now to figure out
    why.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting from historic issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first instinct for a **Data Collector** would be to simply run through the
    same troubleshooting steps from [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*. The **Adaptor**
    and **Educated Gusser** troubleshooters, however, knowing the issue a few days
    ago was due to a static route would simply log in to the database server first
    and check for the same static route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe someone simply re-added it by mistake, or the route was not fully removed
    from the system''s configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, however, our luck is not that good; from the results of the `ip`
    command, we can see that the static route from [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, is not present.
  prefs: []
  type: TYPE_NORMAL
- en: Since the route is not present, we will need to start again at step one by checking
    whether the blog server is able to connect to the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Basic troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first test we should perform is a simple ping from the blog server to the
    database server. This will quickly answer whether the two servers are able to
    communicate at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the `ping` command's results we can see that the blog server can communicate
    with the database server, or rather, the blog server sent an **ICMP echo request**
    and received an **ICMP echo reply** from the database server. The next connectivity
    we can test is connectivity to port `3306`, the MySQL port.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will test this connectivity with the `telnet` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `telnet` however, failed. This shows that there is in fact a problem with
    the blog server connecting to the database service on the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the MariaDB service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have established that the blog server cannot communicate with the
    database server, we need to identify the cause. Before assuming the issue is strictly
    network-related, we should first validate that the database service is up and
    running. To do this, we will simply log in to the database server and check for
    the running database process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use multiple methods to validate that the database processes are running.
    In the following example, we will use the `ps` command once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the `ps` command, we are able to see the running **MariaDB** process. In
    the preceding example, we used the `ps -elf` command to show all processes and
    the `grep` command to filter that output to find the MariaDB service.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the results, it appears that the database service is in fact running;
    but this does not tell us for sure that this process is accepting connections
    on port `3306`. To validate this, we can use the `netstat` command to identify
    which ports are listening on this server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From the `netstat` command, we can see that there are quite a few ports open
    on this system and port `3306` is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the blog server is unable to establish a connection to port
    `3306`, we can once again test the connectivity from multiple places. The first
    place being the database server itself and the second being our laptop just as
    we did in [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the database server does not have the `telnet` client installed, we can
    use the `curl` command to perform this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing I will say repeatedly in this book is that it is important to know
    more than one way to perform a task. `telnet` is a very simple example but this
    concept applies to every task you perform as a system administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have established that the database server is accessible from the local
    server, we can now test this from our laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It seems that from our laptop, the connection to the database service is unavailable,
    but what happens if we test another port such as `22`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is an interesting result; from the laptop, we are able to connect to port
    `22` but not port `3306`. Since port `22` is available on the laptop, what about
    from the blog server?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These results are quite interesting. In the previous chapter, when our connectivity
    issue was due to a misconfigured static route, all communication between the blog
    server and the database server was broken.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this issue, however, the blog server is unable to connect to
    port `3306`, but it is able to talk to the database server on port `22`. What
    makes this issue more interesting is that locally, on the database server, port
    `3306` is available and accepting connections.
  prefs: []
  type: TYPE_NORMAL
- en: These key pieces of information are the first signs to indicate that our issue
    might in fact be due to a firewall. It might be a little early for a Data Collector,
    but an Adaptor or Educated Guesser troubleshooter might already, at this point,
    form an hypothesis that this issue is due to a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting with tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, we used `tcpdump`
    quite extensively to identify our issue; can we tell if the issue is a firewall
    issue with `tcpdump`? Maybe, we can certainly use `tcpdump` to get a better view
    of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will first capture connectivity to port `22` from the blog
    server (a connection that we know is working). The `tcpdump` will run on the database
    server filtering for port `22`; we will also use the `-i` (interface) flag with
    the `any` option to cause `tcpdump` to capture traffic on all network interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `tcpdump` is running, we can initiate a connection to port `22` from the
    blog server to see what a full healthy connection looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the captured data, we can see a standard healthy connection. We can see
    that the connection is coming from the IP `192.168.33.11`, the blog server''s
    IP. We can also see that the connection arrived on the IP `192.168.33.12` via
    port `22`. We can see all of this from the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the second captured packet, we can see the **SYN-ACK** reply from the
    database server to the blog server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `SYN-ACK` reply was from the `192.168.33.12` IP address
    to the `192.168.33.11` IP address. So far, the TCP connection seems normal, the
    third captured packet confirms this for sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The third packet is a **SYN-ACK-ACK** from the blog server. This means that
    not only did the blog servers `SYN` packet arrive and get replied to with a `SYN-ACK`,
    the database servers `SYN-ACK` packet was received by the blog server and replied
    to with a `SYN-ACK-ACK`. This is a full three-way handshake for port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at connectivity to port `3306`. To do this, we will
    use the same `tcpdump` command, this time changing the port to `3306`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tcpdump` running, we can use `telnet` from the blog server to establish
    a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `telnet` command has failed to connect; let''s see if `tcpdump`
    captured any packets during this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It seems in fact that `tcpdump` did capture a packet, but only one.
  prefs: []
  type: TYPE_NORMAL
- en: The packet captured was a `SYN` packet sent from `192.168.33.11` (the blog server)
    to 192.168.33.12 (the database server). This shows that the packet from the blog
    server arrives on the database server; but what we don't see is a reply packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in the previous chapter, when we apply filters to `tcpdump`,
    we often miss things. In this case, we are filtering `tcpdump` to look for traffic
    either from or to port `3306`. Since we know that the server in question is the
    blog server, we can change our filter to capture all traffic from the blog server
    IP; `192.168.33.11`. We can do this by using the host filter of `tcpdump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tcpdump` running again, we can once again initiate a connection with
    a `telnet` from the blog server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the telnet connection was expectedly unsuccessful; however, this time
    we can see quite a bit more from `tcpdump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time we can actually see quite a bit of useful information that directly
    indicates that our issue is due to the system firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like `tcpdump` was able to capture two packets. Let''s break down
    what it was able to capture to get a better understanding of what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first packet is the same as we saw before, a simple `SYN` request from
    the blog server to the database server on port `3306`. The second packet, however,
    is quite interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The second packet isn't even a TCP based packet but rather an **ICMP** packet.
    Earlier in [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, we talked about
    ICMP echo request and reply packets and how they are used by the `ping` command
    to identify whether a host is available. ICMP, however, is used for more than
    the `ping` command.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ICMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ICMP protocol is used as a control protocol for sending messages across
    networks. The echo request and echo reply messages are just one example of this
    protocol. This protocol is also frequently used to notify other systems of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the database server is sending an ICMP packet to the blog server,
    notifying it that the IP host 192.168.33.12 is unreachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Not only is the database server saying it is unreachable, it is also telling
    the blog server that the reason for the unreachable state is because the connection
    is administratively prohibited. This type of reply is a telltale sign of a firewall
    being the source of the connectivity issue, as often administratively prohibited
    is the type of message firewalls will utilize.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding connection rejections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a TCP connection is made to a service that is unavailable or to a port
    that is not being listened to, the Linux kernel will send a reply. The reply,
    however, is a TCP Reset, which tells the remote system to reset the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by connecting to an invalid port while running `tcpdump`.
    On the blog server, port `5000` is not currently being used if we run a `tcpdump`.
    Using the `port` filter, we will see all of the traffic to and from that port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tcpdump`, capturing all traffic on port 5000, we can now use telnet to
    attempt a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We actually can already see something different. Earlier, when we performed
    a `telnet` to port `3306` on the database server, the `telnet` command printed
    a different message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is because previously, when the telnet connection was performed,
    the server received an ICMP destination unavailable packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, however, a different reply was sent. We can see this reply in the
    captured packets by `tcpdump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the packet being sent back was a TCP Reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A **RESET** packet is, typically, what one would expect when the issue is due
    to simple connectivity errors, as this is the standard TCP response for situations
    where the client is attempting to connect to a port which is no longer available.
  prefs: []
  type: TYPE_NORMAL
- en: The RESET packet can also be sent by applications that are rejecting a connection.
    The ICMP destination unreachable, however, is typically the reply you will receive
    when the packet is being rejected by a firewall; that is, if the firewall service
    is configured to reply at all.
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary of what you have learned so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our troubleshooting so far, we have identified that the blog server is
    able to establish a connection to the database server over port `22`. This connection
    is actually able to perform a full three-way handshake unlike our previous chapter.
    However, the blog server is not able to perform a three-way handshake with the
    database server over port `3306`, the database port.
  prefs: []
  type: TYPE_NORMAL
- en: When the blog server attempts to establish a connection to the database server
    over port 3306, the database server is sending an ICMP destination unreachable
    packet back to the blog server. This packet is essentially telling the blog server
    that the connection attempt to the database is being rejected. Yet, the database
    service is up and listening on port 3306 (verified with `netstat`). In addition
    to the port being listened to, if we `telnet` to port 3306 locally, from the database
    server itself the connection is established.
  prefs: []
  type: TYPE_NORMAL
- en: Given all of these data points, it is possible that the database server might
    have the firewall service enabled and blocking connections to port 3306.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Linux firewall with iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to managing the firewall service within Linux, there are many
    options, the most popular being `iptables` and `ufw`. For Ubuntu distributions,
    `ufw` is the default firewall management tool; however, overall, `iptables` is
    by far the most popular across multiple Linux distributions. Both of these, however,
    in themselves, are simply user interfaces to **Netfilter**.
  prefs: []
  type: TYPE_NORMAL
- en: Netfilter is a framework within the Linux kernel that allows for packet filtering
    as well as network and port translation. Tools such as the `iptables` command
    are simply interacting with the `netfilter` framework to apply these rules.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will concentrate on utilizing the `iptables` command and service
    to manage our firewall rules. Not only is it the most popular firewall tool, it
    has also been the default firewall service for Red Hat based operating systems
    for quite a while. Even with the newer `firewalld` service arriving in Red Hat
    Enterprise Linux 7, this is simply a service to manage `iptables`.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that iptables is running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we suspect that our issue is due to the system''s firewall configuration,
    we should first check to see whether the firewall is running and what rules are
    defined. Since `iptables` runs as a service, the first step is to simply check
    that service''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, when we went to check whether a service is running, we would simply
    use the `ps` command. This works great for services such as MariaDB or Apache;
    `iptables`, however, is different. Since `iptables` is simply a command that interacts
    with `netfilter`, the `iptables` service is not a daemon process like most other
    services. In fact, when you start the `iptables` service you are simply applying
    saved `netfilter` rules, and when you stop the service, you are simply flushing
    those rules. We will explore this concept a little later in the chapter but for
    now we will simply check whether the `iptables` service is running using the service
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the Red Hat Enterprise Linux 7 release, Red Hat has migrated to `systemd`,
    which replaces the standard `init` system. With this migration, the service command
    is no longer the preferred command to manage services. This functionality has
    moved the control command for `systemd` to the `systemctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For RHEL 7, at least the `service` command is still executable; however, this
    command is simply a wrapper to `systemctl`. Here is the command to check the status
    of the `iptables` service with the `systemctl` command. For this book, we will
    utilize the `systemctl` commands rather than the legacy service command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output of `systemctl`, we can see that currently the `iptables`
    service is active. We can identify this from the 3rd line of the `systemctl` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `iptables` service is not running, things look quite a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding example, `systemctl` shows the `iptables` service as inactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the nice things about `systemctl` is that when running with the status
    option, the output includes log messages from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see all of the status messages used by the stop
    process for the `iptables` service.
  prefs: []
  type: TYPE_NORMAL
- en: Show iptables rules being enforced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know that the `iptables` service is *Active* and running, we should
    also look at the `iptables` rules that are defined and being enforced. To do this,
    we will use the `iptables` command with the `–L` (list) and `–n` (numeric) flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing `iptables`, the flags `–L` and `–n` are not combined. Unlike
    most other commands, `iptables` has a specific format that requires some flags
    to be separated from others. In this case, the `–L` flag is separated from the
    rest of the options. We could add the `–v` (verbose) option to the `–n` but not
    to the `–L`. The following is an example of executing with the verbose option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It seems from the output of `iptables -L -n` that there are quite a few `iptables`
    rules in place on this server. Let's break down these rules in order to understand
    them better.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding iptables rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the individual rules, we should first cover a few general
    rules of `iptables` and firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering matters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first important rule to know is that ordering matters. If we look at the
    data returned by `iptables -L -n`, we could see that there are multiple rules,
    the order of which those rules are in determines how that rule is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: I like to think of `iptables` as a checklist; when a packet is received `iptables`
    will go through the checklist from top to bottom. When it finds a rule that matches
    the condition, it applies that rule.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most common mistakes people make when using `iptables`, putting
    rules outside of the top to bottom order.
  prefs: []
  type: TYPE_NORMAL
- en: Default policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, `iptables` is used in two ways, either all traffic unless specifically
    blocked is allowed, or all traffic unless specifically allowed is blocked. These
    methodologies are called a **default allow** and **default deny** policy.
  prefs: []
  type: TYPE_NORMAL
- en: It is acceptable to use either policy depending on the desired use of the Linux
    firewall. In general however, the default deny policy is often considered the
    more secure approach, as this policy requires a rule to be added for each type
    of access required for the server in question.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the iptables rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `iptables` processes rules from the top down, to better understand the
    rules in place we are going to take a look at the `iptables` rules from the bottom
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first rule we see says `REJECT` all protocols from any source to any destination
    for the `FORWARD` chain. Does this mean that `iptables` is going to block everything?
    Yes, but only for packets that are being forwarded.
  prefs: []
  type: TYPE_NORMAL
- en: The `iptables` command categorizes network traffic types into tables and chains.
    Tables consist of the high-level operations being performed such as filtering,
    network address translation, or altering packets.
  prefs: []
  type: TYPE_NORMAL
- en: Within each table, there are also several "chains". The chains are used to define
    the type of traffic to apply the rule to. In the case of the `FORWARD` chain,
    this matches traffic that is being forwarded, which is commonly used for routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chain with rules applied is the `INPUT` chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This chain applies to traffic that is incoming to the local system; essentially,
    these rules are only applied to traffic that is arriving on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the last rule in the chain, we can see that it specifically defines
    that the system should `ACCEPT` TCP traffic with a source IP within the `192.168.0.0/16`
    network and a destination IP of 0.0.0.0/0, which like with `netstat` is a wildcard.
    The last part of this rule defines that this rule applies only to new connections
    with a destination port of `3306`.
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, this rule would have the effect of allowing any IP within
    the 192.168.0.0/16 network to access port 3306 on any of the database servers
    local IPs.
  prefs: []
  type: TYPE_NORMAL
- en: This rule in particular should allow traffic from our blog server (192.168.33.11),
    but what about the rule above it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding rule specifically states that the system should `REJECT` all protocols
    from a source IP of `0.0.0.0/0` to a destination IP of `0.0.0.0/0` and reply with
    an ICMP packet that says the host is prohibited. From our earlier network troubleshooting,
    we know that the `0.0.0.0/0` network is a wildcard for all networks.
  prefs: []
  type: TYPE_NORMAL
- en: This means that this rule will `REJECT` all traffic to the system, effectively
    making our system use a "default deny" policy. However, this isn't really the
    common method of defining a "default deny" policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the top of this chain''s ruleset, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially saying that the `INPUT` chain itself has an `ACCEPT` policy,
    which means the chain itself is using a "default allow" policy. However, there
    is a rule in this chain that will `REJECT` all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: This means that while the chain's policy is not technically default deny, this
    rule effectively accomplishes the same thing. Unless traffic is specifically allowed
    before this rule, the traffic will be denied, effectively making the chain a "default
    deny" policy.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have an interesting problem; the last rule in the `INPUT`
    chain specifically allows traffic to port 3306 (the `MariaDB` port) from the source
    network of 192.168.0.0/16\. However, the rule above that denies all traffic from
    anywhere to anywhere. If we take a second to remember that `iptables` is order
    based, then we can easily see that this might be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The issue might simply be that the rule to allow port 3306 is defined after
    a rule that blocks all traffic; essentially, the database traffic is being blocked
    by the default deny rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start acting on this information, however, we should continue looking
    at the `iptables` rules as there could be another rule defined that counters the
    two bottom rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The third from the last rule in the `INPUT` chain does explain why SSH traffic
    is working as expected. This rule specifically states that the system should `ACCEPT`
    all TCP protocol traffic from any source to any destination when the connection
    is a new connection destined for port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: This rule essentially defines that all new TCP connections to port `22` are
    allowed. Since it is before the default deny rule, this means that in no circumstance
    would new connections to port `22` be blocked by that rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the fourth from the last rule in the `INPUT` chain, we see a
    very interesting rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This rule appears to tell the system to `ACCEPT` all protocols from any IP (`0.0.0.0/0`)
    to any IP (`0.0.0.0/0`). If we look at this rule and apply the logic that ordering
    matters; then this rule should allow our database traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `iptables` output can sometimes be misleading, as this rule
    is not showing a critical piece of the rule; the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add the `–v` (verbose) flag to the `iptables` command, we can see quite
    a bit more information. In particular, we can see a new column named "in", which
    stands for interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a second look at this same rule, we can see that the interface column
    shows that this rule only applies to traffic on the `loopback` interface. Since
    our database traffic is on the `enp0s8` interface, the database traffic does not
    match this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The fifth from the last rule is very similar, except that it specifically allows
    all ICMP traffic from any IP to any IP. This explains why our **ping** requests
    are working as this rule will allow the ICMP echo request and echo reply through
    the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sixth from the last rule, however, is quite a bit different from the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This rule does state that the system should `ACCEPT` all protocols from any
    IP (0.0.0.0/0) to any IP (0.0.0.0/0); but the rule is limited to only `RELATED`
    and `ESTABLISHED` packets.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, while reviewing the `iptables` rule for port `22`, we could see that
    the rule is limited to `NEW` connections. This essentially means that packets
    that are used to start a new connection to port `22` such as a `SYN` and `SYN-ACK-ACK`
    are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the rule states that the `ESTABLISHED` state is allowed, `iptables` will
    allow packets that are part of an established TCP connection:'
  prefs: []
  type: TYPE_NORMAL
- en: This means that new SSH connections are allowed by the rule for port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once the TCP connection is established it is allowed by the following
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Putting the rules together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have looked at all of the `iptables` rules, we can make an educated
    guess as to why our database traffic is not working.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `iptables` ruleset, we can see that the rule to reject all traffic is
    defined before the rule to allow database connectivity on port **3306**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Since systems are unable to start new connections, they are not able to become
    established, which would be allowed by the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can determine all of this by looking at the rules defined, but this also
    requires a pretty versed knowledge of `iptables`.
  prefs: []
  type: TYPE_NORMAL
- en: There is another somewhat easier way to determine which rules are blocking or
    allowing traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing iptables counters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the verbose output of `iptables`, we not only see the interface the rule
    applies to, but we also see two additional columns that are very useful. Those
    two columns are **pkts** and **bytes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `pkts` column is the first column in the verbose output of `iptables`, this
    column contains the number of packets the rule has been applied to. If we look
    at the preceding rule, we can see that this rule has been applied to `41` packets.
    The `bytes` column is the second column and is used to denote the number of bytes
    that the rule has been applied to. For our preceding example, the rule has been
    applied to 2,360 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the packet and byte counters in `iptables` to identify which rules
    are being applied to our database traffic. To do this, we simply need to trigger
    database activity by refreshing our browser and running `iptables –L –nv` to identify
    which rules had their counters increased. We can even make this easier by clearing
    out the current values with the `iptables` command followed by the `–Z` (zero)
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we re-execute the verbose listing for `iptables`, we can see that the counters
    are `0` for everything except the `ESTABLISHED` and `RELATED` rule (a rule that
    every connection will match, including our SSH session):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After clearing these values, we can now refresh our web browser and initiate
    some database traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we run `iptables –L` in the verbose mode again, we can see that in fact as
    we suspected the packets are being rejected by the default deny rule. We can see
    this by the fact that this rule has now rejected `45` packets since we used the
    `–Z` flag to zero the counters.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `-Z` flag and counters is a very useful method; however, it might
    not work in all cases. On busy systems and systems with many rules, it might be
    difficult to solely use counters to show which rules are being matched. For this
    reason, it is important to build an experience with `iptables`, understanding
    its intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: Correcting the iptables rule ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing `iptables` can be a bit tricky, not because it is difficult to use
    (though the command syntax is a bit complex), but because there are two steps
    for modifying `iptables` rules. If one step is forgotten (which it often is),
    then the issue can persist unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: How iptables rules are applied
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the `iptables` service is started, the start script doesn't start a daemon
    like other services on the system. What the `iptables` service does is simply
    apply the rules that are defined within a saved rules file (`/etc/sysconfig/iptables`).
  prefs: []
  type: TYPE_NORMAL
- en: These rules are then loaded in the memory, and they become active rules. This
    means that if we were to simply reorder the rules in memory but not modify the
    saved file, the next time the server rebooted, our changes would be lost.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, if we only modified the saved file but did not reorder the
    `iptables` rules in memory, our changes will not take effect until the next time
    the `iptables` service is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: I've seen both of these situations occur somewhat frequently, where someone
    simply forgot one or the other step. This situation caused even more complication
    for the issue they were working.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying iptables rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this scenario, we will choose a simple method to both execute and remember.
    We will first edit the `/etc/sysconfig/iptables` file, which holds all of the
    defined `iptables` rules. Then restart the `iptables` service, which will cause
    the current rules to be flushed and the new rules in the `/etc/sysconfig/iptables`
    file to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit the `iptables` file, we can simply use `vi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of this file are a bit different than the output of `iptables
    -L`. The preceding rules are actually just options that can be appended to the
    `iptables` command. For example, if we wanted to add a rule that allows traffic
    to port 22, we can simply copy and paste the preceding rule with `-dport 22` with
    the `iptables` command prepended. The following is an example of what that command
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When the `iptables` service scripts are adding the `iptables` rules, they also
    simply append these rules to the `iptables` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the contents of the `iptables` file, we can see the two rules that need
    to be reordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to resolve our issue, we can simply change these two rules to match
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once the change is made, we can **save** and **quit** the file by pressing *Esc*
    then `:wq in vi`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our changes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that the file is saved, we should be able to simply restart the `iptables`
    service and the rules will be applied. The only problem is, what if we didn't
    edit our `iptables` file correctly?
  prefs: []
  type: TYPE_NORMAL
- en: Our current `iptables` configuration has a rule that blocks all traffic except
    for connections that are allowed by the rules above it. What if we accidently
    placed that rule before the rule that allows port 22? This would mean that when
    we restart the `iptables` service, we will no longer be able to establish SSH
    connections, and since that is our only method for managing this server, that
    simple mistake could have serious consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Caution should always be exercised when making changes to `iptables`. Even when
    simply restarting the `iptables` service, it is always best to look through the
    saved rules in `/etc/sysconfig/iptables` to ensure that there are no unexpected
    changes that will lock users and yourself out of managing the system.
  prefs: []
  type: TYPE_NORMAL
- en: To help avoid this situation, we can use the `screen` command. The `screen`
    command is used to open up pseudo terminals that will continue even if our SSH
    session is disconnected. This is true even if the disconnection is due to firewall
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the screen, we will simply execute the command `screen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are within the `screen` session, we are going to do a bit more than
    simply restart `iptables`. We are actually going to write out a `bash` one-liner
    that restarts `iptables`, prints the output to the screen to let us know our session
    still works, waits for two minutes, then finally stops the `iptables` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When we run this command, we will see either one of two things, either our SSH
    session will close, which likely means we have an error in our `iptables` rules,
    or we will see a message on our screen that says **still here?**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we see the **still here?** message, this means our `iptables` rules did
    not lock out our SSH session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since the command finished and our SSH session did not terminate, we can now
    simply restart `iptables` with the comfort of knowing that we will not be locked
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to establish a new SSH session when the rules are in
    place without ending the previous SSH session. This verifies that you can initiate
    new SSH sessions, and if it does not work, you still have the old SSH session
    alive to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we restart `iptables` this time, our new rules will be in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see that the rule to accept port `3306` traffic is in front of the
    default deny rule. If we refresh our browser, we can also validate that the `iptables`
    change corrected the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our changes](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Which it seems, it has!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take another look at the `iptables` listing in the verbose mode, we can
    also see how well our rule is being matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: From the statistics in `iptables`, we can see that two packets have matched
    our rule now. This combined with the working website means that our minor correction
    on ordering made a huge difference on what `iptables` allows or denies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we experienced what seemed like a simple networking issue with
    our blog application connecting to its database. In our data collection phase,
    we used commands such as `netstat` and `tcpdump` to inspect the network packets
    and quickly discovered that the blog server was receiving an ICMP packet indicating
    that the database server is rejecting the blog server's TCP packets.
  prefs: []
  type: TYPE_NORMAL
- en: From that point, we suspected the issue was a firewall issue, which after investigating
    with the `iptables` command we noticed that the firewall rules were out of order.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, we were able to use the *trial and error* stage to resolve the issue.
    This specific issue is a very common issue, something that I personally have seen
    in many different environments. This is mostly due to lack of knowledge around
    how `iptables` works and how to define rules properly. While this chapter only
    covered one type of misconfiguration within `iptables`, the general troubleshooting
    methods used within this chapter can be applied to most cases.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0044_split_000.html#19UOO2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 7. Filesystem Errors and Recovery"), *FileSystem Errors and Recovery*,
    we will start exploring file system errors and how to recover from them—a tricky
    topic where one wrong command could mean data loss, something no systems administrator
    wants to see.
  prefs: []
  type: TYPE_NORMAL
