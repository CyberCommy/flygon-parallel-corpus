- en: Creating User Interfaces in VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create virtual hands driven by the
    motion controllers. This enabled our users not only to look around the world and
    move through it, but also to begin to interact with it. In this chapter, we're
    going to take this further, and learn how to create **user interfaces** (**UIs**)
    that communicate information and accept input.
  prefs: []
  type: TYPE_NORMAL
- en: You should seriously consider whether your application really requires a graphical
    UI. Just because most applications need a GUI doesn't necessarily mean that's
    the case for all of them. Artificial-seeming UI elements can break immersion.
    When building UI elements, try to figure out how to fit them meaningfully into
    the world so that they look as though they belong there. Don't fall too much in
    love with buttons either. They're commonly used in 2D UI designs because they
    work well with a mouse, but VR hand controllers offer a much, much wider range
    of potential actions. Think beyond the button.
  prefs: []
  type: TYPE_NORMAL
- en: Most applications we develop for VR will require a **Graphical User Interface**
    (**GUI**) of some sort, but UIs in VR pose new challenges that we didn't have
    to face on the flat screen. Most of the time, when we're building a flat-screen
    UI, we can simply overlay 2D UI elements on top of our 3D environment using a
    **head-up display** (**HUD**) and then read mouse, gamepad, or keyboard input
    to allow the user to interact with it. This doesn't work in VR.
  prefs: []
  type: TYPE_NORMAL
- en: If we simply draw a 2D interface over each eye's view, its position is going
    to appear the same for each eye. The problem with this is that our stereo vision scopic
    interprets an object that looks the same to both eyes as being infinitely far
    away. This means that, when 3D objects in the world appear behind the UI on the
    screen, those objects are going to appear to be closer than the UI, even though
    the UI is drawn over them. This will look terrible and will almost certainly make
    your user uncomfortable.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is to incorporate UI elements into the 3D world, but it
    isn't enough to simply create an HUD panel in front of the player's face and project
    onto this, either (we'll talk more about why that is when we get to the player's
    UI later in this chapter). There's no way around the reality that you have to
    re-think UIs in VR. Think of what you're doing as re-creating objects you interact
    with in the real worlds rather than as re-creating 2D metaphors from the flat-screen
    world.
  prefs: []
  type: TYPE_NORMAL
- en: We need to re-think how we interact with UI in the 3D world as well. We don't
    have access to a mouse cursor in VR (which wouldn't work for us anyway, because
    it's a 2D input device), and keyboard commands aren't a great idea, since your
    user can't see the keyboard. We're going to need new ways to communicate input
    into the system. Fortunately, Unreal gives us a solid set of tools to handle 3D
    UIs in ways that will work well in VR.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to run through the process of creating the various
    elements we'll need to create a functional UI in VR by creating a simple AI-controlled
    companion character with an indicator displaying its current AI state, and a control
    interface on the player character that allows us to change that state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI-controlled character and giving it a simple behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces in 3D space using **Unreal Motion Graphics** (**UMG**) UI
    designer to display information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching UI elements to objects in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using widget interaction components to interact with these interfaces and affect
    objects in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the widget interaction component to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we're going to begin by simply taking the previous chapter's
    project and making a new copy. In previous chapters, we've explored a few ways
    of creating new projects using material from other projects. Simply duplicating
    and renaming a project can often be the simplest way to do this, and is appropriate
    if you're taking the work you've done in a previous project and expanding on it,
    as we are here. (It's also perfectly reasonable for this chapter's work to keep
    working from the previous project, if you'd like to.)
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Unreal project from an existing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating a new project by copying, there really isn''t a lot that needs
    to be done. It''s enough to simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the old project directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the new directory and the `.uproject` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the generated files from the old project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run through this process using our project from [Chapter 5](f9975ede-59dd-4728-b0d4-db3c41a1970a.xhtml),
    *Interacting with the Virtual World – Part I*, as a starting point for our work
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: With Unreal Editor closed, find the location of the previous chapter's Unreal
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of the project directory and give it a new name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new directory, rename the `.uproject` file. You're not required to
    match the name of the project file to the name of the directory that contains
    it, but it's good practice to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Intermediate` and `Saved` directories from your new project directory.
    These will be regenerated when you open the new project, and stray data left over
    from old projects can cause problems. It's always better to start clean with these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the new `.uproject` file. You'll see that the `Intermediate` and `Saved`
    directories you just deleted are regenerated for the new project. The project
    should open to the default map (`LV_Soul_Slum_Mobile`) we set in the last chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the toolbar's Build button to rebuild its lighting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the project by launching a VR preview. Everything should work as it did
    in the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, it's also fine simply to continue working from the previous
    chapter's project. Either way, we're now ready to add the AI character we're going
    to control.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not alone – adding an AI character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an AI-controlled character from scratch would take us into areas that
    fall outside the scope of this book, so, instead, we're going to repurpose the
    standard player character from the third-person template and change the way it's
    controlled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have a project created using the third-person template available,
    open it up. If not, create one:'
  prefs: []
  type: TYPE_NORMAL
- en: Select File | New Project, and create a new Blueprint project using the third-person
    template. It's fine to leave other settings at their default values – they won't
    affect anything we're doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating the third-person character blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether we''ve taken an existing third-person template project or created a
    new one, what we want to do now is migrate the `ThirdPersonCharacter` blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: In the third-person project's content browser, navigate to `Content/ThirdPersonBP/Blueprints` and
    select the `ThirdPersonCharacter` blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select Asset Actions | Migrate. Migrate the character into the
    `Content` directory for this chapter's project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can close this and return to our working project. A new `ThirdPersonBP`
    directory should have been added by our content migration.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `Content/ThirdPersonBP/Blueprints`, and find the `ThirdPersonCharacter`
    blueprint. Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning up the third-person character blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few things we don''t need here that we can safely clear out:'
  prefs: []
  type: TYPE_NORMAL
- en: First, select everything in Event Graph and delete it. We don't need any of
    these input handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also don''t need the FollowCamera and CameraBoom items in the Components
    list, so delete those:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26ac5371-fd6a-4677-8fe5-d71edc52666b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a clean character that's going to work out well for what we need
    it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the animation blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we took a shortcut and migrated our character, it's still not a
    bad idea to take a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the character''s `Mesh` component and look at the Animation section
    of the Details panel. You''ll see that this character is animated using an animation
    blueprint called `ThirdPerson_AnimBP`. Use the magnifying glass beside the Anim
    Class property to navigate to the animation blueprint and then open it up so we
    can see what''s inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67893e0a-85fe-48dd-8de3-3547e971d6e5.png)'
  prefs: []
  type: TYPE_IMG
- en: It would take us outside the scope of this book to discuss animation blueprints
    in depth, but, in general what you should understand about them is that, just
    as we saw with the controlled hands, they're responsible for determining how a
    skeletal mesh animates in response to whatever factors govern its animation.
  prefs: []
  type: TYPE_NORMAL
- en: You saw a simple example of an animation blueprint driving the hand pose. This
    one's doing a similar job, but driving a character skeleton. It's not a bad idea
    to take some time to burrow through this blueprint to see how it works. You can
    find further documentation at [https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints](https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints).
    When you're done looking around, feel free to close the animation blueprint. We
    won't need to change anything here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a companion character subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''re going to be adding new behaviors and components to this character,
    it''s going to be a good idea for us to create a new character blueprint and derive
    it from this one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the `ThirdPersonCharacter` blueprint and select Create Child Blueprint
    Class from the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8310bb3d-981c-4cff-8f0c-bfb772449939.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's name the new class `BP_CompanionCharacter` and move it to our project's
    subdirectory inside the `Content` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can drag an instance of `BP_CompanionCharacter` into the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f282d4aa-a474-4282-8cda-61891cd94e7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Place your companion character somewhere that's covered by the navigation mesh.
    Previously, we used a navigation mesh to allow us to indicate which areas of the
    map were valid teleport destinations. Now, in addition to this, we're going to
    use it for its intended purpose. Navigation meshes provide a simplified model
    of the walkable space of a map that can be used by AI-controlled characters to
    find their way around. Remember that you can use the *P* key to show and hide
    your navmesh if you need to check its coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a follow behavior to our companion character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s give our character a simple behavior. We''ll have him follow the player:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_CompanionCharacter` event graph and find or create an Event Tick
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the graph and create a Simple Move to Actor node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Get Controller node and feed its output into the Simple Move to Actor
    node's Controller input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Get Player Pawn node and feed its output into the Simple Move to Actor
    node''s Goal input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d10b4777-1653-4a5d-a080-e48631baef1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Launch your map. Our companion character should run to your location (if he
    doesn't, verify that he's starting on the navmesh and that the navmesh section
    where he's standing can access your PlayerStart location).
  prefs: []
  type: TYPE_NORMAL
- en: Examining the AI controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a moment to talk about what''s going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: Shut down the gameplay session, select the Simple Move to Actor node, and hit
    *F9* to set a **breakpoint** there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A breakpoint is a debugging tool that instructs the Blueprint interpreter to
    pause execution when it hits the point you've set. While you're in the paused
    state, you can roll over variable and function outputs to see what they contain,
    and you can step through the code to see how it executes. We'll cover using breakpoints
    and debugging tools in depth in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the map again, but don''t bother putting the VR headset on – we just want
    to see what happens when the breakpoint is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df23c33-35f0-45b5-b8e7-146128ad30b5.png)'
  prefs: []
  type: TYPE_IMG
- en: When execution stops at the breakpoint, roll over the output from the Get Controller
    node. You'll see that this character is currently controlled by an AI Controller
    that was automatically created for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any pawn or character in your level must be **possessed** by a controller before
    it can execute commands. The pawn or character you control as a player is possessed
    by a player controller. Characters that are expected to behave autonomously need
    to be possessed by an AI controller.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Simple Move to Actor node again if it's been deselected, and hit
    F9 to clear the breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Resume on the toolbar to return to normal execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The character should run to your location.
  prefs: []
  type: TYPE_NORMAL
- en: Setting breakpoints in your blueprints is a valuable way of debugging them and
    seeing how they operate. If you're working with a blueprint written by another
    developer, setting a breakpoint and stepping through the execution can be a valuable
    way of figuring out how it works. You can set and clear breakpoints by hitting
    *F9,* and step through execution by using *F10*. *F11* and *Alt* + *Shift* + *F11*
    allow you to step into and out of child methods in a blueprint. You can view the
    values currently set in your blueprint by mousing over input and output connectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the `BP_CompanionCharacter` class'' **Details** | **Pawn**,
    we can see that Auto Possess AI is set to Placed in World, meaning that the specified
    AI controller will automatically take control of this pawn if it''s placed in
    the world. Other options here allow us to specify that the AI controller should
    possess the pawn when it''s spawned, or should not auto-possess at all. The AI
    Controller Class specifies which AI Controller class will possess this pawn. If
    we needed to, we could select a new AI controller class here. In our case, we
    don''t need to do this because the default controller can do everything we need
    it to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71c8a8c7-94b3-4bc2-a6c9-753f70df0505.png)'
  prefs: []
  type: TYPE_IMG
- en: As with the depths of animation blueprints, a deep discussion of AI controllers
    and decision trees falls outside the scope of this book, but if you wanted to
    take it further, it's worthwhile exploring the documentation at [https://docs.unrealengine.com/en-us/Gameplay/AI](https://docs.unrealengine.com/en-us/Gameplay/AI).
  prefs: []
  type: TYPE_NORMAL
- en: It's worthwhile spending some time poking around with these elements. If you're
    developing applications that involve visible non-player characters, time spent
    learning about the animation blueprint and the AI controller is absolutely well
    spent.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the companion's follow behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've gotten our character following us, let's improve its behavior.
    It tends to crowd us a bit, and it would improve things if our companion only
    tried to follow us when we got a specified distance away from him.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, for the sake of organization, we should bundle our movement behavior
    into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Simple Move to Actor node and the Get Controller and Get Player Pawn
    nodes feeding it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and collapse them to a function named `FollowPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s improve the way it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the new function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an output from `GetPlayerPawn` and select Promote to local variable. Name
    the new variable `LocalPlayerPawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use local variables in functions whenever you access a piece of information
    that would cost time to collect again. Since we know we're going to need to use
    the player pawn a few times in this function, it's faster to get it once and save
    the value rather than to re-fetch it every time we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the setter that was automatically created for you to the function input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Get Squared Distance To node from the Local Player Pawn node's output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click, select Get a reference to self, and feed Self into the Get Squared
    Distance To node''s Other Actor input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db569b7e-4ce8-43d9-92bf-93b148ea384e.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a float variable named `FollowDistance`, compile, and set its value to
    `320.0`. (Feel free to tune this value later on once the behavior is running.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Square the `FollowDistance` (remember that the Square node will appear in the
    graph as ^2), and test to see whether the result of Get Squared Distance To is
    greater than the square of the follow distance. Create a Branch node from the
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4414527d-b81c-4e45-a86e-6ff173b1bd2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Recall that we mentioned previously that square roots are expensive to calculate,
    so when you're just comparing distances but don't care what those actual distances
    are, use squared distances instead.
  prefs: []
  type: TYPE_NORMAL
- en: This Branch node will return True when we move beyond the follow distance from
    the companion character, and False while we're within that distance.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the Branch node's True output to your Simple Move To Actor node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the False output to a `Return Node` since we don't need to do anything
    if we're within the follow distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grab an instance of `LocalPlayerPawn` and plug it into the Simple Move to Actor
    node's Goal input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Get Controller` should still be connected to your Simple Move to Actor node''s
    Controller input.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Return Node` to the Simple Move to Actor node''s exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b76d0b9-d613-4edb-bd7f-464d6f8e9099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Try it out. The companion pawn should now wait until you get more than 320
    units away from him before trying to follow you again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c3c24e-3060-48b8-b711-0c9ca019717d.png)'
  prefs: []
  type: TYPE_IMG
- en: Not bad. This is a very simple behavior, but it's a good start.
  prefs: []
  type: TYPE_NORMAL
- en: For AI behaviors of any meaningful complexity or behaviors that need to be executed
    by many characters simultaneously, it's a good idea to implement them using **behavior
    trees** instead of Blueprint tick operations. Behavior trees allow us to construct
    very complex behaviors in a clean, readable way, and run much more efficiently
    than simple Blueprint operations on the tick event. We built our character's behavior
    in Blueprint here to avoid going too far onto a tangent, but a behavior tree would
    really be a better structure to use here.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our companion character executing behaviors, it's time for
    us to move on to the real meat of this chapter, which is adding UI elements to
    the world.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI indicator to the companion pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our character is moving through the world, we're going to give it another
    behavior state and allow the player to instruct it to wait.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create this new state, however, we're first going to create a simple
    UI element to indicate the companion character's current state. We'll build it
    as a placeholder first, since we haven't yet created its new state, and then,
    once we have, we'll update it to reflect the real underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI widget using UMG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal provides a powerful tool for constructing UI elements. UMG allows developers
    to lay out UI elements on a visual layout tool, and to tie Blueprint behaviors
    directly to the objects in the layout. We call UI elements **widgets**. Let''s
    learn how to create them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project''s `Content` directory, right-click to create a new asset.
    Select UI | Widget Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6e5473a-a891-40ea-a379-ce8e72826c13.png)'
  prefs: []
  type: TYPE_IMG
- en: Name it `WBP_CompanionIndicator` and open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll be presented with the UMG UI Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal offers two toolsets for creating UIs. The original, called **Slate**,
    is only usable in native C++. Much of the editor itself is written using Slate,
    and some of the older game examples, such as ShooterGame, implement their interfaces
    in Slate. **UMG** provides a much more flexible and user-friendly method of creating
    UI objects in Unreal, and this is what we'll be using to build our interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'UMG is a very robust and deep system. You can create nearly any sort of interface
    element imaginable by using it. We''re not going to be able to cover everything
    UMG can do in this example, so, when you''re ready to go further, we encourage
    you to explore the documentation at [https://docs.unrealengine.com/en-us/Engine/UMG](https://docs.unrealengine.com/en-us/Engine/UMG):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46c345c3-6c78-4bf2-ae93-5311e9538478.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To begin with, notice that the UMG designer consists of two tabs: Designer,
    and Graph. The Designer tab is your layout tool. The Graph, just as with other
    contexts within Unreal, is where you specify the widget''s behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a simple UI to begin with, just so we can get all the parts into
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: In the upper-right corner of the Designer window, find the Fill Screen drop-down
    menu, and set it to Custom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's very common in flat-screen applications to design a UI widget to scale
    itself with the screen, but this isn't a feasible approach in VR, where our UI
    elements need to exist in 3D space. Setting this value to Custom allows us to
    specify the UI widget's dimensions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the Custom dimension to Width=320, Height=100 (you can also use the resizing
    tool to the lower right of the widget outline to adjust this):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8566f2e7-6b97-4f71-a801-5e44e9b5fc97.png)'
  prefs: []
  type: TYPE_IMG
- en: Grab a Common | Text object from the Palette and drag it into the widget's Hierarchy
    panel as a child of the Canvas Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can add elements to the canvas by dragging them directly onto the designer
    workspace, or by dragging them into the Hierarchy panel.
  prefs: []
  type: TYPE_NORMAL
- en: Let's center this text object in our panel.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Text` object in our hierarchy if it isn't already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its name to `txt_StateIndicator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're not required to name your widgets, but if you create a complicated UI,
    and everything is named `TextBlock_128327`, you're going to have an unpleasant
    time finding what you're looking for in your outline. It's a good practice to
    name your stuff sensibly when you make it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Anchors drop-down menu, select the centered anchor and click it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cedb97bd-cbf4-45e4-8efa-63d041e679b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Set its Position X and Position Y properties to `0.0`. You'll see the text object
    move so its upper-left corner is aligned with the center anchor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Alignment to X=0.5, Y=0.5\. You'll see the text object move so that
    its center is now aligned with the center anchor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Size to Content to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Justification to Align Text Center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Text to read Following (we're going to set this dynamically later on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anchors are an important concept to get the hang of in building UIs using UMG.
    When an object is placed on the canvas panel, its position is considered to be
    relative to whatever it's using as its anchor. For a UI canvas that doesn't change
    size, this may not matter much – you could simply leave everything anchored to
    the upper-left corner, but as soon as you start changing the size of your UI,
    anchors matter. It's a good idea to get used to using the appropriate anchors
    for wherever you want your object to appear. You'll save yourself a lot of re-working
    later.
  prefs: []
  type: TYPE_NORMAL
- en: An object's **alignment** determines where it considers its origin to be, on
    a scale of (0,0) to (1,1), so an alignment of `(0,0)` places the origin at the
    object's upper-left corner, while an alignment of `(1,1)` places it at the lower-right.
    `(0.5, 0.5)` centers the origin on the object.
  prefs: []
  type: TYPE_NORMAL
- en: You can use *Ctrl + *click and *Shift *+ click when selecting an anchor to set
    the object's position and alignment values automatically when you select the anchor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8fc1921-692d-4b1f-af16-0c826d499219.png)'
  prefs: []
  type: TYPE_IMG
- en: So, to recap, when you're placing an object on a UMG canvas, choose an anchor
    that determines where the object considers the position (0,0) on the layout board
    to be. This can differ between objects, and that's a powerful thing. Next, determine
    where on the object it should consider its own origin to be using its Alignment
    setting. Finally, set its position.
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about designing interfaces in UMG, you'll have an easier time
    if you think of what you're doing as setting up the *rules by which objects arrange
    themselves* on the panel, rather than setting their locations explicitly. UMG
    is designed to make it easy to create interfaces that scale properly with different
    widget and screen sizes, and respond dynamically to the data that's driving them.
    It does this very well but it can be confusing to new users, until you shift your
    mindset away from thinking of static layouts and toward thinking of it as a dynamic
    system of rules.
  prefs: []
  type: TYPE_NORMAL
- en: We're done with this object for now, so we can close it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI widget to an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created our indicator widget, it''s time to add it to our companion
    pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `BP_CompanionCharacter`, and from its Components panel, select +Add
    Component | UI | Widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new component `Indicator Widget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under its Details | UI, set its Widget Class to the `WBP_CompanionIndicator`
    class we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Draw Size to match the custom size we set for our widget layout: (X=320,
    Y=100).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump over to your Viewport if you're not already in that view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see your widget displayed along with the pawn, but it's too large
    and not yet in the right position.
  prefs: []
  type: TYPE_NORMAL
- en: UI widgets displayed in 3D space will tend to look blurry if they're displayed
    at 100% of the scale at which they were built. It's a better idea to build the
    widget to be larger than you need it to be and then scale it down when you attach
    it to the actor. This will cause it to display at a higher resolution than it
    would if you built the widget to be smaller and displayed at full scale.
  prefs: []
  type: TYPE_NORMAL
- en: Set its Location to (X=0.0, Y=0.0, Z=100.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Scale to (X=0.3, Y=0.3, Z=0.3):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a45f9cd-abf4-444d-b575-032b74ed1d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: The indicator widget is attached to the pawn's Capsule Component and will move
    with the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it in the level. Not bad, but there's a problem – the indicator faces
    in the direction the pawn is facing, so it's difficult or impossible to read if
    the companion pawn isn't facing you. We can fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Orienting the indicator widget to face the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create a function that orients the indicator to face the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Under My Blueprint | Functions, create a new function named `AlignUI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Category to UI, and its Access Specifier to Private (setting categories
    and access specifiers isn't required, but it's a very good practice to follow.
    It will make your life easier when your project gets larger).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the Align UI function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the body of this function, we''re going to find the location of the
    player''s camera and orient the indicator widget to face it:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Indicator Widget from the Components list into the function graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call SetWorldRotation on the Indicator Widget and connect the function's execution
    input to this call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another connector from Indicator Widget and call GetWorldLocation on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Get Player Camera Manager node and call GetActorLocation on the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Find Look at Rotation node and feed the Indicator Widget component's
    location into the Start input and the Camera Manager node's location into its
    Target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed its result into the `SetWorldRotation` function's New Rotation input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the function a `Return Node`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1aba3d1-bddd-4646-be40-99ad3b7d9bbc.png)'
  prefs: []
  type: TYPE_IMG
- en: By getting the location of the player camera manager, we've gotten the location
    from which the player is looking into the scene. The `Find Look at Rotation` method
    returns a rotator whose forward vector points from the start location, where the
    widget is, to the target location, where the camera is. Calling `SetWorldRotation`
    using this rotator causes the UI widget to face the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Align UI from the Tick event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s call the `AlignUI` function on Event Tick:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump back out to your event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new execution line from Event Tick and type `seq` on release. Select
    Sequence from the resulting list and create a Sequence node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Sequence node will interpose itself automatically between Event Tick and
    the Follow Player call that was previously connected to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06cced41-b278-4559-905d-9a589a5e0547.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Call `Align UI` from the Sequence node''s Then 1 output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/311ae60c-298f-4017-92dd-5ac2db00d2c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Try it out in the level. The UI indicator should now orient itself to face
    the camera regardless of where the companion pawn is looking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab471d4-72a4-459e-8489-375b9d3e98e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Good. We've created a simple UI element for our companion pawn. Of course it
    doesn't do much yet, since the pawn only has one state, but we're ready to fix
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new AI state to the companion pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s give our companion pawn a way to know what state it''s in. This
    information is best stored in an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Content Browser, wherever you saved `BP_CompanionCharacter`, right-click
    to add a new object, and select Blueprints | Enumeration. Name it `ECompanionState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open it up and add two items to the enumerator, named Following and Waiting,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e73f313-24d4-4002-8711-99cb1d089741.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and close the new enumerator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a simple AI state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created an enumerator to name our character''s AI states, let''s
    define the behavior we already created as the character''s `Following` state:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `BP_CompanionCharacter` and create a new variable. Set its name to `CompanionState` and
    its Type to the `ECompanionState` enum we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find Event Tick in your event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *Ctrl* anddrag the `CompanionState` variable onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from its output, and type `sw` in the search box to filter
    your search to `Switch on ECompanionState`. Add the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *Ctrl* and drag to move the execution input leading to your `Follow Player`
    call from that node's input to the execution input to your new switch statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the switch statement''s Following output to your `Follow Player` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a18fd849-1bcc-4d25-b762-64c1a2d03b71.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when your companion pawn's `Companion State` is set to `Following`, it
    will execute the follow behavior, but if that state is set to `Waiting` instead,
    it won't.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating AI states using the UI indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go ahead and create our character's next AI state, let's update our
    UI element to reflect the state the character is in. We'll want this shortly when
    we begin changing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want our indicator UI to display information about the pawn to which
    it''s attached, we need to tell it about that pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `WBP_CompanionIndicator` and select `txt_StateIndicator` from the design
    panel or from the Hierarchy tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Is Variable property to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e204d01d-fd34-4e88-b2de-188cefce2824.png)'
  prefs: []
  type: TYPE_IMG
- en: By setting `txt_StateIndicator` as a variable, we've given ourselves access
    to the object in this widget's event graph, so we can grab a reference to it and
    change its value.
  prefs: []
  type: TYPE_NORMAL
- en: Flip to the Graph tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new function and name it `UpdateDisplayedState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an input to the function named `NewState` and set its type to `ECompanionState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`txt_StateIndicator` should now be visible in your Variables list. Hold *Ctrl*
    and drag it onto the function''s graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from `txt_StateIndicator` and call `SetText` on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a connector from your NewState input and type `se` into the search box.
    A Select node should be available. Place it in the graph as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37a8cd47-19f0-4262-8d18-721396065f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Your newly-created Select node will have been automatically populated with options
    for each of the `ECompanionState` enum's values. Select statements can be used
    to select a wide variety of data types. To set its type, simply connect it to
    any other function or variable's input or output, and it will take on the type
    of whatever you connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the `Select` statement's Return Value to your Set Text node's In Text
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see that the `Select` statement has now taken on the Text data type,
    and you can now enter values for the Following and Waiting options.
  prefs: []
  type: TYPE_NORMAL
- en: Populate the select statement's text inputs with the names of the appropriate
    states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the function''s execution input with the SetText node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7758f824-4d0e-4eb2-b293-43ac93e65e4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever we call `Update Displayed State` on this UI element, it will update
    the displayed text to whatever we've entered in our `Select` statement for the
    newly-supplied state.
  prefs: []
  type: TYPE_NORMAL
- en: You've seen in this example, and the previous how we can use switch statements
    and select statements with enumerators. These are valuable techniques and worth
    remembering, as they're easily readable, and will update automatically if you
    add values to an enumerator or remove them. Enumerators and switch and select
    statements are your friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting here that there''s another way we could have updated this
    UI, and it''s a method you''ll commonly see taught. We could have stashed a reference
    to the pawn that owns this widget in a variable, and then we could have used the
    Bind method to set up a real-time update for the text element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/370c8818-9c5f-4f06-9b8c-a631c8c28b5c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a good opportunity to talk about a few important considerations in UI
    development, and explain why we didn't use Bind in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using events to update, rather than polling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the Bind method updates with every UI update. For values that change
    continuously, this is something you'll want, but for a value like the pawn's AI
    state that only changes only occasionally, and only when you perform an action
    that changes it, it's wasteful to check on every single tick to see whether it
    needs to display a new value. Whenever possible, you should favor updating your
    UI only when you know a value you're displaying needs to be updated, rather than
    having your UI poll the underlying data to see whether what it's displaying is
    still accurate. This will really start to matter if you build an interface with
    a lot of different elements and you have every single one of them updating every
    frame. Planning for efficiency in your UI pays off.
  prefs: []
  type: TYPE_NORMAL
- en: Being careful of circular references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other reason we want to be careful about doing this is a bit more subtle,
    but it''s important to know about. If we were to stash a reference to the pawn
    on the widget blueprint, and simultaneously stash a reference to the widget blueprint
    on the pawn, we''ve introduced the possibility of a **circular reference** (sometimes
    also called a **cyclic dependency**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/905f0f08-e6b4-491a-94ca-2cee1b5d8ea8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A circular reference: class A can''t compile until B is built, but class B
    can''t compile until A is built'
  prefs: []
  type: TYPE_NORMAL
- en: A circular reference occurs when one class needs to know about another class
    before it can be built, but that other class needs to know about the first class
    before *it* can be built. This is a bad situation that can create very difficult-to-find
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In the event of a circular reference between the widget blueprint and the pawn,
    the widget blueprint might not be able to compile correctly because it needs the
    pawn to be compiled first, but the pawn might not compile correctly because it
    needs the widget blueprint compiled first (we say "might not" because a lot of
    other factors can affect the order in which objects are built, so it may sometimes
    work. You may not immediately realize you've created a circular reference because
    things could work for a while, and then stop working when you change something
    seemingly unrelated). You don't need to be paranoid about this. Unreal's build
    system is very good at figuring out how to determine the right order to build
    things, but if you try to keep your references going in one direction, you'll
    save yourself what can turn into a very challenging bug-hunt.
  prefs: []
  type: TYPE_NORMAL
- en: Using the event-driven structure we've set up, the widget blueprint doesn't
    need to know anything about the pawn. Only the pawn needs to know about the widget
    blueprint, so the compiler can easily figure out which object it needs to build
    before it can build the other, and no circular reference occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that UI is updated when our state is changed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, because we've chosen to use an event-driven model rather than a polling
    model to drive our indicator UI, we have to ensure that any time the `BP_CompanionCharacter` class' `Companion
    State` changes, the UI is updated.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll want to make the variable private, and force any other object
    changing this value to use an event or function call to change it. By forcing
    outside objects to use a function call to change this value, we can ensure that
    any other operations that need to happen when that value changes will happen by
    including them in the function or event's implementation. Because we've set the
    variable to private, we're preventing anybody else from changing it without calling
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: This is a common practice in software development and a good one to internalize.
    If there's a possibility that you might need to perform operations in response
    to a variable's value changing, don't let outside objects change it directly.
    Make the variable private, and only allow other objects to change it through a
    public function call. If you make a habit of doing this, you'll save yourself
    a lot of headaches when your project gets large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function to handle setting the companion state, and make the
    variable private so that developers are forced to use it when they want to change
    the AI''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BP_CompanionCharacter` class' `Companion State` variable, and, in
    its Details, set its Private flag to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event graph, create a new custom event and name it `SetNewCompanionState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an input to this event. Name it `NewState`, and set its Type to `ECompanionState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hold *Alt *and drag a `CompanionState` setter onto the graph, and connect its
    execution and its new value to the new event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/62d9d79e-07e9-4039-aab5-42d722424fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to tell the indicator widget that this state has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a reference to the `IndicatorWidget` component onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Get User Widget Object` on the `IndicatorWidget` reference (remember that
    `IndicatorWidget` is not a reference to the widget itself, but to the component
    that holds it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the `Get User Widget Object` component's return value to `WBP_CompanionIndicator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call Update Displayed State on the cast result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2095000f-c2ad-430d-8912-d80fac6b4434.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, because `Companion State` is private, it can only be changed by calling
    `SetNewCompanionState`, and we can be sure that the UI indicator will be updated
    whenever this happens.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an interactive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to give ourselves a way to change our companion pawn''s state.
    To do this, we''re going to add a widget component to our player pawn, along with
    a widget interaction component we can use to interact with it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Content Browser, find the location of `BP_VRPawn`—our player pawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same directory, create a UI | Widget Blueprint, and name it `WBP_CompanionController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Designer window, change `Fill Screen` to `Custom` as we did with our
    previous widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its size to Width=300, Height=300.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Palette, select Panel | Vertical Box, and drag it onto your Hierarchy
    as a child of the Canvas Panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8f8a41f-9d72-42f7-9c3b-bb3130589db3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set its Anchors to fill the entire panel by selecting the lower-rightmost option
    (in addition to managing placement rules, anchors can also manage stretching rules):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/633a251b-e5f7-45d6-802d-70bd7450390d.png)'
  prefs: []
  type: TYPE_IMG
- en: Set its Offset Left, Offset Top, Offset Right, and Offset Bottom to `0.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Palette, select Common | Button, and drag it onto the Vertical Box.
    Name it `btn_Follow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag another button onto the same Vertical Box and name this one `btn_Wait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67212a86-052b-46e5-b491-a0dfbe21d3b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag a Common | Text widget onto your `btn_Follow`. Set its Text to `Follow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another Common | Text widget onto `btn_Wait` and set its Text to `Wait`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that we gave our buttons meaningful names when we created
    them, but we didn't bother to rename our text blocks. The reason for this is that
    these buttons are variables and we're going to refer to them in the widget blueprint's
    graph, while the text labels won't be referenced anywhere else, so their names
    don't really matter. You can apply your own judgment in choosing which items to
    name explicitly, but generally, your rule should be that if you're going to refer
    to the object anywhere else, it should have a meaningful name. You don't want
    to return to a widget blueprint after months of working on something else to find
    a forest of references to Button376 in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Our buttons are pretty small, and not well-placed on the widget. Let's do a
    little bit of layout work to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `btn_Follow` in the Hierarchy panel or on the layout designer, and
    select Wrap With... | Size Box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Size Box that just appeared in the Hierarchy panel, and set its
    Height Override to 80.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb650566-22e9-49d8-8f12-2c97792a9d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Size boxes** are used to set specific sizes for UMG widgets. If you don''t
    use a size box, the widget will scale automatically according to its rules. Wrapping
    it with a size box allows you to override these rules and set selected dimensions
    explicitly, while still allowing the rest to scale automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap `btn_Wait` with a Size Box and set its Height Override to 80.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's center these buttons vertically on the panel. We'll do this by adding
    Spacers.
  prefs: []
  type: TYPE_NORMAL
- en: From the Palette, drag a Primitive | Spacer onto the Vertical Box in the Hierarchy panel.
    Place it before the Size Box surrounding `btn_Follow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Size to `Fill`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag another Spacer onto the Vertical Box, after the Size Box surrounding `btn_Wait`,
    and set its Size to Fill as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/60c6a912-7c1a-4b93-a74e-6927d27801f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's add one more spacer to separate the buttons a little.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a Spacer onto the Hierarchy panel before the Size Box surrounding `btn_Wait`.
    Leave its Size as Auto, and set its Padding to 4.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we've seen an example of using spacers to tell the layout how to deal
    with space that isn't occupied by other widgets, and also to force some separation
    between widgets. By placing Fill spacers before and after the buttons, we centered
    them in the vertical box, and by placing an Auto spacer between the buttons, we
    separated them by a fixed amount.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the button colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These default button colors are going to appear too bright to be readable in
    our fairly dark scene. We can fix this by adjusting their background color properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `btn_Follow` and hit the color swatch for its Details | Appearance |
    Background Color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resulting color picker's HSV input, set its Value to 0.05.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for `btn_Wait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/11f409af-9bd2-4420-8ff0-1bd48dd243b8.png)'
  prefs: []
  type: TYPE_IMG
- en: This will dim the button's background enough to allow us to read it clearly
    under the environment's lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event handlers to our buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s make our buttons do something when they''re clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `btn_Follow`, and from its Details | Events, hit the + button for its
    On Clicked event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f5854ab-daf3-4c3f-bed9-ec8239f7da27.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll be taken to the widget's event graph, where a new event named `On Clicked
    (btn_Follow)` has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Get All Actors of Class node in your graph, and set its Actor Class to
    `BP_CompanionCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from its Out Actors array, and create a ForEachLoop from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a connector from the Array Element output of ForEachLoop, and make a call
    to the Set New Companion State event we created on BP_CompanionCharacter. Set
    the state to Following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6708b737-a7ac-4ce5-b2ea-78ed6c804cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's do the same thing for `btn_Wait`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, select `btn_Wait` from the Designer tab, and create an On Clicked event
    for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the nodes connected to the `On Clicked (btn_Follow)` event, and hit *Ctrl
    + **W* to duplicate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the companion state we're setting to `Waiting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attaching the UI element to the player pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, just as we did with our companion pawn's overhead indicator, we need to
    place this UI somewhere in the world.
  prefs: []
  type: TYPE_NORMAL
- en: The natural response for someone used to designing for flat-screen applications
    would be to follow the design principles they already knew and create some sort
    of HUD to display in the headset. This isn't such a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: First, any UI you attach to the headset is attached to the player's head. When
    they turn their head to look at it, it's just going to keep moving away. This
    gets old fast and can induce motion sickness in some users. This problem is compounded
    by the fact that the fresnel lenses in VR headsets are much less clear at the
    edges than they are at the center, so UI elements at the edge of the player's
    vision are going to be difficult to read. Finally, we face the problem that there's
    no easy way to interact with a UI element that's been bolted to our forehead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to attach the UI to something the player can control,
    like their wrist. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `BP_VRPawn`, and find `Hand_L` in its components list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Widget component as a child of `Hand_L`. Name it `CompanionController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `WBP_CompanionController` as the widget's Widget Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Draw Size to (X=300, Y=300) to match the size at which we created it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's get it attached.
  prefs: []
  type: TYPE_NORMAL
- en: Find your `BP_VRPawn` player's `BeginPlay` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a new connector from `BeginPlay` and create a Sequence node. Our `Set Tracking
    Origin` call should automatically attach to the Sequence node's Then 0 output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to the `CompanionController` widget, which we just added to
    the pawn, onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from it and create an Attach to Component node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember that there are two variants of this node: Target is Actor, and Target
    is Scene Component. Select the node designed to work with a scene component.'
  prefs: []
  type: TYPE_NORMAL
- en: Drag an execution line from the Sequence node's Then 1 output to the Attach
    to Component node's execution input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could also simply have dragged a connector from Set Tracking Origin output
    to the GetHand_L call, but it's a better practice to keep unrelated operations
    on separate execution lines so it's easier to see what really belongs together.
    By putting Set Tracking Origin on one sequence output, and the GetHand_L call
    on another, we're making it clear to the reader that these are two separate jobs
    being done.
  prefs: []
  type: TYPE_NORMAL
- en: Drag out an instance of the `Get Hand Mesh for Hand` method we created earlier
    (if you want to set up for a left-handed player, change its Hand value to Right;
    otherwise just leave it at the default Left).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the resulting hand mesh into the AttachToComponent node''s Parent input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7b876fd-1ed8-474b-8208-a45bd83c0f42.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run it. It's tremendous and not yet correctly aligned, but it's moving
    with the left hand as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: Drag another connector from `CompanionController`, and call `Set Relative Transform` on
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the New Transform input and split the struct pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'New Transform Location: (X=0.0, Y=-10.0, Z=0.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New Transform Rotation: (X=0.0, Y=0.0, Z=90.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New Transform Scale: (X=-0.05, Y=0.05, Z=0.05)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/10f117cb-6c25-46e3-8a98-33038de7b8cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we're negating the Scale's X value here. If you recall, we flipped
    our left-hand mesh by inverting its scale. Since we're attaching to that flipped
    mesh, we need to negate the scale here too, otherwise our widget will appear mirrored
    (if we're instead attaching this to the right hand, set the scale's X value to
    positive 0.05 instead, and set the rotation's Z value to positive 90.0).
  prefs: []
  type: TYPE_NORMAL
- en: Run it again and we'll see that the wrist menu is now much better aligned with
    our wrist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the next challenge: how do we press one of these buttons?'
  prefs: []
  type: TYPE_NORMAL
- en: Using widget interaction components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UIs in virtual reality pose a significant problem: how do we allow the user
    to interact with them? Early solutions often used gaze-based controls. The user
    would push a button by looking at it for a fixed amount of time. Yes, it was as
    clunky as it sounds. Thankfully, with the advent of hand controls, we no longer
    need to do it this way.'
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal, we most commonly interact with UI elements in VR by using a **widget
    interaction component**, which acts as a pointer in the scene and can simulate
    mouse interactions when used with UMG widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one to our right hand:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `BP_VRPawn` and add a Widget Interaction component to its Components
    list (its default name is fine).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Details panel, set its Show Debug flag to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On our Event Graph, find the Sequence node on our `Begin Play` event, and use
    the Add pin button to add a new output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43a112d4-f84c-440f-a530-6aea644b1d48.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag a reference to our `Widget Interaction` component onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from the `Widget Interaction` reference and create an Attach
    To Component (Scene Component) node with `Widget Interaction` as its target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a `Get Hand Mesh for Hand` function call onto the graph, and set its Hand
    property to Right (or Left if you attached the UI to the right hand).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed its Hand Mesh output into the Attach To Component node''s Parent input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30984984-90ff-46fc-bb32-f8386aa7412c.png)'
  prefs: []
  type: TYPE_IMG
- en: We're now attaching the controller UI to the left hand and the Widget Interaction
    component to the right hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7288effe-f791-4319-b942-89c744d18f83.png)'
  prefs: []
  type: TYPE_IMG
- en: Good. The widget interaction component's default placement and alignment aren't
    bad. We could adjust it by using a `Set Relative Transform` call if we wanted,
    but for what we're doing here, this is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of setting the placement of objects we're attaching to another object
    is to place a socket on the target object's skeleton. If you add a socket to a
    skeleton, simply put its name in the Attach to Component node's Socket Name property.
    In the interest of staying on topic, we're sticking to simple Set Relative Transform
    calls, but if you want to explore using sockets, the directions on [https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets](https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets)
    will apply.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our widget interaction component attached to our hand, we're
    ready to pass input through it.
  prefs: []
  type: TYPE_NORMAL
- en: Sending input through widget interaction components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First off, we''re going to need to choose what input should drive our widget
    interaction. Since we''re only using our triggers to grab objects, it should work
    out fine to add our widget interactions to these same inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `InputAction_GrabLeft` and `GrabRight` event handlers on the `BP_VRPawn` player's
    event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to your `Widget Interaction` component onto the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connection from the `Widget Interaction` component, and call `Press Pointer
    Key` from the connection. Set its Key drop-down to `Left Mouse Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another connection from `Widget Interaction` and call `Release Pointer
    Key`. Set this Key drop-down to `Left Mouse Button` as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've attached your `Widget Interaction` component to the right hand, call
    `Press Pointer Key` from the end of the `InputAction_GrabRight` component's Pressed
    event chain after the `Grab Actor` call (if the interaction component is on the
    left hand, call it from `GrabLeft` instead).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call `Release Pointer Key` from the `InputAction_GrabRight` component''s Released
    chain, after the `Release Actor` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0373e21-74e9-46c5-9dfe-6a8c3b95cd54.png)'
  prefs: []
  type: TYPE_IMG
- en: What we're doing here is telling the widget interaction component to communicate
    with the widget as though the user had moved a mouse pointer over it and pressed
    the left button. This is a powerful and flexible system—you can recreate nearly
    any input event and pass it through the interaction component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it. You should now be able to point the widget interaction component
    at your wrist controller and pull the trigger to activate a button. Try running
    around the level and switching your companion between the Follow and Wait states.
  prefs: []
  type: TYPE_NORMAL
- en: Making a better pointer for our interaction component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we should probably improve before wrapping this up is that obtrusive-looking
    debug beam on our widget interaction component. Let's take a moment to replace
    it with something better-looking.
  prefs: []
  type: TYPE_NORMAL
- en: In `BP_VRPawn`, select the `Widget Interaction` component and turn off its Show
    Debug flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Components panel, add a Static Mesh component as a child of `WidgetInteraction`.
    Name it `InteractionBeam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Static Mesh property to `/Engine/BasicShapes/Cylinder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Location to (X=50.0, Y=0.0, Z=0.0)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rotation to (Roll=0.0, Pitch=-90.0, Yaw=0.0). Remember that `Pitch`
    is mapped to Y in the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to `(X=0.005, Y=0.005, Z=1.0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Collision | Can Character Step Up On to `No`, and its Collision Presets
    to `NoCollision`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you add a UI or other attached element to a hand and you suddenly find that
    your movement is blocked, check to see whether you've turned its collision off.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out. We now have a gray cylinder indicating our interaction component.
    We should give it a more suitable material.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interaction beam material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to give our interaction beam a simple translucent material. We
    want to be able to see it in the world, but we don''t want it to be so obtrusive
    that it distracts our attention from the world:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the location in our `Content` directory where we saved the `M_Indicator`
    material we used for teleportation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material in this directory and name it `M_WidgetInteractionBeam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open it up and set its Blend Mode to `Translucent`. (Remember: to set material
    properties, select the output node.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold down the *V* key and click to create a Vector Parameter node. Name it `BaseColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the BaseColor node's default value to pure white – (R=1.0, G=1.0, B=1.0,
    A=0.0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed its output into the BaseColor and EmissiveColor material inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the material graph and create a Texture Coordinate node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a Linear Gradient node with the texture coordinate's
    output feeding into its UV Channel input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the *M* key and click to create a Multiply node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the LinearGradient node's VGradient output into the Multiply node's A input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *S* and click to create a Scalar parameter. Name it `OpacityMultiplier`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Slider Max to 1.0 and its Default Value to 0.25.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed its output into the Multiply node's B input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the result of the Multiply node into the material''s Opacity input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef34f7fa-d2a4-400b-9e53-080eaf6ca526.png)'
  prefs: []
  type: TYPE_IMG
- en: We're going to need to tune this material to work with our environment. We can
    make our life easier by creating a **material instance**. Material instances are
    derived from materials, but only those parameters that have been exposed in the
    parent material can be changed. Because material instances don't include any changes
    to the material graph, just value changes, they don't need to be recompiled when
    those changes are made. It's much faster to change values in a material instance
    than in a material.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `M_WidgetInteractionBeam`, and select Material Actions | Create
    Material Instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new instance `MI_WidgetInteractionBeam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `MI_WidgetInteractionBeam` to the `InteractionBeam` static mesh component
    on `BP_VRPawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the map. It's still pretty bright.
  prefs: []
  type: TYPE_NORMAL
- en: Open `MI_WidgetInteractionBeam` and set its OpacityMultiplier to 0.01\. (Put
    a checkmark beside a value you plan to change.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it again. That's much better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an impact effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need an impact effect to show where the beam is intersecting a target.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Static Mesh component as a child of the `BP_VRPawn` player's root
    component (the `Capsule Component`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `InteractionBeamTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Static Mesh property to `Engine/BasicShapes/Sphere`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to `(X=0.01, Y=0.01, Z=0.01)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Collision | Can Character Step Up On to `No`, and its Collision Presets to `NoCollision`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This target sphere needs a material too. For this, we'll create an emissive
    material with a dark outline so it shows up clearly on both light and dark backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material named `M_WidgetInteractionTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the *V* key and click to create a vector parameter. Name it `BaseColor` and
    set its default value to pure white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an output from `BaseColor` and click `–` to create a Subtract node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the result of the Subtract node into the material's Base Color and Emissive
    inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a Fresnel node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold the 1 key and click to create a scalar material expression constant. Set
    its value to 15.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed it into the Fresnel node's ExponentIn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Ctrl *+ *W* to duplicate it, set the new constant's value to 0, and feed
    it into the Fresnel node's BaseReflectFractionIn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *M* and click to create a Multiply node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the Fresnel node's result into the Multiply node's A input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold *S* and click to create a scalar parameter. Name it `OutlineThickness` and
    set its default value to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed OutlineThickness into the Multiply node's B input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the Multiply node''s result into the Subtract node''s B input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc745b2c-0a82-4319-bf08-367821dc9dc3.png)'
  prefs: []
  type: TYPE_IMG
- en: In your content browser, create a material instance from this material named
    `MI_WidgetInteractionTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `MI_WidgetInteractionTarget` to the `InteractionBeamTarget` sphere we
    created on `BP_VRPawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set its position to the interaction component's impact location.
  prefs: []
  type: TYPE_NORMAL
- en: In `BP_VRPawn` player's event graph, find the `Event Tick` and create a Sequence
    node between `Event Tick` and the `UpdateTeleport_Implementation` collapsed graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to `WidgetInteraction` onto the graph, and call `Get Last Hit
    Result` on its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the Return Value and select Split Struct Pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a reference to the `InteractionBeamTarget` static mesh component onto the
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `SetWorldLocation` on it, and feed the Return Value Impact Point from `Get
    Last Hit Result` into its new location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Sequence node's Then 1 output to the SetWorldLocation node's execution
    input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select these new nodes, right-click, and select Collapse Nodes. Name the collapsed
    graph `UpdateWidgetInteractionTarget_Implementation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b67c8a4a-f236-46ce-b2d4-22c8447fcffd.png)'
  prefs: []
  type: TYPE_IMG
- en: Open up the collapsed graph and clean it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The collapsed graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f32f3377-898b-403b-8158-7d3e6d6e8e22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Test it out. The beam isn''t bad, and the target point is fairly easy to spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6efd78d1-54b6-4d5c-9558-b34744d49593.png)'
  prefs: []
  type: TYPE_IMG
- en: There's quite a lot more we could do with this, like cutting off the beam where
    it hits a widget, and adjusting the target sphere's scale based on how close it
    is to the player's view, but what we have here is a very good starting ground.
    This system does a lot, and does it in ways that would be easy to extend and improve
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: Explore the level and try out the companion controller. While what we've put
    together here is fairly streamlined, it contains the seeds for quite a lot of
    things we might want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a major remaining piece to our development repertoire
    and added functional UI elements to our project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a simple AI-controlled character and
    animate it, and we learned how to create a UI in 3D space using UMG, which also
    allowed us to change the character's AI state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to move on from creating characters and interfaces,
    and begin to explore creating environments for use in VR.
  prefs: []
  type: TYPE_NORMAL
