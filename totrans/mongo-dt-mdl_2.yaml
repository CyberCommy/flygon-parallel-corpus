- en: Chapter 2. Data Modeling with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data modeling is a very important process during the conception of an application
    since this step will help you to define the necessary requirements for the database's
    construction. This definition is precisely the result of the data understanding
    acquired during the data modeling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously described, this process, regardless of the chosen data model,
    is commonly divided into two phases: one that is very close to the user''s view
    and the other that is a translation of this view to a conceptual schema. In the
    scenario of relational database modeling, the main challenge is to build a robust
    database from these two phases, with the aim of guaranteeing updates to it with
    any impact during the application''s lifecycle.'
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of NoSQL compared to relational databases is that NoSQL databases
    are more flexible at this point, due to the possibility of a schemaless model
    that, in theory, can cause less impact on the user's view if a modification in
    the data model is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the flexibility NoSQL offers, it is important to previously know how
    we will use the data in order to model a NoSQL database. It is a good idea not
    to plan the data format to be persisted, even in a NoSQL database. Moreover, at
    first sight, this is the point where database administrators, quite used to the
    relational world, become more uncomfortable.
  prefs: []
  type: TYPE_NORMAL
- en: Relational database standards, such as SQL, brought us a sense of security and
    stability by setting up rules, norms, and criteria. On the other hand, we will
    dare to state that this security turned database designers distant of the domain
    from which the data to be stored is drawn.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happened with application developers. There is a notable divergence
    of interests among them and database administrators, especially regarding data
    models.
  prefs: []
  type: TYPE_NORMAL
- en: The NoSQL databases practically bring the need for an approximation between
    database professionals and the applications, and also the need for an approximation
    between developers and databases.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, even though you may be a data modeler/designer or a database
    administrator, don't be scared if from now on we address subjects that are out
    of your comfort zone. Be prepared to start using words common from the application
    developer's point of view, and add them to your vocabulary. This chapter will
    present the MongoDB data model along with the main concepts and structures available
    for the development and maintenance of this model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing your documents and collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document's characteristics and structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the document's design and patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing documents and collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB has the document as a basic unity of data. The documents in MongoDB
    are represented in **JavaScript Object Notation** (**JSON**).
  prefs: []
  type: TYPE_NORMAL
- en: Collections are groups of documents. Making an analogy, a collection is similar
    to a table in a relational model and a document is a record in this table. And
    finally, collections belong to a database in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The documents are serialized on disk in a format known as **Binary JSON** (**BSON**),
    a binary representation of a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a document is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the relational model, where you must declare a table structure, a collection
    doesn't enforce a certain structure for a document. It is possible that a collection
    contains documents with completely different structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have, for instance, on the same `users` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, another interesting feature of MongoDB is that not just
    data is represented by documents. Basically, all user interactions with MongoDB
    are made through documents. Besides data recording, documents are a means to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define what data can be read, written, and/or updated in queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define which fields will be updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query the information from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we go deep into the technical details of documents, let's explore their
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** is a text format for the open-standard representation of data and
    that is ideal for data traffic. To explore the JSON format deeper, you can check
    *ECMA-404 The JSON Data Interchange Standard* where the JSON format is fully described.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSON is described by two standards: ECMA-404 and RFC 7159\. The first one puts
    more focus on the JSON grammar and syntax, while the second provides semantic
    and security considerations.'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, JSON arises from the JavaScript language. It came about
    as a solution for object state transfers between the web server and the browser.
    Despite being part of JavaScript, it is possible to find generators and readers
    for JSON in almost all the most popular programming languages such as C, Java,
    and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON format is also considered highly friendly and human-readable. JSON
    does not depend on the platform chosen, and its specification are based on two
    data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: A set or group of key/value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value ordered list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in order to clarify any doubts, let''s talk about objects. Objects are
    a non-ordered collection of key/value pairs that are represented by the following
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In relation to the value ordered list, a collection is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JSON specification, a value can be:'
  prefs: []
  type: TYPE_NORMAL
- en: A string delimited with `" "`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number, with or without a sign, on a decimal base (base 10). This number can
    have a fractional part, delimited by a period (`.`), or an exponential part followed
    by `e` or `E`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean values (`true` or `false`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `null` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another value ordered array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows us the JSON value structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON](img/B04075_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of JSON code that describes a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: BSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BSON** means **Binary JSON**, which, in other words, means binary-encoded
    serialization for JSON documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are seeking more knowledge on BSON, I suggest you take a look at the
    BSON specification on [http://bsonspec.org/](http://bsonspec.org/).
  prefs: []
  type: TYPE_NORMAL
- en: If we compare BSON to the other binary formats, BSON has the advantage of being
    a model that allows you more flexibility. Also, one of its characteristics is
    that it's lightweight—a feature that is very important for data transport on the
    Web.
  prefs: []
  type: TYPE_NORMAL
- en: The BSON format was designed to be easily navigable and both encoded and decoded
    in a very efficient way for most of the programming languages that are based on
    C. This is the reason why BSON was chosen as the data format for MongoDB disk
    persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of data representation in BSON are:'
  prefs: []
  type: TYPE_NORMAL
- en: String UTF-8 (`string`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer 32-bit (`int32`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer 64-bit (`int64`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point (`double`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document (`document`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array (`document`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary data (`binary`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean false (`\x00` or byte 0000 0000)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean true (`\x01` or byte 0000 0001)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTC datetime (`int64`)—the int64 is UTC milliseconds since the Unix epoch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp (`int64`)—this is the special internal type used by MongoDB replication
    and sharding; the first 4 bytes are an increment, and the last 4 are a timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null value ()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression (`cstring`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript code (`string`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript code w/scope (`code_w_s`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min key()—the special type that compares a lower value than all other possible
    BSON element values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max key()—the special type that compares a higher value than all other possible
    BSON element values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ObjectId (`byte`*12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go into detail about how we must model documents, we need a better
    understanding of some of its characteristics. These characteristics can determine
    your decision about how the document must be modeled.
  prefs: []
  type: TYPE_NORMAL
- en: The document size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must keep in mind that the maximum length for a BSON document is 16 MB. According
    to BSON specifications, this length is ideal for data transfers through the Web
    and to avoid the excessive use of RAM. But this is only a recommendation. Nowadays,
    a document can exceed the 16 MB length by using GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GridFS allows us to store documents in MongoDB that are larger than the BSON
    maximum size, by dividing it into parts, or chunks. Each chunk is a new document
    with 255 K of size.
  prefs: []
  type: TYPE_NORMAL
- en: Names and values for a field in a document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few things that you must know about names and values for fields
    in a document. First of all, any field''s name in a document is a string. As usual,
    we have some restrictions on field names. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `_id` field is reserved for a primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot start the name using the character `$`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name cannot have a null character, or (`.`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, documents that have indexed fields must respect the size limit
    for an indexed field. The values cannot exceed the maximum size of 1,024 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The document primary key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the preceding section, the `_id` field is reserved for the primary
    key. By default, this field must be the first one in the document, even when,
    during an insertion, it is not the first field to be inserted. In these cases,
    MongoDB moves it to the first position. Also, by definition, it is in this field
    that a unique index will be created.
  prefs: []
  type: TYPE_NORMAL
- en: The `_id` field can have any value that is a BSON type, except the array. Moreover,
    if a document is created without an indication of the `_id` field, MongoDB will
    automatically create an `_id` field of the ObjectId type. However, this is not
    the only option. You can use any value you want to identify your document as long
    as it is unique. There is another option, that is, generating an auto-incremental
    value based on a support collection or on an optimistic loop.
  prefs: []
  type: TYPE_NORMAL
- en: Support collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this method, we use a separate collection that will keep the last used value
    in the sequence. To increment the sequence, first we should query the last used
    value. After this, we can use the operator `$inc` to increment the value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a collection called `system.js` that can keep the JavaScript code in
    order to reuse it. Be careful not to include application logic in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The optimistic loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generation of the `_id` field by an optimistic loop is done by incrementing
    each iteration and, after that, attempting to insert it in a new document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, the iteration does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Searches in `targetCollection` for the maximum value for `_id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Settles the next value for `_id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the value on the document to be inserted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inserts the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of errors due to duplicated `_id` fields, the loop repeats itself,
    or else the iteration ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The points demonstrated here are the basics to understanding all the possibilities
    and approaches that this tool can offer. But, although we can use auto-incrementing
    fields for MongoDB, we must avoid using them because this tool does not scale
    for a huge data mass.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, I believe you must be asking yourself: if the basic structure
    of the document is JSON (something so simple and textual), what can be so complex
    about the creation of a NoSQL database?'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see! First of all, yes! You are right. NoSQL databases can be very simple.
    But, this does not mean that their structure will be less complex than that of
    a relational database. It will be different, though!
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, collections do not force you to define the document's
    structure beforehand. But this is certainly a decision that you must make at some
    point. This decision will affect important aspects, especially in matters regarding
    a query's performance.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you are likely to have also asked yourself how the applications represent
    a relationship between documents. If you did not think about this until now, it
    is not your fault. We are used to thinking about the relational world, such as
    wondering what the relationship is between a student and their classes or between
    a product and its orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also has its own way of representing this kind of relationship. In
    fact, there are two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedded documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with embedded documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through the use of subdocuments, we can build more complex and optimized data
    structures. Thus, when we are modeling a document, we can choose to embed related
    data in one document.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to embed data in one document is often related to the intention
    to get a better read performance, since with one query we can completely retrieve
    the information we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can deduce, this document represents a blog post. The advantage of this
    kind of document is that, with a single query, we have all the data we need to
    present to the user. The same applies to updates: with just one query, we can
    modify the content of this document. Nevertheless, when we decide to embed data,
    we must ensure that the document does not exceed the BSON size limit of 16 MB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no rule when embedding data in MongoDB, but overall, we should observe:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether we have a one-to-one relationship between documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we have a one-to-many relationship between documents, and whether the
    "many" part of the relationship is very dependent of the "one" part. This means,
    for instance, that every time we present the "one" part, we will also present
    the "many" part of the relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our model fits in one of the preceding scenarios, we should consider using
    embedded documents.
  prefs: []
  type: TYPE_NORMAL
- en: Working with references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normalization is a fundamental process to help build relational data models.
    In order to minimize redundancy, in this process we divide larger tables into
    smaller ones and define relationships among them. We can say that creating a reference
    in MongoDB is the way we have to "normalize" our model. This reference will describe
    the relationship between documents.
  prefs: []
  type: TYPE_NORMAL
- en: You may be confused about why we are considering relationships in a non-relational
    universe, even though this does not mean that relationships are not present in
    NoSQL databases. We will very often use the concepts of relational modeling to
    solve common problems. As stated before, to eliminate redundancy, documents can
    refer to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! There is something very important you should know from now on: MongoDB
    does not support joins. This means that, even with the reference to another document,
    you must perform at least two queries to get the complete information you need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have documents from the `products` collection.
    We can see that, in the three products'' instances, we have the same value for
    the supplier key. Instead of this repetition of data, we could have two collections:
    `products` and `suppliers`, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular case, with a few products by the supplier, the choice to
    reference products based on the supplier is good. However, if the scenario were
    the opposite, a better approach would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no rule for references using MongoDB, but overall, we should observe:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether we are duplicating the same information many times while embedding data
    (this shows poor reading performance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we need to represent many-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether our model is a hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our model fits in one of the preceding scenarios, we should consider the
    use of references.
  prefs: []
  type: TYPE_NORMAL
- en: Atomicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important concept that will affect our decisions when designing a document
    is atomicity. In MongoDB, operations are atomic at the document level. This means
    that we can modify one document at a time. Even if we have an operation that works
    in more than one document in a collection, this operation will happen in one document
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when we decide to model a document with embedded data, we simply write
    operations, since all the data we need is in the same document. This is opposed
    to what happens when we choose to reference data, where we require many write
    operations that are not atomic.
  prefs: []
  type: TYPE_NORMAL
- en: Common document patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understood the way we can design our documents, let's take some
    examples of real-life problems, such as how to write a data model that better
    describes the relationship between entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will present you with patterns that illustrate when to embed or
    when to reference documents. Until now, we have considered as a deciding factor:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether consistency is the priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether read is the priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether write is the priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What update queries we will make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document growth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-one relationships are simpler than the others. Most of the time, we will
    map this relationship with embedded documents, especially if it is a "contains"
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a customer''s document. In the first case, there
    is a reference in a `customerDetails` document; in the second, we see a reference
    with embedded data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referenced data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With embedded data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of representing the relationship with an embedded document is
    that the customer detail data is always available when we query a customer. Thus,
    we can say that a customer's details do not make sense by themselves, only alongside
    the customer data.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-many relationships are more complex than one-to-one relationships. In
    order to decide when to embed or to make references, we must consider the "many"
    side of the relationship. If the many side should be displayed with its parents,
    then we should choose to embed the data; otherwise, we can use references on the
    parents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of `customer` and the customer''s address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If, every time you want to display a customer''s address, you also need to
    display the customer''s name, then embedded documents are recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A many-to-many relationship is not something trivial, even in a relational universe.
    In the relational world, this kind of relationship is often represented as a join
    table while, in the non-relational one, it can be represented in many different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will see a classic example of a `user` and `group`
    relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s store the relationship in the `User` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can store the relationship in the `group` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, let''s store the relationship in both documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to build documents in MongoDB, examined their characteristics,
    and saw how they are organized into collections.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand how important it is to already know the domain of the application
    in order to design the best models possible, and you saw some of the patterns
    that can help you to decide how to design your documents.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to query these collections and modify the
    data that stored in them.
  prefs: []
  type: TYPE_NORMAL
