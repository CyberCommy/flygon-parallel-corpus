- en: Example – Building BugZot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last few chapters, we have discussed numerous techniques that deal
    with building an enterprise-scale application. But what good is that knowledge
    if we don't have any idea where to utilize it?
  prefs: []
  type: TYPE_NORMAL
- en: During the course of this chapter, we will walk through the process of building
    an enterprise-grade web application, which will be used to track bugs reported
    by various stakeholders of products that are marketed by the Omega Corporation.
    The system that we will, from now on, call **BugZot**, aims to provide such functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The application will use various concepts to build the system in a manner that
    allows it to be scaled easily as the number of users interacting with the system
    grows. We will see how to utilize the various techniques of optimized data access
    and storage, highly scalable deployments, and caching, to build an application
    that performs well, even in high load scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing existing web frameworks for building an enterprise-grade web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing optimizations to database access to speed up the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing caching techniques to reduce load on the application backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing multithreading techniques to increase application concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying application in a scalable manner for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter06` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The chapter aims to build a scalable bug tracking web application. To achieve
    this, we use quite a lot of pre-existing libraries and tools that are openly available
    and well tested to suit various use cases over time. The following set of tools
    will be required to build and run the demo application:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL 9.6 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask—Microframework for web development in Python ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first part of building any enterprise-grade application is to define what
    the application aims to do. Up to now, we know that our application is going to
    track bugs for the various products that are marketed by the Omega Corporation.
    But what things are required from our application that will prove to be useful
    for bug tracking? Let's take a look and try to define the requirements for the
    application that we are going to build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Support for multiple products**: One of the fundamental requirements for
    our bug tracking system is to support the tracking of bugs for multiple products
    that the organization builds. This is also a required feature considering the
    future growth of the organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for multiple components per product**: Although we can file the bugs
    at the product level itself, it will be too clumsy, specifically considering that
    most of the organizations have a separate team working on orthogonal features
    of a product. To make the tracking of bugs easier based on which component they
    have been filed, the bug tracking system should support the filing of bugs on
    a component to component basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for attachments**: Many a time, the users filing a bug, or the ones
    involved in any way in the bug life cycle, might want to attach images showing
    the effect of the bug, or may want to attach patches to the bug so they can be
    tested before being incorporating into the product. This will require the bug
    tracking system to provide support for attaching files to the bug reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for comments**: Once the bug has been filed, a user who is responsible
    for solving that bug might require some other information about the bug, or may
    require some collaboration. This makes it compulsory for the bug tracking system
    to have support for comments. Also, not every comment can be made public. For
    example, if there is some patch that the developers might have attached to the
    bug report to be tested by the original submitter of the bug, but which has not
    yet been incorporated into the main product, the developers might want to keep
    the patch private, so that it can be seen only by people with privileged access.
    This makes the inclusion of functionality for private comments also a necessity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for multiple user roles**: Not everyone in the organization has the
    same level of access to the bug tracking system. For example, only people at the
    director level should be able to add new components to a product, and only employees
    should be able to see private comments on a bug. This calls for the inclusion
    of role-based access as a requirement for the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some of the requirements that are specific to our bug tracking system.
    However, as a consequences of these, there are a few more requirements that obviously
    need to be included in the system. Some of these requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement for a user authentication system**: The system should provide
    a mechanism for authenticating the users based on some simple mechanism. For example,
    a user should be able to sign into the system by providing their username and
    password, or email id and password combination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web interface for filing a new bug**: The application should provide a simple
    to use web interface that can be used by the users to file new bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for bug life cycle**: Once a bug has been filed into the system,
    its life cycle starts in the NEW state. From there it may move on to the ASSIGNED
    state, when someone from the organization picks up the bug for validation and
    reproduction. From there, the bug can move into various states. This is known
    as a bug life cycle inside our tracking system. Our bug tracking system should
    provide the support for this life cycle, and how to handle it when the bug moves
    from one state to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with this, we finally have our requirements in place. These requirements
    play an important role when we move onto designing and defining how our bug tracking
    web application will be built. So, with the requirements in place, it's time for
    us to move onto defining how our code base will look.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the development phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our project structure defined and in place, it's time for us to get up
    and start developing our application. The development phase involves various steps,
    which include setting up the development environment, developing models, creating
    views that map to the models, and setting up the server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step before we begin our development is to set up our development
    environment. This involves getting the required packages in place, and setting
    up the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our web application relies heavily on the database for managing the individual
    records related to the users and the bugs that have been filed. For the demo application,
    we will set back with the PostgreSQL as the choice for our database. To install
    it on an RPM-based distribution, such as Fedora, the following command needs to
    be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To install `postgresql` on any other distribution of Linux or any other operating
    system like Windows or Mac OS, the required commands for the distribution/OS will
    need to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the database installed, the next step is to initialize the database
    so that it can be used to store our application data. For setting ...
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now with the database in place, let''s set up the virtual environment, which
    we will use for the purpose of application development. To set up the virtual
    environment, let''s run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will set up a virtual environment in our current directory. The
    next thing after the virtual environment is set up is to install the required
    framework for the application development and other packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we move on to installing the required packages, let''s just
    first activate our virtual environment by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a design decision, we will base our application on the Python Flask micro
    framework for web application development. The framework is an open source framework,
    which has been around for quite some years and enjoys the support of various plugins
    that can be easily installed along with the framework. The framework also is a
    very light framework, which comes with bare minimum set of modules pre-packaged,
    hence allowing for a smaller footprint. To install `flask`, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have Flask installed, let''s move onto setting up a few other required
    packages that we are going to use in the development of our web application by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are now done with the setup of our virtual environment. Now, let's
    move onto setting up how our code base will look.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are at a stage where we need to decide how our project structure will
    look. The project structure has a lot of importance, since it decides how the
    different components in our code will interact with each other and what point
    will mark the entry point of our application.
  prefs: []
  type: TYPE_NORMAL
- en: A well-structured project will not only help in providing a better navigation
    for the project, but will also help in providing increased coherency between different
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at how our code structure will look and understand the
    significance of what a particular directory or file stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the Flask project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are finally entering the fun phase of our project where we will be building
    this project from scratch. So, let's not wait too long before we can see some
    action. The first thing we will do is to set up a basic project with Flask and
    get it running. To do this, let's fire up our code editor and set up our initial
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the file `bugzot/application.py` and initialize our application
    code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we have completed the very basic setup of our application. Let's spend
    some time trying to understand what we did here.
  prefs: []
  type: TYPE_NORMAL
- en: At the very start of the file, we first imported the required packages over
    which we will be building our project. We imported the `Flask` application class
    from the package `flask`. Similarly, we import the code hashing library `bcrypt`,
    the `Flask` session class, and the SQLAlchemy support package for Flask, which
    provides SQLAlchemy integration with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have imported all the required packages, the next thing is to initialize
    our Flask application. To do this, we create an instance of `Flask` class and
    store it in an object named `app`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While creating this instance, we pass the class constructor two parameters.
    The first parameter is used to signify the name of the application to Flask. `__name__`
    provides, which we pass as the application name to the constructor. The second
    parameter, `instance_relative_config` allows us to override the application configuration
    from an instance folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we have our Flask application instance setup done. Next thing inline
    is to load up the configuration for the application, which will be used to configure
    how the different components inside our application behave, and how our application
    will be served to the user. To do this, we need to read from our configuration
    file. The following two lines achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line loads up our `config.py` file under the project root, treats
    it as an object, and loads up its configuration. The second line is responsible
    for reading the `config.py` file under the instance directory and loading any
    configuration that may be present there.
  prefs: []
  type: TYPE_NORMAL
- en: Once these configurations are loaded, they are available under the `app.config`
    object. Most of the Flask plugins are configured to read the configuration from
    the `app.config`, hence reducing the clutter that may happen if every plugin had
    a different mechanism for dealing with the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our configuration loaded up inside our application, we can now move on
    to initialize the remaining modules that we may require. In particular, we require
    a few more modules to establish our application functionality. These modules include
    the SQLAlchemy engine, which we will use to build and interact with our database
    models, a sessions module, which will be required to manage user sessions across
    the application, and a `bcrypt` module, which will be required to provide encryption
    support across the application. The following lines of code provide this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from these lines of code, to configure these modules, all we needed
    to do was pass the Flask application object as a parameter to the respective class
    constructors and their configuration will be picked up from there itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have our application initialization code in place, the next thing we
    need to do is to export the required components from our BugZot module so the
    application can be called from the project root.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, all we need to do is to get these modules included in the module
    entry point. So, let's fire up the code editor and open `bugzot/__init__.py` where
    we need to get these objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And we are done. We have all the required objects exported in our BugZot module.
    Now, the question is how to launch our application. So, to launch our application
    and make it serve the incoming requests, we need to complete a few more steps.
    So, let''s open up the `run.py` file inside our project root and add the following
    lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And we are done. Wasn't that simple? All we did here was to import the `flask`
    app object we created inside our BugZot module and call the `run` method of the
    `app` object passing it the value for the `hostname` on which the application
    will be serving the users, and the port on which the application server should
    bind to listen to the requests.
  prefs: []
  type: TYPE_NORMAL
- en: We are now all set to start our application server and make it listen to the
    incoming requests. However, before we do that, we need to just complete one more
    step, which is to create the configuration for the application. So, let's get
    going and create the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start our application, we need to configure our modules that
    we are going to use in our application. So, let''s first go ahead and create the
    global configuration of our application by opening up `config.py` in our code
    editor and adding the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have drafted our global application configuration. Let's try to
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Developing database models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database model forms an integral part of any real life application. This
    is because any serious application in enterprises will for sure be dealing with
    some kind of data that needs to be persisted across the time.
  prefs: []
  type: TYPE_NORMAL
- en: The same is the case for our BugZot. BugZot is used to track the bugs and their
    life cycle that are encountered in the products of Omega Corporation. Also, the
    application will have to keep a record of users that are registered on it. To
    achieve this, we will require multiple models, each serving its own purpose.
  prefs: []
  type: TYPE_NORMAL
- en: For the development of this application, we will group all the related models
    under their own separate directories, so that we can maintain the clarity about
    which models serves what purpose. Also, this allows us to keep the code base clean
    from clutter, which may make it hard for the developers to understand what each
    file does as the code base grows in the future.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's first get started with the development of the models that are required
    to manage the user accounts-related information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the development of the user account-related models, we
    first go on and create a directory named `users` inside our models directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then initialize it as a submodule inside the models module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done with this, we are good to go with the creation of our user
    model whose definition is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we just created our user model that can be used to store the information
    related to our users. Most of the columns just provide the definitions for the
    data that we expect to store inside the database. However, there are a couple
    of interesting bits here, so let''s go through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see this attribute is mentioned in the username and the email column
    definition. We set the index attribute to True in the two columns because these
    two columns can be used frequently to access the data related to a particular
    user, and hence can benefit from the added optimization that comes with indexing.
  prefs: []
  type: TYPE_NORMAL
- en: The next interesting piece of information here is the relationship mapping to
    the roles model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since every user inside our database has a role associated to it, we can just
    add a one to one relationship mapping from our user model to the role model. Also,
    if we take a look carefully, we have set `lazy=False`. There is a small reason
    why we want to avoid lazy loading here. The roles model is usually small, and
    there is only a one-to-one mapping from the users model to the role model. By
    avoiding lazy loading, we are shedding off some time that would have been spent
    in waiting, had our database access layer lazily loaded the data from the roles
    model. Now, the question arises, where is the role model?
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the role model can be found under the `bugzot/models/users/roles.py`
    file, but we explicitly are not providing that definition here inside the book,
    to keep the chapter concise.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need a mechanism for verifying the email address of the users. We can
    do this by sending the users a small email containing an activation link, which
    they need to click. To do this, we also have to generate and store an activation
    key for every new user. For this, we leverage a new model named `ActivationKey`
    model whose definition can be found under the `bugzot/models/users/activation_key.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of this is done, we are now ready to export these models out of our
    users model submodule. To do this, let''s fire up the module entrypoint file inside
    our code editor and export the models by adding the following lines to the `bugzot/models/users/__init__.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done with the definition of our data models related to storing
    the information about the users.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing inside our application is to define data models related to the
    categorization of the products for which the bugs can be filed. So, let's jump
    into the creation of the models related to the product categorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating the models related to the products, we first create a new submodule
    directory under the `bugzot/models` module and initialize it. Next, we provide
    the definition for the product model under `bugzot/models/products/products.py`
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this a we have completed the definition of the product model that will
    be used to keep a track of the products, against which the bugs can be filed in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more model definitions inside our products submodule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Category**: The category model is responsible for storing the information
    about the product categories to which a particular product belongs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component**: The component model is responsible for storing the information
    related to the product components against which a bug can be filed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: The version model is responsible for storing the information related
    to the product versions against which a bug can be categorised'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all these models are defined, they can be exported out from the product's
    submodule so that they can be utilized inside the application.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, we define the models related to the tracking of the bugs
    inside the system. We will skip over mentioning the definition of these models
    inside this chapter to keep the chapter length reasonable, but, for the curious
    mind, the definitions of these models can be easily tracked inside the `bugzot/models/bugs`
    directory in the code repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the database models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our database models created and ready for use, the next thing is to migrate
    these database models to the database server that we are using to run the application.
    The process to do this is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'To migrate the models to the database server, we first expose them into the
    application root. For example, to migrate the database models related to the users
    and products, all we need to do is to add the following line to the `bugzot/__init__.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, all we need to do is to call the `create_all()` method of
    the SQLAlchemy database object we created. This can be done by adding the following
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Building the views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the models are generated and are ready for use, the next thing we require
    is to have a mechanism through which we can interact with these models in order
    to access or modify them. One of the ways through which we can achieve this functionality
    is through the use of views.
  prefs: []
  type: TYPE_NORMAL
- en: With Flask, building the views is quite an easy task. The Flask web framework
    provides multiple methods for building views. Indeed, the `/ping` endpoint could
    also be termed as one of the views only which was built using a procedural style.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the example, we will now try to follow object oriented methodology
    while defining any of the resources in the application. So, let's move on and
    start developing some of our views.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the index view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a user visits our application, most likely it will be the case that
    the user will be landing on the home page of the application. So, the first thing
    we build is the index view. This will also be one of the places where we can understand
    how to build simple views in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as the first step, let''s create a new module inside the views directory
    of our project workspace for the index module by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we are now ready to code our first view, the code for which follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getting the index view to render
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have the index view ready. But, before this view can be served to the
    user, we need to provide Flask with a mapping about the endpoint on which this
    view will be rendered. To achieve this, let''s fire up our code editor and open
    `bugzot/__init__.py` and add the following lines to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, our focus is on the second line, which is responsible for mapping our
    view with a URL endpoint. The `add_url_rule()` of our flask application is the
    one that is responsible for providing these mappings. The method takes as its
    first parameter the URL path on which the view should be rendered. The `view_func`
    parameter provided to the method takes in the view that needs to be rendered on
    the provided URL endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we are now ready to serve our index page. All we need to
    do now is to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then visit [http://localhost:8000/](http://localhost:8000/) on your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user registration view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, with the index view deployed and ready for use, let's move on to building
    a more complicated view where we allow the users to register on BugZot.
  prefs: []
  type: TYPE_NORMAL
- en: The following code implements a view known as `UserRegisterView`, which will
    allow the users to register to BugZot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deploying for concurrent access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we were in the development stage and we could easily use the development
    server that comes packaged with Flask to quickly test our changes. But this development
    server is not a good choice if you are planning to run the application in production,
    and we need something more dedicated for that. This is because, in a production
    environment, we will be more concerned about the concurrency of the application,
    as well as its security aspects, like enabling SSL and providing more restricted
    access to some of the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to figure out some choices here based on the fact that we need our
    application to handle a lot of concurrent accesses, while constantly maintaining
    a good response time for the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we end up with the following set of choices, which, by their
    nature are also fairly common in many production environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application server**: Gunicorn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse Proxy**: Nginx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, Gunicorn will be the application that will be responsible for handling
    the requests that are to be served by our Flask application, while Nginx takes
    care of request queuing and handling the distribution of the static assets.
  prefs: []
  type: TYPE_NORMAL
- en: So, first, let's set up Gunicorn and how we are going to serve the application
    through it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Gunicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step that is involved in the setup of Gunicorn is its installation,
    which is quite an easy task. All we need to do is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we have Gunicorn available to be run. Gunicorn runs the
    application through **WSGI**, which stands for Web Server Gateway Interface. For
    Gunicorn to run our application, we need to create an additional file in our project
    workspace, known as `wsgi.py`, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once we have defined the interface file, all we need to do is to run the following
    command to make Gunicorn ...
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Nginx as reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Nginx as our reverse proxy solution, we first need to get it installed
    on our system. For Fedora-based distributions, this can be easily installed by
    using the `dnf` or `yum` based package manager by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For other distributions, their package managers can be used to install the Nginx
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Nginx package is installed, we now need to do its configuration to
    allow it to communicate with our application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Nginx to proxy the communication to our application server, create
    a file named `bugzot.conf` under the `/etc/nginx/conf.d` directory, with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now with the Nginx configured, we need to establish a relationship between our
    Gunicorn application server and Ngnix. So, let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing communication between Nginx and Gunicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing to note inside the Nginx configuration that we just completed was
    the `proxy_pass` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The line tells Nginx to look for a socket file through which Nginx can communicate
    to the application server. We can tell Gunicorn to create this proxy file for
    us. This can be done by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this command, our Gunicorn web server will create a Unix socket
    and bind to it. Now, all that is remaining is to start our Nginx web server, which
    can be easily achieved by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, ...
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained hands-on experience of how we can develop and host
    an enterprise-scale web application. To achieve this, we first started by making
    some technology decisions about which web frameworks and databases we were going
    to use. We then progressed to defining our project structure and how it will look
    on disk. The main aim was to achieve high modularity and less coupling between
    code. Once the project structure was defined, we then initialized a simple Flask
    application and implemented a route to check whether our server worked fine or
    not. We later progressed on to defining our models and views. Once these were
    defined, we altered our application to enable new routes that provide access to
    our views. Once our application development cycle was over, we then moved on to
    understanding how an application can be deployed using Gunicorn and Nginx to handle
    a large number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now as we move on to the next chapter, we will take a look at how we can work
    on to develop an optimized frontend for the applications we are developing and
    how can a frontend affect the experience of the user while interacting with our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are some of the other pre-built view classes provided by Flask?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we remove the foreign key constraint to role table from our user table without
    removing the relationship?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the other options apart from Gunicorn for serving the application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we increase the number of Gunicorn workers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
