- en: '*Chapter 17*: Data Persistence and Sharing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a couple of different ways to save data to
    an Android device's permanent storage. Also, for the first time, we will add a
    second `Activity` to our app. It often makes sense when implementing a separate
    "screen" in our app, such as a settings screen, to do so in a new `Activity`.
    We could go to the trouble of hiding the original UI and then showing the new
    UI, but this would quickly lead to confusing and error-prone code. So, we will
    see how to add an `Activity` class and navigate the user between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, in this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about using Android intents to switch between `Activity` classes and pass
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple (very simple) settings screen in a new `Activity` class for
    the Note to Self project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist the settings screen data using the `SharedPreferences` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about **JavaScript Object Notation** (**JSON**) for serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore Java's `try`-`catch`-`finally` syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement saving data in our Note to Self app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017).
  prefs: []
  type: TYPE_NORMAL
- en: Android intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Intent` class is appropriately named. It is a class that demonstrates the
    intent of an `Activity` class from our app. It makes an intent clear and it also
    facilitates it.
  prefs: []
  type: TYPE_NORMAL
- en: All our apps so far have had just one `Activity`, but many Android apps comprise
    more than one.
  prefs: []
  type: TYPE_NORMAL
- en: In perhaps its most common use, an `Intent` class allows us to switch between
    `Activity` instances. But of course, `Activity` instances are made from classes
    with member variables. So, what happens to the variable's value – the data – when
    we switch between them? Intents handle this problem for us by allowing us to pass
    data between `Activity` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Intents aren't just about wiring up the `Activity` instances of our app. They
    also make it possible to interact with other apps too. For example, we could provide
    a link in our app for the user to send an email, make a phone call, interact with
    social media, or open a web page in a browser and have the email app, phone call
    app, social media app, or web browser do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: There aren't enough pages in this book to really dig deep into interacting with
    other apps, and we will mainly focus on switching between activities and passing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Switching Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have an app with two `Activity`-based classes, because we will
    soon. We can assume that as usual, we have an `Activity` class called `MainActivity`,
    which is where the app starts, and a second `Activity` called `SettingsActivity`.
    This is how we can swap from `MainActivity` to `SettingsActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Look carefully at how we initialized the `Intent` object. `Intent` has a constructor
    that takes two arguments. The first is a reference to the current `Activity`,
    `this`. And the second parameter is the name of the `Activity` class we want to
    open, `SettingsActivity.class`. The `.class` part on the end of `SettingsActivity`
    makes it the full name of the `Activity` class as declared in the `AndroidManifest.xml`
    file, and we will look at that when we experiment with intents shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that `SettingsActivity` doesn't share any of the data of
    `MainActivity`. In a way, this is a good thing because if you need all the data
    from `MainActivity`, then it is a reasonable indication that switching activities
    might not be the best way of proceeding with your app's design. It is, however,
    unreasonable to have encapsulation so thorough that the two `Activity` instances
    know absolutely nothing about each other.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we have a sign-in screen for the user and we want to pass the user's
    credentials to each `Activity` of our app? We could do so using intents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add data to an `Intent` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In `SettingsActivity`, we could then retrieve the string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous two blocks of code, we switched `Activity` in the same way as
    we have already seen. But before we called the `startActivity` method, we used
    the `putExtra` method to load a string into the intent.
  prefs: []
  type: TYPE_NORMAL
- en: We add data using `identifier` instance that can be used in the retrieving `Activity`
    to identify and retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: The identifier name is up to you, but useful/memorable values should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the receiving `Activity`, we simply create an intent using the default
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And we can then retrieve the data using the `getExtras` method and the appropriate
    identifier from the key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: Once we want to start sending more than a few values, it is worth considering
    different tactics.
  prefs: []
  type: TYPE_NORMAL
- en: The `Intent` class can help us when sending more complex data than this, but
    the `Intent` class has its limits. For example, we wouldn't be able to send a
    `Note` object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a settings page to Note to Self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are armed with all this knowledge about the Android `Intent` class,
    we can add another screen (`Activity`) to our Note to Self app. We will add a
    settings screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a new `Activity` for our settings screen and see what effect
    that has on the `AndroidManifest.xml` file; we will then create a very simple
    layout for our settings screen and add the Java code to switch from `MainActivity`
    to the new one. We will, however, defer wiring up our settings screen with Java
    until we have learned how to save the settings to disk. We will do this later
    in this chapter and then come back to the settings screen to make its data persist.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create that new `Activity` class. We will call it `SettingsActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SettingsActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will be a screen where the user can turn on or off the decorative divider
    between each note in the `RecyclerView` widget. This will not be a comprehensive
    settings screen but it will be a useful exercise, and we will learn how to switch
    between activities as well as saving data to disk. Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project explorer, right-click the folder that contains all your `.java`
    files and has the same name as your package. From the pop-up context menu, select
    **New** | **Activity** | **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `SettingsActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave all the other options at their defaults and left-click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio has created a new `Activity`-based class for us and its associated
    `.java` file. Let's take a quick peek at some of the work that was done behind
    the scenes for us because it is useful to know what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file from within the `manifests` folder in the
    project explorer. Notice the following line of code about halfway through this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is how an `Activity` class is `Activity` class is not registered, then
    an attempt to run it will crash the app. We could create an `Activity` class simply
    by creating a class that extends `Activity` (or `AppCompatActivity`) in a new
    `.java` file. However, we would then have to add the preceding code ourselves.
    Also, by using the new `Activity` wizard, we got a layout XML file (`activity_settings.xml`)
    automatically generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the settings screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will quickly build a UI for our settings screen, and the following steps
    and figure should make this straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_settings.xml` file, switch to the **Design** tab, and we
    will quickly lay out our settings screen. Use this next figure as a guide while
    following the rest of the steps:![Figure 17.1 – Designing the settings screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_17.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Designing the settings screen
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop a **Switch** widget onto the center top of the layout. I stretched
    mine by dragging the edges to make it larger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `id` attribute of `switch1` (if it isn't already by default) so we can
    interact with it using Java code from `SettingsActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constraint handles to fix the position of the switch or click the **Infer
    Constraints** button to fix it automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a simple new layout for our settings screen and the `id` property
    is in place, ready for when we wire it up with our Java code later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the user to switch to the settings screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know how to switch to `SettingsActivity`. Also, as we won't be passing
    any data to it or from it, we can get this working with just two lines of Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed in the action bar of our app that there is a menu icon.
    It is a default part of the Basic Activity template that we used when we created
    the project. It is indicated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Menu icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – Menu icon
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tap it, there is already a menu option in there for **Settings**, provided
    by default when we first created the app. This is what you will see when you tap
    the menu icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Settings option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.3_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 – Settings option
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do is place our code to switch to the `SettingsActivity` class
    within the `onOptionsItemSelected` method in the `MainActivity` class. Android
    Studio even provided an `if` block by default for us to paste our code into, on
    the assumption that we would one day want to add a settings screen. How thoughtful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `MainActivity.java` in the editor window and find the following block
    of code in the `onOptionsItemSelected` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code into the `if` block shown previously, just before the `return
    true` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to import the `Intent` class using your preferred technique to
    add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the app and visit the new settings screen by tapping the **Settings**
    menu option. This screenshot shows the settings screen running on the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Settings screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.4_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 – Settings screen
  prefs: []
  type: TYPE_NORMAL
- en: To return from `SettingsActivity` to `MainActivity`, you can tap the back button
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, there are a few ways to make data persist. By persist, I mean that
    if the user quits the app, then when they come back to it, their data is still
    available. Which method is the correct one to use is dependent upon the app and
    the type of data.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will look at three ways to make data persist. For saving our
    users' settings, we only need a simple method. After all, we just need to know
    whether they want the decorative divider between each of the notes in the `RecyclerView`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can make our apps save and reload variables to the internal
    storage of the device. We need to use the `SharedPreferences` class. `SharedPreferences`
    is a class that provides access to data that can be accessed and edited by all
    `Activity` classes of an app. Let''s look at how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all objects, we need to initialize them before we can use them. We
    can initialize the `prefs` object by using the `getSharedPreferences` method and
    passing in a string that will be used to refer to all the data read and written
    using this object. Typically, we could use the name of the app as the value for
    this string. In the next code, `MODE_PRIVATE` means that any class, in this app
    only, can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use our newly initialized `prefs` object to initialize our `editor`
    object by calling the `edit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we wanted to save the user''s name that we have in a string called
    `username`. We can then write the data to the internal memory of the device like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument used in the `putString` method is a label that can be used
    to refer to the data; the second is the actual variable that holds the data we
    want to save. The second line in the previous code initiates the saving process.
    So, we could write multiple variables to disk like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code demonstrates that you can save other variable types, and it
    of course assumes that the `username`, `age`, and `subscribed` variables have
    previously been declared and then initialized with appropriate values.
  prefs: []
  type: TYPE_NORMAL
- en: Once `editor.commit()` has executed, the data is stored. We can quit the app,
    even turn off the device, and the data will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading data with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can reload our data the next time the app is run. This code
    will reload the three values that the previous code saved. We could even declare
    our variables and initialize them with the stored values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we load the data from disk using the method appropriate
    for the data type and the same label we used to save the data in the first place.
    What is less clear is the second argument to each of the method calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `getString`, `getInt`, and `getBoolean` methods require a default value
    as the second parameter. If there is no data stored with that label, it will then
    return the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then check for these default values in our code and go about trying
    to obtain the real values. See here, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now know enough to save our users' settings in the Note to Self app.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Note to Self settings persist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to save data to the device's memory. As we implement
    saving the users' settings, we will also see again how we handle `Switch` input
    and where exactly the code we have just seen will go to make our app work the
    way we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the SettingsActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the action will take place in the `SettingsActivity.java` file. So,
    click on the appropriate tab and we will add the code a bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need some member variables that will give us working `SharedPreferences`
    and `Editor` instances. We also want a member variable to represent the user''s
    settings option: whether they want decorative dividers or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables to the `SettingsActivity` class just after
    the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `SharedPreferences` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `onCreate` method, add the code to initialize `mPrefs` and `mEditor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, still in the `onCreate` method, let's get a reference to our `Switch`
    widget and load up the saved data that represents our user's previous choice for
    whether to show the dividers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get a reference to the switch in the same way that we did in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes – Bringing Android Widgets to Life*. Notice the default value
    is `true` – to show the dividers. We will also set the switch to either on or
    off as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to import the `Switch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create an anonymous class to listen for and handle changes to our `Switch`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: When the `isChecked` variable is `true`, we use the `prefs` object to set the
    `dividers` label and the `mShowDividers` variable to `true`; when it is not checked,
    we set them both to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `onCreate` method that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to import the `CompoundButton` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that at no point in any of that code did we call the
    `mEditor.commit` method to save the user's settings. We could have placed it after
    we detected a change to the switch, but it is much simpler to put it where it
    is guaranteed to be called, but only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use our knowledge of the `Activity` lifecycle and override the `onPause`
    method. When the user leaves the `SettingsActivity` screen either to go back to
    `MainActivity` or to quit the app, the `onPause` method will be called by the
    operating system and the settings will be saved. Add this code to override the
    `onPause` method and save the user''s settings. Add the code just before the closing
    curly brace of the `SettingsActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can add some code to the `MainActivity` class to load the settings
    when the app starts or when the user switches back from the settings screen to
    the main screen.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this highlighted code to add some member variables after our `NoteAdapter`
    instance is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `SharedPreferences` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a `boolean` member to decide whether to show the dividers and a
    `SharedPreferences` instance to read the settings from disk.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will override the `onResume` method to initialize our `mPrefs` variable
    and load the settings into the `mShowDividers` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the overridden `onResume` method as shown next to the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The user is now able to choose their settings. The app will both save and reload
    them as necessary, but we need to make the `MainActivity` class respond to the
    user's choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find this code in the `onCreate` method and delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is what sets the dividers between each note in the list.
    Add this new code to the `onResume` method, which is the same line of code surrounded
    by an `if` statement, to selectively use dividers only when `mShowDividers` is
    `true`. Add the code after the previous code in the `onResume` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and notice that the dividers are gone; go to the settings screen,
    switch on the dividers, and return to the main screen (with the back button) –
    and behold: there are now separators. This next figure shows the list with and
    without separators side by side to illustrate that the code we have added works
    and the settings persist between the two Activity classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – List with and without separators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.5_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 – List with and without separators
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to try quitting the app and restarting to verify that the setting is
    saved to disk. You can even turn the emulator off and back on again and the setting
    will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a neat settings screen and we can permanently save the user's choice
    of decorative preference. Of course, the big missing link regarding persistence
    is that the user's fundamental data, their notes, still does not persist.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about what we need to do. We want to save a bunch of notes to the
    internal storage. Being more specific, we want to store a selection of strings
    and related Boolean values. These strings and Boolean values represent the user's
    note title, the note's text, and whether it is a to-do, important, or an idea.
  prefs: []
  type: TYPE_NORMAL
- en: Given what we already know about the `SharedPreferences` class, at first glance
    this might not seem especially challenging – until we dig a little deeper into
    our requirements. What if the user loves our app and ends up with 100 notes? We
    would need 100 identifiers for key-value pairs. Not impossible, but starting to
    get awkward.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider that we want to enhance the app and give the user the ability to
    add dates to them. Android has a `Date` class that is perfect for this. It would
    be reasonably straightforward to then add neat features such as reminders to our
    app. But when it comes to saving data, suddenly, things start to get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: How would we store a date using `SharedPreferences`? It wasn't designed for
    this. We could convert it to a string when we save it and convert it back again
    when we load it, but this is far from simple.
  prefs: []
  type: TYPE_NORMAL
- en: And as our app grows in features and our users get more and more notes, the
    whole persistence thing becomes a nightmare. What we need is a way to save and
    load objects, actual Java objects. If we can simply save and load objects, including
    their internal data (strings, Booleans, dates, or anything else), our apps can
    have any kind of data we can think of to suit our users.
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting data objects into bits and bytes to store on a disk
    is called **serialization**; the reverse process is called **de-serialization**.
    Serialization on its own is a vast topic and far from straightforward. Fortunately,
    as we are coming to expect, there is a class to handle most of the complexity
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: What is JSON?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation** and it is widely used in
    fields beyond Android and the Java language. It is perhaps most frequently used
    to send data between web applications and servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are JSON classes available for Android that almost entirely
    hide the complexity of the serialization process. By learning about a few more
    Java concepts, we can quickly begin to use these classes and start writing entire
    Java objects to the device storage rather than worrying ourselves about what primitive
    types make up the objects.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON classes when compared with other classes we have seen so far undertake
    operations that have a higher-than-normal probability of failure that is beyond
    their control. To find out why this is so and what can be done about it, let's
    look at Java exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Java exceptions – try, catch, and finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this talk of JSON requires us to learn a new Java concept: **exceptions**.
    When we write a class that performs operations that have a possibility of failure,
    especially for reasons beyond our control, it is advisable to make this plain
    in our code so that anyone using our class is prepared for the possibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading data is one such scenario where failure is possible beyond
    our control. Think about trying to load data when the SD card has been removed
    or has been corrupted. Another instance where code might fail is perhaps when
    we write code that relies on a network connection – what if the user goes offline
    partway through a data transfer?
  prefs: []
  type: TYPE_NORMAL
- en: Java exceptions are the solution and JSON classes use them, so it is a good
    time to learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: When we write a class that uses code with a chance of failure, we can prepare
    the users of our class by using exceptions with `try`, `catch`, and `finally`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write methods in our classes using the `throws` Java keyword at the
    end of the signature – a bit like this perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now any code that uses the `somePrecariousMethod` method will need to `try`
    and `catch` blocks – perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, we can also add a `finally` block if we want to take any further
    action after the `try` and `catch` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In our Note to Self app, we will take the minimum amount of action to handle
    exceptions and simply output an error to logcat, but you could do things such
    as notify the user, retry the operation, or put into action some clever back-up
    plan.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up user data in Note to Self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, with our newfound insight into exceptions, let's modify our Note to Self
    code, and then we can be introduced to the `JSONObject` and `JSONException` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make some minor modifications to our `Note` class. Add some more
    members that will act as the key in a key-value pair for each aspect of our `Note`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a constructor and an empty default constructor that receives `JSONObject`
    and throws `JSONException`. The body of the constructor initializes each of the
    members that defines the properties of a single `Note` object by calling the `getString`
    or `getBoolean` method of `JSONObject`, passing in the key as an argument. We
    also provide an empty default constructor, which is required now that we are providing
    our specialized constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to import the `JSONException` and `JSONObject` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The next code we will see will load the member variables of a given `Note` object
    into `JSONObject`. This is where the `Note` object's members are packed up as
    a single `JSONObject` ready for when the actual serialization takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is call the `put` method with the appropriate key and the
    matching member variable. This method returns `JSONObject` (we will see where
    in a minute) and it also throws a `JSONObject` exception. Add the code we have
    just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now let's make a `JSONSerializer` class that will perform the actual serialization
    and deserialization. Create a new class and call it `JSONSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's split it up into a few chunks and talk about what we are doing as we code
    each chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the declaration and a couple of member variables: a string to hold the
    filename where the data will be saved and a `Context` object that is necessary
    in Android to write data to a file. Add the highlighted code inside the class
    you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to import the `Context` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.content.Context;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code shows that the closing curly brace of the class and all the
    code that follows for this class should be entered inside of it. Here is the very
    straightforward constructor where we initialize the two member variables that
    are passed in as parameters. Add the constructor for `JSONSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start coding the real guts of the class. The `save` method is next.
    It first creates a `JSONArray` object, which is a specialized `ArrayList` class
    for handling JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code uses an enhanced `for` loop to go through all the `Note` objects
    in the `notes` array list and convert them to JSON objects using the `convertToJSON`
    method from the `Note` class, which we added previously. Then, we load these converted
    `JSONObject` instances into `jArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code uses a `Writer` instance and an `OutputStream` instance combined
    to write the data to an actual file. Notice the `OutputStream` instance needed
    the `mContext` object to be initialized. Add the code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add the following `import` statements for these new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now for the de-serialization – loading the data. This time, as we might expect,
    the method receives no parameters but instead returns an `ArrayList` instance.
    An `InputStream` instance is created using `mContext.openFileInput` and our file
    containing all our data is opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a `while` loop to append all the data to a string and use our new `Note`
    constructor, which extracts JSON data to regular primitive variables to unpack
    each `JSONObject` into a `Note` object and add it to the `ArrayList` that is returned
    to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add these imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we need to do is put our new class to work in the `MainActivity` class.
    Add a new member after the `MainActivity` declaration as highlighted next. Also,
    remove the initialization of `noteList` to leave just the declaration as we will
    now initialize it with some new code in the `onCreate` method. I have commented
    out the line you need to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `onCreate` method, we initialize `mSerializer` by calling the `JSONSerializer`
    constructor with the filename and `getApplicationContext()`, which returns the
    `Context` instance of the application and is required. We can then use the `JSONSerializer
    load` method to load any saved data. Add this new, highlighted code after the
    code that handles the floating action button. This new code must come before we
    handle the `RecyclerView` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to import the `Log` class at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.util.Log;`'
  prefs: []
  type: TYPE_NORMAL
- en: I have shown a great deal of context in the previous code because its positioning
    is essential for it to work. If you are having any problems getting this to run,
    be sure to compare it to the code in the download bundle in the [*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/java`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add a new method to our `MainActivity` class so that that we can
    call it to save all our user''s data. All this new method does is call the `save`
    method of the `JSONSerializer` class, passing in the required list of `Note` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just as we did when saving our user''s settings, we will override the
    `onPause` method to save our user''s note data. Be sure to add this code in the
    `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We can now run the app and add as many notes as we like. `ArrayList`
    will store them all in our running app, our `RecyclerAdapter` will manage displaying
    them in `RecyclerView`, and now JSON will take care of loading them to disk and
    loading them back as well.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I didn't understand everything in this chapter – am I not cut out to be a programmer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter introduced many new classes, concepts, and methods. If your head
    is aching a little, that is to be expected. If some of the detail is unclear,
    don't let that hold you back. Proceed with the next couple of chapters (they are
    much more straightforward), then revisit this one and examine the completed code
    files.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does serialization work in detail?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Serialization really is a vast topic. It is possible to write apps your whole
    life and never really need to understand it. It is the type of topic that might
    be the subject of a computer science degree. If you are curious to know more,
    have a look at this article: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in our journey through the Android API, it is worth taking stock
    of what we know. We can lay out our own UI designs and choose from a wide and
    diverse range of widgets to allow the user to interact with the UI. We can create
    multiple screens as well as pop-up dialogs and we can capture comprehensive user
    data. Furthermore, we can now make this data persist.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, there is a lot more to the Android API still to learn, even beyond
    what this book will teach you, but the point is that we know enough now to plan
    and implement a working app. You could just get started on your own app right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the urge to start your own project right away, then my advice is
    to go ahead and do it. Don't wait until you consider yourself an "expert" or more
    ready. Reading this book and, more importantly, implementing the apps will make
    you a better Android programmer, but nothing will teach you faster than designing
    and implementing your own app! It is perfectly possible to read through this book
    and work on your own project(s) simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add the finishing touches to this app by making
    it multilingual. This is quite quick and easy.
  prefs: []
  type: TYPE_NORMAL
