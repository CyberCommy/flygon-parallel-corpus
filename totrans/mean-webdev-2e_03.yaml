- en: Chapter 3. Building an Express Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the proper way to build your first Express application.
    You''ll begin by installing and configuring the Express module and then learning
    about Express'' main APIs. We''ll discuss Express request, response, and application
    objects and learn how to use them. We''ll then cover the Express routing mechanism
    and learn how to properly use it. We''ll also discuss the structure of the application
    folder and how you can utilize different structures for different project types.
    By the end of this chapter, you''ll learn how to build a complete Express application.
    In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express and creating a new Express application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing your project's structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your Express application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Express routing mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering EJS views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an Express session
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Express
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To say that TJ Holowaychuk is a productive developer would be a huge understatement.
    TJ's involvement in the Node.js community is almost unmatched by any other developer,
    and with more than 500 open source projects, he's responsible for some of the
    most popular frameworks in the JavaScript ecosystem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: One of his greatest projects is the Express web framework. The Express framework
    is a small set of common web application features kept to a minimum in order to
    maintain the Node.js style. It is built on top of Connect and makes use of its
    middleware architecture. Its features extend Connect to allow a variety of common
    web application use cases, such as the inclusion of modular HTML template engines,
    extending the response object to support various data format outputs, a routing
    system, and much more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used a single `server.js` file to create our application. However,
    when using Express, you'll learn more about better project structure, properly
    configuring your application, and breaking your application logic into different
    modules. You'll also learn how to use the EJS template engine, manage sessions,
    and add a routing scheme. By the end of this section, you'll have a working application
    skeleton that you'll use for the rest of the book. Let's begin the journey of
    creating your first Express application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we used npm to directly install external modules for our Node
    application. You could, of course, use this approach and install Express by typing
    the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, directly installing modules isn''t really scalable. Think about it
    for a bit: you''re going to use many Node modules in your application, transfer
    it between working environments, and probably share it with other developers.
    So, installing the project modules this way will soon become a dreadful task.
    Instead, you should start using the `package.json` file, which organizes your
    project metadata and helps you manage your application dependencies. Begin by
    creating a new working folder and a new `package.json` file inside it, which contains
    the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `package.json` file, note that you included three properties: the name
    and version of your application and the dependencies property, which defines what
    modules should be installed before your application can run. To install your application
    dependencies, use your command-line tool and navigate to your application folder,
    and then issue the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: npm will then install the Express module because, currently, it is the only
    dependency defined in your `package.json` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Express application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating your `package.json` file and installing your dependencies, you
    can create your first Express application by adding your already familiar `server.js`
    file with the following lines of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should have already recognized most of the code. The first two lines require
    the Express module and create a new Express application object. Then, we use the
    `app.use()` method to mount a middleware function with a specific path and the
    `app.listen()` method to tell the Express application to listen to port `3000`.
    Note how the `module.exports` object is used to return the `app` object. This
    will later help you load and test your Express application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: This new code should also be familiar to you because it resembles the code you
    used in the previous Connect example. This is because Express wraps the Connect
    module in several ways. The `app.use()` method is used to mount a middleware function,
    which will respond to any HTTP request made to the root path. Inside the middleware
    function, the `res.status()` method is then used to set the HTTP response code,
    and the `res.send()` method is used to send the response back. The `res.send()`
    method is basically an Express wrapper that sets the Content-Type header according
    to the response object type and then sends a response back using the Connect `res.end()`
    method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When passing a buffer to the `res.send()` method, the Content-Type header will
    be set to `application/octet-stream`; when passing a string, it will be set to
    `text/html`; and when passing an object or an array, it will be set to `application/json`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your application, simply execute the following command in your command-line
    tool:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You have just created your first Express application. You can
    test it by visiting `http://localhost:3000` in your browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The application, request, and response objects
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express presents three major objects that you'll frequently use. The application
    object is the instance of an Express application you created in the first example
    and is usually used to configure your application. The request object is a wrapper
    of Node's HTTP request object and is used to extract information about the currently
    handled HTTP request. The response object is a wrapper of Node's HTTP response
    object and is used to set the response data and headers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The application object
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application object contains the following methods to help you configure
    your application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`app.set(name, value)`: This is a method used to set environment variables
    that Express will use in its configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.get(name)`: This is a method used to get environment variables that Express
    is using in its configuration.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.engine(ext, callback)`: This is a method used to define a given template
    engine to render certain file types; for example, you can tell the EJS template
    engine to use HTML files as templates like this: `app.engine(''html'', require(''ejs'').renderFile)`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.locals`: This is a property used to send application-level variables to
    all rendered templates.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.use([path], callback)`: This is a method used to create an Express middleware
    to handle HTTP requests sent to the server. Optionally, you''ll be able to mount
    middleware to respond to certain paths.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.VERB(path, [callback...], callback)`: This is used to define one or more
    middleware functions to respond to HTTP requests made to a certain path in conjunction
    with the HTTP verb declared. For instance, when you want to respond to requests
    that are using the GET verb, you can just assign the middleware using the `app.get()`
    method. For POST requests, you''ll use `app.post()`, and so on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.route(path).VERB([callback...], callback)`: This is a method used to define
    one or more middleware functions to respond to HTTP requests made to a certain
    unified path in conjunction with multiple HTTP verbs. For instance, when you want
    to respond to requests that are using the GET and POST verbs, you can just assign
    the appropriate middleware functions using `app.route(path).get(callback).post(callback)`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.param([name], callback)`: This is a method used to attach a certain functionality
    to any request made to a path that includes a certain routing parameter. For instance,
    you can map logic to any request that includes the `userId` parameter using `app.param(''userId'',
    callback)`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more application methods and properties you can use, but using
    these common basic methods enables developers to extend Express in whichever way
    they find reasonable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The request object
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The request object also provides a handful of helping methods that contain
    the information you need about the current HTTP request. The key properties and
    methods of the request object are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`req.query`: This is a property that contains the parsed query-string parameters.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.params`: This is a property that contains the parsed routing parameters.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.body`: This is a property that''s used to retrieve the parsed request
    body. It is included in the `bodyParser()` middleware.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.path` / `req.hostname` / `req.ip`: These are used to retrieve the current
    request path, hostname, and remote IP.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.cookies`: This is a property used in conjunction with the `cookieParser()`
    middleware to retrieve the cookies sent by the user agent.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request object contains many more methods and properties that we'll discuss
    later in this book, but these methods are what you'll usually use in a common
    web application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The response object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The response object is frequently used when developing an Express application
    because any request sent to the server will be handled and responded to using
    the response object methods. It has several key methods, which are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(code)`: This is a method used to set the response HTTP status code.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.set(field, [value])`: This is a method used to set the response HTTP header.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.cookie(name, value, [options])`: This is a method used to set a response
    cookie. The options argument is used to pass an object that defines common cookie
    configuration, such as the `maxAge` property.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.redirect([status], url)`: This is a method used to redirect the request
    to a given URL. Note that you can add an HTTP status code to the response. When
    not passing a status code, it will be defaulted to `302 Found`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status([status]).send( [body])`: This is a method used for non-streaming
    responses. It does a lot of background work, such as setting the Content-Type
    and Content-Length headers and responding with the proper cache headers.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status([status]).json( [body])`: This is identical to the `res.send()`
    method when sending an object or array. Most of the time, it is used as syntactic
    sugar, but sometimes you may need to use it to force a JSON response to non-objects,
    such as `null` or `undefined`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.render(view, [locals], callback)`: This is a method used to render a view
    and send an HTML response.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response object also contains many more methods and properties to handle
    different response scenarios, which you'll learn about later in this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: External middleware
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Express core is minimal, yet the team behind it provides various predefined
    middleware to handle common web development features. These types of middleware
    vary in size and functionality and extend Express to provide a better framework
    support. The popular Express middleware are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`morgan`: This is an HTTP request logger middleware.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body-parser`: This is a body-parsing middleware that is used to parse the
    request body, and it supports various request types.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method-override`: This is a middleware that provides HTTP verb support, such
    as PUT or DELETE, in places where the client doesn''t support it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compression`: This is a compression middleware that is used to compress the
    response data using GZIP/deflate.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express.static`: This is a middleware used to serve static files.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookie-parser`: This is a cookie-parsing middleware that populates the `req.cookies`
    object.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Session`: This is a session middleware used to support persistent sessions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more types of Express middleware that enable you to shorten your
    development time along with a larger number of third-party middleware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the Connect and Express middleware, visit the Connect module's
    official repository page at [https://github.com/senchalabs/connect#middleware](https://github.com/senchalabs/connect#middleware).
    If you'd like to browse the third-party middleware collection, visit Connect's
    wiki page at [https://github.com/senchalabs/connect/wiki](https://github.com/senchalabs/connect/wiki).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MVC pattern
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Express framework is pattern-agnostic, which means that it doesn't support
    any predefined syntax or structure, as some other web frameworks do. Applying
    the MVC pattern to your Express application means that you can create specific
    folders where you place your JavaScript files in a certain logical order. All
    these files are basically CommonJS modules that function as logical units. For
    instance, models will be CommonJS modules that contain a definition of Mongoose
    models placed in the `models` folder, views will be HTML or other template files
    placed in the `views` folder, and controllers will be CommonJS modules with functional
    methods placed in the `controllers` folder. To illustrate this better, it's time
    to discuss the different types of application structure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The application folder structure
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously discussed better practices when developing a real application,
    where we recommended the use of the `package.json` file over directly installing
    your modules. However, this was only the beginning; once you continue developing
    your application, you''ll soon find yourself wondering how you should arrange
    your project files and break them into logical units of code. JavaScript, in general,
    and—consequently—the Express framework are agnostic about the structure of your
    application as you can easily place your entire application in a single JavaScript
    file. This is because no one expected JavaScript to be a full-stack programming
    language, but it doesn''t mean that you shouldn''t dedicate special attention
    to organizing your project. Since the MEAN stack can be used to build all sorts
    of applications that vary in size and complexity, it is also possible to handle
    the project structure in various ways. The decision is often directly related
    to the estimated complexity of your application. For instance, simple projects
    may require a leaner folder structure, which has the advantage of being clearer
    and easier to manage, while complex projects will often require a more complex
    structure and a better breakdown of logic since it will include many features
    and a bigger team working on the project. To simplify this discussion, it would
    be reasonable to divide it into two major approaches: a horizontal structure for
    smaller projects and a vertical structure for feature-rich applications. Let''s
    begin with a simple horizontal structure.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal folder structure
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A horizontal project structure is based on the division of folders and files
    by their functional role rather than by the feature they implement, which means
    that all the application files are placed inside a main application folder that
    contains an MVC folder structure. This also means that there is a single `controllers`
    folder that contains all of the application controllers, a single `models` folder
    that contains all of the application models, and so on. An example of the horizontal
    application structure would be as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal folder structure](img/B05071_03_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the folder structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app` folder is where you keep your Express application logic, and it is
    divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controllers` folder is where you keep your Express application controllers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `models` folder is where you keep your Express application models
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` folder is where you keep your Express application routing middleware
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`文件夹是您保存Express应用程序路由中间件的地方'
- en: The `views` folder is where you keep your Express application views
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`文件夹是您保存Express应用程序视图的地方'
- en: 'The `config` folder is where you keep your Express application configuration
    files. In time, you''ll add more modules to your application, and each module
    will be configured in a dedicated JavaScript file, which is placed inside this
    folder. Currently, it contains several files and folders, which are as follows:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存Express应用程序配置文件的地方。随着时间的推移，您将向应用程序添加更多模块，每个模块将在专用的JavaScript文件中进行配置，该文件放在此文件夹中。目前，它包含几个文件和文件夹，如下所示：'
- en: The `env` folder is where you'll keep your Express application environment's
    configuration files
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`文件夹是您保存Express应用程序环境配置文件的地方'
- en: The `config.js` file is where you'll configure your Express application
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.js`文件是您配置Express应用程序的地方'
- en: The `express.js` file is where you'll initialize your Express application
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.js`文件是您初始化Express应用程序的地方'
- en: 'The `public` folder is where you keep your static client-side files, and it
    is divided into the following folders that represent a separation of functionalities
    in order to comply with the MVC pattern:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`文件夹是您保存静态客户端文件的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `config` folder is where you keep your Angular application configuration
    files
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存Angular应用程序配置文件的地方'
- en: The `components` folder is where you keep your Angular application components
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`文件夹是您保存Angular应用程序组件的地方'
- en: The `css` folder is where you keep your CSS files
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`文件夹是您保存CSS文件的地方'
- en: The `directives` folder is where you keep your Angular application directives
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directives`文件夹是您保存Angular应用程序指令的地方'
- en: The `pipes` folder is where you keep your Angular application pipes
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipes`文件夹是您保存Angular应用程序管道的地方'
- en: The `img` folder is where you keep your image files
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img`文件夹是您保存图像文件的地方'
- en: The `templates` folder is where you keep your Angular application templates
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`文件夹是您保存Angular应用程序模板的地方'
- en: The `bootstrap.ts` file is where you initialize your Angular application
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.ts`文件是您初始化Angular应用程序的地方'
- en: The `package.json` file is the metadata file that helps you organize your application
    dependencies.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`文件是帮助您组织应用程序依赖关系的元数据文件。'
- en: The `server.js` file is the main file of your Node.js application, and it will
    load the `express.js` file as a module in order to bootstrap your Express application.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.js`文件是您的Node.js应用程序的主文件，它将加载`express.js`文件作为模块，以启动您的Express应用程序。'
- en: As you can see, the horizontal folder structure is very useful for small projects
    where the number of features is limited so that files can be conveniently placed
    inside folders that represent their general roles. Nevertheless, in order to handle
    large projects, where you'll have many files that handle certain features, it
    might be too simplistic. In this case, each folder could be overloaded with too
    many files, and you'd get lost in the chaos. A better approach would be to use
    a vertical folder structure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，水平文件夹结构对于功能有限的小型项目非常有用，因此文件可以方便地放在代表其一般角色的文件夹中。然而，为了处理大型项目，在那里您将有许多处理特定功能的文件，这可能太简单了。在这种情况下，每个文件夹可能会被过多的文件所超载，您可能会在混乱中迷失。更好的方法是使用垂直文件夹结构。
- en: Vertical folder structure
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直文件夹结构
- en: 'A vertical project structure is based on the division of folders and files
    by the feature they implement, which means that each feature has its own autonomous
    folder that contains an MVC folder structure. An example of the vertical application
    structure would be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直项目结构基于按功能实现的文件夹和文件的划分，这意味着每个功能都有自己独立的文件夹，其中包含一个MVC文件夹结构。垂直应用程序结构的示例如下：
- en: '![Vertical folder structure](img/B05071_03_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![垂直文件夹结构](img/B05071_03_02.jpg)'
- en: 'As you can see, each feature has its own application-like folder structure.
    In this example, we have the `core feature` folder that contains the main application
    files and the `feature` folder that includes the feature''s files. An example
    feature will be a user management feature that includes authentication and authorization
    logic. To understand this better, let''s review a single feature''s folder structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个功能都有自己类似应用程序的文件夹结构。在这个例子中，我们有包含主应用程序文件的`core feature`文件夹和包含功能文件的`feature`文件夹。一个示例功能将是包含身份验证和授权逻辑的用户管理功能。为了更好地理解这一点，让我们来看一个单个功能的文件夹结构：
- en: 'The `server` folder is where you keep your feature''s server logic, and it
    is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`文件夹是您保存功能的服务器逻辑的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `controllers` folder is where you keep your feature's Express controllers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`文件夹是您保存功能的Express控制器的地方'
- en: The `models` folder is where you keep your feature's Express models
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`文件夹是您保存功能的Express模型的地方'
- en: The `routes` folder is where you keep your feature's Express routing middleware
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`文件夹是您保存功能的Express路由中间件的地方'
- en: The `views` folder is where you keep your feature's Express views
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`文件夹是您保存功能的Express视图的地方'
- en: The `config` folder is where you keep your feature's server configuration files
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存功能服务器配置文件的地方'
- en: The `env` folder is where you keep your feature's environment server configuration
    files
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`文件夹是您保存功能环境服务器配置文件的地方'
- en: The `feature.server.config.js` file is where you configure your features
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature.server.config.js`文件是您配置功能的地方'
- en: 'The `client` folder is where you keep your feature''s client-side files, and
    it is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client`文件夹是您保存功能的客户端文件的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `config` folder is where you keep your feature's Angular configuration files
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `components` folder is where you keep your feature's Angular `components`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `css` folder is where you keep your feature's CSS files
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `directives` folder is where you keep your feature's Angular directives
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pipes` folder is where you keep your feature's Angular pipes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `img` folder is where you keep your feature's image files
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templates` folder is where you keep your feature's Angular templates
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `feature.module.ts` file is where you initialize your feature's Angular
    module
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the vertical folder structure is very useful for large projects
    where the number of features is unlimited and each feature includes a substantial
    number of files. It will allow large teams to work together and maintain each
    feature separately, and it can also be useful in sharing features among different
    applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Although these are two distinctive types of most application structures, the
    reality is that the MEAN stack can be assembled in many different ways. It's even
    likely for a team to structure their project in a way that combines these two
    approaches; so essentially, it is up to the project leader to decide which structure
    to use. In this book, we'll use the horizontal approach for reasons of simplicity,
    but we'll incorporate the Angular part of our application in a vertical manner
    to demonstrate the flexibility of the MEAN stack's structure. Keep in mind that
    everything presented in this book can be easily restructured to accommodate your
    project's specifications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: File-naming conventions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While developing your application, you''ll soon notice that you end up with
    many files with the same name. The reason is that MEAN applications often have
    a parallel MVC structure for both the Express and Angular components. To understand
    this issue, take a look at a common vertical feature''s folder structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![File-naming conventions](img/B05071_03_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: As you can see, enforcing the folder structure helps you understand each file's
    functionality, but it will also cause several files to have the same name. This
    is because an application's feature is usually implemented using several JavaScript
    files, each having a different role. This issue can cause some confusion for the
    development team, so to solve this, you'll need to use some sort of a naming convention.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The simplest solution would be to add each file's functional role to the filename.
    So, a feature controller file will be named `feature.controller.js`, a feature
    model file will be named `feature.model.js`, and so on. However, things get even
    more complicated when you consider the fact that MEAN applications use JavaScript
    MVC files for both Express and Angular applications. This means that you'll often
    have two files with the same name. To solve this issue, it is also recommended
    that you extend file names with their execution destination. This might seem like
    overkill at first, but you'll soon discover that it's quite helpful to quickly
    identify the role and execution destination of your application files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to remember that this is a best practice convention. You can
    easily replace the `controller`, `model`, `client`, and `server` keywords with
    your own keywords.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the horizontal folder structure
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin the structuring of your first MEAN project, create a new project folder
    with the following folders inside it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the horizontal folder structure](img/B05071_03_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Once you have created all the preceding folders, go back to the application''s
    root folder and create a `package.json` file that contains the following code
    snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in the `app/controllers` folder, create a file named `index.server.controller.js`
    with the following lines of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations! You just created your first Express controller. This code probably
    looks very familiar; that's because it's a copy of the middleware you created
    in the previous examples. What you do here is use the CommonJS module pattern
    to define a function named `render()`. Later on, you'll be able to acquire this
    module and use this function. Once you've created a controller, you'll need to
    use an Express-routing functionality to utilize the controller.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你的第一个Express控制器。这段代码可能看起来很熟悉；那是因为它是你在之前示例中创建的中间件的副本。你在这里所做的是使用CommonJS模块模式来定义一个名为`render()`的函数。稍后，你将能够获取这个模块并使用这个函数。一旦你创建了一个控制器，你就需要使用Express路由功能来利用这个控制器。
- en: Handling request routing
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理请求路由
- en: 'Express supports the routing of requests using either the `app.route(path).VERB(callback)`
    method or the `app.VERB(path, callback)` method, where `VERB` should be replaced
    with a lowercase HTTP verb. Take a look at the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Express支持使用`app.route(path).VERB(callback)`方法或`app.VERB(path, callback)`方法来路由请求，其中`VERB`应该替换为小写的HTTP动词。看一下以下例子：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This tells Express to execute the middleware function for any HTTP request
    using the `GET` verb and directed to the root path. If you''d like to deal with
    `POST` requests, your code should be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Express执行中间件函数来处理任何使用`GET`动词并指向根路径的HTTP请求。如果你想处理`POST`请求，你的代码应该如下所示：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, Express also enables you to define a single route and then chain several
    middleware to handle different HTTP requests. This means that the preceding code
    example can also be written as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Express还允许你定义单个路由，然后链接多个中间件来处理不同的HTTP请求。这意味着前面的代码示例也可以写成如下形式：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another cool feature of Express is its ability to chain several middleware
    in a single routing definition. This means that middleware functions will be called
    in an order, passing them to the next middleware so that you can determine how
    to proceed with middleware execution. This is usually used to validate requests
    before executing the response logic. To understand this better, take a look at
    the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Express的另一个很酷的功能是能够在单个路由定义中链接多个中间件。这意味着中间件函数将按顺序调用，将它们传递给下一个中间件，以便你可以确定如何继续执行中间件。这通常用于在执行响应逻辑之前验证请求。要更好地理解这一点，看一下以下代码：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, there are two middleware functions named `hasName()`
    and `sayHello()`. The `hasName()` middleware is looking for the `name` parameter;
    if it finds a defined `name` parameter, it will call the next middleware function
    using the next argument. Otherwise, the `hasName()` middleware will handle the
    response by itself. In this case, the next middleware function would be the `sayHello()`
    middleware function. This is possible because we've added the middleware function
    in a row using the `app.get()` method. It is also worth noting the order of the
    middleware functions because it determines which middleware function is executed
    first.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有两个名为`hasName()`和`sayHello()`的中间件函数。`hasName()`中间件正在寻找`name`参数；如果找到了定义的`name`参数，它将使用next参数调用下一个中间件函数。否则，`hasName()`中间件将自己处理响应。在这种情况下，下一个中间件函数将是`sayHello()`中间件函数。这是可能的，因为我们使用`app.get()`方法将中间件函数按顺序添加。还值得注意的是中间件函数的顺序，因为它决定了哪个中间件函数首先执行。
- en: This example demonstrates well how routing middleware can be used to perform
    different validations when determining what the response should be. You can, of
    course, leverage this functionality to perform other tasks, such as validating
    user authentication and resources' authorization. For now, though, let's just
    continue with our example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地演示了路由中间件如何在确定响应时执行不同的验证。当然，你可以利用这个功能来执行其他任务，比如验证用户身份验证和资源授权。不过，现在让我们继续我们的例子。
- en: Adding the routing file
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加路由文件
- en: 'The next file you''re going to create is your first routing file. In the `app/routes`
    folder, create a file named `index.server.routes.js` with the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要创建的文件是你的第一个路由文件。在`app/routes`文件夹中，创建一个名为`index.server.routes.js`的文件，其中包含以下代码片段：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you did a few things. First, you used the CommonJS module pattern again.
    As you may remember, the CommonJS module pattern supports both the exporting of
    several functions, such as what you did with your controller, and the use of a
    single module function, such as what you did here. Next, you required your `index`
    controller and used its `render()` method as a middleware to GET requests made
    to the root path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你做了一些事情。首先，你再次使用了CommonJS模块模式。你可能还记得，CommonJS模块模式支持导出多个函数，比如你在控制器中所做的，以及使用单个模块函数，就像你在这里所做的那样。接下来，你需要引入你的`index`控制器，并将其`render()`方法用作中间件来处理根路径的GET请求。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The routing module function accepts a single argument called `app`, so when
    you call this function, you'll need to pass it the instance of the Express application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块函数接受一个名为`app`的参数，所以当你调用这个函数时，你需要传递Express应用程序的实例。
- en: 'All that you have left to do is to create the Express application object and
    bootstrap it using the controller and routing modules you just created. To do
    this, go to the `config` folder and create a file named `express.js` with the
    following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你所剩下的就是创建Express应用程序对象，并使用你刚刚创建的控制器和路由模块进行引导。为此，转到`config`文件夹，并创建一个名为`express.js`的文件，其中包含以下代码片段：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, you required the Express module and then used
    the CommonJS module pattern to define a `module` function that initializes the
    Express application. First, it creates a new instance of an Express application,
    and then it requires your routing file and calls it as a function, passing it
    the application instance as an argument. The routing file will use the application
    instance to create a new routing configuration, and then it will call the controller's
    `render()` method. The `module` function ends by returning the application instance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `express.js` file is where we configure our Express application. This is
    where we add everything related to the Express configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize your application, you''ll need to create a file named `server.js`
    in the root folder and copy the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is it! In the main application file, you connected all the loose ends by
    requiring the Express configuration module and then using it to retrieve your
    application object instance and listening to port `3000`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To start your application, navigate to your application''s root folder using
    your command-line tool and install your application dependencies using `npm`,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Your Express application should run now! To test it, navigate to `http://localhost:3000`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you learned how to properly build your Express application.
    It is important that you note the different ways in which you used the CommonJS
    module pattern to create your files and require them across the application. This
    pattern will often repeat itself in this book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an Express application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express comes with a pretty simple configuration system that enables you to
    add certain functionalities to your Express application. Although there are predefined
    configuration options that you can change to manipulate the way it works, you
    can also add your own key/value configuration options for any other usage. Another
    robust feature of Express is its ability to configure your application based on
    the environment it's running on. For instance, you may want to use the Express
    logger in your development environment and not in production, while compressing
    your responses body might seem like a good idea when running in a production environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, you will need to use the `process.env` property. `process.env`
    is a global variable that allows you to access predefined environment variables,
    and the most common one is the `NODE_ENV` environment variable. The `NODE_ENV`
    environment variable is often used for environment-specific configurations. To
    understand this better, let's go back to the previous example and add some external
    middleware. To use this middleware, you will first need to download and install
    them as your project dependencies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, edit your `package.json` file to look like the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we stated previously, the `morgan` module provides a simple logger middleware,
    the `compression` module provides response compression, the `body-parser` module
    provides several middleware to handle the request data, and the `method-override`
    module provides `DELETE` and `PUT` HTTP verbs'' legacy support. To use these modules,
    you will need to modify your `config/express.js` file to look like the following
    code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we just used the `process.env.NODE_ENV` variable to determine
    our environment and configure the Express application accordingly. We simply used
    the `app.use()` method to load the `morgan()` middleware in a development environment
    and the `compress()` middleware in a production environment. The `bodyParser.urlencoded()`,
    `bodyParser.json()`, and `methodOverride()` middleware will always load regardless
    of the environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize your configuration, you''ll need to change your `server.js` file
    to look like the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the `process.env.NODE_ENV` variable is set to the default `development`
    value if it doesn't exist. This is because often, the `NODE_ENV` environment variable
    is not properly set.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you set the NODE_ENV environment variable in your operating
    system prior to running your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Windows environment, this can be done by executing the following command
    in your command prompt:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While in a Unix-based environment, you should simply use the following export
    command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To test your changes, navigate to your application''s root folder using your
    command-line tool and install your application dependencies using `npm`, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Your Express application should now run! To test it, navigate to `http://localhost:3000`,
    and you'll be able to see the logger in action in your command-line output. However,
    the `process.env.NODE_ENV` environment variable can be used in an even more sophisticated
    manner when dealing with more complex configuration options.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Environment configuration files
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During your application development, you will often need to configure third-party
    modules to run differently in various environments. For instance, when you connect
    to your MongoDB server, you''ll probably use different connection strings in your
    development and production environments. Doing this in the current setting will
    probably cause your code to be filled with endless `if` statements, which will
    generally be harder to maintain. To solve this issue, you can manage a set of
    environment configuration files that hold these properties. You will then be able
    to use the `process.env.NODE_ENV` environment variable to determine which configuration
    file to load, thus keeping your code shorter and easier to maintain. Let''s begin
    by creating a configuration file for our default development environment. To do
    this, create a new file inside your `config/env` folder and call it `development.js`.
    Inside your new file, paste the following lines of code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, your configuration file is currently just an empty CommonJS
    module initialization. Don''t worry about it; we''ll soon add the first configuration
    option, but first, we''ll need to manage the configuration files'' loading. To
    do this, go to your application''s `config` folder and create a new file named
    `config.js`. Inside your new file, paste the following lines of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this file simply loads the correct configuration file according
    to the `process.env.NODE_ENV` environment variable. In the upcoming chapters,
    we'll use this file, which will load the correct environment configuration file
    for us. To manage other environment configurations, you'll just need to add a
    dedicated environment configuration file and properly set the `NODE_ENV` environment
    variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Rendering views
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common feature of web frameworks is the ability to render views. The
    basic concept is passing your data to a template engine that will render the final
    view, usually in HTML. In the MVC pattern, your controller uses the model to retrieve
    the data portion and the view template to render the HTML output, as described
    in the next diagram. The Express extendable approach allows the usage of many
    Node.js template engines to achieve this functionality. In this section, we''ll
    use the EJS template engine, but you can later replace it with other template
    engines. The following diagram shows the MVC pattern in rendering application
    views:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering views](img/B05071_03_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Express has two methods to render views: `app.render()`, which is used to render
    the view and then pass the HTML to a callback function, and the more common `res.render()`,
    which renders the view locally and sends the HTML as a response. You''ll use `res.render()`
    more frequently because you usually want to output the HTML as a response. However,
    if, for instance, you''d like your application to send HTML e-mails, you will
    probably use `app.render()`. Before we begin exploring the `res.render()` method,
    let''s first configure our view system.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the view system
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to configure the Express view system, you will need to use the EJS
    template engine. Let''s get back to our example and install the EJS module. You
    should begin by changing your `package.json` file to look like the following code
    snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, install the EJS module by navigating in the command line to your project''s
    root folder and issuing the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After npm finishes the installation of the EJS module, you''ll be able to configure
    Express to use it as the default template engine. To configure your Express application,
    go back to the `config/express.js` file and change it to look like the following
    lines of code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note how we use the `app.set()` method to configure the Express application
    `view` folder and template engine. Let's create your first view.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Rendering EJS views
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EJS views basically consist of HTML code mixed with `EJS` tags. EJS templates
    will reside in the `app/views` folder and will have the `.ejs` extension. When
    you use the `res.render()` method, the EJS engine will look for the template in
    the `views` folder, and if it finds a complying template, it will render the HTML
    output. To create your first EJS view, go to your `app/views` folder and create
    a new file named `index.ejs`, which contains the following HTML code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code should be mostly familiar to you, except for the `<%= %>` tag. These
    tags are the way to tell the EJS template engine where to render the template
    variables—in this case, the `title` variable. All you have left to do is configure
    your controller to render this template and automatically output it as an HTML
    response. To do this, go back to your `app/controllers/index.server.controller.js`
    file and change it to look like the following code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note the way the `res.render()` method is used. The first argument is the name
    of your EJS template without the `.ejs` extension, and the second argument is
    an object containing your template variables. The `res.render()` method will use
    the EJS template engine to look for the file in the `views` folder that we set
    in the `config/express.js` file and will then render the view using the template
    variables. To test your changes, use your command-line tool and issue the following
    command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Well done; you have just created your first EJS view! Test your application
    by visiting `http://localhost:3000`, where you'll be able to view the rendered
    HTML.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: EJS views are simple to maintain, and they provide an easy way to create your
    application views. We'll elaborate a bit more on EJS templates later in this book,
    not as much as you would expect, however, because in MEAN applications, most of
    the HTML rendering is done on the client side using Angular.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any web application, there is always a need to serve static files. Fortunately,
    Express'' only built-in middleware is the `express.static()` middleware, which
    provides this feature. To add static file support to the previous example, just
    make the following changes in your `config/express.js` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `express.static()` middleware takes one argument to determine the location
    of the `static` folder. Note how the `express.static()` middleware is placed below
    the call for the routing file. This order matters because if it were above it,
    Express would first try to look for HTTP request paths in the `static files` folder.
    This would make the response a lot slower as it would have to wait for a filesystem
    I/O operation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your static middleware, add an image named `logo.png` to the `public/img`
    folder and then make the following changes in your `app/views/index.ejs` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, run your application using Node''s command-line tool:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To test the result, visit `http://localhost:3000` in your browser and watch
    how Express is serving your image as a static file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Configuring sessions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sessions are a common web application pattern that allows you to keep track
    of the user''s behavior when they visit your application. To add this functionality,
    you will need to install and configure the `express-session` middleware. To do
    this, start by modifying your `package.json` file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, install the `express-session` module by navigating to your project''s
    root folder in the command line and issuing the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the installation process is finished, you''ll be able to configure your
    Express application to use the `express-session` module. The `express-session`
    module will use a cookie-stored, signed identifier to identify the current user.
    To sign the session identifier, it will use a secret string, which will help prevent
    malicious session tampering. For security reasons, it is recommended that the
    cookie secret be different for each environment, which means that this would be
    an appropriate place to use our environment configuration file. To do this, change
    the `config/env/development.js` file to look like the following code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since this is just an example, feel free to change the secret string. For other
    environments, just add the `sessionSecret` property in their environment configuration
    files. To use the configuration file and configure your Express application, go
    back to your `config/express.js` file and change it to look like the following
    code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note how the configuration object is passed to the `express.session()` middleware.
    In this configuration object, the `secret` property is defined using the configuration
    file you previously modified. The session middleware adds a session object to
    all request objects in your application. Using this session object, you can set
    or get any property that you wish to use in the current session. To test the session,
    change the `app/controller/index.server.controller.js` file as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What you did here was basically record the time of the last user request. The
    controller checks whether the `lastVisit` property was set in the `session` object,
    and if so, it outputs the last visit date to the console. It then sets the `lastVisit`
    property to the current time. To test your changes, use Node''s command-line tool
    to run your application, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, test your application by visiting `http://localhost:3000` in your browser
    and watching the command-line output.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created your first Express application and learned how
    to properly configure it. You arranged your files and folders in an organized
    structure and discovered alternative folder structures. You also created your
    first Express controller and learned how to call its methods using Express' routing
    mechanism. You rendered your first EJS view and learned how to serve static files.
    You also learned how to use `express-session` to track your user's behavior. In
    the next chapter, you'll learn how to save your application's persistent data
    using MongoDB.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
