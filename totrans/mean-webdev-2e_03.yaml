- en: Chapter 3. Building an Express Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the proper way to build your first Express application.
    You''ll begin by installing and configuring the Express module and then learning
    about Express'' main APIs. We''ll discuss Express request, response, and application
    objects and learn how to use them. We''ll then cover the Express routing mechanism
    and learn how to properly use it. We''ll also discuss the structure of the application
    folder and how you can utilize different structures for different project types.
    By the end of this chapter, you''ll learn how to build a complete Express application.
    In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express and creating a new Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing your project's structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Express routing mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering EJS views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an Express session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To say that TJ Holowaychuk is a productive developer would be a huge understatement.
    TJ's involvement in the Node.js community is almost unmatched by any other developer,
    and with more than 500 open source projects, he's responsible for some of the
    most popular frameworks in the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: One of his greatest projects is the Express web framework. The Express framework
    is a small set of common web application features kept to a minimum in order to
    maintain the Node.js style. It is built on top of Connect and makes use of its
    middleware architecture. Its features extend Connect to allow a variety of common
    web application use cases, such as the inclusion of modular HTML template engines,
    extending the response object to support various data format outputs, a routing
    system, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used a single `server.js` file to create our application. However,
    when using Express, you'll learn more about better project structure, properly
    configuring your application, and breaking your application logic into different
    modules. You'll also learn how to use the EJS template engine, manage sessions,
    and add a routing scheme. By the end of this section, you'll have a working application
    skeleton that you'll use for the rest of the book. Let's begin the journey of
    creating your first Express application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we used npm to directly install external modules for our Node
    application. You could, of course, use this approach and install Express by typing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, directly installing modules isn''t really scalable. Think about it
    for a bit: you''re going to use many Node modules in your application, transfer
    it between working environments, and probably share it with other developers.
    So, installing the project modules this way will soon become a dreadful task.
    Instead, you should start using the `package.json` file, which organizes your
    project metadata and helps you manage your application dependencies. Begin by
    creating a new working folder and a new `package.json` file inside it, which contains
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `package.json` file, note that you included three properties: the name
    and version of your application and the dependencies property, which defines what
    modules should be installed before your application can run. To install your application
    dependencies, use your command-line tool and navigate to your application folder,
    and then issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: npm will then install the Express module because, currently, it is the only
    dependency defined in your `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating your `package.json` file and installing your dependencies, you
    can create your first Express application by adding your already familiar `server.js`
    file with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should have already recognized most of the code. The first two lines require
    the Express module and create a new Express application object. Then, we use the
    `app.use()` method to mount a middleware function with a specific path and the
    `app.listen()` method to tell the Express application to listen to port `3000`.
    Note how the `module.exports` object is used to return the `app` object. This
    will later help you load and test your Express application.
  prefs: []
  type: TYPE_NORMAL
- en: This new code should also be familiar to you because it resembles the code you
    used in the previous Connect example. This is because Express wraps the Connect
    module in several ways. The `app.use()` method is used to mount a middleware function,
    which will respond to any HTTP request made to the root path. Inside the middleware
    function, the `res.status()` method is then used to set the HTTP response code,
    and the `res.send()` method is used to send the response back. The `res.send()`
    method is basically an Express wrapper that sets the Content-Type header according
    to the response object type and then sends a response back using the Connect `res.end()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When passing a buffer to the `res.send()` method, the Content-Type header will
    be set to `application/octet-stream`; when passing a string, it will be set to
    `text/html`; and when passing an object or an array, it will be set to `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your application, simply execute the following command in your command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have just created your first Express application. You can
    test it by visiting `http://localhost:3000` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: The application, request, and response objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express presents three major objects that you'll frequently use. The application
    object is the instance of an Express application you created in the first example
    and is usually used to configure your application. The request object is a wrapper
    of Node's HTTP request object and is used to extract information about the currently
    handled HTTP request. The response object is a wrapper of Node's HTTP response
    object and is used to set the response data and headers.
  prefs: []
  type: TYPE_NORMAL
- en: The application object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application object contains the following methods to help you configure
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.set(name, value)`: This is a method used to set environment variables
    that Express will use in its configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.get(name)`: This is a method used to get environment variables that Express
    is using in its configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.engine(ext, callback)`: This is a method used to define a given template
    engine to render certain file types; for example, you can tell the EJS template
    engine to use HTML files as templates like this: `app.engine(''html'', require(''ejs'').renderFile)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.locals`: This is a property used to send application-level variables to
    all rendered templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.use([path], callback)`: This is a method used to create an Express middleware
    to handle HTTP requests sent to the server. Optionally, you''ll be able to mount
    middleware to respond to certain paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.VERB(path, [callback...], callback)`: This is used to define one or more
    middleware functions to respond to HTTP requests made to a certain path in conjunction
    with the HTTP verb declared. For instance, when you want to respond to requests
    that are using the GET verb, you can just assign the middleware using the `app.get()`
    method. For POST requests, you''ll use `app.post()`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.route(path).VERB([callback...], callback)`: This is a method used to define
    one or more middleware functions to respond to HTTP requests made to a certain
    unified path in conjunction with multiple HTTP verbs. For instance, when you want
    to respond to requests that are using the GET and POST verbs, you can just assign
    the appropriate middleware functions using `app.route(path).get(callback).post(callback)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.param([name], callback)`: This is a method used to attach a certain functionality
    to any request made to a path that includes a certain routing parameter. For instance,
    you can map logic to any request that includes the `userId` parameter using `app.param(''userId'',
    callback)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more application methods and properties you can use, but using
    these common basic methods enables developers to extend Express in whichever way
    they find reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: The request object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The request object also provides a handful of helping methods that contain
    the information you need about the current HTTP request. The key properties and
    methods of the request object are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`req.query`: This is a property that contains the parsed query-string parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.params`: This is a property that contains the parsed routing parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.body`: This is a property that''s used to retrieve the parsed request
    body. It is included in the `bodyParser()` middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.path` / `req.hostname` / `req.ip`: These are used to retrieve the current
    request path, hostname, and remote IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.cookies`: This is a property used in conjunction with the `cookieParser()`
    middleware to retrieve the cookies sent by the user agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request object contains many more methods and properties that we'll discuss
    later in this book, but these methods are what you'll usually use in a common
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: The response object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The response object is frequently used when developing an Express application
    because any request sent to the server will be handled and responded to using
    the response object methods. It has several key methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(code)`: This is a method used to set the response HTTP status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.set(field, [value])`: This is a method used to set the response HTTP header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.cookie(name, value, [options])`: This is a method used to set a response
    cookie. The options argument is used to pass an object that defines common cookie
    configuration, such as the `maxAge` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.redirect([status], url)`: This is a method used to redirect the request
    to a given URL. Note that you can add an HTTP status code to the response. When
    not passing a status code, it will be defaulted to `302 Found`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status([status]).send( [body])`: This is a method used for non-streaming
    responses. It does a lot of background work, such as setting the Content-Type
    and Content-Length headers and responding with the proper cache headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status([status]).json( [body])`: This is identical to the `res.send()`
    method when sending an object or array. Most of the time, it is used as syntactic
    sugar, but sometimes you may need to use it to force a JSON response to non-objects,
    such as `null` or `undefined`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.render(view, [locals], callback)`: This is a method used to render a view
    and send an HTML response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response object also contains many more methods and properties to handle
    different response scenarios, which you'll learn about later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: External middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Express core is minimal, yet the team behind it provides various predefined
    middleware to handle common web development features. These types of middleware
    vary in size and functionality and extend Express to provide a better framework
    support. The popular Express middleware are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`morgan`: This is an HTTP request logger middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body-parser`: This is a body-parsing middleware that is used to parse the
    request body, and it supports various request types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method-override`: This is a middleware that provides HTTP verb support, such
    as PUT or DELETE, in places where the client doesn''t support it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compression`: This is a compression middleware that is used to compress the
    response data using GZIP/deflate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express.static`: This is a middleware used to serve static files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookie-parser`: This is a cookie-parsing middleware that populates the `req.cookies`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Session`: This is a session middleware used to support persistent sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more types of Express middleware that enable you to shorten your
    development time along with a larger number of third-party middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the Connect and Express middleware, visit the Connect module's
    official repository page at [https://github.com/senchalabs/connect#middleware](https://github.com/senchalabs/connect#middleware).
    If you'd like to browse the third-party middleware collection, visit Connect's
    wiki page at [https://github.com/senchalabs/connect/wiki](https://github.com/senchalabs/connect/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Express framework is pattern-agnostic, which means that it doesn't support
    any predefined syntax or structure, as some other web frameworks do. Applying
    the MVC pattern to your Express application means that you can create specific
    folders where you place your JavaScript files in a certain logical order. All
    these files are basically CommonJS modules that function as logical units. For
    instance, models will be CommonJS modules that contain a definition of Mongoose
    models placed in the `models` folder, views will be HTML or other template files
    placed in the `views` folder, and controllers will be CommonJS modules with functional
    methods placed in the `controllers` folder. To illustrate this better, it's time
    to discuss the different types of application structure.
  prefs: []
  type: TYPE_NORMAL
- en: The application folder structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously discussed better practices when developing a real application,
    where we recommended the use of the `package.json` file over directly installing
    your modules. However, this was only the beginning; once you continue developing
    your application, you''ll soon find yourself wondering how you should arrange
    your project files and break them into logical units of code. JavaScript, in general,
    and—consequently—the Express framework are agnostic about the structure of your
    application as you can easily place your entire application in a single JavaScript
    file. This is because no one expected JavaScript to be a full-stack programming
    language, but it doesn''t mean that you shouldn''t dedicate special attention
    to organizing your project. Since the MEAN stack can be used to build all sorts
    of applications that vary in size and complexity, it is also possible to handle
    the project structure in various ways. The decision is often directly related
    to the estimated complexity of your application. For instance, simple projects
    may require a leaner folder structure, which has the advantage of being clearer
    and easier to manage, while complex projects will often require a more complex
    structure and a better breakdown of logic since it will include many features
    and a bigger team working on the project. To simplify this discussion, it would
    be reasonable to divide it into two major approaches: a horizontal structure for
    smaller projects and a vertical structure for feature-rich applications. Let''s
    begin with a simple horizontal structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal folder structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A horizontal project structure is based on the division of folders and files
    by their functional role rather than by the feature they implement, which means
    that all the application files are placed inside a main application folder that
    contains an MVC folder structure. This also means that there is a single `controllers`
    folder that contains all of the application controllers, a single `models` folder
    that contains all of the application models, and so on. An example of the horizontal
    application structure would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Horizontal folder structure](img/B05071_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app` folder is where you keep your Express application logic, and it is
    divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controllers` folder is where you keep your Express application controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `models` folder is where you keep your Express application models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` folder is where you keep your Express application routing middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` folder is where you keep your Express application views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `config` folder is where you keep your Express application configuration
    files. In time, you''ll add more modules to your application, and each module
    will be configured in a dedicated JavaScript file, which is placed inside this
    folder. Currently, it contains several files and folders, which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env` folder is where you'll keep your Express application environment's
    configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config.js` file is where you'll configure your Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `express.js` file is where you'll initialize your Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `public` folder is where you keep your static client-side files, and it
    is divided into the following folders that represent a separation of functionalities
    in order to comply with the MVC pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config` folder is where you keep your Angular application configuration
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `components` folder is where you keep your Angular application components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `css` folder is where you keep your CSS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `directives` folder is where you keep your Angular application directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pipes` folder is where you keep your Angular application pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `img` folder is where you keep your image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templates` folder is where you keep your Angular application templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bootstrap.ts` file is where you initialize your Angular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `package.json` file is the metadata file that helps you organize your application
    dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `server.js` file is the main file of your Node.js application, and it will
    load the `express.js` file as a module in order to bootstrap your Express application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the horizontal folder structure is very useful for small projects
    where the number of features is limited so that files can be conveniently placed
    inside folders that represent their general roles. Nevertheless, in order to handle
    large projects, where you'll have many files that handle certain features, it
    might be too simplistic. In this case, each folder could be overloaded with too
    many files, and you'd get lost in the chaos. A better approach would be to use
    a vertical folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical folder structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A vertical project structure is based on the division of folders and files
    by the feature they implement, which means that each feature has its own autonomous
    folder that contains an MVC folder structure. An example of the vertical application
    structure would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vertical folder structure](img/B05071_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, each feature has its own application-like folder structure.
    In this example, we have the `core feature` folder that contains the main application
    files and the `feature` folder that includes the feature''s files. An example
    feature will be a user management feature that includes authentication and authorization
    logic. To understand this better, let''s review a single feature''s folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server` folder is where you keep your feature''s server logic, and it
    is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controllers` folder is where you keep your feature's Express controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `models` folder is where you keep your feature's Express models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` folder is where you keep your feature's Express routing middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` folder is where you keep your feature's Express views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config` folder is where you keep your feature's server configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env` folder is where you keep your feature's environment server configuration
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `feature.server.config.js` file is where you configure your features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `client` folder is where you keep your feature''s client-side files, and
    it is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config` folder is where you keep your feature's Angular configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `components` folder is where you keep your feature's Angular `components`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `css` folder is where you keep your feature's CSS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `directives` folder is where you keep your feature's Angular directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pipes` folder is where you keep your feature's Angular pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `img` folder is where you keep your feature's image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templates` folder is where you keep your feature's Angular templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `feature.module.ts` file is where you initialize your feature's Angular
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the vertical folder structure is very useful for large projects
    where the number of features is unlimited and each feature includes a substantial
    number of files. It will allow large teams to work together and maintain each
    feature separately, and it can also be useful in sharing features among different
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although these are two distinctive types of most application structures, the
    reality is that the MEAN stack can be assembled in many different ways. It's even
    likely for a team to structure their project in a way that combines these two
    approaches; so essentially, it is up to the project leader to decide which structure
    to use. In this book, we'll use the horizontal approach for reasons of simplicity,
    but we'll incorporate the Angular part of our application in a vertical manner
    to demonstrate the flexibility of the MEAN stack's structure. Keep in mind that
    everything presented in this book can be easily restructured to accommodate your
    project's specifications.
  prefs: []
  type: TYPE_NORMAL
- en: File-naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While developing your application, you''ll soon notice that you end up with
    many files with the same name. The reason is that MEAN applications often have
    a parallel MVC structure for both the Express and Angular components. To understand
    this issue, take a look at a common vertical feature''s folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File-naming conventions](img/B05071_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, enforcing the folder structure helps you understand each file's
    functionality, but it will also cause several files to have the same name. This
    is because an application's feature is usually implemented using several JavaScript
    files, each having a different role. This issue can cause some confusion for the
    development team, so to solve this, you'll need to use some sort of a naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest solution would be to add each file's functional role to the filename.
    So, a feature controller file will be named `feature.controller.js`, a feature
    model file will be named `feature.model.js`, and so on. However, things get even
    more complicated when you consider the fact that MEAN applications use JavaScript
    MVC files for both Express and Angular applications. This means that you'll often
    have two files with the same name. To solve this issue, it is also recommended
    that you extend file names with their execution destination. This might seem like
    overkill at first, but you'll soon discover that it's quite helpful to quickly
    identify the role and execution destination of your application files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to remember that this is a best practice convention. You can
    easily replace the `controller`, `model`, `client`, and `server` keywords with
    your own keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the horizontal folder structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin the structuring of your first MEAN project, create a new project folder
    with the following folders inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the horizontal folder structure](img/B05071_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have created all the preceding folders, go back to the application''s
    root folder and create a `package.json` file that contains the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `app/controllers` folder, create a file named `index.server.controller.js`
    with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You just created your first Express controller. This code probably
    looks very familiar; that's because it's a copy of the middleware you created
    in the previous examples. What you do here is use the CommonJS module pattern
    to define a function named `render()`. Later on, you'll be able to acquire this
    module and use this function. Once you've created a controller, you'll need to
    use an Express-routing functionality to utilize the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Handling request routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Express supports the routing of requests using either the `app.route(path).VERB(callback)`
    method or the `app.VERB(path, callback)` method, where `VERB` should be replaced
    with a lowercase HTTP verb. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Express to execute the middleware function for any HTTP request
    using the `GET` verb and directed to the root path. If you''d like to deal with
    `POST` requests, your code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Express also enables you to define a single route and then chain several
    middleware to handle different HTTP requests. This means that the preceding code
    example can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another cool feature of Express is its ability to chain several middleware
    in a single routing definition. This means that middleware functions will be called
    in an order, passing them to the next middleware so that you can determine how
    to proceed with middleware execution. This is usually used to validate requests
    before executing the response logic. To understand this better, take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there are two middleware functions named `hasName()`
    and `sayHello()`. The `hasName()` middleware is looking for the `name` parameter;
    if it finds a defined `name` parameter, it will call the next middleware function
    using the next argument. Otherwise, the `hasName()` middleware will handle the
    response by itself. In this case, the next middleware function would be the `sayHello()`
    middleware function. This is possible because we've added the middleware function
    in a row using the `app.get()` method. It is also worth noting the order of the
    middleware functions because it determines which middleware function is executed
    first.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates well how routing middleware can be used to perform
    different validations when determining what the response should be. You can, of
    course, leverage this functionality to perform other tasks, such as validating
    user authentication and resources' authorization. For now, though, let's just
    continue with our example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the routing file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next file you''re going to create is your first routing file. In the `app/routes`
    folder, create a file named `index.server.routes.js` with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you did a few things. First, you used the CommonJS module pattern again.
    As you may remember, the CommonJS module pattern supports both the exporting of
    several functions, such as what you did with your controller, and the use of a
    single module function, such as what you did here. Next, you required your `index`
    controller and used its `render()` method as a middleware to GET requests made
    to the root path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The routing module function accepts a single argument called `app`, so when
    you call this function, you'll need to pass it the instance of the Express application.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that you have left to do is to create the Express application object and
    bootstrap it using the controller and routing modules you just created. To do
    this, go to the `config` folder and create a file named `express.js` with the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you required the Express module and then used
    the CommonJS module pattern to define a `module` function that initializes the
    Express application. First, it creates a new instance of an Express application,
    and then it requires your routing file and calls it as a function, passing it
    the application instance as an argument. The routing file will use the application
    instance to create a new routing configuration, and then it will call the controller's
    `render()` method. The `module` function ends by returning the application instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `express.js` file is where we configure our Express application. This is
    where we add everything related to the Express configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize your application, you''ll need to create a file named `server.js`
    in the root folder and copy the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is it! In the main application file, you connected all the loose ends by
    requiring the Express configuration module and then using it to retrieve your
    application object instance and listening to port `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start your application, navigate to your application''s root folder using
    your command-line tool and install your application dependencies using `npm`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Your Express application should run now! To test it, navigate to `http://localhost:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you learned how to properly build your Express application.
    It is important that you note the different ways in which you used the CommonJS
    module pattern to create your files and require them across the application. This
    pattern will often repeat itself in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express comes with a pretty simple configuration system that enables you to
    add certain functionalities to your Express application. Although there are predefined
    configuration options that you can change to manipulate the way it works, you
    can also add your own key/value configuration options for any other usage. Another
    robust feature of Express is its ability to configure your application based on
    the environment it's running on. For instance, you may want to use the Express
    logger in your development environment and not in production, while compressing
    your responses body might seem like a good idea when running in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, you will need to use the `process.env` property. `process.env`
    is a global variable that allows you to access predefined environment variables,
    and the most common one is the `NODE_ENV` environment variable. The `NODE_ENV`
    environment variable is often used for environment-specific configurations. To
    understand this better, let's go back to the previous example and add some external
    middleware. To use this middleware, you will first need to download and install
    them as your project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, edit your `package.json` file to look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we stated previously, the `morgan` module provides a simple logger middleware,
    the `compression` module provides response compression, the `body-parser` module
    provides several middleware to handle the request data, and the `method-override`
    module provides `DELETE` and `PUT` HTTP verbs'' legacy support. To use these modules,
    you will need to modify your `config/express.js` file to look like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just used the `process.env.NODE_ENV` variable to determine
    our environment and configure the Express application accordingly. We simply used
    the `app.use()` method to load the `morgan()` middleware in a development environment
    and the `compress()` middleware in a production environment. The `bodyParser.urlencoded()`,
    `bodyParser.json()`, and `methodOverride()` middleware will always load regardless
    of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize your configuration, you''ll need to change your `server.js` file
    to look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `process.env.NODE_ENV` variable is set to the default `development`
    value if it doesn't exist. This is because often, the `NODE_ENV` environment variable
    is not properly set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you set the NODE_ENV environment variable in your operating
    system prior to running your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Windows environment, this can be done by executing the following command
    in your command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While in a Unix-based environment, you should simply use the following export
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To test your changes, navigate to your application''s root folder using your
    command-line tool and install your application dependencies using `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Your Express application should now run! To test it, navigate to `http://localhost:3000`,
    and you'll be able to see the logger in action in your command-line output. However,
    the `process.env.NODE_ENV` environment variable can be used in an even more sophisticated
    manner when dealing with more complex configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Environment configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During your application development, you will often need to configure third-party
    modules to run differently in various environments. For instance, when you connect
    to your MongoDB server, you''ll probably use different connection strings in your
    development and production environments. Doing this in the current setting will
    probably cause your code to be filled with endless `if` statements, which will
    generally be harder to maintain. To solve this issue, you can manage a set of
    environment configuration files that hold these properties. You will then be able
    to use the `process.env.NODE_ENV` environment variable to determine which configuration
    file to load, thus keeping your code shorter and easier to maintain. Let''s begin
    by creating a configuration file for our default development environment. To do
    this, create a new file inside your `config/env` folder and call it `development.js`.
    Inside your new file, paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, your configuration file is currently just an empty CommonJS
    module initialization. Don''t worry about it; we''ll soon add the first configuration
    option, but first, we''ll need to manage the configuration files'' loading. To
    do this, go to your application''s `config` folder and create a new file named
    `config.js`. Inside your new file, paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this file simply loads the correct configuration file according
    to the `process.env.NODE_ENV` environment variable. In the upcoming chapters,
    we'll use this file, which will load the correct environment configuration file
    for us. To manage other environment configurations, you'll just need to add a
    dedicated environment configuration file and properly set the `NODE_ENV` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common feature of web frameworks is the ability to render views. The
    basic concept is passing your data to a template engine that will render the final
    view, usually in HTML. In the MVC pattern, your controller uses the model to retrieve
    the data portion and the view template to render the HTML output, as described
    in the next diagram. The Express extendable approach allows the usage of many
    Node.js template engines to achieve this functionality. In this section, we''ll
    use the EJS template engine, but you can later replace it with other template
    engines. The following diagram shows the MVC pattern in rendering application
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering views](img/B05071_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Express has two methods to render views: `app.render()`, which is used to render
    the view and then pass the HTML to a callback function, and the more common `res.render()`,
    which renders the view locally and sends the HTML as a response. You''ll use `res.render()`
    more frequently because you usually want to output the HTML as a response. However,
    if, for instance, you''d like your application to send HTML e-mails, you will
    probably use `app.render()`. Before we begin exploring the `res.render()` method,
    let''s first configure our view system.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the view system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to configure the Express view system, you will need to use the EJS
    template engine. Let''s get back to our example and install the EJS module. You
    should begin by changing your `package.json` file to look like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install the EJS module by navigating in the command line to your project''s
    root folder and issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After npm finishes the installation of the EJS module, you''ll be able to configure
    Express to use it as the default template engine. To configure your Express application,
    go back to the `config/express.js` file and change it to look like the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note how we use the `app.set()` method to configure the Express application
    `view` folder and template engine. Let's create your first view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering EJS views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EJS views basically consist of HTML code mixed with `EJS` tags. EJS templates
    will reside in the `app/views` folder and will have the `.ejs` extension. When
    you use the `res.render()` method, the EJS engine will look for the template in
    the `views` folder, and if it finds a complying template, it will render the HTML
    output. To create your first EJS view, go to your `app/views` folder and create
    a new file named `index.ejs`, which contains the following HTML code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should be mostly familiar to you, except for the `<%= %>` tag. These
    tags are the way to tell the EJS template engine where to render the template
    variables—in this case, the `title` variable. All you have left to do is configure
    your controller to render this template and automatically output it as an HTML
    response. To do this, go back to your `app/controllers/index.server.controller.js`
    file and change it to look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the way the `res.render()` method is used. The first argument is the name
    of your EJS template without the `.ejs` extension, and the second argument is
    an object containing your template variables. The `res.render()` method will use
    the EJS template engine to look for the file in the `views` folder that we set
    in the `config/express.js` file and will then render the view using the template
    variables. To test your changes, use your command-line tool and issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Well done; you have just created your first EJS view! Test your application
    by visiting `http://localhost:3000`, where you'll be able to view the rendered
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: EJS views are simple to maintain, and they provide an easy way to create your
    application views. We'll elaborate a bit more on EJS templates later in this book,
    not as much as you would expect, however, because in MEAN applications, most of
    the HTML rendering is done on the client side using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any web application, there is always a need to serve static files. Fortunately,
    Express'' only built-in middleware is the `express.static()` middleware, which
    provides this feature. To add static file support to the previous example, just
    make the following changes in your `config/express.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `express.static()` middleware takes one argument to determine the location
    of the `static` folder. Note how the `express.static()` middleware is placed below
    the call for the routing file. This order matters because if it were above it,
    Express would first try to look for HTTP request paths in the `static files` folder.
    This would make the response a lot slower as it would have to wait for a filesystem
    I/O operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your static middleware, add an image named `logo.png` to the `public/img`
    folder and then make the following changes in your `app/views/index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run your application using Node''s command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To test the result, visit `http://localhost:3000` in your browser and watch
    how Express is serving your image as a static file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sessions are a common web application pattern that allows you to keep track
    of the user''s behavior when they visit your application. To add this functionality,
    you will need to install and configure the `express-session` middleware. To do
    this, start by modifying your `package.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the `express-session` module by navigating to your project''s
    root folder in the command line and issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation process is finished, you''ll be able to configure your
    Express application to use the `express-session` module. The `express-session`
    module will use a cookie-stored, signed identifier to identify the current user.
    To sign the session identifier, it will use a secret string, which will help prevent
    malicious session tampering. For security reasons, it is recommended that the
    cookie secret be different for each environment, which means that this would be
    an appropriate place to use our environment configuration file. To do this, change
    the `config/env/development.js` file to look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is just an example, feel free to change the secret string. For other
    environments, just add the `sessionSecret` property in their environment configuration
    files. To use the configuration file and configure your Express application, go
    back to your `config/express.js` file and change it to look like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the configuration object is passed to the `express.session()` middleware.
    In this configuration object, the `secret` property is defined using the configuration
    file you previously modified. The session middleware adds a session object to
    all request objects in your application. Using this session object, you can set
    or get any property that you wish to use in the current session. To test the session,
    change the `app/controller/index.server.controller.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What you did here was basically record the time of the last user request. The
    controller checks whether the `lastVisit` property was set in the `session` object,
    and if so, it outputs the last visit date to the console. It then sets the `lastVisit`
    property to the current time. To test your changes, use Node''s command-line tool
    to run your application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, test your application by visiting `http://localhost:3000` in your browser
    and watching the command-line output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created your first Express application and learned how
    to properly configure it. You arranged your files and folders in an organized
    structure and discovered alternative folder structures. You also created your
    first Express controller and learned how to call its methods using Express' routing
    mechanism. You rendered your first EJS view and learned how to serve static files.
    You also learned how to use `express-session` to track your user's behavior. In
    the next chapter, you'll learn how to save your application's persistent data
    using MongoDB.
  prefs: []
  type: TYPE_NORMAL
