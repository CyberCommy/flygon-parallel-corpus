- en: Chapter 8. Introducing sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that we could make use of `sed` to edit files
    from within our scripts. The `sed` command is the **Stream Editor** and opens
    the file line by line to search or edit the file contents. Historically, this
    goes way back to Unix where systems may not have had enough RAM to open very large
    files. Using `sed` was absolutely required to carry out edits. Even today, we
    will use `sed` to make changes and display data from files with hundreds and thousands
    of entries. It is simpler and easier and more reliable than a human trying to
    do the same thing. Most importantly, as we have seen, we can use `sed` in scripts
    to edit the files automatically, no human interaction is required.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at `grep` and search the files for text. The `re` in
    `grep` command is short for **Regular Expression**. This introduces the power
    of POSIX Compliant Regular Expressions before we look at `sed`. Even though we
    are not looking at scripting in this chapter, we will be covering some very important
    tools that we can use with scripts. In the next chapter, we will see the practical
    implementation of `sed` in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the moment, we have enough queued and we will cover the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `grep` to display text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using grep to display text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome back and welcome to the power of using regular expressions in the command
    line. We will be beginning this journey by looking at the `grep` command. This
    will enable us to grasp some simple concepts of searching through the text before
    moving onto more complex regular expressions and the editing file with `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Regular Expression Print** (**grep**), or what we more commonly call
    the command `grep`, is a command line tool used to search globally (across all
    the lines in a file) and print the result to `STDOUT`. The search string is a
    regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The `grep` command is such a common tool that it has many simple examples and
    numerous occasions where we can use it each day. In the following section, we
    have included some simple and useful examples with explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying received data on an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will print just the received data from the `eth0` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the interface that is my primary network connection to the Raspberry
    Pi that we are using in this course. If you are uncertain of your interface name,
    you can use the `ifconfig -a` command to display all the interfaces and choose
    the correct interface name on your system. If `ifconfig` is not found, try typing
    the full path `/sbin/ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using just the `ifconfig eth0` command, a heap of data can be printed to the
    screen. To show just the packets received, we can isolate the lines that contain
    `RX packets` (`RX` for received). This is where `grep` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the pipe or vertical bars we can take the output of the `ifconfig` command
    and send it to the input of the `grep` command. In this case, `grep` is searching
    for a very simple regular expression, "RX packet". The search string is case-sensitive,
    so we need to get this right or use the `-i` option with `grep` to run the search
    as case-insensitive, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The case-insensitive search is especially useful when searching for options
    on a configuration file, which often have a mixed-case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the result of the initial command in the following screenshot, confirming
    that we have been able to isolate just the single line of output, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying received data on an interface](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying user account data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The local user account database in Linux is the `/etc/passwd` file and this
    is readable by all user accounts. If we want to search for the line that contains
    our own data, we can use either our own login name in the search or use parameter
    expansion and the `$USER` variable. We can see this is the following command example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the input to `grep` comes from the `/etc/passwd` file and we
    search for the value of the `$USER` variable. Again, in this case, it is a simple
    text but it is still the regular expression, just without any operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we include the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying user account data](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can extend this a little using this type of query as a condition within
    a script. We can use this to check if a user account exists before trying to create
    a new account. To keep the script as simple as possible and to ensure that the
    administrative rights are not required, creating the account will display just
    the prompt and conditional test in the following command-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `grep` search now makes use of the `$REPLY` variable populated by `read`.
    If I enter the name `pi`, a message will be displayed and we will exit because
    my user account is also called `pi`. There is no need to display the result from
    `grep`, we are just looking for a return code that is either `true` or `false`.
    To ensure that we do not see any unnecessary output if the user is in the file,
    we redirect the output from `grep` to the special device file `/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run this from the command line, you should start a new bash
    shell first. You can do this by simply typing `bash`. In this way, when the `exit`
    command runs it will not log you out but close the newly opened shell. We can
    see this happening and the results when specifying an existing user within the
    following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying user account data](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Listing the number of CPUs in a system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another really useful feature is that `grep` can count the matching lines and
    not display them. We can use this to count the number of CPU or CPU cores we have
    on a system. Each core or CPU is listed with a name in the `/proc/cpuinfo` file.
    We can then search for the text `name` and count the output; the `-c` option used
    is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I am using a Raspberry Pi 2 and this has four cores, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the number of CPUs in a system](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use the same code on a Raspberry Pi Model B that has a single core, we
    will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the number of CPUs in a system](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can again make use of this in a script to verify if enough cores are available
    before running a CPU intensive task. To test this from the command line, we can
    use the following code that we execute on the Raspberry Pi with just the single
    core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We only run bash at the start to ensure that we are not logged out of the system
    with the exit command. If this was in a script, this will not be required, as
    we will exit the script and not our shell session.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this on the Model B, we can see the results of the script and also
    the indication that we do not have the required number of cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the number of CPUs in a system](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you had a requirement to run this check in more than one script, then you
    could create a function in a shared script and source the script holding the shared
    functions within the script that requires to be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a parameter is passed to the function, then it is used as the required number
    of cores; otherwise, we set the value to `2` as the default. If we define this
    as a function in the shell on the Model B Raspberry Pi and display the details
    with the command type, we should see this as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the number of CPUs in a system](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we run this on a single-core system and specify the requirement of just the
    single core, we will see that there is no output when we meet the requirement.
    If we do not specify the requirement, then it will default to `2` cores and we
    will fail to meet the requirement and we exit the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the output of the function when run with the argument of `1` and
    then without arguments, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the number of CPUs in a system](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see how useful even the basics of `grep` can be within the scripts and
    how we can use what we have learned to start creating usable modules to add to
    our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now look at creating a script to parse or format a CSV file. The formatting
    of the file will add new lines, tabs, and color to the output, so that it is more
    readable. We can then use `grep` to display single items from the CSV file. The
    practical application here is a catalog system based on the CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: The CSV file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CSV file or list of comma separated values will come from the file tools
    that we have in a current directory. This is a catalog of products that we sell.
    The file contents are shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a simple demonstration, so we don''t expect too much data but
    each item in the catalog consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Units in stock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that we have a drill which costs $99 and we have five units in stock.
    If we list the file with `cat` it is not very friendly; however, we can write
    a script to display the data in a more appealing way. We can create a new script
    called `$HOME/bin/parsecsv.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s works through this file and look at the pertinent steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OLDIFS="$IFS"` | The `IFS` variable stores the file separator and this is
    normally a white space. We can store the old `IFS` so that we can restore it later
    at the end of the script. Ensuring that we return the same environment once the
    script is complete, no matter how the script is run. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFS=","` | We set the separator to a comma to match what we need with a
    CSV file. |'
  prefs: []
  type: TYPE_TB
- en: '| `while read product price quantity` | We enter a `while` loop to populate
    three variables that we need: product, price, and quantity. The `while` loop will
    read the input file, line by line, and populate each of the variables. |'
  prefs: []
  type: TYPE_TB
- en: '| `echo …` | The `echo` command displays the product name in blue with double
    underscores underneath. The other variables are printed on new lines and tabbed
    in. |'
  prefs: []
  type: TYPE_TB
- en: '| `done <"$1"` | This is where we read the input file, which we pass as an
    argument to the script. |'
  prefs: []
  type: TYPE_TB
- en: 'The script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CSV file](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can execute the script with the tools catalog file located in the current
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To look at how this will display, we can view the partial output from the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CSV file](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are now starting to get the idea that we have a lot of power at the command
    line to format files in a more readable way and a plain text file does not need
    to be plain.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating catalog entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we need to search for one entry, then we need more than just one line. The
    entry is in three lines. So, if we search for the hammer, we need to go to the
    hammer line and the two lines that follow. We do this using the `-A` option to
    `grep`. We need to display the matching line and two lines after. This will be
    expressed by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating catalog entries](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have maintained our use of **regular expressions** (**RE**) to simple
    text but there is, of course, a lot more to learn from them. Although people may
    often think that the RE seems like comic book profanity that you may see in a
    Batman fight, they do have a powerful meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Working with alternate spellings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, let''s look at some anomalies in spelling. The word color may
    be spelled colour or color depending upon if we were working with UK English or
    US English. This can give rise to issues when searching for the word color, as
    it may be spelled in two ways. Implementing the following command will return
    only the first line containing the word color and not the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to return both spellings, then we can use an `RE` operator. We will
    make use of the `?` operator. You should be aware that in an `RE` the `?` operator
    is not the same as in the shell. In an `RE` the `?` operator means that the previous
    character is optional. When running `RE` with extra operators, we may need to
    run `grep -E` or `egrep` for the enhanced RE engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this in operation with a quick look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with alternate spellings](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How many words have four consecutive vowels?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This ladies and gentlemen is why REs are so important and they are worth persevering
    with. We can also think of some fun games or crossword solvers. The more fun we
    have with REs, the easier they are to use. Many Linux systems include a dictionary
    file located at `/usr/share/dict/words` and we will use this file if it exits
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many words can you think of that have four consecutive vowels? Not sure,
    then let''s search the file with `grep` and REs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, you can see that we use the square brackets. These have the same meaning
    as within the shell and `OR` the grouped characters, as a list. The resulting
    search is for the letter `a` or `e` or `i` or `o` or `u`. Adding the brace brackets
    at the end enables multipliers. Having just the number `4` in the braces indicates
    that we are looking for four vowels consecutive row.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How many words have four consecutive vowels?](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How cool is this? We will never have unfinished crosswords now and no excuse
    for losing at Scrabble either.
  prefs: []
  type: TYPE_NORMAL
- en: RE anchors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used RE anchors when removing commented lines and blank lines
    with the `clean_file` function. The `^` or carat represents the start of the line
    and the `$` represents the end of the line. If we want to list words that begin
    with `ante` from the dictionary file, we will write the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should show anteater, antelope, antenna, and so on. If we want to
    query for words that end with `cord` we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will print a little less and on my system lists the words accord, concord,
    cord, discord, and record.
  prefs: []
  type: TYPE_NORMAL
- en: So, even though this only introduces a small amount of what we can achieve with
    regular expressions, we should appreciate what we can gain from knowing just this
    small amount.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having built a little foundation, we can now start to look at some of the operations
    of `sed`. The commands will be supplied with most Linux systems and are core commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will dive directly into some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `p` operator will print the matched pattern. In this case, we have not
    specified a pattern so we will match everything. Printing the matched lines without
    suppressing `STDOUT` will duplicate lines. The result of this operation is to
    print all the lines in the `passwd` file twice. To suppress `STDOUT`, we use the
    `-n` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Brilliant!!We have just reinvented the `cat` command. We can now specifically
    work with just a range of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have reinvented the `head` command, but we can also specify the range
    in an RE to recreate the `grep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the basics of sed](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Substituting command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the `p` command for printing the pattern space. We will now look
    at the substitute command or `s`. With this command, we can replace one string
    with another. Again by default, we send the output to the `STDOUT` and do not
    edit the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the default shell of the user `pi`, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue the earlier instance using the `p` command to print the matched
    pattern and use the `-n` option to suppress `STDOUT`. We search for lines beginning
    with `pi`. This represents the username. We then issue the `s` command to substitute
    text in those matched lines. This takes two arguments, the first is the text to
    search for and the second represents the text used to replace the original. In
    this case, we look for `bash` and replace it with `sh`. This is simple and does
    work but it may not be reliable in the long term. We can see the output in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substituting command](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We must emphasize that currently we are not editing the file and just displaying
    it to the screen. The original `passwd` file remains untouched and we can run
    this as a standard user. I mentioned in the previous example that the search may
    be less than reliable as the string we are searching for is `bash`. This is very
    short and perhaps it can be included elsewhere on a matched line. Potentially,
    someone''s last name may be "Tabash", which includes the string `bash`. We can
    extend the search to look for `/bin/bash` and replace it with `/bin/sh`. However,
    this introduces another problem, which is, the default delimiter is the forward
    slash so we will have to escape each forward slash we use in the search and replace
    string, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an option but it is not a tidy option. A better solution is to know
    that the first delimiter we use defines the delimiters. In other words, you can
    use any character as a delimiter. Using the `@` symbol may be a good idea in this
    scenario, as it does not appear in either the search or the replace string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a more reliable search and a readable command line to work with,
    which is always a good thing. We replace just the first occurrence on each line
    of `/bin/bash` with `/bin/sh`. If we need to replace more than the first occurrence,
    we add the `g` command for global at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our case, it is not required but it is good to know.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to edit the file we can use the `-i` option. We will need permissions
    to work with the file but we can make a copy of the file to work with, so we don't
    harm any system file or require additional access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can copy the `passwd` file locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We finish with the `cd` command to ensure that we are working in the home directory
    and the local `passwd` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-i` option is used to run an in-place update. We will not need the `-n`
    option or the `p` command when editing the file. As such, the command is as simple
    as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be no output to the command but the file will now reflect the change.
    The following screenshot shows the command usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the file](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We should make a backup before we make the change by appending a string directly
    after the `-i` option and without any spaces. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to see this, we can reverse the search and replace strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will set the local `passwd` file to be the same as it was before and we
    will have a `passwd.bak` with the previous set of changes. This keeps us safe
    with a rollback option if we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another great chapter that you have firmly under your belt and I hope this was
    really useful to you. Although, we want to concentrate on using `sed`, we started
    with how powerful `grep` can be both inside and outside our scripts. This led
    us to the Regular Expressions before taking a look at just a few of the possibilities
    of `sed`. Although, we have only just touched `sed`, we will start extending this
    in the next chapter were we will expand upon what we have learned. This will take
    the form of scripting Apache Virtual Hosts by first extracting commented data
    from the current configuration, uncommenting and writing it to a template. We
    can then use the template to create new Virtual Hosts. The workhorse of all these
    operations will be `sed` and `sed` scripts.
  prefs: []
  type: TYPE_NORMAL
