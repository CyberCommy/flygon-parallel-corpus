- en: Vulnerability Scanner Python - Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk of service scanning using open source scripts, the first thing
    that comes to mind is making use of various NSE scripts to get the service versions
    and associated vulnerabilities with the configured services. Now, in a typical
    manual network penetration test, we not only make use of NSE scripts to get the
    job done, we also use various Ruby, Perl, and Bash scripts, and Java class files.
    We also run Metasploit auxiliary modules for service scanning and exploit modules
    to exploit vulnerabilities and to create a POC. We may also run various Kali tools,
    such as Nikto for web scanning, or SQLmap, w3af, and Wireshark to capture clear-text
    usernames and passwords for improperly configured FTP or SSH services. All of
    these tools and scripts produce a huge information pool that a tester needs to
    enumerate manually and consolidate. False positives must also be eliminated to
    arrive to a conclusion as to which services possess which vulnerabilities. The
    other aspect of manual service scanning is that it lacks standardization and relies
    more on an individual's expertise and the choice of scripts used. It is important
    to bear in mind that the scripts to be used are mostly disintegrated from one
    another such that a person has to follow a sequential approach to run all the
    desired scripts and modules. We can achieve limited parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how our vulnerability scanner can automate all
    of these activities and bring standardization to the whole ecosystem. We will
    also see how the automated scanner invokes and orchestrates all the amazing tools
    that Kali has to produce an integrated report for the penetration tester to walk
    through, giving them a consolidated view that can be used for quick analysis.
    We will also study the GUI version of the vulnerability scanner, which has more
    advanced features and complements existing vulnerability scanners such as Nessus.
    It must be noted that when I use the word *complements*, by no means am I comparing
    our scanner with Nessus or Qualys. They are both excellent commercial products
    that have evolved over years of R&D, and have some excellent engineers working
    on them. However, we will build something that works amazingly well; knowing the
    code gives you an opportunity to contribute to the scanner, which in turn helps
    to make it better and bigger over time.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already taken a look at the architecture of the scanner in Chapter
    5, *Vulnerability Scanner Python - Part 1*. Lets revisit the service-scanning
    part of the scanner and think about how the whole ecosystem works. The following
    diagram shows the service scanning architecture for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c2cb8c-65e4-43cf-9b06-f7c6d48a5ff2.png)'
  prefs: []
  type: TYPE_IMG
- en: A project ID would be associated with all scans that have been completed with
    Nmap port scanning. The user can select the project ID for which they want to
    carry out service scanning and can also see all the project IDs for which port
    scanning has successfully completed. It should be noted that only the project
    IDs for projects that have been completed will be displayed; projects for which
    the port scanning has been paused would not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project ID has been selected, the code reads the database table `IPtable_history` to
    display open ports and the default configuration, which refers to the open ports
    and the associated scripts (depending on the service name). The user can reconfigure
    the scan results, including manually adding any open ports that have been missed
    or removing any entries for which ports displayed as open aren't actually accessible.
    Once the user has reconfigured the results, we are all set to run a service scan.
    It should be noted that the reconfiguration step can be skipped if the user finds
    the port-scanning results to be all right.
  prefs: []
  type: TYPE_NORMAL
- en: When the scanning activity is over, we will save all the results in our MySQL
    database table. In case of service scanning, depending upon the service discovered,
    we will get a configured list of scripts that we need to execute if a specific
    service is found. We use a JSON file to map the service and corresponding scripts
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of port scanning, a user is prompted with the port-scanning results
    and is given an option to reconfigure the results if needed (to reduce false positives).
    Once the final configuration is set, service scanning is started. The logic is
    to pick one host at a time from the database and, based on the services discovered,
    read the appropriate scripts from the JSON file and execute them for that particular
    host. Finally, after the script is executed, the results should be saved in the
    database. This continues until all the hosts are scanned for their services. Finally,
    an HTML report is produced that contains the formatted results and also contains
    screenshots for the POC to be attached. The following screenshot depicts how the
    JSON file is configured to execute the scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14b16790-646d-4621-b88b-a1d1e4acc5b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the preceding screenshot, there are various categories
    of commands that are placed in the JSON file. The Metasploit template contains
    the commands that are meant to execute the Metasploit modules. Single-line commands
    are used to execute NSE scripts and all modules and scripts that are not interactive
    and that can be fired with a single command. The other categories include `interactive_commands` and `single_line_sniffing`
    (where we need to sniff the traffic along with executing the scripts). The general
    template of the JSON file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61f06b62-c5e6-4ed3-ad34-75242f926e11.png)'
  prefs: []
  type: TYPE_IMG
- en: The **key** is the name of the service. The title contains a description of
    the file. `method_id` is the actual Python method that should be invoked to call
    the external script to be executed. Note that for single-line commands, we also
    specify a `timeout` parameter in seconds as the first argument under the `args`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be noted that the whole code base can be found at GitHub [https://github.com/FurqanKhan1/Dictator](https://github.com/FurqanKhan1/Dictator).
    We will be taking a look at all the essential code files that form the central
    piece of logic for our service scanner. Alternatively, I have created a plug-and-play
    Kali VM image that contains all the prerequisite installations and the codebase
    out of the box. This can be download and executed hassle-free from the following
    URL [https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing](https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing). The
    default username is `PTO_root` and the password is `PTO_root`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an overview of the essential files and methods that we will use
    to build our service- scanning engine, using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Driver_scanner.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After port scanning is over, the next step is to perform service scanning.
    This Python class invokes another class, `driver_meta.py`, which takes the project
    name/ID for which service scanning is to be performed, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85fbab57-78e3-484a-8485-0046530ff0e1.png)'
  prefs: []
  type: TYPE_IMG
- en: driver_meta.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class displays the default result of port scanning and gives user the
    option to reconfigure the results if needed. After reconfiguration, this class
    reads the hosts from the database table for the project for which service scanning
    is to be done. For each host, it then reads the JSON file to get the commands
    to be executed, and for each command to be executed, it passes on the control
    to another file `auto_comamnds.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/681da31c-9d55-4caf-8b07-493e0d90a3cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding class represents the main parent class for this Python module.
    As we can see, we have imported various other Python modules such as JSON, SYS,
    and psutil to be used with this class. We can also see that we have used other
    classes such as `auto_commands`, `Auto_logger`, `IPexploits`, and `IPtable` with
    this module. These are not in-built Python modules but our own classes that perform
    different functionalities for our service-scanning engine. We will discuss these
    in greater detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the `main()` method of this class, from where the execution
    cycle actually starts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method is the same piece of code that is used with both the CLI
    version and the GUI version of the code, so there are many parameters that would
    only be relevant when invoked with the GUI mode. We will discuss those that are
    needed in CLI mode in this section. We can see that the `mode` variable is initialized
    to `c` inside the definition of the `main()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the section highlighted as **(1)** in the following screenshot, we initialize
    an object for the `texttable()` Python module, which will be used to draw a table
    on the console window to display the project IDs for which service scanning can
    be performed. The second section collects all the completed projects from the
    database and section **(3)** adds the retrieved rows to the program variable to
    be displayed on the screen. The subsequent code is straightforward. At section **(4)**,
    the functionality actually removes the earlier details of a project for which
    service scanning would have been completed already, so that the user can overwrite
    the results with a new service-scanning operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff8386f7-82c6-4c0e-84eb-68faf33667f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Section **(5)** creates a directory called `<project_id>` under the `results` folder.
    For example, if the current project ID is `744`, the command `init_project_directory()`,
    will create a sub folder under `<parent_folder_code_base>/results/<744_data>`.
    All the log files, the scan configuration, and the final report will be placed
    in this folder. As we have already discussed, we have a preconfigured JSON file
    that contains a mapping between the service name and the test cases to be executed
    against that service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections shows how the JSON file is configured. Let''s take an
    example of an `http` service and see how the test cases are configured to be executed
    against the HTTP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cd0d5fc-1e43-4e3a-adb4-2979fd3bdd44.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/2dfa78c5-7d56-4f00-9816-a31c2b49b049.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/540f9725-5a06-4615-a521-68e986493403.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/506435b2-4e03-4bd1-a5fe-807439c928fd.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/81302c92-bbc5-49eb-ade6-91118d91c197.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/21bb1a31-9f5b-4e24-880b-b84f899b0ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen and classified from the preceding bifurcation, all the test
    cases for the service called `http` will be placed in a JSON list with the key
    as `Commands`. Each entry within the `Commands` list would be a JSON dictionary
    that has the following entries:`{"args":[],"id":"","method":"","include":"","title":""}`.
    Each dictionary formulates one test case to be executed. Let''s try to understand
    each of the entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args`: The `args` parameter is actually a list that contains the actual commands
    and NSE scripts to be executed against a target. All the commands/scripts that
    are to be executed are classified into five different categories that we will
    see in the method section. For now, it is enough to understand that args contain
    the actual commands to be executed on the Kali console with Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: Each command to be executed is given a unique ID, which makes the enumeration
    easy. For all HTTP-based commands, we can see the IDs are `http_1`, `http_2`,
    `http_3`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This particular entry is very important, as it refers to an actual
    Python method that should be invoked to execute this testcase. The methods are
    placed inside a Python file/module `auto_commands.py` and this class has different
    methods mapped to the JSON file. Generally, all the scripts to be executed are
    broken into five classes/categories, and each category has a corresponding method
    associated with it. The categories of scripts and their corresponding methods
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Single_line_comamnds_timeout`: All the commands/scripts that require a one
    time invocation and that produce the output for you, without requiring any interaction
    in between, fall under this classification. For example, an NSE script can be
    executed as follows: `nmap -p80 --script <scriptname.nse> 10.0.2.15`; it would
    not require any other input and would just execute and give us the final output.
    Alternatively, a Perl script to perform directory enumeration can be invoked as
    follows: `perl http-dir-enum.pl http://10.0.2.15:8000`.Likewise, all the Python
    scripts, Bash commands, and Kali tools, such as Nikto or Hoppy, will fall under
    this category. All such scripts are handled by a Python method, `singleLineCommands_timeout()`,
    placed inside the `auto_comamnds.py` module. It should be noticed that all such
    scripts also need an additional `timeout` parameter. There are occasions when
    a single script hangs for some reasons (the host might be unresponsive, or it
    might encounter an unforeseen condition for which it was not tested), and the
    hanging of the script will cause the other scripts in the queue to be in the waiting
    state. To get around this condition, we specify a threshold parameter as the first
    argument in the `args[]` list, which is the maximum time in seconds for which
    we want the script to be executed. This is why, from the previous configuration,
    we can see that `500` seconds is specified as a timeout for the NSE script whose
    ID is `http_5`. If the script is not executed within `500` seconds, the operation
    is aborted and the next script in the queue is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`General_interactive`: Apart from scripts that require a single-line command
    to be fired and executed, we also have other Bash commands, Kali tools, and open
    source scrips that require some interaction after being fired. A typical example
    would be to SSH to a remote server, where we usually pass two sets of commands.
    This can be done in a single shot, but, just for the sake of understanding, let''s
    take the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh root@192.168.250.143 [Command 1]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password:<my_password> [Command 2]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another example could be tools such as SQLmap, or w3af_console, where some amount
    of user interaction is needed. Note that with this automation/scanning engine,
    we would have a workaround by which scripts would be automatically invoked and
    executed with Python. All scripts or testcases that require interaction are handled
    by a method called `general_interactive()`, which is placed under the Python module
    `auto_comamnds.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '`General_commands_timeout_sniff`: There are many occasions in which we need
    to execute a script or a bash command and at the same time we want Wireshark to
    sniff the traffic at the interface so that we can find out if the credentials
    are being passed in cleartext or not. During the execution of scripts in this
    category, the traffic must be sniffed as well. They can either be single-line
    scripts such NSE or interactive commands such as `ssh root@<target_ip>` as the
    first command and `password:<my_password>` as the second. All scripts that need
    this kind of invocation are handled by the Python method `generalCommands_Tout_Sniff()`, which
    is again present in the `auto_comamnds.py` module.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Metasploit_Modules`: This is the category that will execute and handle all
    the Metasploit modules. Whenever we are required to execute any Metasploit module,
    that module (be it auxiliary or exploit) will be placed inside this classification.
    The method to which the execution is delegated, which is called `custom_meta()`, is
    placed under `auto_commands.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_BASED`: The final category contains all test cases that require an HTTP
    GET/POST request to be posted on the target to be tested, and such cases are handled
    by a method called`http_based()`, which is again placed in the `auto_commands.py` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`**: **The `include` parameter takes two values: `True` and `False`)
    If we don''t wish the test case/script to be included in the list of testcases
    to be executed, we can set `include=False`. This feature is very useful when choosing
    scan profiles. There are certain occasions where we don''t want to run time consuming
    testcases such as Nikto or Hoppy on our target and prefer to run only certain
    mandatory checks or scripts. To have that capability the include parameter is
    introduced. We will discuss this further when we look at scan profiles with the
    GUI version of our scanner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is an informative field, which gives information about the underlying
    script to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the JSON file that will be loaded into
    our `self.commandsJSON` `class variable`, let's move ahead with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The section highlighted as **(6)** reads that JSON file in our `all_config_file`` program
    variable`, which eventually goes to the `self.commandsJSON` class variable. The
    sections of code highlighted as **(7), (8)** and **(9)** load the scan profile
    to be used with the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/713e7e4b-8050-48d1-9fca-5c71b6923f2f.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, the scan-profile with the command-line version of our code is **mandatory
    profile**. This profile by and large contains all the testcases that should be
    executed against the target; it just removes a few time-consuming ones. However,
    if we wish to change the definition of `mandatory_profile`, to add subtract test
    cases, we can edit the `mandatory.json` file, which lies at the same path as our
    code file, `driver_meta.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the entries present in the `mandatory.json` file for the
    `http` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69c995fb-6104-47de-8833-c685ade1fb02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The section highlighted as (9) will load all the results obtained from the
    port scanning of the project ID `744` for our example. The results are saved inside
    the database table `IPtable_history` and the following screenshot gives us an
    idea of which records will be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8817ae65-958f-4a75-bfb8-2f7516511948.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding screenshot that there are basically three records
    that correspond to our scan with the ID `744`. The schema of the table columns
    is `(record_id,IP,port_range,status,project_id,Services_detected[CSV_format])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual query executed at the backend is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab761712-4d83-40b8-99ca-4967034874ad.png)'
  prefs: []
  type: TYPE_IMG
- en: The returned result would be a list of lists that can be iterated over. The
    0th index of the first inner list will contain the services detected loaded in
    CSV. The format would be `(host;protocol;port;name;state;product;extrainfo;reason;version;config;cpe)`,
    as can be verified from the preceding screenshot. All this information will be
    placed inside a `results_` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(10)**, as shown in the folliwng snippet, we are iterating over
    the `results_` list and splitting the string data over the new line `\n`. We are
    further splitting the returned list over `;`, and finally placing all the results
    under a list, `lst1 []`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/468fa19f-5549-44a3-b1f2-8cfbea3e15b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the current example, after section (11), `lst1` will contain the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Thus, `lst1[0][0]` will give us `10.0.2.15`, `lst1[2][2]=111` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(12)** of the code, we are sorting the data in `lst1` by the service
    type. We have declared a dictionary, `lst={}`, and we want to group all the hosts
    and ports according to their type of service, such that the output of section
    **(12)**, **(13)** would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In section **(15)**, `ss = set(lst_temp).intersection(set(lst_pre))`, we are
    doing a set intersection between two structures that contain dictionary keys.
    One structure contains keys from the dictionary `lst`, which in turn contains
    all the services that our port scanner discovered. The other contains keys that
    are loaded from the preconfigured JSON file.The objective of this is for us to
    see all the discovered services for which test cases are mapped. All the discovered
    and mapped service keys/names go in the list **SS**, which stands for services
    to be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: In section **(16)**, `ms=list(set(lst_temp) - set(lst_pre))`, we are comparing
    the services that are not configured in the JSON file against the services discovered.
    Our JSON file is quite exhaustive in terms of commonly found services, but there
    are still cases in which Nmap might find a service during port scanning that is
    not preconfigured in our JSON file. In this section, we are trying to identify
    the services that Nmap has discovered but that do not have testcases mapped against
    them in our JSON file. To do this, we are doing a set difference between the two
    structures. We will tag those services as `new`, and the user can either configure
    testcases against them or analyze them offline to execute custom testcases. All
    these services will be placed in a list called `ms`, where **ms** stands for **missed
    services**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In sections **(17) and (18)** as shown in the following code snippet, we are
    again restructuring the two missed and mapped services in two different dictionaries
    in the format mentioned earlier: `{"ssh":[[10.0.2.15,22,open,OpenSSH-7.2p2 Debian
    5;10]],...}`. The discovered services will be placed in the `dic` dictionary and
    then into the `self.processed_services` class variable. The missed ones will be
    placed into `ms_dic` and finally into `self.missed_services`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb45071f-0a2e-464b-92e3-afcd94dc1f62.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, under section **(19)**, we are invoking the `parse_and_process()` method, which
    will invoke the logic of displaying the discovered and missed services and will
    give the user the option to perform any reconfiguration if needed.
  prefs: []
  type: TYPE_NORMAL
- en: After reconfiguration is done, `parse_and_process()` will invoke another method, `launchExploits()`,
    which will actually read the `method_name` from the JSON configuration file, replace
    the `<host>` and `<port>` with the appropriate host IP and port discovered, and
    pass the control to the relevant method (based upon the `method_name` read) of
    the `auto_command.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the testcases are executed for all the discovered hosts and ports,
    it''s time to generate a report with screenshots and relevant data. This is the
    portion that is handled by sections **(20)** and **(21)**, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de832afc-89f4-4334-bb8a-f0b530f0e418.png)'
  prefs: []
  type: TYPE_IMG
- en: parse_and_process()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we are going to understand how the `parse_and_process()`
    method works. It should be noted that for the CLI version, the mode variable has
    a value of `c`, and we are going to focus only on the code section that ladders
    to `mode=c`. The other branches of code will be for GUI mode, and you are free
    to read this if you want to know more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `parse_and_process()` method in sections, **(1), (2), (3),** and **(4)** starts
    its execution by iterating over `self.missed_services` and then over `self.processed_services`.
    The idea of iteration here is to place these discovered services, host, ports
    and `command_template` in a different database table, `IPexploits`. We will discuss
    the `command_template` in a little while. For our current example, the `self.processed_services` will
    contain the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because all the discovered services except `rtsp` are mapped in the
    JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d65d025-09fe-4937-b2d5-69cb6a2c2701.png)'
  prefs: []
  type: TYPE_IMG
- en: Section **(5)** of the code iterates over this dictionary and tries to fetch
    something such as `getTemplate(k)`, where `k` is the current service being iterated
    over. `getTemplate()` is a method that reads the JSON file and returns the command
    ID for the testcase to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71b39b2a-5e6e-4b57-9c5b-133b20b04f55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example will make this clear. Let''s say that `getTemplate` is
    invoked over `http`, such as `getTemplate(''http'')`. This would return the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure is as follows: `{ "http_5" : [''include_command,commands_executed,results_obtained]}`.
    If `http_5` is the key, the value is a list with three entries. The first says
    whether the command is to be included or executed (depending upon the scan profile
    chosen). The second entry holds the actual command that gets executed on the terminal.
    Initially it is set to 0, but once executed, the `0` for `http_5` will be replaced
    by `nmap -Pn --script=banner.nse -p 80 10.0.2.15`.The third, `0`, will actually
    be replaced by the results produced by the execution of the command mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: The code `entries=getTemplate(k)` will return entries such as the one mentioned
    for each service type. We prepare a list called `rows`, where we place the host,
    port, service, open/close status, and entries/`command_template`. The code snippet
    that performs that activity is `self.rows.append((self.project_id, str(h_p[0]),
    str(h_p[1]), str(k), 'init', entries, service_status, str(h_p[2]), str(h_p[3])))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The services where the `type=new` or that are not mapped will be handled by
    code section **(2)**. This will place the following in the entries for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entries={"Entries": {"new": true, "unknown": false}}`'
  prefs: []
  type: TYPE_NORMAL
- en: Code section **(6)** checks for something such as `if(is_custom==True)`. This
    means that, there are certain services that can be used multiple times with other
    services. For example, the testcases for `ssl` can be used with `https` such as `[http
    +ssl]`, `ftps` as `[ftp + ssl]`, `ssh` as `[ssh + ssl]`. For this reason, services
    such as `https`, `ftps`, and so on are marked as `custom`, and when `https` is
    discovered, we should load both templates for `http` and `ssl`. This is what is
    done in section **(6).**
  prefs: []
  type: TYPE_NORMAL
- en: By the end of section(6), `self.rows` will have entries such as `[project_id,host,port,service,project_status,command_template,service_type,port_state,version]` for
    all hosts and ports. In our current example, it will hold six rows for all the
    service types.
  prefs: []
  type: TYPE_NORMAL
- en: In section **(7)**, `self.IPexploit.insertIPexploits(self.rows)`, we push all
    the data of `self.rows` in the backend database table `IPexploits` in one shot.
    It must be remembered that the datatype of `command_template/entries` is marked
    as JSON in the backend database as well. For this reason, we require MySQL version
    5.7 or above, which supports the JSON datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this command is executed, our backend database for the current project `744` would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c5a600-cb6f-495c-a35f-04aa627ab35b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It must be noted that I am not loading the `command_template` (named `Exploits`
    at the back end ), because then the data becomes cluttered. Let''s try to load
    the template for two services, such as `rtsp` and `ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb545040-2968-4d87-815a-460221e76c30.png)'
  prefs: []
  type: TYPE_IMG
- en: Likewise, we will also have entries for `http`, `ssl`, and `rcpbind`. It should
    be noted that we were expecting six rows in the table, but there are in fact seven.
    This is because the `https` service is broken into two classes `http` and `ssl`,
    thus, at port `443`, instead of having `https`, we have two entries: `http-443` and `ssl-443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, the default configuration of the project (host, ports,
    testcases to be executed) is fetched from the same database table and is displayed
    to the user. Section eight calls the code using `launchConfiguration()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b5026d0-b02a-484b-929c-fa6bfa035ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: launchConfiguration()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's take a look at the `launchConfiguration()` method, which
    loads default configurations, and also gives the user the ability to tweak or
    reconfigure it. Furthermore, it invokes the central logic of the file that would
    actually start script execution, which is `launchExploits()`.
  prefs: []
  type: TYPE_NORMAL
- en: For the CLI version `launchExploits()` is invoked by `launchConfiguiration()`.
    However, in the GUI version, `launchExploits()` is invoked by the `parse_and_process()`
    method only. More information about this method can be seen from the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Section**(1)** of the following code snippet loads all details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits` list.
    Remember that in the backend table we only have the command IDs, such as `http_1` or `http_2` placed
    under the `Template`, but to display the selected configuration and commands to
    be executed, we pull out the actual script, which will map to `http-1` and so
    on. This is what section **(2)** is doing. It reads the JSON file to get the actual
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(3)**, we are placing the pulled details in a `tab_draw` variable, which
    will draw a table on the console window and represent the loaded configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/990785c3-c2da-44ba-a39b-8c30e0a52216.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Section **(4)** is self explanatory; we are placing all the pulled details
    in a dictionary called `config_entry`. This will be saved to a file, as the final
    chosen configuration with the scan will be launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6554158-8c15-420d-9e66-d22d7e042f83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, under section **(6)**, we call `launchExploits()`. If there is a need
    to perform reconfiguration, section **(7)** calls the `self.reconfigure()` method,
    which is straightforward and can be referred from the code-base or from the following URL
    <https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/driver_meta.py>:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6433c485-b025-4b3f-9c44-0434e0202025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Section**(5)** will display the configuration on the screens as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c51bda78-c507-42b4-b873-91884245dc26.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/fb31c123-1961-459a-ad79-f98169b64cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: launchExploits()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section will talk about the `launchExploits()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Section**(9)** of the following code loads all the details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits_data` list.
    We don''t need to focus on the `else` block of `if(concurrent=False)`, as that
    refers to code that is invoked in the GUI version. For now, let''s only take the
    `if` block into consideration, as `concurrent=False` for the CLI version. Next,
    we iterate over the `IPexploits_data: "for exploit in IPexploits_data:"` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6763f0f-2643-46cd-aae9-d051b4138781.png)'
  prefs: []
  type: TYPE_IMG
- en: In section **(10)**, we loading the details from the JSON structure for the
    current service that is being iterated. Remember that `self.commandsJSON` holds
    the whole JSON file data where we mapped the services and testcases. We then load
    all the commands and testcases of that particular service and placing them under
    a list `meta`. For example, if `service = http`, then the meta will hold `[http_1,http_2,http_3,http_4,http_5
    ...]`. Now, remember that in the last section, for each record out of the seven
    records, the `project_status` was `init`. In the next line (section **(11)**),
    we update the status to `processing` for the current record's `(host,port,service,record_id)` combination.
    As we have already picked up this service to be executed, we want to change the
    database status.
  prefs: []
  type: TYPE_NORMAL
- en: In section **(12)**, we load all the enabled service cases for the particular
    service to be executed, depending upon the scan profile chosen for the project.
    As discussed earlier, we have all the essential cases loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain projects/scans that may also need some user defined parameters,
    such as username, passwords to use, and so on. All such parameters are placed
    inside a `Project_params.json` file, and section **(13)** replaces the usernames
    and passwords of the command to be executed with the project specific usernames
    and passwords, wherever applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/041520fe-43b0-49b0-8a05-bbf48c712f04.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Self.commandObj` holds the object of the `auto_commands.pl` class. Section **(14)** initializes
    the instance variables of the class that are relevant to the current record set
    to be executed (host, port, service, and so on). As we discussed earlier, the `args` parameter
    from the JSON file contains the actual command to be executed. We loaded the `args` value
    in the program variable args. As we know, this is a list that contains commands.
    We iterate over this list and replace entries such as `<host>` with the actual
    IP to be scanned and `<port>` with the actual port to be scanned. We will repeat
    this activity for all the testcases, one by one. For the current example, if we
    assume that `http` is the current service to be scanned, the code will iterate
    over all the commands, `[http_1,http_2..]`. Finally, the `final_args` list for `http_5` and
    port `80` will be specified as `[500, nmap -Pn --script=banner.nse -P80 10.0.2.5]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ed344b-bd52-4367-a752-f63f7824bf31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In section **(16)**, we are actually invoking the appropriate method from the `auto_comamnds.py` module. Let''s
    think about how this works. `getattr(object, name[, default])` returns the value
    of the named attribute of `object. name` and must be a string. If the string is
    the name of one of the object’s attributes, the result is the value of that attribute.
    For example, `getattr(x,''Method_name'')` is equivalent to `x. Method_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9c3517f-c4db-4c63-bc00-dfbb45d6796d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have already discussed, the name of the method to execute the script/module
    is preconfigured in the JSON file, and in the preceding code it is read in the
    variable method. `func = getattr(self.commandObj,method_name)` will return the
    reference of that method, and can be invoked such as `func(args)`. This is what
    is done in section **(18)**: `func(final_args,grep_commands)`. When that method
    is executed, it will automatically save the results in the database. Once all
    the test cases for a service are executed, we want to update the status of that
    row from `processing` to `complete`, which is what is done at section **(20)**.
    The same operation is repeated until all the discovered services for all the hosts
    are scanned. Let''s take a look at what the database table looks like when a test
    case is executed. We will be taking examples from a different project ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36cb2886-81b8-4eb0-b265-0a256cb7a1c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the preceding screenshot, the data for this particular
    row for the project ID 736 before service scanning would have been as follows:
    `Pid=736,Service=''ssl'',Exploits={"Entries" :{"ssl_1":[true,0,0]} ... }`. Once
    the execution is over, however, the first 0 is replaced by a list that has the
    command(s) executed. In place of the second 0, we have the final results in the
    form of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: auto_commands.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next section, we will take a look at how stuff actually works, in terms
    of how the methods that get invoked automate the process of service scanning.
    We will be exploring the Python module or file `auto_commands.py`. It must be
    remembered that in this section, we will be covering the essential methods of
    this class. As well as these, there are a few others that are custom made for
    specific use cases. You can refer to the exact code file at the GitHub repository
    [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py%3E).
    Let''s start by looking at what the class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fce252f-5930-4159-a26d-36ccbe015f1e.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the modules we imported was **pexpect**. In the following section, let's
    try to understand what this module does and why it is important.
  prefs: []
  type: TYPE_NORMAL
- en: Pexpect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pexpect is a Python module that works like Unix's expect library. The primary
    purpose of this library is to automate interactive console commands and utilities.
    Pexpect is a pure Python module for spawning child applications, controlling them,
    and responding to expected patterns in their output. Pexpect allows your script
    to spawn a child application and control it as if a human were typing commands.
    Pexpect can be used for automating interactive applications such as SSH, FTP,
    passwd, telnet, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using Pexpect to automate Metasploit with Python and also in to
    invoke various use-cases of terminal automation that require user interaction.
    It must be noted that there are two other methods for invoking Metasploit with
    Python code: `"msfrpc"`, which calls the service API built on top of Metasploit,
    and `".rc"` scripts. We have observed maximum success, however, using the Pexpect
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: The Pexpect module has a spawn class that is used to spawn any terminal command,
    process, or tool. The tools that are spawned should be spawned as a child process
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the spawn class constructor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pexpect.spawn(command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
    logfile=None, cwd=None, env=None, ignore_sighup=False, echo=True, preexec_fn=None,
    encoding=None, codec_errors=''strict'', dimensions=None, use_poll=False)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spawn` class constructor takes many parameters, but the mandatory one
    is `command`. The `command` is the actual command that we wish to execute on a
    Unix terminal. If we wish to pass arguments to the command invoked, we can either
    specify the arguments with the command itself, separated with a space, or pass
    the arguments as a Python list specified under the second argument `args`. The
    third argument is `timeout`, which is 30 seconds by default. This implies that
    if a process is not spawned within 30 seconds, the whole operation will be terminated.
    If our server is under a high load, or we have performance issues, we can increase
    the `timeout` parameter. The following code represents how to invoke an SSH session
    with Pexpect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also construct it with a list of arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the command is executed on the terminal, a session is created and controlled
    via the process, which is returned and placed under the `child` variable, as shown
    in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Another important class for `pexpect` is `expect`. Expect, as the name suggests,
    lays down the expected output or outputs that might be produced if the `spawn`
    command is executed successfully. For example, if the `spawn` command is `pexpect.spawn('/usr/bin/ssh',['user@example.com'])`,
    we would usually expect the ssh server to ask us for a password. All the possible
    patterns or strings that might be expected from the previously specified command
    are passed as arguments to the `pexpect.expect` class, and if any of the patterns
    match, we can define the next command to be sent to the terminal according to
    the match. If there is no match, we may abort the operation and try to debug it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following syntax looks through the stream until a pattern is matched. The
    pattern is overloaded and may take several types. The pattern can be a String
    Type, EOF, a compiled regular expression, or a list of any of those types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pexpect.expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass a list of patterns and more than one matches, the first match in
    the stream is chosen. If more than one pattern matches at this point, the leftmost
    pattern in the pattern list is chosen. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`child.sendLine(command)` is a method that takes the command that is to be
    sent to the terminal assuming everything is working as per the expected pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a small example of SSH automation using Pexpect that will make
    things clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are taking only the success scenario. It must be noted
    that if the terminal expects what lies at index 1 of the input list `'root@.*
    password:.'`, then we pass the password as root with the help of the `sendline`
    method. Note that `'root@.* password:.'` indicates any IP address after root,
    because it is a regex pattern*.* Based on the index of the string/regex pattern
    matched, we can formulate our logic to indicate what should be done next.
  prefs: []
  type: TYPE_NORMAL
- en: custom_meta()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take a look at the `custom_meta` method, which is responsible for
    handling all the Metasploit modules. It does this with the help of the Pexpect
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in section **(1)** in the following snippet, we are using `pexpect.spawn`
    to invoke `"msfconsole -q"`, on our terminal. This will invoke a Metasploit process
    over a virtual terminal and would return the control of that process to the variable
    declared as a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fab3c20-acfd-4dad-a8cf-27e946740955.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Whenever we invoke msfconole, if there is no error, we would get a Metasploit
    prompt as `msf>`. This is what we are specifying in section **(2)**, [.*>, ..,
    ..] , as the 0th index. What is implied here is that we expect anything preceded
    by `>` to be successfully executed, and so we will pass the commands that are
    required to run the Metasploit module. If the index returned by child.expect is
    0, we will iterate over the command list of the JSON file and send each command
    to our Metasploit console. For our projectID `744` and the `http` service, we
    have configured a few Metasploit modules. One of these is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3641e7b9-2482-4cdc-b45f-a543895132bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Whatever is within the `args` keyin the preceding screenshot of the JSON structure
    would be passed as a list to the `custom_meta` method and stored in the commands
    list. In section **(3)****,** we iterate over the commands list, and, as we studied
    earlier, the `<host>` and `<port>` would actually be replaced by an actual host
    and the port being scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, each command is sent to the msfconsole Terminal one by one
    with the `child.sendline(cmd)` command. After sending each command, we need to
    check whether the console is as we expect it to be, which means that it should
    contain the `msf>` prompt. We invoke `pexpect.expect` and specify `".*>"` as the
    0th index of our input list. Note that index 0 defines the success criteria for
    us to continue. As long as we get an output that matches with index 0, we continue,
    as specified by section **(4)**. If at anytime we observe anything other than
    index 0 (either a timeout or the end of a file – EOF), we realize that something
    did not happen as expected, and so we set the boolean variable as false:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/235e44b2-6881-4aef-adc9-3194a695d5bc.png)'
  prefs: []
  type: TYPE_IMG
- en: When we get out of this iterative loop, we move to section **(9)**, where we
    are checking if run ==True. If it is true, we assume all the parameters are properly
    set to execute the Metasploit module. We issue the `'run'` command with the help
    of `sendline`, as highlighted by section **(10)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if everything goes right and the module is executed successfully,
    it''s time for us to collect our results. In section **(11)**, if all goes as
    expected, we collect the results in an `exploits_results` variable and the commands
    in the `commands_launched` variable. If there is an error, we collect the error
    details in section **(12)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc5665f-f413-4ef1-88d2-aaa653010a87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in section **(14)**, we save the results in the database table by
    invoking the `saveDetails()`method**.** It must be noted that the results would
    be saved in the same JSON structure as discussed earlier against the `"http_headers_2"`
    key, which is the ID of the script. The definition of the `saveDetails` method is
    shown. Note it would be issued across all the different methods that we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb32e5f-a63e-4e35-a349-d65ce07842ac.png)'
  prefs: []
  type: TYPE_IMG
- en: The section highlighted as **(1)** invokes the method placed in the class file
    `IPexploits.py`, which would insert the details in the database. The whole code
    file can be found at the GitHub repository**.**
  prefs: []
  type: TYPE_NORMAL
- en: singleLineCommands_Timeout()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see the definition of the `singleLineCommands_Timeout` method.
    This section of code explains the power of threading and multiprocessing. We studied
    all the concepts earlier, but in this section, we will see how can we apply the
    concepts of threads and processes to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: The problem at hand is to execute all the categories of commands and scripts
    that can be executed by just firing a single line at the console. These produce
    the output. This might look straightforward, but there is a catch. Remember that
    we discussed occasions in which the execution of a script may take a long time
    for some unforeseen reason and we should design our solution in a manner such
    that we have a timeout associated with all the script categories where this might
    be the case. Here, we will be using threads to implement the timeout functionality.
    A combination of threads and processes will help us achieve our objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'The central idea is to invoke a thread and bind it to a method "x". We call
    `join()` on the thread invoked and the duration of `join()` would be the timeout
    specified in the JSON file. As we studied earlier, the `join()` method, when invoked
    over a thread ''t'', from the main thread ''m'', will cause the main thread ''m''
    to wait until ''t'' finishes its execution. If we invoke join (20) over thread
    ''t'' from the main thread ''m'', this will cause the main thread ''m'' to wait
    for 20 seconds for ''t'' to finish. After 20 seconds, the main thread will continue
    its execution and exit. We can use the same analogy to achieve our task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf96f815-d45b-4934-b60f-b72e6c54bafb.png)'
  prefs: []
  type: TYPE_IMG
- en: In sections **(1)** and **(2)**, we are creating a `thread` object, and the
    method we are attaching to it is `"execute_singleLine"`. It should be noted that
    there are certain occasions where we want to grep out something from the final
    output, which is why we are checking whether the `grep` parameter is set. If it
    is set, we send the `grep` string as an argument to the thread method; otherwise,
    we only send the console script/command that the method is supposed to invoke.
    We don't need to worry about the grep condition for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(3)**, we can see that we are collecting the timeout parameter,
    which is always at index 0 of the commands list or at the 0th index of the args
    from the JSON file. We invoke the start method on the thread, which will invoke
    the `"execute_singleLine"` method and pass the command to be executed as an argument.
    After that, we invoke `join(timeout)`, on the thread invoked, the code will be
    halted there until the duration of seconds specified under timeout. No line after
    section **(3)** will be executed until either the `"execute_singleLine"` method is
    finished or the time exceeds the timeout. Before moving on, let''s take a closer
    look at what is happening within the  `"``execute_singleLine``"` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff0426b-08ff-46f1-bf48-998fd440d39e.png)'
  prefs: []
  type: TYPE_IMG
- en: As specified by section **(1)** of the `"execute_singleLine()"` method, we are
    making use of Python's subprocess module to spawn a child process. The process
    will be specified by the command present in the `"cmd"` variable. Therefore, if
    `cmd` holds "`nmap -Pn --script=banner.nse -p 80 192.168.250.143`", the same command
    will be executed at the terminal, which is nothing but a process at OS level. The
    instance of the process class will be returned and placed under the `self.process` class
    variable. The instance holds various properties such as `"id"`, `"is_alive()"`,
    and so on, which give us information about the state of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are sure of the parameters passed to the process (as they are not coming
    from user directly), we can proceed with it. However, it's a good practice to
    use `shell=False` and specify the arguments as a list `[]`, or, alternatively,
    use the **shelx** utility of Python to convert string arguments automatically
    to a list and use `shell=False`.
  prefs: []
  type: TYPE_NORMAL
- en: We want our parent process to wait until the child process executes and we also
    want the child process to give all the data it produces back to the parent process.
    We can achieve this by invoking `communicate()` on the invoked process. The `communicate()`
    method will return a tuple with a 0th index that contains the output from the
    process and a first index that will have the errors produced. Since we are specifying
    `output=subprocess.PIPE`, and `error=subprocess.PIPE`, both the output and the
    errors will be piped to the parent process via OS pipes, which is how we achieve
    inter-process communication. This is highlighted in section **(2).**
  prefs: []
  type: TYPE_NORMAL
- en: Our next challenge is to convert the console output to a standard ASCII format
    so that we can save the data cleanly in the database. It should be noted that
    different tools and scripts produce data in different formats and encoding that
    would be appropriate for the console to display. The console supports a wide range
    of encoding, but we need to save the output in our database tables, so before
    pushing the data, we need to convert it from console encoding to ASCII format.
    This is what we are doing in section **(3).**
  prefs: []
  type: TYPE_NORMAL
- en: In section **(4)**, we get control of the parent process by invoking `process
    = psutil.Process(self.process.pid).`
  prefs: []
  type: TYPE_NORMAL
- en: In section **(5)**, after we have cleaned the data, we push both of the commands
    that were executed and the data that was generated in the database table by invoking
    the `saveDetails()`method.
  prefs: []
  type: TYPE_NORMAL
- en: After section **(3),** we check whether the thread is still alive by invoking
    `thread.is_alive()`. If it returns `false`, it means that the thread was successfully
    executed within the specified time via internally invoking the `subprocess.Process` command
    and also that the details are saved in the database table. However, if `thread.is_alive()`
    returns `true`, this means that the external script is still running and so we
    would need to forcibly kill it so that it doesn't hamper the execution of the
    other scripts that are lined up to be executed. Remember that the process invoked
    returns us the instance of the process that we saved under the `self.process`
    class variable. We are going to use that variable here in order to kill the process.
    Python has got a very powerful utility called `"psutil"`, which we can use to
    not only kill the process, but also all the child processes invoked by that process.
    We need to kill the child processes as well, because we don't want these to be
    running in the background and consuming our CPU. For example, tools such as Nikto
    invoke many child processes to expedite the whole operation and we would want
    to kill all of them to make sure the parent process is killed and all the system
    resources are released for other processes to use. Once we have fetched the parent
    process, we iterate over each of its child processes using a `for` loop, `for
    proc in process.children(recursive=True):`, and kill each of the child processes
    by issuing the command `proc.kill()`**. **This is highlighted in section **(5).**
    Finally, in section **(6)**, we ensure that we kill the parent process as well
    by invoking `self.process.kill()`.
  prefs: []
  type: TYPE_NORMAL
- en: general_interactive()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to understand how the `general_interactive()`
    method works. Although we could have Metasploit commands implemented with this
    method as well, to keep the separation of categories, we implemented Metasploit
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of `general_interactive` is to automate interactive tools and
    Bash commands. This means that the JSON file contains both success patterns and
    failure patterns, which define the workflow of execution. We will be using Pexpect
    to accommodate this as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fac8b47-a996-4614-84aa-b76504f92684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at this method by carrying out a dry run, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d93bb4e-20d8-43b1-a924-453ff53dd525.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the `args[]`, the first argument is the timeout. The second
    index holds the command that we wish to automate using the general interactive
    method. As always for this category, the first argument will be the `timeout`
    and the second will be the command to be fired. From here on, an alternate pattern
    is defined. The third index will hold the expected output list and the success
    criteria. If the success criteria is met, the fourth index will hold the next
    command to be send to the console. The fifth index will again hold the expected
    output list based upon the command sent in the fourth index, and it also holds
    the success criteria. The pattern is straightforward, and the same alternating
    sequence is carried on as required by the underlying command or tool that we plan
    to automate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The success criteria is defined at the first index of the expected output list.
    If there are multiple success outcomes or indices, they can be given as a comma
    separated input at the first index. Let''s take the above example of `rlogin`,
    where we are trying to do a remote login with root as the username and password,
    and try to understand what the expected output list holds and signifies. The list
    at index 3 holds `[''0,1'',''.* password: .*","[$,#]",".*No route.*"]`**. **Here,
    the 0th index "0,1" defines the success criteria. This means that if the terminal
    expects either `".* password: .*"` or `"[$,#]"`, we assume that the output is
    as expected and therefore we send the next command to the console, which is `"root"`
    in our case. If we get anything other than index 0 or 1, we assume that the tool
    or script is not behaving as expected, and thus abort the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: To configure commands and scripts that belong to this category, the tester needs
    to know how the script executes under both success and failure conditions, and
    formulate the configuration file once. The preceding code is straightforward and
    implements the same logic we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: generalCommands_Tout_Sniff()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea here is similar to how we implemented the `singleLineComamnd()` method
    with the help of threads. Note that the category of the command to be executed
    would either be `interactive` or `"singleLineCommand_Timeout"`, along with a sniffing
    operation. We will create a thread and delegate the sniffing task to it by attaching
    it to the `start_sniffing` method. We will also reuse the methods we created earlier.
    Either we invoke `singleLineCommands_Timeout()` as specified by **(1)**, or `general_interactive()`
    as specified by **(2)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39b5a7b-b670-4897-92de-138e071f5b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In section **(3)** and **(4)**, we check whether the sniffing process is still
    alive, and if it is, then we kill it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We usually use Wireshark to capture all traffic on our interface. Since Wireshark
    is a desktop application, however, in this case, we will use **Tshark**. Tshark
    stands for terminal shark and is the CLI version of Wireshark. The Tshark invocation
    command is specified in section **(2)**, where we specify the port at which we
    want Tshark to sniff traffic. We also specify the host for which traffic needs
    to be sniffed, or the destination host. The reason we specify both the host and
    the port is that we want to maintain result integrity; the GUI version of the
    tool can deployed on the server and multiple users can use it to conduct scanning.
    If we specify that it should sniff on the interface, data from other running sessions
    for other users would also be sniffed. To avoid this, we are very specific with
    host and port. We also specify the timeout duration for it to sniff. We save the
    output in a file specified as `"project_id_host_port_capture-output.pcap"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(2)**, we invoke the `tshark` process with the help of the subprocess
    module, which we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e571c8-2181-4798-8e4c-485f7364060e.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP_based()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `http_based` method is straightforward. We use Python''s request
    library to send a GET request to our target, capture the response, and save it
    in the database. For now, we are just sending a GET request, but you can tweak
    the code to handle both GET and POST in your own time. We will cover more about
    python requests and scraping in the next chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1f98ec6-8bd3-4733-8eba-a9dec6238b73.png)'
  prefs: []
  type: TYPE_IMG
- en: IPexploits.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important code file, which handles the database layer of the service
    scanning engine, is `IPexploits.py`. This file is straightforward; it contains
    various methods and the objective of each method is either to fetch data from
    a database table or to put data in a database table. We won't be discussing this
    module here, but I would recommend that you take a look at the code that can be
    found at the GitHub repository [https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py](https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py).
  prefs: []
  type: TYPE_NORMAL
- en: Executing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before executing the code, refer to the installation and setup instructions
    carefully from the GitHub repository [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    The installation guide also discusses how to set up the backend database and tables.
    Alternatively, you can download the plug and play VM that has everything installed
    and preconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code, go to the following path: `/root/Django_project/Dictator/Dictator_Service`.
    Run the code file `driver_main_class.py` as `:python Driver_scanner.py` It must
    be noted that, the results are generated using a Python library that converts
    the console output into its HTML equivalent. Further details can be found at the
    following code file [https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python](https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python),
    under the `generate_results()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Database schema for the service-scanning portion of the vulnerability scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For service scanning the scan results, go to the IPexploits table, the schema
    of which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/330d9b69-af86-4e96-86d5-d4d3c968b98b.png)'
  prefs: []
  type: TYPE_IMG
- en: GUI version of vulnerability scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same code base discussed previously can be enhanced to develop a web-based
    version of the vulnerability scanner, with both port scanning and service scanning
    capabilities. The tool has many different features, including a four-tier architecture,
    which has a web layer presentation, a web layer server, an API layer, and a DB
    layer. Download and install the web version of the tool from the GitHub repository
    [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    Alternatively, you can use the plug-and-play vm and simply log in and open the
    browser at `https://127.0.0.1:8888` to access the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various features of GUI version of the scanner include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and resuming port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All test case automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and resuming Service scanning **(not in CLI)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel service scanning **(not in CLI)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap report uploading and parsing of Qualys and Nessus reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage [PTO-GUI]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section walks us through the usage of the GUI version of the scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based upon the type and nature of scans being conducted on the underlying infrastructure,
    the pen tester has got multiple options available and may choose the one that
    may fit best with the given infrastructure to be tested. The various modes of
    usage available are covered in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In sequential mode, the tool would start with the discovery followed by reconfiguration
    and then it will start service scanning. Thus, it is a three step process. Note
    that in sequential mode
  prefs: []
  type: TYPE_NORMAL
- en: The service scanning cannot be started until all hosts have been scanned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once service scanning is started, no reconfiguration can be done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning once started, would be started for all services. User has no
    control over which service to scan first and which one to scan last
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d1de7f0a-49fd-4838-bc8b-9988831c945b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reconfiguration after discovery is finished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to reduce false positives and false negatives, kindly analyze port
    scanning results and if required, reconfigure/change them. You may additionally
    add test cases if in case any service/port is left out.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be48f0bc-0324-4267-9356-5722ec6de546.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/b05d1ad9-b8a4-4aab-bc9b-0a19cf078f4e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we are changing service of type **status** to
    type `ftp`. Thus, the test cases would be run for `ftp`. Note: Do it only if you
    are sure that the service discovered is incorrect or of type `Unknown`. We shall
    understand service types shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If nmap misses out host/port/service, it can be added manually as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/676cb125-e46d-41fa-9f82-2aed49201424.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the test case, we can click upon **Start scanning** option to
    begin with service scanning. We can choose to enable threading option for speeding
    up the results, and we can also go and start service scanning without the threading
    option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/881bab84-8099-4e57-b6c7-89dc7dbf2044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Viewing intermediate results: The moment a person clicks upon **Start scanning**,
    he/she would be redirected to the scanning page. Every time a test case is executed,
    the UI would be updated and a blue color icon would appear on the screen in front
    of the service being scanned. A user may click upon that icon to view the test
    case results.'
  prefs: []
  type: TYPE_NORMAL
- en: When all the `test_cases` for a service would be executed then the icon will
    turn green.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows intermediate test case results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d10429a-985d-431a-b473-8368da06b74d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At any point,, a user can leave the UI without impacting the running scan.
    In case the user wishes to see the scans are that currently running, he may choose
    running scans from the **Scanning Status** tab at the top . The following screen
    would be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a388638e-aa90-4bf1-aed4-c3c759ecc6f8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Depending upon the state of the scan, it will display an appropriate action.
    If the scan is under progress, the **Action** column will have action as **Ongoing**. 
    Users may click upon this button to get to the UI screen of the current state
    of his/her scan.
  prefs: []
  type: TYPE_NORMAL
- en: A user can click upon the name of the scan to see the configuration (hosts,
    ports, switch) with which the scan was initially launched.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In sequential mode, the service scanning cannot be started until port scanning
    results are available for all the ports and the hosts are scanned. Thus, a pen
    tester may have to wait to obtain these results. Also, in this mode, the pen tester
    does not have control over which services can be scanned first and which can be
    scanned later. All the services are scanned in one go, limiting the granularity
    of control over service scanning. These are the limitations of the sequential
    mode that is handled by the concurrent mode.
  prefs: []
  type: TYPE_NORMAL
- en: The concurrent mode offers the flexibility to launch service scanning the moment
    service discovery is finished and further gives an option to launch service scanning
    for selective services based upon the pen testers choice.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **New Scan** tab under the **Scan** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the scan parameters and choose the scan mode as **Concurrent**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7ceb7a8-e9ed-4348-9ac1-c1d080a592e9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The remaining steps will be the same, with the only exception being that in
    this mode of scan, a user will not have to wait for all hosts and ports to be
    scanned to begin with service scanning. Also, the user can choose what services
    he may wish to scan. This is illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a66c7363-483b-4e59-8cb4-2693bb49781e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, a user can choose to scan `http`
    first and not scan ssh immediately. The user can decide when to scan what service.
  prefs: []
  type: TYPE_NORMAL
- en: All the capabilities (reconfiguration, viewing results and so on) are available
    with the concurrent mode as well.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential default mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this mode, the service scanning would start immediately after discovery
    is finished, thus skipping the reconfiguration phase. The utility of this mode
    is more relevant in case of scheduling scans where the pen tester may schedule
    scans to start at some other time and may not be available to do the reconfiguration
    while simultaneously wanting to proceed with default port scanning results for
    service scanning. Thus, this scan mode skips the reconfiguration phase and directly
    launches service scanning on obtaining default `nmap` port scanning results.
  prefs: []
  type: TYPE_NORMAL
- en: Click upon **New scan** tab under the **Scan** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the scan parameters and choose the scan mode as **Sequential Default**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e095c26-7b94-439c-966d-6b2b8a12dc1f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When port scanning results are done, it will start service scanning by itself,
    irrespective of whether the user is currently logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and resuming scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of the scan mode, any scan weather in the discovery or service
    scanning state can be paused. The intermediate results would be saved, and the
    user can resume the scan anytime in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It must be noted that if the scan is paused while discovery (port scanning would
    have been going on), then the port scanning results for the ports that have already
    been scanned would be saved; the scan would start for unscanned ports once the
    user resumes. Likewise, if the scan is paused during service scanning, then whatever
    services would have been scanned, their results would be saved, and the user gets
    the flexibility to analyze the results of the services that would be scanned.
    When the scan resumes, the service scanning will start for unscanned services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen shots show how to pause an ongoing scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85ec9f7-aecf-4e07-b8eb-fd8ee0b2dc63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to resume the scan, either go to the **Current scans** tab or go to
    the **Paused scans** tab. The action column by default would have two buttons
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resume**: This will resume the scan from whatever state it was paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze**: If the scan is paused while scanning, then the penetration tester
    may analyze the results for the services that were already scanned. If you wish
    to resume the scan, then he/she may choose the option analyze. With this the user
    can get to see intermediate test case results for completed services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze option may not appear if the scan would be paused during port scanning,
    as there would be no `test_cases` executed to analyze if port scanning would be
    going and mode would not be concurrent. **Analyze** option does not appear for
    concurrent scans, the **Resume** button will perform that joint functionality
    of resuming and analyzing the scans invoked in concurrent mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1746627a-0a38-4ff6-bd94-4d17adbd9538.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading reports or analyzing when scan would be completed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the scan would be finished, the user will get the option **Download All**
    on the UI. If the user would visit the **Current scans** tab, for all the scans
    with status as **Complete** for both discovery and service scanning, the **Action**
    column will by default have an option to download the results for offline analysis
    or to analyze the results online itself as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45cb5b5b-e634-4eb1-83df-a1c473c50050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking **Download All**, a zipped folder would be downloaded. It will
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: The final HTML report containing all test case results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pcap files which would sniff certain services where sniffing is required. The
    Pcap files can be opened with Wireshark and analyzed weather the text/credentials
    are passed as plain text or in encrypted format. Note: The name of the Pcap file
    would be like `<project_id>_capture_output.pcap`. Thus if sniffing is done on
    `host1` for port `21` and project ID `100`, the Pcap file name would be `100_host1_21_capture_output.pcap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downloaded folder will also have the final chosen configuration (Services
    -Test cases) with which the scan was launched. (JSON format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand clicking upon **Analyze tests** will take us to UI where we
    can see the results of all `test_cases` on the user interface only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To upload Nmap report, go to **Upload Reports** and choose Nmap report. Its
    a result importer module, which can read the results from an existing `Nmap.xml`
    report file and can import the findings in our custom database, and further use
    these findings in order to launch test cases/service scan. Thus, this leaves the
    user with the flexibility to use our tool in both modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovery and service scanning together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning mode alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4c6d5b56-57cf-432b-b886-c535305a0e6f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/a18ad171-8f38-4d72-831a-51f19028cc01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On clicking on **Upload**, the report will be parsed and uploaded. A user may
    go to **Current scans** tab and would find the uploaded project `test_upload_nmap` listed
    over there, with its **Discovery status** as **Complete** and **Service scanning**
    status as **Incomplete**. A user may click upon **Action** tab **Ongoing** and
    can reconfigure the results and then start service scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Qualys and Nessus report parsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this option, go to **Upload reports** tab and select either **Qualys**/**Nessus**
    report. We have a report merging module, which would merge the results obtained
    from Qualys, Nessus and manual test cases. In order to merge the reports, they
    have to be parsed first. We have Qualys, Nmap and Nessus report parsers. All of
    them will take a report in XML format and would parse the report and place it
    in local storage so that querying and integrating the results with other reports
    becomes easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46df89e3-7ade-4543-bf82-9b8c604d177e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The purpose of uploading the report here is to merge it with some manual project.
    Thus select the project from drop-down list with which a user may wish to merge
    the Nessus/Qualys report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Report merger:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use this option go to **Merge reports** tab and select the **ID**/**Name**
    of the manual project with which you wish to integrate the Qualys and Nessus results.
  prefs: []
  type: TYPE_NORMAL
- en: It assumes that the Nessus and Qualys reports would have already been uploaded
    and linked to the project with which they are meant to be merged .
  prefs: []
  type: TYPE_NORMAL
- en: This module merges the manual test cases, parsed Qualys report, parsed Nessus
    report and would also map the CVEs to exploits and finally, would provide the
    user an option to download the integrated reports in any of the format among (XML,
    HTML, CSV, JSON) thus providing one consolidated view for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34d668d7-9fa8-4f84-b7c1-01476bfd893a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/f393784d-9279-4b0a-ab86-b6ae5119e0bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final downloadable report is available in four formats (HTML, CSV, JSON,
    XML).
  prefs: []
  type: TYPE_NORMAL
- en: The merged report will do the merging based upon common results found in Nessus/Qualys
    and manual test_cases. It will cluster the common host and port into one group
    in such a way that analysis becomes easier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to use various Python modules to achieve
    the task of service- scanning automation. We also studied how we can use a combination
    of threading and multiprocessing to solve real-world problems. All the concepts
    discussed in this chapter were mentioned by and large in the previous chapters.
    By the end of this chapter, the reader should have a good understanding of how
    powerful Python can be in the cyber security domain, and how can we use it to
    make a scanner of our own. We also looked at an overview of the vulnerability
    scanner in GUI mode.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can use machine learning and Natural
    language processing to automate the manual report analysis phase of penetration
    testing phase.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we not use msfrpc to automate Metasploit ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we possibly do to further optmize the throughput?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it mandatory to use the JSON file? Can we use a database instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other tools can we integrate with the scanner?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python-nmap 0.6.1: [https://pypi.org/project/python-nmap/](https://pypi.org/project/python-nmap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nmap from Python: [https://xael.org/pages/python-nmap-en.html](https://xael.org/pages/python-nmap-en.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON encoder and decoder: [https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
