- en: Vulnerability Scanner Python - Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk of service scanning using open source scripts, the first thing
    that comes to mind is making use of various NSE scripts to get the service versions
    and associated vulnerabilities with the configured services. Now, in a typical
    manual network penetration test, we not only make use of NSE scripts to get the
    job done, we also use various Ruby, Perl, and Bash scripts, and Java class files.
    We also run Metasploit auxiliary modules for service scanning and exploit modules
    to exploit vulnerabilities and to create a POC. We may also run various Kali tools,
    such as Nikto for web scanning, or SQLmap, w3af, and Wireshark to capture clear-text
    usernames and passwords for improperly configured FTP or SSH services. All of
    these tools and scripts produce a huge information pool that a tester needs to
    enumerate manually and consolidate. False positives must also be eliminated to
    arrive to a conclusion as to which services possess which vulnerabilities. The
    other aspect of manual service scanning is that it lacks standardization and relies
    more on an individual's expertise and the choice of scripts used. It is important
    to bear in mind that the scripts to be used are mostly disintegrated from one
    another such that a person has to follow a sequential approach to run all the
    desired scripts and modules. We can achieve limited parallelism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how our vulnerability scanner can automate all
    of these activities and bring standardization to the whole ecosystem. We will
    also see how the automated scanner invokes and orchestrates all the amazing tools
    that Kali has to produce an integrated report for the penetration tester to walk
    through, giving them a consolidated view that can be used for quick analysis.
    We will also study the GUI version of the vulnerability scanner, which has more
    advanced features and complements existing vulnerability scanners such as Nessus.
    It must be noted that when I use the word *complements*, by no means am I comparing
    our scanner with Nessus or Qualys. They are both excellent commercial products
    that have evolved over years of R&D, and have some excellent engineers working
    on them. However, we will build something that works amazingly well; knowing the
    code gives you an opportunity to contribute to the scanner, which in turn helps
    to make it better and bigger over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Architectural overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already taken a look at the architecture of the scanner in Chapter
    5, *Vulnerability Scanner Python - Part 1*. Lets revisit the service-scanning
    part of the scanner and think about how the whole ecosystem works. The following
    diagram shows the service scanning architecture for us:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c2cb8c-65e4-43cf-9b06-f7c6d48a5ff2.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: A project ID would be associated with all scans that have been completed with
    Nmap port scanning. The user can select the project ID for which they want to
    carry out service scanning and can also see all the project IDs for which port
    scanning has successfully completed. It should be noted that only the project
    IDs for projects that have been completed will be displayed; projects for which
    the port scanning has been paused would not be displayed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Once the project ID has been selected, the code reads the database table `IPtable_history` to
    display open ports and the default configuration, which refers to the open ports
    and the associated scripts (depending on the service name). The user can reconfigure
    the scan results, including manually adding any open ports that have been missed
    or removing any entries for which ports displayed as open aren't actually accessible.
    Once the user has reconfigured the results, we are all set to run a service scan.
    It should be noted that the reconfiguration step can be skipped if the user finds
    the port-scanning results to be all right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: When the scanning activity is over, we will save all the results in our MySQL
    database table. In case of service scanning, depending upon the service discovered,
    we will get a configured list of scripts that we need to execute if a specific
    service is found. We use a JSON file to map the service and corresponding scripts
    to execute.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描活动结束后，我们将把所有结果保存在我们的MySQL数据库表中。在服务扫描的情况下，根据发现的服务，我们将得到一个配置好的脚本列表，如果找到特定的服务，我们需要执行这些脚本。我们使用一个JSON文件来映射服务和相应的要执行的脚本。
- en: 'In case of port scanning, a user is prompted with the port-scanning results
    and is given an option to reconfigure the results if needed (to reduce false positives).
    Once the final configuration is set, service scanning is started. The logic is
    to pick one host at a time from the database and, based on the services discovered,
    read the appropriate scripts from the JSON file and execute them for that particular
    host. Finally, after the script is executed, the results should be saved in the
    database. This continues until all the hosts are scanned for their services. Finally,
    an HTML report is produced that contains the formatted results and also contains
    screenshots for the POC to be attached. The following screenshot depicts how the
    JSON file is configured to execute the scripts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口扫描的情况下，用户将收到端口扫描结果，并有选择重新配置结果（以减少误报）。最终配置设置后，将开始服务扫描。逻辑是从数据库中逐个选择一个主机，并根据发现的服务，从JSON文件中读取适当的脚本，并为该特定主机执行它们。最后，在执行脚本后，结果应保存在数据库中。这将持续到所有主机都扫描其服务为止。最后，将生成一个包含格式化结果和POC截图的HTML报告。以下截图显示了如何配置JSON文件以执行脚本：
- en: '![](img/14b16790-646d-4621-b88b-a1d1e4acc5b4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14b16790-646d-4621-b88b-a1d1e4acc5b4.png)'
- en: 'As can be seen from the preceding screenshot, there are various categories
    of commands that are placed in the JSON file. The Metasploit template contains
    the commands that are meant to execute the Metasploit modules. Single-line commands
    are used to execute NSE scripts and all modules and scripts that are not interactive
    and that can be fired with a single command. The other categories include `interactive_commands` and `single_line_sniffing`
    (where we need to sniff the traffic along with executing the scripts). The general
    template of the JSON file looks as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，JSON文件中包含各种类别的命令。Metasploit模板包含用于执行Metasploit模块的命令。单行命令用于执行NSE脚本以及所有非交互式的模块和脚本，可以用单个命令触发。其他类别包括“interactive_commands”和“single_line_sniffing”（需要在执行脚本的同时嗅探流量）。JSON文件的一般模板如下：
- en: '![](img/61f06b62-c5e6-4ed3-ad34-75242f926e11.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f06b62-c5e6-4ed3-ad34-75242f926e11.png)'
- en: The **key** is the name of the service. The title contains a description of
    the file. `method_id` is the actual Python method that should be invoked to call
    the external script to be executed. Note that for single-line commands, we also
    specify a `timeout` parameter in seconds as the first argument under the `args`
    parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**是服务的名称。标题包含文件的描述。`method_id`是应调用的实际Python方法，以调用要执行的外部脚本。请注意，对于单行命令，我们还在`args`参数下的第一个参数中指定了一个`timeout`参数，单位为秒。'
- en: A closer look at the code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的更详细查看
- en: It should be noted that the whole code base can be found at GitHub [https://github.com/FurqanKhan1/Dictator](https://github.com/FurqanKhan1/Dictator).
    We will be taking a look at all the essential code files that form the central
    piece of logic for our service scanner. Alternatively, I have created a plug-and-play
    Kali VM image that contains all the prerequisite installations and the codebase
    out of the box. This can be download and executed hassle-free from the following
    URL [https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing](https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing). The
    default username is `PTO_root` and the password is `PTO_root`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到整个代码库可以在GitHub上找到[https://github.com/FurqanKhan1/Dictator](https://github.com/FurqanKhan1/Dictator)。我们将查看所有构成服务扫描器核心逻辑的基本代码文件。或者，我创建了一个即插即用的Kali
    VM镜像，其中包含所有必需的安装和开箱即用的代码库。可以从以下URL[https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing](https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing)下载并无忧地执行。默认用户名是`PTO_root`，密码是`PTO_root`。
- en: Let's look at an overview of the essential files and methods that we will use
    to build our service- scanning engine, using Python.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概览一下我们将使用的基本文件和方法，来构建我们的服务扫描引擎，使用Python。
- en: Driver_scanner.py
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Driver_scanner.py
- en: 'After port scanning is over, the next step is to perform service scanning.
    This Python class invokes another class, `driver_meta.py`, which takes the project
    name/ID for which service scanning is to be performed, as shown in the following
    code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描结束后，下一步是执行服务扫描。这个Python类调用另一个类`driver_meta.py`，它接受要执行服务扫描的项目名称/ID，如下面的代码片段所示：
- en: '![](img/85fbab57-78e3-484a-8485-0046530ff0e1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85fbab57-78e3-484a-8485-0046530ff0e1.png)'
- en: driver_meta.py
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: driver_meta.py
- en: 'This class displays the default result of port scanning and gives user the
    option to reconfigure the results if needed. After reconfiguration, this class
    reads the hosts from the database table for the project for which service scanning
    is to be done. For each host, it then reads the JSON file to get the commands
    to be executed, and for each command to be executed, it passes on the control
    to another file `auto_comamnds.py`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类显示了端口扫描的默认结果，并给用户重新配置结果的选项。重新配置后，这个类从数据库表中读取要执行服务扫描的项目的主机。对于每个主机，它然后从JSON文件中读取要执行的命令，对于要执行的每个命令，它将控制传递给另一个文件`auto_comamnds.py`：
- en: '![](img/681da31c-9d55-4caf-8b07-493e0d90a3cf.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/681da31c-9d55-4caf-8b07-493e0d90a3cf.png)'
- en: The preceding class represents the main parent class for this Python module.
    As we can see, we have imported various other Python modules such as JSON, SYS,
    and psutil to be used with this class. We can also see that we have used other
    classes such as `auto_commands`, `Auto_logger`, `IPexploits`, and `IPtable` with
    this module. These are not in-built Python modules but our own classes that perform
    different functionalities for our service-scanning engine. We will discuss these
    in greater detail later on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the `main()` method of this class, from where the execution
    cycle actually starts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method is the same piece of code that is used with both the CLI
    version and the GUI version of the code, so there are many parameters that would
    only be relevant when invoked with the GUI mode. We will discuss those that are
    needed in CLI mode in this section. We can see that the `mode` variable is initialized
    to `c` inside the definition of the `main()` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the section highlighted as **(1)** in the following screenshot, we initialize
    an object for the `texttable()` Python module, which will be used to draw a table
    on the console window to display the project IDs for which service scanning can
    be performed. The second section collects all the completed projects from the
    database and section **(3)** adds the retrieved rows to the program variable to
    be displayed on the screen. The subsequent code is straightforward. At section **(4)**,
    the functionality actually removes the earlier details of a project for which
    service scanning would have been completed already, so that the user can overwrite
    the results with a new service-scanning operation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff8386f7-82c6-4c0e-84eb-68faf33667f5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Section **(5)** creates a directory called `<project_id>` under the `results` folder.
    For example, if the current project ID is `744`, the command `init_project_directory()`,
    will create a sub folder under `<parent_folder_code_base>/results/<744_data>`.
    All the log files, the scan configuration, and the final report will be placed
    in this folder. As we have already discussed, we have a preconfigured JSON file
    that contains a mapping between the service name and the test cases to be executed
    against that service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections shows how the JSON file is configured. Let''s take an
    example of an `http` service and see how the test cases are configured to be executed
    against the HTTP service:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cd0d5fc-1e43-4e3a-adb4-2979fd3bdd44.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: '![](img/2dfa78c5-7d56-4f00-9816-a31c2b49b049.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: '![](img/540f9725-5a06-4615-a521-68e986493403.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: '![](img/506435b2-4e03-4bd1-a5fe-807439c928fd.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: '![](img/81302c92-bbc5-49eb-ade6-91118d91c197.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '![](img/21bb1a31-9f5b-4e24-880b-b84f899b0ce9.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen and classified from the preceding bifurcation, all the test
    cases for the service called `http` will be placed in a JSON list with the key
    as `Commands`. Each entry within the `Commands` list would be a JSON dictionary
    that has the following entries:`{"args":[],"id":"","method":"","include":"","title":""}`.
    Each dictionary formulates one test case to be executed. Let''s try to understand
    each of the entries:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`args`: The `args` parameter is actually a list that contains the actual commands
    and NSE scripts to be executed against a target. All the commands/scripts that
    are to be executed are classified into five different categories that we will
    see in the method section. For now, it is enough to understand that args contain
    the actual commands to be executed on the Kali console with Python.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: Each command to be executed is given a unique ID, which makes the enumeration
    easy. For all HTTP-based commands, we can see the IDs are `http_1`, `http_2`,
    `http_3`, and so on.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This particular entry is very important, as it refers to an actual
    Python method that should be invoked to execute this testcase. The methods are
    placed inside a Python file/module `auto_commands.py` and this class has different
    methods mapped to the JSON file. Generally, all the scripts to be executed are
    broken into five classes/categories, and each category has a corresponding method
    associated with it. The categories of scripts and their corresponding methods
    are as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 这个特定的条目非常重要，因为它指的是应该调用的实际 Python 方法来执行这个测试用例。这些方法位于一个名为 `auto_commands.py`
    的 Python 文件/模块中，该类别有不同的方法与 JSON 文件进行了映射。通常，要执行的所有脚本被分成五类/类别，并且每个类别都有一个相应的方法与之关联。脚本的类别及其相应的方法如下：'
- en: '`Single_line_comamnds_timeout`: All the commands/scripts that require a one
    time invocation and that produce the output for you, without requiring any interaction
    in between, fall under this classification. For example, an NSE script can be
    executed as follows: `nmap -p80 --script <scriptname.nse> 10.0.2.15`; it would
    not require any other input and would just execute and give us the final output.
    Alternatively, a Perl script to perform directory enumeration can be invoked as
    follows: `perl http-dir-enum.pl http://10.0.2.15:8000`.Likewise, all the Python
    scripts, Bash commands, and Kali tools, such as Nikto or Hoppy, will fall under
    this category. All such scripts are handled by a Python method, `singleLineCommands_timeout()`,
    placed inside the `auto_comamnds.py` module. It should be noticed that all such
    scripts also need an additional `timeout` parameter. There are occasions when
    a single script hangs for some reasons (the host might be unresponsive, or it
    might encounter an unforeseen condition for which it was not tested), and the
    hanging of the script will cause the other scripts in the queue to be in the waiting
    state. To get around this condition, we specify a threshold parameter as the first
    argument in the `args[]` list, which is the maximum time in seconds for which
    we want the script to be executed. This is why, from the previous configuration,
    we can see that `500` seconds is specified as a timeout for the NSE script whose
    ID is `http_5`. If the script is not executed within `500` seconds, the operation
    is aborted and the next script in the queue is executed.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single_line_comamnds_timeout`: 所有需要一次性调用并为您生成输出的命令/脚本，而不需要在其间进行任何交互的命令/脚本都属于这一分类。例如，可以执行一个
    NSE 脚本，命令如下：`nmap -p80 --script <scriptname.nse> 10.0.2.15`；它不需要任何其他输入，只需执行并给出最终输出。或者，可以如下调用一个用于执行目录枚举的
    Perl 脚本：`perl http-dir-enum.pl http://10.0.2.15:8000`。同样，所有 Python 脚本、Bash 命令和
    Kali 工具，如 Nikto 或 Hoppy，都属于这一类别。所有这些脚本都由一个名为 `singleLineCommands_timeout()` 的
    Python 方法处理，该方法位于 `auto_comamnds.py` 模块中。需要注意的是，所有这些脚本还需要一个额外的 `timeout` 参数。有时单个脚本由于某些原因而挂起（主机可能无响应，或者可能遇到未经测试的意外情况），脚本的挂起将导致队列中的其他脚本处于等待状态。为了解决这种情况，我们在
    `args[]` 列表中指定一个阈值参数作为第一个参数，这是我们希望脚本执行的最长时间（以秒为单位）。因此，从先前的配置中，我们可以看到为 ID 为 `http_5`
    的 NSE 脚本指定了 `500` 秒的超时时间。如果脚本在 `500` 秒内未执行完毕，操作将被中止，并执行队列中的下一个脚本。'
- en: '`General_interactive`: Apart from scripts that require a single-line command
    to be fired and executed, we also have other Bash commands, Kali tools, and open
    source scrips that require some interaction after being fired. A typical example
    would be to SSH to a remote server, where we usually pass two sets of commands.
    This can be done in a single shot, but, just for the sake of understanding, let''s
    take the following example:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`General_interactive`: 除了需要执行单行命令并执行的脚本外，我们还有其他需要在执行后进行一些交互的 Bash 命令、Kali 工具和开源脚本。一个典型的例子是
    SSH 到远程服务器，通常我们需要传递两组命令。这可以一次完成，但为了更好地理解，让我们举个例子：'
- en: '`ssh root@192.168.250.143 [Command 1]`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh root@192.168.250.143 [Command 1]`'
- en: '`password:<my_password> [Command 2]`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password:<my_password> [Command 2]`'
- en: Another example could be tools such as SQLmap, or w3af_console, where some amount
    of user interaction is needed. Note that with this automation/scanning engine,
    we would have a workaround by which scripts would be automatically invoked and
    executed with Python. All scripts or testcases that require interaction are handled
    by a method called `general_interactive()`, which is placed under the Python module
    `auto_comamnds.py`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是工具，如 SQLmap 或 w3af_console，需要一定程度的用户交互。请注意，通过这种自动化/扫描引擎，我们可以通过自动调用 Python
    来解决脚本的问题。所有需要交互的脚本或测试用例都由一个名为 `general_interactive()` 的方法处理，该方法位于 Python 模块 `auto_comamnds.py`
    中。
- en: '`General_commands_timeout_sniff`: There are many occasions in which we need
    to execute a script or a bash command and at the same time we want Wireshark to
    sniff the traffic at the interface so that we can find out if the credentials
    are being passed in cleartext or not. During the execution of scripts in this
    category, the traffic must be sniffed as well. They can either be single-line
    scripts such NSE or interactive commands such as `ssh root@<target_ip>` as the
    first command and `password:<my_password>` as the second. All scripts that need
    this kind of invocation are handled by the Python method `generalCommands_Tout_Sniff()`, which
    is again present in the `auto_comamnds.py` module.'
  id: totrans-46
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`General_commands_timeout_sniff`: 有许多情况下，我们需要执行一个脚本或一个 Bash 命令，同时我们希望 Wireshark
    在接口上嗅探流量，以便我们可以找出凭据是否以明文传递。在执行此类别中的脚本时，流量必须被嗅探。它们可以是单行脚本，如 NSE，也可以是交互式命令，如 `ssh
    root@<target_ip>` 作为第一个命令，`password:<my_password>` 作为第二个命令。所有需要这种调用的脚本都由 Python
    方法 `generalCommands_Tout_Sniff()` 处理，该方法同样位于 `auto_comamnds.py` 模块中。'
- en: '`Metasploit_Modules`: This is the category that will execute and handle all
    the Metasploit modules. Whenever we are required to execute any Metasploit module,
    that module (be it auxiliary or exploit) will be placed inside this classification.
    The method to which the execution is delegated, which is called `custom_meta()`, is
    placed under `auto_commands.py`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit_Modules：这是执行和处理所有Metasploit模块的类别。每当我们需要执行任何Metasploit模块时，该模块（无论是辅助还是利用）都将放置在此分类中。执行委托的方法称为`custom_meta()`，放置在`auto_commands.py`下。
- en: '`HTTP_BASED`: The final category contains all test cases that require an HTTP
    GET/POST request to be posted on the target to be tested, and such cases are handled
    by a method called`http_based()`, which is again placed in the `auto_commands.py` module.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_BASED`：最终类别包含所有需要在目标上发布HTTP GET/POST请求进行测试的测试用例，并且这些情况由名为`http_based()`的方法处理，该方法再次放置在`auto_commands.py`模块中。'
- en: '`include`**: **The `include` parameter takes two values: `True` and `False`)
    If we don''t wish the test case/script to be included in the list of testcases
    to be executed, we can set `include=False`. This feature is very useful when choosing
    scan profiles. There are certain occasions where we don''t want to run time consuming
    testcases such as Nikto or Hoppy on our target and prefer to run only certain
    mandatory checks or scripts. To have that capability the include parameter is
    introduced. We will discuss this further when we look at scan profiles with the
    GUI version of our scanner.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`**: **`include`参数有两个值：`True`和`False`）如果我们不希望将测试用例/脚本包含在要执行的测试用例列表中，我们可以设置`include=False`。在选择扫描配置文件时，此功能非常有用。有时我们不希望在目标上运行耗时的测试用例，例如Nikto或Hoppy，并且更喜欢仅运行某些强制性检查或脚本。为了具有该功能，引入了包含参数。我们将在查看我们的扫描仪的GUI版本时进一步讨论这一点。'
- en: '`title`: This is an informative field, which gives information about the underlying
    script to be executed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个信息字段，提供有关要执行的基础脚本的信息。'
- en: Now that we have a good understanding of the JSON file that will be loaded into
    our `self.commandsJSON` `class variable`, let's move ahead with our code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对将加载到我们的`self.commandsJSON`类变量中的JSON文件有了很好的理解，让我们继续进行我们的代码。
- en: 'The section highlighted as **(6)** reads that JSON file in our `all_config_file`` program
    variable`, which eventually goes to the `self.commandsJSON` class variable. The
    sections of code highlighted as **(7), (8)** and **(9)** load the scan profile
    to be used with the scan:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分**(6)**读取我们的`all_config_file`程序变量中的JSON文件，最终进入`self.commandsJSON`类变量。突出显示的代码部分**(7)，(8)**和**(9)**加载要与扫描一起使用的扫描配置文件：
- en: '![](img/713e7e4b-8050-48d1-9fca-5c71b6923f2f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/713e7e4b-8050-48d1-9fca-5c71b6923f2f.png)'
- en: By default, the scan-profile with the command-line version of our code is **mandatory
    profile**. This profile by and large contains all the testcases that should be
    executed against the target; it just removes a few time-consuming ones. However,
    if we wish to change the definition of `mandatory_profile`, to add subtract test
    cases, we can edit the `mandatory.json` file, which lies at the same path as our
    code file, `driver_meta.py`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的代码的命令行版本的扫描配置文件是**强制性配置文件**。该配置文件基本上包含应针对目标执行的所有测试用例；它只删除了一些耗时的测试用例。但是，如果我们希望更改`mandatory_profile`的定义，以添加或减去测试用例，我们可以编辑`mandatory.json`文件，该文件位于与我们的代码文件`driver_meta.py`相同的路径上。
- en: 'The following are the entries present in the `mandatory.json` file for the
    `http` service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`mandatory.json`文件中为`http`服务存在的条目：
- en: '![](img/69c995fb-6104-47de-8833-c685ade1fb02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c995fb-6104-47de-8833-c685ade1fb02.png)'
- en: 'The section highlighted as (9) will load all the results obtained from the
    port scanning of the project ID `744` for our example. The results are saved inside
    the database table `IPtable_history` and the following screenshot gives us an
    idea of which records will be loaded:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分(9)将加载项目ID`744`的端口扫描获得的所有结果，结果将保存在数据库表`IPtable_history`中，以下屏幕截图给出了将加载的记录的想法：
- en: '![](img/8817ae65-958f-4a75-bfb8-2f7516511948.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8817ae65-958f-4a75-bfb8-2f7516511948.png)'
- en: We can see from the preceding screenshot that there are basically three records
    that correspond to our scan with the ID `744`. The schema of the table columns
    is `(record_id,IP,port_range,status,project_id,Services_detected[CSV_format])`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的屏幕截图中看到，基本上有三条记录对应于我们的ID`744`的扫描。表列的模式是`(record_id,IP,port_range,status,project_id,Services_detected[CSV_format])`。
- en: 'The actual query executed at the backend is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 后端执行的实际查询如下：
- en: '![](img/ab761712-4d83-40b8-99ca-4967034874ad.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab761712-4d83-40b8-99ca-4967034874ad.png)'
- en: The returned result would be a list of lists that can be iterated over. The
    0th index of the first inner list will contain the services detected loaded in
    CSV. The format would be `(host;protocol;port;name;state;product;extrainfo;reason;version;config;cpe)`,
    as can be verified from the preceding screenshot. All this information will be
    placed inside a `results_` list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果将是一个可以迭代的列表。第一个内部列表的第0个索引将包含以CSV格式加载的检测到的服务。格式将是`(主机;协议;端口;名称;状态;产品;额外信息;原因;版本;配置;cpe)`，可以从前面的屏幕截图中验证。所有这些信息将放在`results_`列表中。
- en: 'In section **(10)**, as shown in the folliwng snippet, we are iterating over
    the `results_` list and splitting the string data over the new line `\n`. We are
    further splitting the returned list over `;`, and finally placing all the results
    under a list, `lst1 []`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(10)**部分中，如下片段所示，我们正在遍历`results_`列表，并将字符串数据拆分为新行`\n`。我们进一步将返回的列表拆分为`；`，最后将所有结果放在一个列表`lst1
    []`中：
- en: '![](img/468fa19f-5549-44a3-b1f2-8cfbea3e15b6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/468fa19f-5549-44a3-b1f2-8cfbea3e15b6.png)'
- en: 'For the current example, after section (11), `lst1` will contain the following
    data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前示例，在第(11)部分之后，`lst1`将包含以下数据：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Thus, `lst1[0][0]` will give us `10.0.2.15`, `lst1[2][2]=111` and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`lst1[0][0]`将给我们`10.0.2.15`，`lst1[2][2]=111`等等。
- en: 'In section **(12)** of the code, we are sorting the data in `lst1` by the service
    type. We have declared a dictionary, `lst={}`, and we want to group all the hosts
    and ports according to their type of service, such that the output of section
    **(12)**, **(13)** would be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第**(12)**节中，我们正在按服务类型对`lst1`中的数据进行排序。我们声明了一个字典`lst={}`，并希望根据它们的服务类型对所有主机和端口进行分组，以便第**(12)**，**(13)**节的输出如下：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In section **(15)**, `ss = set(lst_temp).intersection(set(lst_pre))`, we are
    doing a set intersection between two structures that contain dictionary keys.
    One structure contains keys from the dictionary `lst`, which in turn contains
    all the services that our port scanner discovered. The other contains keys that
    are loaded from the preconfigured JSON file.The objective of this is for us to
    see all the discovered services for which test cases are mapped. All the discovered
    and mapped service keys/names go in the list **SS**, which stands for services
    to be scanned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**（15）**节中，`ss = set(lst_temp).intersection(set(lst_pre))`，我们对包含字典键的两个结构进行了交集运算。一个结构包含来自字典`lst`的键，该字典包含我们的端口扫描程序发现的所有服务。另一个包含从预配置的JSON文件中加载的键。这样做的目的是让我们看到所有已映射测试用例的发现服务。所有已发现和映射的服务键/名称都放在列表**SS**中，代表要扫描的服务。
- en: In section **(16)**, `ms=list(set(lst_temp) - set(lst_pre))`, we are comparing
    the services that are not configured in the JSON file against the services discovered.
    Our JSON file is quite exhaustive in terms of commonly found services, but there
    are still cases in which Nmap might find a service during port scanning that is
    not preconfigured in our JSON file. In this section, we are trying to identify
    the services that Nmap has discovered but that do not have testcases mapped against
    them in our JSON file. To do this, we are doing a set difference between the two
    structures. We will tag those services as `new`, and the user can either configure
    testcases against them or analyze them offline to execute custom testcases. All
    these services will be placed in a list called `ms`, where **ms** stands for **missed
    services**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**（16）**节中，`ms=list(set(lst_temp) - set(lst_pre))`，我们正在比较未在JSON文件中配置的服务与发现的服务。我们的JSON文件在常见服务方面非常详尽，但仍然有时Nmap可能会在端口扫描期间发现未在JSON文件中预先配置的服务。在本节中，我们试图识别Nmap发现但在我们的JSON文件中没有针对它们映射测试用例的服务。为此，我们对这两种结构进行了集合差异。我们将标记这些服务为`new`，用户可以对其进行配置测试用例，或者离线分析以执行自定义测试用例。所有这些服务将被放在一个名为`ms`的列表中，其中**ms**代表**未发现的服务**。
- en: 'In sections **(17) and (18)** as shown in the following code snippet, we are
    again restructuring the two missed and mapped services in two different dictionaries
    in the format mentioned earlier: `{"ssh":[[10.0.2.15,22,open,OpenSSH-7.2p2 Debian
    5;10]],...}`. The discovered services will be placed in the `dic` dictionary and
    then into the `self.processed_services` class variable. The missed ones will be
    placed into `ms_dic` and finally into `self.missed_services`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中显示的第**(17)**和**(18)**节中，我们再次将两个未发现和映射的服务重新构建为两个不同的字典，格式如前所述：`{"ssh":[[10.0.2.15,22,open,OpenSSH-7.2p2
    Debian 5;10]],...}`。发现的服务将放在`dic`字典中，然后放入`self.processed_services`类变量中。未发现的服务将放入`ms_dic`，最终放入`self.missed_services`中。
- en: '![](img/fb45071f-0a2e-464b-92e3-afcd94dc1f62.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb45071f-0a2e-464b-92e3-afcd94dc1f62.png)'
- en: Finally, under section **(19)**, we are invoking the `parse_and_process()` method, which
    will invoke the logic of displaying the discovered and missed services and will
    give the user the option to perform any reconfiguration if needed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第**（19）**节中，我们调用`parse_and_process()`方法，该方法将调用显示发现和未发现服务的逻辑，并为用户提供必要时执行任何重新配置的选项。
- en: After reconfiguration is done, `parse_and_process()` will invoke another method, `launchExploits()`,
    which will actually read the `method_name` from the JSON configuration file, replace
    the `<host>` and `<port>` with the appropriate host IP and port discovered, and
    pass the control to the relevant method (based upon the `method_name` read) of
    the `auto_command.py` module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重新配置完成后，`parse_and_process()`将调用另一个方法`launchExploits()`，该方法将实际从JSON配置文件中读取`method_name`，用发现的适当主机IP和端口替换`<host>`和`<port>`，并将控制传递给`auto_command.py`模块的相关方法（根据读取的`method_name`）。
- en: 'Once all the testcases are executed for all the discovered hosts and ports,
    it''s time to generate a report with screenshots and relevant data. This is the
    portion that is handled by sections **(20)** and **(21)**, as shown in the following
    snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对所有发现的主机和端口执行了所有测试用例，就该生成包含屏幕截图和相关数据的报告了。这部分由第**(20)**和**(21)**节处理，如下面的代码片段所示：
- en: '![](img/de832afc-89f4-4334-bb8a-f0b530f0e418.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de832afc-89f4-4334-bb8a-f0b530f0e418.png)'
- en: parse_and_process()
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析和处理()
- en: In the following section, we are going to understand how the `parse_and_process()`
    method works. It should be noted that for the CLI version, the mode variable has
    a value of `c`, and we are going to focus only on the code section that ladders
    to `mode=c`. The other branches of code will be for GUI mode, and you are free
    to read this if you want to know more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将了解`parse_and_process()`方法的工作原理。值得注意的是，对于CLI版本，mode变量的值为`c`，我们将只关注通向`mode=c`的代码部分。代码的其他分支将用于GUI模式，如果您想了解更多，可以自由阅读。
- en: 'The `parse_and_process()` method in sections, **(1), (2), (3),** and **(4)** starts
    its execution by iterating over `self.missed_services` and then over `self.processed_services`.
    The idea of iteration here is to place these discovered services, host, ports
    and `command_template` in a different database table, `IPexploits`. We will discuss
    the `command_template` in a little while. For our current example, the `self.processed_services` will
    contain the following data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(1)，(2)，(3)**和**(4)**节中的`parse_and_process()`方法开始执行，通过迭代`self.missed_services`和`self.processed_services`。这里的迭代思想是将这些发现的服务、主机、端口和`command_template`放入不同的数据库表`IPexploits`。我们将稍后讨论`command_template`。对于当前的示例，`self.processed_services`将包含以下数据：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is because all the discovered services except `rtsp` are mapped in the
    JSON file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为除了`rtsp`之外，所有发现的服务都在JSON文件中映射了。
- en: '![](img/7d65d025-09fe-4937-b2d5-69cb6a2c2701.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d65d025-09fe-4937-b2d5-69cb6a2c2701.png)'
- en: Section **(5)** of the code iterates over this dictionary and tries to fetch
    something such as `getTemplate(k)`, where `k` is the current service being iterated
    over. `getTemplate()` is a method that reads the JSON file and returns the command
    ID for the testcase to be executed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第**(5)**部分遍历此字典，并尝试获取诸如`getTemplate(k)`的内容，其中`k`是当前正在迭代的服务。`getTemplate()`是一个读取JSON文件并返回要执行的测试用例的命令ID的方法。
- en: '![](img/71b39b2a-5e6e-4b57-9c5b-133b20b04f55.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71b39b2a-5e6e-4b57-9c5b-133b20b04f55.png)'
- en: 'The following example will make this clear. Let''s say that `getTemplate` is
    invoked over `http`, such as `getTemplate(''http'')`. This would return the following
    structure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将说明这一点。假设`getTemplate`在`http`上被调用，如`getTemplate('http')`。这将返回以下结构：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The structure is as follows: `{ "http_5" : [''include_command,commands_executed,results_obtained]}`.
    If `http_5` is the key, the value is a list with three entries. The first says
    whether the command is to be included or executed (depending upon the scan profile
    chosen). The second entry holds the actual command that gets executed on the terminal.
    Initially it is set to 0, but once executed, the `0` for `http_5` will be replaced
    by `nmap -Pn --script=banner.nse -p 80 10.0.2.15`.The third, `0`, will actually
    be replaced by the results produced by the execution of the command mentioned.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结构如下：`{"http_5"：['include_command,commands_executed,results_obtained]}`。如果`http_5`是键，那么值是一个包含三个条目的列表。第一个条目表示命令是要包含还是执行（取决于所选择的扫描配置文件）。第二个条目保存在终端上执行的实际命令。最初它设置为0，但一旦执行，`http_5`的`0`将被替换为`nmap
    -Pn --script=banner.nse -p 80 10.0.2.15`。第三个`0`实际上将被执行命令产生的结果所替换。
- en: The code `entries=getTemplate(k)` will return entries such as the one mentioned
    for each service type. We prepare a list called `rows`, where we place the host,
    port, service, open/close status, and entries/`command_template`. The code snippet
    that performs that activity is `self.rows.append((self.project_id, str(h_p[0]),
    str(h_p[1]), str(k), 'init', entries, service_status, str(h_p[2]), str(h_p[3])))`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`entries=getTemplate(k)`将为每种服务类型返回一个类似上述的条目。我们准备一个名为`rows`的列表，其中放置主机、端口、服务、开/关状态和条目/`command_template`。执行该活动的代码片段是`self.rows.append((self.project_id,
    str(h_p[0]), str(h_p[1]), str(k), 'init', entries, service_status, str(h_p[2]),
    str(h_p[3])))`。
- en: 'The services where the `type=new` or that are not mapped will be handled by
    code section **(2)**. This will place the following in the entries for our example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`type=new`的服务或未映射的服务将由代码部分**(2)**处理。这将在我们的示例条目中放置以下内容：'
- en: '`entries={"Entries": {"new": true, "unknown": false}}`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries={"Entries": {"new": true, "unknown": false}}`'
- en: Code section **(6)** checks for something such as `if(is_custom==True)`. This
    means that, there are certain services that can be used multiple times with other
    services. For example, the testcases for `ssl` can be used with `https` such as `[http
    +ssl]`, `ftps` as `[ftp + ssl]`, `ssh` as `[ssh + ssl]`. For this reason, services
    such as `https`, `ftps`, and so on are marked as `custom`, and when `https` is
    discovered, we should load both templates for `http` and `ssl`. This is what is
    done in section **(6).**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码部分**(6)**检查诸如`if(is_custom==True)`之类的内容。这意味着有一些服务可以与其他服务多次使用。例如，`ssl`的测试用例可以与`https`一起使用，如`[http
    +ssl]`，`ftps`作为`[ftp + ssl]`，`ssh`作为`[ssh + ssl]`。因此，诸如`https`，`ftps`等服务被标记为`custom`，当发现`https`时，我们应该加载`http`和`ssl`的两个模板。这就是在第**(6)**部分中所做的。
- en: By the end of section(6), `self.rows` will have entries such as `[project_id,host,port,service,project_status,command_template,service_type,port_state,version]` for
    all hosts and ports. In our current example, it will hold six rows for all the
    service types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(6)部分结束时，`self.rows`将为所有主机和端口的所有服务类型保存类似`[project_id,host,port,service,project_status,command_template,service_type,port_state,version]`的条目。在我们当前的示例中，它将为所有服务类型保存六行。
- en: In section **(7)**, `self.IPexploit.insertIPexploits(self.rows)`, we push all
    the data of `self.rows` in the backend database table `IPexploits` in one shot.
    It must be remembered that the datatype of `command_template/entries` is marked
    as JSON in the backend database as well. For this reason, we require MySQL version
    5.7 or above, which supports the JSON datatype.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**(7)**部分，`self.IPexploit.insertIPexploits(self.rows)`，我们一次性将`self.rows`的所有数据推送到后端数据库表`IPexploits`中。必须记住，后端数据库中`command_template/entries`的数据类型也标记为JSON。因此，我们需要MySQL版本5.7或更高版本，支持JSON数据类型。
- en: 'After this command is executed, our backend database for the current project `744` would
    look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们当前项目`744`的后端数据库将如下所示：
- en: '![](img/a7c5a600-cb6f-495c-a35f-04aa627ab35b.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c5a600-cb6f-495c-a35f-04aa627ab35b.png)'
- en: 'It must be noted that I am not loading the `command_template` (named `Exploits`
    at the back end ), because then the data becomes cluttered. Let''s try to load
    the template for two services, such as `rtsp` and `ssh`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，我没有加载`command_template`（在后端命名为`Exploits`），因为数据会变得混乱。让我们尝试加载两个服务的模板，如`rtsp`和`ssh`：
- en: '![](img/cb545040-2968-4d87-815a-460221e76c30.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb545040-2968-4d87-815a-460221e76c30.png)'
- en: Likewise, we will also have entries for `http`, `ssl`, and `rcpbind`. It should
    be noted that we were expecting six rows in the table, but there are in fact seven.
    This is because the `https` service is broken into two classes `http` and `ssl`,
    thus, at port `443`, instead of having `https`, we have two entries: `http-443` and `ssl-443`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还将有`http`，`ssl`和`rcpbind`的条目。应该注意的是，我们预计表中有六行，但实际上有七行。这是因为`https`服务被分为两类`http`和`ssl`，因此，在端口`443`上，我们不是有`https`，而是有两个条目：`http-443`和`ssl-443`。
- en: 'In the next section, the default configuration of the project (host, ports,
    testcases to be executed) is fetched from the same database table and is displayed
    to the user. Section eight calls the code using `launchConfiguration()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，项目的默认配置（主机、端口、要执行的测试用例）从同一数据库表中获取，并显示给用户。第八部分调用代码使用`launchConfiguration()`：
- en: '![](img/5b5026d0-b02a-484b-929c-fa6bfa035ca2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b5026d0-b02a-484b-929c-fa6bfa035ca2.png)'
- en: launchConfiguration()
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: launchConfiguration()
- en: In this section, let's take a look at the `launchConfiguration()` method, which
    loads default configurations, and also gives the user the ability to tweak or
    reconfigure it. Furthermore, it invokes the central logic of the file that would
    actually start script execution, which is `launchExploits()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，让我们来看一下`launchConfiguration()`方法，它加载默认配置，并且还允许用户进行微调或重新配置。此外，它调用了文件的中心逻辑，实际上会启动脚本执行，即`launchExploits()`。
- en: For the CLI version `launchExploits()` is invoked by `launchConfiguiration()`.
    However, in the GUI version, `launchExploits()` is invoked by the `parse_and_process()`
    method only. More information about this method can be seen from the preceding
    screenshot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CLI版本，`launchExploits()`是由`launchConfiguiration()`调用的。然而，在GUI版本中，`launchExploits()`只能由`parse_and_process()`方法调用。有关此方法的更多信息可以从前面的截图中看到。
- en: Section**(1)** of the following code snippet loads all details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits` list.
    Remember that in the backend table we only have the command IDs, such as `http_1` or `http_2` placed
    under the `Template`, but to display the selected configuration and commands to
    be executed, we pull out the actual script, which will map to `http-1` and so
    on. This is what section **(2)** is doing. It reads the JSON file to get the actual
    commands.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的第1节加载了放置在当前项目的`IPexploits`表中的所有细节。我们已经看到了将被拉出并放置在`IPexploits`列表下的七行。请记住，在后端表中，我们只有命令ID，例如`http_1`或`http_2`放在`Template`下，但是为了显示所选的配置和要执行的命令，我们拉出实际的脚本，它将映射到`http-1`等等。这就是第2节在做什么。它读取JSON文件以获取实际命令。
- en: 'In section **(3)**, we are placing the pulled details in a `tab_draw` variable, which
    will draw a table on the console window and represent the loaded configuration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3节中，我们将拉取的细节放在`tab_draw`变量中，它将在控制台窗口上绘制一个表，并表示加载的配置：
- en: '![](img/990785c3-c2da-44ba-a39b-8c30e0a52216.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/990785c3-c2da-44ba-a39b-8c30e0a52216.png)'
- en: 'Section **(4)** is self explanatory; we are placing all the pulled details
    in a dictionary called `config_entry`. This will be saved to a file, as the final
    chosen configuration with the scan will be launched:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第4节是不言自明的；我们将所有拉取的细节放在一个名为`config_entry`的字典中。这将被保存到一个文件中，因为最终选择的配置与扫描将被启动：
- en: '![](img/d6554158-8c15-420d-9e66-d22d7e042f83.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6554158-8c15-420d-9e66-d22d7e042f83.png)'
- en: 'Finally, under section **(6)**, we call `launchExploits()`. If there is a need
    to perform reconfiguration, section **(7)** calls the `self.reconfigure()` method,
    which is straightforward and can be referred from the code-base or from the following URL
    <https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/driver_meta.py>:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第6节下，我们调用`launchExploits()`。如果需要执行重新配置，第7节调用`self.reconfigure()`方法，该方法很简单，可以从代码库或以下URL
    <https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/driver_meta.py>
    中找到：
- en: '![](img/6433c485-b025-4b3f-9c44-0434e0202025.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6433c485-b025-4b3f-9c44-0434e0202025.png)'
- en: 'Section**(5)** will display the configuration on the screens as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第5节将如下显示屏幕上的配置：
- en: '![](img/c51bda78-c507-42b4-b873-91884245dc26.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c51bda78-c507-42b4-b873-91884245dc26.png)'
- en: '![](img/fb31c123-1961-459a-ad79-f98169b64cdc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb31c123-1961-459a-ad79-f98169b64cdc.png)'
- en: launchExploits()
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: launchExploits()
- en: The following section will talk about the `launchExploits()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将讨论`launchExploits()`方法。
- en: 'Section**(9)** of the following code loads all the details that are placed
    in the `IPexploits` table for the current project, which is `744`. We have already
    seen the seven rows that will be pulled out and placed under the `IPexploits_data` list.
    We don''t need to focus on the `else` block of `if(concurrent=False)`, as that
    refers to code that is invoked in the GUI version. For now, let''s only take the
    `if` block into consideration, as `concurrent=False` for the CLI version. Next,
    we iterate over the `IPexploits_data: "for exploit in IPexploits_data:"` structure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码的第9节加载了放置在当前项目的`IPexploits`表中的所有细节。我们已经看到了将被拉出并放置在`IPexploits_data`列表下的七行。我们不需要关注`if(concurrent=False)`的`else`块，因为那是指在GUI版本中调用的代码。现在，让我们只考虑`if`块，因为对于CLI版本，`concurrent=False`。接下来，我们遍历`IPexploits_data:
    "for exploit in IPexploits_data:"`结构：'
- en: '![](img/d6763f0f-2643-46cd-aae9-d051b4138781.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6763f0f-2643-46cd-aae9-d051b4138781.png)'
- en: In section **(10)**, we loading the details from the JSON structure for the
    current service that is being iterated. Remember that `self.commandsJSON` holds
    the whole JSON file data where we mapped the services and testcases. We then load
    all the commands and testcases of that particular service and placing them under
    a list `meta`. For example, if `service = http`, then the meta will hold `[http_1,http_2,http_3,http_4,http_5
    ...]`. Now, remember that in the last section, for each record out of the seven
    records, the `project_status` was `init`. In the next line (section **(11)**),
    we update the status to `processing` for the current record's `(host,port,service,record_id)` combination.
    As we have already picked up this service to be executed, we want to change the
    database status.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10节中，我们从当前正在迭代的服务的JSON结构中加载细节。请记住，`self.commandsJSON`保存了整个JSON文件数据，我们在其中映射了服务和测试用例。然后，我们加载该特定服务的所有命令和测试用例，并将它们放在一个名为`meta`的列表下。例如，如果`service
    = http`，那么meta将包含`[http_1,http_2,http_3,http_4,http_5 ...]`。现在，请记住，在最后一节中，对于七条记录中的每条记录，`project_status`都是`init`。在下一行（第11节），我们将当前记录的`(host,port,service,record_id)`组合的状态更新为`processing`。因为我们已经选择了执行此服务，我们希望更改数据库状态。
- en: In section **(12)**, we load all the enabled service cases for the particular
    service to be executed, depending upon the scan profile chosen for the project.
    As discussed earlier, we have all the essential cases loaded.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12节中，我们加载了为项目选择的扫描配置所执行的特定服务用例的所有启用服务用例。
- en: 'There are certain projects/scans that may also need some user defined parameters,
    such as username, passwords to use, and so on. All such parameters are placed
    inside a `Project_params.json` file, and section **(13)** replaces the usernames
    and passwords of the command to be executed with the project specific usernames
    and passwords, wherever applicable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/041520fe-43b0-49b0-8a05-bbf48c712f04.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '`Self.commandObj` holds the object of the `auto_commands.pl` class. Section **(14)** initializes
    the instance variables of the class that are relevant to the current record set
    to be executed (host, port, service, and so on). As we discussed earlier, the `args` parameter
    from the JSON file contains the actual command to be executed. We loaded the `args` value
    in the program variable args. As we know, this is a list that contains commands.
    We iterate over this list and replace entries such as `<host>` with the actual
    IP to be scanned and `<port>` with the actual port to be scanned. We will repeat
    this activity for all the testcases, one by one. For the current example, if we
    assume that `http` is the current service to be scanned, the code will iterate
    over all the commands, `[http_1,http_2..]`. Finally, the `final_args` list for `http_5` and
    port `80` will be specified as `[500, nmap -Pn --script=banner.nse -P80 10.0.2.5]`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ed344b-bd52-4367-a752-f63f7824bf31.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'In section **(16)**, we are actually invoking the appropriate method from the `auto_comamnds.py` module. Let''s
    think about how this works. `getattr(object, name[, default])` returns the value
    of the named attribute of `object. name` and must be a string. If the string is
    the name of one of the object’s attributes, the result is the value of that attribute.
    For example, `getattr(x,''Method_name'')` is equivalent to `x. Method_name`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9c3517f-c4db-4c63-bc00-dfbb45d6796d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'As we have already discussed, the name of the method to execute the script/module
    is preconfigured in the JSON file, and in the preceding code it is read in the
    variable method. `func = getattr(self.commandObj,method_name)` will return the
    reference of that method, and can be invoked such as `func(args)`. This is what
    is done in section **(18)**: `func(final_args,grep_commands)`. When that method
    is executed, it will automatically save the results in the database. Once all
    the test cases for a service are executed, we want to update the status of that
    row from `processing` to `complete`, which is what is done at section **(20)**.
    The same operation is repeated until all the discovered services for all the hosts
    are scanned. Let''s take a look at what the database table looks like when a test
    case is executed. We will be taking examples from a different project ID:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36cb2886-81b8-4eb0-b265-0a256cb7a1c6.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the preceding screenshot, the data for this particular
    row for the project ID 736 before service scanning would have been as follows:
    `Pid=736,Service=''ssl'',Exploits={"Entries" :{"ssl_1":[true,0,0]} ... }`. Once
    the execution is over, however, the first 0 is replaced by a list that has the
    command(s) executed. In place of the second 0, we have the final results in the
    form of a string.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: auto_commands.py
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next section, we will take a look at how stuff actually works, in terms
    of how the methods that get invoked automate the process of service scanning.
    We will be exploring the Python module or file `auto_commands.py`. It must be
    remembered that in this section, we will be covering the essential methods of
    this class. As well as these, there are a few others that are custom made for
    specific use cases. You can refer to the exact code file at the GitHub repository
    [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/auto_commands.py%3E).
    Let''s start by looking at what the class looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fce252f-5930-4159-a26d-36ccbe015f1e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: One of the modules we imported was **pexpect**. In the following section, let's
    try to understand what this module does and why it is important.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的模块之一是**pexpect**。在接下来的部分中，让我们试着理解这个模块的作用以及它为什么重要。
- en: Pexpect
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pexpect
- en: Pexpect is a Python module that works like Unix's expect library. The primary
    purpose of this library is to automate interactive console commands and utilities.
    Pexpect is a pure Python module for spawning child applications, controlling them,
    and responding to expected patterns in their output. Pexpect allows your script
    to spawn a child application and control it as if a human were typing commands.
    Pexpect can be used for automating interactive applications such as SSH, FTP,
    passwd, telnet, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect是一个类似Unix的expect库的Python模块。这个库的主要目的是自动化交互式控制台命令和实用程序。Pexpect是一个纯Python模块，用于生成子应用程序、控制它们，并响应其输出中的预期模式。Pexpect允许您的脚本生成子应用程序并控制它，就像一个人在键入命令一样。Pexpect可用于自动化交互式应用程序，如SSH、FTP、passwd、telnet等。
- en: 'We will be using Pexpect to automate Metasploit with Python and also in to
    invoke various use-cases of terminal automation that require user interaction.
    It must be noted that there are two other methods for invoking Metasploit with
    Python code: `"msfrpc"`, which calls the service API built on top of Metasploit,
    and `".rc"` scripts. We have observed maximum success, however, using the Pexpect
    module.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Pexpect来使用Python自动化Metasploit，并且还将调用需要用户交互的终端自动化的各种用例。必须注意的是，还有另外两种用Python代码调用Metasploit的方法："msfrpc"，它调用了建立在Metasploit之上的服务API，以及".rc"脚本。然而，我们观察到使用Pexpect模块的成功率最高。
- en: The Pexpect module has a spawn class that is used to spawn any terminal command,
    process, or tool. The tools that are spawned should be spawned as a child process
    of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect模块有一个spawn类，用于生成任何终端命令、进程或工具。生成的工具应作为代码的子进程生成。
- en: 'The syntax for the spawn class constructor is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: spawn类构造函数的语法如下：
- en: '`pexpect.spawn(command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
    logfile=None, cwd=None, env=None, ignore_sighup=False, echo=True, preexec_fn=None,
    encoding=None, codec_errors=''strict'', dimensions=None, use_poll=False)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect.spawn(command, args=[], timeout=30, maxread=2000, searchwindowsize=None,
    logfile=None, cwd=None, env=None, ignore_sighup=False, echo=True, preexec_fn=None,
    encoding=None, codec_errors=''strict'', dimensions=None, use_poll=False)`'
- en: 'The `spawn` class constructor takes many parameters, but the mandatory one
    is `command`. The `command` is the actual command that we wish to execute on a
    Unix terminal. If we wish to pass arguments to the command invoked, we can either
    specify the arguments with the command itself, separated with a space, or pass
    the arguments as a Python list specified under the second argument `args`. The
    third argument is `timeout`, which is 30 seconds by default. This implies that
    if a process is not spawned within 30 seconds, the whole operation will be terminated.
    If our server is under a high load, or we have performance issues, we can increase
    the `timeout` parameter. The following code represents how to invoke an SSH session
    with Pexpect:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`类构造函数有许多参数，但强制参数是`command`。`command`是我们希望在Unix终端上执行的实际命令。如果我们希望传递参数给调用的命令，我们可以在命令本身中指定参数，用空格分隔，或者将参数作为Python列表传递到第二个参数`args`下。第三个参数是`timeout`，默认为30秒。这意味着如果在30秒内未生成进程，整个操作将被终止。如果我们的服务器负载很高，或者我们有性能问题，我们可以增加`timeout`参数。以下代码表示如何使用Pexpect调用SSH会话：'
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also construct it with a list of arguments as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用参数列表构造它，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the command is executed on the terminal, a session is created and controlled
    via the process, which is returned and placed under the `child` variable, as shown
    in the preceding example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当在终端上执行命令时，会创建一个会话，并通过返回的进程进行控制，该进程被放置在`child`变量下，如前面的示例所示。
- en: Another important class for `pexpect` is `expect`. Expect, as the name suggests,
    lays down the expected output or outputs that might be produced if the `spawn`
    command is executed successfully. For example, if the `spawn` command is `pexpect.spawn('/usr/bin/ssh',['user@example.com'])`,
    we would usually expect the ssh server to ask us for a password. All the possible
    patterns or strings that might be expected from the previously specified command
    are passed as arguments to the `pexpect.expect` class, and if any of the patterns
    match, we can define the next command to be sent to the terminal according to
    the match. If there is no match, we may abort the operation and try to debug it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect`的另一个重要类是`expect`。如其名称所示，Expect规定了在成功执行`spawn`命令时可能产生的预期输出或输出。例如，如果`spawn`命令是`pexpect.spawn(''/usr/bin/ssh'',[''user@example.com''])`，我们通常期望ssh服务器要求我们输入密码。从先前指定的命令中可能期望的所有可能模式或字符串都作为参数传递给`pexpect.expect`类，如果任何模式匹配，我们可以根据匹配定义要发送到终端的下一个命令。如果没有匹配，我们可以中止操作并尝试调试。'
- en: 'The following syntax looks through the stream until a pattern is matched. The
    pattern is overloaded and may take several types. The pattern can be a String
    Type, EOF, a compiled regular expression, or a list of any of those types:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法查找流，直到匹配模式。模式是重载的，可能有多种类型。模式可以是字符串类型、EOF、编译的正则表达式，或者是任何这些类型的列表：
- en: '`pexpect.expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw)`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`pexpect.expect(pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw)`'
- en: 'If you pass a list of patterns and more than one matches, the first match in
    the stream is chosen. If more than one pattern matches at this point, the leftmost
    pattern in the pattern list is chosen. For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了模式列表，并且有多个匹配项，则流中选择第一个匹配项。如果此时有多个模式匹配，则选择模式列表中最左边的模式。例如：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`child.sendLine(command)` is a method that takes the command that is to be
    sent to the terminal assuming everything is working as per the expected pattern:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`child.sendLine(command)`是一个方法，它接受要发送到终端的命令，假设一切都按预期模式工作：'
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a small example of SSH automation using Pexpect that will make
    things clearer:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Pexpect进行SSH自动化的小例子来更清楚地说明问题：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we are taking only the success scenario. It must be noted
    that if the terminal expects what lies at index 1 of the input list `'root@.*
    password:.'`, then we pass the password as root with the help of the `sendline`
    method. Note that `'root@.* password:.'` indicates any IP address after root,
    because it is a regex pattern*.* Based on the index of the string/regex pattern
    matched, we can formulate our logic to indicate what should be done next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: custom_meta()
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take a look at the `custom_meta` method, which is responsible for
    handling all the Metasploit modules. It does this with the help of the Pexpect
    library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in section **(1)** in the following snippet, we are using `pexpect.spawn`
    to invoke `"msfconsole -q"`, on our terminal. This will invoke a Metasploit process
    over a virtual terminal and would return the control of that process to the variable
    declared as a child:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fab3c20-acfd-4dad-a8cf-27e946740955.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Whenever we invoke msfconole, if there is no error, we would get a Metasploit
    prompt as `msf>`. This is what we are specifying in section **(2)**, [.*>, ..,
    ..] , as the 0th index. What is implied here is that we expect anything preceded
    by `>` to be successfully executed, and so we will pass the commands that are
    required to run the Metasploit module. If the index returned by child.expect is
    0, we will iterate over the command list of the JSON file and send each command
    to our Metasploit console. For our projectID `744` and the `http` service, we
    have configured a few Metasploit modules. One of these is shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3641e7b9-2482-4cdc-b45f-a543895132bf.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Whatever is within the `args` keyin the preceding screenshot of the JSON structure
    would be passed as a list to the `custom_meta` method and stored in the commands
    list. In section **(3)****,** we iterate over the commands list, and, as we studied
    earlier, the `<host>` and `<port>` would actually be replaced by an actual host
    and the port being scanned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, each command is sent to the msfconsole Terminal one by one
    with the `child.sendline(cmd)` command. After sending each command, we need to
    check whether the console is as we expect it to be, which means that it should
    contain the `msf>` prompt. We invoke `pexpect.expect` and specify `".*>"` as the
    0th index of our input list. Note that index 0 defines the success criteria for
    us to continue. As long as we get an output that matches with index 0, we continue,
    as specified by section **(4)**. If at anytime we observe anything other than
    index 0 (either a timeout or the end of a file – EOF), we realize that something
    did not happen as expected, and so we set the boolean variable as false:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/235e44b2-6881-4aef-adc9-3194a695d5bc.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: When we get out of this iterative loop, we move to section **(9)**, where we
    are checking if run ==True. If it is true, we assume all the parameters are properly
    set to execute the Metasploit module. We issue the `'run'` command with the help
    of `sendline`, as highlighted by section **(10)**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if everything goes right and the module is executed successfully,
    it''s time for us to collect our results. In section **(11)**, if all goes as
    expected, we collect the results in an `exploits_results` variable and the commands
    in the `commands_launched` variable. If there is an error, we collect the error
    details in section **(12)**:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc5665f-f413-4ef1-88d2-aaa653010a87.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in section **(14)**, we save the results in the database table by
    invoking the `saveDetails()`method**.** It must be noted that the results would
    be saved in the same JSON structure as discussed earlier against the `"http_headers_2"`
    key, which is the ID of the script. The definition of the `saveDetails` method is
    shown. Note it would be issued across all the different methods that we will discuss:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb32e5f-a63e-4e35-a349-d65ce07842ac.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: The section highlighted as **(1)** invokes the method placed in the class file
    `IPexploits.py`, which would insert the details in the database. The whole code
    file can be found at the GitHub repository**.**
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: singleLineCommands_Timeout()
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see the definition of the `singleLineCommands_Timeout` method.
    This section of code explains the power of threading and multiprocessing. We studied
    all the concepts earlier, but in this section, we will see how can we apply the
    concepts of threads and processes to solve real-world problems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The problem at hand is to execute all the categories of commands and scripts
    that can be executed by just firing a single line at the console. These produce
    the output. This might look straightforward, but there is a catch. Remember that
    we discussed occasions in which the execution of a script may take a long time
    for some unforeseen reason and we should design our solution in a manner such
    that we have a timeout associated with all the script categories where this might
    be the case. Here, we will be using threads to implement the timeout functionality.
    A combination of threads and processes will help us achieve our objective.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The central idea is to invoke a thread and bind it to a method "x". We call
    `join()` on the thread invoked and the duration of `join()` would be the timeout
    specified in the JSON file. As we studied earlier, the `join()` method, when invoked
    over a thread ''t'', from the main thread ''m'', will cause the main thread ''m''
    to wait until ''t'' finishes its execution. If we invoke join (20) over thread
    ''t'' from the main thread ''m'', this will cause the main thread ''m'' to wait
    for 20 seconds for ''t'' to finish. After 20 seconds, the main thread will continue
    its execution and exit. We can use the same analogy to achieve our task:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf96f815-d45b-4934-b60f-b72e6c54bafb.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: In sections **(1)** and **(2)**, we are creating a `thread` object, and the
    method we are attaching to it is `"execute_singleLine"`. It should be noted that
    there are certain occasions where we want to grep out something from the final
    output, which is why we are checking whether the `grep` parameter is set. If it
    is set, we send the `grep` string as an argument to the thread method; otherwise,
    we only send the console script/command that the method is supposed to invoke.
    We don't need to worry about the grep condition for now.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(3)**, we can see that we are collecting the timeout parameter,
    which is always at index 0 of the commands list or at the 0th index of the args
    from the JSON file. We invoke the start method on the thread, which will invoke
    the `"execute_singleLine"` method and pass the command to be executed as an argument.
    After that, we invoke `join(timeout)`, on the thread invoked, the code will be
    halted there until the duration of seconds specified under timeout. No line after
    section **(3)** will be executed until either the `"execute_singleLine"` method is
    finished or the time exceeds the timeout. Before moving on, let''s take a closer
    look at what is happening within the  `"``execute_singleLine``"` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ff0426b-08ff-46f1-bf48-998fd440d39e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: As specified by section **(1)** of the `"execute_singleLine()"` method, we are
    making use of Python's subprocess module to spawn a child process. The process
    will be specified by the command present in the `"cmd"` variable. Therefore, if
    `cmd` holds "`nmap -Pn --script=banner.nse -p 80 192.168.250.143`", the same command
    will be executed at the terminal, which is nothing but a process at OS level. The
    instance of the process class will be returned and placed under the `self.process` class
    variable. The instance holds various properties such as `"id"`, `"is_alive()"`,
    and so on, which give us information about the state of the process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Since we are sure of the parameters passed to the process (as they are not coming
    from user directly), we can proceed with it. However, it's a good practice to
    use `shell=False` and specify the arguments as a list `[]`, or, alternatively,
    use the **shelx** utility of Python to convert string arguments automatically
    to a list and use `shell=False`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: We want our parent process to wait until the child process executes and we also
    want the child process to give all the data it produces back to the parent process.
    We can achieve this by invoking `communicate()` on the invoked process. The `communicate()`
    method will return a tuple with a 0th index that contains the output from the
    process and a first index that will have the errors produced. Since we are specifying
    `output=subprocess.PIPE`, and `error=subprocess.PIPE`, both the output and the
    errors will be piped to the parent process via OS pipes, which is how we achieve
    inter-process communication. This is highlighted in section **(2).**
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Our next challenge is to convert the console output to a standard ASCII format
    so that we can save the data cleanly in the database. It should be noted that
    different tools and scripts produce data in different formats and encoding that
    would be appropriate for the console to display. The console supports a wide range
    of encoding, but we need to save the output in our database tables, so before
    pushing the data, we need to convert it from console encoding to ASCII format.
    This is what we are doing in section **(3).**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In section **(4)**, we get control of the parent process by invoking `process
    = psutil.Process(self.process.pid).`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In section **(5)**, after we have cleaned the data, we push both of the commands
    that were executed and the data that was generated in the database table by invoking
    the `saveDetails()`method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: After section **(3),** we check whether the thread is still alive by invoking
    `thread.is_alive()`. If it returns `false`, it means that the thread was successfully
    executed within the specified time via internally invoking the `subprocess.Process` command
    and also that the details are saved in the database table. However, if `thread.is_alive()`
    returns `true`, this means that the external script is still running and so we
    would need to forcibly kill it so that it doesn't hamper the execution of the
    other scripts that are lined up to be executed. Remember that the process invoked
    returns us the instance of the process that we saved under the `self.process`
    class variable. We are going to use that variable here in order to kill the process.
    Python has got a very powerful utility called `"psutil"`, which we can use to
    not only kill the process, but also all the child processes invoked by that process.
    We need to kill the child processes as well, because we don't want these to be
    running in the background and consuming our CPU. For example, tools such as Nikto
    invoke many child processes to expedite the whole operation and we would want
    to kill all of them to make sure the parent process is killed and all the system
    resources are released for other processes to use. Once we have fetched the parent
    process, we iterate over each of its child processes using a `for` loop, `for
    proc in process.children(recursive=True):`, and kill each of the child processes
    by issuing the command `proc.kill()`**. **This is highlighted in section **(5).**
    Finally, in section **(6)**, we ensure that we kill the parent process as well
    by invoking `self.process.kill()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: general_interactive()
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to understand how the `general_interactive()`
    method works. Although we could have Metasploit commands implemented with this
    method as well, to keep the separation of categories, we implemented Metasploit
    separately.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of `general_interactive` is to automate interactive tools and
    Bash commands. This means that the JSON file contains both success patterns and
    failure patterns, which define the workflow of execution. We will be using Pexpect
    to accommodate this as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fac8b47-a996-4614-84aa-b76504f92684.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at this method by carrying out a dry run, as shown
    here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d93bb4e-20d8-43b1-a924-453ff53dd525.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: As we can see in the `args[]`, the first argument is the timeout. The second
    index holds the command that we wish to automate using the general interactive
    method. As always for this category, the first argument will be the `timeout`
    and the second will be the command to be fired. From here on, an alternate pattern
    is defined. The third index will hold the expected output list and the success
    criteria. If the success criteria is met, the fourth index will hold the next
    command to be send to the console. The fifth index will again hold the expected
    output list based upon the command sent in the fourth index, and it also holds
    the success criteria. The pattern is straightforward, and the same alternating
    sequence is carried on as required by the underlying command or tool that we plan
    to automate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The success criteria is defined at the first index of the expected output list.
    If there are multiple success outcomes or indices, they can be given as a comma
    separated input at the first index. Let''s take the above example of `rlogin`,
    where we are trying to do a remote login with root as the username and password,
    and try to understand what the expected output list holds and signifies. The list
    at index 3 holds `[''0,1'',''.* password: .*","[$,#]",".*No route.*"]`**. **Here,
    the 0th index "0,1" defines the success criteria. This means that if the terminal
    expects either `".* password: .*"` or `"[$,#]"`, we assume that the output is
    as expected and therefore we send the next command to the console, which is `"root"`
    in our case. If we get anything other than index 0 or 1, we assume that the tool
    or script is not behaving as expected, and thus abort the operation.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: To configure commands and scripts that belong to this category, the tester needs
    to know how the script executes under both success and failure conditions, and
    formulate the configuration file once. The preceding code is straightforward and
    implements the same logic we discussed previously.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: generalCommands_Tout_Sniff()
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea here is similar to how we implemented the `singleLineComamnd()` method
    with the help of threads. Note that the category of the command to be executed
    would either be `interactive` or `"singleLineCommand_Timeout"`, along with a sniffing
    operation. We will create a thread and delegate the sniffing task to it by attaching
    it to the `start_sniffing` method. We will also reuse the methods we created earlier.
    Either we invoke `singleLineCommands_Timeout()` as specified by **(1)**, or `general_interactive()`
    as specified by **(2)**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39b5a7b-b670-4897-92de-138e071f5b3a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'In section **(3)** and **(4)**, we check whether the sniffing process is still
    alive, and if it is, then we kill it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We usually use Wireshark to capture all traffic on our interface. Since Wireshark
    is a desktop application, however, in this case, we will use **Tshark**. Tshark
    stands for terminal shark and is the CLI version of Wireshark. The Tshark invocation
    command is specified in section **(2)**, where we specify the port at which we
    want Tshark to sniff traffic. We also specify the host for which traffic needs
    to be sniffed, or the destination host. The reason we specify both the host and
    the port is that we want to maintain result integrity; the GUI version of the
    tool can deployed on the server and multiple users can use it to conduct scanning.
    If we specify that it should sniff on the interface, data from other running sessions
    for other users would also be sniffed. To avoid this, we are very specific with
    host and port. We also specify the timeout duration for it to sniff. We save the
    output in a file specified as `"project_id_host_port_capture-output.pcap"`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'In section **(2)**, we invoke the `tshark` process with the help of the subprocess
    module, which we discussed earlier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e571c8-2181-4798-8e4c-485f7364060e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: HTTP_based()
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `http_based` method is straightforward. We use Python''s request
    library to send a GET request to our target, capture the response, and save it
    in the database. For now, we are just sending a GET request, but you can tweak
    the code to handle both GET and POST in your own time. We will cover more about
    python requests and scraping in the next chapters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1f98ec6-8bd3-4733-8eba-a9dec6238b73.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: IPexploits.py
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important code file, which handles the database layer of the service
    scanning engine, is `IPexploits.py`. This file is straightforward; it contains
    various methods and the objective of each method is either to fetch data from
    a database table or to put data in a database table. We won't be discussing this
    module here, but I would recommend that you take a look at the code that can be
    found at the GitHub repository [https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py](https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/IPexploits.py).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Executing the code
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before executing the code, refer to the installation and setup instructions
    carefully from the GitHub repository [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    The installation guide also discusses how to set up the backend database and tables.
    Alternatively, you can download the plug and play VM that has everything installed
    and preconfigured.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code, go to the following path: `/root/Django_project/Dictator/Dictator_Service`.
    Run the code file `driver_main_class.py` as `:python Driver_scanner.py` It must
    be noted that, the results are generated using a Python library that converts
    the console output into its HTML equivalent. Further details can be found at the
    following code file [https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python](https://github.com/PacktPublishing/Hands-On-Penetration-Testing-with-Python),
    under the `generate_results()` method.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Database schema for the service-scanning portion of the vulnerability scanner
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For service scanning the scan results, go to the IPexploits table, the schema
    of which looks as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/330d9b69-af86-4e96-86d5-d4d3c968b98b.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: GUI version of vulnerability scanner
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same code base discussed previously can be enhanced to develop a web-based
    version of the vulnerability scanner, with both port scanning and service scanning
    capabilities. The tool has many different features, including a four-tier architecture,
    which has a web layer presentation, a web layer server, an API layer, and a DB
    layer. Download and install the web version of the tool from the GitHub repository
    [https://github.com/FurqanKhan1/Dictator/wiki](https://github.com/FurqanKhan1/Dictator/wiki).
    Alternatively, you can use the plug-and-play vm and simply log in and open the
    browser at `https://127.0.0.1:8888` to access the tool.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The various features of GUI version of the scanner include the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Parallel port scanning
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and resuming port scanning
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All test case automation
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and resuming Service scanning **(not in CLI)**
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel service scanning **(not in CLI)**
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap report uploading and parsing of Qualys and Nessus reports
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage [PTO-GUI]
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section walks us through the usage of the GUI version of the scanner.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Scanning modules
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based upon the type and nature of scans being conducted on the underlying infrastructure,
    the pen tester has got multiple options available and may choose the one that
    may fit best with the given infrastructure to be tested. The various modes of
    usage available are covered in the following sections.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Sequential mode
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In sequential mode, the tool would start with the discovery followed by reconfiguration
    and then it will start service scanning. Thus, it is a three step process. Note
    that in sequential mode
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The service scanning cannot be started until all hosts have been scanned
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once service scanning is started, no reconfiguration can be done
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning once started, would be started for all services. User has no
    control over which service to scan first and which one to scan last
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d1de7f0a-49fd-4838-bc8b-9988831c945b.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Reconfiguration after discovery is finished
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to reduce false positives and false negatives, kindly analyze port
    scanning results and if required, reconfigure/change them. You may additionally
    add test cases if in case any service/port is left out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be48f0bc-0324-4267-9356-5722ec6de546.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: '![](img/b05d1ad9-b8a4-4aab-bc9b-0a19cf078f4e.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we are changing service of type **status** to
    type `ftp`. Thus, the test cases would be run for `ftp`. Note: Do it only if you
    are sure that the service discovered is incorrect or of type `Unknown`. We shall
    understand service types shortly.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'If nmap misses out host/port/service, it can be added manually as shown below:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/676cb125-e46d-41fa-9f82-2aed49201424.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'After adding the test case, we can click upon **Start scanning** option to
    begin with service scanning. We can choose to enable threading option for speeding
    up the results, and we can also go and start service scanning without the threading
    option, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/881bab84-8099-4e57-b6c7-89dc7dbf2044.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Viewing intermediate results: The moment a person clicks upon **Start scanning**,
    he/she would be redirected to the scanning page. Every time a test case is executed,
    the UI would be updated and a blue color icon would appear on the screen in front
    of the service being scanned. A user may click upon that icon to view the test
    case results.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: When all the `test_cases` for a service would be executed then the icon will
    turn green.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows intermediate test case results:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d10429a-985d-431a-b473-8368da06b74d.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'At any point,, a user can leave the UI without impacting the running scan.
    In case the user wishes to see the scans are that currently running, he may choose
    running scans from the **Scanning Status** tab at the top . The following screen
    would be displayed:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a388638e-aa90-4bf1-aed4-c3c759ecc6f8.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Depending upon the state of the scan, it will display an appropriate action.
    If the scan is under progress, the **Action** column will have action as **Ongoing**. 
    Users may click upon this button to get to the UI screen of the current state
    of his/her scan.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A user can click upon the name of the scan to see the configuration (hosts,
    ports, switch) with which the scan was initially launched.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mode
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In sequential mode, the service scanning cannot be started until port scanning
    results are available for all the ports and the hosts are scanned. Thus, a pen
    tester may have to wait to obtain these results. Also, in this mode, the pen tester
    does not have control over which services can be scanned first and which can be
    scanned later. All the services are scanned in one go, limiting the granularity
    of control over service scanning. These are the limitations of the sequential
    mode that is handled by the concurrent mode.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The concurrent mode offers the flexibility to launch service scanning the moment
    service discovery is finished and further gives an option to launch service scanning
    for selective services based upon the pen testers choice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Click on **New Scan** tab under the **Scan** tab.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the scan parameters and choose the scan mode as **Concurrent**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7ceb7a8-e9ed-4348-9ac1-c1d080a592e9.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'The remaining steps will be the same, with the only exception being that in
    this mode of scan, a user will not have to wait for all hosts and ports to be
    scanned to begin with service scanning. Also, the user can choose what services
    he may wish to scan. This is illustrated in the following figure:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a66c7363-483b-4e59-8cb4-2693bb49781e.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, a user can choose to scan `http`
    first and not scan ssh immediately. The user can decide when to scan what service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: All the capabilities (reconfiguration, viewing results and so on) are available
    with the concurrent mode as well.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Sequential default mode
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this mode, the service scanning would start immediately after discovery
    is finished, thus skipping the reconfiguration phase. The utility of this mode
    is more relevant in case of scheduling scans where the pen tester may schedule
    scans to start at some other time and may not be available to do the reconfiguration
    while simultaneously wanting to proceed with default port scanning results for
    service scanning. Thus, this scan mode skips the reconfiguration phase and directly
    launches service scanning on obtaining default `nmap` port scanning results.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Click upon **New scan** tab under the **Scan** tab
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the scan parameters and choose the scan mode as **Sequential Default**
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e095c26-7b94-439c-966d-6b2b8a12dc1f.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: When port scanning results are done, it will start service scanning by itself,
    irrespective of whether the user is currently logged in.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and resuming scans
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of the scan mode, any scan weather in the discovery or service
    scanning state can be paused. The intermediate results would be saved, and the
    user can resume the scan anytime in the future.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: It must be noted that if the scan is paused while discovery (port scanning would
    have been going on), then the port scanning results for the ports that have already
    been scanned would be saved; the scan would start for unscanned ports once the
    user resumes. Likewise, if the scan is paused during service scanning, then whatever
    services would have been scanned, their results would be saved, and the user gets
    the flexibility to analyze the results of the services that would be scanned.
    When the scan resumes, the service scanning will start for unscanned services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen shots show how to pause an ongoing scan:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85ec9f7-aecf-4e07-b8eb-fd8ee0b2dc63.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'In order to resume the scan, either go to the **Current scans** tab or go to
    the **Paused scans** tab. The action column by default would have two buttons
    :'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Resume**: This will resume the scan from whatever state it was paused.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze**: If the scan is paused while scanning, then the penetration tester
    may analyze the results for the services that were already scanned. If you wish
    to resume the scan, then he/she may choose the option analyze. With this the user
    can get to see intermediate test case results for completed services.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze option may not appear if the scan would be paused during port scanning,
    as there would be no `test_cases` executed to analyze if port scanning would be
    going and mode would not be concurrent. **Analyze** option does not appear for
    concurrent scans, the **Resume** button will perform that joint functionality
    of resuming and analyzing the scans invoked in concurrent mode.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1746627a-0a38-4ff6-bd94-4d17adbd9538.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Downloading reports or analyzing when scan would be completed
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the scan would be finished, the user will get the option **Download All**
    on the UI. If the user would visit the **Current scans** tab, for all the scans
    with status as **Complete** for both discovery and service scanning, the **Action**
    column will by default have an option to download the results for offline analysis
    or to analyze the results online itself as shown in the following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45cb5b5b-e634-4eb1-83df-a1c473c50050.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'On clicking **Download All**, a zipped folder would be downloaded. It will
    have:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The final HTML report containing all test case results.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pcap files which would sniff certain services where sniffing is required. The
    Pcap files can be opened with Wireshark and analyzed weather the text/credentials
    are passed as plain text or in encrypted format. Note: The name of the Pcap file
    would be like `<project_id>_capture_output.pcap`. Thus if sniffing is done on
    `host1` for port `21` and project ID `100`, the Pcap file name would be `100_host1_21_capture_output.pcap`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downloaded folder will also have the final chosen configuration (Services
    -Test cases) with which the scan was launched. (JSON format)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand clicking upon **Analyze tests** will take us to UI where we
    can see the results of all `test_cases` on the user interface only.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To upload Nmap report, go to **Upload Reports** and choose Nmap report. Its
    a result importer module, which can read the results from an existing `Nmap.xml`
    report file and can import the findings in our custom database, and further use
    these findings in order to launch test cases/service scan. Thus, this leaves the
    user with the flexibility to use our tool in both modes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Discovery and service scanning together
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning mode alone
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4c6d5b56-57cf-432b-b886-c535305a0e6f.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: '![](img/a18ad171-8f38-4d72-831a-51f19028cc01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: On clicking on **Upload**, the report will be parsed and uploaded. A user may
    go to **Current scans** tab and would find the uploaded project `test_upload_nmap` listed
    over there, with its **Discovery status** as **Complete** and **Service scanning**
    status as **Incomplete**. A user may click upon **Action** tab **Ongoing** and
    can reconfigure the results and then start service scanning.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Qualys and Nessus report parsers
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this option, go to **Upload reports** tab and select either **Qualys**/**Nessus**
    report. We have a report merging module, which would merge the results obtained
    from Qualys, Nessus and manual test cases. In order to merge the reports, they
    have to be parsed first. We have Qualys, Nmap and Nessus report parsers. All of
    them will take a report in XML format and would parse the report and place it
    in local storage so that querying and integrating the results with other reports
    becomes easier:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46df89e3-7ade-4543-bf82-9b8c604d177e.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: The purpose of uploading the report here is to merge it with some manual project.
    Thus select the project from drop-down list with which a user may wish to merge
    the Nessus/Qualys report.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Report merger:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use this option go to **Merge reports** tab and select the **ID**/**Name**
    of the manual project with which you wish to integrate the Qualys and Nessus results.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: It assumes that the Nessus and Qualys reports would have already been uploaded
    and linked to the project with which they are meant to be merged .
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: This module merges the manual test cases, parsed Qualys report, parsed Nessus
    report and would also map the CVEs to exploits and finally, would provide the
    user an option to download the integrated reports in any of the format among (XML,
    HTML, CSV, JSON) thus providing one consolidated view for analysis.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34d668d7-9fa8-4f84-b7c1-01476bfd893a.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: '![](img/f393784d-9279-4b0a-ab86-b6ae5119e0bb.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: The final downloadable report is available in four formats (HTML, CSV, JSON,
    XML).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The merged report will do the merging based upon common results found in Nessus/Qualys
    and manual test_cases. It will cluster the common host and port into one group
    in such a way that analysis becomes easier.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to use various Python modules to achieve
    the task of service- scanning automation. We also studied how we can use a combination
    of threading and multiprocessing to solve real-world problems. All the concepts
    discussed in this chapter were mentioned by and large in the previous chapters.
    By the end of this chapter, the reader should have a good understanding of how
    powerful Python can be in the cyber security domain, and how can we use it to
    make a scanner of our own. We also looked at an overview of the vulnerability
    scanner in GUI mode.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can use machine learning and Natural
    language processing to automate the manual report analysis phase of penetration
    testing phase.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we not use msfrpc to automate Metasploit ?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we possibly do to further optmize the throughput?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it mandatory to use the JSON file? Can we use a database instead?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other tools can we integrate with the scanner?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python-nmap 0.6.1: [https://pypi.org/project/python-nmap/](https://pypi.org/project/python-nmap/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nmap from Python: [https://xael.org/pages/python-nmap-en.html](https://xael.org/pages/python-nmap-en.html)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON encoder and decoder: [https://docs.python.org/2/library/json.html](https://docs.python.org/2/library/json.html)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
