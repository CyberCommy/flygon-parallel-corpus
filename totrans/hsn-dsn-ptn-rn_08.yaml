- en: JavaScript and ECMAScript Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go back to the heart of the JavaScript language. Some
    of the patterns here can be reused across many different languages, such as Java,
    C++, and Python. It is vital to fill your toolbox with such powerful things. This
    time, we will implement well-known design patterns in JavaScript and see how we
    can benefit from them, especially within the React Native environment. As a little
    addition, we will learn a new library, called Ramda, which is known for its great
    functionalities that can help us to write much shorter and concise code. You will
    also get to know the fundamentals of functional programming, which will be the
    topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Selector patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ramda library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript and functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming basically means using functions in a certain way to write
    a logical piece of code. Most languages allow functions to be really complex and
    hard to understand. Functional programming, however, puts constraints on functions
    in order to be able to compose them and mathematically prove something about their
    behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: One of the constraints is the regulation of communication with the external
    world (for instance, side effects, such as data fetching). Some assert that no
    matter how many times we call a function with the same arguments, it will return
    the exact same value. All of these constraints will give us certain benefits.
    You can name some of these benefits already, such as time-traveling, which uses pure
    reducers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn a bunch of useful functions that will ease us into
    [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements of Functional
    Programming Patterns*. We will also elaborate more on the exact constraints and
    their benefits.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 map, filter, and reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is aimed at refreshing our knowledge on the `map`, `filter`, and
    `reduce` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, common language functions need to be extremely performant, which is
    a topic that spans beyond this book. Avoid reimplementing what is in the language
    already. Some of the examples in this chapter are here only for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` is most likely often neglected, hence, we will focus on it. Usually,
    `reduce` (as the name suggests) is used to reduce a collection in size to a smaller
    one, or even a single variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the reduce function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The callback takes four arguments: `previousValue`, `currentValue`, `index`,
    and `array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly remind you how the `reduce` function works, let''s look at the following 
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`reduce` iterates over the collection. At each step, it calls the function
    on the element iterator it is at. Then it remembers the function output and passes
    to the next element. This remembered output is the first function argument; in
    the preceding example, it is the accumulator (`acc`) variable. It remembers the
    result of the previously run function, applies the `reducer` function and passes
    along to the following step. This is very similar to how the Redux library operates
    on the state.'
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of the `reduce` function is the initial value of the accumulator;
    in the preceding example, we start with zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rise the bar and implement an `average` function using `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we do a trick with the `if` statement. If the element is the
    last one in the array, then we want to calculate `average` instead of the `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: Using reduce to reimplement filter and map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for a little challenge. Did you know that you can implement both `map`
    and `filter` with `reduce`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, let''s do a quick recap how the `filter` function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aaeb5354-b0a9-4851-9e2e-bcb46f67903b.png)'
  prefs: []
  type: TYPE_IMG
- en: How the filter function works on collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a `task` collection and want to filter only tasks with `type`
    equal to `1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With a standard filter function, you would simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But now, imagine there was no `filter` function and, so far, you only had `reduce`
    in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The trick is to make the accumulator into a collection. The previous value is
    always a collection, starting from the empty array. Step by step, we either add
    tasks to the accumulator or simply return the accumulator if the task fails to
    pass the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about implementing the `map` function? `map` just transforms each element
    into a new element by applying a mapping function that is passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4406e918-8437-4cda-beed-c5d8c4f71a4f.png)'
  prefs: []
  type: TYPE_IMG
- en: How the map function works on collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it using `reduce`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we just collect every item again into the same collection,
    but before adding it into the array, we apply a mapping function on it. In this
    example, the mapping function is defined under the name `someFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: Counting items in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next example is about counting the items in an array. Let''s say you have
    an array of house items. You need to count how many of each you own. Using the
    `reduce` function, the expected outcome is an object with items as keys and a
    count of particular items as values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite tricky: the part `(acc[elem] || 0)` means we either take the
    value of `acc[elem]`, if it is defined, or otherwise, `0`. This way, we check
    for the first element of its kind. Also, `{ [elem]: something }` is syntax used
    to define a key with the name that is stored in the `elem` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is helpful when you work with serialized data that came
    from an external API. Sometimes you need to transform it in order to cache it,
    so it avoids unnecessary re-rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The next example introduces a new word—**flattening**. When we flatten a collection,
    it means it is a nested collection in a collection and we want it to make it flat.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a collection such as `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` becomes `[1,
    2, 3, 4, 5, 6, 7, 8, 9]` after flattening. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example is essential to understand flattening in the more complex examples
    that we will use in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we traversed many different collections, even nested
    ones. Now, it's time to learn more about the iterator pattern. This pattern especially
    shines if you plan to use the Redux Saga library.
  prefs: []
  type: TYPE_NORMAL
- en: If you jumped straight to this chapter, I highly advise you to read the section
    that introduces iterator patterns in [Chapter 6](d4c32a64-637b-4e0d-a508-9f239913d5cc.xhtml), *Data
    Transfer Patterns*. That chapter also covers the Redux Saga library and generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, in JavaScript, an iterator is an object that knows how to traverse
    items of a collection one at a time. It must expose the `next()` function, which
    returns the next item of a collection. The collection can be whatever it wants.
    It can even be an infinite collection, such as the Fibonacci numbers, as seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can use this, you need to create an instance of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This could quickly get boring, as it smells like an academic example. But it
    is not. It is useful to show you the algorithm with which we will recreate with
    closure and the `Symbol` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a custom iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a quick recap on symbols in JavaScript: `CallingSymbol()` returns a unique
    symbol value. A symbol value should be treated as an ID, for instance, as an ID
    to be used as a key in an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an iterator for a collection, you need to specify the special key, `Symbol.iterator`.
    If such a symbol is defined, we say that the collection is iterable. See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a custom `iterator` for the Fibonacci collection. The Fibonacci
    sequence is characterized by the fact that every number after the first two is
    the sum of the two preceding ones (the beginning of the sequence is 1, 1, 2, 3,
    5, 8, 13, 21, 34, 55, 89, 144, ...):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To easily traverse iterable collections, we can use the handy `for...of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using generators as a factory for iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will also need to know how to use generators (for instance, for Redux Saga),
    so we should get fluent in writing them. It turns out they can act like a factory
    for the iterators that we have learned already.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick recap on generators—they are functions with `*` and `yield` operators
    within their scope, such as, `function* minGenExample() { yield "a"; }`. Such
    functions execute until the `yield` keyword is encountered. Then, the function
    returns with the `yield` value. Functions can have many `yields`, and on their
    first call, return `Generator`. Such a generator is iterable. Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this knowledge to reimplement Fibonacci as a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We used generator function syntax to simplify things for ourselves.
    The generator function is like a factory for iterators. Once invoked, it will
    provide you with a new generator that you can iterate over like any other collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The piece of code that handles Fibonacci numbers can be simplified. The shortest
    way I could write this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function* fib() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  let n1 = 1, n2 = 1;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  while (true) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    yield n1;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    [n1, n2] = [n2, n1 + n2];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: Making an API call to fetch task details with a generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already tried generators and we have successfully fetched tasks using
    them. Now, we will repeat the process, but with a slightly different goal: to
    fetch the data of a single task. To achieve this, I have made a few changes to
    the code base and prepared the parts of code to keep your eyes on generators only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This generator takes care of the API call first. The endpoint is calculated
    using the payload from a dispatched action. A string template is used for convenience.
    Then, based on the outcome, we either dispatch a success action or an error action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3c663de8-7432-4a98-8402-c20e521ee25e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of the Task Details screen. Feel free to work on the styles.
  prefs: []
  type: TYPE_NORMAL
- en: Please pay attention to the numerous yields in the generator. We stop function
    execution with every yield. In our example, the execution is resumed on a finished
    `call` effect. Then, we can proceed, knowing the result of the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why would we want to stop? Is there any use case for this? First of all,
    it''s more powerful than simple promises and async/await (there will be more on
    this in the following section). Secondly, it is handy to stop and wait for certain
    things to happen. Imagine, for example, that we want to wait until the creation
    of three tasks to display a congratulations message, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example is for playground purposes only. Pay attention to the fact that
    the task creation counter is within the generator function. Hence, is not saved
    in any backend system. On app refresh, the counter will reset. If you build any
    reward system for your application, keep such issues under consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular alternative that has been in JavaScript for years is that of promises.
    The promises use a very similar concept to generators. The syntactic sugar allows
    you to await the promise. If you want this syntactic sugar, then your function
    needs to be `async`. Do you see any similarity? Yeah, I would risk saying that
    promises are a less powerful variation of generators.
  prefs: []
  type: TYPE_NORMAL
- en: If you do use promises, take a look at a new loop called **`for await of`**.
    You may find it handy. Another feature worth checking is **asynchronous iterators**.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we worked with async data again. This data has been
    pushed to the application''s Redux store. We have accessed it numerous times in
    `mapStateToProps` functions, for example, in the task list container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is not looking very ugly, but for the task details page, it already
    is getting out of control. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We do numerous checks and then transformations. This flow happens on every re-render.
    Could we somehow remember the calculations if the data did not change? Yes we
    can—here come cached selectors to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from the Redux store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s face it, we did not have any abstraction on accessing the store so far.
    This means that every `mapStateToProps` function accessed it on its own. In case
    of store shape change, all `mapStateToProps` functions could be affected. The
    first step is to separate the concerns and provide selectors, instead of straightforward
    object access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is just the same as before, with the simple exception that
    we can reuse the code in many places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Even in this little example, we access `tasksSelector` twice in every other
    selector. If `tasksSelector` was expensive, it would be really inefficient. However,
    we will now shield ourselves from such  a scenario by caching the selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To cache the selector, we will use the **memoization** function. Such a function
    recomputes the value once the function''s input reference changes. To save us
    time, we will use a popular library that implements this memoization function
    for us. The library is called `reselect`. In `reselect`, the reference change
    is checked with strong equality (**===**), but you can change the equality function
    to your own if you need. Add the library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we are ready to cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Learning functions from the Ramda library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map, filter, reduce, iterators, generators, and selectors. Not too much, right?
    Don't get too scared, can you speak English using only 10 words? No? Okay, then
    we can proceed with learning some new words that will make us more fluent in JavaScript
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most advertised features of HOCs is their composability. Taking,
    for instance, the `withLogger`, `withAnalytics`, and `withRouter` HOCs, we can
    compose them in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ramda library takes composability to the next level. Unfortunately, I find
    many developers hardly understand it. Let''s look at an equivalent example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What most people find hard about Ramda `compose` is understanding how it works.
    It generally applies functions from right to left, meaning that it first evaluates
    `withRouter` and then forwards results to `withAnalytics`, and so on. The most
    important thing about the functions is that only the first one (`withRouter`)
    can have multiple arguments. Every following function needs to operate on the
    result of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: The Ramda `compose` function composes functions from right to left. To compose
    functions from left to right you can use the Ramda `pipe` function.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of this example to your React or React Native code base is the
    fact that you don't need `reselect` or any other library to compose things. You
    can do it on your own. This will come in handy in use cases such as the `reselect`
    library, which expects you to compose selectors. Spend some time getting used
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Fighting the confusing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next interesting pattern I see in code written by skilled Ramda users is
    so-called **pointfree** code. It means there is only one single place where we
    pass all data. As beautiful as it sounds, I wouldn't recommend you to be so strict
    about it. But there is a nice thing we can derive from this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider refactoring your code from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You could refactor it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will hide the obvious part. The most common problem is that it starts to
    act like a magic box, where only we know how to pass data to it. If you use a
    type system such as TypeScript or Flow, it will be much easier to quickly look
    it up if you have no idea. But, surprisingly, many developers will freak out at
    this point. The less they understand about how `compose` works (particularly the
    right to left function application), the more likely they will have no idea what
    to pass to this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare the previous example to this freak version of `compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, you will probably be able to understand what is happening
    in less than 30 seconds. In the second example, it may take over one minute for
    a beginner to understand the code. This is unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Currying functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, bearing in mind the challenges from the previous section, let's now focus
    on the other side of a coin. In brownfield applications, we may bump into the
    problem that it is very risky or time-consuming to modify a function that we would
    like to use in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Brownfield applications are applications that were developed in the past and
    are fully functional. Some of these applications may be built using old patterns
    or approaches. We cannot usually afford to rewrite them to the latest trend, such
    as React Native. If they are battle-tested, why would we even bother? Hence, we
    will need to find a way to connect both worlds if we decide that a new trend will
    give us enough of a benefit by switching to it for its new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a function that expects you to pass two parameters, but you would like
    to pass one, and then the other later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is tricky if you don''t want to modify the function. However, we could
    write a `util` function that would do this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome. But why bother to write a helper in every such case? It''s time to
    introduce `curry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We made it behave just like we wanted, and we didn't even change
    a single line in the brownfield app function (`oldFunc` or `notCurriedFunc`).
  prefs: []
  type: TYPE_NORMAL
- en: If there are only one or two places in your app where you would use `curry`,
    think twice. Will there be more use cases in the future? If not, it is probably
    overkill to use it. Use the helper arrow functions, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is nice that we can `curry` a function, but what if we wanted to pass arguments
    in a different sequence? For the change of the first two arguments, there is a
    handy function called `flip`, demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we needed to reverse all of the arguments, unfortunately there is no such
    function. But we can write it out nonetheless for our use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into the world of different patterns that are commonly
    found in modern JavaScript, such as iterators, generators, useful reduce use cases,
    selectors, and function composition.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learnt a handful of functions from the Ramda library. Ramda deserves
    much more attention than a few pages of simple use cases. Please have a look at
    it in your free time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use what we have learned here to look at functional
    programming and its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterators and generators article in the Mozilla guide:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reselect documentation FAQ:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/reduxjs/reselect#faq](https://github.com/reduxjs/reselect#faq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Old-school design patterns that are not only used in JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://medium.com/@tkssharma/js-design-patterns-quick-look-fbc9ebfaf9aa](https://medium.com/@tkssharma/js-design-patterns-quick-look-fbc9ebfaf9aa).'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC39 proposal for asynchronous iterators for JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/tc39/proposal-async-iteration](https://github.com/tc39/proposal-async-iteration).'
  prefs: []
  type: TYPE_NORMAL
