- en: Web Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Don''t believe everything you read on the web."– Confucius'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to work on a website together. By working on a
    small project, my aim is to open a window for you to take a peek into what web
    development is, along with the main concepts and tools you should know if you
    want to be successful with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we are going to explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic concepts around web programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of the Flask and Falcon web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: What is the web?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **World Wide Web** (**WWW**), or simply the **web**, is a way of accessing
    information through the use of a medium called the **internet**. The internet
    is a huge network of networks, a networking infrastructure. Its purpose is to
    connect billions of devices together, all around the globe, so that they can communicate
    with one another. Information travels through the internet in a rich variety of
    languages, called **protocols**, that allow different devices to speak the same
    tongue in order to share content.
  prefs: []
  type: TYPE_NORMAL
- en: The web is an information-sharing model, built on top of the internet, which
    employs the **Hypertext Transfer Protocol** (**HTTP**) as a basis for data communication.
    The web, therefore, is just one of several different ways information can be exchanged
    over the internet; email, instant messaging, news groups, and so on, all rely
    on different protocols.
  prefs: []
  type: TYPE_NORMAL
- en: How does the web work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, HTTP is an asymmetric **request-response** **client-server**
    protocol. An HTTP client sends a request message to an HTTP server. The server,
    in turn, returns a response message. In other words, HTTP is a **pull protocol**
    in which the client pulls information from the server (as opposed to a **push
    protocol**, in which the server pushes information down to the client). Take a
    look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTTP is based on **TCP**/**IP** (or the **Transmission Control Protocol**/**Internet
    Protocol**), which provides the tools for a reliable communication exchange.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of the HTTP protocol is that it's *stateless*. This means
    that the current request has no knowledge about what happened in previous requests.
    This is a limitation, but you can browse a website with the illusion of being
    logged in. Under the covers though, what happens is that, on login, a token of
    user information is saved (most often on the client side, in special files called
    **cookies**) so that each request the user makes carries the means for the server
    to recognize the user and provide a custom interface by showing their name, keeping
    their basket populated, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it's very interesting, we're not going to delve into the rich details
    of HTTP and how it works. However, we're going to write a small website, which
    means we'll have to write the code to handle HTTP requests and return HTTP responses.
    I won't keep prepending HTTP to the terms request and response from now on, as
    I trust there won't be any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The Django web framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our project, we''re going to use one of the most popular web frameworks
    you can find in the Python ecosystem: Django.'
  prefs: []
  type: TYPE_NORMAL
- en: A **web framework** is a set of tools (libraries, functions, classes, and so
    on) that we can use to code a website. We need to decide what kind of requests
    we want to allow to be issued against our web server and how we respond to them.
    A web framework is the perfect tool for doing that because it takes care of many
    things for us so that we can concentrate only on the important bits without having
    to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of frameworks. Not all of them are designed for writing
    code for the web. In general, a **framework** is a tool that provides functionalities
    to facilitate the development of software applications, products, and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Django design philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django is designed according to the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t repeat yourself** (**DRY**): Don''t repeat code, and code in a way
    that makes the framework deduce as much as possible from as little as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling**: The various layers of the framework shouldn''t know about
    each other (unless absolutely necessary for whatever reason). Loose coupling works
    best when paralleled with high cohesion. Putting together things which change
    for the same reason, and spreading apart those which change for different reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less code**: Applications should use the least possible amount of code, and
    be written in a way that favors reuse as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: When using the Django framework, regardless of which layer
    you''re coding against, your experience will be very consistent with the design
    patterns and paradigms that were chosen to lay out the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework itself is designed around the **model-template-view** (**MTV**)
    pattern, which is a variant of **model-view-controller** (**MVC**), which is widely
    employed by other frameworks. The purpose of such patterns is to separate concerns
    and promote code reuse and quality.
  prefs: []
  type: TYPE_NORMAL
- en: The model layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the three layers, this is the one that defines the structure of the data
    that is handled by the application, and deals with data sources. A **model** is
    a class that represents a data structure. Through some Django magic, models are
    mapped to database tables so that you can store your data in a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: A **relational database** stores data in tables in which each column is a property
    of the data and each row represents a single item or entry in the collection represented
    by that table. Through the **primary key** of each table, which is that part of
    the data that allows it to uniquely identify each item, it is possible to establish
    relationships between items belonging to different tables, that is, to put them
    into *relation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of this system is that you don''t have to write database-specific
    code in order to handle your data. You just have to configure your models correctly
    and use them. The work on the database is done for you by the Django **object-relational
    mapping** (**ORM**), which takes care of translating operations done on Python
    objects into a language that a relational database can understand: **SQL** (or **Structured
    Query Language**). We saw an example of ORM in [Chapter 7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files
    and Data Persistence*, where we explored SQLAlchemy.'
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of this approach is that you will be able to change databases without
    rewriting your code, since all the database-specific code is produced by Django
    on the fly, according to which database it's connected to. Relational databases
    speak SQL, but each of them has its own unique flavor of it; therefore, not having
    to hardcode any SQL in our application is a tremendous advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Django allows you to modify your models at any time. When you do, you can run
    a command that creates a migration, which is the set of instructions needed to
    port the database in a state that represents the current definition of your models.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this layer deals with defining the data structures you need to
    handle in your website and gives you the means to save and load them from and
    to the database by simply accessing the models, which are Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: The view layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function of a view is handling a request, performing whatever action needs
    to be carried out, and eventually returning a response. For example, if you open
    your browser and request a page corresponding to a category of products in an
    e-commerce shop, the view will likely talk to the database, asking for all the
    categories that are children of the selected category (for example, to display
    them in a navigation sidebar) and for all the products that belong to the selected
    category, in order to display them on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the view is the mechanism through which we can fulfill a request.
    Its result, the response object, can assume several different forms: a JSON payload,
    text, an HTML page, and so on. When you code a website, your responses usually
    consist of HTML or JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Hypertext Markup Language**, or **HTML**, is the standard markup language
    used to create web pages. Web browsers run engines that are capable of interpreting
    HTML code and render it into what we see when we open a page of a website.
  prefs: []
  type: TYPE_NORMAL
- en: The template layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the layer that provides the bridge between backend and frontend development.
    When a view has to return HTML, it usually does it by preparing a **context object**
    (a dictionary) with some data, and then it feeds this context to a template, which
    is rendered (that is to say, transformed into HTML), and returned to the caller
    in the form of a response (more precisely, the body of the response). This mechanism
    allows for maximum code reuse. If you go back to the category example, it's easy
    to see that, if you browse a website that sells products, it doesn't really matter
    which category you click on or what type of search you perform, the layout of
    the products page doesn't change. What does change is the data with which that
    page is populated.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the layout of the page is defined by a template, which is written
    in a mixture of HTML and Django template languages. The view that serves that
    page collects all the products to be displayed in the context dictionary, and
    feeds it to the template, which will be rendered into an HTML page by the Django
    template engine.
  prefs: []
  type: TYPE_NORMAL
- en: The Django URL dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way Django associates a **Uniform Resource Locator** (**URL**) with a view
    is by matching the requested URL with the patterns that are registered in a special
    file. A URL represents a page in a website so `http://mysite.com/categories?id=123`
    would probably point to the page for the category with ID `123` on my website,
    while `https://mysite.com/login` would probably be the user login page.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between HTTP and HTTPS is that the latter adds encryption to
    the protocol so that the data that you exchange with the website is secured. When
    you put your credit card details on a website, or log in anywhere, or do anything
    around sensitive data, you want to make sure that you're using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way Django matches URLs to patterns is through a regular expression. A **regular
    expression** is a sequence of characters that defines a search pattern with which
    we can carry out operations, such as pattern and string matching, and find/replace.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions have a special syntax to indicate things such as digits,
    letters, and spaces, as well as how many times we expect a character to appear,
    and much more. A complete explanation of this topic is outside the scope of this
    book. However, it is a very important subject, so the project we're going to work
    on together will revolve around it, in the hope that you will be stimulated to
    find the time to explore it a bit more on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a quick example, imagine that you wanted to specify a pattern to
    match a date, such as `"26-12-1947"`. This string consists of two digits, one
    dash, two digits, one dash, and finally four digits. Therefore, we could write
    it like this: `r''[0-9]{2}-[0-9]{2}-[0-9]{4}''`. We created a class by using square
    brackets, and we defined a range of digits inside, from `0` to `9`, hence all
    the possible digits. Then, between curly brackets, we say that we expect two of
    them. Then a dash, then we repeat this pattern once as it is, and once more, by
    changing how many digits we expect, and without the final dash. Having a class
    such as `[0-9]` is such a common pattern that a special notation has been created
    as a shortcut: `''\d''`. Therefore, we can rewrite the pattern like this: `r''\d{2}-\d{2}-\d{4}''`
    and it will work exactly the same. That **r** in front of the string stands for
    **raw**, and its purpose is to prevents python from trying to interpret backslash
    escape sequences, so that they can be passed as-is to the regular expression engine.'
  prefs: []
  type: TYPE_NORMAL
- en: A regex website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here we are. We'll code a website that stores regular expressions so that
    we'll be able to play with them a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed with creating the project, I'd like to talk about **Cascading
    Style Sheets** (**CSS**). CSS are files in which we specify how the various elements
    on an HTML page look. You can set all sorts of properties, such as shape, size,
    color, margins, borders, and fonts. In this project, I have tried my best to achieve
    a decent result on the pages, but I'm neither a frontend developer nor a designer,
    so please don't pay too much attention to how things look. Try to focus on how
    they work.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Django website ([https://www.djangoproject.com/](https://www.djangoproject.com/)),
    you can follow the tutorial, which gives you a pretty good idea of Django''s capabilities.
    If you want, you can follow that tutorial first and then come back to this example.
    So, first things first; let''s install Django in your virtual environment (you
    will find it is already installed, as it is part of the requirements file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When this command is done, you can test it within a console (try doing it with
    `bpython`, it gives you a shell similar to IPython but with nice introspection
    capabilities):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that Django is installed, we're good to go. We'll have to do some scaffolding,
    so I'll quickly guide you through that.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choose a folder in the book''s environment and change into that. I''ll use
    `ch14`. From there, we can start a Django project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prepare the skeleton for a Django project called `regex`. Change
    into the `regex` folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to go to `http://127.0.0.1:8000/` with your browser and
    see the It worked! default Django page. This means that the project is correctly
    set up. When you''ve seen the page, kill the server with *Ctrl* + *C* (or whatever
    it says in the console). I''ll paste the final structure for the project now so
    that you can use it as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry if you''re missing files, we''ll get there. A Django project is
    typically a collection of several different applications. Each application is
    meant to provide a functionality in a self-contained, reusable fashion. We''ll
    create just one, called `entries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within the `entries` folder that has been created, you can get rid of the `tests.py`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fix the `regex/settings.py` file in the `regex` folder. We need
    to add our application to the `INSTALLED_APPS` list so that we can use it (add
    it at the bottom of the list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you may want to fix the language and time zone according to your personal
    preference. I live in London, so I set them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing else to do in this file, so you can save and close it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to apply the **migrations** to the database. Django needs database
    support to handle users, sessions, and things like that, so we need to create
    a database and populate it with the necessary data. Luckily, this is very easily
    done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For this project, we use an SQLite database, which is basically just a file.
    On a real project, you would use a different database engine, such as MySQL or
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a database, we can create a superuser using the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering the username and other details, we have a user with admin privileges.
    This is enough to access the Django admin section, so try to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Django development server, which is a very useful built-in
    web server that you can use while working with Django. Now that the server is
    running, we can access the admin page at `http://localhost:8000/admin/`. I will
    show you a screenshot of this section later. If you log in with the credentials
    of the user you just created and head to the Authentication and Authorization
    section, you''ll find Users. Open that and you will be able to see the list of
    users. You can edit the details of any user you want as an admin. In our case,
    make sure you create a different one so that there are at least two users in the
    system (we''ll need them later). I''ll call the first user Fabrizio (username:
    `fab`) and the second one Adriano (username: `adri`), in honor of my father.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you should see that the Django admin panel comes for free automatically.
    You define your models, hook them up, and that's it. This is an incredible tool
    that shows how advanced Django's introspection capabilities are. Moreover, it
    is completely customizable and extendable. It's truly an excellent piece of work.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Entry model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the boilerplate is out of the way, and we have a couple of users,
    we''re ready to code. We start by adding the `Entry` model to our application
    so that we can store objects in the database. Here''s the code you''ll need to
    add (remember to use the project tree for reference):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the model we'll use to store regular expressions in our system. We'll
    store a pattern, a test string, a reference to the user who created the entry,
    and the moment of creation. You can see that creating a model is actually quite
    easy, but nonetheless, let's go through it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to import the `models` module from `django.db`. This will give
    us the base class for our `Entry` model. Django models are special classes and
    much is done for us behind the scenes when we inherit from `models.Model`.
  prefs: []
  type: TYPE_NORMAL
- en: We want a reference to the user who created the entry, so we need to import
    the `User` model from Django's authorization application and we also need to import
    the `timezone` model to get access to the `timezone.now()` function, which provides
    us with a `timezone`-aware version of `datetime.now()`. The beauty of this is
    that it's hooked up with the `TIME_ZONE` settings I showed you before.
  prefs: []
  type: TYPE_NORMAL
- en: As for the primary key for this class, if we don't set one explicitly, Django
    will add one for us. A **primary key** is a key that allows us to uniquely identify
    an `Entry` object in the database (in this case, Django will add an auto-incrementing
    integer ID).
  prefs: []
  type: TYPE_NORMAL
- en: So, we define our class, and we set up four class attributes. We have a `ForeignKey`
    attribute that is our reference to the `User` model. We also have two `CharField`
    attributes that hold the pattern and test strings for our regular expressions.
    We also have `DateTimeField`, whose default value is set to `timezone.now`. Note
    that we don't call `timezone.now` right there, it's `now`, not `now()`. So, we're
    not passing a `DateTime` instance (set at the moment in time when that line is
    parsed) rather, we're passing a callable, a function that is called when we save
    an entry in the database. This is similar to the callback mechanism we used in
    [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe), *GUIs and
    Scripts*, when we were assigning commands to button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines are very interesting. We define a `Meta` class within the
    `Entry` class itself. The `Meta` class is used by Django to provide all sorts
    of extra information for a model. Django has a great deal of logic under the hood
    to adapt its behavior according to the information we put into the `Meta` class.
    In this case, in the admin panel, the pluralized version of `Entry` would be *Entrys*,
    which is wrong, therefore we need to set it manually. We specify the plural in
    all lowercase, as Django takes care of capitalizing it for us when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a new model, we need to update the database to reflect the
    new state of the code. In order to do this, we need to instruct Django that it
    needs to create the code to update the database. This code is called **migration**.
    Let''s create it and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After these two instructions, the database will be ready to store `Entry` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different kinds of migrations: data and schema migrations. **Data
    migrations** port data from one state to another without altering its structure.
    For example, a data migration could set all products for a category as out of
    stock by switching a flag to `False` or `0`. A **schema migration** is a set of
    instructions that alter the structure of the database schema. For example, that
    could be adding an `age` column to a `Person` table, or increasing the maximum
    length of a field to account for very long addresses. When developing with Django,
    it''s quite common to have to perform both kinds of migrations over the course
    of development. Data evolves continuously, especially if you code in an agile
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the admin panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to hook the `Entry` model up with the admin panel. You can
    do it with one line of code, but in this case, I want to add some options to customize
    the way the admin panel shows the entries, both in the list view of all entry
    items in the database and in the form view that allows us to create and modify
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is simply beautiful. My guess is that you probably already understand most
    of it, even if you're new to Django.
  prefs: []
  type: TYPE_NORMAL
- en: So, we start by importing the `admin` module and the `Entry` model. Because
    we want to foster code reuse, we import the `Entry` model using a relative import
    (there's a dot before `models`). This will allow us to move or rename the application
    without too much trouble. Then, we define the `EntryAdmin` class, which inherits
    from `admin.ModelAdmin`. The decoration on the class tells Django to display the
    `Entry` model in the admin panel, and what we put in the `EntryAdmin` class tells
    Django how to customize the way it handles this model.
  prefs: []
  type: TYPE_NORMAL
- en: First, we specify the `fieldsets` for the create/edit page. This will divide
    the page into two sections so that we get a better visualization of the content
    (pattern and test string) and the other details (user and timestamp) separately.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we customize the way the list page displays the results. We want to see
    all the fields, but not the date. We also want to be able to filter on the user
    so that we can have a list of all the entries by just one user, and we want to
    be able to search on `test_string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will go ahead and add three entries, one for myself and two on behalf of
    my father. The result is shown in the next two screenshots. After inserting them,
    the list page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have highlighted the three parts of this view that we customized in the `EntryAdmin`
    class. We can filter by user, we can search, and we have all the fields displayed.
    If you click on a pattern, the edit view opens up.
  prefs: []
  type: TYPE_NORMAL
- en: 'After our customization, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how we have two sections: Regular Expression and Other Information,
    thanks to our custom `EntryAdmin` class. Have a go with it, add some entries to
    a couple of different users, get familiar with the interface. Isn''t it nice to
    have all this for free?'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you fill in your details on a web page, you're inserting data in
    form fields. A **form** is a part of the HTML **Document Object Model** (**DOM**)
    tree. In HTML, you create a form by using the `form` tag. When you click on the
    submit button, your browser normally packs the `form` data together and puts it
    in the body of a `POST` request. As opposed to `GET` requests, which are used
    to ask the web server for a resource, a `POST` request normally sends data to
    the web server with the aim of creating or updating a resource. For this reason,
    handling `POST` requests usually requires more care than `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives data from a `POST` request, that data needs to be validated.
    Moreover, the server needs to employ security mechanisms to protect against various
    types of attacks. One attack that is very dangerous is the **cross-site request
    forgery** (**CSRF**) attack, which happens when data is sent from a domain that
    is not the one the user is authenticated on. Django allows you to handle this
    issue in a very elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of being lazy and using the Django admin to create the entries,
    I'm going to show you how to do it using a Django form. By using the tools the
    framework gives you, you get a very good degree of validation work already done
    (in fact, we won't need to add any custom validation ourselves).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of form classes in Django: `Form` and `ModelForm`. You
    use the former to create a form whose shape and behavior depends on how you code
    the class, what fields you add, and so on. On the other hand, the latter is a
    type of form that, albeit still customizable, infers fields and behavior from
    a model. Since we need a form for the `Entry` model, we''ll use that one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Amazingly enough, this is all we have to do to have a form that we can put on
    a page. The only notable thing here is that we restrict the fields to only `pattern`
    and `test_string`. Only logged-in users will be allowed access to the insert page,
    and therefore we don't need to ask who the user is, we already know that. As for
    the date, when we save an `Entry`, the `date_added` field will be set according
    to its default, therefore we don't need to specify that as well. We'll see in
    the view how to feed the user information to the form before saving. So, now that
    the background work is done, all we need is the views and the templates. Let's
    start with the views.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to write three views. We need one for the home page, one to display
    the list of all entries for a user, and one to create a new entry. We also need
    views to log in and log out. But thanks to Django, we don''t need to write them.
    I''ll paste the code in steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the imports. We need the `re` module to handle regular expressions,
    then we need a few classes and functions from Django, and finally, we need the
    `Entry` model and the `EntryForm` form.
  prefs: []
  type: TYPE_NORMAL
- en: The home view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first view is `HomeView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It inherits from `TemplateView`, which means that the response will be created
    by rendering a template with the context we'll create in the view. All we have
    to do is specify the `template_name` class attribute to point to the correct template.
    Django promotes code reuse to a point that if we didn't need to make this view
    accessible only to logged-in users, the first two lines would have been all we
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we want this view to be accessible only to logged-in users; therefore,
    we need to decorate it with `login_required`. Now, historically views in Django
    were functions; therefore, this decorator was designed to accept a function, and
    not a method like we have in this class. We''re using Django class-based views
    in this project so, in order to make things work, we need to transform `login_required`
    so that it accepts a method (the difference being in the first argument: `self`).
    We do this by passing `login_required` to `method_decorator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to feed the `login_required` decorator with `login_url` information,
    and here comes another wonderful feature of Django. As you''ll see after we''re
    done with the views, in Django, you tie a view to a URL through a pattern, consisting
    of a string which may or may not be a regular expression, and possibly other information.
    You can give a name to each entry in the `urls.py` file so that when you want
    to refer to a URL, you don''t have to hardcode its value into your code. All you
    have to do is get Django to reverse-engineer that URL from the name we gave to
    the entry in `urls.py`, defining the URL and the view that is tied to it. This
    mechanism will become clearer later. For now, just think of `reverse(''...'')`
    as a way of getting a URL from an identifier. In this way, you only write the
    actual URL once, in the `urls.py` file, which is brilliant. In the `views.py`
    code, we need to use `reverse_lazy`, which works exactly like `reverse` with one
    major difference: it only finds the URL when we actually need it (in a lazy fashion).
    The reason why `reverse_lazy` can be so useful is that sometimes it might happen
    that we need to reverse an URL from an identifier, but at the moment we call `reverse`,
    the `urls.py` module hasn''t been loaded yet, which causes a failure. The lazy
    behavior of `reverse_lazy` solves the issue because even if the call is made before
    the `urls.py` module has been loaded, the actual reversing of the identifier,
    to get to the related URL, happens in a lazy fashion, later on, when `urls.py`
    has surely been loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: The `get` method, which we just decorated, simply calls the `get` method of
    the parent class. Of course, the `get` method is the method that Django calls
    when a `GET` request is performed against the URL tied to this view.
  prefs: []
  type: TYPE_NORMAL
- en: The entry list view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This view is much more interesting than the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we decorate the `get` method as we did before. Inside of it,
    we need to prepare a list of `Entry` objects and feed it to the template, which
    shows it to the user. In order to do so, we start by getting the `context` dictionary
    like we''re supposed to do, by calling the `get_context_data` method of the `TemplateView`
    class. Then, we use the ORM to get a list of the entries. We do this by accessing
    the objects manager, and calling a filter on it. We filter the entries according
    to which user is logged in, and we ask for them to be sorted in descending order
    (that `''-''` in front of the name specifies the descending order). The `objects`
    manager is the default **manager** every Django model is augmented with on creation:
    it allows us to interact with the database through its methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We parse each entry to get a list of matches (actually, I coded it so that `matches`
    is a generator expression). Finally, we add to the context an `'entries'` key
    whose value is the coupling of `entries` and `matches`, so that each `Entry` instance
    is paired with the resulting match of its pattern and test string.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, we simply ask Django to render the template using the context
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `_parse_entry` method. All it does is perform a search on
    the `entry.test_string` with the `entry.pattern`. If the resulting `match` object
    is not `None`, it means that we found something. If so, we return a tuple with
    three elements: the overall group, the subgroups, and the group dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `match.groups()` and `match.groupdict()` might return respectively
    an empty tuple and an empty dict. In order to normalize empty results to a simpler `None`,
    I use a common pattern in Python by exploiting the `or` operator. `A or B`, in
    fact, will return `A` if `A` evaluates to a truthy value, or `B` otherwise. Can
    you think how this might differ from the behavior of the `and` operator?
  prefs: []
  type: TYPE_NORMAL
- en: If you're not familiar with those terms, don't worry, you'll see a screenshot
    soon with an example. We return `None` if there is no match (which technically
    is not needed, as Python would do that anyway, but I have included it here for
    the sake of being explicit).
  prefs: []
  type: TYPE_NORMAL
- en: The form view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s examine `EntryFormView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly interesting for a few reasons. First, it shows us a nice
    example of Python's multiple inheritance. We want to display a message on the
    page, after having inserted an `Entry`, so we inherit from `SuccessMessageMixin`.
    But we want to handle a form as well, so we also inherit from `FormView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, when you deal with mixins and inheritance, you may have to consider
    the order in which you specify the base classes in the class declaration, as it
    will affect how methods are found when going up the inheritance chain to serve
    a call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up this view correctly, we need to specify a few attributes
    at the beginning: the template to be rendered, the form class to be used to handle
    the data from the `POST` request, the URL we need to redirect the user to in the
    case of success, and the success message.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature is that this view needs to handle both `GET` and
    `POST` requests. When we land on the form page for the first time, the form is
    empty, and that is the `GET` request. On the other hand, when we fill in the form
    and want to submit the `Entry`, we make a `POST` request. You can see that the
    body of `get` is conceptually identical to `HomeView`. Django does everything
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The `post` method is just like `get`. The only reason we need to code these
    two methods is so that we can decorate them to require login.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Django form-handling process (in the `FormView` class), there are
    a few methods that we can override in order to customize the overall behavior.
    We need to do it with the `form_valid` method. This method will be called when
    the form validation is successful. Its purpose is to save the form so that an
    `Entry` object is created out of it, and then stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that our form is missing the user. We need to intercept
    that moment in the chain of calls and put the user information in ourselves. This
    is done by calling the `_save_with_user` method, which is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: First, we ask Django to save the form with the `commit` argument set to `False`.
    This creates an `Entry` instance without attempting to save it to the database.
    Saving it immediately would fail because the `user` information is not there.
  prefs: []
  type: TYPE_NORMAL
- en: The next line updates the `Entry` instance (`self.object`), adding the `user`
    information and, on the last line, we can safely save it. The reason I called `object`
    and set it on the instance like that was to follow what the original `FormView`
    class does.
  prefs: []
  type: TYPE_NORMAL
- en: We're fiddling with the Django mechanism here, so if we want the whole thing
    to work, we need to pay attention to when and how we modify its behavior, and
    make sure we don't alter it incorrectly. For this reason, it's very important
    to remember to call the `form_valid` method of the base class (we use `super`
    for that) at the end of our own customized version, to make sure that every other
    action that method usually performs is carried out correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the request is tied to each view instance (`self.request`) so that
    we don't need to pass it through when we refactor our logic into methods. Note
    also that the user information has been added to the request automatically by
    Django. Finally, the reason why all the process is split into very small methods
    like these is so that we can only override those that we need to customize. All
    this removes the need to write a lot of code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the views covered, let's see how we couple them to the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Tying up URLs and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `urls.py` module, we tie each view to a URL. There are many ways of
    doing this. I chose the simplest one, which works perfectly for the extent of
    this exercise, but you may want to explore this subject more deeply if you intend
    to work with Django. This is the core around which the whole website logic will
    revolve; therefore, you should try to get it down correctly. Note that the `urls.py`
    module belongs to the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with version 1 of Django, you will notice some differences
    here, as this project is coded in version 2.As you can see, the magic comes from
    the `path` function, which has recently replaced the `url` function. First, we
    pass it a path string (also known as a *route*), then the view, and finally a
    name, which is what we will use in the `reverse` and `reverse_lazy` functions
    to recover the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, when using class-based views, we have to transform them into functions,
    which is what `path` is expecting. To do that, we call the `as_view()` method
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the first `path` entry, for the admin, is special. Instead of
    specifying a URL and a view, it specifies a URL prefix and another `urls.py` module
    (from the `admin.site` package). In this way, Django will complete all the URLs
    for the admin section by prepending `'admin/'` to all the URLs specified in `admin.site.urls`.
    We could have done the same for our entries application (and we should have),
    but I feel it would have been a bit of overkill for this simple project.
  prefs: []
  type: TYPE_NORMAL
- en: The URL paths defined in this module are so simple that they don't require any
    regular expression to be defined. Should you need to use a regular expression,
    you can check out the `re_path` function, which is designed for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We also include login and logout functionalities, by employing views that come
    straight out of the `django.contrib.auth` package. We enrich the declaration with
    the necessary information (such as the next page, for the logout view, for example)
    and we don't need to write a single line of code to handle authentication. This
    is brilliant and saves us a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Each `path` declaration must be done within the `urlpatterns` list and on this
    matter, it's important to consider that, when Django is trying to find a view
    for a URL that has been requested, the patterns are exercised in order, from top
    to bottom. The first one that matches is the one that will provide the view for
    it so, in general, you have to put specific patterns before generic ones, otherwise
    they will never get a chance to be caught. To show you an example that uses regular
    expressions in the route declaration, `'^shop/categories/$'` needs to come before
    `'^shop'` (notice that the `'$'` signals the end of the pattern, and it is not
    specified in the latter), otherwise it would never be called.
  prefs: []
  type: TYPE_NORMAL
- en: So, models, forms, admin, views, and URLs are all done. All that's left is to
    take care of the templates. I'll have to be very brief on this part because HTML
    can be very verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All templates inherit from a base one, which provides the HTML structure for
    all others, in a very **object-oriented programming** (**OOP**) fashion. It also
    specifies a few blocks, which are areas that can be overridden by children so
    that they can provide custom content for those areas. Let''s start with the base
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There is a good reason to repeat the `entries` folder from the `templates` one.
  prefs: []
  type: TYPE_NORMAL
- en: When you deploy a Django website, you collect all the template files under one
    folder. If you don't specify the paths like I did, you may get a `base.html` template
    in the entries application, and a `base.html` template in another app. The last
    one to be collected will override any other file with the same name. For this
    reason, by putting them in a `templates/entries` folder and using this technique
    for each Django application you write, you avoid the risk of name collisions (the
    same goes for any other static file).
  prefs: []
  type: TYPE_NORMAL
- en: There is not much to say about this template, really, apart from the fact that
    it loads the `static` tag so that we can get easy access to the `static` path
    without hardcoding it in the template using `{% static ... %}`. The code in the
    special `{% ... %}` sections is code that defines logic. The code in the special
    `{{ ... }}` represents variables that will be rendered on the page.
  prefs: []
  type: TYPE_NORMAL
- en: We define five blocks: `styles`, `meta`, `title`, `page-content`, and `footer`,
    whose purpose is to hold the metadata, style information, title, the content of
    the page, and the footer, respectively. Blocks can be optionally overridden by
    child templates in order to provide different content within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives us a nice link to the home page, which comes from the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It extends the `base.html` template, and overrides `title` and `page-content`.
    You can see that basically all it does is provide four links to the user. These
    are the list of entries, the insert page, the logout page, and the admin page.
    All of this is done without hardcoding a single URL, through the use of the `{%
    url ... %}` tag, which is the template equivalent of the `reverse` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template for inserting `Entry` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is some conditional logic at the beginning to display messages, if any,
    and then we define the form. Django gives us the ability to render a form by simply
    calling `{{ form.as_p }}` (alternatively, `form.as_ul` or `form.as_table`). This
    creates all the necessary fields and labels for us. The difference between the
    three commands is in the way the form is laid out: as a paragraph, as an unordered
    list, or as a table. We only need to wrap it in form tags and add a submit button.
    This behavior was designed for our convenience: we need the freedom to shape that
    `<form>` tag as we want, so Django isn''t intrusive on that. Also, note that `{%
    csrf_token %}`.'
  prefs: []
  type: TYPE_NORMAL
- en: It will be rendered into a token by Django and will become part of the data
    sent to the server on submission. This way, Django will be able to verify that
    the request was from an allowed source, thus avoiding the aforementioned CSRF
    issue. Did you see how we handled the token when we wrote the view for the `Entry`
    insertion? Exactly. We didn't write a single line of code for it. Django takes
    care of it automatically thanks to a **middleware** class (`CsrfViewMiddleware`).
    Please refer to the official Django documentation ([https://docs.djangoproject.com/en/2.0/](https://docs.djangoproject.com/en/2.0/))
    to explore this subject further.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this page, we also use the footer block to display a link to the home page.
    Finally, we have the list template, which is the most interesting one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It may take you a while to get used to the template language, but really, all
    there is to it is the creation of a table using a `for` loop. We start by checking
    whether there are any entries and, if so, we create a table. There are two columns,
    one for `Entry`, and the other for the match.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Entry` column, we display the `Entry` object (apart from the user),
    and in the `Matches` column, we display that three-tuple we created in the `EntryListView`.
    Note that to access the attributes of an object, we use the same dot syntax we
    use in Python, for example `{{ entry.pattern }}` or `{{ entry.test_string }}`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with lists and tuples, we cannot access items using the square
    brackets syntax, so we use the dot one as well (`{{ match.0 }}` is equivalent
    to `match[0]`, and so on). We also use a filter, through the pipe (`|`) operator
    to display a custom value if a match is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The Django template language (which is not properly Python) is kept simple for
    a precise reason. If you find yourself limited by the language, it means you're
    probably trying to do something in the template that should actually be done in
    the view, where that logic is more pertinent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow me to show you a couple of screenshots of the *list* and *insert* templates.
    This is what the list of entries looks like for my father:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note how the use of the cycle tag alternates the background color of the rows
    from white to light gray. Those classes are defined in the `main.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Entry` insertion page is smart enough to provide a few different scenarios.
    When you land on it at first, it presents you with just an empty form. If you
    fill it in correctly, it will display a nice message for you (see the following
    picture). However, if you fail to fill in both fields, it will display an error
    message before them, alerting you that those fields are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the custom footer, which includes both a link to the entries list
    and a link to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And that's it! You can play around with the CSS styles if you want. Download
    the code for the book and have fun exploring and extending this project. Add something
    else to the model, create and apply a migration, play with the templates, there's
    lots to do!
  prefs: []
  type: TYPE_NORMAL
- en: Django is a very powerful framework, and offers so much more than what I've
    been able to show you in this chapter, so you should definitely check it out.
    The beauty of it is that Django is Python, so reading its source code is a very
    useful exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The future of web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer science is a very young subject, compared to other branches of science
    that have existed alongside humankind for centuries. One of its main characteristics
    is that it moves extremely fast. It leaps forward with such speed that, in just
    a few years, you can see changes that are comparable to real-world changes that
    took a century to happen. Therefore, as a coder, you must pay attention to what
    happens in this world, all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, because powerful computers are quite cheap and almost everyone has
    access to them, the trend is to try to avoid putting too much workload on the
    backend, and let the frontend handle part of it. Therefore, in the last few years,
    JavaScript frameworks and libraries, such as jQuery, Backbone and, more recently,
    React, have become very popular. Web development has shifted from a paradigm where
    the backend takes care of handling data, preparing it, and serving it to the frontend
    to display it, to a paradigm where the backend is sometimes just used as an API,
    a sheer data provider. The frontend fetches the data from the backend with an
    API call, and then it takes care of the rest. This shift facilitates the existence
    of paradigms such as **Single-Page Application** (**SPA**), where, ideally, the
    whole page is loaded once and then evolves, based on the content that usually
    comes from the backend. E-commerce websites that load the results of a search
    in a page that doesn't refresh the surrounding structure are made with similar
    techniques. Browsers can perform asynchronous calls such as **Asynchronous JavaScript
    and XML** (**AJAX**) that can return data that can be read, manipulated, and injected
    back into the page with JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you''re planning to work on web development, I strongly suggest you
    to get acquainted with JavaScript (if you''re not already), and also with APIs.
    In the last few pages of this chapter, I''ll give you an example of how to make
    a simple API using two different Python microframeworks: Flask and Falcon.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Flask view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask ([http://flask.pocoo.org/](http://flask.pocoo.org/)) is a Python microframework.
    It provides far fewer features than Django, but if your project is meant to be
    very small, then it might be a better choice. In my experience though, when developers
    choose Flask at the beginning of a project, they eventually end up adding plugin
    after plugin, until they have what I call a Django Frankenstein project. Being
    agile means having periodically to spend time reducing the technical debt accumulated
    over time. However, switching from Flask to Django can be a daunting operation,
    so when starting a new project, make sure you consider its evolution. My cheeky
    opinion on this matter is very simple: I always go with Django, as I personally
    prefer it to Flask, but you might disagree with me, so I want to offer you an
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `ch14` folder, create a `flask` folder with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we''re going to code two simple files: a Flask application and an
    HTML template. Flask uses Jinja2 as a template engine. It''s extremely popular
    and very fast, to the point that even Django started offering native support for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The template is almost offensively simple. All it does is change the greeting
    according to the presence of the `name` variable. A bit more interesting is the
    Flask application that renders it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We create an `app` object, which is a Flask application. We only feed the fully
    qualified name of the module, which is stored in `__name__`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we write a simple `hello` view, which takes an optional `name` argument.
    In the body of the view, we simply render the `main.html` template, passing to
    it the `name` argument, regardless of its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s interesting is the routing. Differently from Django''s way of tying
    up views and URLs (the `urls.py` module), in `Flask` you decorate your views with
    one or more `@app.route` decorators. In this case, we decorate twice: the first
    line ties the view to the root URL (`/`), while the second line ties the view
    to the root URL with a name information (`/<name>`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `flask` folder and type (make sure you have either installed
    Flask with `$ pip install flask` or by installing the requirements in the source
    code for the book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can open a browser and go to `http://127.0.0.1:5000/`. This URL has no name
    information; therefore, you will see Hello shy person! It is written all nice
    and big. Try to add something to that URL, such as `http://127.0.0.1:5000/Milena`.
    Hit *Enter* and the page will change to Hello Milena! (so you will have said hello
    to my sister).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Flask offers you much more than this, but we don't have the room
    to go through a more complex example. It's definitely worth exploring, though.
    Several projects use it successfully and it's fun and nice to create websites
    or APIs with it. Flask's author, Armin Ronacher, is a successful and very prolific
    coder. He also created or collaborated on several other interesting projects,
    such as Werkzeug, Jinja2, Click, and Sphinx. He also contributed functionalities
    to the Python AST module.
  prefs: []
  type: TYPE_NORMAL
- en: Building a JSON quote server in Falcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falcon ([http://falconframework.org/](http://falconframework.org/)) is another
    microframework written in Python, which was designed to be light, fast, and flexible.
    I have seen this relatively young project evolve to become something really popular
    due to its speed, which is impressive, so I'm happy to show you a tiny example
    using it. We're going to build an API that returns a random quote from the Buddha.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `ch14` folder, create a new one called `falcon`. We''ll have two files:
    `quotes.py` and `main.py`. To run this example, install Falcon and Gunicorn (`$
    pip install falcon gunicorn` or the full requirements for the book). Falcon is
    the framework, and **Gunicorn** (**Green Unicorn**) is a Python WSGI HTTP Server
    for Unix (which, in layman''s terms, means the technology that is used to run
    the server).'
  prefs: []
  type: TYPE_NORMAL
- en: The Web Server Gateway Interface (WSGI) is a simple calling convention for web
    servers to forward requests to web applications or frameworks written in Python.
    If you wish to learn more, please checkout [PEP333](https://www.python.org/dev/peps/pep-0333/),
    which defines the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re all set up, start by creating the `quotes.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You will find the complete list of quotes in the source code for this book.
    If you don't have it, you can instead fill in your favorite quotes. Note that
    not every line has a comma at the end. In Python, it's possible to concatenate
    strings like that, as long as they are in brackets (or braces). It's called **implicit
    concatenation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the main application is not long, but it is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the class. In Django we had a `get` method, in Flask we defined
    a function, and here we write an `on_get` method, a naming style that reminds
    me of Java/C# event handlers. It takes a request and a response argument, both
    automatically fed by the framework. In its body, we define a dictionary with a
    randomly chosen quote, and the author information. Then we dump that dictionary
    to a JSON string and set the response body to its value. We don't need to return
    anything, Falcon will take care of it for us.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we create the Falcon application, and we call `add_route`
    on it to tie the handler we have just written to the URL we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re all set up, change to the `falcon` folder and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make a request (or simply open the page with your browser) to `http://127.0.0.1:8000/quote`.
    When I did it, I got this JSON in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Within the `falcon` folder, I have left a `stress.py` module for you, which
    tests how fast our Falcon code is. See if you can make it work by yourself, it
    should be very easy for you at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever framework you end up using for your web development, try to keep yourself
    informed about other choices too. Sometimes you may be in situations where a different
    framework is the right way to go, and having a working knowledge of different
    tools will give you an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at web development. We talked about important
    concepts, such as the DRY philosophy and the concept of a framework as a tool
    that provides us with many things we need in order to write code to serve requests.
    We also talked about the MTV pattern, and how nicely these three layers play together
    to realize a request-response path.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we briefly introduced regular expressions, which is a subject of paramount
    importance, and it's the layer that provides the tools for URL routing.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different frameworks out there, and Django is definitely one
    of the best and most widely used, so it's worth exploring, especially its source
    code, which is well written.
  prefs: []
  type: TYPE_NORMAL
- en: There are other very interesting and important frameworks too, such as Flask.
    They provide fewer features but might be faster, both in execution time and to
    set up. One that is extremely fast is the Falcon project, whose benchmarks are
    outstanding.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to get a solid understanding of how the request-response mechanism
    works, and how the web in general works, so that eventually it won't matter too
    much which framework you have to use. You will be able to pick it up quickly because
    it will only be a matter of getting familiar with a way of doing something you
    already know a lot about.
  prefs: []
  type: TYPE_NORMAL
- en: Explore at least three frameworks and try to come up with different use cases
    to decide which one of them could be the ideal choice. When you are able to make
    that choice, you will know you have a good enough understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: A farewell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you are still thirsty and that this book will be just the first
    of many steps you take towards Python. It's a truly wonderful language, well worth
    learning deeply.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you enjoyed this journey with me, I did my best to make it interesting
    for you. It sure was for me, I had such a great time writing these pages.
  prefs: []
  type: TYPE_NORMAL
- en: Python is open source, so please keep sharing it and consider supporting the
    wonderful community around it.
  prefs: []
  type: TYPE_NORMAL
- en: Until next time, my friend, farewell!
  prefs: []
  type: TYPE_NORMAL
