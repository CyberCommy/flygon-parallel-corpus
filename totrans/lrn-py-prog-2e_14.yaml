- en: Web Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Don''t believe everything you read on the web."– Confucius'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to work on a website together. By working on a
    small project, my aim is to open a window for you to take a peek into what web
    development is, along with the main concepts and tools you should know if you
    want to be successful with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we are going to explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The basic concepts around web programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django web framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of the Flask and Falcon web frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the fundamentals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What is the web?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **World Wide Web** (**WWW**), or simply the **web**, is a way of accessing
    information through the use of a medium called the **internet**. The internet
    is a huge network of networks, a networking infrastructure. Its purpose is to
    connect billions of devices together, all around the globe, so that they can communicate
    with one another. Information travels through the internet in a rich variety of
    languages, called **protocols**, that allow different devices to speak the same
    tongue in order to share content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The web is an information-sharing model, built on top of the internet, which
    employs the **Hypertext Transfer Protocol** (**HTTP**) as a basis for data communication.
    The web, therefore, is just one of several different ways information can be exchanged
    over the internet; email, instant messaging, news groups, and so on, all rely
    on different protocols.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How does the web work?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, HTTP is an asymmetric **request-response** **client-server**
    protocol. An HTTP client sends a request message to an HTTP server. The server,
    in turn, returns a response message. In other words, HTTP is a **pull protocol**
    in which the client pulls information from the server (as opposed to a **push
    protocol**, in which the server pushes information down to the client). Take a
    look at the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: HTTP is based on **TCP**/**IP** (or the **Transmission Control Protocol**/**Internet
    Protocol**), which provides the tools for a reliable communication exchange.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of the HTTP protocol is that it's *stateless*. This means
    that the current request has no knowledge about what happened in previous requests.
    This is a limitation, but you can browse a website with the illusion of being
    logged in. Under the covers though, what happens is that, on login, a token of
    user information is saved (most often on the client side, in special files called
    **cookies**) so that each request the user makes carries the means for the server
    to recognize the user and provide a custom interface by showing their name, keeping
    their basket populated, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Even though it's very interesting, we're not going to delve into the rich details
    of HTTP and how it works. However, we're going to write a small website, which
    means we'll have to write the code to handle HTTP requests and return HTTP responses.
    I won't keep prepending HTTP to the terms request and response from now on, as
    I trust there won't be any confusion.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Django web framework
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our project, we''re going to use one of the most popular web frameworks
    you can find in the Python ecosystem: Django.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: A **web framework** is a set of tools (libraries, functions, classes, and so
    on) that we can use to code a website. We need to decide what kind of requests
    we want to allow to be issued against our web server and how we respond to them.
    A web framework is the perfect tool for doing that because it takes care of many
    things for us so that we can concentrate only on the important bits without having
    to reinvent the wheel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of frameworks. Not all of them are designed for writing
    code for the web. In general, a **framework** is a tool that provides functionalities
    to facilitate the development of software applications, products, and solutions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Django design philosophy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django is designed according to the following principles:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t repeat yourself** (**DRY**): Don''t repeat code, and code in a way
    that makes the framework deduce as much as possible from as little as possible.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）：不要重复编写代码，并以尽可能从尽可能少的代码中推断出尽可能多的框架。'
- en: '**Loose coupling**: The various layers of the framework shouldn''t know about
    each other (unless absolutely necessary for whatever reason). Loose coupling works
    best when paralleled with high cohesion. Putting together things which change
    for the same reason, and spreading apart those which change for different reasons.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：框架的各个层次不应该彼此了解（除非出于绝对必要的原因）。松耦合最适合与高内聚并行。将因同一原因而改变的事物放在一起，将因不同原因而改变的事物分开。'
- en: '**Less code**: Applications should use the least possible amount of code, and
    be written in a way that favors reuse as much as possible.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**少量代码**：应用程序应尽可能使用最少的代码，并以尽可能有利于重用的方式编写。'
- en: '**Consistency**: When using the Django framework, regardless of which layer
    you''re coding against, your experience will be very consistent with the design
    patterns and paradigms that were chosen to lay out the project.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：使用Django框架时，无论您正在编写哪个层，您的体验都将与选择布置项目的设计模式和范例非常一致。'
- en: The framework itself is designed around the **model-template-view** (**MTV**)
    pattern, which is a variant of **model-view-controller** (**MVC**), which is widely
    employed by other frameworks. The purpose of such patterns is to separate concerns
    and promote code reuse and quality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 框架本身是围绕**模型-模板-视图**（**MTV**）模式设计的，这是**模型-视图-控制器**（**MVC**）的一个变体，其他框架广泛采用。这些模式的目的是分离关注点，促进代码重用和质量。
- en: The model layer
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型层
- en: Of the three layers, this is the one that defines the structure of the data
    that is handled by the application, and deals with data sources. A **model** is
    a class that represents a data structure. Through some Django magic, models are
    mapped to database tables so that you can store your data in a relational database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个层次中，这一层定义了应用程序处理的数据结构，并处理数据源。**模型**是表示数据结构的类。通过一些Django魔术，模型被映射到数据库表，以便您可以将数据存储在关系数据库中。
- en: A **relational database** stores data in tables in which each column is a property
    of the data and each row represents a single item or entry in the collection represented
    by that table. Through the **primary key** of each table, which is that part of
    the data that allows it to uniquely identify each item, it is possible to establish
    relationships between items belonging to different tables, that is, to put them
    into *relation*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库以表格形式存储数据，其中每一列都是数据的属性，每一行代表该表格所代表的集合中的单个项目或条目。通过每个表格的主键，即允许其唯一标识每个项目的数据部分，可以建立不同表格中项目之间的关系，即将它们放入*关系*中。
- en: 'The beauty of this system is that you don''t have to write database-specific
    code in order to handle your data. You just have to configure your models correctly
    and use them. The work on the database is done for you by the Django **object-relational
    mapping** (**ORM**), which takes care of translating operations done on Python
    objects into a language that a relational database can understand: **SQL** (or **Structured
    Query Language**). We saw an example of ORM in [Chapter 7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files
    and Data Persistence*, where we explored SQLAlchemy.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的美妙之处在于，您不必编写特定于数据库的代码来处理数据。您只需正确配置模型并使用它们。Django的**对象关系映射**（**ORM**）为您处理数据库的工作，它负责将在Python对象上执行的操作转换为关系数据库可以理解的语言：**SQL**（或**结构化查询语言**）。我们在[第7章](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe)中看到了ORM的一个例子，即*文件和数据持久性*，在那里我们探讨了SQLAlchemy。
- en: One benefit of this approach is that you will be able to change databases without
    rewriting your code, since all the database-specific code is produced by Django
    on the fly, according to which database it's connected to. Relational databases
    speak SQL, but each of them has its own unique flavor of it; therefore, not having
    to hardcode any SQL in our application is a tremendous advantage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，您可以在不重写代码的情况下更改数据库，因为Django会根据连接的数据库动态生成所有特定于数据库的代码。关系数据库使用SQL，但每个数据库都有其自己独特的风格；因此，在我们的应用程序中不需要硬编码任何SQL是一个巨大的优势。
- en: Django allows you to modify your models at any time. When you do, you can run
    a command that creates a migration, which is the set of instructions needed to
    port the database in a state that represents the current definition of your models.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Django允许您随时修改模型。当您这样做时，您可以运行一个命令来创建一个迁移，这是将数据库移植到表示模型当前定义的状态的一组指令。
- en: To summarize, this layer deals with defining the data structures you need to
    handle in your website and gives you the means to save and load them from and
    to the database by simply accessing the models, which are Python objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这一层处理定义您的网站中需要处理的数据结构，并为您提供通过简单访问模型来保存和加载数据到数据库的手段，这些模型是Python对象。
- en: The view layer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图层
- en: The function of a view is handling a request, performing whatever action needs
    to be carried out, and eventually returning a response. For example, if you open
    your browser and request a page corresponding to a category of products in an
    e-commerce shop, the view will likely talk to the database, asking for all the
    categories that are children of the selected category (for example, to display
    them in a navigation sidebar) and for all the products that belong to the selected
    category, in order to display them on the page.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的功能是处理请求，执行需要执行的任何操作，并最终返回响应。例如，如果您打开浏览器并请求电子商务商店中产品类别对应的页面，视图可能会与数据库交互，请求所有作为所选类别子类的类别（例如，在导航侧栏中显示它们）以及属于所选类别的所有产品，以便在页面上显示它们。
- en: 'Therefore, the view is the mechanism through which we can fulfill a request.
    Its result, the response object, can assume several different forms: a JSON payload,
    text, an HTML page, and so on. When you code a website, your responses usually
    consist of HTML or JSON.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，视图是我们可以满足请求的机制。其结果，响应对象，可以呈现为多种不同形式：JSON有效载荷、文本、HTML页面等。当您编写网站时，您的响应通常由HTML或JSON组成。
- en: The **Hypertext Markup Language**, or **HTML**, is the standard markup language
    used to create web pages. Web browsers run engines that are capable of interpreting
    HTML code and render it into what we see when we open a page of a website.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言**，或**HTML**，是用于创建网页的标准标记语言。Web浏览器运行引擎，能够解释HTML代码并将其呈现为我们在打开网站页面时看到的内容。'
- en: The template layer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板层
- en: This is the layer that provides the bridge between backend and frontend development.
    When a view has to return HTML, it usually does it by preparing a **context object**
    (a dictionary) with some data, and then it feeds this context to a template, which
    is rendered (that is to say, transformed into HTML), and returned to the caller
    in the form of a response (more precisely, the body of the response). This mechanism
    allows for maximum code reuse. If you go back to the category example, it's easy
    to see that, if you browse a website that sells products, it doesn't really matter
    which category you click on or what type of search you perform, the layout of
    the products page doesn't change. What does change is the data with which that
    page is populated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供后端和前端开发之间桥梁的层。当视图必须返回HTML时，通常会通过准备一个**上下文对象**（字典）与一些数据，然后将此上下文提供给模板，模板会被呈现（即转换为HTML），并以响应的形式返回给调用者（更准确地说，是响应的主体）。这种机制允许最大程度地重用代码。如果回到类别的例子，很容易看出，如果您浏览销售产品的网站，您点击哪个类别或执行何种类型的搜索并不重要，产品页面的布局不会改变。改变的是用于填充该页面的数据。
- en: Therefore, the layout of the page is defined by a template, which is written
    in a mixture of HTML and Django template languages. The view that serves that
    page collects all the products to be displayed in the context dictionary, and
    feeds it to the template, which will be rendered into an HTML page by the Django
    template engine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，页面的布局是由模板定义的，该模板是用HTML和Django模板语言编写的混合体。提供页面的视图会在上下文字典中收集所有要显示的产品，并将其提供给模板，然后由Django模板引擎将其呈现为HTML页面。
- en: The Django URL dispatcher
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django URL分发器
- en: The way Django associates a **Uniform Resource Locator** (**URL**) with a view
    is by matching the requested URL with the patterns that are registered in a special
    file. A URL represents a page in a website so `http://mysite.com/categories?id=123`
    would probably point to the page for the category with ID `123` on my website,
    while `https://mysite.com/login` would probably be the user login page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django将**统一资源定位符**（**URL**）与视图关联的方式是通过将请求的URL与注册在特殊文件中的模式进行匹配。URL代表网站中的一个页面，因此`http://mysite.com/categories?id=123`可能指向我的网站上ID为`123`的类别页面，而`https://mysite.com/login`可能是用户登录页面。
- en: The difference between HTTP and HTTPS is that the latter adds encryption to
    the protocol so that the data that you exchange with the website is secured. When
    you put your credit card details on a website, or log in anywhere, or do anything
    around sensitive data, you want to make sure that you're using HTTPS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP和HTTPS之间的区别在于后者为协议添加了加密，以确保您与网站交换的数据是安全的。当您在网站上输入信用卡详细信息，或者在任何地方登录，或者处理敏感数据时，您希望确保您正在使用HTTPS。
- en: Regular expressions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: The way Django matches URLs to patterns is through a regular expression. A **regular
    expression** is a sequence of characters that defines a search pattern with which
    we can carry out operations, such as pattern and string matching, and find/replace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Django将URL与模式匹配的方式是通过正则表达式。**正则表达式**是一系列字符，用于定义搜索模式，我们可以执行操作，如模式和字符串匹配，查找/替换等。
- en: Regular expressions have a special syntax to indicate things such as digits,
    letters, and spaces, as well as how many times we expect a character to appear,
    and much more. A complete explanation of this topic is outside the scope of this
    book. However, it is a very important subject, so the project we're going to work
    on together will revolve around it, in the hope that you will be stimulated to
    find the time to explore it a bit more on your own.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式具有特殊的语法，用于指示诸如数字、字母和空格等内容，以及我们期望字符出现的次数等内容。本书不涵盖此主题的完整解释。然而，这是一个非常重要的主题，因此我们将一起开展的项目将围绕它展开，希望您能有时间自行探索一下。
- en: 'To give you a quick example, imagine that you wanted to specify a pattern to
    match a date, such as `"26-12-1947"`. This string consists of two digits, one
    dash, two digits, one dash, and finally four digits. Therefore, we could write
    it like this: `r''[0-9]{2}-[0-9]{2}-[0-9]{4}''`. We created a class by using square
    brackets, and we defined a range of digits inside, from `0` to `9`, hence all
    the possible digits. Then, between curly brackets, we say that we expect two of
    them. Then a dash, then we repeat this pattern once as it is, and once more, by
    changing how many digits we expect, and without the final dash. Having a class
    such as `[0-9]` is such a common pattern that a special notation has been created
    as a shortcut: `''\d''`. Therefore, we can rewrite the pattern like this: `r''\d{2}-\d{2}-\d{4}''`
    and it will work exactly the same. That **r** in front of the string stands for
    **raw**, and its purpose is to prevents python from trying to interpret backslash
    escape sequences, so that they can be passed as-is to the regular expression engine.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 举个快速的例子，假设您想指定一个匹配日期的模式，比如 `"26-12-1947"`。这个字符串由两个数字、一个破折号、两个数字、一个破折号，最后是四个数字。因此，我们可以这样写：`r'[0-9]{2}-[0-9]{2}-[0-9]{4}'`。我们使用方括号创建了一个类，并在其中定义了一个数字范围，从
    `0` 到 `9`，因此包括了所有可能的数字。然后，在花括号中，我们说我们期望其中有两个。然后是一个破折号，然后我们重复这个模式一次，然后再一次，通过改变我们期望的数字数量，而最后没有破折号。拥有一个类，比如
    `[0-9]` 是一个如此常见的模式，以至于已经创建了一个特殊的符号作为快捷方式：`'\d'`。因此，我们可以这样重写这个模式：`r'\d{2}-\d{2}-\d{4}'`，它将完全相同地工作。字符串前面的那个
    **r** 代表 **原始**，它的目的是防止 Python 尝试解释反斜杠转义序列，以便它们可以原样传递给正则表达式引擎。
- en: A regex website
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个正则表达式网站
- en: So, here we are. We'll code a website that stores regular expressions so that
    we'll be able to play with them a little bit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们要编写一个网站，用于存储正则表达式，以便我们可以稍微玩一下。
- en: Before we proceed with creating the project, I'd like to talk about **Cascading
    Style Sheets** (**CSS**). CSS are files in which we specify how the various elements
    on an HTML page look. You can set all sorts of properties, such as shape, size,
    color, margins, borders, and fonts. In this project, I have tried my best to achieve
    a decent result on the pages, but I'm neither a frontend developer nor a designer,
    so please don't pay too much attention to how things look. Try to focus on how
    they work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建项目之前，我想谈谈 **层叠样式表**（**CSS**）。CSS 是我们在其中指定 HTML 页面上各种元素的外观的文件。您可以设置各种属性，比如形状、大小、颜色、边距、边框和字体。在这个项目中，我已经尽力在页面上取得了一个体面的结果，但我既不是前端开发人员也不是设计师，所以请不要太在意事物的外观。请尽量关注它们的工作原理。
- en: Setting up Django
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Django
- en: 'On the Django website ([https://www.djangoproject.com/](https://www.djangoproject.com/)),
    you can follow the tutorial, which gives you a pretty good idea of Django''s capabilities.
    If you want, you can follow that tutorial first and then come back to this example.
    So, first things first; let''s install Django in your virtual environment (you
    will find it is already installed, as it is part of the requirements file):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 网站 ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    上，您可以按照教程，这会让您对 Django 的功能有一个很好的了解。如果您愿意，您可以先按照该教程操作，然后再回到这个例子。所以，首先要做的事情是；让我们在您的虚拟环境中安装
    Django（您会发现它已经安装好了，因为它是要求文件的一部分）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When this command is done, you can test it within a console (try doing it with
    `bpython`, it gives you a shell similar to IPython but with nice introspection
    capabilities):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个命令完成后，您可以在控制台中测试它（尝试使用 `bpython`，它会给您一个类似于 IPython 但具有良好内省能力的 shell）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that Django is installed, we're good to go. We'll have to do some scaffolding,
    so I'll quickly guide you through that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Django 已经安装好了，我们可以开始了。我们需要做一些搭建工作，所以我会快速指导您完成。
- en: Starting the project
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'Choose a folder in the book''s environment and change into that. I''ll use
    `ch14`. From there, we can start a Django project with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择书中环境中的一个文件夹并切换到其中。我会使用 `ch14`。从那里，我们可以使用以下命令启动一个 Django 项目：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will prepare the skeleton for a Django project called `regex`. Change
    into the `regex` folder and run the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为一个名为 `regex` 的 Django 项目准备好骨架。切换到 `regex` 文件夹并运行以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should be able to go to `http://127.0.0.1:8000/` with your browser and
    see the It worked! default Django page. This means that the project is correctly
    set up. When you''ve seen the page, kill the server with *Ctrl* + *C* (or whatever
    it says in the console). I''ll paste the final structure for the project now so
    that you can use it as a reference:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在浏览器中输入 `http://127.0.0.1:8000/` 并看到 It worked! 默认的 Django 页面。这意味着项目已经正确设置。当您看到页面后，使用
    *Ctrl* + *C* 杀死服务器（或者控制台上显示的其他指令）。我现在将粘贴项目的最终结构，以便您可以用作参考：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry if you''re missing files, we''ll get there. A Django project is
    typically a collection of several different applications. Each application is
    meant to provide a functionality in a self-contained, reusable fashion. We''ll
    create just one, called `entries`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您缺少文件，不要担心，我们会解决的。一个 Django 项目通常是由几个不同的应用程序集合组成的。每个应用程序都旨在以一种独立的、可重用的方式提供功能。我们将创建一个名为
    `entries` 的应用程序：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within the `entries` folder that has been created, you can get rid of the `tests.py`
    module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的 `entries` 文件夹中，您可以删除 `tests.py` 模块。
- en: 'Now, let''s fix the `regex/settings.py` file in the `regex` folder. We need
    to add our application to the `INSTALLED_APPS` list so that we can use it (add
    it at the bottom of the list):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复 `regex/settings.py` 文件在 `regex` 文件夹中。我们需要将我们的应用程序添加到 `INSTALLED_APPS`
    列表中，以便我们可以使用它（将其添加到列表的底部）：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you may want to fix the language and time zone according to your personal
    preference. I live in London, so I set them like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可能想根据个人喜好设置语言和时区。我住在伦敦，所以我设置它们如下：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is nothing else to do in this file, so you can save and close it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中没有其他事情要做，所以您可以保存并关闭它。
- en: 'Now it''s time to apply the **migrations** to the database. Django needs database
    support to handle users, sessions, and things like that, so we need to create
    a database and populate it with the necessary data. Luckily, this is very easily
    done with the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将**迁移**应用到数据库了。Django需要数据库支持来处理用户、会话等内容，所以我们需要创建一个数据库并用必要的数据填充它。幸运的是，这可以很容易地通过以下命令完成：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this project, we use an SQLite database, which is basically just a file.
    On a real project, you would use a different database engine, such as MySQL or
    PostgreSQL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们使用SQLite数据库，它基本上只是一个文件。在一个真正的项目中，你会使用不同的数据库引擎，比如MySQL或PostgreSQL。
- en: Creating users
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'Now that we have a database, we can create a superuser using the console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数据库，我们可以使用控制台创建一个超级用户：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After entering the username and other details, we have a user with admin privileges.
    This is enough to access the Django admin section, so try to start the server:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名和其他细节后，我们有了一个具有管理员特权的用户。这足以访问Django管理部分，所以尝试启动服务器：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will start the Django development server, which is a very useful built-in
    web server that you can use while working with Django. Now that the server is
    running, we can access the admin page at `http://localhost:8000/admin/`. I will
    show you a screenshot of this section later. If you log in with the credentials
    of the user you just created and head to the Authentication and Authorization
    section, you''ll find Users. Open that and you will be able to see the list of
    users. You can edit the details of any user you want as an admin. In our case,
    make sure you create a different one so that there are at least two users in the
    system (we''ll need them later). I''ll call the first user Fabrizio (username:
    `fab`) and the second one Adriano (username: `adri`), in honor of my father.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Django开发服务器，这是一个非常有用的内置Web服务器，你可以在使用Django时使用它。现在服务器正在运行，我们可以在`http://localhost:8000/admin/`访问管理页面。稍后我会向你展示这部分的截图。如果你用刚刚创建的用户的凭据登录并转到身份验证和授权部分，你会找到用户。打开它，你就能看到用户列表。你可以作为管理员编辑任何用户的细节。在我们的情况下，请确保你创建一个不同的用户，这样系统中至少有两个用户（我们以后会需要）。我会称第一个用户为Fabrizio（用户名：`fab`），第二个用户为Adriano（用户名：`adri`），以纪念我的父亲。
- en: By the way, you should see that the Django admin panel comes for free automatically.
    You define your models, hook them up, and that's it. This is an incredible tool
    that shows how advanced Django's introspection capabilities are. Moreover, it
    is completely customizable and extendable. It's truly an excellent piece of work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你应该看到Django管理面板是自动免费提供的。你定义你的模型，连接它们，就这样。这是一个令人难以置信的工具，显示了Django的内省能力有多么先进。而且，它是完全可定制和可扩展的。这真是一项出色的工作。
- en: Adding the Entry model
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Entry模型
- en: 'Now that the boilerplate is out of the way, and we have a couple of users,
    we''re ready to code. We start by adding the `Entry` model to our application
    so that we can store objects in the database. Here''s the code you''ll need to
    add (remember to use the project tree for reference):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然样板代码已经完成，我们有了一些用户，我们准备好编码了。我们首先要将`Entry`模型添加到我们的应用程序中，以便我们可以将对象存储在数据库中。以下是你需要添加的代码（记得使用项目树作为参考）：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the model we'll use to store regular expressions in our system. We'll
    store a pattern, a test string, a reference to the user who created the entry,
    and the moment of creation. You can see that creating a model is actually quite
    easy, but nonetheless, let's go through it line by line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来在系统中存储正则表达式的模型。我们将存储一个模式、一个测试字符串、对创建条目的用户的引用以及创建的时刻。你可以看到创建一个模型实际上是相当容易的，但尽管如此，让我们逐行过一遍。
- en: First we need to import the `models` module from `django.db`. This will give
    us the base class for our `Entry` model. Django models are special classes and
    much is done for us behind the scenes when we inherit from `models.Model`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`django.db`中导入`models`模块。这将为我们提供`Entry`模型的基类。Django模型是特殊的类，当我们从`models.Model`继承时，很多工作都是在幕后为我们完成的。
- en: We want a reference to the user who created the entry, so we need to import
    the `User` model from Django's authorization application and we also need to import
    the `timezone` model to get access to the `timezone.now()` function, which provides
    us with a `timezone`-aware version of `datetime.now()`. The beauty of this is
    that it's hooked up with the `TIME_ZONE` settings I showed you before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对创建条目的用户的引用，所以我们需要从Django的授权应用程序中导入`User`模型，我们还需要导入`timezone`模型以访问`timezone.now()`函数，该函数为我们提供了`datetime.now()`的`timezone`-aware版本。这样做的美妙之处在于它与我之前向你展示的`TIME_ZONE`设置相连。
- en: As for the primary key for this class, if we don't set one explicitly, Django
    will add one for us. A **primary key** is a key that allows us to uniquely identify
    an `Entry` object in the database (in this case, Django will add an auto-incrementing
    integer ID).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 至于这个类的主键，如果我们不明确设置一个，Django会为我们添加一个。**主键**是一个允许我们在数据库中唯一标识`Entry`对象的键（在这种情况下，Django将添加一个自增的整数ID）。
- en: So, we define our class, and we set up four class attributes. We have a `ForeignKey`
    attribute that is our reference to the `User` model. We also have two `CharField`
    attributes that hold the pattern and test strings for our regular expressions.
    We also have `DateTimeField`, whose default value is set to `timezone.now`. Note
    that we don't call `timezone.now` right there, it's `now`, not `now()`. So, we're
    not passing a `DateTime` instance (set at the moment in time when that line is
    parsed) rather, we're passing a callable, a function that is called when we save
    an entry in the database. This is similar to the callback mechanism we used in
    [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe), *GUIs and
    Scripts*, when we were assigning commands to button clicks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了我们的类，并设置了四个类属性。我们有一个`ForeignKey`属性，它是我们对`User`模型的引用。我们还有两个`CharField`属性，用于保存我们的正则表达式的模式和测试字符串。我们还有一个`DateTimeField`，其默认值设置为`timezone.now`。请注意，我们不在那里调用`timezone.now`，它是`now`，而不是`now()`。因此，我们不是传递一个`DateTime`实例（在解析该行时设置的时间点），而是传递一个可调用的函数，在保存数据库中的条目时调用该函数。这类似于我们在[第12章](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe)中使用的回调机制，*GUIs
    and Scripts*，当我们将命令分配给按钮点击时。
- en: The last two lines are very interesting. We define a `Meta` class within the
    `Entry` class itself. The `Meta` class is used by Django to provide all sorts
    of extra information for a model. Django has a great deal of logic under the hood
    to adapt its behavior according to the information we put into the `Meta` class.
    In this case, in the admin panel, the pluralized version of `Entry` would be *Entrys*,
    which is wrong, therefore we need to set it manually. We specify the plural in
    all lowercase, as Django takes care of capitalizing it for us when needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行非常有趣。我们在`Entry`类本身内部定义了一个`Meta`类。`Meta`类被Django用来为模型提供各种额外信息。Django在幕后有很多逻辑，根据我们放入`Meta`类的信息来调整其行为。在这种情况下，在管理面板中，`Entry`的复数形式将是*Entrys*，这是错误的，因此我们需要手动设置它。我们将复数形式指定为全部小写，因为Django在需要时会为我们大写它。
- en: 'Now that we have a new model, we need to update the database to reflect the
    new state of the code. In order to do this, we need to instruct Django that it
    needs to create the code to update the database. This code is called **migration**.
    Let''s create it and execute it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新模型，我们需要更新数据库以反映代码的新状态。为了做到这一点，我们需要告诉Django它需要创建更新数据库的代码。这段代码被称为**迁移**。让我们创建并执行它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After these two instructions, the database will be ready to store `Entry` objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个指令之后，数据库将准备好存储`Entry`对象。
- en: 'There are two different kinds of migrations: data and schema migrations. **Data
    migrations** port data from one state to another without altering its structure.
    For example, a data migration could set all products for a category as out of
    stock by switching a flag to `False` or `0`. A **schema migration** is a set of
    instructions that alter the structure of the database schema. For example, that
    could be adding an `age` column to a `Person` table, or increasing the maximum
    length of a field to account for very long addresses. When developing with Django,
    it''s quite common to have to perform both kinds of migrations over the course
    of development. Data evolves continuously, especially if you code in an agile
    environment.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同类型的迁移：数据迁移和模式迁移。**数据迁移**将数据从一种状态转移到另一种状态，而不改变其结构。例如，数据迁移可以通过将标志切换为`False`或`0`来将某个类别的所有产品设置为缺货。**模式迁移**是一组指令，用于改变数据库模式的结构。例如，可以向`Person`表添加一个`age`列，或者增加字段的最大长度以适应非常长的地址。在使用Django进行开发时，通常需要在开发过程中执行这两种类型的迁移。数据不断发展，特别是在敏捷环境中编码时。
- en: Customizing the admin panel
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管理面板
- en: The next step is to hook the `Entry` model up with the admin panel. You can
    do it with one line of code, but in this case, I want to add some options to customize
    the way the admin panel shows the entries, both in the list view of all entry
    items in the database and in the form view that allows us to create and modify
    them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`Entry`模型与管理面板连接起来。您可以用一行代码做到这一点，但在这种情况下，我想添加一些选项来自定义管理面板显示条目的方式，无论是在数据库中的所有条目的列表视图中，还是在允许我们创建和修改它们的表单视图中。
- en: 'All we need to do is to add the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要添加以下代码：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is simply beautiful. My guess is that you probably already understand most
    of it, even if you're new to Django.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太美了。我猜你可能已经理解了大部分内容，即使你是Django的新手。
- en: So, we start by importing the `admin` module and the `Entry` model. Because
    we want to foster code reuse, we import the `Entry` model using a relative import
    (there's a dot before `models`). This will allow us to move or rename the application
    without too much trouble. Then, we define the `EntryAdmin` class, which inherits
    from `admin.ModelAdmin`. The decoration on the class tells Django to display the
    `Entry` model in the admin panel, and what we put in the `EntryAdmin` class tells
    Django how to customize the way it handles this model.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先导入`admin`模块和`Entry`模型。因为我们想要促进代码重用，我们使用相对导入导入`Entry`模型（在`models`之前有一个点）。这将使我们能够在不太麻烦的情况下移动或重命名应用程序。然后，我们定义`EntryAdmin`类，它继承自`admin.ModelAdmin`。类上的装饰告诉Django在管理面板中显示`Entry`模型，我们在`EntryAdmin`类中放入的内容告诉Django如何自定义处理这个模型。
- en: First, we specify the `fieldsets` for the create/edit page. This will divide
    the page into two sections so that we get a better visualization of the content
    (pattern and test string) and the other details (user and timestamp) separately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为创建/编辑页面指定`fieldsets`。这将把页面分成两个部分，以便我们更好地可视化内容（模式和测试字符串）和其他细节（用户和时间戳）分开。
- en: Then, we customize the way the list page displays the results. We want to see
    all the fields, but not the date. We also want to be able to filter on the user
    so that we can have a list of all the entries by just one user, and we want to
    be able to search on `test_string`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们自定义列表页面显示结果的方式。我们想要看到所有字段，但不包括日期。我们还希望能够按用户进行筛选，以便我们可以列出一个用户的所有条目，并且我们希望能够在`test_string`上进行搜索。
- en: 'I will go ahead and add three entries, one for myself and two on behalf of
    my father. The result is shown in the next two screenshots. After inserting them,
    the list page looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续添加三个条目，一个是我自己的，另外两个是我父亲的。结果显示在接下来的两个屏幕截图中。插入它们后，列表页面如下所示：
- en: '![](../images/00027.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: I have highlighted the three parts of this view that we customized in the `EntryAdmin`
    class. We can filter by user, we can search, and we have all the fields displayed.
    If you click on a pattern, the edit view opens up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了我们在`EntryAdmin`类中自定义的此视图的三个部分。我们可以按用户筛选，可以搜索，并且所有字段都显示出来。如果单击模式，则会打开编辑视图。
- en: 'After our customization, it looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义之后，它看起来像这样：
- en: '![](../images/00028.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'Notice how we have two sections: Regular Expression and Other Information,
    thanks to our custom `EntryAdmin` class. Have a go with it, add some entries to
    a couple of different users, get familiar with the interface. Isn''t it nice to
    have all this for free?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们有两个部分：正则表达式和其他信息，这要归功于我们自定义的`EntryAdmin`类。试一试，为几个不同的用户添加一些条目，熟悉界面。免费获得所有这些东西是不是很好？
- en: Creating the form
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表单
- en: Every time you fill in your details on a web page, you're inserting data in
    form fields. A **form** is a part of the HTML **Document Object Model** (**DOM**)
    tree. In HTML, you create a form by using the `form` tag. When you click on the
    submit button, your browser normally packs the `form` data together and puts it
    in the body of a `POST` request. As opposed to `GET` requests, which are used
    to ask the web server for a resource, a `POST` request normally sends data to
    the web server with the aim of creating or updating a resource. For this reason,
    handling `POST` requests usually requires more care than `GET` requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您在网页上填写详细信息时，您都在表单字段中插入数据。**表单**是HTML **文档对象模型**（**DOM**）树的一部分。在HTML中，您可以使用`form`标签创建一个表单。当您单击提交按钮时，您的浏览器通常会将`form`数据打包在一起，并将其放入`POST`请求的正文中。与用于向Web服务器请求资源的`GET`请求相反，`POST`请求通常会将数据发送到Web服务器，目的是创建或更新资源。因此，处理`POST`请求通常需要比处理`GET`请求更多的注意。
- en: When the server receives data from a `POST` request, that data needs to be validated.
    Moreover, the server needs to employ security mechanisms to protect against various
    types of attacks. One attack that is very dangerous is the **cross-site request
    forgery** (**CSRF**) attack, which happens when data is sent from a domain that
    is not the one the user is authenticated on. Django allows you to handle this
    issue in a very elegant way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到来自`POST`请求的数据时，需要对这些数据进行验证。此外，服务器需要采用安全机制来防范各种类型的攻击。一种非常危险的攻击是**跨站点请求伪造**（**CSRF**）攻击，当数据从未经用户认证的域发送时就会发生。Django允许您以非常优雅的方式处理这个问题。
- en: So, instead of being lazy and using the Django admin to create the entries,
    I'm going to show you how to do it using a Django form. By using the tools the
    framework gives you, you get a very good degree of validation work already done
    (in fact, we won't need to add any custom validation ourselves).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其懒惰地使用Django管理员来创建条目，我将向您展示如何使用Django表单来完成。通过使用框架提供的工具，您已经完成了非常好的验证工作（实际上，我们不需要添加任何自定义验证）。
- en: 'There are two kinds of form classes in Django: `Form` and `ModelForm`. You
    use the former to create a form whose shape and behavior depends on how you code
    the class, what fields you add, and so on. On the other hand, the latter is a
    type of form that, albeit still customizable, infers fields and behavior from
    a model. Since we need a form for the `Entry` model, we''ll use that one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中有两种形式类：`Form`和`ModelForm`。您可以使用前者创建一个表单，其形状和行为取决于您如何编写类，添加哪些字段等。另一方面，后者是一种类型的表单，尽管仍然可定制，但是从模型中推断字段和行为。由于我们需要一个`Entry`模型的表单，我们将使用这个：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Amazingly enough, this is all we have to do to have a form that we can put on
    a page. The only notable thing here is that we restrict the fields to only `pattern`
    and `test_string`. Only logged-in users will be allowed access to the insert page,
    and therefore we don't need to ask who the user is, we already know that. As for
    the date, when we save an `Entry`, the `date_added` field will be set according
    to its default, therefore we don't need to specify that as well. We'll see in
    the view how to feed the user information to the form before saving. So, now that
    the background work is done, all we need is the views and the templates. Let's
    start with the views.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这就是我们需要做的一切，就可以在页面上放置一个表单。这里唯一值得注意的是，我们将字段限制为`pattern`和`test_string`。只有已登录的用户才能访问插入页面，因此我们不需要询问用户是谁，我们已经知道了。至于日期，当我们保存一个`Entry`时，`date_added`字段将根据其默认设置，因此我们也不需要指定。我们将在视图中看到如何在保存之前向表单提供用户信息。因此，现在背景工作已经完成，我们所需要的只是视图和模板。让我们从视图开始。
- en: Writing the views
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写视图
- en: 'We need to write three views. We need one for the home page, one to display
    the list of all entries for a user, and one to create a new entry. We also need
    views to log in and log out. But thanks to Django, we don''t need to write them.
    I''ll paste the code in steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写三个视图。我们需要一个用于主页的视图，一个用于显示用户的所有条目的列表，以及一个用于创建新条目的视图。我们还需要登录和注销视图。但幸运的是，由于Django，我们不需要编写它们。我将逐步粘贴代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's start with the imports. We need the `re` module to handle regular expressions,
    then we need a few classes and functions from Django, and finally, we need the
    `Entry` model and the `EntryForm` form.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始。我们需要`re`模块来处理正则表达式，然后我们需要从Django中导入一些类和函数，最后，我们需要`Entry`模型和`EntryForm`表单。
- en: The home view
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页视图
- en: 'The first view is `HomeView`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视图是`HomeView`：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It inherits from `TemplateView`, which means that the response will be created
    by rendering a template with the context we'll create in the view. All we have
    to do is specify the `template_name` class attribute to point to the correct template.
    Django promotes code reuse to a point that if we didn't need to make this view
    accessible only to logged-in users, the first two lines would have been all we
    needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它继承自`TemplateView`，这意味着响应将通过渲染视图中创建的上下文来创建。我们所要做的就是指定`template_name`类属性，指向正确的模板。Django在代码重用方面的推广程度达到了一个程度，以至于如果我们不需要使此视图仅对已登录用户可访问，前两行就足够了。
- en: 'However, we want this view to be accessible only to logged-in users; therefore,
    we need to decorate it with `login_required`. Now, historically views in Django
    were functions; therefore, this decorator was designed to accept a function, and
    not a method like we have in this class. We''re using Django class-based views
    in this project so, in order to make things work, we need to transform `login_required`
    so that it accepts a method (the difference being in the first argument: `self`).
    We do this by passing `login_required` to `method_decorator`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望此视图仅对已登录用户可访问；因此，我们需要用`login_required`进行装饰。现在，历史上Django中的视图是函数；因此，这个装饰器是设计为接受一个函数的，而不是我们在这个类中拥有的方法。在这个项目中，我们使用Django基于类的视图，因此为了使事情正常工作，我们需要转换`login_required`，以便它接受一个方法（不同之处在于第一个参数：`self`）。我们通过将`login_required`传递给`method_decorator`来实现这一点。
- en: 'We also need to feed the `login_required` decorator with `login_url` information,
    and here comes another wonderful feature of Django. As you''ll see after we''re
    done with the views, in Django, you tie a view to a URL through a pattern, consisting
    of a string which may or may not be a regular expression, and possibly other information.
    You can give a name to each entry in the `urls.py` file so that when you want
    to refer to a URL, you don''t have to hardcode its value into your code. All you
    have to do is get Django to reverse-engineer that URL from the name we gave to
    the entry in `urls.py`, defining the URL and the view that is tied to it. This
    mechanism will become clearer later. For now, just think of `reverse(''...'')`
    as a way of getting a URL from an identifier. In this way, you only write the
    actual URL once, in the `urls.py` file, which is brilliant. In the `views.py`
    code, we need to use `reverse_lazy`, which works exactly like `reverse` with one
    major difference: it only finds the URL when we actually need it (in a lazy fashion).
    The reason why `reverse_lazy` can be so useful is that sometimes it might happen
    that we need to reverse an URL from an identifier, but at the moment we call `reverse`,
    the `urls.py` module hasn''t been loaded yet, which causes a failure. The lazy
    behavior of `reverse_lazy` solves the issue because even if the call is made before
    the `urls.py` module has been loaded, the actual reversing of the identifier,
    to get to the related URL, happens in a lazy fashion, later on, when `urls.py`
    has surely been loaded.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向`login_required`装饰器提供`login_url`信息，这里又出现了Django的另一个精彩特性。正如在我们完成视图后所看到的那样，在Django中，您通过模式将视图绑定到URL，该模式由一个字符串组成，该字符串可能是正则表达式，也可能是其他信息。您可以在`urls.py`文件中为每个条目指定一个名称，以便在引用URL时，您不必将其值硬编码到代码中。您只需让Django从我们在`urls.py`中为条目指定的名称中反向工程出该URL，定义URL和绑定到它的视图。这种机制稍后将变得更加清晰。现在，只需将`reverse('...')`视为从标识符获取URL的一种方式。通过这种方式，您只需在`urls.py`文件中写入实际的URL一次，这是非常出色的。在`views.py`代码中，我们需要使用`reverse_lazy`，它的工作原理与`reverse`完全相同，只有一个主要区别：它只在我们实际需要时才找到URL（以懒惰的方式）。`reverse_lazy`之所以如此有用的原因是，有时可能需要从标识符反转URL，但在调用`reverse`时，`urls.py`模块尚未加载，这会导致失败。`reverse_lazy`的懒惰行为解决了这个问题，因为即使在`urls.py`模块加载之前进行调用，从标识符反转到相关URL的实际过程也是以懒惰的方式进行的，稍后，当`urls.py`肯定已经加载时。
- en: The `get` method, which we just decorated, simply calls the `get` method of
    the parent class. Of course, the `get` method is the method that Django calls
    when a `GET` request is performed against the URL tied to this view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚装饰的`get`方法只是简单地调用了父类的`get`方法。当然，`get`方法是Django在针对与此视图绑定的URL执行`GET`请求时调用的方法。
- en: The entry list view
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条目列表视图
- en: 'This view is much more interesting than the previous one:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图比之前的要有趣得多：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First of all, we decorate the `get` method as we did before. Inside of it,
    we need to prepare a list of `Entry` objects and feed it to the template, which
    shows it to the user. In order to do so, we start by getting the `context` dictionary
    like we''re supposed to do, by calling the `get_context_data` method of the `TemplateView`
    class. Then, we use the ORM to get a list of the entries. We do this by accessing
    the objects manager, and calling a filter on it. We filter the entries according
    to which user is logged in, and we ask for them to be sorted in descending order
    (that `''-''` in front of the name specifies the descending order). The `objects`
    manager is the default **manager** every Django model is augmented with on creation:
    it allows us to interact with the database through its methods.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像之前一样装饰`get`方法。在其中，我们需要准备一个`Entry`对象列表并将其提供给模板，然后将其显示给用户。为了做到这一点，我们首先获取`context`字典，调用`TemplateView`类的`get_context_data`方法。然后，我们使用ORM获取条目列表。我们通过访问对象管理器并对其进行过滤来执行此操作。我们根据登录的用户对条目进行过滤，并要求它们按降序排序（名称前面的'-'指定了降序排序）。`objects`管理器是每个Django模型在创建时都会增强的默认**管理器**：它允许我们通过其方法与数据库进行交互。
- en: We parse each entry to get a list of matches (actually, I coded it so that `matches`
    is a generator expression). Finally, we add to the context an `'entries'` key
    whose value is the coupling of `entries` and `matches`, so that each `Entry` instance
    is paired with the resulting match of its pattern and test string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析每个条目以获得匹配项列表（实际上，我编码使`matches`成为一个生成器表达式）。最后，我们向上下文添加了一个`'entries'`键，其值是`entries`和`matches`的耦合，以便每个`Entry`实例与其模式和测试字符串的结果匹配配对。
- en: On the last line, we simply ask Django to render the template using the context
    we created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `_parse_entry` method. All it does is perform a search on
    the `entry.test_string` with the `entry.pattern`. If the resulting `match` object
    is not `None`, it means that we found something. If so, we return a tuple with
    three elements: the overall group, the subgroups, and the group dictionary.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `match.groups()` and `match.groupdict()` might return respectively
    an empty tuple and an empty dict. In order to normalize empty results to a simpler `None`,
    I use a common pattern in Python by exploiting the `or` operator. `A or B`, in
    fact, will return `A` if `A` evaluates to a truthy value, or `B` otherwise. Can
    you think how this might differ from the behavior of the `and` operator?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: If you're not familiar with those terms, don't worry, you'll see a screenshot
    soon with an example. We return `None` if there is no match (which technically
    is not needed, as Python would do that anyway, but I have included it here for
    the sake of being explicit).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The form view
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s examine `EntryFormView`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is particularly interesting for a few reasons. First, it shows us a nice
    example of Python's multiple inheritance. We want to display a message on the
    page, after having inserted an `Entry`, so we inherit from `SuccessMessageMixin`.
    But we want to handle a form as well, so we also inherit from `FormView`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Note that, when you deal with mixins and inheritance, you may have to consider
    the order in which you specify the base classes in the class declaration, as it
    will affect how methods are found when going up the inheritance chain to serve
    a call.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up this view correctly, we need to specify a few attributes
    at the beginning: the template to be rendered, the form class to be used to handle
    the data from the `POST` request, the URL we need to redirect the user to in the
    case of success, and the success message.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature is that this view needs to handle both `GET` and
    `POST` requests. When we land on the form page for the first time, the form is
    empty, and that is the `GET` request. On the other hand, when we fill in the form
    and want to submit the `Entry`, we make a `POST` request. You can see that the
    body of `get` is conceptually identical to `HomeView`. Django does everything
    for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The `post` method is just like `get`. The only reason we need to code these
    two methods is so that we can decorate them to require login.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Within the Django form-handling process (in the `FormView` class), there are
    a few methods that we can override in order to customize the overall behavior.
    We need to do it with the `form_valid` method. This method will be called when
    the form validation is successful. Its purpose is to save the form so that an
    `Entry` object is created out of it, and then stored in the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that our form is missing the user. We need to intercept
    that moment in the chain of calls and put the user information in ourselves. This
    is done by calling the `_save_with_user` method, which is very simple.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: First, we ask Django to save the form with the `commit` argument set to `False`.
    This creates an `Entry` instance without attempting to save it to the database.
    Saving it immediately would fail because the `user` information is not there.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The next line updates the `Entry` instance (`self.object`), adding the `user`
    information and, on the last line, we can safely save it. The reason I called `object`
    and set it on the instance like that was to follow what the original `FormView`
    class does.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We're fiddling with the Django mechanism here, so if we want the whole thing
    to work, we need to pay attention to when and how we modify its behavior, and
    make sure we don't alter it incorrectly. For this reason, it's very important
    to remember to call the `form_valid` method of the base class (we use `super`
    for that) at the end of our own customized version, to make sure that every other
    action that method usually performs is carried out correctly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note how the request is tied to each view instance (`self.request`) so that
    we don't need to pass it through when we refactor our logic into methods. Note
    also that the user information has been added to the request automatically by
    Django. Finally, the reason why all the process is split into very small methods
    like these is so that we can only override those that we need to customize. All
    this removes the need to write a lot of code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the views covered, let's see how we couple them to the URLs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Tying up URLs and views
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `urls.py` module, we tie each view to a URL. There are many ways of
    doing this. I chose the simplest one, which works perfectly for the extent of
    this exercise, but you may want to explore this subject more deeply if you intend
    to work with Django. This is the core around which the whole website logic will
    revolve; therefore, you should try to get it down correctly. Note that the `urls.py`
    module belongs to the project folder:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are familiar with version 1 of Django, you will notice some differences
    here, as this project is coded in version 2.As you can see, the magic comes from
    the `path` function, which has recently replaced the `url` function. First, we
    pass it a path string (also known as a *route*), then the view, and finally a
    name, which is what we will use in the `reverse` and `reverse_lazy` functions
    to recover the URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Note that, when using class-based views, we have to transform them into functions,
    which is what `path` is expecting. To do that, we call the `as_view()` method
    on them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the first `path` entry, for the admin, is special. Instead of
    specifying a URL and a view, it specifies a URL prefix and another `urls.py` module
    (from the `admin.site` package). In this way, Django will complete all the URLs
    for the admin section by prepending `'admin/'` to all the URLs specified in `admin.site.urls`.
    We could have done the same for our entries application (and we should have),
    but I feel it would have been a bit of overkill for this simple project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The URL paths defined in this module are so simple that they don't require any
    regular expression to be defined. Should you need to use a regular expression,
    you can check out the `re_path` function, which is designed for that purpose.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We also include login and logout functionalities, by employing views that come
    straight out of the `django.contrib.auth` package. We enrich the declaration with
    the necessary information (such as the next page, for the logout view, for example)
    and we don't need to write a single line of code to handle authentication. This
    is brilliant and saves us a lot of time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Each `path` declaration must be done within the `urlpatterns` list and on this
    matter, it's important to consider that, when Django is trying to find a view
    for a URL that has been requested, the patterns are exercised in order, from top
    to bottom. The first one that matches is the one that will provide the view for
    it so, in general, you have to put specific patterns before generic ones, otherwise
    they will never get a chance to be caught. To show you an example that uses regular
    expressions in the route declaration, `'^shop/categories/$'` needs to come before
    `'^shop'` (notice that the `'$'` signals the end of the pattern, and it is not
    specified in the latter), otherwise it would never be called.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: So, models, forms, admin, views, and URLs are all done. All that's left is to
    take care of the templates. I'll have to be very brief on this part because HTML
    can be very verbose.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Writing the templates
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All templates inherit from a base one, which provides the HTML structure for
    all others, in a very **object-oriented programming** (**OOP**) fashion. It also
    specifies a few blocks, which are areas that can be overridden by children so
    that they can provide custom content for those areas. Let''s start with the base
    template:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is a good reason to repeat the `entries` folder from the `templates` one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: When you deploy a Django website, you collect all the template files under one
    folder. If you don't specify the paths like I did, you may get a `base.html` template
    in the entries application, and a `base.html` template in another app. The last
    one to be collected will override any other file with the same name. For this
    reason, by putting them in a `templates/entries` folder and using this technique
    for each Django application you write, you avoid the risk of name collisions (the
    same goes for any other static file).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There is not much to say about this template, really, apart from the fact that
    it loads the `static` tag so that we can get easy access to the `static` path
    without hardcoding it in the template using `{% static ... %}`. The code in the
    special `{% ... %}` sections is code that defines logic. The code in the special
    `{{ ... }}` represents variables that will be rendered on the page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We define five blocks: `styles`, `meta`, `title`, `page-content`, and `footer`,
    whose purpose is to hold the metadata, style information, title, the content of
    the page, and the footer, respectively. Blocks can be optionally overridden by
    child templates in order to provide different content within them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the footer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It gives us a nice link to the home page, which comes from the following template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It extends the `base.html` template, and overrides `title` and `page-content`.
    You can see that basically all it does is provide four links to the user. These
    are the list of entries, the insert page, the logout page, and the admin page.
    All of this is done without hardcoding a single URL, through the use of the `{%
    url ... %}` tag, which is the template equivalent of the `reverse` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The template for inserting `Entry` is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is some conditional logic at the beginning to display messages, if any,
    and then we define the form. Django gives us the ability to render a form by simply
    calling `{{ form.as_p }}` (alternatively, `form.as_ul` or `form.as_table`). This
    creates all the necessary fields and labels for us. The difference between the
    three commands is in the way the form is laid out: as a paragraph, as an unordered
    list, or as a table. We only need to wrap it in form tags and add a submit button.
    This behavior was designed for our convenience: we need the freedom to shape that
    `<form>` tag as we want, so Django isn''t intrusive on that. Also, note that `{%
    csrf_token %}`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: It will be rendered into a token by Django and will become part of the data
    sent to the server on submission. This way, Django will be able to verify that
    the request was from an allowed source, thus avoiding the aforementioned CSRF
    issue. Did you see how we handled the token when we wrote the view for the `Entry`
    insertion? Exactly. We didn't write a single line of code for it. Django takes
    care of it automatically thanks to a **middleware** class (`CsrfViewMiddleware`).
    Please refer to the official Django documentation ([https://docs.djangoproject.com/en/2.0/](https://docs.djangoproject.com/en/2.0/))
    to explore this subject further.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'For this page, we also use the footer block to display a link to the home page.
    Finally, we have the list template, which is the most interesting one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It may take you a while to get used to the template language, but really, all
    there is to it is the creation of a table using a `for` loop. We start by checking
    whether there are any entries and, if so, we create a table. There are two columns,
    one for `Entry`, and the other for the match.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the `Entry` column, we display the `Entry` object (apart from the user),
    and in the `Matches` column, we display that three-tuple we created in the `EntryListView`.
    Note that to access the attributes of an object, we use the same dot syntax we
    use in Python, for example `{{ entry.pattern }}` or `{{ entry.test_string }}`,
    and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with lists and tuples, we cannot access items using the square
    brackets syntax, so we use the dot one as well (`{{ match.0 }}` is equivalent
    to `match[0]`, and so on). We also use a filter, through the pipe (`|`) operator
    to display a custom value if a match is `None`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The Django template language (which is not properly Python) is kept simple for
    a precise reason. If you find yourself limited by the language, it means you're
    probably trying to do something in the template that should actually be done in
    the view, where that logic is more pertinent.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow me to show you a couple of screenshots of the *list* and *insert* templates.
    This is what the list of entries looks like for my father:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Note how the use of the cycle tag alternates the background color of the rows
    from white to light gray. Those classes are defined in the `main.css` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The `Entry` insertion page is smart enough to provide a few different scenarios.
    When you land on it at first, it presents you with just an empty form. If you
    fill it in correctly, it will display a nice message for you (see the following
    picture). However, if you fail to fill in both fields, it will display an error
    message before them, alerting you that those fields are required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the custom footer, which includes both a link to the entries list
    and a link to the home page:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: And that's it! You can play around with the CSS styles if you want. Download
    the code for the book and have fun exploring and extending this project. Add something
    else to the model, create and apply a migration, play with the templates, there's
    lots to do!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Django is a very powerful framework, and offers so much more than what I've
    been able to show you in this chapter, so you should definitely check it out.
    The beauty of it is that Django is Python, so reading its source code is a very
    useful exercise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The future of web development
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer science is a very young subject, compared to other branches of science
    that have existed alongside humankind for centuries. One of its main characteristics
    is that it moves extremely fast. It leaps forward with such speed that, in just
    a few years, you can see changes that are comparable to real-world changes that
    took a century to happen. Therefore, as a coder, you must pay attention to what
    happens in this world, all the time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Currently, because powerful computers are quite cheap and almost everyone has
    access to them, the trend is to try to avoid putting too much workload on the
    backend, and let the frontend handle part of it. Therefore, in the last few years,
    JavaScript frameworks and libraries, such as jQuery, Backbone and, more recently,
    React, have become very popular. Web development has shifted from a paradigm where
    the backend takes care of handling data, preparing it, and serving it to the frontend
    to display it, to a paradigm where the backend is sometimes just used as an API,
    a sheer data provider. The frontend fetches the data from the backend with an
    API call, and then it takes care of the rest. This shift facilitates the existence
    of paradigms such as **Single-Page Application** (**SPA**), where, ideally, the
    whole page is loaded once and then evolves, based on the content that usually
    comes from the backend. E-commerce websites that load the results of a search
    in a page that doesn't refresh the surrounding structure are made with similar
    techniques. Browsers can perform asynchronous calls such as **Asynchronous JavaScript
    and XML** (**AJAX**) that can return data that can be read, manipulated, and injected
    back into the page with JavaScript code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you''re planning to work on web development, I strongly suggest you
    to get acquainted with JavaScript (if you''re not already), and also with APIs.
    In the last few pages of this chapter, I''ll give you an example of how to make
    a simple API using two different Python microframeworks: Flask and Falcon.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Flask view
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask ([http://flask.pocoo.org/](http://flask.pocoo.org/)) is a Python microframework.
    It provides far fewer features than Django, but if your project is meant to be
    very small, then it might be a better choice. In my experience though, when developers
    choose Flask at the beginning of a project, they eventually end up adding plugin
    after plugin, until they have what I call a Django Frankenstein project. Being
    agile means having periodically to spend time reducing the technical debt accumulated
    over time. However, switching from Flask to Django can be a daunting operation,
    so when starting a new project, make sure you consider its evolution. My cheeky
    opinion on this matter is very simple: I always go with Django, as I personally
    prefer it to Flask, but you might disagree with me, so I want to offer you an
    example.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `ch14` folder, create a `flask` folder with the following structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Basically, we''re going to code two simple files: a Flask application and an
    HTML template. Flask uses Jinja2 as a template engine. It''s extremely popular
    and very fast, to the point that even Django started offering native support for
    it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The template is almost offensively simple. All it does is change the greeting
    according to the presence of the `name` variable. A bit more interesting is the
    Flask application that renders it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create an `app` object, which is a Flask application. We only feed the fully
    qualified name of the module, which is stored in `__name__`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Then, we write a simple `hello` view, which takes an optional `name` argument.
    In the body of the view, we simply render the `main.html` template, passing to
    it the `name` argument, regardless of its value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s interesting is the routing. Differently from Django''s way of tying
    up views and URLs (the `urls.py` module), in `Flask` you decorate your views with
    one or more `@app.route` decorators. In this case, we decorate twice: the first
    line ties the view to the root URL (`/`), while the second line ties the view
    to the root URL with a name information (`/<name>`).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `flask` folder and type (make sure you have either installed
    Flask with `$ pip install flask` or by installing the requirements in the source
    code for the book):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can open a browser and go to `http://127.0.0.1:5000/`. This URL has no name
    information; therefore, you will see Hello shy person! It is written all nice
    and big. Try to add something to that URL, such as `http://127.0.0.1:5000/Milena`.
    Hit *Enter* and the page will change to Hello Milena! (so you will have said hello
    to my sister).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Flask offers you much more than this, but we don't have the room
    to go through a more complex example. It's definitely worth exploring, though.
    Several projects use it successfully and it's fun and nice to create websites
    or APIs with it. Flask's author, Armin Ronacher, is a successful and very prolific
    coder. He also created or collaborated on several other interesting projects,
    such as Werkzeug, Jinja2, Click, and Sphinx. He also contributed functionalities
    to the Python AST module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Building a JSON quote server in Falcon
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falcon ([http://falconframework.org/](http://falconframework.org/)) is another
    microframework written in Python, which was designed to be light, fast, and flexible.
    I have seen this relatively young project evolve to become something really popular
    due to its speed, which is impressive, so I'm happy to show you a tiny example
    using it. We're going to build an API that returns a random quote from the Buddha.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `ch14` folder, create a new one called `falcon`. We''ll have two files:
    `quotes.py` and `main.py`. To run this example, install Falcon and Gunicorn (`$
    pip install falcon gunicorn` or the full requirements for the book). Falcon is
    the framework, and **Gunicorn** (**Green Unicorn**) is a Python WSGI HTTP Server
    for Unix (which, in layman''s terms, means the technology that is used to run
    the server).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The Web Server Gateway Interface (WSGI) is a simple calling convention for web
    servers to forward requests to web applications or frameworks written in Python.
    If you wish to learn more, please checkout [PEP333](https://www.python.org/dev/peps/pep-0333/),
    which defines the interface.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re all set up, start by creating the `quotes.py` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will find the complete list of quotes in the source code for this book.
    If you don't have it, you can instead fill in your favorite quotes. Note that
    not every line has a comma at the end. In Python, it's possible to concatenate
    strings like that, as long as they are in brackets (or braces). It's called **implicit
    concatenation**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the main application is not long, but it is interesting:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's start with the class. In Django we had a `get` method, in Flask we defined
    a function, and here we write an `on_get` method, a naming style that reminds
    me of Java/C# event handlers. It takes a request and a response argument, both
    automatically fed by the framework. In its body, we define a dictionary with a
    randomly chosen quote, and the author information. Then we dump that dictionary
    to a JSON string and set the response body to its value. We don't need to return
    anything, Falcon will take care of it for us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we create the Falcon application, and we call `add_route`
    on it to tie the handler we have just written to the URL we want.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re all set up, change to the `falcon` folder and type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, make a request (or simply open the page with your browser) to `http://127.0.0.1:8000/quote`.
    When I did it, I got this JSON in response:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Within the `falcon` folder, I have left a `stress.py` module for you, which
    tests how fast our Falcon code is. See if you can make it work by yourself, it
    should be very easy for you at this point.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Whatever framework you end up using for your web development, try to keep yourself
    informed about other choices too. Sometimes you may be in situations where a different
    framework is the right way to go, and having a working knowledge of different
    tools will give you an advantage.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at web development. We talked about important
    concepts, such as the DRY philosophy and the concept of a framework as a tool
    that provides us with many things we need in order to write code to serve requests.
    We also talked about the MTV pattern, and how nicely these three layers play together
    to realize a request-response path.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Then, we briefly introduced regular expressions, which is a subject of paramount
    importance, and it's the layer that provides the tools for URL routing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: There are many different frameworks out there, and Django is definitely one
    of the best and most widely used, so it's worth exploring, especially its source
    code, which is well written.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: There are other very interesting and important frameworks too, such as Flask.
    They provide fewer features but might be faster, both in execution time and to
    set up. One that is extremely fast is the Falcon project, whose benchmarks are
    outstanding.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: It's important to get a solid understanding of how the request-response mechanism
    works, and how the web in general works, so that eventually it won't matter too
    much which framework you have to use. You will be able to pick it up quickly because
    it will only be a matter of getting familiar with a way of doing something you
    already know a lot about.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Explore at least three frameworks and try to come up with different use cases
    to decide which one of them could be the ideal choice. When you are able to make
    that choice, you will know you have a good enough understanding of them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: A farewell
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you are still thirsty and that this book will be just the first
    of many steps you take towards Python. It's a truly wonderful language, well worth
    learning deeply.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you enjoyed this journey with me, I did my best to make it interesting
    for you. It sure was for me, I had such a great time writing these pages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Python is open source, so please keep sharing it and consider supporting the
    wonderful community around it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Until next time, my friend, farewell!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
