- en: Chapter 2. Project Setup and Breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the implementation of procedural generation for ourselves,
    we're going to take a quick tour through the game template that has been provided
    with the book. Moving forward, the focus will be on the procedural systems that
    we create, not the underlying template and engine. Given that, it will be beneficial
    to familiarize ourselves with the templates and engine before we start.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also take a look at **Simple Fast Multimedia Library** (**SFML**), the
    framework that we'll work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an **Integrated Development Environment** (**IDE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breakdown of the provided game template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of SFML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup and first compile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing an IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we do anything, you're going to need a solid C++ IDE. You may already
    have one that you prefer to use. If you do have one, that's fine. But if you don't,
    here's a quick summary of two of my favorites.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft Visual Studio is an industry-standard IDE from Microsoft. It supports
    a wide range of languages, and provides a large variety of testing and compatibility
    tools. It''s also tied in with a number of Microsoft services, making it the top
    choice for development on Windows PCs. The pros and cons to using Microsoft Visual
    Studio are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: It has a number of free versions available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide range of languages are supported by Microsoft Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is widely supported by Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a highly customizable environment with dockable windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has intelligent code completion features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is integrated with a number of Microsoft features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: Its full version is very expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its free version is limited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works only on Windows PC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Visual Studio and a wide range of other Microsoft technologies are
    available to students for free for the duration of their studies. To find out
    more about this, visit [https://www.dreamspark.com/Student/](https://www.dreamspark.com/Student/).
  prefs: []
  type: TYPE_NORMAL
- en: Code::Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Code::Blocks IDE is a free, open source, and cross-platform IDE for development
    in C, C++, and Fortran programming languages. It's built around a plugin architecture,
    meaning it can be highly customized by installing various add-ons to create an
    IDE that best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: It is available for free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is available for all Operating Systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is highly customizable through the installation of add-ons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports multiple containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has intelligent code completion features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: It has fewer features and tools as compared to what Microsoft Visual Studio
    offers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both IDEs have the required features that will allow us to create a game in
    C++. Therefore, it all boils down to personal preferences. I'll suggest Visual
    Studio, and it's the one that I'll use throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Other IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio and Code::Blocks are just two examples of the many IDEs that
    are available. If you don''t prefer either, the following are a number of alternate
    cross-platform IDEs. All of them are capable of developing C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans (Windows, Mac OS X, and Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse (Windows, Mac OS X, and Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Lite (Windows, Mac OS X, and Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to using an IDE is compiling via a build system. These systems
    decouple the build process from the IDE or code editor that you're using, giving
    you more control over the process. Build systems allow you to automate various
    aspects of the build process. It may be something simple, such as incrementing
    a build number, or advanced, such as automated unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of build systems available, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSBuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't cover the setup or use of these systems in the book. So, head to each
    systems' respective site for documentation and instructions for use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on build systems and the benefits that they provide, visit
    [http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make](http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make).
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the game template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to learn is by practicing. Examples are great, but there's nothing
    like getting stuck in and working on a real game. The game template provided will
    allow us to implement the systems that we're going to learn about in a real game
    as opposed to them being a collection of isolated exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarizing yourself with this template will not only help make the code examples
    throughout the book clearer, but also make the exercises at the end of each chapter
    easier. It will also allow you to use what you're learning to implement your own
    systems in the project once we're done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Download templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start, download the game template so that you have the source code
    available as you run through some of the key points. The template is available
    for download on the official Packt Publishing website at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: We'll set it up shortly, but for now, let's take a quick look at some of its
    key features.
  prefs: []
  type: TYPE_NORMAL
- en: The class diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included with the project download is an image of the complete class diagram
    for our solution. If at any point you have any questions about the structure of
    the template, refer to the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Class diagrams are a great way of seeing the complete structure of your software.
    As your game gets bigger and bigger, it will inevitably get more convoluted as
    inheritance structures grow larger. If you have the tools available to do so,
    it's a great idea to view a class diagram regularly and keep on top of its structure.
    It will help you identify where your structure needs work, and where doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating diagrams in Microsoft Visual Studio is restricted to the Professional
    edition or higher. However, there are various free tools available, such as Doxygen
    at [http://www.stack.nl/~dimitri/doxygen/index.html](http://www.stack.nl/~dimitri/doxygen/index.html)
    and ArgoUML at [http://argouml.tigris.org/](http://argouml.tigris.org/), which
    create UML diagrams from source code.
  prefs: []
  type: TYPE_NORMAL
- en: The object hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All objects in the template follow a set inheritance hierarchy. At the base
    of all classes is the `Object` class. This provides a `sprite`, a `position`,
    an `Update()` virtual function, and a `Draw()` virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: 'All classes extend from this base class, implementing their own behaviors by
    overriding these virtual functions. In our `main` game class we create containers
    for the main base classes, grouping all items and enemies into single collections
    that we can iterate over easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A vector of base class pointers allows us to take advantage of polymorphism
    and store all the classes that inherit from the same parent classes in a single
    data structure. Don't worry if you're unfamiliar with polymorphism. Towards the
    end of the chapter we'll take a look at both polymorphism and the object pipeline
    to add an object to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're using the `std::unique_ptr` C++11 smart pointer over raw pointers. For
    more information on smart pointers and their benefits, visit [https://msdn.microsoft.com/en-us/library/hh279674.aspx](https://msdn.microsoft.com/en-us/library/hh279674.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Level data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game template that is provided is a `roguelike` template. Given this, the
    level is described as a grid. The best way to represent a grid in this context
    is with a 2D array, and to store all the information that we need, we''ll use
    a custom data type named `Tile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `struct` allows us to have a single 2D array of the `Tile` type, which
    can store all the information that each tile needs. This approach is incredibly
    common when creating a game of this type. The array is found in the `Level` class,
    which is instantiated at the beginning of the game. It encapsulates all the data
    pertaining to the level.
  prefs: []
  type: TYPE_NORMAL
- en: For now, level data is stored in a simple text file which is parsed during the
    runtime by performing a simple lookup on an enumerator that defines all the tile
    types. We will work on an example of this towards the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the level data is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Level data](img/B04920_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collisions are based on the `ID` of the tile that you're currently standing
    on. Every time a player starts to move, the position that they will be in after
    a successful move is calculated. This position is then used to calculate the grid
    `tile` that they are placed on. This tile is then used to determine what action
    should be performed; the action can involve performing a blocking movement, picking
    up an item, or taking damage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of collision can lead to the bullet through paper problem, but given
    the game's speed, this isn't an issue in our case. If you're unaware of what this
    problem is, look it up online; it may catch you out in later projects!
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input is handled through a custom static `Input` class. It works much like the
    `Input` class that is provided with SFML, but it combines a number of possible
    inputs into a single call. For example, when checking whether the left key is
    pressed, it will check the *A* key, Left arrow key, left *D*-Pad, and analog stick.
    If this was to be done using the standard `Input` class, you would have to check
    all four individually. The `Input` class provided streamlines this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A public `enum` of keycodes is defined in `input.h` and contains the following
    values that are used to poll input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To check the input, we simply call `Inputs IsKeyPressed(KEY keycode)` statically,
    passing one of the aforementioned valid keycodes.
  prefs: []
  type: TYPE_NORMAL
- en: Simple and Fast Multimedia Library (SFML)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst you will have experience with C++, you may not have any prior experience
    with SFML. That's fine, the book doesn't assume any, so now let's take a brief
    tour through it
  prefs: []
  type: TYPE_NORMAL
- en: Defining SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SFML**, short for **Simple and Fast Multimedia Library**, is a software development
    library that provides easy access to multiple system components. It''s written
    in C++ and is split into the following succinct modules:'
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this architecture you can easily pick and choose how you want to use SFML,
    ranging from a simple window manager to use OpenGL, to a complete multimedia library
    that is capable of making full video games and multimedia software.
  prefs: []
  type: TYPE_NORMAL
- en: Why we'll be using SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SFML is both free, open-source, and has a vibrant community. With active forums
    and a selection of great tutorials on the official site, there are plenty of resources
    available for those who wish to learn. Another compelling reason to use SFML is
    that it's written in C++ and has bindings for many other languages, meaning you
    can pretty much code in any language that takes your fancy. There is probably
    a binding available for the language that you wish to use!
  prefs: []
  type: TYPE_NORMAL
- en: The single most attractive feature of SFML is that it is a multiplatform library.
    An app written in SFML can compile and run on most common operating systems, including
    Windows, Linux, and Mac OS X, with the Android and iOS versions coming soon in
    the market at the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For your app to be cross-compatible across various platforms, remember that
    you also have to ensure that your native code or the other libraries used, if
    any, are also cross-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Learning SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the course of the book, we''ll look at the features and functions of
    SFML that we''ll use to implement our procedural systems, but nothing more. We
    won''t be taking an in-depth look at the library, as that would require a whole
    book. Luckily, there are a few great books that are published by Packt Publishing
    dedicated to just that:'
  prefs: []
  type: TYPE_NORMAL
- en: SFML Game Development at [https://www.packtpub.com/game-development/sfml-game-development](https://www.packtpub.com/game-development/sfml-game-development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFML Essentials at [https://www.packtpub.com/game-development/sfml-essentials](https://www.packtpub.com/game-development/sfml-essentials)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFML Blueprints at [https://www.packtpub.com/game-development/sfml-blueprints](https://www.packtpub.com/game-development/sfml-blueprints)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to learn more about SFML, then these books are a great place to
    start. There is also a selection of great tutorials on the official SFML site
    along with active forums. Visit [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SFML is a great option for cross-platform game development, it's not the
    only one. There are a number of great libraries available, each with their own
    approaches and styles. Therefore, though we'll use SFML for this project, it's
    advised that you shop around for your next one. You may just run into your new
    favorite library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few suggestions for future reference:'
  prefs: []
  type: TYPE_NORMAL
- en: SDL2 at [https://www.libsdl.org/download-2.0.php](https://www.libsdl.org/download-2.0.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allegro at [http://liballeg.org/](http://liballeg.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MonoGame at [http://www.monogame.net/downloads/](http://www.monogame.net/downloads/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with the game template, we're going to take a look at
    polymorphism. It's an important feature of object-orientated programming that
    we will be taking advantage of in many of the procedural systems that we will
    create. Therefore, it's important that you have a solid understanding of not only
    what it is, but also the techniques that are used to achieve it and the potential
    pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have a strong understanding of polymorphism, feel free to skip
    this section or head to [https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90)](https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90))
    for a more in-depth discussion of the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is the ability to access different objects through an individually
    implemented common interface. That's a very formal definition. So, let's break
    that down into the individual techniques and features that are used to achieve
    it. It's worth noting that while polymorphism is the standard approach in the
    games industry, it's still a choice among other schools of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is perhaps the key component in achieving polymorphism. Inheritance
    is extending an existing class by inheriting its variables and functions, and
    then adding your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a typical game example. Let''s assume that we have a
    game with three different weapons: a sword, a wand, and an axe. These classes
    will share some common variables such as attack strength, durability, and attack
    speed. It would be a waste to create three individual classes and add this information
    to each, so instead we will create a parent class that includes all the shared
    information. Then, the children will inherit these values and use them the way
    they want.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance creates an "is a" relationship. This means that since Axe is inherited
    from Weapon, Axe is a Weapon. This concept of creating a common interface in a
    parent class and implementing it in unique ways via child classes is the key to
    achieving polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By interface, I mean the collection of functions and variables that the parent
    class passes to its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this scenario in the form of a simple class
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/B04920_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The highlighted `Attack()` functions in the individual weapons are all inherited
    from the single `Attack()` function defined in the **Weapon** class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To maintain proper encapsulation and scope, it's important that our variables
    and functions are given the correct visibility modifiers. If you're unsure about
    this or you could do with a quick reminder, head to [https://msdn.microsoft.com/en-us/library/kktasw36.aspx](https://msdn.microsoft.com/en-us/library/kktasw36.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with the generic weapon example, we now have a parent class that
    provides a number of functions and variables that all child classes will inherit.
    In order to be able to denote our own behavior that is different from that of
    the parent class, we need to be able to override the parent functions. This is
    achieved through the use of virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual functions are functions that can be overridden by implementing classes.
    In order for this to be possible, the parent class must mark the function as virtual.
    This is done by simply prefixing the virtual keyword to a function declaration
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In a child class, we can then override that function by providing our own definition,
    provided the signatures of the two functions are identical. This override is done
    automatically, however, C++11 introduced the `override` keyword to specifically
    denote where a function will override the function of a parent. The override keyword
    is optional, but it''s considered good practice and it is recommended. It is used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'C++11 also introduced the `final` keyword. This keyword is used to designate
    virtual functions that cannot be overridden in a derived class. It can also be
    applied to classes that cannot be inherited. You can use the final keyword as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Attack()` function could not be overridden by inheriting
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Pure virtual functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual functions that we just covered allow a function to be *optionally* overridden
    by an inheriting class. The override is optional, as the parent class will provide
    a default implementation if one is not found in the child class.
  prefs: []
  type: TYPE_NORMAL
- en: A pure virtual function however does not provide a default implementation. Hence,
    it must be implemented by inheriting classes. Furthermore, if a class contains
    a pure virtual function, it becomes abstract. This means that it cannot be instantiated,
    only inheriting classes, providing they provide an implementation for the pure
    virtual function, can be. If a class inherits from an abstract class and does
    not provide an implementation for pure virtual functions, then that class becomes
    abstract too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax that is used to declare a pure virtual function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the example of the `Weapon` parent class, which is inherited by `Sword`,
    `Axe` and `Wand`, it would make sense to make `Weapon` an abstract class. We will
    never instantiate a `Weapon` object; its sole purpose is to provide a common interface
    to its children. Since each child class needs to have an `Attack()` function,
    it then makes sense to make the `Attack()` function in `Weapon` pure virtual,
    as we know that every child will implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and object slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last part of the polymorphism puzzle is the use of pointers. Consider the
    following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we are not using pointers; in the second one, we are. It
    is a seemingly small difference, but it produces extremely different results.
    To properly demonstrate this, we're going to look at a small program that defines
    a number of weapons.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Weapon` class contains a pure virtual function, the first line of the
    preceding code won't be compiled since it will be abstract and cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code for this program from the Packt Publishing website.
    It will be in the `Examples` folder, and the project name is `polymorphism_example`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code we created a base struct `Weapon`. We then inherit from it to create
    a specific implementation named `Sword`. The base `Weapon` struct defines the
    `GetItemType()` function and `Sword` overrides it to change and then return the
    item type. This is a pretty straightforward case of inheritance and polymorphism,
    but there are some important things that we need to know that could otherwise
    trip us up.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the code currently stands, the `Weapon` object is instantiated in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pointers and object slicing](img/B04920_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though we assigned `myWeapon` a `Sword` object, it's a `Weapon` object.
    What's happening here? The problem is that `myWeapon` is given a fixed type of
    weapon. When we try to assign it a `Sword` object, it gets passed to the `copy`
    constructor of `Weapon` and gets sliced, leaving just a `Weapon` object. As a
    result, when we call the `GetItemType()` function, we call the function in `Weapon`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more in-depth explanation of object slicing, head to [http://www.bogotobogo.com/cplusplus/slicing.php](http://www.bogotobogo.com/cplusplus/slicing.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this and make good use of polymorphism, we need to work with pointers.
    Let''s make the following change to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart pointers such as `unique_ptr` require the `include <memory>`. So don't
    forget to add this to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve now changed `myWeapon` to a pointer, we also need to change the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with pointers, we need to use the `->` operator to access its
    variables and functions. Now, let''s rerun the code and see what the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pointers and object slicing](img/B04920_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This time, we called the overridden function in the `Sword` struct as intended,
    and it boils down to the way we defined `myWeapon`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `myWeapon` is now a pointer to a `Weapon` object, we avoid object slicing.
    Since `Sword` is derived from `Weapon`, pointing to a `Sword` in memory isn't
    a problem. They share a common interface, so we achieve this overriding behavior.
    Returning to the initial definition, polymorphism is the ability to access different
    objects through an individually implemented common interface.
  prefs: []
  type: TYPE_NORMAL
- en: The roguelike template setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A template is provided with this book for a `roguelike` game that was created
    specifically for the book. It's been designed to receive the work that we'll cover,
    and at the end of the book, you'll have a fully functional roguelike game that
    implements everything that you will have learned. Now that we've brushed up on
    our understanding of polymorphism, let's get the template setup. The first step
    is to download and link SFML.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The project, as provided, is linked with SMFL 32-bit windows libraries. This
    should suit most systems. If this is compatible with your system, you can skip
    the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SFML is available in a number of different precompiled packages. For example,
    the latest release at the time of writing this book has 12 packages available
    for Windows alone, so it''s important that you download the correct one for your
    system. The following steps will help you to download and setup SFML:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit at [http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)
    to find the SFML download page. Unless you specifically need to target a 64-bit
    machine, choose the 32-bit libraries. A 32-bit program will work fine on a 64-bit
    machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to choose the right package for your compiler. If you're using
    Microsoft Visual Studio, you just need to choose the year that matches your version,
    and if you're using Code::Blocks, or any other IDE for that matter, choose the
    version of **GNU Compiler Collection** (**GCC**) that you're using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've identified the correct version for your system, download it and
    extract the contents of the `.zip` file to where you want SFML to be saved. This
    location has nothing to do with your project; they don't need to share a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can build SFML on your own to create a custom package if you wish or need
    to do so. For instructions on how to do so, visit [https://github.com/SFML/SFML](https://github.com/SFML/SFML).
  prefs: []
  type: TYPE_NORMAL
- en: Linking SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to link SFML: **static** and **dynamic** libraries. A static
    library is the one that is compiled into your executable. This means that your
    executable is bigger, but you don''t have to worry about getting the library during
    the runtime. Dynamic libraries do not get linked into the executable, which results
    in a smaller executable, but creates dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the difference between `static` and `dynamic` libraries,
    visit [http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/](http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/).
  prefs: []
  type: TYPE_NORMAL
- en: We're going to link dynamically, which means that to run the game, you will
    need the `.dll` files.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, first copy the `DLL` files that the game will need from the SFML source
    to the project's executable location. Copy all the files from `<sfml-install-path/bin>`
    to `<project-location/Debug>`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to tell the compiler where the SFML headers are and the linker
    where the out libraries are. Headers are `.hpp` files, and libraries are `.lib`
    files. This step slightly differs depending on which IDE you're using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Microsoft Visual Studio, add the following to the project''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the SFML headers (`<sfml-install-path>/include`) to **C/C++** |
    **General** | **Additional Include Directories**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to the SFML libraries (`<sfml-install-path>/lib`) to **Linker** | **General**
    | **Additional Library Directories**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Code::Blocks, add the following to the project''s **Build Options** and
    **Search Directories** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the SFML headers (`<sfml-install-path>/include`) to the `Compiler`
    search directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to the SFML libraries (`<sfml-install-path>/lib`) to the `Linker` search
    directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These paths are the same in both the `Debug` and `Release` configurations. Therefore,
    they can be set globally for the project.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to link our project to the SFML libraries that are being used.
    SFML is made up of five modules, but we won't use all of them. We're using `System`,
    `Windows`, `Graphics`, and `Audio`. Therefore, we only need to link to these libraries.
    Unlike the previous step, the project configuration is important. There are separate
    libraries for the `Debug` and `Release` configurations. Therefore, you need to
    ensure that you link the correct ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Debug` configuration, we need to add the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sfml-system-d.lib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sfml-window-d.lib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sfml-graphics-d.lib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sfml-audio-d.lib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, do the same for the **Release** configuration. However, drop the `–d` from
    each. For example, we add `sfml-system-d.lib` in the **Debug** configuration,
    and we add `sfml-system.lib` in the **Release** configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To add these to Microsoft Visual Studio, they must be added to the project's
    properties by navigating to **Linker** | **Input** | **Additional Dependencies**.
  prefs: []
  type: TYPE_NORMAL
- en: To add these to Code::Blocks, they must be added to the **Link Libraries** list
    in the project's build options under the **Linker Settings** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have any queries regarding this setup, visit [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)
    for a complete breakdown along with images.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that SFML is linked to our project, we should be ready to perform the first
    build. The following screenshot shows our currently empty roguelike game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the project](img/B04920_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the project currently stands, we have a runnable application that spawns
    a player in a fixed room. The first task involves adding an item.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All items that we create need to inherit from the base `Item` class because
    all game items are stored in a single vector of the `std::unique_ptr<Item>` type.
    With this data structure we can take advantage of polymorphism, and store all
    the item subclasses in a single structure; through this, we can update and draw
    each item.
  prefs: []
  type: TYPE_NORMAL
- en: To add to this vector, simply instantiate a new item via a unique pointer. Then,
    add it to the vector using the `.push_back()` method. Since we're using unique
    pointers, we have to use `std::move()` to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're unclear about why we have to use `std::move` here, look up for unique
    pointers on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Game::PopulateLevel` function, let''s add a gem item, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All that we have to do is create a new object via a unique pointer, give it
    a position, and then add it to the list of all the items in the level using the
    `std::move` function. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: Updating and drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once an item is added to the vector of all the objects, it will be automatically
    updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function iterates over all the items, checking whether they have been collected;
    if this is not the case, it updates them. The `Update()` function of each object
    has a single parameter named `timeDelta`. This is a float that contains the time
    that has passed since the last update. It's used in the main outer game loop to
    keep the game logic fixed at 60 fps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know more about the main game loop, visit [http://gafferongames.com/game-physics/fix-your-timestep/](http://gafferongames.com/game-physics/fix-your-timestep/),
    which is a great article on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Items are drawn in a similar way; their container is simply iterated over in
    the `Game::Draw` function. This loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `m_window` variable is a pointer to the render window. Hence, we pass it
    to each object so that it can use it to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the game, you will see the gem in the room along with the gold,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating and drawing](img/B04920_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you test your knowledge of this chapter's content, here are a few exercises
    that you should work on. They are not imperative to the rest of the book, but
    working on them will help you assess your strengths and weakness on the material
    covered.
  prefs: []
  type: TYPE_NORMAL
- en: Create a name for your game and change the text of the main window to reflect
    this change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What is the visibility of `x`, `y`, and `z` in `class B`?
  prefs: []
  type: TYPE_NORMAL
- en: Add more items to the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made preparations that are needed in order to start coding
    the game and create the procedural systems. We looked at the software and libraries
    that we will use, and the game template that we'll extend. We also took a crash
    course in polymorphism and the techniques that we will use to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to start creating our own procedural systems. The groundwork
    that we just covered isn't terribly exciting, but it is crucial to understanding
    the work that we're going to cover when moving forward. In the next chapter we're
    going to use what we learned about random number generation with C++ data types
    to spawn random items, and give our player random stats.
  prefs: []
  type: TYPE_NORMAL
