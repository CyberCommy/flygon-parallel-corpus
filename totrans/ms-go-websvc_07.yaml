- en: Chapter 7. Working with Other Web Technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our last chapter, we looked at how our web service can play nicely and integrate
    with other web services through APIs or OAuth integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing that train of thought, we'll take a pit stop as we develop the technology
    around our social network service to see how we can also integrate other technologies
    with it, independent of other services.
  prefs: []
  type: TYPE_NORMAL
- en: Very few applications run on a stack that's limited to just one language, one
    server type, or even one set of code. Often, there are multiple languages, operating
    systems, and designated purposes for multiple processes. You may have web servers
    running with Go on Ubuntu, which is a database server that runs PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving our web traffic through a reverse proxy to leverage the more advanced
    features provided by mature HTTP products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to NoSQL or key/value datastores, which we can utilize as our core
    data provider or with which we can do ancillary work such as caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling sessions for our API and allowing clients and users to make requests
    without specifying credentials again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing users to connect with each other by way of friending or adding other
    users to their network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we've finished all of this, you should have an idea about how to connect
    your web service with NoSQL and database solutions that are different to MySQL.
    We will utilize datastores later on to give us a performance boost in [Chapter
    10](ch10.html "Chapter 10. Maximizing Performance"), *Maximizing Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: You will hopefully also be familiar enough with some out-of-the-box solutions
    for handling APIs, be able to bring middleware into your web service, and be able
    to utilize message passing to communicate between dissonant or segregated systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by looking at ways in which we can connect with other web
    servers to impose some additional functionality and failure mitigation into our
    own service that is presently served solely by Go's `net/http` package.
  prefs: []
  type: TYPE_NORMAL
- en: Serving Go through a reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most prominent features of Go''s internal HTTP server might have
    also triggered an immediate, skeptical response: if it''s so easy to start serving
    applications with Go, then is it fully featured as it relates to web serving?'
  prefs: []
  type: TYPE_NORMAL
- en: This is an understandable question, particularly given Go's similarity to interpreted
    scripting languages. After all, Ruby on Rails, Python, NodeJS, and even PHP all
    come with out-of-the-box simple web servers. Rarely are these simple servers suggested
    as production-grade servers due to their limitations in feature set, security
    updates, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, Go's `http` package is robust enough for many production-level
    projects; however, you may find not only some missing features but also some reliability
    by integrating Go with a reverse proxy that has a more mature web server.
  prefs: []
  type: TYPE_NORMAL
- en: A "reverse proxy" is a misnomer or at least a clunky way to illustrate an internal,
    incoming proxy that routes client requests opaquely through one system to another
    server, either within the same machine or network. In fact, it's often referred
    to simply as a gateway for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: The potential advantages are myriad. These include being able to employ a well-known,
    well-supported, fully featured web server (versus only having the building blocks
    to build your own in Go), having a large community for support, and having a lot
    of pre-built, available plugins and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Whether it's necessary or advantageous or has a good return on investment is
    a matter of preference and the situation you're in, but it can often help in logging
    and debugging web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go with Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache's web server is the elder statesman in web serving. First released in
    1996, it quickly became a stalwart and as of 2009, it has served more than 100
    million websites. It has remained in the most popular web server in the world
    since shortly after its inception, although some estimates have placed Nginx as
    the new number 1 (we will talk a little more about this in some time).
  prefs: []
  type: TYPE_NORMAL
- en: Putting Go behind Apache is super easy but there is one caveat; Apache, as it
    comes installed, is a blocking, nonconcurrent web server. This is different to
    Go, which delineates requests as goroutines or NodeJS or even Nginx. Some of these
    are bound to threads and some aren't. Go is obviously not bound, and this ultimately
    impacts how performant the servers can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s create a simple `hello world` web application in Go, which
    we''ll call `proxy-me.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing too complicated here. We listen on port 8080 and we have one
    very simple route, `/hello`, which just says `hello world`. To get Apache to serve
    this as a reverse proxy in pass-through, we edit our default server configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default server configuration is generally stored at `/etc/apache2/sites-enabled/`
    for Linux and `[Drive]:/[apache install directory]/conf/` in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that we're seeing the page served by Apache rather than directly
    through Go by viewing the headers on a request to the `/hello` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do this, we''ll see not only the Server as **Apache/2.4.7**, but also
    our custom header that was passed along. Typically, we''d use the **X-Forwarded-For**
    header for another purpose, but it''s analogous enough to use as a demonstration,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Go with Apache](img/1304OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Go and NGINX as reverse proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Apache is the old king of web serving, in recent years, it has been surpassed
    in popularity by Nginx at least by some measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx was initially written as an approach to the C10K problem—serving 10,000
    concurrent connections. It's not an impossible task, but one that previously required
    expensive solutions to address it.
  prefs: []
  type: TYPE_NORMAL
- en: Since Apache, by default, spawns new threads and/or processes to handle new
    requests, it often struggles under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Nginx was designed with an event model that is asynchronous
    and does not spawn new processes for each request. In many ways this makes it
    complementary to the way Go works with concurrency in the HTTP package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Apache, the benefits of putting Nginx instead of Go are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It has access and error logs. This is something that you'll need to build using
    the log package in Go. While it's easy enough to do, it's one fewer hassle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has extraordinarily fast static file serving. In fact, Apache users often
    use Nginx exclusively to serve static files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has SPDY support. SPDY is a new and somewhat experimental protocol that manipulates
    the HTTP protocol to introduce some speed and security features. There are some
    attempts to implement Go's HTTP and TLS at package libraries for SPDY, but nothing
    has been built natively into the net/HTTP package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has built-in caching options and hooks for popular caching engines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the flexibility to delegate some requests to other processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss the usage of SPDY directly in both Nginx and within Go in [Chapter
    10,](ch10.html "Chapter 10. Maximizing Performance") *Maximizing Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that asynchronous, nonblocking, and concurrent HTTP serving
    will almost always be bound to the constraints of technical externalities such
    as network latency, file and database blocking, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's take a look at the setup for quickly putting Nginx
    instead of Go as a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx allows a pass through very simply by modifying the default configuration
    file. Nginx has no native support for Windows yet; so, in most *nix solutions,
    this file can be found by navigating to `/etc/nginx/sites-enabled`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternately, you can do a proxy globally by making the change within the `.conf`
    file available at `/etc/nginx/nginx.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a sample Nginx configuration operation that will let us proxy
    our server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this modification in place, you can start Nginx by running `/etc/init.d/nginx`,
    and then start the Go server with `go run proxy-me.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hit our localhost implementation, we''ll see something that looks a lot
    like our last request''s headers but with Nginx instead of Apache as our proxy
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Go and NGINX as reverse proxies](img/1304OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling sessions for the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mostly, we expose APIs for machines to use. In other words, we expect that some
    applications will be directly interfacing with our web service rather than the
    users.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not always the case. Sometimes, users interact with APIs using
    the browser, either directly or through a conduit like JavaScript with JSONP and/or
    AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the fundamentals of the aesthetics of Web 2.0 were rooted in providing
    users a seamless, desktop-like experience. This has come to fruition today and
    includes a lot of JavaScript MVC frameworks that handle presentation layers. We'll
    tackle this in our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The term Web 2.0 has largely been supplanted and it is now usually referred
    to as a **Single Page App** or **SPA**. What was once a mixture of server-generated
    (or served) HTML pages with some pieces built or updated through XML and JavaScript
    has ceded to JavaScript frameworks that build entire client-side applications.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all of these rely on an underlying API, which is generally accessible
    through stateless requests over HTTP/HTTPS, although some newer models use web
    sockets to enable real-time communication between the server and the presentation
    model. This is something that we'll look at in the next chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of the model, you cannot simply expose this API to the world without
    some authentication. If, for example, an API is accessible from a `/admin` request
    without authentication, it's probably also accessible from outside. You cannot
    rely on a user's information such as an HTTP referer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grammarians may note the misspelling of referrer in the previous sentence. However,
    it's not a typo. In the initial HTTP request for comments proposal, the term was
    included without the double *r* in the spelling and it has largely stuck ever
    since.
  prefs: []
  type: TYPE_NORMAL
- en: However, relying on every OAuth request is overkill when it's a user who is
    making many requests per page. You could cache tokens in local storage or cookies,
    but browser support for the former is still limited and the latter limits the
    revocability of a token.
  prefs: []
  type: TYPE_NORMAL
- en: A traditional and simple solution for this is to allow sessions for authentication
    that are based on cookies. You may still want to leave an API open for access
    from outside a main application so that it can be authenticated via an API key
    or OAuth, but it should also enable users to interface with it directly from client-side
    tools to provide a clean SPA experience.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions in a RESTful design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's worth noting that because sessions typically enforce some sense of state,
    they are not inherently considered as a part of a RESTful design. However, it
    can also be argued that sessions can be used solely for authentication and not
    state. In other words, an authentication and a session cookie can be used elusively
    as a method for verifying identity.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also do this by passing a username and password along with
    every secure request. This is not an unsafe practice on its own, but it means
    that users will need to supply this information with every request, or the information
    will need to be stored locally. This is the problem that sessions that are stored
    in cookies attempt to solve.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, this will never apply to third-party applications, which
    for the most part need some sort of easily revokable key to work and rarely have
    a username and a password (although ours are tied to users, so they technically
    do).
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is to allow a username and a password to go directly
    into the URL request, and you may see this sometimes. The risk here is that if
    a user shares the URL in full accidentally, the data will be compromised. In fact,
    this happens often with newer GitHub users, as it's possible to automatically
    push config files that contain GitHub passwords.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce this risk, we should mandate that a username and a password be passed
    via a header field, although it should still be in cleartext. Assuming that a
    solid TSL (or SSL) option is in place, cleartext in the header of the request
    is not inherently a problem, but could be one if an application can at any point
    switch to (or be accessed by) unsecure protocols. This is a problem that time-restricted
    token systems attempt to address.
  prefs: []
  type: TYPE_NORMAL
- en: We can store session data anywhere. Our application presently uses MySQL, but
    session data will be read frequently. So, it's not ideal to encumber our database
    with information that has very little in terms of relational information.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we'll be storing an active user, their session's start time, the last
    update time (changed with every request), and perhaps where they are within the
    application. This last piece of information can be used in our application to
    tell users what their friends are currently doing within our social network.
  prefs: []
  type: TYPE_NORMAL
- en: With these conditions in mind, relying on our primary datastore is not an ideal
    solution. What we want is something more ephemeral, faster, and more concurrent
    that enables many successive requests without impacting our datastore.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular solutions today for handling sessions in this regard
    is to yield relational databases to NoSQL solutions that include document and
    column stores or key-value datastores.
  prefs: []
  type: TYPE_NORMAL
- en: Using NoSQL in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Long ago, the world of data storage and retrieval was relegated almost exclusively
    to the realm of relational databases. In our application, we are using MySQL,
    largely because it's been a lingua franca for quick applications and SQL translates
    fairly easily across similar databases (Microsoft's SQL Server, PostgreSQL, Oracle,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, however, a big push has been made toward NoSQL. More accurately,
    the push has been towards data storage solutions that rely less on typical relational
    database structures and schemas and more on highly performant, key-value stores.
  prefs: []
  type: TYPE_NORMAL
- en: A key-value store is exactly what anyone who works with associative arrays,
    hashes, and maps (in Go) would expect, that is, some arbitrary data associated
    with a key. Many of these solutions are very fast because of the lack of indexed
    relationships, mitigation of locking, and a de-emphasis of consistency. In fact,
    many solutions guarantee no ACIDity out of the box (but some offer methods for
    employing it optionally).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ACID** refers to the properties that developers expect in a database application.
    Some or all of these may be missing or may be optional parameters in any given
    NoSQL or key-value datastore solution. The term **ACID** can be elaborated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**: This indicates that all parts of a transaction must succeed
    for any part to succeed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: This refers to the database''s state at the start of a transaction
    does not change before the completion of a transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: This refers to the table or row locking mechanism that prevents
    access to data that is presently in the state of transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability**: This ensures that a successful transaction can and will survive
    a system or application failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL solutions can be used for a lot of different things. They can be outright
    replacements for SQL servers. They can supplement data with some data that requires
    less consistency. They can work as quickly accessible, automatically expiring
    cache structures. We'll look at this in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to introduce a NoSQL solution into your application, be thoughtful
    about the potential impact this could bring to your application. For example,
    you can consider whether the potential tradeoff for ACID properties will be outweighed
    by performance boosts and horizontal scalability that a new solution provides.
  prefs: []
  type: TYPE_NORMAL
- en: While almost any SQL or traditional relational database solution out there has
    some integration with Go's `database/sql` package, this is not often the case
    with key-value stores that need some sort of package wrapper around them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll briefly look at a few of the most popular solutions for key-value
    stores and when we talk about caching in the next section, we'll come back and
    use NoSQL as a basic caching solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NoSQL is, despite the recent resurgence, not a new concept. By definition, anything
    that eschews SQL or relational database concepts qualifies as NoSQL, and there
    have been dozens of such solutions since the 1960s. It probably bears to be mentioned
    that we're not spending any time on these solutions—like Ken Thompson's DBM or
    BerkeleyDB—but instead the more modern stories.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start exploring the various NoSQL solutions that we can use to handle
    sessions, let's enable them in our application by providing an alternative username/password
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that back when we enabled third-party authentication proxies,
    we enabled sessions and stored them in our MySQL database in the `CheckLogin()`
    function. This function was only called in response to a `POST` request to the
    `ApplicationAuthorize` function. We''ll open this up to more methods. First, let''s
    create a new function called `CheckSession()`, if it doesn''t exist, which will
    validate the cookie''s session ID, and then validate against our session store
    if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that we also had a basic session struct and a method within
    `api.go`. We''ll move these to sessions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create our session store, we''ll make a new package called `sessions.go`
    within our API''s subdirectory/sessions. This is the skeleton without any NoSQL
    specific methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at a few simple NoSQL models that have strong third-party integrations
    with Go to examine how we can keep these sessions segregated and enable client-side
    access to our APIs in a way that they remain secure.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with Memcached, specifically because it's not really a datastore
    like our other options. While it is still a key-value store in a sense, it's a
    general purpose caching system that maintains data exclusively in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Developed by Brad Fitzpatrick for the once massively popular LiveJournal site,
    it was designed and intended to reduce the amount of direct access to the database,
    which is one of the most common bottlenecks in web development.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached was originally written in Perl but has since been rewritten in C and
    it has reached a point of large-scale usage.
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of this are already apparent—you get the speed of memory without
    the drag of disk access. This is obviously huge, but it precludes using data that
    should be consistent and fault tolerant without some redundancy process.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it's ideal for caching pieces of the presentation layer and
    sessions. Sessions are already ephemeral in nature, and Memcached's built-in expiration
    feature allows you to set a maximum age for any single piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps Memcached's biggest advantage is its distributed nature. This allows
    multiple servers to share data in-memory values across a network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth noting here that Memcached operates as a first-in, first out system.
    Expiration is only necessary for programmatic purposes. In other words, there's
    no need to force a maximum age unless you need something to expire at a certain
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `api.go` file, we''ll check a cookie against our Memcached session proxy,
    or we''ll create a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, here is our `sessions.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`GetSession()` attempts to grab a session by key. If it exists in memory, it
    will pass its value to the referenced `UserSession` directly. Note that we make
    one minor change when we verify a session in the following code. We increase the
    cookie''s expiry time by one hour. This is optional, but it allows a session to
    remain active if a user leaves one hour after their last action (and not their
    first one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Brad Fitzpatrick has joined the Go team at Google, so it should come as no surprise
    that he has written a Memcached implementation in Go. It should also come as no
    surprise that this is the implementation that we'll use for this example.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about this at [https://github.com/bradfitz/gomemcache](https://github.com/bradfitz/gomemcache)
    and install it using the `go get github.com/bradfitz/gomemcache/memcache` command.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is one of the earlier big names in the latter day NoSQL solutions; it
    is a document store that relies on JSON-esque documents with open-ended schemas.
    Mongo's format is called BSON, for Binary JSON. So, as you can imagine, this opens
    up some different data types, namely BSON object and BSON array, which are both
    stored as binary data rather than string data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the Binary JSON format at [http://bsonspec.org/](http://bsonspec.org/).
  prefs: []
  type: TYPE_NORMAL
- en: As a superset, BSON wouldn't provide much in the way of a learning curve, and
    we won't be using binary data for session storage anyway, but there are places
    where storing data can be useful and thrifty. For example, BLOB data in SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB has earned some detractors in recent years as newer, more feature-rich
    NoSQL solutions have come to the forefront, but you can still appreciate and utilize
    the simplicity it provides.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of decent packages for MongoDB and Go out there, but the
    most mature is mgo.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information and download links for MongoDB are available at [http://www.mongodb.org/](http://www.mongodb.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mgo can be found at [https://labix.org/mgo](https://labix.org/mgo) and it can
    installed using the `go get gopkg.in/mgo.v2` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mongo does not come with a built-in GUI, but there are a number of third-party
    interfaces and quite a few of them are HTTP-based. Here, I'll recommend Genghis
    ([http://genghisapp.com/](http://genghisapp.com/)) that uses just a single file
    for either PHP or Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can jump from authentication into session storage and retrieval
    using Mongo.
  prefs: []
  type: TYPE_NORMAL
- en: We'll supplant our previous example with another. Create a second file and another
    package subdirectory called `sessions2.go`.
  prefs: []
  type: TYPE_NORMAL
- en: In our `api.go` file, change the import call from `Sessions "github.com/nkozyra/api/sessions"`
    to `Sessions "github.com/nkozyra/api/sessionsmongo"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to replace the `"github.com/bradfitz/gomemcache/memcache"`
    import with the mgo version, but since we''re just modifying the storage platform,
    much of the rest remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The big change to our struct in this case is that we're setting our data to
    BSON instead of JSON in the string literal attribute. This is not actually critical
    and it will still work with the `json` attribute type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our method of connection obviously changes, but we also need to work within
    a collection (that is analogous to a table in database nomenclature), so we connect
    to our database and then the collection that are both named `session`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`GetSession()` works in almost exactly the same way, aside from the datastore
    method being switched to `Find()`. The `mgo.One()` function assigns the value
    of a single document (row) to an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Enabling connections using a username and password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To permit users to enter a username and password for their own connections instead
    of relying on a token or leaving the API endpoint open, we can create a piece
    of middleware that can be called directly into any specific function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll do several authentication passes. Here''s an example in
    the `/api/users` GET function, which was previously open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see the passes that we make here. First, we check for a token and then
    we check for an existing session. If this doesn't exist, we check for a login
    `username` and `password` and validate them.
  prefs: []
  type: TYPE_NORMAL
- en: If all these three fail, then we return an unauthorized error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we already have the `MiddlewareAuth()` function in another part of the
    code in `ApplicationAuthorize()`, so let''s move it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If users access the `/api/users` endpoint via a `GET` method, they will now
    need a `username` and `password` combination, an `access_token`, or a valid session
    in cookie data.
  prefs: []
  type: TYPE_NORMAL
- en: We also return the expected `user_id` on a valid authentication, which will
    otherwise return a value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing our users to connect to each other
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a step back into our application and add some functionality that's
    endemic to social networks—the ability to create connections such as friending.
    In most social networks, this grants read access to the data among those connected
    as friends.
  prefs: []
  type: TYPE_NORMAL
- en: Since we already have a valid view to see users, we can create some new routes
    to allow users to initiate connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a few endpoints to our `Init()` function in the `api.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't have a `PUT` request method here. Since our connections are
    friendships and binary, they won't be changed but they will be either created
    or deleted. For example, if we add a mechanism for blocking a user, we can create
    that as a separate connection type and allow changes to be made to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a database table to handle these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can now duplicate the code that we used to ensure that
    the users are authenticated for our `/api/connections` `POST` method and allow
    them to initiate friend requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ConnectionsCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the same code as our `/api/users` `GET` function. We'll come back to
    this after we look at the full example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check for an existing user. If we are trying to connect to a user
    that doesn''t exist, we return a 410: Gone HTTP error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check whether such a request has been initiated. If it has, then we
    also pass a Gone reference error. If neither of these error conditions is met,
    then we can create a relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With a successful call, we create a pending user relationship between the authenticated
    user and the intended one.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noted the duplication of code in this function. This is something
    that's typically settled with middleware and Go has some options that are available
    to inject in the process. In the next chapter, we'll look at some frameworks and
    packages that can assist in this as well to build our own middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a featured social network that is available through web services
    with forced TLS, authentication from users, and it has the ability to interact
    with other users.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also looked at offloading our session management to NoSQL
    databases and putting other web servers instead of Go to provide additional features
    and failover protections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll flesh out our social network even more as we try
    to interact with our API from the client side. With the foundation in place that
    allows this, we can then let users directly authenticate and interact with the
    API through a client-side interface without needing API tokens, while simultaneously
    retaining the ability to use third-party tokens.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also peek at using Go with complementary frontend frameworks like Go and
    Meteor to provide a more responsive, app-like web interface.
  prefs: []
  type: TYPE_NORMAL
