- en: Wireless Pentesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The era of wireless connectivity has enabled flexibility and mobility, but
    it has also ushered in many security issues. With wired connectivity, the attacker
    needs physical access in order to connect and attack. In the case of wireless
    connectivity, an attacker just needs the availability of the signal to launch
    an attack. Before proceeding, you should be aware of the terminology used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Point** (**AP**): This is used to connect wireless devices to wired
    networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Set Identifier** (**SSID**): This is a unique 0-32 alphanumeric identifier
    for a wireless LAN. It is human readable and simply put, it is the network name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic Service Set Identification** (**BSSID**): This is the MAC address of
    the wireless AP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel number**: This represents the range of the radio frequency used by
    AP for transmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The channel number might get changed due to the auto setting of AP, so, in this
    chapter, don't get confused. If you run the same program at a different time,
    the channel number might change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding wireless SSID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing wireless traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the clients of an AP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wireless deauth attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of the deauth attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to 802.11 frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '802.11 and 802.11x are defined as a family of wireless LAN technologies by
    IEEE. The following are the 802.11 specifications based on frequency and bandwidth:'
  prefs: []
  type: TYPE_NORMAL
- en: '`802.11`: This provides bandwidth up to 1-2 Mbps with a 2.4 GHz frequency band'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`802.11.a`: This provides bandwidth up to 54 Mbps with a 5 GHz frequency band'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`802.11.b` : This provides bandwidth up to 11 Mbps with a 2.4 GHz frequency
    band'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`802.11g`: This provides bandwidth up to 54 Mbps with a 2.4 GHz frequency band'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`802.11n`: This provides bandwidth up to 300 Mbps with both frequency bands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All components of `802.11` fall into either the **Media Access Control** (**MAC**)
    layer or the physical layer. The MAC layer is the subclass of the datalink layer.
    We have already covered the **Protocol Data Unit** (**PDU**) of the data link
    layer, which is called a frame, in [Chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml),
    *Scanning Pentesting*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, however, let''s understand the `802.11` frame format. The three major
    types of frame that exist in `802.11` are:'
  prefs: []
  type: TYPE_NORMAL
- en: The data frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The management frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These frames are assisted by the MAC layer. The following diagram depicts the
    format of the MAC layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccb2c53a-f4d3-4e73-94ee-e5a8183d779e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the three types of address are shown. **Address 1**,
    **Address 2**, and **Address 3** are the MAC addresses of the destination, AP,
    and source, respectively. This means **Address 2** is the BSSID of AP. In this
    chapter, our focus will be on the management frame, because we are interested
    in the subtypes of the management frame. Some common types of management frame
    are the authentication frame, the deauthentication frame, the association request
    frame, the disassociation frame, the probe request frame, and the probe response
    frame. The connection between the clients and APs is established by the exchange
    of various frames, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8288cfe-bdc3-4db7-80e7-b3179b31e09b.png)'
  prefs: []
  type: TYPE_IMG
- en: Frame exchange
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows the exchange of frames. These frames are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Beacon frame**: The AP periodically sends a Beacon frame to advertise
    its presence. The Beacon frame contains information such as SSID, channel number,
    and BSSID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Probe request**: The wireless device (client) sends out a probe request
    to determine which APs are in range. The probe request contains elements such
    as the SSID of the AP, supported rates, and vendor-specific info. The client sends
    the probe request and waits for the probe response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Probe response**: In response to the probe request, the corresponding
    AP will respond with a probe response frame that contains the capability information
    and supported data rates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Authentication request**: The client sends the authentication request
    frame that contains its identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Authentication response**: The AP responds with an authentication, which
    indicates acceptance or rejection. If shared key authentication exists, such as
    WEP, then the AP sends a challenge text in the form of an authentication response.
    The client must send the encrypted form of the challenged text in an authentication
    frame back to the AP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Association request**: After successful authentication, the client sends
    an association request that contains its characteristics, such as supported data
    rates and the SSID of the AP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Association response**: The AP sends an association response that contains
    acceptance or rejection. In the case of acceptance, the AP will create an association
    ID for the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our forthcoming attacks will be based upon these frames.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time for a practical. In the following section, we will go through
    the rest of the theory.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless SSID finding and wireless traffic analysis with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have done wireless testing with Back-Track or Kali Linux, then you will
    be familiar with the `airmon-ng` suite. The `airmon-ng` script is used to enable monitor
    mode on wireless interfaces. The Monitor mode allows a wireless device to capture
    frames without having to associate with an AP. We are going to run all our programs
    on Kali Linux. The following screenshot shows you how to set **mon0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30d14dcc-8380-4316-8e0c-59efb310e9bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting mon0
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `airmon-ng` script, it gives the wireless card a name, such
    as **wlan0**, as shown in the preceding screenshot. The `airmon-ng start wlan0`
    command will start **wlan0** in monitor mode, and **mon0** captures wireless packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write our first program, which gives three values: SSID, BSSID,
    and the channel number. The program name is `ssid_finder_raw.py`. Let''s see the
    code and explanation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the user to view the previously stored result, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user presses `Y`, then the program will open the `wireless_data.dat`
    file and fetch the information, such as SSID, BSSID, and channel number. If it
    is run the first time, the `wireless_data.dat` file will not be there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code creates a socket to capture all frames and bind them to `mon0`. I
    hope you have read [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml), *Sniffing
    and Penetration Testing* carefully. The only new thing is `3`. The 3 argument
    represents the protocol number, which indicates `ETH_P_ALL`. It means we are interested
    in every packet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an `ap_list` list, which will be used later. Open shelve files named
    `wireless_data.dat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Receive Beacon frames, extract the `SSID`; `BSSID`, and channel number information;
    and save it in the `wireless_data.dat` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `if fm[radio_tap_lenght] == "\x80"` syntax only allows Beacon frames. To
    understand the `radio_tap_lenght+4+6+6+6+2+12+1` syntax see in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd8873ef-ffe7-465b-8af0-78f9465b4d96.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By viewing the screenshot, you got the idea of numeric values used with `radio_tap_length`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the obtained information in `wireless_data.dat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to capture the frame using *Wireshark*, use `mon0` mode. The following
    frame is a Beacon frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1b0864d-1feb-4f0d-9dac-1bb4e99271f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The Wireshark representation of the Beacon frame
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot will clearly finish your doubts. The screenshot is
    self-explanatory. You can channel number, SSID, and BSSID.
  prefs: []
  type: TYPE_NORMAL
- en: 'I tested the code on two different wireless USB cards.  Here is the output
    of `ssid_finder_raw.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64ce38c0-49e7-44a1-ad7d-5803b4521f37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Always press *Ctrl* + *C* to store the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the code to find the SSID and MAC address of the APs using
    Scapy. You must be thinking that we have already performed the same task in the
    raw packet analysis. Writing code by using scapy is easier than a raw socket,
    actually, for research purposes, you should know about raw packet analysis. If
    you want some information that Scapy does not know, raw packet analysis gives
    you the freedom to create the desired sniffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the code from the start. The `scapy.all import *` statement
    imports all the modules of the Scapy library. The variable interface is set to
    `mon0`. An empty list named `ap_list` is declared. In the next line, the `info`
    function is defined and the `fm` argument is passed.
  prefs: []
  type: TYPE_NORMAL
- en: The `if fm.haslayer(Dot11):` statement is like a filter, which passes only `Dot11`
    traffic; `Dot11` indicates 802.11 traffic. The next `if((fm.type == 0) & (fm.subtype==8)):`
    statement is another filter, which passes traffic where the frame type is `0`
    and the frame subtype is `8`; type `0` represents the management frame and subtype
    `8` represents the Beacon frame. In the next line, the `if fm.addr2 not in ap_list:`
    statement is used to remove redundancy; if the AP's MAC address is not in `ap_list`,
    then it appends the list and adds the address to the list, as stated in the next
    line. The next line prints the output. The last `sniff(iface=interface,prn=info)`
    line sniffs the data with the interface, which is `mon0`, and invokes the `info()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `ssid.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac8dc7b7-c08f-4990-bf4e-40e6e4af6362.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I hope you now understand the `ssid.py` program. Let''s try and figure out
    the channel number of the AP. We will have to make some amendments to the code.
    The modified code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we have added one thing here, which is `ord(fm[Dot11Elt:3].info)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder what `Dot11Elt` is. If you open `Dot11Elt` in Scapy, you will
    get three things, `ID`, `len`, and `info`, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following class code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class code, `DSset` gives information about the channel number,
    so the `DSset` number is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not make it complex and let''s simply capture a packet using scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see that there are lots of Dot11Elt in
    the `0th` frame. Let''s check the `0th` frame in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bdc7183-5495-4275-923a-eec0ff9196f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Dot11Elt in the frame
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see that there are several `<Dot11Elt`. Every `Dot11Elt` has three
    fields. `ord(fm[Dot11Elt:3].info)` gives the channel number, which resides in
    the fourth place (according to the class code), which is `<Dot11Elt ID=DSset len=1
    info='x04'`. I hope you understand `Dot11Elt` now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Wireshark, we can see which outputs are represented by `Dot11Elt` in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1be321c5-a233-46b0-8e5f-4ff1697d4338.png)'
  prefs: []
  type: TYPE_IMG
- en: Dot11Elt representation in Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: The tagged parameters in the preceding screenshot are represented by `Dot11Elt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `scapt_ssid.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ef3d028-6c82-40ea-bf27-824b5dcadca4.png)'
  prefs: []
  type: TYPE_IMG
- en: Output with channel
  prefs: []
  type: TYPE_NORMAL
- en: Detecting clients of an AP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might want to obtain all the clients of a particular AP. In this situation,
    you have to capture the probe request frame. In scapy, this is called `Dot11ProbeReq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the frame in Wireshark in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d15778b2-85ee-46e3-a409-31e416595b92.png)'
  prefs: []
  type: TYPE_IMG
- en: The probe request frame
  prefs: []
  type: TYPE_NORMAL
- en: The probe request frame contains some interesting information, such as the source
    address and SSID, as highlighted in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to see the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the new things added in the preceding program. The user enters
    the AP's SSID of interest, which will be stored in the `ap_name` variable. The
    `if fm.haslayer(Dot11ProbeReq):` statement indicates that we are interested in
    the probe request frames. The `if client_name == ap_name:` statement is a filter
    and captures all requests that contain the SSID of interest. The `print "MAC ",
    fm.addr2` line prints the MAC address of the wireless device attached to the AP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `probe_req.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0c46329-8b26-4755-8168-ec337c65c4f4.png)'
  prefs: []
  type: TYPE_IMG
- en: A list of wireless devices are attached to the ` CITY PG3`.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless hidden SSID scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, for security reasons, users hide their accesspoint SSID and configure
    their computer to detect the access point. When you hide the SSID access point,
    then Beacon frames stop broadcasting their SSID. In this scenario, we have to
    capture all Probe request, Probe response, Reassociation request, Association
    response, and Association request frames sent by an associated client of the AP.
    For the purpose of our experiment, I am hiding the SSID, and then running the `ssid_finder_raw.py` code
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63ad8c2f-461b-4282-b1ff-5f17ab812e32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can clearly see the SSID of the first AP is
    not being shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `hidden_ssid_finder.py` program, but before running the program, make
    sure monitor mode is on, We are using monitor mode `mon0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a raw socket and bind it with the `mon0` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Ask the user to enter the MAC address of the AP, and remove the colon from
    the MAC address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create lists and dictionaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuously receive the frames as defined in the `filter_type` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the associated clients of the AP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the probe request frame of the associated clients, and extract the SSID
    from the probe request frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To gracefully exit, press *Ctrl* + *C*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code. The client must be connected to the AP for the code logic
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6556d0d3-090c-4ad6-9279-dff10521b741.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output shows that only one client is connected to the AP.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you have seen various sniffing techniques that gather information.
    In this section, you'll see how wireless attacks take place, which is a very important
    topic in pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: The deauthentication (deauth) attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deauthentication frames fall under the category of the management frames. When
    a client wishes to disconnect from the AP, the client sends the deauthentication
    frame. The AP also sends the deauthentication frame in the form of a reply. This
    is the normal process, but an attacker takes advantage of this process. The attacker
    spoofs the MAC address of the victim and sends the deauth frame to the AP on behalf
    of the victim; because of this, the connection to the client is dropped. The `aireplay-ng`
    program is the best tool to accomplish a deauth attack. In this section, you will
    learn how to carry out this attack using Python. But, you can take advantage of
    the output of the `ssid_finder_raw.py` code because the `ssid_finder_raw.py` program
    writes a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential modules and libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code opens the `wireless_data.dat` file, fetches the information,
    and displays it to the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code asks the user to enter the AP sequence number. If the user
    wants to specify any victim, then the user can provide the MAC of the victim''s
    machine; otherwise, the code will pick the broadcast address:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The channel number is being used by a selected AP; the following piece of code
    sets the same channel number for `mon0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very easy to understand. The `frame= RadioTap()/ Dot11(addr1=victim_mac,addr2=BSSID,
    addr3=BSSID)/ Dot11Deauth()` statement creates the deauth packet. From the very
    first screenshot in this chapter, you can check these addresses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code tells the threads to attack the deauth attack:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last line, `sendp(frame,iface=interface, count= 1000, inter= .1)`, `count`
    gives the total number of packets sent, and `inter` indicates the interval between
    the two packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `deauth.py` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/691a0ae7-cfca-4635-b748-94d0223e6e3d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The aim of this attack is not only to perform a deauth attack, but also to check
    the victim's security system. IDS should have the ability to detect the deauth
    attack. So far, there is no way of avoiding the attack, but it can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the deauth attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to detect a deauthentication attack. It
    is like a wireless IDS that detects the deauthentication attack. In this program,
    we will find which access points get deauth frames and how many. We will use the
    raw socket here to detect the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the `deauth_ids.py` program. Make sure the monitor is on; otherwise,
    the program will give an error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential module and library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The queue and counter will be used later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates and binds the raw socket to `mon0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function IDs receive the deauth frames, extract the BSSID, and
    put it in the global queue:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `insert_frame` function gets the deauth frame from the global
    queue and makes a counter to display it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates two threads that start the `ids()` and `insert_frame` functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In order to perform both the attack and detection, we need two machines with
    Linux and one wireless access point. One machine will do the attack, and the second
    will run our `deauth_ids.py` detection program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the output of the code. For testing purposes, run `deauth_ids.py`,
    and from the second machine, start the deauth attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60a44e84-dbbd-4df6-9c9f-424dd39a4237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see it is continuously displaying the victim BSSID, and its counter
    shows the number of frames received. Let''s see another screenshot in the continuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5653fa54-b845-41b6-8513-d1b2d4302397.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if the attacker changes target, our program can detect the attack
    on multiple access points.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about wireless frames and how to obtain information,
    such as SSID, BSSID, and the channel number, from the wireless frame using the
    Python script and the scapy library. We also learned how to connect a wireless
    device to the AP. After information gathering, we moved on to wireless attacks.
    The first attack we discussed was the deauth attack, which is similar to a Wi-Fi
    jammer. In this attack, you have to attack the wireless device and see the reaction
    of the AP or the intrusion detection system.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](2273f0c1-16dc-4c51-9d74-e51a70cbb900.xhtml), *Honeypot – Building
    Traps for Attackers*, you will learn how set traps for hacker, how to create fake
    reply or fake identities.
  prefs: []
  type: TYPE_NORMAL
