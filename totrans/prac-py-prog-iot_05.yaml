- en: Networking with MQTT, Python, and the Mosquitto MQTT Broker
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created two Python servers and accompanying web
    pages using both a RESTful API and Web Socket approach to networking. In this
    chapter, we will cover another networking topology that is common in the IoT world,
    known as **MQTT **or **Message Queue Telemetry Transport***.*
  prefs: []
  type: TYPE_NORMAL
- en: We will commence by setting up your development environment and installing the
    Mosquitto MQTT broker service on your Raspberry Pi. Then, we will learn about
    MQTT features using command-line tools that come with Mosquitto to help you to
    understand the core concepts in isolation. After that, we'll proceed to a Python
    IoT application that uses MQTT for its messaging layer—and yes, it'll be all about
    controlling the LED!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Mosquitto MQTT broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning MQTT by example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Python Paho-MQTT client library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling an LED with Python and MQTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web-based MQTT client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minimum of Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find this chapter''s source code in the `chapter04` folder in the
    GitHub repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paho-MQTT** **Client**: The Paho-MQTT client library ([https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be working with the breadboard circuit we created in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, *Figure 2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Mosquitto MQTT broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MQTT***,* or **Message Queue Telemetry Transport**, is a lightweight and
    simple messaging protocol targeted specifically for IoT applications. While a
    Raspberry Pi is powerful enough to leverage more complex messaging protocols,
    if you are using it as part of a distributed IoT solution, chances are you are
    going to encounter MQTT; hence, learning it is very important. Besides, its simplicity
    and open nature make it easy to learn and use.'
  prefs: []
  type: TYPE_NORMAL
- en: Our introduction to MQTT is going to be performed using a popular open source
    MQTT broker called *Mosquitto* that we will install on your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we cover in this chapter were performed with the Mosquitto broker
    and client version 1.5.7, which are MQTT protocol version 3.1.1-complaint. A different
    version of the broker or client tools will be suitable as long as they are MQTT
    protocol version 3.1.x-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Mosquitto MQTT broker service and client tools, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and execute the following `apt-get` command. This
    must be performed using `sudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the Mosquitto MQTT broker service has started, run the following
    command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the Mosquitto service has started with the following `service` command. We
    expect to see the `active (running)` text printed to the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the Mosquitto and MQTT protocol version with the `mosquitto -h` command.
    Here, we see that the Mosquitto broker is using MQTT version 3.1.1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will configure Mosquitto so that it can serve web pages and handle
    Web Socket requests. We will use these features when we come to build a web page
    client later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `chapter4` folder, there is a file named `mosquitto_pyiot.conf`, which
    is partially replicated here. There is one line in this file that we need to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For the exercises in this chapter, you need to update the `http_dir` setting
    on the last line so it's the absolute path to the `chapter04/mosquitto_www` folder
    on your Raspberry Pi. If you used the suggested folder, `/home/pi/pyiot`, when
    cloning the GitHub repository in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)*,
    Setting Up Your Development Environment*, then the path listed previously is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we copy the configuration in `mosquitto_pyiot.conf` using the following `cp`
    command into the appropriate folder so that it can be loaded by Mosquitto:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we restart the Mosquitto service to load our configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that the configuration has worked, visit the `http://localhost:8083` URL in
    a web browser on your Raspberry Pi, and you should see a page similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/525e2257-5a0c-4b58-a62a-8b11eb2f467e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Web page served by the Mosquitto MQTT broker
  prefs: []
  type: TYPE_NORMAL
- en: This is a giveaway to what we'll be doing later in this chapter! At the moment,
    while you can move the slider, it *will not* change the LED's brightness because
    we do not have the Python-side code running. We'll cover that in due course later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you experience problems getting the Mosquitto MQTT Broker to start, try
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `sudo mosquitto -v -c /etc/mosquitto/mosquitto.conf` in a Terminal.
    This will start Mosquitto in the foreground and any start up or configurations
    errors will be shown on your Terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the troubleshooting comments in the `mosquitto_pyiot.conf` file for additional
    suggestions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default configuration of Mosquitto after installation creates an *unencrypted*
    and *unauthenticated* MQTT broker service. The Mosquitto documentation contains
    details regarding its configuration and how to enable authentication and encryption.
    You will find links in the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Mosquitto installed and running, we can explore MQTT concepts
    and perform examples to see them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Learning MQTT by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MQTT is a broker-based *publishing* and *subscription* messaging protocol (frequently
    paraphrased as *pub/sub*), while an MQTT *broker* (just like the Mosquitto MQTT
    broker we installed in the previous section) is a server that implements the MQTT
    protocol. By using an MQTT-based architecture, your applications can essentially
    hand off all complex messaging handling and routing logic to the broker so they
    can remain solution-focused.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT clients (for example, your Python programs and the command-line tools we
    are about to use) create a subscription with the broker and *subscribe* to message
    topics they are interested in. Clients *publish *messages to a topic, and it is
    the broker that is then responsible for all message routing and delivery assurances.
    Any client may assume the role of a subscriber, a publisher, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple conceptual MQTT-based system involving a pump, water tank, and controller
    application is illustrated in *Figure 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/09bd86dd-a43b-4ff7-917c-c0be54738043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – MQTT example
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a high-level description of system components:'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the *Water Level Sensor MQTT client* as the software connected to a
    water level sensor in a water tank. This client assumes the role of a *publisher*
    in our MQTT example. It periodically sends (that is, *publishes)* messages about
    how full the water tank is to the MQTT broker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Think of the *Pump MQTT client* as a software driver that is capable of switching
    a water pump on or off. This client assumes both the role of a *publisher* and
    *subscriber* in our example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a *subscriber*, it can receive a message (via a *subscription)* instructing
    it to switch the pump on or off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a *publisher*, it can send a message indicating whether the pump is on and
    pumping water or off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of the *Controller MQTT client* as the application where all of the control
    logic resides. This client also assumes both the roles of a *publisher* and *subscriber:*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a *publisher*, this client can send a message that will tell the pump to
    switch on or off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a *subscriber*, this client can receive messages from both the water tank
    level sensor and the pump.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By way of example, the *Controller MQTT client *application could be configured
    to switch on the pump when the water level in the tank falls below 50% and switch
    off the pump when the level reaches 100%. This controller application may also
    include a dashboard user interface that displays the current water level in the
    tank and a status light indicating whether the pump is on or off.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note regarding our MQTT system is that each client is
    unaware of the other clients—a client only ever connects to and interacts with
    the MQTT broker, which then routes messages as appropriate to clients. This routing
    is achieved using message *topics,* which we will cover later in the section entitled
    *Exploring MQTT topics and wildcards*.
  prefs: []
  type: TYPE_NORMAL
- en: It's understandable why the pump would need to receive a message to tell it
    to turn on or off, but what about the pump's need to also send a message stating
    whether it is on or off? If you wondered about this, here is the reason. MQTT
    messages are send-and-forget, meaning that a client does not get an application-level
    response to a message that it publishes. So, in our example, while the controller
    client can publish a message asking the pump to turn on, without the pump publishing
    its status, the controller has no way of knowing whether the pump actually turned
    on.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the pump would publish its on/off status every time it turns on
    or off. This would allow the controller's dashboard to update the pump's status
    indicator in a timely manner. Furthermore, the pump would also periodically publish
    its status (just like the water level sensor) independent of any requests it receives
    to turn on or off. This way, the controller application can monitor the connection
    and availability of the pump and detect whether the pump goes offline.
  prefs: []
  type: TYPE_NORMAL
- en: For now, if you can grasp the basic ideas presented in the preceding example,
    then you are well on your way to understanding at a deeper level the core MQTT
    concepts that will be our focus for the remainder of this chapter. By the time
    we finish, you will have a fundamental end-to-end understanding of how to work
    with and design MQTT-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by learning how to publish and subscribe to messages.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and subscribing MQTT messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work through the steps to send (that is, publish) and receive (that
    is, subscribe to) messages using MQTT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Terminal, run the following command. `mosquitto_sub` (Mosquitto subscribe)
    is a command-line tool to *subscribe* to messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` (--verbose): verbose is so we get both the message *topic* and *message* payload
    printed on the Terminal.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h` (--host): localhost is the host of the broker we want to connect to; here
    it''s the one we just installed. The default port used is 1883.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` (--topic): `pyiot` is the topic we want to subscribe to and listen to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will require two and sometimes three Terminal sessions
    for the examples. The first line of a code block will indicate which Terminal
    you need to run a command in; for example, **Terminal #1** in the preceding code
    block, and **Terminal #2** in the following code block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a second Terminal and run the following command.`mosquitto_pub` (Mosquitto
    publish) is a command-line tool to *publish* messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-h` and `-t` have the same meaning as in the preceding subscription command.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m ''hello!''` (--message) is the message we want to publish. Messages in
    MQTT are simple strings— if you''re wondering about JSON, it just needs to be
    serialized/deserialized to strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On **Terminal #1**, we see the topic and message, `hello!`, printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The final line is in the format <*topic>* <*message payload>.*
  prefs: []
  type: TYPE_NORMAL
- en: The `hello!` message is preceded by the topic name, `pyiot`, because we have
    used the `-v` option to `mosquitto_sub`. Without the `-v` option, if we were subscribing
    to multiple topics, we could not identify which topic a message belonged to.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we've learned how to publish and subscribe to messages with a simple topic.
    But is there any way we can organize these messages in a better way? Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MQTT topics and wildcards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MQTT *topics* are used to categorize, or group, messages together in a hierarchical
    format. We have already been working with topics in our proceeding command-line
    examples, but in a non-hierarchical fashion. W*ildcards*, on the other hand, are
    special characters used by a *subscriber *to create flexible topic matching patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few hierarchical topic examples from a hypothetical building with sensors.
    The hierarchy is delimited by the `/` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '`level1/lounge/temperature/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/temperature/sensor2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/lighting/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/temperature/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/lighting/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no need to pre-create a topic on an MQTT broker. Using the *default* broker
    configuration (which we are), you just publish and subscribe to topics at will.
  prefs: []
  type: TYPE_NORMAL
- en: When the Mosquitto broker is configured to use authentication, there is the
    possibility to restrict access to topics based on a client ID and/or username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages *must* be published to a *specific* topic such as `pyiot`, while subscriptions
    can be made to a specific topic, or a range of topics, by using the wildcard characters, `+` and `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` is used to match a single element of the hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#` is used to match *all* remaining elements in a hierarchy (it can only be
    at the end of a topic query).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscriptions to topics and wildcards are best explained by example. Using
    the aforementioned hypothetical building with sensors, consider the examples in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| We want to subscribe to... | Wildcard topic | Topic matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| All **temperature** sensors everywhere | `+/+/**temperature**/+` |'
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/**temperature**/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/**temperature**/sensor2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/**temperature**/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| All **light** sensors everywhere | `+/+/**lighting**/+` |'
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/**lighting**/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/**lighting**/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Every sensor on **level 2** | `**level2**/+/+/+` |'
  prefs: []
  type: TYPE_TB
- en: '`**level2**/bedroom1/temperature/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**level2**/bedroom1/lighting/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Every sensor on **level 2**(a simpler way where `#` matches every remaining
    child) | `**level2**/#` |'
  prefs: []
  type: TYPE_TB
- en: '`**level2**/bedroom1/temperature/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**level2**/bedroom1/lighting/sensor1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Only **sensor1** everywhere | `+/+/+/**sensor1**` |'
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/temperature/**sensor1**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/lighting/**sensor1**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/temperature/**sensor1**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/lighting/**sensor1**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Only **sensor1** everywhere(a simpler way where `#` matches every remaining
    child) | `#/**sensor1**` | Invalid because # can only be at the end of the topic
    query |'
  prefs: []
  type: TYPE_TB
- en: '| Every topic | `#` | Matches everything |'
  prefs: []
  type: TYPE_TB
- en: '| Broker information | `$SYS/#` | This is a special reserved topic where the
    broker publishes information and runtime statistics. |'
  prefs: []
  type: TYPE_TB
- en: Table 1 - MQTT wildcard topic examples
  prefs: []
  type: TYPE_NORMAL
- en: What may be evident from the preceding examples is that you need to take care
    when designing topic hierarchies for an application so that subscribing to multiple
    topics using wildcards is consistent, logical, and easy.
  prefs: []
  type: TYPE_NORMAL
- en: If you are subscribing using the `+` or `#` wildcards with `mosquitto_sub`,
    remember to use the `-v` (--verbose) option so that the topic name is printed
    in the output, for example, `mosquitto_sub -h localhost -v -t '#'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try a few examples for yourself on the command line by mixing and matching
    the preceding topics and wildcards to get a feel for how topics and wildcards
    work. Following are the steps for one example where `mosquitto_sub` subscribes
    to all childtopics that have the parent *temperature* two levels down from the
    root topic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Terminal, start a subscriber that subscribes to a wildcard topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the topics from *Table 1 – MQTT wildcard topic examples,* here are two
    `mosquitto_pub` commands that will publish messages that will be received by the `mosquitto_sub`
    command in **Terminal #1**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have just seen how to subscribe to topic hierarchies using the wildcard characters, `+`
    and `*`. Using topics and wildcards together is a design decision you'll need
    to make on a per-project level based on how your data needs to flow and how you
    envision it will be both published and subscribed by client applications. Time
    invested in designing a congruent yet flexible wildcard-based topic hierarchy
    will go a long way to helping you to build simpler and reusable client code and
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn all about message Quality of Service and how this impacts
    the messages you send through an MQTT Broker.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Quality of Service to messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MQTT provides three **Quality of Service** (**QoS**) levels for *individual message delivery—*I
    am emphasizing *individual message delivery* because QoS levels apply to the delivery
    of individual messages and not to a topic. This will become clearer as you work
    through the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you, as the developer, stipulate the QoS for your messages, it''s the
    broker that is responsible for ensuring that the message delivery adheres to the
    QoS. Here is the QoS you can apply to a message and what they mean for delivery:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **QoS level** | **Meaning** | **Number of messages delivered** |'
  prefs: []
  type: TYPE_TB
- en: '| Level 0 | The message will be delivered at most once, but maybe not at all.
    | 0 or 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Level 1 | The message will be delivered at least once, but perhaps more.
    | 1 or more |'
  prefs: []
  type: TYPE_TB
- en: '| Level 2 | The message will be delivered exactly once. | 1 |'
  prefs: []
  type: TYPE_TB
- en: Table 2 – Message QoS levels
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking the question: Level 0 and 1 seem a bit random, so why not
    just always use Level 2? The answer is *resources*. Let''s see why...'
  prefs: []
  type: TYPE_NORMAL
- en: The broker and clients will consume more resources to process higher-level QoS
    messages than lower-level QoS messages—for example, the broker will need more
    time and memory to store and process messages, while both the broker and clients
    consume more time and network bandwidth with acknowledgment confirmations and
    connection handshaking.
  prefs: []
  type: TYPE_NORMAL
- en: For many use cases, including the examples that follow in this chapter, we will
    not notice a difference between QoS levels 1 and 2, nor will we be able to practically
    demonstrate them (Level 0 gets omitted for a good reason, which we'll see later
    on when we cover message retention and durable connections). However, set your
    mind to a distributed IoT system with thousands of sensors publishing thousands
    or more messages every minute, and now designing around QoS starts to make a little
    more sense.
  prefs: []
  type: TYPE_NORMAL
- en: QoS levels apply to both message *subscriptions* and message *publishing,* which
    may seem odd when you first think it through. For example, a client may publish
    a message with a QoS of 1 to a topic, while another client may subscribe to that
    topic with a QoS of 2 (I know I said QoS relates to messages, not topics, but
    here it's the messages flowing *through* the topic that the QoS relates to). What
    QoS is this message, 1 or 2? For the subscriber, it's 1—let's find out why.
  prefs: []
  type: TYPE_NORMAL
- en: It's the *subscribing* client that chooses the *highest* QoS of messages it
    wants to receive—but it may get lower. So, effectively, this means the delivery
    QoS received by a client is downgraded to the lowest QoS of the publication or
    subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples for you to ponder:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Publisher sends message | Subscriber subscribing at | What subscriber gets
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 0 | Delivery of message adhering to a QoS 0 (subscriber gets
    the message 0 or 1 time) |'
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 2 | Delivery of message adhering to a QoS 2 (subscriber gets
    the message exactly once) |'
  prefs: []
  type: TYPE_TB
- en: '| QoS 0 | QoS 1 | Delivery of message adhering to QoS 0 (subscriber gets the
    message 0 or 1 time) |'
  prefs: []
  type: TYPE_TB
- en: '| QoS 1 | QoS 2 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 1 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  prefs: []
  type: TYPE_TB
- en: Table 3 – Publisher and subscriber QoS examples
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from these examples is that, in practice, when designing or integrating
    IoT solutions, you need to be aware of the QoS used by both publishers and subscribers
    on either side of a topic—QoS cannot be interpreted on either side in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to play out QoS scenarios and see client-broker interactions
    in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Terminal, run the following command to start a subscriber:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In a second Terminal, run the following command to publish a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are again subscribing on **Terminal #1**, and publishing on **Terminal
    #2**. Here are the new options used with both `mosquitto_sub` and `mosquitto_pub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: Turn on debugging messages'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q <level>`: QoS level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With debugging enabled (`-d`), try changing the `-q` parameter (to 0, 1, or
    2) on either side and publishing new messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the logged messages in **Terminal #1** and **Terminal #2**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Among the debugging messages that will appear in **Terminal #1** and **Terminal
    #2**, you will obverse the QoS downgrade occurring at the subscription side (look
    for `q0`, `q1`, or `q2`) while, on both sides, you will also notice different
    debug messages depending on the QoS specified as the client and broker perform
    handshaking and exchange acknowledgments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the debug output for the subscriber on **Terminal #1**. Notice
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At line (1), we subscribed using QoS 2 (`-q 2`). This is reflected in the debug
    output, `QoS: 2`, on line (2).'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On line (3), we see the QoS downgrade. The message received is QoS 1 (`q1`),
    which is the QoS that the message was published in **Terminal #1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QoS is one of the more complex MQTT concepts to grasp. You will find links in
    the *Further reading* section if you want to go deeper into QoS levels and the
    lower level communications that take place between publishers, subscribers, and
    the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered message QoS levels, we will next learn about two MQTT
    features that ensure offline clients can receive past messages when they come
    back online. We will also see how QoS levels impact these features.
  prefs: []
  type: TYPE_NORMAL
- en: Retaining messages for later delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An MQTT broker can be instructed to retain messages published to a topic. Message
    retention comes in two flavors, known as *retained messages* and *durable connections*:'
  prefs: []
  type: TYPE_NORMAL
- en: A **retained message** is where the broker retains the *last message* published
    on a topic. This is also commonly referred to as the *last known good message*,
    and any client subscribing to a topic automatically gets this message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durable connections** are also about retaining messages but in a different
    context. If a client tells the broker it wants a *durable connection*, then the
    broker retains QoS 1 and 2 messages for that client while it''s offline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless configured specifically, Mosquitto *does not* retain messages or connections
    across server restarts. To persist this information across a restart, a Mosquitto
    configuration file must contain the entry `persistence true`. A default installation
    of Mosquitto on a Raspberry Pi should include this entry, however, to be sure
    it has also been included in `mosquitto_pyiot.conf` that we installed earlier.
    Please consult the official Mosquitto documentation for more information and configuration
    parameters regarding persistence. You will find a link in the *Further reading*
    section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about retained messages and cover durable connections in
    the subsequent section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a retained message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A publisher can ask the broker to retain a message as the *last known good*
    message for a topic. Any newly connecting subscriber will immediately receive
    this last retained message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step through an example to demonstrate retained messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following, noting that we''re starting with **Terminal #2**, the publisher
    in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A new option has been added,`-r` (--retain), to tell the broker that this message
    should be retained for the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Only a single retained message can exist for a topic. If you publish another
    message using the `-r` option, the previous retained message will be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a subscriber in another Terminal, and immediately you will receive the
    retained message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *C* in **Terminal #1** to terminate `mosquitto_sub`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start `mosquitto_sub` again using the same command from *step 2*, and you will
    see the retained message received again in **Terminal #1**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can still publish normal messages (that is, *not* using the `-r` option),
    however, it's the last retained message indicated by the use of the `-r` option
    that newly connecting subscribers will receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final command shows how to clear a previously retained message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are publishing (with `-r`) an empty message with `-m ''`. Note that
    we can use `-n` as an alternative to `-m ''` to indicate an empty message. The
    effect of retaining an empty message is to actually clear the retained message.
  prefs: []
  type: TYPE_NORMAL
- en: When you send an empty message to a topic to remove a retained message, any
    clients currently subscribed to the topic (including offline clients with durable
    connections—see the next section) will receive the empty message, so your application
    code must test for and handle empty messages appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand and know how to use retained messages, we can now explore
    the other type of message retention available with MQTT, called *durable connections*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating durable connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A client subscribing to a topic can ask the broker to retain, or queue, messages
    for it while it''s offline. This is known in MQTT terminology as a *durable connection*.
    For durable connections and delivery to work, the subscribing client needs to
    be configured and subscribe in a certain way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client *must* *provide* a unique client ID to the broker when it connects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client *must subscribe* with a QoS 1 or 2 (levels 1 and 2 guarantee delivery,
    but level 0 does not).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client is only guaranteed to get messages *published* with QoS 1 or 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two points concern an example where knowing QoS on both the publishing
    and subscribing sides of a topic is very important for IoT application design.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT brokers can—and the default configuration of Mosquitto on the Raspberry
    Pi does—retain messages for durable connections between broker restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a subscriber, and then immediately terminate it with *Ctrl* + *C* so
    that it is offline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The new options used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i <client id>` (–id <client id>) is a unique client ID (this is how the broker
    identifies the client).'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` (--disable-clean-session) instructs the broker to keep any QoS 1 and 2
    messages that arrive at subscribed topics even while the client is disconnected
    (that is, *retain* the messages).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worded a bit backward, but by starting the subscriber with the `-c` option,
    we've asked the broker to create a *durable connection* for our client by not
    clearing out any stored messages on connecting.
  prefs: []
  type: TYPE_NORMAL
- en: If you subscribe to a range of topics using wildcards (for example, `pyiot/#`)
    and request a durable connection, then all messages for all topics in the wildcard
    hierarchy will be retained for your client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Publish a few messages (while the subscriber in **Terminal #1** is still offline):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Bring the subscriber in **Terminal #1** back online, and we will see that the
    messages published in *step 2* are delivered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Try *steps 1* to *3* again, only this time omit the `-c` option from the subscriber
    in *steps 1* and *3* and you will notice that no messages are retained. Also,
    when you connect *without* the `-c` flag when there are retained messages waiting
    to be delivered, then all retained messages are purged (and is how you would clear
    retained messages for a client if you wanted to).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using both *retained messages* (that is, last known good message)
    and *durable connections* together on a single topic and reconnect an offline
    subscriber, you will *receive the retained message twice—*one is the *retained
    message,* while the second is from the *durable connection*.
  prefs: []
  type: TYPE_NORMAL
- en: When building solutions around MQTT, your knowledge of retained messages and
    durable connections will be key to designing systems that are resilient and reliable,
    particularly where you need to handle offline clients. Retained (last known good)
    messages are ideal for initializing a client when they come back online, while durable
    connections will help you to retain and deliver messages in bulk for any offline
    client that must be able to consume every message for topics that it subscribes
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! We have covered a lot and you actually now know most of the core
    MQTT features you will use when building an MQTT-based IoT solution. Our last
    feature to learn about is known as a *Will*.
  prefs: []
  type: TYPE_NORMAL
- en: Saying goodbye with a Will
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final MQTT feature for exploration is known as a Will. A client (publisher
    or subscriber) can register a special *Will* message with the broker so that if
    the client dies and disconnects from the broker abruptly (for example, it loses
    its network connection or its batteries go flat), the broker on the clients' behalf
    will send out the *Will* message notifying subscribers of the device's demise.
  prefs: []
  type: TYPE_NORMAL
- en: Wills are just a message and topic combination similar to what we have been
    using previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see Wills in action, and for this, we''re going to need three Terminals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal and start a subscriber with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The new options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--will-payload`: This is the Will message.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--will-topic`: This is the topic the Will message will be published on. Here
    we are using the same topic that we are subscribing to, but it could be a different
    topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--will-qos`: This is the QoS for the Will message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--will-retain`: If this option is present, then if the client disconnects
    abruptly, the Will message will be retained by the broker as the *retained (last
    known good) message* for the Will topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start a subscriber in a second Terminal with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And in a third Terminal, publish a message using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you execute the `mosquitto_pub` command in *step 3* on **Terminal #3**,
    you should see `hello` printed on *both* the subscribers in **Terminals #1** and
    **#2**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Terminal #1**, press *Ctrl* + *C* to terminate the subscriber that registered
    the Will with the broker. *Ctrl* + *C* is seen as a non-graceful or abrupt disconnection
    from the broker.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Terminal #2**, we will see the Will''s `Good Bye` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Okay, what about a graceful disconnection where the subscriber properly closes
    its connection with the broker? We can demonstrate this using the `-C` option
    with `mosquitto_sub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the subscriber in **Terminal #1** with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new `-C <count>` option tells `mosquitto_sub` to disconnect (gracefully)
    and exit after it has received the specified number of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice the `Good Bye` message printed immediately. This is because
    we specified the `--retain-will` option previously in **Terminal #1**. This option
    made the Will message become the retained or last known good message for the topic,
    so newly connecting clients will receive this message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Terminal #3**, publish a new message, and the subscriber in **Terminal
    #1** will exit. Notice in **Terminal #3** that the Will message, `Good Bye, Again`,
    is *not* received. This is because our **Terminal #1** subscriber disconnected
    *gracefully* from the broker because of the `-C` option—and in case you are wondering
    about `2` in  `-C 2`, the retained Will message counted as the first message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done! If you have worked your way through each of the preceding MQTT examples,
    then you have covered the core concepts and use of MQTT and the Mosquitto broker.
    Do remember that all of these principles will apply to any MQTT broker or client
    since MQTT is an open standard.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've learned about message subscriptions and publication, how we segregate messages
    using topics, and how features including QoS, message retention, durable connections,
    and Wills can be leveraged to control how messages are managed and delivered.
    This knowledge alone provides you with the foundations to build complex and resilient
    distributed IoT systems using MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave you with one final tip (which caught me out a few times when I started
    with MQTT).
  prefs: []
  type: TYPE_NORMAL
- en: If your live, retained, or queued durable connection messages seem to be vanishing
    into a black hole, then check the QoS levels on both your subscribing and publishing
    clients. To monitor all messages, start a command-line subscriber with QoS 2,
    listening to the `#` topic, with both verbose and debug options enabled, for example, `mosquitto_sub
    -q 2 -v -d -h localhost -t '#'`.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed all of our examples from the MQTT-by-example section and
    learned how to interact with an MQTT broker from the command line. Next, I want
    to briefly make mention of public broker services. Following this, we'll get into
    code and see how we can leverage MQTT with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using MQTT broker services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several MQTT broker service providers on the internet that you can
    use to create MQTT-based messaging applications if you do not want to host your
    own MQTT broker. Many also offer free public MQTT brokers that you can use for
    testing and quick proofs-of-concept—but remember they are free and public, so
    do not publish any sensitive information!
  prefs: []
  type: TYPE_NORMAL
- en: If you experience frustration, disconnections, or unexpected behavior with a
    free public broker service, then test and verify your application with a local
    broker. You cannot reliably know or verify the traffic congestion, topic usage,
    or configuration details of an open public broker and how that may be impacting
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few free public brokers you can try. Just replace the `-h`*localhost* option
    in the preceding examples with the address of the broker. Visit the following
    pages for more information and instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://test.mosquitto.org](https://test.mosquitto.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://broker.mqtt-dashboard.com](http://broker.mqtt-dashboard.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ot.eclipse.org/getting-started](https://iot.eclipse.org/getting-started/#sandboxes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will move a level higher. Finally, we're up to
    the Python bit of MQTT! Rest assured that everything we just covered will be invaluable
    when you develop IoT applications that use MQTT because the command-line tools
    and examples we covered will become an important part of your MQTT development
    and debugging toolkit. We will be applying the core MQTT concepts we have learned
    already, only this time using Python and the Paho-MQTT client library.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Python Paho-MQTT client library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into Python code, we first need an MQTT client library for Python.
    At the start of this chapter in the *Technical requirements* section, we installed
    the Paho-MQTT client library, which was part of `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to MQTT and have not read the preceding section, *Learning MQTT
    by example*, I recommend stopping now and reading it first so you gain an understanding
    of MQTT concepts and terminology that will be used in the Python examples that
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: The Paho-MQTT client library comes from the Eclipse Foundation, which also maintains
    the Mosquitto MQTT broker. In the *Further reading* section, you will find a link
    to the official *Paho-MQTT Client Library API* documentation. After completing
    this chapter, if you wish to deepen your understanding of this library and its
    capabilities, I recommend reading through the official documentation and the examples
    found therein.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python Paho-MQTT library has three core modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: This gives you full life cycle management of MQTT in your Python
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**: This is a helper module for message publishing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: This is a helper module for message subscribing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client module is ideal if you are creating more complex and long-running
    IoT applications, whereas the publisher and subscriber helper modules are convenient
    for short-lived applications and situations where full life cycle management is
    not warranted.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python examples will connect to your local Mosquitto MQTT broker
    that we installed in the *Installing the Mosquitto MQTT broker* section previously.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the Paho client module so we can create a more complete MQTT
    example. However, once you can follow and understand the client module, creating
    alternatives using the helper modules will be a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, we will be working with the breadboard circuit we created in
    [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)*, Getting Started with
    Python and IoT*, *Figure 2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic familiarity with the Paho-MQTT library, we will next start
    by briefly reviewing what the Python program and the accompanying web page client
    do and see Paho-MQTT in action.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED with Python and MQTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in the *Installing the Mosquitto MQTT broker* section, we tested
    the installation by visiting the `http://localhost:8083` URL, which gave us a
    web page with a slider. However, at the time, we could not change the LED's brightness.
    When you moved the slider, the web page was publishing MQTT messages to the Mosquitto
    broker, but no program was receiving the messages to change the LED's brightness.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll see the Python code that subscribes to a topic called
    `led` and processes the messages generated by the slider. We will start by running
    the Python code and making sure we can change the LED's brightness.
  prefs: []
  type: TYPE_NORMAL
- en: Running the LED MQTT example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will find the code in the `chapter04/mqtt_led.py` file. Please review this
    file before proceeding to get an overall idea of what it contains and then follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program in a Terminal with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open a second Terminal window and try the following, and the LED should
    turn on (be careful to make sure the JSON string is formed correctly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice the `-r` (`--retain`) option used in *step 2*? Terminate and
    restart `mqtt_led.py` and watch the log output in **Terminal #1** and the LED.
    You should notice on startup that `mqtt_led.py` receives the LED''s brightness
    value from the topic''s *retained message* and initializes the LED''s brightness
    accordingly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, visit the `http://localhost:8083` URL and make sure the LED changes its
    brightness as you move the slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the web page open, and try the command in *step 2* again. Observe what
    happens to the slider—it will stay in sync with the new level value you specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see durable connections in action. Terminate `mqtt_led.py` again
    and perform the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the web page, move the slider around randomly for about 5 seconds. As you
    move the slider, messages are being published to the broker on the `led` topic.
    They will be queued for delivery to `mqtt_led.py` when it reconnects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart `mqtt_led.py` and observe the Terminal and LED. You will notice a flood
    of messages on the Terminal, and the LED will flicker as the queued messages are
    delivered and processed by `mqtt_led.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Mosquitto is configured to queue 100 messages per client that are
    using a durable connection. A client is identified by its client ID that you provide
    when connecting to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have interacted with and seen `mqtt_led.py` in action, let's take
    a look at its code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discuss the code found in `chapter04/mqtt_led.py`, pay particular attention
    to how the code connects to the MQTT broker and manages the connection life cycle.
    Furthermore, as we cover how the code receives and processes messages, try to
    relate the code workflow back to the command-line examples that we used to publish
    the message in the previous subsection, *Running the LED MQTT example*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an understanding of our Python code and how it integrates with
    our MQTT broker, you'll have an end-to-end working reference solution built around
    MQTT messaging that you can adapt for your own needs and projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at the imports. As usual, we will skip over any common
    code that we have already covered in previous chapters, including logging setup
    and **GPIOZero**-related code.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only new import we have in this example is for the Paho-MQTT client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At line (1), we are importing the Paho-MQTT `client` class and giving it the
    alias, `mqtt`. As mentioned previously, this is the client class that will allow
    us to create a full life cycle MQTT client in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will consider global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `BROKER_HOST` and `BROKER_POST` variables at line (2) are referring to
    our locally installed Mosquitto MQTT broker. Port `1883` is the standard default
    MQTT port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At line (3), we define `CLIENT_ID`, which will be the unique client identifier
    we use to identify our program with the Mosquitto MQTT broker. We *must* provide
    a unique ID to the broker so that we can use *durable connections*.
  prefs: []
  type: TYPE_NORMAL
- en: At line (4), we define the MQTT topic that our program will be subscribing to,
    while at line (5), the `client` variable is a placeholder that will be assigned
    the Paho-MQTT client instance, which we'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The set_led_level(data) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`set_led_level(data)` at line (6) is where we integrate with GPIOZero to change
    the brightness of our LED and the method similar to the corresponding methods
    we covered in [Ch](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)[apter](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml) [3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, so we will not cover
    the internals here again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The data parameter is expected to be a Python dictionary in the form of `{
    "level": 50 }`, where the integer is between 0 and 100 to indicate the brightness
    percentage.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the callback functions for MQTT. We'll start by reviewing `on_connect()` and
    `on_disconnect()`.
  prefs: []
  type: TYPE_NORMAL
- en: The on_connect() and on_disconnect() MQTT callback methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `on_connect()` and `on_disconnect()` callback handlers are examples of the
    full life cycle that is available using the Paho `client` class. We will see how
    to instantiate a Paho `client` instance and register these callbacks later when
    we cover the `init_mqtt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of interest to `on_connect()` at line (7) in the following code
    block are `client`, which is a reference to the Paho `client` class, and `result_code`,
    which is an integer describing the connection result. We see `result_code` used
    at line (8) to test the success of the connection. Notice the `connack_string()` method,
    which is used for a connection failure to translate `result_code` into a human-readable
    string.
  prefs: []
  type: TYPE_NORMAL
- en: When we speak of the MQTT *client* and see the `client` parameter at line (7)
    in the following code block, remember this is our Python code's client connection *to
    the broker*, NOT a reference to a client program such as the web page. This client
    parameter is very different in meaning to the client parameter we saw used in
    callback handlers for our Flask-SocketIO Web Socket server in *[Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    Networking with RESTful APIs and Web Sockets Using Flask*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, the `user_data` parameter can be used to pass around private
    data between a Paho client''s callback methods, while `flags` is a Python dictionary
    containing response and configuration hints from the MQTT broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At line (9), we see the Paho `client` instance method, `subscribe()`, used to
    subscribe to the `led` topic using the `TOPIC` global variable, which we saw defined
    earlier. We also indicate to the broker that our subscription is a QoS level 2.
  prefs: []
  type: TYPE_NORMAL
- en: Always subscribe to topics in an `on_connect()` handler. This way, if the client
    ever loses the connection to the broker, it can re-establish subscriptions when
    it reconnects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at line (10) in the following, we have the `on_disconnect()` handler,
    where we are simply logging any disconnects. The method parameters have the same
    meanings as for the `on_connect()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will now move on to the callback method that handles incoming messages for
    the `led` topic that we subscribed to in `on_connect()` on line (9).
  prefs: []
  type: TYPE_NORMAL
- en: The on_message() MQTT callback method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's the `on_message()` handler at line (11) that is called whenever a new message
    for a subscribed topic is received by our program. The message is available through
    the `msg` parameter, which is an instance of `MQTTMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At line (12), we access the `payload` property of `msg` and decode it into
    a string. We expect our data to be a JSON string (for example, `{ "level": 100
    }`), so we parse the string into a Python dictionary using `json.loads()` and
    assign the result to `data`. If the message payload is not valid JSON, we catch
    the exception and log an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using the `topic` property of `msg` on line (13), we check that it matches our
    expected `led` topic, which it will in our case since our program is only subscribing
    to this specific topic. However, this provides a point of reference regarding
    where and how you would perform conditional logic and routing for a program that
    subscribes to multiple topics.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at line (14), we pass our parsed message to the `set_led_level()` method,
    which, as discussed, changes the brightness of our LED.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how the Paho client is created and configured.
  prefs: []
  type: TYPE_NORMAL
- en: The init_mqtt() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We see the Paho-MQTT `client` instance created and assigned to the global `client`
    variable at line (15). A reference to this object is the  `client` parameter we
    saw previously in the `on_connect()`, `on_disconnect()`, and `on_message()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `client_id` parameter is set to be the client name we defined earlier in
    `CLIENT_ID`, while `clean_session=False` tells the broker that it *must not clear*
    any stored messages for our client when we connect. As we discussed earlier in
    the command-line examples, this is the back-to-front way of saying we want a durable
    connection so any messages published to the `led` topic are stored for our client
    when it''s offline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: An important point to note is on line (16). Our program is using the standard
    Python logging packages, so we need to make this call to `client.enable_logger()` to
    ensure that we get any Paho-MQTT client log message. Missing this call means helpful
    diagnostic information may not get logged.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at line (18), we connect to the Mosquitto MQTT broker. It's our `on_connect()`
    handler that will be called once the connection is established.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how our program is started.
  prefs: []
  type: TYPE_NORMAL
- en: Main entry point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After initializing our LED and client instances, we get to the program's main
    entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are registering a signal handler to capture *Ctrl* + *C* key combinations
    at line (19). The `signal_handler` method (not shown) simply turns off our LED
    and gracefully disconnects from the broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At line (20), the call to `client.loop_start()` is what allows our client to
    start, connect to the broker, and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the LED program is stateless? We are not storing or persisting
    any LED level in code or to disk. All our program does is subscribe to a topic
    on the broker and change the LED's brightness using GPIOZero. We effectively hand
    all state management over to the MQTT broker by relying on MQTT's retained message
    (also known as the *last known good message*) facility.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished exploring the Python code that interacts with both the
    LED and MQTT broker. We learned how to use the Python Paho-MQTT library to connect
    to an MQTT broker and subscribe to an MQTT topic. As we received messages on the
    subscribed topic, we saw how to process them and changed the brightness level
    of our LED according to the message payload.
  prefs: []
  type: TYPE_NORMAL
- en: The Python and Paho-MQTT framework and example we covered will provide you with
    a solid starting point for your own MQTT-based IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will be looking at a web client that uses MQTT together with Web Sockets.
    This web client will connect to our Mosquitto MQTT broker and publish messages
    to control our LED.
  prefs: []
  type: TYPE_NORMAL
- en: Building a web-based MQTT client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking with
    RESTful APIs and Web Sockets Using Flask*, we covered a code example using Web
    Sockets, which included an HTML file and JavaScript web client. In this section,
    we will also be looking at a Web Socket-based web client built using HTML and
    JavaScript. However, this time, we will be leveraging the built-in Web Socket
    features provided by the Mosquitto MQTT broker and the compatible JavaScript Paho-JavaScript
    Web Sockets library (you will find a link to this library in the *Further reading*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: For comparison, in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking
    with RESTful APIs and Web Sockets Using Flask*, we created our Web Socket server
    ourselves in Python using Flask-SocketIO, while our web client used the Socket.io
    JavaScript Web socket library.
  prefs: []
  type: TYPE_NORMAL
- en: We interacted with the web client we are about to explore to control our LED
    previously in the  *Installing the Mosquitto MQTT broker *at section *step 7*. You
    might like to quickly review *step 7* to refamiliarize yourself with the web client
    and how to access it in your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the code for the web page client in the `chapter04/mosquitto_www/index.html` file. Please
    review this file before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the JavaScript library we are using in this example is different, you
    will find that the general structure and use of the JavsScript code are similar
    to the code we saw for the `socket.io`-based web client in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)*,
    Networking with RESTful APIs and Web Sockets Using Flask*. As usual, we will start
    by looking at the imports.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our web client imports the Paho-MQTT JavaScript client library at line (1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`paho-mqtt.js` can be also found in the `chapter04/mosquitto_www` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation page for the Paho-MQTT JavaScript library is available
    at [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js),
    while its official GitHub page is found at [https://github.com/eclipse/paho.mqtt.javascript](https://github.com/eclipse/paho.mqtt.javascript)[.](https://www.eclipse.org/paho/clients/js)
  prefs: []
  type: TYPE_NORMAL
- en: When you explore the Paho-MQTT JavaScript API further, start at its GitHub site
    and make note of any breaking changes that are mentioned. The documentation pages
    are known to contain code fragments that do not reflect the latest GitHub code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we encounter the global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At line (2), we initialize a `Client_ID` constant that will identify our JavaScript
    client with the broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Paho JavaScript MQTT client *must* have a unique *hostname, port,* and
    *client ID *combination when it connects to the broker. To ensure we can run multiple
    web pages on a single computer for testing and demonstration, we use a random
    number to create a quasi-unique client ID for each web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At line (3), we define the `TOPIC` constant with `led`, the name of the MQTT
    topic that we will be subscribing and publishing to shortly. Next, we create our
    client instance.
  prefs: []
  type: TYPE_NORMAL
- en: The Paho JavaScript MQTT client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At line (4), we create our Paho-MQTT Client instance and assign it to the `client`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters to `Paho.MQTT.Client()` are the broker''s hostname and port.
    We are serving this web page via Mosquitto, so the broker''s host and port will
    be the same as web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed in the `http://localhost:8083` URL that the port is `8083`,
    while in Python we used port `1883`:'
  prefs: []
  type: TYPE_NORMAL
- en: Port `1883` is the MQTT protocol port on the broker. Our Python program connects
    directly to the broker on this port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We previously configured port `8083` as a Web Socket port on the Mosquitto broker.
    Web pages can speak HTTP and Web Socket protocols, not MQTT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This raises an important point. While we're using the term MQTT in the context
    of our JavaScript code, we're really proxying the MQTT idea using Web Sockets back
    and forth to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: When we speak of the MQTT *client* and created the `client` instance at line
    (4), remember this is our JavaScript code's client connection *to the broker*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see how to connect to the broker and register an `onConnect` handler
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the broker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define our `onConnectionSuccess()` handler at line (5), which will be called
    after our `client` successfully connects to the broker. When we successfully connect,
    we then update the web page to reflect the successful connection and enable the
    slider control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next, at line (6), we subscribe to the `led` topic. It's at line (7) that we
    connect to the broker. Notice that we're registering the `onConnectionSuccess`
    function as the `onSuccess` option.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, similar to the Python example, always subscribe to topics in an
  prefs: []
  type: TYPE_NORMAL
- en: '`onSuccess` handler. This way, if the client ever loses the connection to the
    broker, it can re-establish subscriptions when it reconnects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify the `reconnect: true` option so that our client will automatically
    reconnect to the broker if it loses its connection.'
  prefs: []
  type: TYPE_NORMAL
- en: It has been observed that it may take up to a minute for the JavaScript Paho-MQTT
    client to reconnect after losing a connection, so please be patient. This is in
    contrast to the Python Paho-MQTT client, which reconnects almost instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have another two handlers to review.
  prefs: []
  type: TYPE_NORMAL
- en: The onConnectionLost and onMessageArrived handler methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code, at lines (8) and (9), we see how to register an `onConnectionLost`
    and `onMessageArrived` handler with our Paho-MQTT `client` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: These two functions are similar in principle to their corresponding functions
    in the socket.io example from the previous [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, in that they update
    the slider and web page text based on the data found in their respective `data`
    and `message` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our document ready function.
  prefs: []
  type: TYPE_NORMAL
- en: JQuery document ready function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we encounter the document ready function at line (1o) where we initialize our
    web page content and register the event listener for the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Within the sliders event handler at line (11), we see how to create an MQTT
    message. Notice the use of `JSON.stringify(payload)`. The `Paho.Message` constructor
    expects a `String` parameter, not an `Object`, so we must convert the payload
    variable (which is an `Object`) in to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at line (12), we set the message publication topic to `led` with `message.destinationName
    = TOPIC` before flagging its QoS level as 2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at line (13), with `message.retained = true`, we indicate that we want
    this message to be retained so that it is automatically delivered to new clients
    subscribing to the `led` topic. The retention of this message is what allows `mqtt_led.py`
    to reinitialize the LED's previous brightness between restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Well Done! We have now covered both the Python and JavaScript sides of a simple
    MQTT-based application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored and practiced the core concepts of MQTT. After
    installing and configuring the Mosquitto MQTT broker on your Raspberry Pi, we
    moved straight into learning a range of examples on the command line. We learned
    how to publish and subscribe to MQTT messages, how to understand topic construction
    and name hierarchies, and how we can attach a QoS level to a message.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered durable connections and retained messages, two mechanisms offered
    by MQTT brokers for storing messages for later delivery. We concluded our walk-through
    of MQTT concepts by exploring a special message and topic type known as a *Will*,
    whereby a client can register a message with a broker that gets automatically
    published to a topic in cases where the client abruptly loses its connection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we reviewed and walked through a Python program that used the Paho Python
    MQTT library to subscribe to an MQTT topic and control the brightness of our LED
    in response to the messages it received. We followed this with a walk-through
    of a web page built with the Paho JavaScript MQTT library that published the messages
    consumed by our Python program.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a working knowledge of MQTT and a practical code framework you
    can now leverage for your own IoT applications. This is in addition to the other
    networking approaches and code frameworks that we've explored in earlier chapters,
    such as the dweet.io service, Flask-RESTful, and Flask-SocketIO. Which approach
    you use for your projects all depends on what you are trying to create and, of
    course, your own personal preference. For larger projects and projects where you
    need to integrate with external systems, you may find yourself needing to leverage
    multiple approaches in tandem and even find the need to research and explore additional
    techniques. I do not doubt that your learning and understanding of the alternative
    networking approaches we've covered so far will be of value and help with your
    understanding of other approaches you encounter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Connecting Python to the Physical World*, we will be exploring
    a range of topics related to how you connect your Raspberry Pi to the world. We
    will run through popular Python GPIO library options in addition to GPIOZero and
    PiGPIO and look at the different types of electronic interfacing options and configurations
    that are available with a Raspberry Pi. We also have a comprehensive exercise
    where we will be adding an analog-to-digital converter to your Raspberry Pi and
    using it to create a program to explore PWM techniques and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: What is MQTT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your retained MQTT messages never get delivered. What should you check?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under what condition will an MQTT broker publish a *Will* message?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You choose to use MQTT as your IoT application's messaging layer and must ensure
    that messages are sent and received. What is the minimum QoS level required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You develop an application using MQTT and use the Mosquitto broker, but now
    you need to use a different broker. What does this mean for your code base and
    deployment configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Where in code (hint: which handler method) should you subscribe to MQTT topics
    and why?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the basics of MQTT from an operational level in this chapter. If
    you want to learn more about MQTT from a protocol and data level, HiveMQ (an MQTT
    broker and service provider) has an excellent 11-part series on the MQTT protocol
    available at [https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The home page of the Mosquitto MQTT broker and client tools are available at
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: Mosquitto MQTT broker: [https://mosquitto.org](https://mosquitto.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation and API references for the Paho-MQTT libraries we used in
    this chapter are available at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: Paho-MQTT Python library: [https://www.eclipse.org/paho/clients/python](https://www.eclipse.org/paho/clients/python/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paho-MQTT JavaSctipt library: [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to MQTT, HTTP RESTful APIs, and Web Sockets, there are complimentary
    communication protocols that are specially designed for constrained devices, known
    as CoRA and MQTT-NS. The Eclipse Foundation has a summary of these protocols available
    at [https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php](https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php).
  prefs: []
  type: TYPE_NORMAL
