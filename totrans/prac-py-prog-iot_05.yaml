- en: Networking with MQTT, Python, and the Mosquitto MQTT Broker
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MQTT，Python和Mosquitto MQTT代理进行网络连接
- en: In the previous chapter, we created two Python servers and accompanying web
    pages using both a RESTful API and Web Socket approach to networking. In this
    chapter, we will cover another networking topology that is common in the IoT world,
    known as **MQTT **or **Message Queue Telemetry Transport***.*
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用RESTful API和Web Socket方法创建了两个Python服务器和相应的网页。在本章中，我们将涵盖另一种在物联网世界中常见的网络拓扑，称为**MQTT**或**消息队列遥测传输**。
- en: We will commence by setting up your development environment and installing the
    Mosquitto MQTT broker service on your Raspberry Pi. Then, we will learn about
    MQTT features using command-line tools that come with Mosquitto to help you to
    understand the core concepts in isolation. After that, we'll proceed to a Python
    IoT application that uses MQTT for its messaging layer—and yes, it'll be all about
    controlling the LED!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置您的开发环境，并在树莓派上安装Mosquitto MQTT代理服务。然后，我们将使用Mosquitto附带的命令行工具学习MQTT的特性，以帮助您单独理解核心概念。之后，我们将进行一个使用MQTT作为其消息传输层的Python物联网应用程序，是的，它将完全关于LED的控制！
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Installing the Mosquitto MQTT broker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Mosquitto MQTT代理
- en: Learning MQTT by example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例学习MQTT
- en: Introducing the Python Paho-MQTT client library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Python Paho-MQTT客户端库
- en: Controlling an LED with Python and MQTT
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python和MQTT控制LED
- en: Building a web-based MQTT client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于Web的MQTT客户端
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B型号
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: A minimum of Python version 3.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望代码示例应该可以在树莓派3型B型或不同版本的Raspbian OS上无需修改地运行，只要您的Python版本是3.5或更高。
- en: 'You will find this chapter''s source code in the `chapter04` folder in the
    GitHub repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL的GitHub存储库的`chapter04`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令，以设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从`requirements.txt`中安装以下依赖项：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Paho-MQTT** **Client**: The Paho-MQTT client library ([https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Paho-MQTT** **客户端**：Paho-MQTT客户端库（[https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt)）'
- en: We will be working with the breadboard circuit we created in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, *Figure 2.7*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中创建的面包板电路进行工作，*使用Python和物联网入门*，*图2.7*。
- en: Installing the Mosquitto MQTT broker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Mosquitto MQTT代理
- en: '**MQTT***,* or **Message Queue Telemetry Transport**, is a lightweight and
    simple messaging protocol targeted specifically for IoT applications. While a
    Raspberry Pi is powerful enough to leverage more complex messaging protocols,
    if you are using it as part of a distributed IoT solution, chances are you are
    going to encounter MQTT; hence, learning it is very important. Besides, its simplicity
    and open nature make it easy to learn and use.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**MQTT**，或**消息队列遥测传输**，是一种专门针对物联网应用的轻量级和简单的消息传输协议。虽然树莓派足够强大，可以利用更复杂的消息传输协议，但如果您将其用作分布式物联网解决方案的一部分，很可能会遇到MQTT；因此，学习它非常重要。此外，它的简单性和开放性使其易于学习和使用。'
- en: Our introduction to MQTT is going to be performed using a popular open source
    MQTT broker called *Mosquitto* that we will install on your Raspberry Pi.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为*Mosquitto*的流行开源MQTT代理来进行MQTT的介绍，并将其安装在您的树莓派上。
- en: The examples we cover in this chapter were performed with the Mosquitto broker
    and client version 1.5.7, which are MQTT protocol version 3.1.1-complaint. A different
    version of the broker or client tools will be suitable as long as they are MQTT
    protocol version 3.1.x-compatible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的示例是使用Mosquitto代理和客户端版本1.5.7执行的，这是MQTT协议版本3.1.1兼容的。只要它们是MQTT协议版本3.1.x兼容的，代理或客户端工具的不同版本都将适用。
- en: 'To install the Mosquitto MQTT broker service and client tools, follow these
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Mosquitto MQTT代理服务和客户端工具，请按照以下步骤进行：
- en: 'Open a new Terminal window and execute the following `apt-get` command. This
    must be performed using `sudo`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并执行以下`apt-get`命令。这必须使用`sudo`执行：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To ensure that the Mosquitto MQTT broker service has started, run the following
    command in the Terminal:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确保Mosquitto MQTT代理服务已启动，请在终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check that the Mosquitto service has started with the following `service` command. We
    expect to see the `active (running)` text printed to the Terminal:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`service`命令检查Mosquitto服务是否已启动。我们期望在终端上看到`active (running)`文本打印出来：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can check the Mosquitto and MQTT protocol version with the `mosquitto -h` command.
    Here, we see that the Mosquitto broker is using MQTT version 3.1.1:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`mosquitto -h`命令检查Mosquitto和MQTT协议版本。 在这里，我们看到Mosquitto代理使用的是MQTT版本3.1.1：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we will configure Mosquitto so that it can serve web pages and handle
    Web Socket requests. We will use these features when we come to build a web page
    client later in this chapter.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置Mosquitto，以便它可以提供网页并处理Web套接字请求。 当我们在本章后面构建网页客户端时，我们将使用这些功能。
- en: 'In the `chapter4` folder, there is a file named `mosquitto_pyiot.conf`, which
    is partially replicated here. There is one line in this file that we need to check:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter4`文件夹中，有一个名为`mosquitto_pyiot.conf`的文件，这里部分复制了该文件。 此文件中有一行我们需要检查的内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the exercises in this chapter, you need to update the `http_dir` setting
    on the last line so it's the absolute path to the `chapter04/mosquitto_www` folder
    on your Raspberry Pi. If you used the suggested folder, `/home/pi/pyiot`, when
    cloning the GitHub repository in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)*,
    Setting Up Your Development Environment*, then the path listed previously is correct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的练习，您需要更新最后一行的`http_dir`设置，使其成为树莓派上`chapter04/mosquitto_www`文件夹的绝对路径。 如果您在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)*，设置您的开发环境*中克隆GitHub存储库时使用了建议的文件夹`/home/pi/pyiot`，那么先前列出的路径是正确的。
- en: 'Next, we copy the configuration in `mosquitto_pyiot.conf` using the following `cp`
    command into the appropriate folder so that it can be loaded by Mosquitto:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下`cp`命令将`mosquitto_pyiot.conf`中的配置复制到适当的文件夹中，以便Mosquitto可以加载它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we restart the Mosquitto service to load our configuration:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们重新启动Mosquitto服务以加载我们的配置：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check that the configuration has worked, visit the `http://localhost:8083` URL in
    a web browser on your Raspberry Pi, and you should see a page similar to the following
    screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查配置是否有效，请在树莓派上的Web浏览器中访问`http://localhost:8083` URL，您应该看到类似以下截图的页面：
- en: '![](assets/525e2257-5a0c-4b58-a62a-8b11eb2f467e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/525e2257-5a0c-4b58-a62a-8b11eb2f467e.png)'
- en: Figure 4.1 – Web page served by the Mosquitto MQTT broker
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - Mosquitto MQTT代理提供的网页
- en: This is a giveaway to what we'll be doing later in this chapter! At the moment,
    while you can move the slider, it *will not* change the LED's brightness because
    we do not have the Python-side code running. We'll cover that in due course later
    in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章后面我们将要做的事情的线索！ 目前，虽然您可以移动滑块，但它*不会*改变LED的亮度，因为我们没有运行Python端的代码。 我们将在本章后面逐步介绍。
- en: 'If you experience problems getting the Mosquitto MQTT Broker to start, try
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在启动Mosquitto MQTT代理时遇到问题，请尝试以下操作：
- en: Execute `sudo mosquitto -v -c /etc/mosquitto/mosquitto.conf` in a Terminal.
    This will start Mosquitto in the foreground and any start up or configurations
    errors will be shown on your Terminal.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中执行`sudo mosquitto -v -c /etc/mosquitto/mosquitto.conf`。 这将在前台启动Mosquitto，并且任何启动或配置错误都将显示在您的终端上。
- en: Read the troubleshooting comments in the `mosquitto_pyiot.conf` file for additional
    suggestions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`mosquitto_pyiot.conf`文件中的故障排除注释以获取其他建议。
- en: The default configuration of Mosquitto after installation creates an *unencrypted*
    and *unauthenticated* MQTT broker service. The Mosquitto documentation contains
    details regarding its configuration and how to enable authentication and encryption.
    You will find links in the *Further reading* section at the end of this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Mosquitto安装后的默认配置创建了一个*未加密*和*未经身份验证*的MQTT代理服务。 Mosquitto文档包含有关其配置以及如何启用身份验证和加密的详细信息。
    您将在本章末尾的*进一步阅读*部分找到链接。
- en: Now that we have Mosquitto installed and running, we can explore MQTT concepts
    and perform examples to see them in practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并运行了Mosquitto，我们可以探索MQTT概念并执行示例以看到它们在实践中的应用。
- en: Learning MQTT by example
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例学习MQTT
- en: MQTT is a broker-based *publishing* and *subscription* messaging protocol (frequently
    paraphrased as *pub/sub*), while an MQTT *broker* (just like the Mosquitto MQTT
    broker we installed in the previous section) is a server that implements the MQTT
    protocol. By using an MQTT-based architecture, your applications can essentially
    hand off all complex messaging handling and routing logic to the broker so they
    can remain solution-focused.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是基于代理的*发布*和*订阅*消息协议（经常被简化为*pub/sub*），而MQTT *代理*（就像我们在上一节中安装的Mosquitto MQTT代理）是实现MQTT协议的服务器。
    通过使用基于MQTT的架构，您的应用程序可以基本上将所有复杂的消息处理和路由逻辑交给代理，以便它们可以保持专注于解决方案。
- en: MQTT clients (for example, your Python programs and the command-line tools we
    are about to use) create a subscription with the broker and *subscribe* to message
    topics they are interested in. Clients *publish *messages to a topic, and it is
    the broker that is then responsible for all message routing and delivery assurances.
    Any client may assume the role of a subscriber, a publisher, or both.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT客户端（例如，您的Python程序和我们即将使用的命令行工具）与代理创建订阅并*订阅*它们感兴趣的消息主题。 客户端*发布*消息到主题，然后代理负责所有消息路由和传递保证。
    任何客户端都可以扮演订阅者、发布者或两者的角色。
- en: 'A simple conceptual MQTT-based system involving a pump, water tank, and controller
    application is illustrated in *Figure 4.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.2*展示了涉及泵、水箱和控制器应用程序的简单概念MQTT系统：'
- en: '![](assets/09bd86dd-a43b-4ff7-917c-c0be54738043.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09bd86dd-a43b-4ff7-917c-c0be54738043.png)'
- en: Figure 4.2 – MQTT example
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - MQTT示例
- en: 'Here is a high-level description of system components:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是系统组件的高级描述：
- en: Think of the *Water Level Sensor MQTT client* as the software connected to a
    water level sensor in a water tank. This client assumes the role of a *publisher*
    in our MQTT example. It periodically sends (that is, *publishes)* messages about
    how full the water tank is to the MQTT broker.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*水位传感器MQTT客户端*视为连接到水箱中的水位传感器的软件。 在我们的MQTT示例中，此客户端扮演*发布者*的角色。 它定期发送（即*发布*）关于水箱装满了多少水的消息到MQTT代理。
- en: 'Think of the *Pump MQTT client* as a software driver that is capable of switching
    a water pump on or off. This client assumes both the role of a *publisher* and
    *subscriber* in our example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将* Pump MQTT客户端*视为能够打开或关闭水泵的软件驱动程序。在我们的示例中，此客户端扮演*发布者*和*订阅者*的角色：
- en: As a *subscriber*, it can receive a message (via a *subscription)* instructing
    it to switch the pump on or off.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*订阅者*，它可以接收一条消息（通过*订阅*）指示它打开或关闭水泵。
- en: As a *publisher*, it can send a message indicating whether the pump is on and
    pumping water or off.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*发布者*，它可以发送一条消息，指示水泵是打开并抽水还是关闭。
- en: Think of the *Controller MQTT client* as the application where all of the control
    logic resides. This client also assumes both the roles of a *publisher* and *subscriber:*
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*Controller MQTT客户端*视为所有控制逻辑所在的应用程序。此客户端还扮演*发布者*和*订阅者*的角色：
- en: As a *publisher*, this client can send a message that will tell the pump to
    switch on or off.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*发布者*，此客户端可以发送一条消息，告诉水泵打开或关闭。
- en: As a *subscriber*, this client can receive messages from both the water tank
    level sensor and the pump.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*订阅者*，此客户端可以从水箱水位传感器和水泵接收消息。
- en: By way of example, the *Controller MQTT client *application could be configured
    to switch on the pump when the water level in the tank falls below 50% and switch
    off the pump when the level reaches 100%. This controller application may also
    include a dashboard user interface that displays the current water level in the
    tank and a status light indicating whether the pump is on or off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，*Controller MQTT客户端*应用程序可以配置为在水箱水位低于50％时打开水泵，并在水位达到100％时关闭水泵。此控制器应用程序还可以包括一个仪表板用户界面，显示水箱的当前水位以及指示水泵是否打开或关闭的状态灯。
- en: An important point to note regarding our MQTT system is that each client is
    unaware of the other clients—a client only ever connects to and interacts with
    the MQTT broker, which then routes messages as appropriate to clients. This routing
    is achieved using message *topics,* which we will cover later in the section entitled
    *Exploring MQTT topics and wildcards*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的MQTT系统需要注意的一点是，每个客户端都不知道其他客户端，客户端只连接到MQTT代理并与之交互，然后代理将消息适当地路由到客户端。这通过使用消息*主题*来实现，我们将在标题为*探索MQTT主题和通配符*的部分中进行介绍。
- en: It's understandable why the pump would need to receive a message to tell it
    to turn on or off, but what about the pump's need to also send a message stating
    whether it is on or off? If you wondered about this, here is the reason. MQTT
    messages are send-and-forget, meaning that a client does not get an application-level
    response to a message that it publishes. So, in our example, while the controller
    client can publish a message asking the pump to turn on, without the pump publishing
    its status, the controller has no way of knowing whether the pump actually turned
    on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解为什么水泵需要接收消息来告诉它打开或关闭，但是水泵还需要发送消息来说明它是打开还是关闭吗？如果您对此感到困惑，这就是原因。MQTT消息是发送并忘记的，这意味着客户端不会收到它发布的消息的应用级响应。因此，在我们的示例中，虽然控制器客户端可以发布一条消息要求水泵打开，但如果水泵不发布其状态，控制器就无法知道水泵是否真的打开了。
- en: In practice, the pump would publish its on/off status every time it turns on
    or off. This would allow the controller's dashboard to update the pump's status
    indicator in a timely manner. Furthermore, the pump would also periodically publish
    its status (just like the water level sensor) independent of any requests it receives
    to turn on or off. This way, the controller application can monitor the connection
    and availability of the pump and detect whether the pump goes offline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，每次水泵打开或关闭时，水泵都会发布其开/关状态。这将允许控制器的仪表板及时更新水泵的状态指示器。此外，水泵还会定期发布其状态（就像水位传感器一样），而不依赖于其接收到的任何请求来打开或关闭。这样，控制器应用程序可以监视水泵的连接和可用性，并检测水泵是否脱机。
- en: For now, if you can grasp the basic ideas presented in the preceding example,
    then you are well on your way to understanding at a deeper level the core MQTT
    concepts that will be our focus for the remainder of this chapter. By the time
    we finish, you will have a fundamental end-to-end understanding of how to work
    with and design MQTT-based applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果您能理解前面示例中提出的基本思想，那么您就已经在更深入地理解本章其余部分将关注的核心MQTT概念的道路上了。到我们完成时，您将对如何使用和设计基于MQTT的应用程序有一个基本的端到端理解。
- en: We will start by learning how to publish and subscribe to messages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何发布和订阅消息开始。
- en: Publishing and subscribing MQTT messages
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和订阅MQTT消息
- en: 'Let''s work through the steps to send (that is, publish) and receive (that
    is, subscribe to) messages using MQTT:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来发送（即发布）和接收（即订阅）使用MQTT的消息：
- en: 'In a Terminal, run the following command. `mosquitto_sub` (Mosquitto subscribe)
    is a command-line tool to *subscribe* to messages:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令。`mosquitto_sub`（Mosquitto订阅）是一个命令行工具，用于*订阅*消息：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The options are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 选项如下：
- en: '`-v` (--verbose): verbose is so we get both the message *topic* and *message* payload
    printed on the Terminal.'
  id: totrans-78
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`（-详细信息）：详细信息是为了在终端上打印消息*主题*和*消息*负载。'
- en: '`-h` (--host): localhost is the host of the broker we want to connect to; here
    it''s the one we just installed. The default port used is 1883.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`（-主机）：localhost是我们要连接的代理的主机；这里是我们刚刚安装的代理。使用的默认端口是1883。'
- en: '`-t` (--topic): `pyiot` is the topic we want to subscribe to and listen to.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`（-主题）：`pyiot`是我们要订阅和监听的主题。'
- en: 'In this chapter, we will require two and sometimes three Terminal sessions
    for the examples. The first line of a code block will indicate which Terminal
    you need to run a command in; for example, **Terminal #1** in the preceding code
    block, and **Terminal #2** in the following code block.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要两个或三个终端会话来进行示例。代码块的第一行将指示您需要在哪个终端中运行命令；例如，在前面的代码块中是**终端＃1**，在下面的代码块中是**终端＃2**。
- en: 'Open a second Terminal and run the following command.`mosquitto_pub` (Mosquitto
    publish) is a command-line tool to *publish* messages:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look at the options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`-h` and `-t` have the same meaning as in the preceding subscription command.'
  id: totrans-85
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m ''hello!''` (--message) is the message we want to publish. Messages in
    MQTT are simple strings— if you''re wondering about JSON, it just needs to be
    serialized/deserialized to strings.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On **Terminal #1**, we see the topic and message, `hello!`, printed:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final line is in the format <*topic>* <*message payload>.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The `hello!` message is preceded by the topic name, `pyiot`, because we have
    used the `-v` option to `mosquitto_sub`. Without the `-v` option, if we were subscribing
    to multiple topics, we could not identify which topic a message belonged to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Now, we've learned how to publish and subscribe to messages with a simple topic.
    But is there any way we can organize these messages in a better way? Read on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MQTT topics and wildcards
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MQTT *topics* are used to categorize, or group, messages together in a hierarchical
    format. We have already been working with topics in our proceeding command-line
    examples, but in a non-hierarchical fashion. W*ildcards*, on the other hand, are
    special characters used by a *subscriber *to create flexible topic matching patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few hierarchical topic examples from a hypothetical building with sensors.
    The hierarchy is delimited by the `/` character:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`level1/lounge/temperature/sensor1`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/temperature/sensor2`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/lighting/sensor1`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/temperature/sensor1`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/lighting/sensor1`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no need to pre-create a topic on an MQTT broker. Using the *default* broker
    configuration (which we are), you just publish and subscribe to topics at will.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: When the Mosquitto broker is configured to use authentication, there is the
    possibility to restrict access to topics based on a client ID and/or username
    and password.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages *must* be published to a *specific* topic such as `pyiot`, while subscriptions
    can be made to a specific topic, or a range of topics, by using the wildcard characters, `+` and `#`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`+` is used to match a single element of the hierarchy.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#` is used to match *all* remaining elements in a hierarchy (it can only be
    at the end of a topic query).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscriptions to topics and wildcards are best explained by example. Using
    the aforementioned hypothetical building with sensors, consider the examples in
    the following table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '| We want to subscribe to... | Wildcard topic | Topic matches |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| All **temperature** sensors everywhere | `+/+/**temperature**/+` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/**temperature**/sensor1`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/**temperature**/sensor2`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/**temperature**/sensor1`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| All **light** sensors everywhere | `+/+/**lighting**/+` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/**lighting**/sensor1`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/**lighting**/sensor1`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '| Every sensor on **level 2** | `**level2**/+/+/+` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '`**level2**/bedroom1/temperature/sensor1`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**level2**/bedroom1/lighting/sensor1`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| Every sensor on **level 2**(a simpler way where `#` matches every remaining
    child) | `**level2**/#` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '`**level2**/bedroom1/temperature/sensor1`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**level2**/bedroom1/lighting/sensor1`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| Only **sensor1** everywhere | `+/+/+/**sensor1**` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '`level1/lounge/temperature/**sensor1**`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level1/lounge/lighting/**sensor1**`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/temperature/**sensor1**`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level2/bedroom1/lighting/**sensor1**`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '| Only **sensor1** everywhere(a simpler way where `#` matches every remaining
    child) | `#/**sensor1**` | Invalid because # can only be at the end of the topic
    query |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| Every topic | `#` | Matches everything |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| Broker information | `$SYS/#` | This is a special reserved topic where the
    broker publishes information and runtime statistics. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: Table 1 - MQTT wildcard topic examples
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: What may be evident from the preceding examples is that you need to take care
    when designing topic hierarchies for an application so that subscribing to multiple
    topics using wildcards is consistent, logical, and easy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以明显看出，您需要在设计应用程序的主题层次结构时小心，以便使用通配符订阅多个主题是一致的、逻辑的和简单的。
- en: If you are subscribing using the `+` or `#` wildcards with `mosquitto_sub`,
    remember to use the `-v` (--verbose) option so that the topic name is printed
    in the output, for example, `mosquitto_sub -h localhost -v -t '#'`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`mosquitto_sub`订阅使用`+`或`#`通配符，请记住使用`-v`（--verbose）选项，以便主题名称打印在输出中，例如`mosquitto_sub
    -h localhost -v -t '#'`。
- en: 'Try a few examples for yourself on the command line by mixing and matching
    the preceding topics and wildcards to get a feel for how topics and wildcards
    work. Following are the steps for one example where `mosquitto_sub` subscribes
    to all childtopics that have the parent *temperature* two levels down from the
    root topic:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上尝试一些示例，通过混合和匹配前面的主题和通配符来感受主题和通配符的工作原理。以下是一个示例的步骤，其中`mosquitto_sub`订阅了所有从根主题下两级的父主题为*temperature*的子主题：
- en: 'In a Terminal, start a subscriber that subscribes to a wildcard topic:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中，启动一个订阅通配符主题的订阅者：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the topics from *Table 1 – MQTT wildcard topic examples,* here are two
    `mosquitto_pub` commands that will publish messages that will be received by the `mosquitto_sub`
    command in **Terminal #1**:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*表1 - MQTT通配符主题示例*中的主题，以下是两个`mosquitto_pub`命令，将发布的消息将被**终端#1**中的`mosquitto_sub`命令接收：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have just seen how to subscribe to topic hierarchies using the wildcard characters, `+`
    and `*`. Using topics and wildcards together is a design decision you'll need
    to make on a per-project level based on how your data needs to flow and how you
    envision it will be both published and subscribed by client applications. Time
    invested in designing a congruent yet flexible wildcard-based topic hierarchy
    will go a long way to helping you to build simpler and reusable client code and
    applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何使用通配符字符`+`和`*`订阅主题层次结构。使用主题和通配符一起是一个设计决策，您需要根据数据流动的需求以及您设想客户端应用程序发布和订阅的方式在每个项目级别上做出的。在设计一致而灵活的基于通配符的主题层次结构方面投入的时间将有助于帮助您构建更简单和可重用的客户端代码和应用程序。
- en: Next, we will learn all about message Quality of Service and how this impacts
    the messages you send through an MQTT Broker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习有关消息服务质量的所有内容，以及这如何影响您通过MQTT Broker发送的消息。
- en: Applying Quality of Service to messages
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将服务质量应用于消息
- en: MQTT provides three **Quality of Service** (**QoS**) levels for *individual message delivery—*I
    am emphasizing *individual message delivery* because QoS levels apply to the delivery
    of individual messages and not to a topic. This will become clearer as you work
    through the examples.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT为*单个消息传递*提供了三个**服务质量**（**QoS**）级别 - 我强调*单个消息传递*，因为QoS级别适用于单个消息的传递，而不适用于主题。随着您逐步学习示例，这一点将变得更加清晰。
- en: 'While you, as the developer, stipulate the QoS for your messages, it''s the
    broker that is responsible for ensuring that the message delivery adheres to the
    QoS. Here is the QoS you can apply to a message and what they mean for delivery:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您规定消息的QoS，而代理负责确保消息传递符合QoS。以下是您可以应用于消息的QoS以及它们对传递的含义：
- en: '| **QoS level** | **Meaning** | **Number of messages delivered** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **QoS级别** | **含义** | **传递的消息数量** |'
- en: '| Level 0 | The message will be delivered at most once, but maybe not at all.
    | 0 or 1 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 级别0 | 该消息将被传递最多一次，但也可能根本不传递。 | 0或1 |'
- en: '| Level 1 | The message will be delivered at least once, but perhaps more.
    | 1 or more |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 级别1 | 该消息将至少传递一次，但可能更多。 | 1或更多 |'
- en: '| Level 2 | The message will be delivered exactly once. | 1 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 级别2 | 该消息将被传递一次。 | 1 |'
- en: Table 2 – Message QoS levels
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表2 - 消息QoS级别
- en: 'You might be asking the question: Level 0 and 1 seem a bit random, so why not
    just always use Level 2? The answer is *resources*. Let''s see why...'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问：级别0和1似乎有点随机，那么为什么不总是使用级别2呢？答案是*资源*。让我们看看为什么...
- en: The broker and clients will consume more resources to process higher-level QoS
    messages than lower-level QoS messages—for example, the broker will need more
    time and memory to store and process messages, while both the broker and clients
    consume more time and network bandwidth with acknowledgment confirmations and
    connection handshaking.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与较低级别的QoS消息相比，代理和客户端将消耗更多的资源来处理较高级别的QoS消息 - 例如，代理将需要更多的时间和内存来存储和处理消息，而代理和客户端在确认确认和连接握手时消耗更多的时间和网络带宽。
- en: For many use cases, including the examples that follow in this chapter, we will
    not notice a difference between QoS levels 1 and 2, nor will we be able to practically
    demonstrate them (Level 0 gets omitted for a good reason, which we'll see later
    on when we cover message retention and durable connections). However, set your
    mind to a distributed IoT system with thousands of sensors publishing thousands
    or more messages every minute, and now designing around QoS starts to make a little
    more sense.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多用例，包括本章后续的示例，我们将注意不到QoS级别1和2之间的区别，我们也无法实际演示它们（级别0由于一个很好的原因被省略，我们稍后将在消息保留和持久连接时看到）。然而，设想一个分布式物联网系统，其中成千上万的传感器每分钟发布成千上万条消息，现在围绕QoS设计开始变得更有意义。
- en: QoS levels apply to both message *subscriptions* and message *publishing,* which
    may seem odd when you first think it through. For example, a client may publish
    a message with a QoS of 1 to a topic, while another client may subscribe to that
    topic with a QoS of 2 (I know I said QoS relates to messages, not topics, but
    here it's the messages flowing *through* the topic that the QoS relates to). What
    QoS is this message, 1 or 2? For the subscriber, it's 1—let's find out why.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: It's the *subscribing* client that chooses the *highest* QoS of messages it
    wants to receive—but it may get lower. So, effectively, this means the delivery
    QoS received by a client is downgraded to the lowest QoS of the publication or
    subscription.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples for you to ponder:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '| Publisher sends message | Subscriber subscribing at | What subscriber gets
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 0 | Delivery of message adhering to a QoS 0 (subscriber gets
    the message 0 or 1 time) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 2 | Delivery of message adhering to a QoS 2 (subscriber gets
    the message exactly once) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| QoS 0 | QoS 1 | Delivery of message adhering to QoS 0 (subscriber gets the
    message 0 or 1 time) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| QoS 1 | QoS 2 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| QoS 2 | QoS 1 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: Table 3 – Publisher and subscriber QoS examples
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from these examples is that, in practice, when designing or integrating
    IoT solutions, you need to be aware of the QoS used by both publishers and subscribers
    on either side of a topic—QoS cannot be interpreted on either side in isolation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to play out QoS scenarios and see client-broker interactions
    in real time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Terminal, run the following command to start a subscriber:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a second Terminal, run the following command to publish a message:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are again subscribing on **Terminal #1**, and publishing on **Terminal
    #2**. Here are the new options used with both `mosquitto_sub` and `mosquitto_pub`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: Turn on debugging messages'
  id: totrans-173
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q <level>`: QoS level'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With debugging enabled (`-d`), try changing the `-q` parameter (to 0, 1, or
    2) on either side and publishing new messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the logged messages in **Terminal #1** and **Terminal #2**.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Among the debugging messages that will appear in **Terminal #1** and **Terminal
    #2**, you will obverse the QoS downgrade occurring at the subscription side (look
    for `q0`, `q1`, or `q2`) while, on both sides, you will also notice different
    debug messages depending on the QoS specified as the client and broker perform
    handshaking and exchange acknowledgments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following is the debug output for the subscriber on **Terminal #1**. Notice
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'At line (1), we subscribed using QoS 2 (`-q 2`). This is reflected in the debug
    output, `QoS: 2`, on line (2).'
  id: totrans-180
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On line (3), we see the QoS downgrade. The message received is QoS 1 (`q1`),
    which is the QoS that the message was published in **Terminal #1**.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QoS is one of the more complex MQTT concepts to grasp. You will find links in
    the *Further reading* section if you want to go deeper into QoS levels and the
    lower level communications that take place between publishers, subscribers, and
    the broker.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered message QoS levels, we will next learn about two MQTT
    features that ensure offline clients can receive past messages when they come
    back online. We will also see how QoS levels impact these features.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Retaining messages for later delivery
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An MQTT broker can be instructed to retain messages published to a topic. Message
    retention comes in two flavors, known as *retained messages* and *durable connections*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: A **retained message** is where the broker retains the *last message* published
    on a topic. This is also commonly referred to as the *last known good message*,
    and any client subscribing to a topic automatically gets this message.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durable connections** are also about retaining messages but in a different
    context. If a client tells the broker it wants a *durable connection*, then the
    broker retains QoS 1 and 2 messages for that client while it''s offline.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久连接**也涉及保留消息，但在不同的上下文中。如果客户端告诉代理它想要一个*持久连接*，那么代理将在客户端离线时保留QoS 1和2的消息。'
- en: Unless configured specifically, Mosquitto *does not* retain messages or connections
    across server restarts. To persist this information across a restart, a Mosquitto
    configuration file must contain the entry `persistence true`. A default installation
    of Mosquitto on a Raspberry Pi should include this entry, however, to be sure
    it has also been included in `mosquitto_pyiot.conf` that we installed earlier.
    Please consult the official Mosquitto documentation for more information and configuration
    parameters regarding persistence. You will find a link in the *Further reading*
    section at the end of the chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除非特别配置，Mosquitto *不会*在服务器重新启动时保留消息或连接。要在重新启动时保留此信息，Mosquitto配置文件必须包含条目`persistence
    true`。树莓派上Mosquitto的默认安装应该包括此条目，但是，为了确保它也包含在我们之前安装的`mosquitto_pyiot.conf`中。请参阅官方Mosquitto文档以获取有关持久性的更多信息和配置参数。您将在本章末尾的*进一步阅读*部分找到链接。
- en: Next, we will learn about retained messages and cover durable connections in
    the subsequent section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习保留消息并在随后的部分中涵盖持久连接。
- en: Publishing a retained message
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布保留消息
- en: A publisher can ask the broker to retain a message as the *last known good*
    message for a topic. Any newly connecting subscriber will immediately receive
    this last retained message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者可以要求代理保留一个消息作为主题的*最后已知的良好*消息。任何新连接的订阅者将立即收到这个最后保留的消息。
- en: 'Let''s step through an example to demonstrate retained messages:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示保留消息：
- en: 'Run the following, noting that we''re starting with **Terminal #2**, the publisher
    in this example:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，注意我们从**终端#2**开始，这个示例中是发布者：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A new option has been added,`-r` (--retain), to tell the broker that this message
    should be retained for the topic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加了一个新选项，`-r`（--retain），告诉代理应该为该主题保留此消息。
- en: Only a single retained message can exist for a topic. If you publish another
    message using the `-r` option, the previous retained message will be replaced.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主题只能存在一个保留的消息。如果使用`-r`选项发布另一条消息，则先前保留的消息将被替换。
- en: 'Start a subscriber in another Terminal, and immediately you will receive the
    retained message:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中启动一个订阅者，然后立即您将收到保留的消息：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Press *Ctrl* + *C* in **Terminal #1** to terminate `mosquitto_sub`.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#1**中按下*Ctrl* + *C*来终止`mosquitto_sub`。
- en: 'Start `mosquitto_sub` again using the same command from *step 2*, and you will
    see the retained message received again in **Terminal #1**.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用与*步骤2*相同的命令启动`mosquitto_sub`，然后您将在**终端#1**中再次收到保留的消息。
- en: You can still publish normal messages (that is, *not* using the `-r` option),
    however, it's the last retained message indicated by the use of the `-r` option
    that newly connecting subscribers will receive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以发布普通消息（即*不*使用`-r`选项），但是，新连接的订阅者将接收到使用`-r`选项指示的最后保留的消息。
- en: 'Our final command shows how to clear a previously retained message:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一个命令显示了如何清除先前保留的消息：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are publishing (with `-r`) an empty message with `-m ''`. Note that
    we can use `-n` as an alternative to `-m ''` to indicate an empty message. The
    effect of retaining an empty message is to actually clear the retained message.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在发布（使用`-r`）一个带有`-m ''`的空消息。请注意，我们可以使用`-n`作为`-m ''`的替代方法来指示空消息。保留空消息的效果实际上是清除保留的消息。
- en: When you send an empty message to a topic to remove a retained message, any
    clients currently subscribed to the topic (including offline clients with durable
    connections—see the next section) will receive the empty message, so your application
    code must test for and handle empty messages appropriately.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向主题发送空消息以删除保留的消息时，当前订阅该主题的任何客户端（包括具有持久连接的离线客户端-请参阅下一节）都将收到空消息，因此您的应用代码必须适当地测试和处理空消息。
- en: Now that you understand and know how to use retained messages, we can now explore
    the other type of message retention available with MQTT, called *durable connections*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解并知道如何使用保留消息，我们现在可以探索MQTT中可用的另一种消息保留类型，称为*持久连接*。
- en: Creating durable connections
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建持久连接
- en: 'A client subscribing to a topic can ask the broker to retain, or queue, messages
    for it while it''s offline. This is known in MQTT terminology as a *durable connection*.
    For durable connections and delivery to work, the subscribing client needs to
    be configured and subscribe in a certain way, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅主题的客户端可以要求代理在其离线时保留或排队消息。在MQTT术语中，这被称为*持久连接*。为了使持久连接和传递工作，订阅客户端需要以特定的方式进行配置和订阅，如下所示：
- en: The client *must* *provide* a unique client ID to the broker when it connects.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端连接时，*必须*向代理提供唯一的客户端ID。
- en: The client *must subscribe* with a QoS 1 or 2 (levels 1 and 2 guarantee delivery,
    but level 0 does not).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端*必须*使用QoS 1或2（级别1和2保证传递，但级别0不保证）进行订阅。
- en: The client is only guaranteed to get messages *published* with QoS 1 or 2.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端只有在使用QoS 1或2进行发布的消息时才能得到保证。
- en: The last two points concern an example where knowing QoS on both the publishing
    and subscribing sides of a topic is very important for IoT application design.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点涉及了一个示例，其中了解主题的发布和订阅双方的QoS对于物联网应用程序设计非常重要。
- en: MQTT brokers can—and the default configuration of Mosquitto on the Raspberry
    Pi does—retain messages for durable connections between broker restarts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT代理可以在代理重新启动时保留消息，树莓派上Mosquitto的默认配置也可以这样做。
- en: 'Let''s step through an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示：
- en: 'Start a subscriber, and then immediately terminate it with *Ctrl* + *C* so
    that it is offline:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动订阅者，然后立即使用*Ctrl* + *C*终止它，使其处于离线状态：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The new options used are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的新选项如下：
- en: '`-i <client id>` (–id <client id>) is a unique client ID (this is how the broker
    identifies the client).'
  id: totrans-218
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i <client id>`（-id <client id>）是一个唯一的客户端ID（这是代理识别客户端的方式）。'
- en: '`-c` (--disable-clean-session) instructs the broker to keep any QoS 1 and 2
    messages that arrive at subscribed topics even while the client is disconnected
    (that is, *retain* the messages).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`（--disable-clean-session）指示代理保留订阅主题上到达的任何QoS 1和2消息，即使客户端断开连接（即*保留*消息）。'
- en: It's worded a bit backward, but by starting the subscriber with the `-c` option,
    we've asked the broker to create a *durable connection* for our client by not
    clearing out any stored messages on connecting.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 措辞有点反向，但通过使用`-c`选项启动订阅者，我们已要求代理通过在连接时不清除任何存储的消息来为我们的客户端创建一个*持久连接*。
- en: If you subscribe to a range of topics using wildcards (for example, `pyiot/#`)
    and request a durable connection, then all messages for all topics in the wildcard
    hierarchy will be retained for your client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用通配符订阅一系列主题（例如，`pyiot/#`），并请求持久连接，那么通配符层次结构中所有主题的所有消息都将保留给您的客户端。
- en: 'Publish a few messages (while the subscriber in **Terminal #1** is still offline):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布一些消息（当**终端#1**中的订阅者仍然离线时）：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Bring the subscriber in **Terminal #1** back online, and we will see that the
    messages published in *step 2* are delivered:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**终端#1**中的订阅者重新连接，我们将看到在*步骤2*中发布的消息被传送：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try *steps 1* to *3* again, only this time omit the `-c` option from the subscriber
    in *steps 1* and *3* and you will notice that no messages are retained. Also,
    when you connect *without* the `-c` flag when there are retained messages waiting
    to be delivered, then all retained messages are purged (and is how you would clear
    retained messages for a client if you wanted to).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试*步骤1*至*3*，只是这次在*步骤1*和*3*中的订阅者中省略`-c`选项，您会注意到没有消息被保留。此外，当您在有保留消息等待传送时*不使用*`-c`标志连接时，那么所有保留消息都将被清除（这是您想要清除客户端的保留消息的方法）。
- en: If you are using both *retained messages* (that is, last known good message)
    and *durable connections* together on a single topic and reconnect an offline
    subscriber, you will *receive the retained message twice—*one is the *retained
    message,* while the second is from the *durable connection*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在单个主题上同时使用*保留消息*（即最后已知的良好消息）和*持久连接*，并重新连接离线订阅者，您将*收到保留消息两次*—一次是*保留消息*，而第二次是来自*持久连接*的消息。
- en: When building solutions around MQTT, your knowledge of retained messages and
    durable connections will be key to designing systems that are resilient and reliable,
    particularly where you need to handle offline clients. Retained (last known good)
    messages are ideal for initializing a client when they come back online, while durable
    connections will help you to retain and deliver messages in bulk for any offline
    client that must be able to consume every message for topics that it subscribes
    to.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在围绕MQTT构建解决方案时，您对保留消息和持久连接的了解将对设计具有弹性和可靠性的系统至关重要，特别是在需要处理离线客户端的情况下。保留（最后已知的良好）消息非常适合在客户端重新上线时初始化客户端，而持久连接将帮助您为任何必须能够消费其订阅的每条消息的离线客户端保留和传送消息。
- en: Well done! We have covered a lot and you actually now know most of the core
    MQTT features you will use when building an MQTT-based IoT solution. Our last
    feature to learn about is known as a *Will*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们已经涵盖了很多内容，实际上您现在已经了解了构建基于MQTT的物联网解决方案时将使用的大多数核心MQTT功能。我们要了解的最后一个功能是称为*Will*。
- en: Saying goodbye with a Will
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Will说再见
- en: Our final MQTT feature for exploration is known as a Will. A client (publisher
    or subscriber) can register a special *Will* message with the broker so that if
    the client dies and disconnects from the broker abruptly (for example, it loses
    its network connection or its batteries go flat), the broker on the clients' behalf
    will send out the *Will* message notifying subscribers of the device's demise.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索的最后一个MQTT功能是称为Will。客户端（发布者或订阅者）可以向代理注册一个特殊的*Will*消息，以便如果客户端死机并突然断开与代理的连接（例如，它失去了网络连接或其电池耗尽），代理将代表客户端发送*Will*消息，通知订阅者设备的消亡。
- en: Wills are just a message and topic combination similar to what we have been
    using previously.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Will只是一个消息和主题组合，类似于我们之前使用的。
- en: 'Let''s see Wills in action, and for this, we''re going to need three Terminals:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Will的作用，为此，我们将需要三个终端：
- en: 'Open a Terminal and start a subscriber with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，并使用以下命令启动一个订阅者：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The new options are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 新的选项如下：
- en: '`--will-payload`: This is the Will message.'
  id: totrans-237
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-payload`：这是Will消息。'
- en: '`--will-topic`: This is the topic the Will message will be published on. Here
    we are using the same topic that we are subscribing to, but it could be a different
    topic.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-topic`：这是Will消息将要发布的主题。在这里，我们使用与我们订阅的相同主题，但也可以是不同的主题。'
- en: '`--will-qos`: This is the QoS for the Will message.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-qos`：这是Will消息的QoS。'
- en: '`--will-retain`: If this option is present, then if the client disconnects
    abruptly, the Will message will be retained by the broker as the *retained (last
    known good) message* for the Will topic.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-retain`：如果存在此选项，那么如果客户端突然断开连接，Will消息将被代理保留为Will主题的*保留（最后已知的良好）消息*。'
- en: 'Start a subscriber in a second Terminal with the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在第二个终端中启动一个订阅者：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And in a third Terminal, publish a message using the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三个终端中，使用以下命令发布一条消息：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you execute the `mosquitto_pub` command in *step 3* on **Terminal #3**,
    you should see `hello` printed on *both* the subscribers in **Terminals #1** and
    **#2**.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在**终端#3**上执行*步骤3*中的`mosquitto_pub`命令，您应该会在**终端#1**和**#2**上都看到`hello`被打印出来。
- en: 'In **Terminal #1**, press *Ctrl* + *C* to terminate the subscriber that registered
    the Will with the broker. *Ctrl* + *C* is seen as a non-graceful or abrupt disconnection
    from the broker.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#1**中，按下*Ctrl* + *C*来终止向代理注册Will的订阅者。*Ctrl* + *C*被视为与代理的非优雅或突然断开连接。
- en: 'In **Terminal #2**, we will see the Will''s `Good Bye` message:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay, what about a graceful disconnection where the subscriber properly closes
    its connection with the broker? We can demonstrate this using the `-C` option
    with `mosquitto_sub`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the subscriber in **Terminal #1** with the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new `-C <count>` option tells `mosquitto_sub` to disconnect (gracefully)
    and exit after it has received the specified number of messages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice the `Good Bye` message printed immediately. This is because
    we specified the `--retain-will` option previously in **Terminal #1**. This option
    made the Will message become the retained or last known good message for the topic,
    so newly connecting clients will receive this message.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Terminal #3**, publish a new message, and the subscriber in **Terminal
    #1** will exit. Notice in **Terminal #3** that the Will message, `Good Bye, Again`,
    is *not* received. This is because our **Terminal #1** subscriber disconnected
    *gracefully* from the broker because of the `-C` option—and in case you are wondering
    about `2` in  `-C 2`, the retained Will message counted as the first message.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done! If you have worked your way through each of the preceding MQTT examples,
    then you have covered the core concepts and use of MQTT and the Mosquitto broker.
    Do remember that all of these principles will apply to any MQTT broker or client
    since MQTT is an open standard.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've learned about message subscriptions and publication, how we segregate messages
    using topics, and how features including QoS, message retention, durable connections,
    and Wills can be leveraged to control how messages are managed and delivered.
    This knowledge alone provides you with the foundations to build complex and resilient
    distributed IoT systems using MQTT.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: I'll leave you with one final tip (which caught me out a few times when I started
    with MQTT).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: If your live, retained, or queued durable connection messages seem to be vanishing
    into a black hole, then check the QoS levels on both your subscribing and publishing
    clients. To monitor all messages, start a command-line subscriber with QoS 2,
    listening to the `#` topic, with both verbose and debug options enabled, for example, `mosquitto_sub
    -q 2 -v -d -h localhost -t '#'`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed all of our examples from the MQTT-by-example section and
    learned how to interact with an MQTT broker from the command line. Next, I want
    to briefly make mention of public broker services. Following this, we'll get into
    code and see how we can leverage MQTT with Python.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Using MQTT broker services
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several MQTT broker service providers on the internet that you can
    use to create MQTT-based messaging applications if you do not want to host your
    own MQTT broker. Many also offer free public MQTT brokers that you can use for
    testing and quick proofs-of-concept—but remember they are free and public, so
    do not publish any sensitive information!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: If you experience frustration, disconnections, or unexpected behavior with a
    free public broker service, then test and verify your application with a local
    broker. You cannot reliably know or verify the traffic congestion, topic usage,
    or configuration details of an open public broker and how that may be impacting
    your application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few free public brokers you can try. Just replace the `-h`*localhost* option
    in the preceding examples with the address of the broker. Visit the following
    pages for more information and instructions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[https://test.mosquitto.org](https://test.mosquitto.org/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://broker.mqtt-dashboard.com](http://broker.mqtt-dashboard.com/)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ot.eclipse.org/getting-started](https://iot.eclipse.org/getting-started/#sandboxes)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will move a level higher. Finally, we're up to
    the Python bit of MQTT! Rest assured that everything we just covered will be invaluable
    when you develop IoT applications that use MQTT because the command-line tools
    and examples we covered will become an important part of your MQTT development
    and debugging toolkit. We will be applying the core MQTT concepts we have learned
    already, only this time using Python and the Paho-MQTT client library.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Python Paho-MQTT client library
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into Python code, we first need an MQTT client library for Python.
    At the start of this chapter in the *Technical requirements* section, we installed
    the Paho-MQTT client library, which was part of `requirements.txt`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to MQTT and have not read the preceding section, *Learning MQTT
    by example*, I recommend stopping now and reading it first so you gain an understanding
    of MQTT concepts and terminology that will be used in the Python examples that
    follow.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The Paho-MQTT client library comes from the Eclipse Foundation, which also maintains
    the Mosquitto MQTT broker. In the *Further reading* section, you will find a link
    to the official *Paho-MQTT Client Library API* documentation. After completing
    this chapter, if you wish to deepen your understanding of this library and its
    capabilities, I recommend reading through the official documentation and the examples
    found therein.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python Paho-MQTT library has three core modules:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: This gives you full life cycle management of MQTT in your Python
    application.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**: This is a helper module for message publishing.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: This is a helper module for message subscribing.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client module is ideal if you are creating more complex and long-running
    IoT applications, whereas the publisher and subscriber helper modules are convenient
    for short-lived applications and situations where full life cycle management is
    not warranted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The following Python examples will connect to your local Mosquitto MQTT broker
    that we installed in the *Installing the Mosquitto MQTT broker* section previously.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the Paho client module so we can create a more complete MQTT
    example. However, once you can follow and understand the client module, creating
    alternatives using the helper modules will be a piece of cake.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, we will be working with the breadboard circuit we created in
    [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)*, Getting Started with
    Python and IoT*, *Figure 2.7*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic familiarity with the Paho-MQTT library, we will next start
    by briefly reviewing what the Python program and the accompanying web page client
    do and see Paho-MQTT in action.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED with Python and MQTT
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in the *Installing the Mosquitto MQTT broker* section, we tested
    the installation by visiting the `http://localhost:8083` URL, which gave us a
    web page with a slider. However, at the time, we could not change the LED's brightness.
    When you moved the slider, the web page was publishing MQTT messages to the Mosquitto
    broker, but no program was receiving the messages to change the LED's brightness.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll see the Python code that subscribes to a topic called
    `led` and processes the messages generated by the slider. We will start by running
    the Python code and making sure we can change the LED's brightness.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Running the LED MQTT example
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will find the code in the `chapter04/mqtt_led.py` file. Please review this
    file before proceeding to get an overall idea of what it contains and then follow
    these steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program in a Terminal with the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, open a second Terminal window and try the following, and the LED should
    turn on (be careful to make sure the JSON string is formed correctly):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Did you notice the `-r` (`--retain`) option used in *step 2*? Terminate and
    restart `mqtt_led.py` and watch the log output in **Terminal #1** and the LED.
    You should notice on startup that `mqtt_led.py` receives the LED''s brightness
    value from the topic''s *retained message* and initializes the LED''s brightness
    accordingly.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, visit the `http://localhost:8083` URL and make sure the LED changes its
    brightness as you move the slider.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the web page open, and try the command in *step 2* again. Observe what
    happens to the slider—it will stay in sync with the new level value you specified.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see durable connections in action. Terminate `mqtt_led.py` again
    and perform the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the web page, move the slider around randomly for about 5 seconds. As you
    move the slider, messages are being published to the broker on the `led` topic.
    They will be queued for delivery to `mqtt_led.py` when it reconnects.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart `mqtt_led.py` and observe the Terminal and LED. You will notice a flood
    of messages on the Terminal, and the LED will flicker as the queued messages are
    delivered and processed by `mqtt_led.py`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Mosquitto is configured to queue 100 messages per client that are
    using a durable connection. A client is identified by its client ID that you provide
    when connecting to the broker.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have interacted with and seen `mqtt_led.py` in action, let's take
    a look at its code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discuss the code found in `chapter04/mqtt_led.py`, pay particular attention
    to how the code connects to the MQTT broker and manages the connection life cycle.
    Furthermore, as we cover how the code receives and processes messages, try to
    relate the code workflow back to the command-line examples that we used to publish
    the message in the previous subsection, *Running the LED MQTT example*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an understanding of our Python code and how it integrates with
    our MQTT broker, you'll have an end-to-end working reference solution built around
    MQTT messaging that you can adapt for your own needs and projects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at the imports. As usual, we will skip over any common
    code that we have already covered in previous chapters, including logging setup
    and **GPIOZero**-related code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only new import we have in this example is for the Paho-MQTT client:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At line (1), we are importing the Paho-MQTT `client` class and giving it the
    alias, `mqtt`. As mentioned previously, this is the client class that will allow
    us to create a full life cycle MQTT client in Python.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will consider global variables.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `BROKER_HOST` and `BROKER_POST` variables at line (2) are referring to
    our locally installed Mosquitto MQTT broker. Port `1883` is the standard default
    MQTT port:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At line (3), we define `CLIENT_ID`, which will be the unique client identifier
    we use to identify our program with the Mosquitto MQTT broker. We *must* provide
    a unique ID to the broker so that we can use *durable connections*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: At line (4), we define the MQTT topic that our program will be subscribing to,
    while at line (5), the `client` variable is a placeholder that will be assigned
    the Paho-MQTT client instance, which we'll see shortly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The set_led_level(data) method
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`set_led_level(data)` at line (6) is where we integrate with GPIOZero to change
    the brightness of our LED and the method similar to the corresponding methods
    we covered in [Ch](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)[apter](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml) [3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, so we will not cover
    the internals here again:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The data parameter is expected to be a Python dictionary in the form of `{
    "level": 50 }`, where the integer is between 0 and 100 to indicate the brightness
    percentage.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the callback functions for MQTT. We'll start by reviewing `on_connect()` and
    `on_disconnect()`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The on_connect() and on_disconnect() MQTT callback methods
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: on_connect()和on_disconnect() MQTT回调方法
- en: The `on_connect()` and `on_disconnect()` callback handlers are examples of the
    full life cycle that is available using the Paho `client` class. We will see how
    to instantiate a Paho `client` instance and register these callbacks later when
    we cover the `init_mqtt()` method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_connect()`和`on_disconnect()`回调处理程序是使用Paho `client`类提供的完整生命周期的示例。我们将在覆盖`init_mqtt()`方法时看到如何实例化Paho
    `client`实例并注册这些回调。'
- en: The parameters of interest to `on_connect()` at line (7) in the following code
    block are `client`, which is a reference to the Paho `client` class, and `result_code`,
    which is an integer describing the connection result. We see `result_code` used
    at line (8) to test the success of the connection. Notice the `connack_string()` method,
    which is used for a connection failure to translate `result_code` into a human-readable
    string.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第7行，`on_connect()`感兴趣的参数是`client`，它是对Paho `client`类的引用，以及`result_code`，它是描述连接结果的整数。我们在第8行看到`result_code`用于测试连接的成功。注意`connack_string()`方法，它用于连接失败时将`result_code`转换为可读的字符串。
- en: When we speak of the MQTT *client* and see the `client` parameter at line (7)
    in the following code block, remember this is our Python code's client connection *to
    the broker*, NOT a reference to a client program such as the web page. This client
    parameter is very different in meaning to the client parameter we saw used in
    callback handlers for our Flask-SocketIO Web Socket server in *[Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    Networking with RESTful APIs and Web Sockets Using Flask*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论MQTT *client*并在以下代码块的第7行看到`client`参数时，请记住这是我们Python代码的客户端连接*到代理*，而不是指客户端程序，比如网页。这个客户端参数在意义上与我们在*[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中为Flask-SocketIO
    Web Socket服务器使用回调处理程序时看到的客户端参数非常不同。
- en: 'For reference, the `user_data` parameter can be used to pass around private
    data between a Paho client''s callback methods, while `flags` is a Python dictionary
    containing response and configuration hints from the MQTT broker:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，`user_data`参数可用于在Paho客户端的回调方法之间传递私有数据，而`flags`是一个包含MQTT代理的响应和配置提示的Python字典：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At line (9), we see the Paho `client` instance method, `subscribe()`, used to
    subscribe to the `led` topic using the `TOPIC` global variable, which we saw defined
    earlier. We also indicate to the broker that our subscription is a QoS level 2.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9行，我们看到Paho `client`实例方法`subscribe()`，用于使用我们之前定义的全局变量`TOPIC`订阅`led`主题。我们还告诉代理我们的订阅是QoS级别2。
- en: Always subscribe to topics in an `on_connect()` handler. This way, if the client
    ever loses the connection to the broker, it can re-establish subscriptions when
    it reconnects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在`on_connect()`处理程序中订阅主题。这样，如果客户端失去与代理的连接，它可以在重新连接时重新建立订阅。
- en: 'Next, at line (10) in the following, we have the `on_disconnect()` handler,
    where we are simply logging any disconnects. The method parameters have the same
    meanings as for the `on_connect()` handler:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在以下的第10行，我们有`on_disconnect()`处理程序，我们只是记录任何断开连接。方法参数的含义与`on_connect()`处理程序相同：
- en: '[PRE33]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will now move on to the callback method that handles incoming messages for
    the `led` topic that we subscribed to in `on_connect()` on line (9).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转到处理我们在`on_connect()`中订阅的`led`主题的回调方法，位于第9行。
- en: The on_message() MQTT callback method
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: on_message() MQTT回调方法
- en: It's the `on_message()` handler at line (11) that is called whenever a new message
    for a subscribed topic is received by our program. The message is available through
    the `msg` parameter, which is an instance of `MQTTMessage`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11行的`on_message()`处理程序在我们的程序接收到订阅主题的新消息时被调用。消息通过`msg`参数可用，它是`MQTTMessage`的一个实例。
- en: 'At line (12), we access the `payload` property of `msg` and decode it into
    a string. We expect our data to be a JSON string (for example, `{ "level": 100
    }`), so we parse the string into a Python dictionary using `json.loads()` and
    assign the result to `data`. If the message payload is not valid JSON, we catch
    the exception and log an error:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '在第12行，我们访问`msg`的`payload`属性并将其解码为字符串。我们期望我们的数据是一个JSON字符串（例如，`{ "level": 100
    }`），所以我们使用`json.loads()`将字符串解析为Python字典，并将结果赋给`data`。如果消息负载不是有效的JSON，我们捕获异常并记录错误：'
- en: '[PRE34]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using the `topic` property of `msg` on line (13), we check that it matches our
    expected `led` topic, which it will in our case since our program is only subscribing
    to this specific topic. However, this provides a point of reference regarding
    where and how you would perform conditional logic and routing for a program that
    subscribes to multiple topics.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行使用`msg`的`topic`属性，我们检查它是否与我们预期的`led`主题匹配，在我们的情况下，它会匹配，因为我们的程序只订阅这个特定的主题。然而，这提供了一个参考点，关于在订阅多个主题的程序中执行条件逻辑和路由的位置和方式。
- en: Finally, at line (14), we pass our parsed message to the `set_led_level()` method,
    which, as discussed, changes the brightness of our LED.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第14行，我们将解析的消息传递给`set_led_level()`方法，正如讨论的那样，这会改变LED的亮度。
- en: Next, we will learn how the Paho client is created and configured.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建和配置Paho客户端。
- en: The init_mqtt() method
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init_mqtt()方法
- en: We see the Paho-MQTT `client` instance created and assigned to the global `client`
    variable at line (15). A reference to this object is the  `client` parameter we
    saw previously in the `on_connect()`, `on_disconnect()`, and `on_message()` methods.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第15行看到Paho-MQTT `client`实例被创建并分配给全局`client`变量。这个对象的引用是`client`参数，我们之前在`on_connect()`、`on_disconnect()`和`on_message()`方法中看到过。
- en: 'The `client_id` parameter is set to be the client name we defined earlier in
    `CLIENT_ID`, while `clean_session=False` tells the broker that it *must not clear*
    any stored messages for our client when we connect. As we discussed earlier in
    the command-line examples, this is the back-to-front way of saying we want a durable
    connection so any messages published to the `led` topic are stored for our client
    when it''s offline:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: An important point to note is on line (16). Our program is using the standard
    Python logging packages, so we need to make this call to `client.enable_logger()` to
    ensure that we get any Paho-MQTT client log message. Missing this call means helpful
    diagnostic information may not get logged.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at line (18), we connect to the Mosquitto MQTT broker. It's our `on_connect()`
    handler that will be called once the connection is established.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how our program is started.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Main entry point
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After initializing our LED and client instances, we get to the program's main
    entry point.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'We are registering a signal handler to capture *Ctrl* + *C* key combinations
    at line (19). The `signal_handler` method (not shown) simply turns off our LED
    and gracefully disconnects from the broker:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At line (20), the call to `client.loop_start()` is what allows our client to
    start, connect to the broker, and receive messages.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the LED program is stateless? We are not storing or persisting
    any LED level in code or to disk. All our program does is subscribe to a topic
    on the broker and change the LED's brightness using GPIOZero. We effectively hand
    all state management over to the MQTT broker by relying on MQTT's retained message
    (also known as the *last known good message*) facility.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished exploring the Python code that interacts with both the
    LED and MQTT broker. We learned how to use the Python Paho-MQTT library to connect
    to an MQTT broker and subscribe to an MQTT topic. As we received messages on the
    subscribed topic, we saw how to process them and changed the brightness level
    of our LED according to the message payload.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The Python and Paho-MQTT framework and example we covered will provide you with
    a solid starting point for your own MQTT-based IoT projects.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will be looking at a web client that uses MQTT together with Web Sockets.
    This web client will connect to our Mosquitto MQTT broker and publish messages
    to control our LED.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Building a web-based MQTT client
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking with
    RESTful APIs and Web Sockets Using Flask*, we covered a code example using Web
    Sockets, which included an HTML file and JavaScript web client. In this section,
    we will also be looking at a Web Socket-based web client built using HTML and
    JavaScript. However, this time, we will be leveraging the built-in Web Socket
    features provided by the Mosquitto MQTT broker and the compatible JavaScript Paho-JavaScript
    Web Sockets library (you will find a link to this library in the *Further reading*
    section).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: For comparison, in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking
    with RESTful APIs and Web Sockets Using Flask*, we created our Web Socket server
    ourselves in Python using Flask-SocketIO, while our web client used the Socket.io
    JavaScript Web socket library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: We interacted with the web client we are about to explore to control our LED
    previously in the  *Installing the Mosquitto MQTT broker *at section *step 7*. You
    might like to quickly review *step 7* to refamiliarize yourself with the web client
    and how to access it in your web browser.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: You will find the code for the web page client in the `chapter04/mosquitto_www/index.html` file. Please
    review this file before proceeding.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the JavaScript library we are using in this example is different, you
    will find that the general structure and use of the JavsScript code are similar
    to the code we saw for the `socket.io`-based web client in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)*,
    Networking with RESTful APIs and Web Sockets Using Flask*. As usual, we will start
    by looking at the imports.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our web client imports the Paho-MQTT JavaScript client library at line (1):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`paho-mqtt.js` can be also found in the `chapter04/mosquitto_www` folder.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation page for the Paho-MQTT JavaScript library is available
    at [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js),
    while its official GitHub page is found at [https://github.com/eclipse/paho.mqtt.javascript](https://github.com/eclipse/paho.mqtt.javascript)[.](https://www.eclipse.org/paho/clients/js)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: When you explore the Paho-MQTT JavaScript API further, start at its GitHub site
    and make note of any breaking changes that are mentioned. The documentation pages
    are known to contain code fragments that do not reflect the latest GitHub code
    base.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Next, we encounter the global variables.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At line (2), we initialize a `Client_ID` constant that will identify our JavaScript
    client with the broker.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Paho JavaScript MQTT client *must* have a unique *hostname, port,* and
    *client ID *combination when it connects to the broker. To ensure we can run multiple
    web pages on a single computer for testing and demonstration, we use a random
    number to create a quasi-unique client ID for each web page:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At line (3), we define the `TOPIC` constant with `led`, the name of the MQTT
    topic that we will be subscribing and publishing to shortly. Next, we create our
    client instance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The Paho JavaScript MQTT client
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At line (4), we create our Paho-MQTT Client instance and assign it to the `client`
    variable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters to `Paho.MQTT.Client()` are the broker''s hostname and port.
    We are serving this web page via Mosquitto, so the broker''s host and port will
    be the same as web pages:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You may have noticed in the `http://localhost:8083` URL that the port is `8083`,
    while in Python we used port `1883`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Port `1883` is the MQTT protocol port on the broker. Our Python program connects
    directly to the broker on this port.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We previously configured port `8083` as a Web Socket port on the Mosquitto broker.
    Web pages can speak HTTP and Web Socket protocols, not MQTT.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This raises an important point. While we're using the term MQTT in the context
    of our JavaScript code, we're really proxying the MQTT idea using Web Sockets back
    and forth to the broker.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: When we speak of the MQTT *client* and created the `client` instance at line
    (4), remember this is our JavaScript code's client connection *to the broker*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see how to connect to the broker and register an `onConnect` handler
    function.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the broker
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define our `onConnectionSuccess()` handler at line (5), which will be called
    after our `client` successfully connects to the broker. When we successfully connect,
    we then update the web page to reflect the successful connection and enable the
    slider control:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, at line (6), we subscribe to the `led` topic. It's at line (7) that we
    connect to the broker. Notice that we're registering the `onConnectionSuccess`
    function as the `onSuccess` option.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Remember, similar to the Python example, always subscribe to topics in an
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`onSuccess` handler. This way, if the client ever loses the connection to the
    broker, it can re-establish subscriptions when it reconnects.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify the `reconnect: true` option so that our client will automatically
    reconnect to the broker if it loses its connection.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: It has been observed that it may take up to a minute for the JavaScript Paho-MQTT
    client to reconnect after losing a connection, so please be patient. This is in
    contrast to the Python Paho-MQTT client, which reconnects almost instantly.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have another two handlers to review.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The onConnectionLost and onMessageArrived handler methods
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code, at lines (8) and (9), we see how to register an `onConnectionLost`
    and `onMessageArrived` handler with our Paho-MQTT `client` instance:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These two functions are similar in principle to their corresponding functions
    in the socket.io example from the previous [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, in that they update
    the slider and web page text based on the data found in their respective `data`
    and `message` parameters.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our document ready function.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: JQuery document ready function
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we encounter the document ready function at line (1o) where we initialize our
    web page content and register the event listener for the slider:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Within the sliders event handler at line (11), we see how to create an MQTT
    message. Notice the use of `JSON.stringify(payload)`. The `Paho.Message` constructor
    expects a `String` parameter, not an `Object`, so we must convert the payload
    variable (which is an `Object`) in to a string.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Starting at line (12), we set the message publication topic to `led` with `message.destinationName
    = TOPIC` before flagging its QoS level as 2.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Next, at line (13), with `message.retained = true`, we indicate that we want
    this message to be retained so that it is automatically delivered to new clients
    subscribing to the `led` topic. The retention of this message is what allows `mqtt_led.py`
    to reinitialize the LED's previous brightness between restarts.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Well Done! We have now covered both the Python and JavaScript sides of a simple
    MQTT-based application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored and practiced the core concepts of MQTT. After
    installing and configuring the Mosquitto MQTT broker on your Raspberry Pi, we
    moved straight into learning a range of examples on the command line. We learned
    how to publish and subscribe to MQTT messages, how to understand topic construction
    and name hierarchies, and how we can attach a QoS level to a message.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We also covered durable connections and retained messages, two mechanisms offered
    by MQTT brokers for storing messages for later delivery. We concluded our walk-through
    of MQTT concepts by exploring a special message and topic type known as a *Will*,
    whereby a client can register a message with a broker that gets automatically
    published to a topic in cases where the client abruptly loses its connection.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Next, we reviewed and walked through a Python program that used the Paho Python
    MQTT library to subscribe to an MQTT topic and control the brightness of our LED
    in response to the messages it received. We followed this with a walk-through
    of a web page built with the Paho JavaScript MQTT library that published the messages
    consumed by our Python program.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: You now have a working knowledge of MQTT and a practical code framework you
    can now leverage for your own IoT applications. This is in addition to the other
    networking approaches and code frameworks that we've explored in earlier chapters,
    such as the dweet.io service, Flask-RESTful, and Flask-SocketIO. Which approach
    you use for your projects all depends on what you are trying to create and, of
    course, your own personal preference. For larger projects and projects where you
    need to integrate with external systems, you may find yourself needing to leverage
    multiple approaches in tandem and even find the need to research and explore additional
    techniques. I do not doubt that your learning and understanding of the alternative
    networking approaches we've covered so far will be of value and help with your
    understanding of other approaches you encounter.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Connecting Python to the Physical World*, we will be exploring
    a range of topics related to how you connect your Raspberry Pi to the world. We
    will run through popular Python GPIO library options in addition to GPIOZero and
    PiGPIO and look at the different types of electronic interfacing options and configurations
    that are available with a Raspberry Pi. We also have a comprehensive exercise
    where we will be adding an analog-to-digital converter to your Raspberry Pi and
    using it to create a program to explore PWM techniques and concepts.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: What is MQTT?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your retained MQTT messages never get delivered. What should you check?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under what condition will an MQTT broker publish a *Will* message?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You choose to use MQTT as your IoT application's messaging layer and must ensure
    that messages are sent and received. What is the minimum QoS level required?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You develop an application using MQTT and use the Mosquitto broker, but now
    you need to use a different broker. What does this mean for your code base and
    deployment configuration?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Where in code (hint: which handler method) should you subscribe to MQTT topics
    and why?'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the basics of MQTT from an operational level in this chapter. If
    you want to learn more about MQTT from a protocol and data level, HiveMQ (an MQTT
    broker and service provider) has an excellent 11-part series on the MQTT protocol
    available at [https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The home page of the Mosquitto MQTT broker and client tools are available at
    the following URL:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Mosquitto MQTT broker: [https://mosquitto.org](https://mosquitto.org)
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation and API references for the Paho-MQTT libraries we used in
    this chapter are available at the following URLs:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Paho-MQTT Python library: [https://www.eclipse.org/paho/clients/python](https://www.eclipse.org/paho/clients/python/)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paho-MQTT JavaSctipt library: [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to MQTT, HTTP RESTful APIs, and Web Sockets, there are complimentary
    communication protocols that are specially designed for constrained devices, known
    as CoRA and MQTT-NS. The Eclipse Foundation has a summary of these protocols available
    at [https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php](https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
