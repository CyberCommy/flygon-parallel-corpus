- en: Language Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 15\. IPv4 data type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a class that represents an IPv4 address. Implement the functions required
    to be able to read and write such addresses from or to the console. The user should
    be able to input values in dotted form, such as `127.0.0.1` or `168.192.0.100`.
    This is also the form in which IPv4 addresses should be formatted to an output
    stream.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Enumerating IPv4 addresses in a range
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that allows the user to input two IPv4 addresses representing
    a range and list all the addresses in that range. Extend the structure defined
    for the previous problem to implement the requested functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Creating a 2D array with basic operations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a class template that represents a two-dimensional array container with
    methods for element access (`at()` and `data()`), capacity querying, iterators,
    filling, and swapping. It should be possible to move objects of this type.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 18\. Minimum function with any number of arguments
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function template that can take any number of arguments and returns
    the minimum value of them all, using `operator <` for comparison. Write a variant
    of this function template that can be parameterized with a binary comparison function
    to use instead of `operator <`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 19\. Adding a range of values to a container
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a general-purpose function that can add any number of elements to the
    end of a container that has a method `push_back(T&& value)`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Container any, all, none
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a set of general-purpose functions that enable checking whether any,
    all, or none of the specified arguments are present in a given container. These
    functions should make it possible to write code as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 21\. System handle wrapper
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider an operating system handle, such as a file handle. Write a wrapper
    that handles the acquisition and release of the handle, as well as other operations
    such as verifying the validity of the handle and moving handle ownership from
    one object to another.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 22\. Literals of various temperature scales
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a small library that enables expressing temperatures in the three most
    used scales, Celsius, Fahrenheit, and Kelvin, and converting between them. The
    library must enable you to write temperature literals in all these scales, such
    as `36.5_deg` for Celsius, `97.7_f` for Fahrenheit, and `309.65_K` for Kelvin;
    perform operations with these values; and convert between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 15\. IPv4 data type
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem requires writing a class to represent an IPv4 address. This is
    a 32-bit value, usually represented in decimal dotted format, such as `168.192.0.100`*;* each
    part of it is an 8-bit value, ranging from 0 to 255\. For easy representation
    and handling, we can use four `unsigned char` to store the address value. Such
    a value could be constructed either from four `unsigned char` or from an `unsigned
    long`. In order to be able to read a value directly from the console (or any other
    input stream) and be able to write the value to the console (or any other output
    stream), we have to overload `operator>>` and `operator<<`. The following listing
    shows a minimal implementation that can meet the requested functionality:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ipv4` class can be used as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 16\. Enumerating IPv4 addresses in a range
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to enumerate IPv4 addresses in a given range, it should first be
    possible to compare IPv4 values. Therefore, we should implement at least `operator<`,
    but the following listing contains implementation for all comparison operators:
    `==`, `!=`, `<`, `>`, `<=`, and `>=`. Also, in order to increment an IPv4 value,
    implementations for both the prefix and postfix `operator++` are provided. The
    following code is an extension of the IPv4 class from the previous problem:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these changes to the `ipv4` class from the previous problem, we can write
    the following program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 17\. Creating a 2D array with basic operations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before looking at how we could define such a structure, let''s consider several
    test cases for it. The following snippet shows all the functionality that was
    requested:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that for element access, we are using `operator()`, such as in `a(i,j)`,
    and not `operator[]`, such as in `a[i][j]`, because only the former can take multiple
    arguments (one for the index on each dimension). The latter can only have a single
    argument, and in order to enable expressions like `a[i][j]`, it has to return
    an intermediate type (one that basically represents a row) that in turn overloads
    `operator[]` to return a single element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'There are already standard containers that store either fixed or variable-length
    sequences of elements. This two-dimensional array class should be just an adapter
    for such a container. In choosing between `std::array` and `std::vector`, we should
    consider two things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The `array2d` class should have move semantics to be able to move objects
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be possible to list initialize an object of this type
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::array` container is movable only if the elements it holds are move-constructible
    and move-assignable. On the other hand, it cannot be constructed from an `std::initializer_list`.
    Therefore, the more viable option remains an `std::vector`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Internally, this adapter container can store its data either in a vector of
    vectors (each row is a `vector<T>` with `C` elements, and the 2D array has `R`
    such elements stored in a `vector<vector<T>>`) or single vector of `R![](img/2f9ae4c1-380b-4377-84dd-a28429c062c5.png)C`
    elements of type `T`. In the latter case, the element on row `i` and column `j`
    is found at index `i * C + j`. This approach has a smaller memory footprint, stores
    all data in a single contiguous chunk, and is also simpler to implement. For these
    reasons, it is the preferred solution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible implementation of the two-dimensional array class with the requested
    functionality is shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 18\. Minimum function with any number of arguments
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to write function templates that can take a variable number
    of arguments using variadic function templates. For this, we need to implement
    compile-time recursion (which is actually just calls through a set of overloaded
    functions). The following snippet shows how the requested function could be implemented:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to be able to use a user-provided binary comparison function, we need
    to write another function template. The comparison function must be the first
    argument because it cannot follow the function parameter pack. On the other hand,
    this cannot be an overload of the previous minimum function, but a function with
    a different name. The reason is that the compiler would not be able to differentiate
    between the template parameter lists `<typename T1, typename... T>` and `<class
    Compare, typename T1, typename... T>`. The changes are minimal and should be easy
    to follow in this snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 19\. Adding a range of values to a container
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing functions with any number of arguments is possible using variadic function
    templates. The function should have the container as the first parameter, followed
    by a variable number of arguments representing the values to be added at the back
    of the container. However, writing such a function template can be significantly
    simplified using fold expressions. Such an implementation is shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Examples of using this function template, with various container types, can
    be seen in the following listing:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 20\. Container any, all, none
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirement to be able to check the presence or absence of a variable number
    of arguments suggests that we should write variadic function templates. However,
    these functions require a helper function, a general-purpose one that checks whether
    an element is found in a container or not and returns a `bool` to indicate success
    or failure. Since all these functions, which we could call `contains_all`, `contains_any`,
    and `contains_none`, do is apply logical operators on the results returned by
    the helper function, we would use fold expressions to simplify the code. Short
    circuit evaluation is enabled after the expansion of the fold expression, which
    means we are evaluating only the elements that lead to a definitive result. So
    if we are looking for the presence of all 1, 2, and 3, and 2 is missing, the function
    will return after looking up value 2 in the container without checking value 3:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 21\. System handle wrapper
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System handles are a form of reference to system resources. Because all operating
    systems were at least initially written in C, creating and releasing the handles
    is done through dedicated system functions. This increases the risk of leaking
    resources because of erroneous disposal, such as in the case of an exception.
    In the following snippet, specific to Windows, you can see a function where a
    file is opened, read from, and eventually closed. However, this has a couple of
    problems: in one case, the developer forgot to close the handle before leaving
    the function; in another case, a function that throws is called before the handle
    is properly closed, without the exception being caught. However, since the function
    throws, that cleanup code never executes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A C++ wrapper class can ensure proper disposal of the handle when the wrapper
    object goes out of scope and is destroyed (whether that happens through a normal
    execution path or as the result of an exception). A proper implementation should
    account for different types of handles, with a range of values to indicate an
    invalid handle (such as 0/null or -1). The implementation shown next provides:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Explicit acquisition and automatic release of the handle when the object is
    destroyed
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move semantics to enable transfer of ownership of the handle
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators to check whether two objects refer to the same handle
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional operations such as swapping and resetting
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation shown here is a modified version of the handle class implemented
    by Kenny Kerr and published in the article *Windows with C++ - C++ and the Windows
    API*, MSDN Magazine, July 2011, [https://msdn.microsoft.com/en-us/magazine/hh288076.aspx](https://msdn.microsoft.com/en-us/magazine/hh288076.aspx).
    Although the handle traits shown here refer to Windows handles, it should be fairly
    simple to write traits appropriate for other platforms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this handle type defined, we can rewrite the previous example in simpler
    terms, avoiding all those problems with handles not properly closed because of
    exceptions occurring that are not properly handled, or simply because developers
    forget to release resources when no longer needed. This code is both simpler and
    more robust:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 22\. Literals of various temperature scales
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To meet this requirement, we need to provide an implementation for several
    types, operators, and functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration of supported temperature scales called `scale`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class template to represent a temperature value, parameterized with the scale,
    called `quantity`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators `==`, `!=`, `<`, `>`, `<=`, and `>=` that compare two quantities
    of the same time.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators `+` and `-` that add and subtract values of the same quantity
    type. Additionally, we could implement member operators `+=` and `-+`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function template to convert temperatures from one scale to another, called
    `temperature_cast`. This function does not perform the conversion itself but uses
    type traits to do that.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal operators `""_deg`, `""_f`, and `""_k` for creating user-defined temperature
    literals.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建用户定义的温度字面量的文字操作符`""_deg`，`""_f`和`""_k`。
- en: For brevity, the following snippet only contains the code that handles Celsius
    and Fahrenheit temperatures. You should take it as a further exercise to extend
    the code with support for the Kelvin scale. The code accompanying the book contains
    the full implementation of all three required scales.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，以下代码片段仅包含处理摄氏度和华氏度温度的代码。您应该将其视为进一步练习，以扩展代码以支持开尔文标度。附带书籍的代码包含了所有三个所需标度的完整实现。
- en: 'The `are_equal()` function is a utility function used to compare floating-point
    values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`are_equal()`函数是一个用于比较浮点值的实用函数：'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The enumeration of possible temperature scales and the class that represents
    a temperature value are defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的温度标度的枚举和表示温度值的类定义如下：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The comparison operators for the `quantity<S>` class can be seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantity<S>`类的比较操作符可以在这里看到：'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To convert between temperature values of different scales, we will define a
    function template called `temperature_cast()` that utilizes several type traits
    to perform the actual conversion. All these are shown here, although not all type
    traits; the others can be found in the code accompanying the book:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同温度标度之间进行转换，我们将定义一个名为`temperature_cast()`的函数模板，该函数利用了几个类型特征来执行实际的转换。所有这些都在这里显示，尽管并非所有类型特征；其他类型特征可以在附带书籍的代码中找到：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The literal operators for creating temperature values are shown in the following
    snippet. These operators are defined in a separate namespace, called `temperature_scale_literals`,
    which is a good practice in order to minimize the risk of name collision with
    other literal operators:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建温度值的文字操作符显示在以下代码片段中。这些操作符定义在一个名为`temperature_scale_literals`的单独命名空间中，这是一种良好的做法，以减少与其他文字操作符的名称冲突的风险：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following example shows how to define two temperature values, one in Celsius
    and one in Fahrenheit, and convert between the two:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何定义两个温度值，一个是摄氏度，一个是华氏度，并在两者之间进行转换：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
