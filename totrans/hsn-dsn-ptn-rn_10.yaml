- en: Managing Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to managing dependencies, namely libraries, that your
    mobile applications rely on. Most current applications abuse the singleton pattern.
    However, I strongly believe that, one day, JavaScript developers will adopt well-known
    **dependency injection** (**DI**) patterns. Even if they decide to use the singleton
    pattern, it will be way easier to refactor. In this chapter, we will focus on
    the React context and how libraries such as Redux leverage the DI mechanism. This
    is the safest alternative to use if you really want to step up your code and make
    it easily testable. We will dive into the code in the React Redux library, which
    uses the React context extensively. You will also understand why the JavaScript
    world is so slow to abandon the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DI pattern and its flavors in ECMAScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The storybook pattern, to increase productivity and document your components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage large code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get ready, as we will start off with the singleton pattern straightaway.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern is a class that can have only one instance. By its design,
    whenever we attempt to create a new instance, it will either create an instance
    for the first time or return the one that was created previously.
  prefs: []
  type: TYPE_NORMAL
- en: How is this pattern useful? If we want to have a single manager for certain
    things, this comes in handy, whether it be an API manager or cache manager. For
    instance, if you need to authorize the API to get the token, you will only want
    to do this once. The first instance will initiate whatever work is necessary and
    then any other instance will reuse the work that has already been done. This use
    case was abused mostly by server-side applications, but more and more people have
    come to realize that there are better alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Such use cases can nowadays be easily countered by better patterns. Instead
    of creating a singleton pattern, you could simply store the token in a cache,
    and in any new instance, verify if the token is already in the cache. If it is,
    you can skip authorization and use the token. This trick uses the well-known fact
    that a cache is the one centralized place for storing data. In this context, it
    serves as a singleton store for us. Whether it be a cache for a client or cloud
    server, it's exactly the same thing, with the exception that on the server, it
    may be more costly to call.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the singleton pattern in ECMAScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although using the singleton pattern is discouraged nowadays, it is very beneficial
    to learn how to create this mechanism. For this code example, we will use ECMAScript
    6 classes and ECMAScript 7 static fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are changing the behavior of the constructor. First, before returning anything,
    we need to check if the instance has already been created. If so, the current
    call returns that instance instead.
  prefs: []
  type: TYPE_NORMAL
- en: Why using the singleton pattern is discouraged
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Singleton` is sometimes treated as a `global` variable. If you attempt to
    import it from many different places and your use case is just sharing the same
    instance, you are probably abusing the pattern. This way, you tightly couple different
    pieces to the exact imported object. It is one of the vital signs of **code smell**
    if you use a `global` variable instead of passing it down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, `Singleton` is very unpredictable in terms of testing. You
    receive something that is an effect of mutation. It may be a new object, or the
    object previously created. You may be tempted to use this to synchronize some
    form of a state. For instance, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This makes `Singleton` not only globally shared, but also globally mutable.
    This is a horrible story if you want to make it predictable. It generally defeats
    everything we learned about in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: You need to reassure every consumer component that it is ready to handle any
    type of data that comes from a singleton. This requires an exponential number
    of tests, and thus kills productivity. This is unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, you will find a solution that will fix all of these
    issues via DI.
  prefs: []
  type: TYPE_NORMAL
- en: The many singleton flavors in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be honest, beyond just the previous implementation, we can see many other
    variations in order to achieve the same thing. Let's discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the singleton has already been exported as an `instance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This looks like a good improvement unless your `Singleton` requires arguments.
    If so, the `Singleton` is exported in such a way that it is also harder to test
    and may only accept hard-coded dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, your `Singleton` may be very small and only an object will be enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Refactoring this pattern we may lead to a well-known syntax for any mature
    JavaScript developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last example may start worrying you, and you may have started asking yourself—am
    I unknowingly using singletons? I bet you are. But this is not the end of the
    world, as long as you inject them properly. Let's go through a section on ECMAScript
    and JavaScript module approaches. This is important knowledge for any JavaScript
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, as some module bundlers do not guarantee that modules will be instantiated
    only once. Tools such as webpack may internally, for the sake of optimization
    or compatibility, instantiate some modules multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 modules and beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best aspects of ES6 modules is the static nature of import and export
    declarations. Thanks to this, we can check at compile time if imports and exports
    are correct, perform injections (such as polyfills for older browsers), and bundle
    them together if necessary (like webpack does). These are amazing positives that
    save us a lot of runtime checking that would possibly slow our application down.
  prefs: []
  type: TYPE_NORMAL
- en: However, some people abuse how ES6 modules work. The syntax is super easy—you
    can import module wherever and use it easily. This is a gotcha. You may not want
    to abuse importing.
  prefs: []
  type: TYPE_NORMAL
- en: The DI pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Importing and using an imported value in the same file locks that file to the
    concrete implementation. For instance, check out the following app code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the `TasksSection` component is composed of two container
    components, `AddTaskContainer` and `TaskListContainer`. The important fact is
    that you cannot modify either of the container components if you are a consumer
    of the `TasksSection` component. You need to rely on the implementations provided
    by imported modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we can use the DI pattern. We are essentially passing
    dependencies to the component as props. In this example, this would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If somebody is not interested in passing these components, we can create a container
    that will provide them. However, in cases where we want to substitute containers
    for something else, this comes in very handy, for instance, in tests or in storybooks!
    What is storybook? Keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DI pattern with storybooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A storybook is a way to document your components. As your application grows,
    you may quickly end up with hundreds of components. If you build a serious application,
    most of them are aligned to a design specification and all of the expected features
    will have been implemented. The trick is knowing which props to send to achieve
    the expected result. Storybook makes this simple. When you implement a component,
    you also create a storybook for different scenarios. Check out the following trivial
    example for the `Button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a901b7cd-8918-498c-aa7e-6bceacaa1d6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Example storybook of the Button component
  prefs: []
  type: TYPE_NORMAL
- en: By selecting scenarios in the left panel, you can quickly look up how components
    look with different props.
  prefs: []
  type: TYPE_NORMAL
- en: I have installed Storybook for you to play with in `src/Example 10/Exercise
    1`. You can launch Storybook by running either `yarn run ios:storybook` or `yarn
    run android:storybook` from that directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn how to set up Storybook yourself, check out the official
    documentation at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/storybooks/storybook/tree/master/app/react-native](https://github.com/storybooks/storybook/tree/master/app/react-native).'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the configuration files you will need to add should go in the `storybook`
    directory within the project.
  prefs: []
  type: TYPE_NORMAL
- en: The installation command-line interface that storybook provides sets up playground
    stories for you. Those are the ones in the preceding screenshot (the `Button`
    with text and with emojis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to add our own stories. Let''s start with something easy – the `TaskList`
    component. This component is ideal for storybooking because it is very well-developed.
    It handles errors, and displays various messages depending on the loading state
    or error state. It can display 0 tasks, 1 task, and 2 or more tasks. There are
    a lot of stories to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we created our first story for the `TaskList`
    component. The `storiesOf` function comes with storybook. Then, in a decorator,
    we wrapped every story with a scrollable view and general styles that apply padding
    to the left and right. In the end, we created two stories using the `add` function:
    `TaskList` with only one story and `TaskList` with `7` stories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, our code breaks with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem lies in the `NavButton` component that we have implemented. It
    uses the `withNavigation` HOC, which effectively requires context already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, `withNavigation` is already using the DI pattern thanks to relying
    on the React context. What we need to do is inject the required context (navigation)
    into our storybook example. To do so, we need to use `NavigationProvider` from
    react-navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can admire our two newly created stories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bd519bd2-dfbe-4a6e-8f8a-766f61753db8.png)'
  prefs: []
  type: TYPE_IMG
- en: TaskList component stories in storybook
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select one of them, it will be displayed on the simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a7f76cf9-b2d7-42d4-b4cd-eb749922fec1.png)'
  prefs: []
  type: TYPE_IMG
- en: TaskList stories displayed on the iPhone X simulators
  prefs: []
  type: TYPE_NORMAL
- en: 'With a little more effort, we can add further stories to this storybook. For
    instance, let''s try loading an error case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e53337d0-df47-4b21-a073-47c839445871.png)TaskList stories for loading
    state and error state'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a story for a combination such as the one shown in the preceding
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9501c3c3-a69e-4b5c-b1c8-11a730c51818.png)TaskList story with error
    and loading state'
  prefs: []
  type: TYPE_NORMAL
- en: Nested stories with DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example is good enough. It creates a storybook, it is reusable,
    and everyone is happy. However, as the application grows and we add more stories,
    it is not always possible to fix this with a `Provider`, or the `Provider` may
    have been used in too many stories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will refactor our code to be able to inject our own component
    instead of importing the `NavButton` container. As our goal is to retain the functionality
    that we had previously, in the storybook we will inject a `NavButton` story, which
    will take care of the navigation problem. However, in the normal app, we will
    inject the `NavButton` container just as before but into the `TaskList` container.
    The win here is the fact that we will not need to use `NavigationProvider` at
    all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, `TaskList` expects the `NavButton` component in props. We need
    to comply with these prop expectations, both in the container and in the storybook.
    The following is the code for the first container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Time for the fun part. We need to solve a storybook problem. To accomplish our
    goal with DI, we will create a separate storybook for `NavButton`. To fix the `TaskList`
    storybook, we will import the `NavButton` story and inject it as a `NavButton`
    component to the `TaskList` view.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound complicated, but let's see this in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `NavButton` story, we need to refactor `NavButton` into a view
    and a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The view is just the same as before—I have moved the code to `view.js` in the `NavigateButton`
    directory, next to the preceding container. We can now proceed with the creation
    of the storybook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, I have introduced a little improvement. Separation of
    concerns examples go into separate files so that they can be reused in areas other
    than just storybooks, for instance, in snapshot tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking `navigation` is now very simple and straightforward. We just substitute
    the `navigation` object and the `navigate` function inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to inject that example as the `NavButton` component in the `TaskList`
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, our `scrollViewDecorator` is minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: DI with React context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used DI in a very straightforward way by just injecting
    components. React comes with its own mechanism for DI.
  prefs: []
  type: TYPE_NORMAL
- en: React context can be used to inject dependencies into components that are very
    far in the chain from the container component. This makes React context a great
    fit for global dependencies that are reused across the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: Good examples of such a global dependency are a theme configuration, a logger,
    a dispatcher, a logged in user object, or language options.
  prefs: []
  type: TYPE_NORMAL
- en: Using the React Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn about the React Context API, we will use a simple language selector.
    I have created a component that allows us to select one of two languages, either
    English or Polish. It stores the selected language in the Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e705491b-1c10-44a5-8c0e-004dd261a186.png)'
  prefs: []
  type: TYPE_IMG
- en: Language selector in the application's header and the left image shows English
    selected; the right image shows Polish selected
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is now to expose language through the React context API. To do so,
    we need to use the `createContext` function that was imported from React. This
    function will return an object containing the `Provider` and `Consumer` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`LanguageConsumer` is used to get a value that traverses the component tree.
    The first `LanguageProvider` it encounters will provide the value; otherwise,
    if there is no `LanguageProvider`, the default value from the `createContext`
    call will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that every component has access to language, we should add `LanguageProvider`
    in the root, preferably in the screens component. To easily do so using already
    learned patterns, I have created a higher-order component called `withLanguageProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this utility to wrap the screen component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please notice the refactoring – we also provide the store in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having language in the context, we can proceed with the consumption in any
    lower level components, for instance, in the `TaskList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6edefca5-8b92-41a6-8081-5d1f2842775a.png)'
  prefs: []
  type: TYPE_IMG
- en: Example usage of LanguageConsumer in the TaskList component
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is only an example in order to learn about the context
    API. No actual translation is being performed. To add translations to your app,
    use the React Intl library from Yahoo!. It also exposes `Provider` for your convenience
    ([https://github.com/yahoo/react-intl](https://github.com/yahoo/react-intl)).
  prefs: []
  type: TYPE_NORMAL
- en: React Redux aside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you paid close attention to the previous examples, you may have spotted
    an interesting part – `withStoreProvider.` This is a higher order component I
    made to wrap the root component with the `react-redux` store `Provider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Provider` that is exposed is very similar to the React context API. The
    context was in the React library for a long time, along with an experimental API.
    However, the newest context API was introduced with React 16 and you may notice
    that old libraries still use their own custom providers. For instance, have a
    look at the react-redux `Provider` implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is how the react-redux `connect` function has access to your Redux store.
    Instead of the `Consumer` API, there is the `connect` function, which we use instead
    to access the store. You are probably already used to it. Treat this as a guideline
    on how to use exposed providers or consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code base has started growing. We have taken the first steps in addressing
    the monolithic architecture problem and we have a pretty good file structure so
    far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d10fb327-4630-4fae-954a-403e2a60b131.png)'
  prefs: []
  type: TYPE_IMG
- en: Current src/ directory structure
  prefs: []
  type: TYPE_NORMAL
- en: Although good enough for now, we should rethink our approach and create rules
    if we want to make this project bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Quick wins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a new developer joins the project, it may be a little challenging for them
    to understand our code base. Let's address a few easy fixes.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, where is the entry file for our application? It's in the root
    directory. However, there is no clear entry point in the source (`src/`) directory.
    This is okay, but it would be handy to have it close to the story and examples.
    At a glance, you will have examples, the storybook, and the app root to lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we can refactor the current `ScreenRoot` component. It serves
    as `AppRoot` and is wrapped in two HOCs. As you already know, such coupling is
    not a good thing. I have made a little refactor. Have a look at the new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aa2e4e2a-923a-4f62-90c2-59f141b9160c.png)'
  prefs: []
  type: TYPE_IMG
- en: The entry point to the application is now clearly visible (index.js)
  prefs: []
  type: TYPE_NORMAL
- en: 'We have achieved a very quick win; it is now way easier to find the root component.
    Now, let''s look at the `components` and `features` directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6d248313-16ac-4508-9d0f-4d3b7302dcb5.png)Components and features
    directories'
  prefs: []
  type: TYPE_NORMAL
- en: 'The components folder was initially meant to collect stateless components.
    As the application grew, we quickly realized that having a shared directory for
    just stateless components is not enough. We want to reuse stateful ones too. Thus,
    we should rename the `components` directory to `common`. It better represents
    what the directory is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e908a4cc-3ecf-4206-830c-6a790af89d9b.png)'
  prefs: []
  type: TYPE_IMG
- en: The Components directory has been renamed to common
  prefs: []
  type: TYPE_NORMAL
- en: Another issue that we will quickly notice is the fact that the language directory
    under features only creates confusion. It's primarily `LanguageSwitcher`, not
    the `language` in general. We have put this under features only because we want
    to consume the language in the app feature components. Is language context a feature?
    Not really; it is some sort of feature, but not in the context of user experience.
    This creates confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the context to the common directory as we plan to reuse `LanguageConsumer`
    in the whole app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Admit that we will not reuse the `LanguageSwitcher` component and place it within
    the layout directory as it is not meant to be used anywhere beyond layout components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we do this, our app structure is again cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e9c3f03-f0dd-4a3b-bddb-6ac07d3a18f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Language directory has been split into LanguageSwitcher and LanguageContext
  prefs: []
  type: TYPE_NORMAL
- en: '`LanguageContext` is now easy to find. Similarly, we do not need to bother
    about the `LanguageSwitcher` implementation until we change the layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The util directory creates a similar confusion, just like the initial language
    directory does. We can safely move it to the `common` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/eb0c5fb6-d2c5-4d95-82e4-d67d08135745.png)'
  prefs: []
  type: TYPE_IMG
- en: The refactored directory structure
  prefs: []
  type: TYPE_NORMAL
- en: Now, any new developer joining the project can quickly get a clear idea of it.
    `screens`, `layout`, `flux`, `features`, and `common` are all very self-explanatory
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you build a big project, relying on the developer's own judgement,
    like in the previous section, may not be enough. The inconsistency of approaches
    taken by different tech leads may quickly escalate and lead to tens of development
    hours being lost on exploring a code jungle.
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds to you like a foreign problem, I can promise that in code bases
    with hundreds of developers working simultaneously every day, it is a very important
    pattern to establish clear guidelines and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linter**: Takes care of the code appearance guidelines and enforces them
    automatically. It may also enforce certain usage patterns and favor certain options
    over others if there is a list of alternatives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux architecture**: The general architecture of how to connect and structure
    JavaScript code to solve common usage patterns. Not enforced automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure reducers**: Reducers need to be as pure as an architectural decision
    of the Redux library. This is not enforced in the classic Flux architecture. This
    may or may not be enforced automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Styles defined in JavaScript**: A solution that comes out of the box with
    React Native.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on. I hope it is enough to convince you that establishing conventions
    is a good thing. It does limit the available capabilities a little, but enables
    you to ship customer value much faster. React Native on its own is a good example
    that connects many different ecosystems to provide a unified way of developing
    mobile applications. It has proven to increase mobile developer's productivity
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'All big software companies approach similar convention problems. Some of them
    are so common that companies invest money into making them open source to make
    a name for themselves. Thanks to this, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: React and React Native from Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript, a typed language on top of ECMAScript from Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: eslint configuration from Airbnb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization library for React from Yahoo!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on JavaScript from Mozilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material design guidelines from Google, and many many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is changing the software world for the better.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you will apply this wisdom to your future projects. Please use it
    to enhance the productivity of your team and organization. If it is overkill right
    now, it is also a good sign that you have spotted that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has addressed the common problems of dependencies in your application.
    As you strive to deliver bulletproof applications, you will find these patterns
    useful in tests. On top of that, you have also learned what a storybook is, that
    is, something that documents use cases for your components. You now can easily
    compose components and storybooks.
  prefs: []
  type: TYPE_NORMAL
- en: Ecosystem also embraces these patterns, and we have used the React Context API
    to pass language context down the component chain. You also had a glimpse into
    the react-redux implementation of `Provider`.
  prefs: []
  type: TYPE_NORMAL
- en: Brace yourself for the last chapter, which introduces types into your applications.
    We will finally ensure that passed variables match consumer function expectations.
    This will enable us to type everything in the application, instead of using just
    `PropTypes` for React views.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directory structure guide by Atlaskit developers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This guideline will teach you about how a big code base can be maintained. It
    is one of the many examples on how to approach the scalability of frontend code
    bases which are maintained by multiple developers every day
  prefs: []
  type: TYPE_NORMAL
- en: ([https://atlaskit.atlassian.com/docs/guides/directory-structure](https://atlaskit.atlassian.com/docs/guides/directory-structure)).
  prefs: []
  type: TYPE_NORMAL
- en: 'How Airbnb Is Using React Native:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tech talk about the Airbnb techstack, which needs to ship to three different
    platforms: the browser, Android, and iOS. Learn about the challenges that developers
    at Airbnb have faced'
  prefs: []
  type: TYPE_NORMAL
- en: ([https://www.youtube.com/watch?v=8qCociUB6aQ](https://www.youtube.com/watch?v=8qCociUB6aQ)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rafael de Oleza - Building JavaScript bundles for React Native:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rafael explains how metro bundler in React Native works.
  prefs: []
  type: TYPE_NORMAL
- en: ([https://www.youtube.com/watch?v=tX2lg59Wm7g](https://www.youtube.com/watch?v=tX2lg59Wm7g)).
  prefs: []
  type: TYPE_NORMAL
