- en: '*Chapter 6*: Enabling Network Connectivity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we installed our system in the first chapter, we enabled the network interface.
    However, network configuration is, or can be, even more than that.
  prefs: []
  type: TYPE_NORMAL
- en: A server connected to a network might require additional interfaces for configuring
    other networks; for example, for reaching backup servers, performing internal
    services from other servers, or even accessing storage that is not presented directly
    via a Storage Array Network (SAN) as local drives but as, for example, **Internet
    Small Computer System Interface** (**iSCSI**) drives.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a server might use redundant network capabilities to ensure that,
    in the event of a failure in one of the cards, switches, and so on, the server
    can still be reached and perform properly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about how to define network configuration for
    our RHEL machine using different methods and perform some basic network troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge will be key since servers are commonly used to provide services
    to other systems, and we need networking for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring network configuration in RHEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config files and NetworkManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring network interfaces with IPv4 and IPv6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring hostname and hostname resolutions (DNS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of firewall configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get hands-on with networking!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can continue using the virtual machine we created at the beginning of this
    book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Installing
    RHEL8*. Additionally, to test network communication, it might be useful to create
    a second virtual machine or reuse the one we created in the previous chapters
    for testing the **Network Time Protocol** (**NTP**) configuration as we will use
    it to check for connectivity. Any additional packages that are required will be
    indicated in the text. Any additional files that are required for this chapter
    can be downloaded from [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring network configuration in RHEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network is made of different devices that have been interconnected so that
    information and resources can be shared among them; for example, internet access,
    printers, files, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Networks have been present since the beginning computing. Initially, the most
    common were non-IP-based ones, which were generally used for sharing data across
    computers in the local network, but with the expansion of internet services and
    the requirement for applications or remote services, IP networks were expanded
    and the concept of intranet was introduced, where the **Transmission Control Protocol/Internet
    Protocol** (**TCP**/**IP**) was used as transport, and the applications started
    to be more like internet services (or even be based on them).
  prefs: []
  type: TYPE_NORMAL
- en: The migration to IP-based networks has also adapted other protocols such as
    **Network Basic Input/Output System** (**NetBIOS**) so that they can run on top
    of it (it was working on top of **NetBIOS Extended User Interface** (**NetBEUI**),
    and even if other networks such as **InfiniBand** or **Remote Direct Memory Access**
    (**RDMA**) are still in use, they are not as common as TCP/IP).
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP, of course, is built on top of other protocols. You can check the OSI
    layer definition at [https://www.redhat.com/sysadmin/osi-model-bean-dip](https://www.redhat.com/sysadmin/osi-model-bean-dip).
    However, some concepts are still involved. We will cover these when we become
    familiar with TCP/IP and networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the actual details, we need to clarify a few common TCP/IP
    and networking keywords we''ll be using from now on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP address**: This is the address that''s used for interacting with other
    devices on the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`255.255.255.0` or `/24`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway**: This the IP address of the device that will get all our traffic
    when the target device is outside our netmask, so that we cannot reach it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DNS**: This is the IP address of a server or servers that translate **domain
    names** into IP addresses so that the hosts can connect to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAC address**: This is the physical interface address. It is unique for each
    card and helps identify the card in the network so that the proper traffic is
    sent to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Interface Card (NIC)**: This card allows our device to connect to
    the network. It might be wireless, wired, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Service Set Identification (ESSID)**: This is how a wireless network
    is named.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Private Network (VPN)**: This is a virtual network that is created
    between the client and the server. Once established, it allows you to direct connection
    to the services as if they were local, even if the client and the server are in
    different places. For example, a VPN network is used to allow remote workers to
    connect to their corporate network using their private internet connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Local Area Network (VLAN)**: This allows us to define virtual networks
    on top of the actual wiring. We can then use a specific header field to have them
    correctly understood and processed by the network equipment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPv6**: This is the replacement protocol for **IPv4**, which is still the
    predominant protocol in networks today.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will use some of these terms when we explain how
    a network is set up and defined in **Red Hat Enterprise Linux** (**RHEL**) systems.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when systems are connected, some relationships between the devices
    on the network are established. Sometimes, some hosts are providers of services,
    often called servers, and the consumers are known as clients. When the systems
    in the network perform roles, these networks are known as **Peer-To-Peer** (**p2p**)
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll become familiar with the configuration files and
    the different approaches for configuring networking in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the configuration files and NetworkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about some of the keywords and concepts of networking,
    it's the time to look at where we can use them to get our system networked.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, network interfaces were configured via text files in the system,
    under the `/etc/sysconfig/network-scripts/` folder. Those scripts were processed
    via the utilities provided via the `network-scripts` package, which took care
    of getting the networking stack up and running with the defined configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although the `network-scripts` package is available and can be installed, it
    is considered to be **deprecated**, which means that the package is provided and
    available but might disappear in future major versions of the operating system,
    so they will only be provided to ease the transition toward the updated methods.
  prefs: []
  type: TYPE_NORMAL
- en: '*NetworkManager* is a utility that was created in 2004 to make network configuration
    and its usage easier for desktop users. At that point, all configuration was done
    via text files and it was more or less static. Once a system was connected to
    a network, the information barely changed at all. With the adoption of wireless
    networks, more flexibility was required to automate and ease the connection to
    different networks via different profiles, VPNs, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: NetworkManager was created to cover those gaps and aimed to be a component that
    would be used in many distributions but from a new standpoint, for example, it
    queries the **Hardware Abstraction Layer** (**HAL**) at startup to learn about
    available network devices and their changes.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a laptop system; it can be connected to a wired cable, disconnected
    when you're moving it to another location or cubicle, can connect to a wireless
    network, and so on. All those events are relayed to NetworkManager, which takes
    care of reconfiguring network interfaces, routes, authenticating with the wireless
    network, and making the user's life a lot easier than it traditionally was.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The hardware that is connected to the system can be queried with several commands,
    depending on how the hardware is connected; for example, via utilities such as
    `lsusb`, `lspci`, or `lshw` (provided by installing the `usbutils`, `pciutils`,
    and `lshw` packages, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the available packages related to NetworkManager,
    as obtained via the `dnf search network manager` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – NetworkManagermanager-related packages available for installation'
  prefs: []
  type: TYPE_NORMAL
- en: in a Red Hat Enterprise Linux 8 system
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – NetworkManagermanager-related packages available for installation
    in a Red Hat Enterprise Linux 8 system
  prefs: []
  type: TYPE_NORMAL
- en: '`NetworkManagermanager` is configured with the files located in the `/etc/NetworkManager`
    folder, especially `NetworkManager.conf` and the files available in that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conf.d`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatcher.d`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dnsmasq-shared.d`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dnsmasq.d`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system-connections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can't remember what a dispatcher is? Remember to use `man networkmanager` to
    get details on this!
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page of NetworkManager explains that those scripts are executed in
    alphabetical order based on network events and will receive two arguments: the
    name of the device for the event and the action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several actions you can perform, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pre-up`: The interface gets connected to a network but is not activated yet.
    The script must be executed before the connection can be notified as activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`up`: The interface has been activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre-down`: The interface is being deactivated but hasn''t been disconnected
    from the network yet. In the case of forced disconnections (lost wireless connection
    or lost carrier), this will not be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down`: The interface has been deactivated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vpn-up`/`vpn-down`/`vpn-pre-up`/`vpn-pre-down`: Similar to the preceding interfaces
    but for VPN connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostname`: Hostname has been changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dhcp4-change`/`dhcp6-change`: The DHCP lease has changed (renewed, rebounded,
    and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connectivity-change`: Connectivity transitions such as no connection, system
    went online, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned a bit about NetworkManager and how it works and was
    designed, let's learn how to configure network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring network interfaces with IPv4 and IPv6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several approaches to configuring network interfaces and several network
    configurations. These will help us determine what we need to do and the required
    parameters and settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A server might have two or more **Network Interface Cards** (**NIC**) for redundancy,
    but only one of them is active at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server might use a trunk network and require that we define VLANs on top for
    accessing or providing the different services in the networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more NICS might be combined to provide increased output and redundancy
    via teaming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration can be performed in several ways, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmtui`: Text-based interface for configuring a network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli`: The command-line interface for NetworkManager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nm-connection-editor`: The graphical tool available for graphical environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via text configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before editing your network configuration, ensure that you can reach the system
    being configured in another way. In the case of a server, this can be done via
    a remote management card or physical console access. A mistake in the configuration
    might leave the system unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's learn a bit about IPv4 and IPv6
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6... what does that mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 was created in 1983 and uses a 32-bit address space, which provides 2³²
    unique addresses (`4,294,967,296`), but from those possible ones, large blocks
    are reserved for special usage. IPv6, ratified as Internet Standard in 2017, is
    the latest version at the time of writing and uses a 128-bit address space instead;
    that is, 2¹²⁸ (3.4 x 10³⁸ addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, the number of IPv4 addresses seemed huge at the time, but
    today, where phones, tablets, computers, laptops, servers, lightbulbs, smart plugs,
    and all of the other **Internet of Things** (**IoT**) devices require an IP address,
    that number has been depleted for public IP addresses, meaning that it's not possible
    to assign more. This has caused some **Internet Service Providers** (**ISP**)
    to use techniques such as **Carrier-Grade Network Address Translation** (**CGNAT**),
    similar to what private networks do, which causes all the traffic from several
    devices to appear as coming from only one IP, and having the device interacting
    on both networks (a router), to do the proper routing from outgoing and incoming
    packages to the original requestors.
  prefs: []
  type: TYPE_NORMAL
- en: Why no IPv6, then? The main problem is that IPv4 and IPv6 are not interoperable,
    and even if IPv6 was a draft in 1998, not all network equipment is compatible
    with it and might not have been yet tested. Check out [https://www.ripe.net/support/training/videos/ipv6/transition-mechanisms](https://www.ripe.net/support/training/videos/ipv6/transition-mechanisms)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about how to configure network interfaces
    using a text-based user interface to NetworkManager named `nmtui`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces with nmtui
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`nmtui` provides a text-based interface for configuration. This is the initial
    screen you''ll see when it is executed by running `nmtui` on a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The nmtui welcome screen showing a menu of possible actions
    that can be performed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – The nmtui welcome screen showing a menu of possible actions that
    can be performed
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the available options for our interface. In this case, let''s
    select **Edit a connection**. On the screen that appears, move down and edit the
    **Wired Connection** option that we have in our system to get to the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The Edit Connection page with the IPv4 options expanded'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – The Edit Connection page with the IPv4 options expanded
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be hard to show screenshots for each step, as one of the advantages
    of the text interface is that we can condense a lot of options into a simple screen.
    However, the preceding screenshot makes it easy to understand each of the required
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netmask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, there are checkboxes for ignoring routes or DNS parameters
    that are obtained when the connection is set to `Automatic`. Additionally, there
    are other options for interfaces: `Disabled`, `Link-Local`, `Manual`, and `Shared`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the `Automatic` option, which means that the interface will be
    set to autoconfiguration. This is one of the most common settings for configuration.
    It does not mean that everything is done magically, though. Let's dig into this
    a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: In a network (corporate, private, and others), it is typical to have a special
    service or server doing **Dynamic Host Routing Protocol** (**DHCP**). DHCP is
    a protocol that runs on top of TCP/IP that allows you to configure hosts dynamically,
    using the configuration that was made previously either by the network administrator
    or some appliance and its default settings.
  prefs: []
  type: TYPE_NORMAL
- en: DHCP allows you to autoconfigure (from the client side) many aspects of network
    configuration, such as IP, netmask, gateway, DNS, search domain, time server,
    and so on. The configuration that's received is given a lease that is valid for
    a period of time. After that, the system attempts to renew it or if the system
    is being powered off or disconnected, the lease is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the DHCP configuration is considered to be tied to dynamic IPs, but
    keep in mind that a DHCP server can use two different approaches: a pool of IPs
    that can be reused by different systems connecting and fixed mappings of MAC addresses
    to static IPs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's, for example, think about a `192.168.1.0/24` subnet.
  prefs: []
  type: TYPE_NORMAL
- en: We can define our ISP router to be at IP `192.168.1.1` because of the subnet
    (`/24`), which means that the last part of the IPv4 address can range from 0 to
    255.
  prefs: []
  type: TYPE_NORMAL
- en: Using that IP range, we can set up hosts to get dynamic configuration and a
    dynamic IP from a pool in the last 100 IPs and leave the ones at the beginning
    for fixed equipment (even if they get the configuration dynamically), such as
    printers, storage devices, and more.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, we can create reservations for servers, but in general,
    for devices that are always going to have the same address, it is also common
    practice to configure static addressing. In this way, if the DHCP server becomes
    unavailable, the servers will be still reachable from other services with either
    a valid lease or other servers/devices with static addresses configured.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Just to get familiar with this concept, IP addresses are represented in IPv4
    with a dotted notation separating four groups of numbers, such as `192.168.2.12`,
    while in IPv6, numbers are separated with `:`; for example, `2001:db8:0:1::c000:207`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces with nm-connection-editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If our system has the graphical environment installed, which is not the case
    for our test system, we can use the graphical configuration tool instead. If it
    is not installed, proceed to execute `dnf install nm-connection-editor` in a shell
    console inside your graphical session.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To install the graphical interface, you can run the `dnf groupinstall "Server
    with GUI" -y` command or select it during installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the window that was opened by executing
    `nm-connection-editor`. It''s similar to the text interface shown by `nmtui` earlier
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 –  Initial screen for nm-connection-editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Initial screen for nm-connection-editor
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the **+**, **-**, and *gear* buttons, which are used to add/remove
    or configure the connection that's highlighted, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click on our **Wired Connection** option and then click on the **gear**
    icon to open the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Dialog for editing a network connection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Dialog for editing a network connection
  prefs: []
  type: TYPE_NORMAL
- en: In the dialog, we can see the fields we had in the simpler command-line configuration
    tool, plus extra fields and different tabs for each group of options.
  prefs: []
  type: TYPE_NORMAL
- en: The important fields to remember are those that are used to **Connect automatically
    with priority** in the **General** tab. This enables our system to automatically
    enable that NIC when a connection is available.
  prefs: []
  type: TYPE_NORMAL
- en: As you can find by examining the different tabs, there are lots of choices,
    such as marking a connection to be metered. This means that, for example, if a
    connection is made via a mobile phone, extra charges may be specified if network
    usage is not controlled.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re creating extra networks, we can define physical or virtual devices
    based on the packages we have installed in our system (if you recall the list
    of packages we saw when searching for NetworkManager, we had packages for different
    VPNs, Wi-Fi, and others), as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – nm-connection-editor with plugins for Wi-Fi, OpenVPN, PPTP,'
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth, and more installed
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – nm-connection-editor with plugins for Wi-Fi, OpenVPN, PPTP, Bluetooth,
    and more installed
  prefs: []
  type: TYPE_NORMAL
- en: For server environments, the most common network types are **Bonds**, **Bridge**,
    and **Team** (a part of **Ethernet**), while for desktops, the most common network
    types are **Ethernet**, **Wi-Fi**, and **Broadband**.
  prefs: []
  type: TYPE_NORMAL
- en: Each type of connection has some requirements. For example, for bonds, bridges,
    and teams, we need more than one network interface that can be combined.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on a review `nmcli` usage in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces with nmcli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`nmcli` is the command-line interface for NetworkManager. It allows us to not
    only check but also configure the network interfaces in our system, and even if
    using it might require more memory skills than what `nmtui` required, it empowers
    users and administrators with scripting capabilities to automate the network setup
    of our system.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Most commands allow us to use autocompletion; that is, pressing the *Tab* key
    will use the autocompletion lists on the command line to suggest the syntax. For
    example, typing `nmcli dev` on the command line and pressing *Tab* will autocomplete
    the command to `nmcli device`. In this case, it might not be as critical as `nmcli`
    takes both arguments as valid, but for others, it's mandatory to spell it properly
    for the code to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start checking the available connections in our system with `nmcli dev`,
    and then use `nmcli con show` to check out its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 –  nmcli dev and nmcli con show'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – nmcli dev and nmcli con show
  prefs: []
  type: TYPE_NORMAL
- en: 'When controlling a network connection, for example, when using `nmcli con up
    "Wired Connection"` or when disabling it with `nmcli con down ens3`, we should
    bear in mind what we explained about NetworkManager: if the connection is available
    in the system, NetworkManager might reactivate it just after being disconnected
    because the connection and the devices required are available in our system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new interface to illustrate the process of adding a new
    connection via IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same with IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the preceding commands have been executed, we can check the network connections
    that have been defined with `nmcli connection show eth0` and validate that the
    proper settings were applied (or, of course, via `nmtui`, `nm-connection-editor`,
    or the text files that were created on disk as the information is shared and stored
    in the system).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we reviewed the output of `nmcli connection show interface`, the output
    contained some keys separated by dots, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ipv4.address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipv4.gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipv6.address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipv6.gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connection.id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use these keys to define new values via `nmcli con mod $key $value`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Example of modifying a network connection to change the name'
  prefs: []
  type: TYPE_NORMAL
- en: of the connection ID and IP address
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Example of modifying a network connection to change the name of
    the connection ID and IP address
  prefs: []
  type: TYPE_NORMAL
- en: Of course, after doing the preceding tests, we can also remove the connection
    to avoid problems in our system with `nmcli con del datacenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands can be used to modify connections with the `nmcli` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmcli con show`: Shows the status of the connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli con show NAME`: Shows the details of the connection named `NAME`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli dev status`: Shows the statuses of the devices in the system. Note that
    this means **devices**, not connections that might be using those devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli con add con-NAME`: Adds a new connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmci con mod NAME`: Modifies a connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli con up NAME`: Brings up a connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli con down NAME`: Brings down a connection (that can still be reenabled
    by NetworkManager).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli con del NAME`: Removes a connection definition from the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Check `man nmcli-examples` to find more examples that are included in the documentation
    for the system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces with text files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In prior subsections, we explored how to configure the network using different
    approaches, but in the end, all those configurations end up being written to disk
    as interface definition files (which also provides backward compatibility with
    the previously mentioned `network-scripts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of starting with creating an interface definition from scratch, let''s
    examine what `nmcli` did when we created the interface with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will generate the `/etc/sysconfig/network-scripts/ifcfg-eth0`
    file, which we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Contents of the /etc/sysconfig/network-scripts/ifcfg-eth0 connection
    definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Contents of the /etc/sysconfig/network-scripts/ifcfg-eth0 connection
    definition
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, by default, we have specified a network interface of the `Ethernet`
    (`TYPE`) type using the `eth0` device, along with the provided values for IPv4
    and IPv6 addressing and gateways. The names of the keys differ from the ones defined
    with `nmcli`, and the reason for this is that we have backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding example, the `ONBOOT` field has already been set
    to `yes`, which means that the interface will be enabled automatically when the
    system is booting. If we're using `nmcli`, we can check the status via the `connection.autoconnect`
    configuration key, which will also, by default, make the connection automatically
    enabled at boot.
  prefs: []
  type: TYPE_NORMAL
- en: We can edit those files directly, but to let NetworkManager be aware of the
    changes that will be introduced, `nmcli con reload` must be executed. This will
    sync the changes that are made to the individual files.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can correct one of the settings in the preceding file because
    for statically defined IPs, it is a common practice to define `BOOTPROTO=none`.
    Use your preferred method to modify the `/etc/sysconfig/network-scripts/ifcfg-eth0`
    file (`vim`, `nano`, `sed`, or others). To get other details we can check with
    `nmcli` and also change the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how, in the following screenshot, the changes don''t appear in `nmcli`
    until we issue the `reload` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The process of editing an interface definition doesn''t show
    up on nmcli until we reload the connections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – The process of editing an interface definition doesn't show up
    on nmcli until we reload the connections
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can also create network definitions from scratch, and until the
    arrival and spread of NetworkManager, this method was used in scripting, including
    Anaconda automated installations via kickstart files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple network definition in IPv4 with the commands show in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Creating a connection using a configuration file (that can
    be part of a script)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Creating a connection using a configuration file (that can be
    part of a script)
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see not only the creation of the connection but the previous status,
    the interface definition, the NetworkManager view of the system, and a comparison
    of the configuration files that were reloaded. Note that the device column is
    empty as we have defined an interface for that connection that is not present
    in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The network interface definition can become a nightmare as the interface name
    itself is subject to several rules, such as the location of the interface in the
    bus, if it was previously seen, and so on. Generally, once the network cards have
    been detected in the system, a custom rule is written that matches the MAC address
    of the interface to a custom naming convention. This happens so that it does not
    change across reboots or if a new software update changes the way we must enumerate
    the cards. You can read more about this topic by looking at the official RHEL8
    manual at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/consistent-network-interface-device-naming_configuring-and-managing-networking](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/consistent-network-interface-device-naming_configuring-and-managing-networking).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed the different ways to configure networking in our
    system, let's learn about naming resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring hostname and hostname resolutions (DNS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remembering IP addresses, whether they are IPv4 or IPv6 addresses, can become
    a nightmare. To make things easier, a more human approach was used for the hostnames
    and the DNS, in that we can translate those easier-to-remember names into the
    IP addresses that systems use for connecting.
  prefs: []
  type: TYPE_NORMAL
- en: Hostnames are the names we assign to a host to have them identified, but when
    they're used in addition to a DNS server, we must have other hosts that can *resolve*
    them into IP addresses they can connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `hostname` command to see or to temporarily modify the current
    hostname, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Querying and changing the hostname for our host'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Querying and changing the hostname for our host
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that this change is only temporary; as long as we restart the server,
    it will use the configured one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a new configured hostname, we will use the `hostnamectl set-hostname`
    command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Checking the previously configured hostname and the definition'
  prefs: []
  type: TYPE_NORMAL
- en: of a new one via hostnamectl
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Checking the previously configured hostname and the definition
    of a new one via hostnamectl
  prefs: []
  type: TYPE_NORMAL
- en: Note in the preceding example how we have `Transient hostname` versus `Static
    hostname`, which refers to the temporary status of the name that was defined with
    `hostname` instead of `hostnamectl`.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to name resolution, there are several approaches we can take.
    One, of course, is to use DNS servers, which we will explain later in this section,
    but there are other ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, systems have several resolvers, and those are defined in the `/etc/nsswitch.conf`
    configuration file. Those resolvers are not only for network naming, but, for
    example, for resolving users, where, for example, a corporate `nsswitch.conf`
    instructs our system to use, for hosts resolving this entry: `hosts: files dns
    myhostname`.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we are using the files in our `/etc/` directory as our first
    source. In the case of hostnames, this refers to the `/etc/hosts` file. If an
    entry is defined in that file, the value that was specified will be used; if not,
    the `/etc/resolv.conf` file will determine how to proceed with its resolution.
    Those files, and especially `resolv.conf`, are configured when the system is deployed
    and when a connection is activated. NetworkManager takes care of updating the
    values that were obtained via DHCP if autoconfiguration was used, or the specified
    DNS servers if manual configuration was performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the entries that have been defined
    in our `/etc/hosts` file, how pinging a host fails because the name does not exist,
    and how, after manually adding an entry to the `/etc/hosts` file, our system is
    able to reach it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Adding a static host entry to our local system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Adding a static host entry to our local system
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, DNS resolution is done via the configuration at
    `/etc/resolv.conf`, which, by default, contains a `search` parameter and a `nameserver`
    parameter. If we check the man page of `resolv.conf`, we can obtain descriptions
    for the common parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nameserver`: Contains the IP of the nameserver to use. Currently, only a maximum
    of three entries (each on its own line) will be used by the `resolv` library in
    the system. The resolution is performed in order each time, so if one server fails,
    it will time out, try with the next one, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`: The local domain name. It allows us to use short names to hosts that
    are relative to the local domain in our host. If it''s not listed, it''s calculated
    based on the hostname of our system (everything after the first "`.`").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`: By default, this contains the local domain name, and it''s the list
    of domains we can attempt to use to resolve the short name that''s provided. It''s
    limited to 6 domains and 256 characters. Domain and search are mutually exclusive,
    since the last one in the file is the one to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: DNS resolution works by asking special servers (DNS) for the relevant data for
    a domain. This happens in a hierarchical way, with the top-most general servers
    being called **root servers**. DNS servers contain not only registers or entries
    for converting hostnames into IPs, but also information about the mail server
    to use when sending an email, verification details for security, reverse entries,
    and more. Also, DNS servers can be used to block access to services by returning
    invalid IPs for some domains, or to speed up internet navigation by using faster
    DNS servers than the ones provided by the ISP. When a domain name is registered,
    a new entry is created in the root tables for the domain pointing to the DNS server.
    This will take care of that domain resolution, and later, those entries will be
    populated and cached across the internet for faster resolution.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to modify the DNS servers defined for a connection, remember to use
    `nmcli con mod NAME ipv4.dns IP` (or IPv6 equivalent) and use a `+` symbol beforehand,
    as in `+ipv4.dns`, to add a new entry to the list of DNS servers. Any manual changes
    that are to `resolv.conf` might be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about how DNS works and how our system uses it, let's
    look at how to secure system network access.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of firewall configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a system is connected to a network, many of the services running can be
    reached from other systems. That is the goal behind having systems connected.
    However, we also want to keep systems secure and away from unauthorized usage.
  prefs: []
  type: TYPE_NORMAL
- en: A **firewall** is a software layer that sits between the network cards and the
    services and allows us to fine-tune what is allowed or not.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot completely block all the incoming connections to our system as often,
    the incoming connection is a response from a request that our system made.
  prefs: []
  type: TYPE_NORMAL
- en: The connections are blocked via a kernel framework named `iptables`, `ip6tables`,
    `ebtables`, and `arptables`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As we explained earlier in regard to network configuration, a bad configuration
    in a firewall can lock you out of the system, so be extremely careful when you're
    setting some restrictive rules so that you can log into the system again if you
    are remotely accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` package, which should be included in a base installation. It will
    provide the `firewall-cmd` command once installed for interacting with the service.'
  prefs: []
  type: TYPE_NORMAL
- en: firewalld uses the concept of zones, which allows us to predefine a set of rules
    for each of those zones. These can also be assigned to network connections. This
    is more relevant, for example, for laptops that might be roaming across connections,
    and they might have some default settings for when you're using home or corporate
    connections. However, they will default to a more secure one when you're using
    Wi-Fi from a cafeteria.
  prefs: []
  type: TYPE_NORMAL
- en: firewalld also uses predefined services so that the firewall knows what ports
    and protocols should enable based on the services and zones they have been enabled
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the available zones and some more details about the home zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Available zones and configuration for the zone home'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Available zones and configuration for the zone home
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, several zones have been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: This is the default zone for newly added interfaces. It allows us
    to cockpit SSH and DHCP clients and rejects all incoming traffic not related to
    the outgoing traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block`: Rejects all incoming traffic unless it''s related to outgoing traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmz`: Rejects all incoming traffic unless it''s related to outgoing or SSH
    connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop`: Drops all incoming packets that are not related to outgoing ones (not
    even ping).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external`: Blocks all incoming traffic except that related to outgoing traffic.
    It also allows SSH and it masquerades traffic as originating from this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home`: In addition to public, its allows `smb` and `mdns`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal`: Based on the home zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trusted`: Allows all incoming traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`work`: Blocks all incoming traffic except that related to outgoing or SSH/cockpit/DHCP
    traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll learn how to use those zones when we're configuring the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the firewall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in the introduction to this section, a firewall can be configured
    via the `firewall-cmd` command (as well as the cockpit web interface, which was
    described earlier in this book on [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059),
    *Tools for Regular Operations*). The most common command options that are used
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firewall-cmd --get-zones`: Lists the available zones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --get-active-zones`: List the active zones and interfaces that
    have been assigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --list-all`: Dumps the current configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --add-service`: Adds a service to the current zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --add-port`: Adds a port/protocol to the current zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --remove-service`: Removes the service from the current zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --remove-port`: Removes the port/protocol from the current zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you need to mention the port number and service name after the preceding
    commands to add or remove a service/port.
  prefs: []
  type: TYPE_NORMAL
- en: '`firewall-cmd --reload`: Reloads the configuration from the saved data, thus
    discarding the runtime configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd –get-default-zone`: Gets the default zone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-cmd --set-default-zone`: Defines the default zone to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, when we install an HTTP server in our system (for serving web pages),
    port `80` on TCP must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this in our sample system by installing, running, and opening the
    HTTP port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last command will make a petition to the local `http` server to grab the
    results. If you have access to an additional system, you can try to connect to
    the IP of the server that we have been using to watch the default web page be
    served by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the output of the `curl localhost`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Output of curl when requesting the web page hosted by our system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Output of curl when requesting the web page hosted by our system
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have reviewed how to configure some basic firewall rules,
    so we are ready to check the network's connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Testing network connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we were interacting with network interfaces, addresses,
    and firewall rules that define, limit, or allow connections to our system. In
    this section, we will review some of the basic tools that can be used to validate
    that network connectivity exists.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the following commands assume that the firewall is not set to strict
    mode and that we can use the **Internet Control Message Protocol** (**ICMP**)
    to reach the servers hosting the service. In secured networks, the service might
    be working but not answering to ping – it may only be answering the service queries
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several commands that we can use here, so consider these suggestions
    for diagnosing issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the local interface's IP address, netmask, and gateway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ping` command with the IP address of the gateway to validate the proper
    network configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ping` command to ping the DNS servers in `/etc/resolv.conf` to see
    if those are reachable. Alternatively, use the `host` or `dig` command to query
    the DNS servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's supposedly external network connectivity, try to reach external DNS
    servers such as `8.8.8.8` or `1.1.1.1` or use `curl` or `wget` to request some
    of the web pages of known services; for example, `curl nasa.gov`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should give you a rough idea of where a problem might be, based on how
    far you reach into the tests. Remember that there are other tools, such as `tracepath`,
    that will show the hops a TCP packet does before reaching the destination. The
    man pages for each command will give you hints and examples on their usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the output of `tracepath` against
    one web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The output of the tracepath command against the University
    of Valencia, Spain web server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – The output of the tracepath command against the University of
    Valencia, Spain web server
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there were 11 steps that were performed across different servers
    until our data package reached the destination host. This allowed us to learn
    about how a package traverses the internet to reach target systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about configuring network interfaces using different
    approaches, either via manual interaction or via methods that allow us to script
    or automate the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Some troubleshooting for network issues was also introduced to help us find
    some of the basic errors that might occur.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in this chapter's introduction, networking is the basis for
    our system to reach other services and to provide services to other systems. We
    also introduced the idea of more complex network setups that fall outside the
    scope of this RHCSA level, but it's interesting to at least be familiar with the
    keywords that we'll be using in our career.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover some important topics related to security
    such as adding, patching, and managing the software in our systems.
  prefs: []
  type: TYPE_NORMAL
