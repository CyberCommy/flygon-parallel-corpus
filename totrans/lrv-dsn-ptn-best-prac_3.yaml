- en: Chapter 3. Views in MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss what the View is, its structure, its purpose,
    and the advantages of Laravel's View layer and Blade template engine.
  prefs: []
  type: TYPE_NORMAL
- en: What is a View?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The View in Laravel refers to the V in MVC. The View consists of presentation
    logic aspects such as templates and caching and the code that involves presentation.
    Precisely, the View defines exactly what is presented to the user. Usually, Controllers
    pass data to each View to render in some format. Views collect data from users
    as well. This is where you're likely to find HTML markup in your MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern MVCs, such as Laravel Framework, implement a template language that
    adds a further layer of abstraction from PHP. Added layers mean added overhead.
    Here, we stick with the speed of PHP within the template, yet all the logic stays
    outside. This makes it easy for User Interface (UI) designers to develop themes/templates
    without the need to learn any programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many MVC implementations, the View layer speaks with Controllers and Models.
    The approach is well explained in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a View?](Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, the View communicates with both the
    Controller and the Model. At first sight, it seems like a very flexible approach
    to develop an application with OOP languages. Sharing data between all objects
    of MVC and accessing them in any layer of application sounds very cool. Unfortunately,
    the method causes some problems that depend on the project's size.
  prefs: []
  type: TYPE_NORMAL
- en: The foremost problems are the complexity of allocating development tasks between
    teams/developers. If you don't set the development rules, it will lead to chaotic
    situations such as unmanageable spaghetti code. Also, we have to consider extra
    costs of development such as training the developers and comparatively long development
    processes, which directly affect the cost of the project.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the book, development not only involves
    coding or sharing tasks, it's also the process that includes the planning and
    marketing of the project development method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel ships a different kind of approach to MVC. According to Laravel, the
    View layer should only communicate with the Controller. The Model communicates
    with the Controller. Let''s look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a View?](Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding figure, the layers of application are completely
    separated. Thus, you can get easily manageable code and a development team. Generally,
    we need at least three files in MVCs: the Model file, the Controller file, and
    the View file. Let''s explain the View file through its objects.'
  prefs: []
  type: TYPE_NORMAL
- en: View objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your application, there is usually more than one HTML page that contains
    forms, asset references, and so on; for example, if you are developing an e-commerce
    application. In a simple e-commerce system, there are product lists, categories,
    carts, and product detail pages that we need. This means that we need four templates
    and too much data to present to our users. We can group the objects of the View
    layer as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML elements (div, header, section, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML form elements (input, select, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset and JavaScript references (`.css` and `.js` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you work on a project that has dynamic data, separating the template files
    does not help simplify the problem because you still need programming language
    functions to process objects. This causes what we don''t want to face—spaghetti
    code. When a project has inline PHP code in HTML documents, you will face problems
    in keeping the code simple. Let''s take a look at the generic template file contents
    that are not implemented with any template language in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As a UI developer, you need prior knowledge of the PHP language (at least knowledge
    of the syntax of the language) to understand the code you see. As we mentioned
    in [Chapter 1](text00015.html#page "Chapter 1. Design and Architectural Pattern
    Fundamentals") , *Design and Architectural Pattern Fundamentals* , most modern
    MVC frameworks come with a template language bundled to be used in Views. Laravel
    ships an implemented template language to be used with Views; this is called the
    Blade template engine, or simply Blade.
  prefs: []
  type: TYPE_NORMAL
- en: View in Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Laravel''s MVC approach, the View handles data from the Controller.
    This means that the View gets the data that is usually already formatted as we
    need. If the View directly communicates with the Model, we have to format, validate,
    or filter the data at the View layer, as seen in the previous example code. So,
    let''s see what a Blade template file looks like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is neither PHP syntax nor any unclosed brackets problems. So, we have
    a cleaner template file. Thanks to Blade''s built-in features, we can get clearer
    View files. Generally, the header and footer sections are common to all pages
    in our applications. There are two ways to add them. The first and unrecommended
    way is to separate the header, footer, and body sections in three files, similar
    to something shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This way is not recommended because it requires each page to include both the
    header and the footer. This also means that if we add a right or left column,
    we will need to change all the Views of our application. The best way to implement
    this in Blade is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file is our layout View, for example, `master_layout.blade.php`
    . As you can see, there is a function for the content that is using the `yield()`
    function. This is a placeholder; therefore, when any View file extends this file,
    the section named `content` will be shown instead of the `yield()` function. You
    can define as many sections in your master layout as you need. So, when we want
    to use this layout in a View file, we should use it as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You can extend the master layout in as many Views as you need, and
    you can create multiple layouts as your application requires.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the role of Views in the MVC pattern, and what Laravel's
    approach to Views is. We saw the basics of the Blade template engine functions.
    For more information, please refer to Laravel's online documentation at [http://laravel.com/](http://laravel.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the role of the Controller, the maestro in
    the MVC philosophy of Laravel.
  prefs: []
  type: TYPE_NORMAL
