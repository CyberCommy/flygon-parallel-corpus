- en: Deploying on the AWS Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw one of the platforms for our application, which
    is called Docker. It can isolate your application, and can be used to respond
    to your application request from the customer. During the course of this chapter,
    we will introduce you to the cloud platform, especially AWS (Amazon Cloud Services),
    which mainly deals with the IaaS (Infrastructure) and **PaaS** (**Platform as
    a Service**) Services. We will also look at how we can build up infrastructure,
    and deploy our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AWS and its services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building application infrastructure using Terraform/CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Deployment** using Jenkins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Amazon Web Services (AWS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) is a secure cloud platform. It has various
    offerings in IaaS as well as PaaS, including computing power, database storage,
    and content delivery, which help in scaling applications, and also grows our business
    across the globe. AWS is a public cloud, and as per the cloud computing concepts,
    it provides all its resources in an on-demand delivery with a pay-as-you-go plan.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about AWS and its services at [https://aws.amazon.com/](https://aws.amazon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As specified previously in [Chapter 1](part0023.html#LTSU0-4022ecb0f8ea4b719ffb742bf2a6a072),
    *Introducing Cloud Native Architecture and Microservices*, you need to create
    an AWS account to start using the services. You can use the following link to
    create an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/appliedcode/setup-aws-account-1727ce89353e](https://medium.com/appliedcode/setup-aws-account-1727ce89353e)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are logged in, you will see the following screen, which showcases
    the AWS and its categories. A few of the services are in the beta stage. We will
    be using some of the services related to **compute** and **networking** to build
    an infrastructure for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the commonly used AWS services for applications are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EC2 (Elastic compute cloud)**: This is a compute offering from AWS, which,
    in simply put, offers a server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECS (Elastic Container Services)**: This is similar to the Docker services
    on top of a public cloud, that is, Amazon. It manages Docker on top of an EC2
    machine only. Instead of creating a Docker cluster on-premises, you can easily
    set it up in the Amazon cloud within a few minutes, and with less overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EBS (Elasticbeanstalk)**: This is a PaaS offering where you just need to
    upload your code, and specify how much infrastructure (basically, app server (EC2))
    is required. EBS will take care of creating the machines, and deploy the code
    on it as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S3 (Simple storage service)**: This is a storage service offered by AWS where
    we usually keep our application data or static content, which could be used for
    static website hosting. We will be using it for Continuous Deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glacier**: This is another storage service, which is mainly used for backup,
    as it is less costly, and hence, has a slow data storing and retrieving capability
    as compared to S3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VPC (Virtual Private Network)**: This is a networking service which gives
    you control over your resources'' accessibility. We will be using this service
    to keep our infrastructure. This service is very useful for securing our application
    service and database services, and exposes only selective resources, which are
    required, to the outside world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFront**: This is a content delivery service which distributes your content
    in S3 across the globe, and makes sure it is quickly retrievable irrespective
    of the location of the request source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation**: This gives developers and system administrators an easy
    way to create and manage a collection of related AWS resources, such as provisioning,
    and updating them in the form of code. We will be using this service to build
    our infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudWatch**: This service keeps track of the activity of your resources.
    It also keeps track of any activity on your AWS account in the form of logs, which
    is useful for identifying any suspicious activity or account compromise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IAM (Identity and Access Management)**: This service, as the name suggests,
    is very useful for managing users on the AWS account, and to provide them roles/privileges
    as per their usage and requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route 53**: This is a highly available and scalable cloud DNS Cloud service.
    We can either migrate our Domain from any other Registrar such as GoDaddy, and
    others to Route 53, or purchase the Domain AWS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more services offered by AWS that can't be covered in this chapter.
    If you are interested and would like to explore other services, you can go through
    the AWS product list ([https://aws.amazon.com/products/](https://aws.amazon.com/products/)).
  prefs: []
  type: TYPE_NORMAL
- en: We will be using most of the aforementioned AWS services. Let's begin by building
    our infrastructure on AWS as per our application.
  prefs: []
  type: TYPE_NORMAL
- en: Building application infrastructure on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage of our application, the system architect or a DevOps guy comes
    into the picture, and suggests different infrastructure plans which are secure
    and efficient enough to handle application requests, and are cost effective as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as our application is concerned, we will build its infrastructure the
    same as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will follow the preceding architecture diagram for our application, which
    includes a few of AWS services such as EC2, VPC, Route 53, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different ways by which you can provision your resources on
    the AWS cloud, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Management console**: This is the user interface which we have already logged
    into, and can be used to launch resources on the cloud. (Check this link for your
    reference: [https://console.aws.amazon.com/console/](https://console.aws.amazon.com/console/home?region=us-east-1))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmatically**: We may use a couple of programming languages such as
    Python, Ruby, and the like to create resources, for which different development
    tools have been created by AWS, like Codecom. Also, you can use SDK to create
    your resources based on your preferred choice of language. You can check [https://aws.amazon.com/tools/](https://aws.amazon.com/tools/)
    for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CLI (Command-line interface)**: It is an open source tool built on top
    of SDK for Python which offers commands to interact with the AWS resources. You
    can check the link at: [http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html)
    to understand its working, and the steps to set this up on your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating resources is pretty easy and straightforward, so we won't be covering
    that, but you can check the AWS documentation ([https://aws.amazon.com/documentation/](https://aws.amazon.com/documentation/))
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: I will show you how to build your infrastructure using Terraform and an AWS-based
    service called CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: Generating authentication keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is an important feature for any product or platform to check
    the authenticity of a user who is trying to access and perform operations on the
    product, and also to keep the system secure. Since here we are going to access
    the AWS account using APIs, we need authorization keys to validate our request.
    Now, an important AWS service enters the picture called **IAM** (**Identity and
    Access Management**).
  prefs: []
  type: TYPE_NORMAL
- en: In IAM, we define the  users and generate access/secret keys, and also assign
    roles based on the resources which we want to access using it.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended NEVER to generate access/secrets keys as the root user,
    because it will have, by default, full access over your account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to create a user, and to generate access/secret
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://console.aws.amazon.com/iam/home?region=us-east-1#/home](https://console.aws.amazon.com/iam/home?region=us-east-1#/home);
    you should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the third option, named Users, in the left pane. If your account
    is new, you will see no users. Now, let''s create a new user--for that, click
    on the Add user button in the right pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the Add user button, a new page will load and ask for the
    username and the way you want your user to access the account. If you are going
    to use this user, for example, `manish`, only for programmatic purposes, in that
    case, I recommend that you uncheck the AWS Management Console access box so that
    the user doesn''t need to log in using the AWS management console. Check the following
    screenshot for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are done, click on the Next: Permissions button on the bottom-right
    side of the screen. Next, you need to select the permission you want to give to
    this user, which we call the IAM Policies. That means now, the user should be
    able to access the resources as per the policy defined, and also the kind of operations
    allowed for the user on the resources. For now, we add the Power User Access policy
    to this user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Internally, Power User Access will have a policy in the JSON format, something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information about the IAM policy, read the documentation at the following
    link: [http://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Readers who have been using Microsoft Active Directory can integrate AD with
    IAM easily using the AD connector. For more info, read the article given at this
    link: [https://aws.amazon.com/blogs/security/how-to-connect-your-on-premises-active-directory-to-aws-using-ad-connector/](https://aws.amazon.com/blogs/security/how-to-connect-your-on-premises-active-directory-to-aws-using-ad-connector/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have added the policies to the user, click on the Next: Review button
    on the bottom-right side of the screen to move forward.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next screen will ask you to review it, and once you are sure, you can click
    on the Create user button to create the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the Create user button, the user will be created, and the
    policy will be attached to it. You will now see the following screen which has
    auto-generated the access key as well as the secret key, which you need to keep
    safe and NEVER ever share with anyone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our access/secret key has been generated, it''s time to build our
    application infrastructure on AWS. We will use the following tools to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Terraform**: This is an open-source tool for building infrastructure on different
    cloud platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation**: These are AWS services to build application infrastructure
    using the AWS resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform - a tool to build infrastructure as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is a tool for building, managing, and versioning infrastructure over
    different cloud platforms such as AWS, Azure, and so on. It can manage the low-level
    components of the infrastructure such as compute, storage, networking, and others.
  prefs: []
  type: TYPE_NORMAL
- en: In Terraform, we specify the configuration files which describe the resources
    specification for the infrastructure of the application. Terraform describes the
    execution plan, and the desired state to be achieved. Then it starts building
    the resources as per specification, and keeps track of the current state of infrastructure
    after build up, always performing incremental execution if the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few features of Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform describes your data center onto a blueprint, which can be versioned
    and can be managed into code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform provides you the execution plan before actual implementation, which
    helps you to match the execution plan with the desired result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform helps you architect all your resources and parallelize your resources
    creation. It gives you an insight into the dependencies on the resources, and
    also makes sure that the dependencies are fulfilled before resources creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With its insight capability, it gives more control to the developer over the
    revisions to be performed over the infrastructure with less human errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Terraform, we consider every service in AWS in terms of the resources which
    need to be created, so we need to provide its mandatory attributes for its creation.
    Now, let''s begin by creating the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to create **VPC** (**Virtual Private Cloud**) in which we will
    launch all the other resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: We will need to create all the files with the `.tf` file extension as
    per convention.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create an empty `main.tf` file. Add the following code, which will
    set the access and secret key of the service provider for authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, there is a value like `${var.aws_region}`.
    Actually, it is a convention to keep all your values in a separate file called
    `variables.tf`, so we do this here. Let''s change the `variables.tf` file with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the VPC resource, so let''s add this code to `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used one variable, which needs to be defined in `variables.tf` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the VPC resource is defined, we need to create a subnet which will be
    associated with the EC2 machine, Elastic Load Balancer, or other resources. So,
    add the following code to `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since we want our resources to be accessible from the internet, we need to create
    an internet gateway, and associate it with our subnet so that the resources created
    inside it are accessible over the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: We can create multiple subnets to secure the network of our resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make sure that the subnet where you will be launching your
    EC2 machine provides a public address to the machines. This can be achieved by
    adding the code given next to your `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once this is configured, it's time to begin with the creation of the app server
    and the MongoDB server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially, we need to create the dependent resources, such as the security group,
    without which, EC2 cannot be launched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `main.tf` to create the security group resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this security group, we open ports `22` and `5000` only in order to ssh and
    access our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add/create ssh key-pairs, which you can generate on your local
    machine and upload to AWS, or can get it generated from the AWS console as well.
    In our case, I have generated an ssh key on my local machine using the `ssh-keygen`
    command. Now to create an ssh-key pairs resource in AWS, add this code to `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet to `variables.tf` to provide parameters to the
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created dependent resources, it''s time to create the app
    server (that is, EC2 machine). So, add the following code snippet to `main.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a couple of variables in the EC2 configuration as well, so we
    need to add the variable values in the `variables.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now our app server resource configuration is ready. Now, we have added
    the app server configuration, and next, we need to add a similar setting for the
    MongoDB server, which is needed for keeping our data. Once both are ready, we
    will create ELB (which will be the user's point of application access), and then
    attach the app servers to ELB.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to add the configuration for the MongoDB server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the MongoDB server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add following code to `main.tf` for the creation of a security group for the
    MongoDB server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the configuration for the MongoDB server. Also notice
    that in the following configuration, we provision the server with the MongoDB
    installation at the time of creation of the EC2 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One last resource which still needs to be configured is the Elastic Load Balancer,
    which will balance the customer requests to provide high availability.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Elastic Load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we need to create a security group resource for our ELB by adding
    this code to `main.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the following configuration for creating the ELB resources,
    and to add the app server into it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are all set for our first run of the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our infrastructure configuration is ready to be deployed. It is a good practice
    to use the following command to understand the execution plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the last command should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t see any errors, you can execute the following command for actual
    creation of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Currently, we don''t have the domain registered with us, but if we have the
    domain name registered and configured in Route 53, we need to create an additional
    resource in `main.tf` to add an entry for our application. We can do so by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need to do. Also, another quick, and the most crucial, way of
    making your infrastructure high available is to create an auto scaling service,
    based on server metric usage (CPU or memory). We provide conditions which decides
    whether we need to scale our infrastructure up or down  so that our application
    performance should see less latency.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so , you can check the Terraform documentation at [https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html](https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html).
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our application is not deployed, we will be using the Code Deploy
    service to deploy our application using continuous delivery which we will discuss
    in a later part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, let's see how we can create the same setup using a Cloud Platform
    Service called **CloudFormation**, provided by AWS.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation - an AWS tool for building infrastructure using code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFormation is an AWS service, which works in a similar fashion to Terraform.
    However, in CloudFormation, we don't need the access/secret keys. Instead, we
    need to create an IAM role, which will have the required access to launch all
    the resources  needed to architect our application.
  prefs: []
  type: TYPE_NORMAL
- en: You can write your CloudFormation configuration using the YAML or JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin our infrastructure setup using CloudFormation by building the VPC,
    where we will create a VPC with, a public and a private subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `vpc.template`, with the VPC and subnet''s (public
    and private) configurations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration is written in the JSON format to give you an understanding
    of the JSON configuration. Also, we need to specify the configuration for routing
    the table and internet gateway as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the configuration available, it's time to create a stack for
    the VPC from the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: The VPC stack on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a stack for the VPC from the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new) to
    create a new stack using CloudFormation. You should see a screen as shown in this
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Provide the path for your template file, and click on the Next button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next window, we need to specify Stack name, which is the unique identifier
    for our stack, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Provide the stack name, and click on Next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screen is optional; in case we want to set up **SNS** (**Notification
    service**), or add IAM roles for it, we need to add it here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to enable Notifications and the IAM role, add the details, and click
    on Next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screen is for reviewing the details, and to make sure they are correct
    for creating the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once ready, click on Create to initiate the stack creation. At the time of creation,
    you can check the events to know the status of your resource's creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a screen similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, you will be able to see the progress of the stack,
    and in case some errors occur, you can identify them using these events.
  prefs: []
  type: TYPE_NORMAL
- en: Once our VPC stack is ready, we need to create the EC2, ELB, and autoscaling
    resources in our VPC. We will use the YAML format to give you an overview of how
    to write the configuration in the YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code at `<path of repository>`. We will use the `main.yml`
    file, which has the details about the VPC and the subnet where you need to launch
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to launch the stack, go to the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be one change in the launch configuration--instead of specifying
    values in the file, we will specify it in the AWS console at the time of providing
    the details as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Refer to the following screenshot to provide the instance details in which
    you want to deploy your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have provided all the details in the preceding screen, scroll down
    to the next section, where it will ask for the ELB details, as shown in the next
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The remaining steps remain the same for creating the AWS CloudFormation stack.
    In order to add the MongoDB server, we need to add the configuration for the EC2
    machine in `main.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the configuration in AWS CloudFormation is straightforward, as AWS
    provides a couple of templates which we use as a reference to create our template.
    The following is the link for the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: "[https://aws.amazon.com/cloudformation/aws-cloudformation-templates/\uFEFF\
    ](https://aws.amazon.com/cloudformation/aws-cloudformation-templates/)"
  prefs: []
  type: TYPE_NORMAL
- en: That's all we have for building the infrastructure; it's time for our application
    to be deployed on the app servers.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment for a cloud native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we successfully set up the infrastructure, but we
    are yet to deploy the application. Also, we need to make sure that further deployment
    should be taken care of using Continuous Deployment. Since we have our development
    environment in our local machine, we don''t need to set up the continuous integration
    cycle. However, for large-scale companies where many developers work collaboratively,
    we need to set up a separate pipeline for Continuous Integration using Jenkins.
    In our case, we only need Continuous Deployment. Our Continuous Deployment pipeline
    would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It starts with the developer pushing new code to the main branch of its version
    control system (in our case, it's GitHub). As soon as the new code is pushed,
    the Jenkins **GitHub plugin** detects the change as per its defined job, and triggers
    the **Jenkins job** to deploy the new code to its infrastructure. Jenkins then
    communicates with **Code Deploy** to trigger the code to the Amazon EC2 machine.
    Since we need to make sure that our deployment is successful, we can set up a
    notification section, which will notify us of the status of deployment so that
    it can reverted back if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the Continuous Deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first configure our AWS service beginning with Code Deploy, which will
    help us to deploy the application on the available app servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, when you switch to the code deploy service ([https://us-west-1.console.aws.amazon.com/codedeploy/](https://us-west-1.console.aws.amazon.com/codedeploy/)),
    you should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is the introduction page for Code Deploy, which showcases
    its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Get Started Now button in the middle of the page to move forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you should see the following screen, which will recommend you to deploy
    a sample application, which is fine for the initial stage. But since we have already
    built up our infrastructure, in that case, we need to select Custom Deployment--
    this will skip the walkthrough. So, select the option, and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Skip Walkthrough to move forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next wizard screen, there are a couple of sections which need to be reviewed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first section will ask you to Create application--you need to provide a
    user-defined Application name and Deployment group name, which is mandatory, as
    it becomes the identifier for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Scroll down to the next section, which talks about the type of deployment you
    want for your application. There are two methods, which are defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blue/green deployment**: In this type, during deployment, new instances are
    launched and new code is deployed to it, and if its health check is fine, it is
    replaced with the old one, and old instances are then terminated. This is recommended
    for the production environment, where customers can''t afford downtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-place deployment**: In this deployment type, new code is deployed directly
    into the existing instances. In this deployment, each instance is taken offline
    for updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go with **In-place deployment**, but the choice changes with the use
    case and product owner's decision. Say, for example, applications like Uber or
    Facebook, which can't afford a downtime at the time of deployment, will go for
    the Blue/green deployment, which will give them high availability.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move on to the next section, which talks about the infrastructure where
    the application is going to be deployed. We will specify the instances and ELB
    details as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next segment, we will define the way to deploy the application. For
    example, suppose you have 10 instances. You may want to deploy the application
    on all these instances at one time, or one at a time, or half at a time. We will
    go with the default option, that is, `CodeDeployDefault.OneAtATime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we also need to specify a Service role, which is needed by
    Code Deploy to perform operations on your AWS resources, more specifically, on
    EC2 and ELB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand more about service role creation, go to the AWS documentation
    at this link: [http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have provided the required information, click on Create Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following screen once your application is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are all set for deployment. All we need to create is a job in Jenkins,
    and add a post-built section with the CodeDeploy details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of a job is similar to what we explained in the previous chapter.
    The following few changes are needed though:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to make sure we have installed a few Jenkins plugins, namely,
    AWS CodeDeploy Plugin for Jenkins, Git plugin, GitHub plugin, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have installed the plugins, you should see new actions in the post-build
    actions list, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you need to select the Deploy an application to AWS CodeDeploy action.
    A new section will be added, and we need to provide the details of the CodeDeploy
    application we created in the AWS console, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We also need to provide access/secret keys which we created at the beginning
    of this chapter in the section, *Generating authentication keys*. This is needed,
    as Jenkins, after packaging the application, needs to upload it to S3 and instruct
    CodeDeploy to deploy the latest build from the specified bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all we need to do. Now our Jenkins job is ready to deploy the application.
    Try it out, and it should work as smooth as butter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is very interesting in various ways. Firstly, you got the basic
    understanding about AWS services, and how to make the most out of them. Next,
    we explored the architecture of our application on the AWS cloud, which will shape
    your views on architecture designing for different application/products that you
    might plan to create in the future. We also made use of Terraform, which is a
    third-party tool used to build infrastructure on AWS as code. Finally, we deployed
    our application, and created a continuous pipeline for deployment using Jenkins.
    In the next chapter, we will explore another cloud platform owned by Microsoft--Microsoft
    Azure. Stay alive, and get ready to explore Azure in the coming chapter. See you
    there!
  prefs: []
  type: TYPE_NORMAL
