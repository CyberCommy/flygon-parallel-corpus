- en: '*Chapter 4*: Implementing Quaternions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about quaternions. Quaternions are used to encode
    rotations. A quaternion is a complex number in an *x*i *+ y*j *+ z*k *+ w* form.
    Think of *i,* *j*,
  prefs: []
  type: TYPE_NORMAL
- en: and *k* as placeholders that each represent a three-dimensional axis. *w* is
    a real number. While quaternions don't directly encode an angle axis pair, it's
    easy to think of them
  prefs: []
  type: TYPE_NORMAL
- en: as just that—a rotation about an arbitrary axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should have a strong understanding of what
    quaternions are and how to use them and you will have implemented a robust quaternion
    class in code. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Different methods for creating quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the angle and axis of a quaternion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic component-wise operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length and dot product of two quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverting quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming vectors by quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating between quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting quaternions and matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are quaternions important? Most humanoid animations are created using only
    rotations—no translation or scale is needed. Think about an elbow joint, for example.
    The natural motion of an elbow only rotates. If you want to translate the elbow
    through space, you rotate the shoulder. Quaternions encode rotations and they
    interpolate well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important information:'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement quaternions with an intuitive, code-first
    approach. If you are interested in the more formal math behind quaternions, check
    out [https://gabormakesgames.com/quaternions.html](https://gabormakesgames.com/quaternions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quaternions are used to encode rotation data. In code, quaternions will have
    four components. They resemble `vec4` in that they have an `x`, `y`, `z`, and
    `w` component.
  prefs: []
  type: TYPE_NORMAL
- en: As with `vec4`, the `w` component comes last.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quat` structure should have two constructors. The default constructor
    creates an identity quaternion, `(0, 0, 0, 1)`. The `(0, 0, 0, 1)` identity quaternion
    is like `1`. Any number multiplied by `1` remains the same. Similarly, any quaternion
    multiplied by the identity quaternion remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `quat.h`, to declare the quaternion structure. The `quat`
    structure is going to be used throughout the rest of this book to represent rotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous union inside the `quat` structure will allow you to access the
    data inside a quaternion through `X`, `Y`, `Z`, and `W` subscript notation, as
    a vector and scalar pair, or as an array of floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you're going to learn how to start creating quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Angle axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quaternions are often created using an axis of rotation and an angle. A rotation
    about an axis by *θ* can be represented on a sphere as any directed arc whose
    length is ![](img/Formula_04_001.png) on the plane perpendicular to the rotation
    axis. Positive angles yield a counterclockwise rotation around the axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `quat.cpp`. Implement the `angleAxis` function in `quat.cpp`.
    Don''t forget to add the function declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Why ![](img/Formula_04_002.png)? A quaternion can track two full rotations,
    which is *720* degrees. This makes the period of a quaternion *720* degrees. The
    period of sin/cos is *360* degrees. Dividing *θ* by *2* maps the range of a quaternion
    to the range of sin/cos.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how the angle and axis of a rotation are encoded
    in
  prefs: []
  type: TYPE_NORMAL
- en: a quaternion. In the next section, you will learn how to build an angle and
    an axis
  prefs: []
  type: TYPE_NORMAL
- en: for the rotation between two vectors and encode that into a quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: Creating rotations from one vector to another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any two-unit vectors can represent points on a sphere. The shortest arc between
    these points lies on a plane that contains both points and the center of the sphere.
    This plane
  prefs: []
  type: TYPE_NORMAL
- en: is perpendicular to the axis of rotation between those two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the axis of rotation, normalize the input vectors. Find the cross product
    of the input vectors. This is the axis of rotation. Find the angle between the
    input vectors. From [*Chapter 2*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026),
    *Implementing Vectors*, the formula for the angle between two vectors is ![](img/Formula_04_003.png).
    Since both input vectors are normalized, this simplifies to ![](img/Formula_04_004.png),
    which means that the cosine of *θ* is the dot product of the input vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will recall from [*Chapter 2*](B16191_02_Final_JC_ePub.xhtml#_idTextAnchor026),
    *Implementing Vectors*, that the dot product has a relationship to the cosine
    of the angle between two vectors, and that the cross product has a relationship
    to the sine of the angle between two vectors. When creating quaternions, the dot
    and cross product have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_006.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_007.png)'
  prefs: []
  type: TYPE_IMG
- en: The cross product can be expanded into *x*, *y*, and *z* components and the
    previous equation starts to look like the code for creating a quaternion from
    an angle and an axis of rotation. Finding the angle between the two vectors would
    be expensive, but the half-angle can be counted without knowing what the angle
    is.
  prefs: []
  type: TYPE_NORMAL
- en: To find the half-angle, find the halfway vector between the *v1* and *v2* input
    vectors. Construct a quaternion using *v1* and this halfway vector. This will
    create a quaternion that results in the desired rotation.
  prefs: []
  type: TYPE_NORMAL
- en: There is one edge case—what happens when *v1* and *v2* are parallel? Or if *v1==
    -v2* ? The cross product that's used to find the axis of rotation would yield
    a *0* vector. If this edge case happens, find the most perpendicular vector between
    the two vectors to create a pure quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the `fromTo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin to implement the `fromTo` function in `quat.cpp` and add the function
    declaration to `quat.h`. Start by normalizing the `from` and `to` vectors, making
    sure they are not the same vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, check whether the two vectors are opposites of each other. If they are,
    the most orthogonal axis of the `from` vector can be used to create a pure quaternion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a half vector between the `from` and `to` vectors. Use the
    cross product of the half vector and the starting vector to calculate the axis
    of rotation and the dot product of the two to find the angle of rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `fromTo` function is one of the most intuitive ways of creating a quaternion.
    Next, you're going to learn how to retrieve the angle and the axis that define
    a quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving quaternion data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since a quaternion can be created from an angle and an axis, it's reasonable
    to expect to be able to retrieve the same angle and axis from the quaternion.
    To retrieve the axis of rotation, normalize the vector part of the quaternion.
    The angle of rotation is double the inverse cosine of the real component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `getAngle` and `getAxis` functions in `quat.cpp` and add function
    declarations for both in `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Being able to retrieve the angle and the axis that defines a quaternion will
    be needed later for some quaternion operations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you're going to learn about the component-wise operations that are commonly
    performed on quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Common quaternion operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like vectors, quaternions also have component-wise operations. Common
  prefs: []
  type: TYPE_NORMAL
- en: component-wise operations are adding, subtracting, multiplying, or negating
  prefs: []
  type: TYPE_NORMAL
- en: quaternions. Component-wise quaternion multiplication multiplies a quaternion
  prefs: []
  type: TYPE_NORMAL
- en: by a single scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these functions are component-wise, they just perform the appropriate
    action on similar components of the input quaternions. Implement these functions
    in `quat.cpp` and add declarations for each function in `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These component-wise operations don't have much practical use by themselves.
    They are the building blocks for building the rest of the quaternion functionality
    on. Next, you're going to learn about the different ways to compare quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing two quaternions can be done component-wise. Two quaternions can represent
    the same rotation even if they are not identical on a component level. This happens
    because a quaternion and its inverse rotate to the same spot but they take different
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overload the `==` and `!=` operators in `quat.cpp`. Add the declaration for
    these functions to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether two quaternions represent the same rotation, the absolute difference
    between the two needs to be tested. Implement the `sameOrientation` function in
    `quat.cpp`. Add the function declaration to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you will want to use the equality operator to compare quaternions.
    The `sameOrientation` function is not as useful because the rotation that a quaternion
    takes can be changed if the quaternion is inverted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to implement a quaternion dot product.
  prefs: []
  type: TYPE_NORMAL
- en: Dot product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like with vectors, the dot product measures how similar two quaternions are.
    The implementation is the same as the vector implementation. Multiply like components
    and sum the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the quaternion dot product function in `quat.cpp` and add its declaration
    to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Like vectors, the length of a quaternion is the dot product of the quaternion
    with itself. In the next section, you will learn how to find the squared length
    and length of a quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: Length and squared length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like vectors, the squared length of a quaternion is the same as the dot product
    of the quaternion with itself. The length of a quaternion is the square root of
    the square length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `lenSq` function in `quat.cpp` and declare the function in `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `len` function in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Quaternions that represent a rotation should always have a length of *1*. In
    the next section, you will learn about unit quaternions, which always have a length
    of *1*.
  prefs: []
  type: TYPE_NORMAL
- en: Unit quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quaternions can be normalized just like vectors. Normalized quaternions represent
    only a rotation and non-normalized quaternions introduce a skew. In the context
    of game animation, quaternions should be normalized to avoid adding a skew to
    the transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To normalize a quaternion, divide each component of the quaternion by its length.
    The resulting quaternion''s length will be *1*. This can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `normalize` function in `quat.cpp` and declare it in `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `normalized` function in `quat.cpp`, and declare it in `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is a fast way of inverting any unit quaternion. In the next section, you
    will learn how to find the conjugate and inverse of a quaternion and their relationship
    when it comes to unit quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Conjugate and inverse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games mostly use normalized quaternions, which comes in handy when inverting
    quaternions. The inverse of a normalized quaternion is its conjugate. The conjugate
  prefs: []
  type: TYPE_NORMAL
- en: 'of a quaternion flips its axis of rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `conjugate` function in `quat.cpp` and remember to declare the
    function in `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The proper inverse of a quaternion is the conjugate divided by the squared
    length of the quaternion. Implement the quaternion `inverse` function in `quat.cpp`.
    Add the function declaration to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you need to find out whether a quaternion is normalized or not, check the
    squared length. The squared length of a normalized quaternion is always *1*. If
    a quaternion is normalized, its conjugate and inverse are the same. This means
    you can use the faster `conjugate` function, instead of the `inverse` function.
    In the next section, you will learn how to multiply two quaternions together.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two quaternions can be concatenated by multiplying them together. Like with
    matrices, the operation is carried out from right to left; the right quaternion's
    rotation is applied first and then the left quaternion's.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you have two quaternions, *q* and *p*. They are subscripted with `0`,
    `1`, `2`, and `3`, which correspond to the `X`, `Y`, `Z`, and `W` components,
    respectively. These quaternions can be expressed in *ijk* notation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_008.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To multiply these two quaternions together, distribute the components of *p*
    to the components of *q*. Distributing the real component is simple. Distributing
    *p*3 to *q* would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Distributing the imaginary components looks very similar. The real and imaginary
    parts are combined separately; the order of imaginary components matters. For
    example, distributing *p*o*i* to *q* would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fully distributing *p* to *q* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_012.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_013.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_014.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start simplifying for the case when imaginary numbers are squared. The square
    root of an imaginary number is *-1*. If you raise *-1* to the power of *-1*, the
    result is also *-1*. This means that any instance of *i*2, *j*2, or *k*2 can be
    replaced by *-1*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_016.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_017.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_018.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_019.png)'
  prefs: []
  type: TYPE_IMG
- en: What about the rest of the imaginary numbers? When talking about quaternions,
  prefs: []
  type: TYPE_NORMAL
- en: '*ijk= -1*, the squared value of each of these components is also *-1*, which
    means that'
  prefs: []
  type: TYPE_NORMAL
- en: '*i*2*= j*2*= k*2*=ijk*. This property of quaternions can be used to simplify
    the rest of the equation.'
  prefs: []
  type: TYPE_NORMAL
- en: Take *jk*, for example. Start with *ijk= -1* and try to isolate *jk* to one
    side of the equation.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, multiply both sides by *i*, leaving you with *i(ijk)= -i*. Distribute
    *i*, which will leave you with *i*2 *jk= -i*. You already know that the value
    of *i*2 is *-1*. Substitute it to get
  prefs: []
  type: TYPE_NORMAL
- en: '*-jk= -i*. Multiply both sides by *-1* and you have found the value of *jk—
    jk=i*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values for *ki* and *ij* can be found in a similar way; they are *ki=j*
    and *k=ij*. You can now substitute any instances of *ki* with *j*, *ij* with *k*,
    and *jk* with *i*. Substituting these values leaves you with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_020.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_021.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_022.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The remaining imaginary numbers are *ik*, *ji*, and *kj*. Like the cross product,
    the order matters: *ik= -ki*. From this, you can assume that *ik= -j*, *ji= -k*,
    and *kj= -1*. Substituting these values leaves you with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_024.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_025.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_026.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Numbers with different imaginary components cannot be added together. Re-arrange
    the preceding formula so that like imaginary components are next to each other.
    This results in the final equation for quaternion multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_028.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_029.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_030.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement this formula in code, change from this subscripted *ijk* notation
    back to vector notation with `X`, `Y`, `Z`, and `W` subscripts. Implement the
    quaternion multiplication function in `quat.cpp` and don''t forget to add the
    function declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When looking at the preceding code, notice that the real part of the quaternion
    has one positive component, but the vector part has one negative component. Re-arrange
    the quaternion so that the negative numbers are always last. Write it down using
    vector notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*qp*x*= p*x *q*w*+ p*w *q*x*+ p*y *q*z*- p*z *q*y'
  prefs: []
  type: TYPE_NORMAL
- en: '*qp*y= *p*y *q*w+ *p*w *q*y+ *p*z *q*x- *p*x *q*z'
  prefs: []
  type: TYPE_NORMAL
- en: '*qp*z= *p*z *q*w+ *p*w *q*z+ *p*x *q*y- *p*y *q*x'
  prefs: []
  type: TYPE_NORMAL
- en: '*qp*w= *p*w *q*w- *p*x *q*x- *p*y *q*y- *p*z *q*z'
  prefs: []
  type: TYPE_NORMAL
- en: There are two interesting parts in the preceding equation. If you look closely
    at the last two columns of the first three rows, the columns with the subtraction
    are the cross product. The first two columns are just scaling the vector parts
    of each quaternion by the scalar parts of the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the last row, the dot product is in there with the negative
    of the dot product. The last row is basically multiplying the real parts of both
    quaternions, then subtracting the dot product of their vector parts. This means
    that an alternate multiplication implementation could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The original implementation is a bit more performant since it doesn't need to
    invoke other functions. The sample code for this book will use the first implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to transform vectors by quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To multiply a vector and a quaternion, you first have to turn the vector into
    a pure quaternion. What is a pure quaternion? It''s a quaternion whose `W` component
    is `0` and the vector part is normalized. Assume you have a quaternion, *q*, and
    a vector, *v*. First, turn *v* into a pure quaternion, represented as *v*'':'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_035.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_04_036.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, multiply *q* by *v*'' then multiply the result by the inverse of *q*.
    The result of this multiplication is a pure quaternion whose vector part contains
    the rotated vector. The quaternion becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_038.png)'
  prefs: []
  type: TYPE_IMG
- en: Why is *v*' multiplied by *q* and then *q*-1? Multiplying by *q* will rotate
    the vector twice as much as the rotation of *q*. Multiplying by *q*-1 brings the
    vector back into the expected range. This formula can be simplified further.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving this formula is outside the scope of this book. Given a quaternion,
    *q*, and
  prefs: []
  type: TYPE_NORMAL
- en: a vector, *v*, the simplified vector quaternion multiplication formula is listed
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*q*v refers to the vector part of the quaternion and *q*s refers to the real
    (or scalar) part:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the preceding formula for quaternion vector multiplication in `quat.cpp`.
    Don''t forget to add the function declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Multiplying a vector by a quaternion will always yield a vector that is rotated
    by the quaternion. In the next section, you're going to learn about interpolating
    between quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quaternions can be interpolated in a similar fashion to vectors. Quaternion
    interpolation is used to animate rotation between two keyframes. Since most skeletal
    animation is achieved by rotating joints over time, interpolating between quaternions
    is going to be
  prefs: []
  type: TYPE_NORMAL
- en: a very common operation.
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quaternion represents a rotation, not an orientation. Rotating from one part
    of a sphere to another can be achieved by one of two rotations. The rotation can
    take the shortest or the longest arc. Generally, having quaternions travel along
    the shortest arc is desirable. When interpolating between two quaternions, which
    path will be taken—the shortest arc or the longest?
  prefs: []
  type: TYPE_NORMAL
- en: This problem is called neighborhooding. To solve it, check the dot product of
    the quaternions being interpolated. If the dot product is positive, the shorter
    arc will be taken. If the dot product is negative, the longer arc will be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the dot product is negative, how can you correct the interpolation to take
    the shortest arc? The answer is to negate one of the quaternions. An example of
    quaternion neighborhooding is provided in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You only need to neighborhood quaternions when interpolating between them. Next,
    you will learn how to mix linear interpolation (`lerp`), normalized linear interpolation
    (`nlerp`), and spherical linear interpolation (`slerp`) quaternions. Remember
    that these functions expect the quaternion to already be in its desired neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the mix function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When mixing two or more quaternions together, each quaternion is scaled by some
    weight value, then the resulting scaled quaternions are added together. All the
    weights of all input quaternions must add up to *1*.
  prefs: []
  type: TYPE_NORMAL
- en: If all input quaternions are of unit length, the resulting quaternion will be
    of unit length as well. This function achieves the same result as `lerp` does,
    but it's not really a `lerp` function as the quaternion still travels on an arc.
    To avoid any confusion, this function will be called `mix`, not `lerp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mix` function assumes that the input quaternions are in the desired neighborhood.
    Implement the `mix` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the nlerp function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`nlerp` between quaternions is a fast and good approximation for spherical
    interpolation. Its implementation is almost the same as the `nlerp` implementation
    of the `vec3` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `mix`, `nlerp` also assumes the input vectors are in the desired neighborhood.
    Implement the `nlerp` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to slerp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`slerp` should only be used if consistent velocity is required. In most cases,
    `nlerp` will be a better interpolation method. Depending on the interpolation
    step size, `slerp` may end up falling back to `nlerp` anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to spherically interpolate between two quaternions, create a delta
    quaternion between the two. Adjust the angle of the delta quaternion, then concatenate
    it with the starting quaternion using quaternion multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: How can the angle of a quaternion be adjusted? To adjust the angle of a quaternion,
    raise it to the desired power. For example, to adjust the quaternion to only rotate
    halfway, you would raise it to the power of *0.5*.
  prefs: []
  type: TYPE_NORMAL
- en: Power
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To raise a quaternion to some power, it needs to be decomposed into an angle
    and an axis. Then, the angle can be adjusted by the power and a new quaternion
    can be built from the adjusted angle and axis. If a quaternion rotates around
    the *v* axis by an *θ* angle, raising it to some power, *t*, would be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_044.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `power operator` in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implementing slerp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to raise a quaternion to a power, implementing `slerp`
    becomes straightforward. If the start and end quaternions are very close together,
    `slerp` tends to produce unexpected results. If the start and end quaternions
    are close together, fall back on `nlerp`.
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate between two quaternions, find the delta quaternion from the start
    rotation to the end rotation. This delta quaternion is the interpolation path.
    Raise the angle to the power of how much the two quaternions are being interpolated
    between (usually represented as *t*) and multiply the start quaternion back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `slerp` function in `quat.cpp`. Don''t forget to add the function
    declaration to `quat.h`. Like the other interpolation functions, `slerp` assumes
    that the quaternions being interpolated are in the desired neighborhoods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The input vectors to `slerp` should be normalized, which means you could use
    `conjugate` instead of `inverse` in the `slerp` function. Most of the time, `nlerp`
    will be used over `slerp`. In the next section, you will learn how to create a
    quaternion that points in a specific direction.
  prefs: []
  type: TYPE_NORMAL
- en: Look rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a direction and a reference for which way is up, it's possible to create
    a quaternion that looks in that direction with the correct orientation. This function
    will be called `lookRotation`—not `lookAt`, to avoid any confusion with the matrix
    `lookAt` function.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the `lookRotation` function, find a quaternion that rotates to
    the desired direction. To do this, create a quaternion between the world `forward`
    vector *(0, 0, 1)* and the `desired direction`. This quaternion will rotate to
    the `right` target, but with no regard for what direction `up` might be.
  prefs: []
  type: TYPE_NORMAL
- en: To correct the `up` direction of this quaternion, you first have to find a vector
    that is perpendicular to the current forward direction and the desired `up` direction.
    This can be done by taking the cross product of the two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this cross product will be used to construct three orthogonal
    vectors—the forward vector, this new vector, and a vector that points up. The
    one you just found would point to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to find a vector that is perpendicular to both the `forward`
    and `right` directions; this will be the orthonormal `up` vector. To find this
    vector, take the cross product of the direction and this `right` vector and the
    result is the object space `up` vector.
  prefs: []
  type: TYPE_NORMAL
- en: Find a quaternion that rotates from the desired `up` vector to the object `up`
    vector. Multiply the quaternion that rotates to the target direction and the quaternion
    that rotates from `desired up` to `object up`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `lookRotation` function in `quat.cpp`. Don''t forget to add the
    function declaration to `quat.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The matrix `lookAt` function creates a view matrix, which is the inverse of
    the camera transform. This means the rotation of `lookAt` and the result of `lookRotation`
    are going to be the inverse of each other. In the next section, you will learn
    how to convert matrices to quaternions and quaternions to matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between quaternions and matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since both matrices and quaternions can be used to encode rotation data, it
    will be useful to be able to convert between them. To make converting between
    the two easier, you have to start thinking about rotation in terms of basis vectors,
    which are the vectors that represent the *x*, *y*, and *z* axes.
  prefs: []
  type: TYPE_NORMAL
- en: The upper 3 x 3 sub-matrix of a 4 x 4 matrix contains three basis vectors. The
    first column is the `right` vector, the second is the `up` vector, and the third
    is the `forward` vector. Using only the `forward` and `up` vectors, the `lookRotation`
    function can be used to convert a matrix into a quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a quaternion into a matrix, simply multiply the world basis vectors,
    which are the *x*, *y*, and *z* axes of the world, by the quaternion. Store the
    resulting vectors in the appropriate components of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `quatToMat4` function in `quat.cpp`. Don''t forget to add the
    function declaration to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A matrix stores both rotation and scale data using some of the same components.
    To address this, the basis vectors need to be normalized and the cross product
    needs to be used to make sure that the resulting vectors are orthogonal. Implement
    the `mat4ToQuat` function in `quat.cpp` and don''t forget to add the function
    declaration to `quat.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Being able to convert quaternions to matrices will be useful later when you
    need to pass rotation data to a shader. Shaders don't know what a quaternion is,
    but they have built-in functionality to deal with matrices. Converting matrices
    to quaternions is going to be useful for debugging and in the case where an external
    data source only provides rotations as matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented a robust quaternion library. Quaternions are
    important to the rest of this book as all animated rotation data is recorded as
    quaternions. You learned how to create quaternions and common quaternion operations,
    combine quaternions with multiplication, transform vectors by quaternions, interpolate
    quaternions and utility functions to create quaternions given a forward and up
    direction, and convert between matrices and quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use your combined knowledge of vectors, matrices,
    and quaternions to define a transformation object.
  prefs: []
  type: TYPE_NORMAL
