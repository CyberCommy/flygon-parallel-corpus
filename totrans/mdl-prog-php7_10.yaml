- en: Chapter 10. Building the Shipment Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shipment module, alongside the `payment` module, provides a basis for further
    sales functionality in our web shop. It will enable us to choose the shipment
    method when we reach the checkout process of the upcoming `sales` module. Similar
    to `payment`, `shipment` can be sort of static and dynamic. Whereas static might
    imply a fixed pricing value, or even a calculated one by some simple conditions,
    dynamic usually implies a connection to external API services.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will touch base with both types and see how we can
    set up a basic structure for implementing the `shipment` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics of the `shipment`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application requirements, defined under [Chapter 4](ch04.html "Chapter 4. Requirement
    Specification for a Modular Web Shop App"), *Requirement Specification for Modular
    Web Shop App*, do not give us any specifics as to what type of shipment we need
    to implement. Thus, for the purpose of this chapter, we will develop two shipment
    methods: dynamic rate shipment and flat rate shipment. Dynamic rate shipment is
    used as a way of connecting the shipment method to a real shipment processor,
    such as UPS, FedEx, and so on. It will not, however, actually connect to any of
    the external APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, we want this done by an interface similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `getInfo` method can then be used to fetch the available delivery options
    for the given order information, while the process method would then process the
    selected delivery option. For example, we might have an API return "same day delivery
    ($9.99)",= and "standard delivery ($4.99)" as delivery options under the dynamic
    rate shipment method.
  prefs: []
  type: TYPE_NORMAL
- en: Having such a shipment interface would then impose the requirement of having
    the `SalesBundle` module, which we still haven't developed. We will therefore
    proceed with our shipment methods, using a Symfony controller for handling the
    process method and a service for handling the `getInfo` method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as we did with the payment method in the previous chapter, we will
    expose our `getInfo` method through tagged Symfony services. The tag we will be
    using for shipment methods is `shipment_method`. Later on, during the checkout
    process, the `SalesBundle` module will fetch all of the services tagged with `shipment_method`
    and use them internally for a list of available shipment methods to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are building the module the other way round. That is, we are building it
    before we know anything about the `SalesBundle` module, which is the only module
    that will be using it. With that in mind, the `shipment` module has no firm dependencies
    on any other module. However, it might have been more convenient to build the
    `SalesBundle` module first and then expose a few interfaces that the `shipment`
    module might use.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start off by creating a new module called `Foggyline\ShipmentBundle`.
    We will do so with the help of the console by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command triggers an interactive process, which asks us several questions
    along the way, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, files `app/AppKernel.php` and `app/config/routing.yml` are modified
    automatically. The `registerBundles` method of an `AppKernel` class has been added
    to the following line under the `$bundles` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routing.yml` file has been updated with the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to avoid colliding with the core application code, we need to change
    `prefix: /`into `prefix: /shipment/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flat rate shipment service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flat rate shipment service is going to provide the fixed shipment method
    that our `sales` module is going to use for its checkout process. Its role is
    to provide the shipment method labels, code, delivery options, and processing
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by defining the following service under the services element
    of the `src/Foggyline/ShipmentBundle/Resources/config/services.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This `service` accepts only one argument: the `router`. The `tagname` value
    is set to `shipment_method`, as our `SalesBundle` module will be looking for shipment
    methods based on the `shipment_method` tag assigned to the service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create the actual `service` class, within the `src/Foggyline/ShipmentBundle/Service/FlatRateShipment.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `getInfo` method is what's going to provide the necessary information to
    our future `SalesBundle` module in order for it to construct the `shipment` step
    of the checkout process. It accepts a series of arguments:`$street`, `$city`,
    `$country`, `$postcode`, `$amount`, and `$qty`. We can consider these to be part
    of some unified shipment interface. `delivery_options` in this case returns a
    single, fixed value. `url_process` is the URL to which we will be inserting our
    selected shipment method. Our future `SalesBundle` module will then merely be
    doing an AJAX POST to this URL, expecting either a success or error JSON response,
    which is quite similar to what we imagined doing with payment methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flat rate shipment controller and routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We edit the `src/Foggyline/ShipmentBundle/Resources/config/routing.xml` file
    by adding the following route definitions to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `src/Foggyline/ShipmentBundle/Controller/FlatRateController.php`.
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We should now be able to access a URL, like `/app_dev.php/shipment/flat_rate/process`,
    and see the output of `processAction`. Implementations given here are dummy ones.
    What is important for us to know is that the `sales` module will, during its checkout
    process, render any possible `delivery_options` pushed through the `getInfo` method
    of a `shipment_method` tagged service. Meaning, the checkout process should show
    flat rate shipment as an option. The behavior of checking out will be coded such
    that if a `shipment` method is not selected, it will prevent the checkout process
    from going any further. We will touch upon this some more when we get to the `SalesBundle`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic rate payment service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from the flat rate shipment method, let's go ahead and define one more
    dynamic shipment, called Dynamic Rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by defining the following service under the `services` element
    of the `src/Foggyline/ShipmentBundle/Resources/config/services.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `service` defined here accepts only one `router` argument. The `tag name`
    property is the same as with the flat rate shipment service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create the `src/Foggyline/ShipmentBundle/Service/DynamicRateShipment.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the flat rate shipment, here the `delivery_options` key of the `getInfo`
    method is constructed with the response of the `getDeliveryOptions` method. The
    method is internal to the service and is not imagined as exposed or to be looked
    at as part of an interface. We can easily imagine doing some API calls within
    it, in order to fetch calculated rates for our dynamic shipment method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic rate shipment controller and routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the dynamic rates shipment service is in place, we can go ahead and create
    the necessary route for it. We will start by adding the following route definition
    to the `src/Foggyline/ShipmentBundle/Resources/config/routing.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create the `src/Foggyline/ShipmentBundle/Controller/DynamicRateController.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the flat rate shipment, here we have added a simple dummy implementation
    of the process and method. The incoming `$request` should contain the same info
    as the service `getInfo` method, meaning, it should have the following arguments
    available: `$street`, `$city`, `$country`, `$postcode`, `$amount`, and `$qty`.
    The method responses will feed into the `SalesBundle` module later on. We can
    easily implement more robust functionality from within these methods, but that
    is out of the scope of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FoggylineShipmentBundle` module is quite simple. By providing only two
    simple services and two simple controllers, it's easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by adding the following line under the `testsuites` element
    of our `phpunit.xml.dist` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, running the `phpunit` command from root of our shop should
    pick up any test we have defined under the `src/Foggyline/ShipmentBundle/Tests/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and create a test for our `FlatRateShipment` service.
    We will do so by creating a `src/Foggyline/ShipmentBundle/Tests/Service/FlatRateShipmentTest.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Two simple tests are being run here. One checks if we can instantiate a service
    via a container, and the other checks if we can do so directly. Once instantiated,
    we simply call the `getInfo` method of a service, passing it a dummy address and
    order information. Although we are not actually using this data within the `getInfo`
    method, we need to pass something along otherwise the test will fail. The method
    is expected to return a response that contains several keys under the shipment
    key, most notably `title`, `code`, `delivery_options`, and `url_process`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and create a test for our `DynamicRateShipment` service.
    We will do so by creating a `src/Foggyline/ShipmentBundle/Tests/Service/DynamicRateShipmentTest.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is nearly identical to that of the `FlatRateShipment` service. Here,
    we also have two simple tests: one fetching the payment method via a container,
    and the other directly via a class. The difference being that we are no longer
    asserting the presence of `delivery_options` not being empty. This is because
    a real API request might not return any options for delivery, depending on the
    given address and order information.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our entire module has only two controller classes that we want to test for responses.
    We want to make sure that the process method of the `FlatRateController` and `DynamicRateController`
    classes are accessible and working.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create an `src/Foggyline/ShipmentBundle/Tests/Controller/FlatRateControllerTest.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create a `src/Foggyline/ShipmentBundle/Tests/Controller/DynamicRateControllerTest.php`
    file, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both tests are nearly identical. They contain a test for a single process action
    method. As it is coded now, the controller process action simply returns a fixed
    success JSON response. We can easily extend it to return more than just a fixed
    response and can accompany that change with a more robust functional test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we have built a `shipment` module with two shipment
    methods. Each shipment method provided the available delivery options. The flat
    rate shipment method has only one fixed value under its delivery options, whereas
    the dynamic rate method gets its values from the `getDeliveryOptions` method.
    We can easily embed a real shipping API as part of `getDeliveryOptions` in order
    to provide truly dynamic shipping options.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we lack the official interfaces here, as we did with payment methods.
    However, this is something we can always come back to and refactor in our application
    as we finalize the `final` module.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the payment methods, the idea here was to create a minimal structure
    that showcases how one can develop a simple shipment module for further customization.
    Using the `shipment_methodservice` tag, we effectively exposed the shipment methods
    for the future `sales` module.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will build a `sales` module, which will
    finally make use of our `payment` and `shipment` modules.
  prefs: []
  type: TYPE_NORMAL
