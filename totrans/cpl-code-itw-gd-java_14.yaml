- en: '*Chapter 11*:'
  prefs: []
  type: TYPE_NORMAL
- en: Linked Lists and Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the most popular coding challenges involving maps and linked
    lists that you will encounter in coding interviews. Since singly linked lists
    are preferred in technical interviews, most of the problems in this chapter will
    exploit them. However, you can challenge yourself and try to solve each such problem
    in the context of a doubly linked list as well. Commonly, the problems become
    easier to solve for a doubly linked list because a doubly linked list maintains
    two pointers for each node and allows us to navigate back and forth within the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll know all of the popular problems involving
    linked lists and maps, and you''ll have enough knowledge and understanding of
    numerous techniques to help you to tackle any other problem in this category.
    Our agenda is quite simple; we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linked lists in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code files in this chapter are available on GitHub and can be accessed
    at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: However, before going into the coding challenges, let's first learn about linked
    lists and maps.
  prefs: []
  type: TYPE_NORMAL
- en: Linked lists in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A linked list is a linear data structure that represents a sequence of nodes.
    The first node is commonly referred to as the **head**, while the last node is
    commonly referred to as the **tail**. When each node points to the next node,
    we have a *singly linked list*, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.1: A singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – A singly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'When each node points to the next node and to the previous node, we have a
    *doubly linked list*, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.2: A doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – A doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a singly linked list. If the tail points to the head, then we
    have a *circular singly linked list*. Alternatively, let's consider a doubly linked
    list. If the tail points to the head and the head points to the tail, then we
    have a *circular doubly linked list*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a singly linked list, a node holds the data (for example, an integer or
    an object) and the pointer to the next node. The following code represents the
    node of a singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A doubly linked list also requires the pointer to the previous node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unlike an array, a linked list doesn't provide constant time to access the *n*th
    element. We have to iterate *n*-1 elements to obtain the *n*th element. We can
    insert, remove, and update nodes in constant time from the beginning of a linked
    list (singly and doubly). If our implementation manages the tail of the doubly
    linked list (known as a two-head doubly linked list), then we can insert, remove,
    and update nodes in constant time from the end of the linked list as well; otherwise,
    we need to iterate the linked list until the last node. If our implementation
    manages the tail of the singly linked list (known as a two-head singly linked
    list), then we can insert nodes in constant time at the end of the linked list;
    otherwise, we need to iterate the linked list until the last node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for this book comes with the following applications (each application
    exposes the `insertFirst()`, `insertLast()`, `insertAt()`, `delete()`, `deleteByIndex()`,
    and `print()` methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '*SinglyLinkedList*: Implementation of a two-head singly linked list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SinglyLinkedListOneHead*: Implementation of a single-head singly linked list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DoublyLinkedList*: Implementation of a two-head doubly linked list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DoublyLinkedListOneHead*: Implementation of a single-head doubly linked list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is highly recommended that you dissect, to the bone, each of these applications
    on your own. Each of them is heavily commented to help you to understand each
    step. The following coding challenges rely on these linked list implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Maps in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are looking for a word in a dictionary. The word itself is
    unique and can be considered a *key*. The meaning of this word can be considered
    the *value*. Therefore, the word and its meaning form a *key-value pair*. Similarly,
    in computing, a key-value pair accommodates a piece of data in which the value
    can be found by searching with the key. In other words, we know the key and we
    can use it to find the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A map is an **Abstract Data Type** (**ADT**) that manages key-value pairs (known
    as entries) via an array. The characteristics of a map include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Keys are unique (that is, no duplicate keys are allowed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can view the list of keys, the list of values, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common methods to work with a map are `get()`, `put()`, and `remove()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've briefly overviewed the notions of linked lists and maps, let's
    begin our coding challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following 17 coding challenges, we will cover a number of problems involving
    maps and linked lists. Since linked lists are a more popular topic in technical
    interviews, we will allocate a higher number of problems to them. However, to
    master the concept of map data structures, especially built-in Java map implementations,
    I strongly recommend that you buy the book *Java Coding Problems*, which is also
    published by Packt Publishing ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    Besides being an awesome companion to this book, *Java Coding Problems* contains
    the following problems with maps (note that this is not a complete list):'
  prefs: []
  type: TYPE_NORMAL
- en: Creating unmodifiable/immutable collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping a default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing whether a value is absent/present in a `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal from a `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing entries from a `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing two maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a `HashMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging two maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing all the elements of a collection that match a predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a basic idea of what linked lists and maps are, let's take
    a look at the most popular problems in interviews to do with maps and linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Map put, get, and remove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`put(K k, V v)`, one method named `get(K k)`, and one method named `remove(K
    k)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As you know, a map is a key-value pair data structure. Each key-value
    pair is an entry to the map. Therefore, we cannot implement a map''s functionalities
    until we materialize an entry. Since an entry holds two pieces of information,
    we need to define a class that wraps the key and the value in a generic approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an entry, we can declare a map. A map is managed via an array
    of entries that have a default size, which is known as the map capacity. A map
    with an initial capacity of 16 elements is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can focus on working with this array to act as a map for the client.
    Putting an entry into the map can only be done if the entry''s key is unique across
    the map. If the given key exists, then we just update its value. In addition to
    this, we can add an entry as long as we haven''t exceeded the map capacity. The
    typical approach in such a case is to double the size of the map. The code based
    on these statements is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following helper method is used to double the capacity of the map. Since
    a Java array cannot be resized, we need to tackle this issue by creating a copy
    of the initial array, but with a double the size of the initial array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a value is done using the key. If the given key is not found, then
    we return `null`. Getting a value doesn''t remove the entry from the map. Let''s
    take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to remove an entry using the key. Removing an element from
    an array involves shifting the remaining elements by one position. After the elements
    are shifted, the penultimate and last elements are equal. You can avoid memory
    leaks by nullifying the last element of the array. It is a common mistake to forget
    this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The production implementation of a map is much more complicated than the one
    exposed here (for example, a map uses buckets). However, most probably, you won't
    need to know more than this implementation in an interview. Nevertheless, it is
    a good idea to mention this to the interviewer. That way, you can show them you
    understand the complexity of the problem and that you are aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Done! The complete application is named *Map*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Map the key set and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`keySet()`) and a method that returns a collection of values (`values()`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set`. The following code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To return a collection of values, we loop the map and add the values, one by
    one, to a `List`. We use a `List` since values can contain duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Done! This was simple; a map implemented for production is far more complex
    than what is shown here. For example, the values are cached instead of being extracted
    every time. Mention this to the interviewer so she/he can see that you are aware
    of how a production map works. Take your time and check the Java built-in `Map`
    and `HashMap` source code.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named *Map*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Nuts and bolts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Given *n* nuts and *n* bolts, consider a one-to-one mapping between
    them. Write a snippet of code that finds all matches between the nuts and bolts
    with the minimum number of iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the nuts and bolts are represented by the
    following two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The most intuitive solution relies on a brute-force approach. We can choose
    a nut and iterate the bolts to find its mate. For example, if we choose `nuts[0]`,
    we can find its mate with `bolts[3]`. Additionally, we can take `nuts[1]` and
    find its mate with `bolts[0]`. This algorithm is very simple to implement via
    two `for` statements and has a complexity time of O(n2).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can consider sorting the nuts and bolts. This way, the matches
    between the nuts and bolts will automatically align. This will also work, but
    it will not include the minimum number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to obtain a minimum number of iterations, we can use a hash map. In
    this hash map, first, we put each nut as a key and its position in the given array
    of nuts as a value. Next, we iterate the bolts, and we check whether the hash
    map contains each bolt as a key. If the hash map contains a key for the current
    bolt, then we have found a match (a pair); otherwise, there is no match for this
    bolt. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The runtime for this code is O(n). The complete code is named *NutsAndBolts*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Remove duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an unsorted singly linked list of integers. Write a snippet
    of code that removes duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<Integer>`. However, before adding the data of the current node into the
    `Set`, we check the data against the current contents of the `Set`. If the `Set`
    already contains that data, we remove the node from the linked list; otherwise,
    we just add its data to the `Set`. Removing a node from a singly linked list can
    be done by linking the previous node to the next node of the current node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.3: Removing a node from a singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Removing a node from a singly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a singly linked list holds a pointer to only the next node, we cannot
    know the node previous to the current node. The trick is to track two consecutive
    nodes starting with the current node as the linked list head and the previous
    node as `null`. When the current node advances to the next node, the previous
    node advances to the current node. Let''s look at the code that glues these statements
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution works in the time and space complexity of O(n), where *n* is
    the number of nodes in the linked list. We can try another approach that reduces
    space complexity to O(1). First, let''s consider the following diagram as a guide
    for the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.4: Removing a node from a singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Removing a node from a singly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach uses two pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: The current node, which starts from the head of the linked list and traverses
    the linked list, node by node, until it reaches the tail (for example, in the
    preceding diagram, the current node is the second node).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The runner node, which starts from the same place as the current node, that
    is, the head of the linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, the runner node iterates through the linked list and checks whether
    the data of each node is equal to the data of the current node. While the runner
    code iterates through the linked list, the current node's position remains fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the runner node detects a duplicate, then it removes it from the linked
    list. When the runner node reaches the tail of the linked list, the current node
    advances to the next node, and the runner node iterates through the linked list
    again starting from the current node. So, this is an O(n2) time complexity algorithm,
    but with an O(1) space complexity. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is named *LinkedListRemoveDuplicates*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Rearranging linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Amazon**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an unsorted singly linked list of integers and a given
    integer, *n*. Write a snippet of code that rearranges the nodes around *n*. In
    other words, by the end, the linked list will contain all of the values that are
    less than *n* followed by all of the nodes that are larger than *n*. The order
    of the nodes can be altered and *n* itself can be anywhere between the values
    that are larger than *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider that the given linked list is 1 → 5 → 4 → 3 → 2 → 7
    → null, and *n*=3\. So, 3 is our pivot. The rest of the nodes should be rearranged
    around this pivot conforming to the problem requirement. One solution to this
    problem is to iterate the linked list node by node and each node that is smaller
    than the pivot is put at the head, while each node that is larger than the pivot
    is put at the tail. The following diagram helps us to visualize this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.5: Linked list rearranging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Linked list rearranging
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the nodes with the values of 5, 4, and 3 are moved to the tail, while the
    node with the value of 2 is moved to the head. By the end, all values smaller
    than 3 are on the left side of the dashed line, while all values larger than 3
    are on the right side of the dashed line. We can put this algorithm into code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListRearranging*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – The nth to last node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list of integers and a given integer,
    *n*. Write a snippet of code that returns the value of the *n*th to last node.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We have a bunch of nodes and we have to find the *n*th node that
    satisfies a given constraint. Based on our experience from [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161),
    *Recursion and Dynamic Programming*, we can intuit that this problem has a solution
    involving recursion. But we can also solve it via an iterative solution. Since
    the iterative solution is more interesting, I will present it here, while the
    recursive solution is available in the bundled code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following diagram to present the algorithm (follow the diagram
    from top to bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.6: The nth to last node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – The nth to last node
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are given a linked list, 2 → 1 → 5 → 9 → 8 → 3 → 7 → null, and we want
    to find the fifth to last node value, which is 5 (you can see this at the top
    of the preceding diagram). The iterative solution uses two pointers; let''s denote
    them as *runner1* and *runner2*. Initially, both of them point to the head of
    the linked list. In step 1 (the middle of the preceding diagram), we move the
    *runner1* from the head to the 5th to head (or *n*th to head) node. This is easy
    to accomplish in a `for` loop from 0 to 5 (or *n*). In step 2 (the bottom of the
    preceding diagram), we move *runner1* and *runner2* simultaneously until *runner1*
    is `null`. When *runner1* is `null`, *runner2* will point to the fifth from the
    head to last node (or *n*th from the head to last). In code lines, we do it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListNthToLastNode*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Loop start detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list of integers that contains a loop.
    In other words, the tail of the linked list points to one of the previous nodes
    defining a loop or a circularity. Write a snippet of code that detects the first
    node of the loop (that is, the node from which the loop starts).'
  prefs: []
  type: TYPE_NORMAL
- en: '`tail.next`. If we don''t manage the tail, then we can search for the node
    that has two nodes pointing to it. This is also quite easy to implement. If we
    know the size of the linked list, then we can iterate from 0 to size, and the
    last `node.next` points to the node that marks the loop start.'
  prefs: []
  type: TYPE_NORMAL
- en: The Fast Runner/Slow Runner approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, let's try another algorithm that requires more imagination. This approach
    is called the Fast Runner/Slow Runner approach. It is important because it can
    be used in certain problems involving linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primarily, the Fast Runner/Slow Runner approach involves using two pointers
    that start from the head of the linked list and iterate through the list simultaneously
    until a certain condition(s) is met. One pointer is named **Slow Runner** (**SR**)
    because it iterates through the list node by node. The other pointer is named
    **Fast Runner** (**FR**) because it iterates through the list by jumping over
    the next node at every move. The following diagram is an example of four moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.7: Fast Runner/Slow Runner example](img/Figure_11.7_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Fast Runner/Slow Runner example
  prefs: []
  type: TYPE_NORMAL
- en: So, at the first move, *FR* and *SR* are pointing to the *head*. At the second
    move, *SR* points to the *head.next* node with value 1, while *FR* points to the
    *head.next.next* node with value 4\. The moves continue following this pattern.
    When *FR* reaches the tail of the linked list, *SR* is pointing to the middle
    node.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the next coding challenge, the Fast Runner/Slow Runner approach
    can be used to detect whether a linked list is a palindrome. However, for now,
    let's resume our problem. So, can we use this approach to detect whether a linked
    list has a loop and to find the start node of this loop? This question generates
    another question. If we apply the Fast Runner/Slow Runner approach to a linked
    list having a loop, do the *FR* and *SR* pointers collide or meet? The answer
    is yes, they will collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this, let''s assume that before starting the loop, we have *q* preceding
    nodes (these are the nodes that are outside the loop). For every *q* nodes traversed
    by *SR*, *FR* has traversed 2**q* nodes (this is obvious since *FR* jumps over
    a node at every move). Therefore, when *SR* enters the loop (reaches the loop
    start node), *FR* has traversed 2**q* nodes. In other words, *FR* is at 2**q-q*
    nodes in the loop portion; therefore, it is at *q* nodes in the loop portion.
    Let''s visualize this via the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.8: Linked list with a loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – Linked list with a loop
  prefs: []
  type: TYPE_NORMAL
- en: So, when *SR* enters the loop (reaches the fourth node), *FR* reaches the fourth
    node into the loop. Of course, we need to consider that *q* (the number of preceding
    non-loop nodes) might be much larger than the loop length; therefore, we should
    express 2**q-q* as *Q=modulo(q, LOOP_SIZE)*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider *Q = modulo*(3, 8) =3, where we have three non-loop nodes
    (*q*=3) and the loop size is eight (*LOOP_SIZE=*8). In this case, we can apply
    2**q-q* as well since 2*3-3=3\. Hence, we can conclude that *SR* is at three nodes
    from the start of the list and *FR* is at three nodes from the start of the loop.
    However, if the linked list has 25 nodes that precede a loop of 7 nodes, then
    *Q = modulo* (25, 7) = 4 nodes, while 2*25-25=25, which is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, *FR* and *SR* are moving inside the loop. Since they are
    moving in a circle, it means that when *FR* moves away from *SR*, it also moves
    closer to *SR* and vice versa. The following diagram isolates the loop and shows
    how it continues moving *FR* and *SR* until they collide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.9: FR and SR collision](img/Figure_11.9_B15403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – FR and SR collision
  prefs: []
  type: TYPE_NORMAL
- en: Take your time tracking *SR* and *FR* until they reach the meet point. We know
    that *FR* is at *LOOP_SIZE – Q* nodes behind *FR* and that *SR* is *Q* nodes behind
    *FR*. In our test case, *FR* is 8-3=5 nodes behind *SR*, and *SR* is 3 nodes behind
    *FR*. By continuing to move *SR* and *FR*, we can see that *FR* catches up at
    a rate of 1 step per move.
  prefs: []
  type: TYPE_NORMAL
- en: So, where do they meet? Well, if *FR* catches up at a rate of 1 step per move
    and *FR* is *LOOP_SIZE – Q* nodes behind *SR*, then they will meet *Q* steps before
    the head of the loop. In our test case, they will meet 3 steps before the head
    of the loop at the node with a value of 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the meet point is at *Q* nodes from the head of the loop, we can continue
    by recalling that the meet point is at *q* nodes from the head of the loop as
    well, since *Q=modulo(q, LOOP_SIZE)*. This means that we can develop the following
    four-step algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with *FR* and *SR* from the head of the linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move *SR* at a rate of 1 node and *FR* at a rate of 2 nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When they collide (at the meet point), move *SR* to the head of the linked list
    and keep *FR* where it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move *SR* and *FR* at a rate of 1 node until they collide (this is the node
    representing the head of the loop).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As a quick note, don't expect that *FR* can jump over *SR*, so they will not
    meet. This scenario is not possible. Imagine that *FR* has jumped over *SR* and
    it is at node *a*, then *SR* must be at node *a*-1\. This means that, at the previous
    step, *FR* was at node *a*-2 and *SR* was at node (*a*-1)-1=*a*-2; therefore,
    they have collided.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named *LinkedListLoopDetection*. In this code, you'll
    find a method named `generateLoop()`. This method is called to generate random
    linked lists with loops.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Palindromes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the linked list is a palindrome. The solution should involve the
    Fast Runner/Slow Runner approach (this approach was detailed in the previous coding
    challenge).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Just as a quick reminder, a palindrome (whether a string, a number,
    or a linked list) looks unchanged when it''s reversed. This means that processing
    (reading) a palindrome can be done from both directions and the same result will
    be obtained (for example, the number 12321 is a palindrome, while the number 12322
    is not).'
  prefs: []
  type: TYPE_NORMAL
- en: We can intuit a solution that involves the Fast Runner/Slow Runner approach
    by thinking that when *FR* reaches the end of the linked list, *SR* is in the
    middle of the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first half of the linked list is the reverse of the second half, then
    the linked list is a palindrome. So, if, in a stack, we store all of the nodes
    traversed by *SR* until *FR* reaches the end of the linked list, the resulting
    stack will contain the first half of the linked list in reverse order. Let''s
    visualize this via the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.10: Linked list palindrome using the Fast Runner/Slow Runner approach'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Linked list palindrome using the Fast Runner/Slow Runner approach
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when *FR* has reached the end of the linked list and *SR* has reached the
    fourth node (the middle of the linked list), the stack contains the values of
    2, 1, and 4\. Next, we can continue to move *SR* at a rate of 1 node until the
    end of the linked list. At each move, we pop a value from the stack, and we compare
    it with the current node value. If we find a mismatch, then the linked list is
    not a palindrome. In the code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListPalindrome*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Sum two linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two positive integers and two singly linked lists. The
    first integer is stored in the first linked list digit by digit (the first digit
    is the head of the first linked list). The second integer is stored in the second
    linked list digit by digit (the first digit is the head of the second linked list).
    Write a snippet of code that adds the two numbers and returns the sum as a linked
    list having one digit per node.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s start with a visualization of a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.11: Summing two numbers as linked lists'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – Summing two numbers as linked lists
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compute the sum from the preceding diagram step by step, we obtain the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 7 + 7 = 14, so we write down 4 and carry 1:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → ?
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 3 + 9 + 1 = 13, so we write down 3 and carry 1:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → ?
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 8 + 8 + 1 = 17, so we write down 7 and carry 1:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → 7 → ?
  prefs: []
  type: TYPE_NORMAL
- en: We add 9 + 4 + 1 = 14, so we write down 4 and carry 1
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → 7 → 4 → ?
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 4 + 1 = 5, so we write down 5 and carry nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → ?
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 1 + 0 = 1, so we write down 1 and carry nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → 1 → ?
  prefs: []
  type: TYPE_NORMAL
- en: 'We add 2 + 0 = 2, so we write down 2 and carry nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → 1 → 2
  prefs: []
  type: TYPE_NORMAL
- en: 'If we write the resulting linked list as a number, we obtain 4374512; therefore,
    we need to reverse it to 2154734\. While the method for reversing the resulting
    linked list (which can be considered a coding challenge itself) can be found in
    the bundled code, the following method applies the preceding steps in a recursive
    approach (if you are not skilled in recursion problems, don''t forget to cover
    [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161), *Recursion and
    Dynamic Programming*). Essentially, the following recursion works by adding data
    node by node, carrying over any excess data to the next node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListSum*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Linked lists intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two singly linked lists. Write a snippet of code that
    checks whether the two lists intersect. The intersection is based on reference,
    not on value, but you should return the value of the intersection node. So, check
    the intersection by reference and return the value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you are not sure what the *intersection of two linked lists*
    means, then we recommended that you sketch a test case and discuss the details
    with the interviewer. The following diagram shows such a case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.12: The intersection of two lists'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.12_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – The intersection of two lists
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we have two lists that intersect at the node with value 8\.
    Because we are talking about an intersection by reference, this means that the
    nodes with the value of 9, and value of 4, point to the memory address of the
    node with the value of 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main issue is that the lists are not of the same size. If their sizes were
    equal, we could traverse both of them, node by node, from head to tail until they
    collide (until *node_list_1.next= node_list_2.next*). If we could skip the nodes
    with values of 2 and 1, our lists will be the same size (refer to the next diagram;
    since the first list is longer than the second list, we should start iterating
    from the node marked *virtual head*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.13: Removing the first two nodes of the top list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – Removing the first two nodes of the top list
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this statement in mind, we can deduce the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the sizes of the lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the first list (let's denote it as *l1*) is longer than the second one (let's
    denote it as *l2*), then move the pointer of the first list to (*l1-l2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the first list is shorter than the second one, then move the pointer of the
    second list to (*l2-l1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move both pointers, node by node, until you reach the end or until they collide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Putting these steps into code is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListsIntersection*. In the code, you
    will see a helper method named `generateTwoLinkedListWithInterection()`. This
    is used to generate random lists with an intersection point.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Swap adjacent nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list. Write a snippet of code that swaps
    the adjacent nodes so that a list such as 1 → 2 → 3 → 4 → null becomes 2 → 1 →
    4 → 3 → null. Consider swapping the adjacent nodes, not their values!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We can reduce the problem of finding a solution to swap two consecutive
    nodes, *n1* and *n2*. A well-known technique to swap two values (for example,
    two integers, *v1* and *v2*) relies on an auxiliary variable and can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*aux = v1; v1 = v2; v2 = aux;*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we cannot apply this plain approach to nodes because we have to deal
    with their links. It is not enough to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*aux = n1; n1 = n2; n2 = aux;*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rely on this plain approach to swap *n1* with *n2*, then we will obtain
    something similar to the following diagram (notice that after swapping *n1* with
    *n2*, we have *n1.next* = *n3* and *n2.next* = *n1*, which is totally wrong):'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.14: Plain swapping with broken links (1)](img/Figure_11.14_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Plain swapping with broken links (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can fix the links, right? Well, we can explicitly set *n1.next* to point
    to *n2*, and set *n2.next* to point to *n3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n1.next = n2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*n2.next = n3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it should be good! We can swap two consecutive nodes. However, when we
    swap a pair of nodes, we also break the links between two consecutive pairs of
    nodes. The following diagram illustrates this issue (we swap and fix the links
    for the *n1-n2* pair and the *n3-n4* pair):'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.15: Plain swapping with broken links (2)](img/Figure_11.15_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Plain swapping with broken links (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that after swapping these two pairs, *n2.next* points to *n4*, which
    is wrong. Hence, we must fix this link as well. For this, we can store *n2*, and,
    after swapping *n3-n4*, we can repair the link by setting *n2.next=n3*. Now, everything
    looks good and we can put it into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListPairwiseSwap*. Consider challenging
    yourself to swap sequences of *n* nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Merge two sorted linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two sorted singly linked lists. Write a snippet of code
    that merges these two lists without extra space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: So, we have two sorted lists, *list1*: 4 → 7 → 8 → 10 → null
    and *list2*: 5 → 9 → 11 → null, and we want to obtain the result, 4 → 5 → 7 →
    8 → 9 → 10 → 11 → null. Moreover, we want to obtain this result without allocating
    new nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we cannot allocate new nodes, we have to choose one of these lists to
    become the final result or the merged linked list. In other words, we can start
    with *list1* as the merged linked list and add nodes from *list2* at the appropriate
    place in *list1*. After processing each comparison, we move the pointer (*list1*)
    to the last node in the merged list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we start by comparing the heads of these two lists. If the head
    of *list1* is smaller than the head of *list2*, we choose the head of *list1*
    as the head of the merged list. Otherwise, if the head of *list1* is bigger than
    the head of *list2*, we swap the heads. The following diagram illustrates this
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Merging two sorted linked lists (step 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.16_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.16 – Merging two sorted linked lists (step 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the head of *list1* is less than the head of *list2* (4 < 5), it becomes
    the head of the merged list. We said that *list1* will point to the last node
    of the merged list; therefore, the next node to compare should be *list1.next*
    (the node with value 7) and *list2* (the node with value 5). The following diagram
    reveals the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Merging two sorted linked lists (step 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – Merging two sorted linked lists (step 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 5, but we cannot do it directly. If we say
    *list1.next=list2*, then we lose the rest of *list1*. Therefore, we have to perform
    a swap, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move *list1* to *list1.next*, which is the node with value 9\. We
    compare *list.next* with *list2*; therefore, we compare 9 with 7\. The following
    diagram reveals the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Merging two sorted linked lists (step 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.18_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – Merging two sorted linked lists (step 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 7 (since 7 < 9), and we do it using the swap
    that we discussed earlier. Next, we move *list1* to *list1.next*, which is the
    node with value 8\. We compare *list.next* with *list2*; therefore, we compare
    8 with 9\. The following diagram reveals the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Merging two sorted linked lists (step 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.19_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.19 – Merging two sorted linked lists (step 4)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 8 < 9, no swap is needed. We move *list1.next* to the next node (the
    node with value 10) and compare 10 with 9\. The next diagram reveals the result
    of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Merging two sorted linked lists (step 5)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.20_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – Merging two sorted linked lists (step 5)
  prefs: []
  type: TYPE_NORMAL
- en: 'As *list1* follows the merged list (the final result), we have to move *list1.next*
    to the node with value 9 (since 9 < 10), and we do it using the swap that we discussed
    earlier. Next, we move *list1* to *list1.next*, which is the node with value 11\.
    We compare *list.next* with *list2*; therefore, we compare 11 with 10\. The next
    diagram reveals the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.21: Merging two sorted linked lists (step 6)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.21_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – Merging two sorted linked lists (step 6)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 10 (since 10 < 11), and we do it using the
    swap that we discussed earlier. Next, we move *list1* to *list1.next*, which is
    `null`; therefore, we copy the remaining part from *list2*. The next diagram reveals
    the result of this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.22: Merging two sorted linked lists (last step)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.22_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – Merging two sorted linked lists (last step)
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the merged linked list is complete. It is time to reveal the
    code (this method is added to the well-known `SinglyLinkedList`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListMergeTwoSorted*. A similar problem
    may require you to merge two sorted linked lists via recursion. While you can
    find this application named as *LinkedListMergeTwoSortedRecursion,* I advise you
    to challenge yourself to try an implementation. Additionally, based on this recursive
    implementation, challenge yourself to merge *n*-linked lists. The complete application
    is named *LinkedListMergeNSortedRecursion.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Remove the redundant path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list storing a path in a matrix. The
    data of a node is of type (*row, column*) or, in short, (*r, c*). The path can
    only be either horizontal (by *column*) or vertical (by *row*). The complete path
    is given by the end points of all of the horizontal and vertical paths; therefore,
    the middle points (or points in between) are redundant. Write a snippet of code
    that removes the redundant path.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider a linked list containing the following path:
    (0, 0) → (0, 1) → (0, 2) → (1, 2) → (2, 2) → (3, 2) → (3, 3) → (3, 4) → null.
    The redundant path includes the following nodes: (0, 1), (1, 2), (2, 2), and (3,
    3). So, after removing the redundant path, we should remain with a list that contains
    four nodes: (0, 0) → (0, 2) → (3, 2) → (3, 4) → null. The following diagram represents
    the redundant path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.23: The redundant path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.23_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – The redundant path
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing the redundant path, we obtain the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.24: The remaining path after removing the redundancy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.24_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.24 – The remaining path after removing the redundancy
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagrams should suggest a solution to this problem. Notice that
    the nodes that define a vertical path have the same column since we move only
    down/up on the rows, while the nodes that define a horizontal path have the same
    row since we move only left/right on the columns. This means that if we consider
    three consecutive nodes having the same value for the column or the row, then
    we can remove the middle node. Repeating this process for adjacent triplets will
    remove all redundant nodes. The code should be quite simple to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListRemoveRedundantPath*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Move the last node to the front
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list. Write a snippet of code that moves
    the last node to the front via two approaches. So, the last node of the linked
    list becomes its head.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This is the kind of problem that sounds simple, and it is simple.
    The first approach will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move a pointer to the second to last node (let's denote it as *currentNode*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the *currentNode.next* (let's denote it as *nextNode* – this is the last
    node).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `cu`*rrentNode.next* to `null` (so, the last node becomes the tail).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the new head as the stored node (so, the head becomes *nextNode*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach can be performed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move a pointer to the second to last node (let's denote it as *currentNode*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the linked list into a circular list (link *currentNode.next.next* to
    the head).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the new head as *currentNode.next*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break the circularity by setting *currentNode.next* to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LinkedListMoveLastToFront*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Reverse a singly linked list in groups of k
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a singly linked list and an integer, *k*. Write a snippet
    of code that reverses the linked list''s nodes in *k* groups.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given linked list is 7 → 4 → 3 → 1 →
    8 → 2 → 9 → 0 → null and *k*=3\. The result should be 3 → 4 → 7 → 2 → 8 → 1 →
    0 → 9 → null.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider that the given *k* is equal to the size of the linked list. In
    this case, we reduced the problem to reversing the given linked list. For example,
    if the given list is 7 → 4 → 3 → null and *k*=3, then the result should be 3 →
    4 → 7 → null. So, how can we obtain this result?
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reverse the nodes, we need the current node (*current*), the node
    next to the current node (*next*), and the node previous to the current node (*previous*),
    and we apply the following algorithm representing the rearrangement of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a counter from 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the *current* node (initially the head) is not `null` and we haven''t reached
    the given *k*, the following occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The *next* node (initially `null`) becomes the node next to the *current*
    node (initially the head).
  prefs: []
  type: TYPE_NORMAL
- en: b. The node next to the *current* node (initially the head) becomes the *previous*
    node (initially `null`).
  prefs: []
  type: TYPE_NORMAL
- en: c. The *previous* node becomes the *current* node (initially the head).
  prefs: []
  type: TYPE_NORMAL
- en: d. The *current* node becomes the *next* node (the node from *step 2a*).
  prefs: []
  type: TYPE_NORMAL
- en: e. Increment the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply this algorithm, we can reverse the whole list. But we need
    to reverse it in the groups; therefore, we must solve the *k* subproblems of what
    we''ve done. If this sounds like recursion to you, then you are right. At the
    end of the preceding algorithm, the node set at *step 2a* (*next*) points to the
    node where the counter is pointing as well. We can say that we''ve reversed the
    first *k* nodes. Next, we continue with the next group of *k* nodes via recursion
    starting from the *next* node. The following diagram illustrates this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.25: Reversing the list in k groups (k=3)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.25_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.25 – Reversing the list in k groups (k=3)
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following code implements this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n), where *n* is the number of nodes in the given list.
    The complete application is named *ReverseLinkedListInGroups*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Reverse a doubly linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a doubly linked list. Write a snippet of code that reverses
    its nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Reversing a doubly linked list can take advantage of the fact
    that a doubly linked list maintains the link to the previous node. This means
    that we can simply swap the previous pointers and the next pointers for each node,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *DoublyLinkedListReverse*. To sort a singly
    and doubly linked list, please refer to [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340),
    *Sorting and Searching*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – LRU cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Write a snippet of code to implement a fixed-size LRU cache. LRU
    cache stands for Least Recently Used Cache. This means that, when the cache is
    full, adding a new entry will instruct the cache to automatically evict the least
    recently used entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Any cache implementation must provide a fast and efficient way
    of retrieving data. This means that our implementation must respect the following
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed size**: The cache must use a limited amount of memory. Therefore, it
    needs to have some bounds (for example, a fixed size).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast access to data**: Inserting and searching operations should be fast;
    preferably, O(1) complexity time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast eviction of data**: When the cache is full (it has reached its allocated
    bounds), the cache should empower an efficient algorithm to evict an entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of the last bullet point, eviction from an LRU cache means evicting
    the least recently used data. To accomplish this, we have to keep track of the
    recently used entries and of the entries that have not been used for a long time.
    Moreover, we have to ensure O(1) complexity time for inserting and searching operations.
    There is no built-in data structure in Java that can give us this cache out of
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: But we can start with a `HashMap` data structure. In Java, a `HashMap` allows
    us to insert and search (lookup) data by key in O(1) time. So, using a `HashMap`
    solves half of the problem. The other half, that is, keeping track of the recently
    used entries and of the entries that have not been used for a long time, cannot
    be accomplished with a `HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we imagine a data structure that provides fast insertions, updates,
    and deletions, then we have to think of a doubly linked list. Essentially, if
    we know the address of a node in a doubly linked list, then inserting, updating,
    and deleting can be performed in O(1).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can provide an implementation that relies on the symbiosis
    between a `HashMap` and a doubly linked list. Essentially, for each entry (key-value
    pair) in the LRU cache, we can store the key of the entry and the address of the
    associated linked list''s node in the `HashMap`, while this node will store the
    value of the entry. The following diagram is a visual representation of this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![11.26: An LRU cache using a HashMap and doubly linked list](img/Figure_11.26_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.26 – An LRU cache using a HashMap and doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does the doubly linked list help us to track the recently used entries?
    The secret relies on the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new entry in the cache will result in adding the corresponding node
    to the head of the linked list (so, the head of the linked list holds the most
    recently used value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an entry is accessed, we move its corresponding node to the head of the
    linked list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to evict an entry, we evict the tail of the linked list (so, the
    tail of the linked list holds the least recently used value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Well, based on these statements, we can provide the following straightforward
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LRUCache*.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this was the last coding challenge of the chapter. It's time to summarize
    the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter brought your attention to the most common problems involving linked
    lists and maps. Among these problems, the ones that involve singly linked lists
    are preferred; therefore, this chapter was primarily focused on this category
    of coding challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle coding challenges related to stacks and
    queues.
  prefs: []
  type: TYPE_NORMAL
