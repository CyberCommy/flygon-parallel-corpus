- en: Chapter 8. Creating a MEAN CRUD Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, you learned how to set up each framework and how
    to connect them all together. In this chapter, you''re going to implement the
    basic operational building blocks of a MEAN application, the CRUD module. CRUD
    modules consist of a base entity with the basic functionality of creating, reading,
    updating, and deleting entity instances. In a MEAN application, your CRUD module
    is built from the server-side Express components and an Angular client module.
    In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Mongoose model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Express controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring the Express routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and organizing the Angular module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Angular forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Angular `http` client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Angular module service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Angular module components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing CRUD modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRUD modules are the basic building blocks of a MEAN application. Each CRUD
    module consists of two structures supporting the Express and Angular functionalities.
    The Express part is built upon a Mongoose model, an Express controller, and an
    Express routes file. The Angular module is a bit more complex and contains a set
    of templates and a few Angular components, service, and the routing configuration.
    In this chapter, you'll learn how to combine these components in order to build
    an example `Article` CRUD module. The examples in this chapter will continue directly
    from those in previous chapters, so copy the final example from [Chapter 7](ch07.html
    "Chapter 7. Introduction to Angular"), *Introduction to Angular*, and let's start
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Express components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin with the Express part of the module. First, you'll create a Mongoose
    model that will be used to save and validate your articles. Then, you'll move
    on to the Express controller that will deal with the business logic of your module.
    Finally, you'll wire the Express routes to produce a RESTful API for your controller
    methods. We'll begin with the Mongoose model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Mongoose model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mongoose model will consist of four simple properties that will represent
    our `Article` entity. Let''s begin by creating the Mongoose model file in the
    `app/models` folder; create a new file named `article.server.model.js`, which
    contains the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be familiar with this code snippet, so let''s quickly go over this
    model. First, you included your model dependencies and then you used the Mongoose
    `Schema` object to create a new `ArticleSchema`. `ArticleSchema` defines four
    model fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`created`: This is a date field that represents the time at which the article
    was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is a string field that represents the article title; note how
    you used the required validation to make sure all articles have a title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: This is a string field that represents the article content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`creator`: This is a reference object that represents the user who created
    the article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the end, you registered the `Article` Mongoose model to allow you to use
    it in the `Articles` Express controller. Next, you''ll need to make sure your
    application is loading the model file, so go back to the `config/mongoose.js`
    file and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will load your new model file and make sure your application can use your
    `Article` model. Once you have your model configured, you'll be able to create
    your `Articles` controller.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Express controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Express controller is responsible for managing articles-related functionalities
    on the server side. It is built to offer the basic CRUD operations to manipulate
    the MongoDB article documents. To begin writing the Express controller, go to
    your `app/controllers` folder and create a new file named `articles.server.controller.js`.
    In your newly created file, add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, you basically just included your `Article` mongoose
    model. Now, before you begin creating the CRUD methods, it is recommended that
    you create an error handling method for validation and other server errors.
  prefs: []
  type: TYPE_NORMAL
- en: The error handling method of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to handle Mongoose errors, it is preferable to write a simple error
    handling method that will take care of extracting a simple error message from
    the Mongoose error object and provide it to your controller methods. Go back to
    your `app/controllers/articles.server.controller.js` file and append the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `getErrorMessage()` method gets the Mongoose error object passed as an argument
    and then iterates over the error collection and extracts the first message. This
    is done because you don't want to overwhelm your users with multiple error messages
    at once. Now that you have error handling set up, it is time to write your first
    controller method.
  prefs: []
  type: TYPE_NORMAL
- en: The create() method of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `create()` method of the Express controller will provide the basic functionality
    to create a new article document. It will use the HTTP request body as the JSON
    base object for the document, and it will use the model `save()` method to save
    it to MongoDB. To implement the `create()` method, append the following lines
    of code to your `app/controllers/articles.server.controller.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over the `create()` method code. First, you created a new `Article`
    model instance using the HTTP request body. Next, you added the authenticated
    `passport` user as the article `creator`. Finally, you used the Mongoose instance
    `save()` method to save the article document. In the `save()` callback function,
    it is worth noticing how you return either an error response and an appropriate
    HTTP error code or the new `article` object as a JSON response. Once you''re done
    with the `create()` method, you will move on to implementing the read operation.
    The read operation consists of two methods: one that retrieves a list of articles
    and a second method that retrieves a particular article. Let''s begin with the
    method that lists a collection of articles.'
  prefs: []
  type: TYPE_NORMAL
- en: The list() method of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `list()` method of the Express controller will provide the basic functionality
    to retrieve a list of the existing articles. It will use the model''s `find()`
    method to retrieve all the documents in the article collection and then output
    a JSON representation of this list. To implement the `list()` method, append the
    following lines of code to your `app/controllers/articles.server.controller.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this controller method, note how you used the `find()` function of Mongoose
    to get the collection of article documents, and while we can add a MongoDB query
    of some sort, for now, we'll retrieve all the documents in the collection. Next,
    note how the article collection is sorted using the `created` property. Then,
    you can see how the `populate()` method of Mongoose was used to add some user
    fields to the `creator` property of the `articles` objects. In this case, you
    populated the `firstName`, `lastName`, and `fullName` properties of the `creator`
    user object.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the CRUD operations involve a manipulation of a single existing
    article document. You could, of course, implement the retrieval of the article
    document in each method by itself, basically repeating this logic. However, the
    Express router has a neat feature for the handling of route parameters, so before
    you'll implement the rest of your Express CRUD functionality, you'll first learn
    how to leverage the route parameter middleware to save some time and code redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: The read() middleware of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `read()` method of the Express controller will provide the basic functionality
    to read an existing article document from the database. Since you're writing a
    sort of RESTful API, the common usage of this method will be handled by passing
    the article's ID field as a route parameter. This means that your requests to
    the server will contain an `articleId` parameter in their paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Express router provides the `app.param()` method for the handling
    of route parameters. This method allows you to attach a middleware for all the
    requests containing the `articleId` route parameter. The middleware itself will
    then use the `articleId` provided to find the proper MongoDB document and add
    the retrieved `article` object to the request object. This will allow all the
    controller methods that manipulate an existing article to obtain the `article`
    object from the Express request object. To make this clearer, let''s implement
    the route parameter middleware. Go to your `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the middleware function signature contains all the Express middleware
    arguments and an `id` argument. It then uses the `id` argument to find an article
    and reference it using the `req.article` property. Note how the `populate()` method
    of the Mongoose model was used to add some user fields to the `creator` property
    of the `article` object. In this case, you populated the `firstName`, `lastName`,
    and `fullName` properties of the `creator` user object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you connect your Express routes, you''ll learn how to add the `articleByID()`
    middleware to different routes, but for now, let''s add the `read()` method of
    the Express controller, which will return an `article` object. To add the `read()`
    method, append the following lines of code to your `app/controllers/articles.server.controller.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Quite simple, isn't it? That's because you already took care of obtaining the
    `article` object in the `articleByID()` middleware, so now all you have to do
    is just output the `article` object as a JSON representation. We'll connect the
    middleware and routes in the next sections, but before we do that, let's finish
    implementing the Express controller CRUD functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The update() method of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `update()` method of the Express controller will provide the basic operations
    to update an existing article document. It will use the existing `article` object
    as the base object and then update the `title` and `content` fields using the
    HTTP request body. It will also use the model `save()` method to save the changes
    to the database. To implement the `update()` method, go to your `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `update()` method also makes the assumption that you already
    obtained the `article` object in the `articleByID()` middleware. So, all you have
    to do is update the `title` and `content` fields, save the article, and then output
    the updated `article` object as a JSON representation. In case of an error, it
    will output the appropriate error message using the `getErrorMessage()` method
    you wrote earlier and an HTTP error code. The last CRUD operation left to implement
    is the `delete()` method; so let's look at how you can add a simple `delete()`
    method to your Express controller.
  prefs: []
  type: TYPE_NORMAL
- en: The delete() method of the Express controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `delete()` method of the Express controller will provide the basic operations
    to delete an existing article document. It will use the model `remove()` method
    to delete the existing article from the database. To implement the `delete()`
    method, go to your `app/controllers/articles.server.controller.js` file and append
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see how the `delete()` method also makes use of the already obtained
    `article` object by the `articleByID()` middleware. So, all you have to do is
    invoke the Mongoose model's `remove()` method and then output the deleted `article`
    object as a JSON representation. In case of an error, it will output the appropriate
    error message using the `getErrorMessage()` method you wrote earlier and an HTTP
    error code instead.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just finished implementing your Express controller's CRUD
    functionality. Before you continue to wire the Express routes that will invoke
    these methods, let's take some time to implement two authorization middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an authentication middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building your Express controller, you probably noticed that most methods
    require your user to be authenticated. For instance, the `create()` method won''t
    be operational if the `req.user` object is not assigned. While you can check this
    assignment inside your methods, this will enforce you to implement the same validation
    code over and over. Instead, you can just use the Express middleware chaining
    to block unauthorized requests from executing your controller methods. The first
    middleware you should implement will check whether a user is authenticated at
    all. Since this is an authentication-related method, it would be best to implement
    it in the Express `users` controller, so go to the `app/controllers/users.server.controller.js`
    file and append the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `requiresLogin()` middleware uses the Passport-initiated `req.isAuthenticated()`
    method to check whether a user is currently authenticated. If it finds out that
    the user is indeed signed in, it will call the next middleware in the chain; otherwise,
    it will respond with an authentication error and an HTTP error code. This middleware
    is great, but if you want to check whether a specific user is authorized to perform
    a certain action, you will need to implement an article-specific authorization
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an authorization middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your CRUD module, there are two methods that edit an existing article document.
    Usually, the `update()` and `delete()` methods should be restricted so that only
    the user who created the article will be able to use them. This means that you
    need to authorize any request made to these methods to validate whether the current
    article is being edited by its creator. To do this, you will need to add an authorization
    middleware to your `Articles` controller, so go to the `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `hasAuthorization()` middleware uses the `req.articl`e and `req.user` objects
    to verify that the current user is the creator of the current article. This middleware
    also assumes that it gets executed only for requests that contain the `articleId`
    route parameter. Now that you have all your methods and middleware in place, it
    is time to wire the routes that enable their execution.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Express routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin wiring the Express routes, let''s do a quick overview of the
    RESTful API architectural design. The RESTful API provides a coherent service
    structure that represents a set of actions that you can perform on an application
    resource. This means that the API uses a predefined route structure along with
    the HTTP method name in order to provide context for HTTP requests. Though the
    RESTful architecture can be applied in different ways, a RESTful API usually complies
    with a few simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A base URI per resource, in our case, `http://localhost:3000/articles`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data structure, usually JSON, passed in the request body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usage of standard HTTP methods (for example, `GET`, `POST`, `PUT`, and `DELETE`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these three rules, you''ll be able to properly route HTTP requests to
    use the right controller method. So, your articles API will consist of five routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://localhost:3000/articles`: This will return a list of articles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST http://localhost:3000/articles` : This will create and return a new article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://localhost:3000/articles/:articleId`: This will return a single
    existing article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT http://localhost:3000/articles/:articleId`: This will update and return
    a single existing article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE http://localhost:3000/articles/:articleId`: This will delete and return
    a single article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you probably noticed, these routes already have corresponding controller
    methods. You even have the `articleId` route parameter middleware already implemented,
    so all that is left to do is implement the Express routes. To do that, go to the
    `app/routes` folder and create a new file named `articles.server.routes.js`. In
    your newly created file, paste the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you did several things. First, you required the
    `users` and `articles` controllers, and then you used the Express `app.route()`
    method to define the base routes for your CRUD operations. You used the Express
    routing methods to wire each controller method to a specific HTTP method. You
    may also notice how the `POST` method uses the `users.requiresLogin()` middleware,
    since a user needs to log in before they can create a new article. In the same
    way, the `PUT` and `DELETE` methods use both `users.requiresLogin()` and `articles.hasAuthorization()`
    middleware, since users can only edit and delete the articles they created. Finally,
    you used the `app.param()` method to make sure that every route that has the `articleId`
    parameter will first call the `articles.articleByID()` middleware. Next, you'll
    need to configure your Express application to load your new `Article` model and
    routes file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Express application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use your new Express assets, you have to configure your Express
    application to load your route file. To do that, go back to your `config/express.js`
    file and change it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is it; your article's RESTful API is ready! Next, you'll learn how simple
    it is to use the `HTTP` client to let your Angular components communicate with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Introduction to Angular"), *Introduction
    to Angular*, we mentioned the `http` client as a means of communication between
    the Angular 2 application and your backend API. Since the REST architecture is
    well structured, it would be quite easy to implement a service for our Angular
    module, which we'll provide to our components with an API in order to communicate
    with the server. To do that, the Angular http client utilizes the Observable pattern
    to deal with its asynchronous nature, so before we continue, it would be best
    to quickly review this powerful pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming and Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In programming, we mostly expect things to run in a serial way, where all of
    our instructions occur in an order. Alas, from its beginning, web application
    development suffered from a lack of synchronicity. This is especially a problem
    when dealing with data and, more specifically in our case, data that is retrieved
    from the server. To solve this issue, various different patterns were created,
    from which now we mostly use the callback and promise patterns. Callbacks were
    the go-to for most of JavaScript''s lifetime, and more recently, Promises started
    gaining some traction. However, Promises suffer from a short, onetime lifespan.
    To be more precise, a Promise can be set up and then can only be differed once,
    but our data can change over time, so we''ll need to create more and more promises.
    For instance, let''s say we want to track all the changes made to a text field
    and implement an ''undo'' functionality; to do that, we can use a callback to
    our text change event and then record all of the changes and do something with
    it. This might seem simple, but what if we have hundreds of objects or what if
    our text field value is changed programmatically? This is a very simplistic example,
    but this scenario repeats itself in various ways across modern application development,
    and to solve it, a new methodology has emerged, a methodology called Reactive
    Programming. You might have heard about reactive programming or you might have
    not, but the easiest way to understand it is to realize that it''s all about tracking
    asynchronous data that is changing over time, and the way it does this is by using
    Observables. Observables are streams of data that can be observed by one or multiple
    observers. An Observable emits values over time and notifies the "subscribed"
    observers with a new value, an error, or a completion event. A visual representation
    of this mechanism can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactive programming and Observables](img/B05071_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, you can see that the Observables keeps emitting value changes,
    an error, another value change, and then a completion event when the Observable
    finishes its life cycle. Reactive programming might seem complicated, but fortunately,
    the ReactiveX library allows us to deal with observables in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you continue reading about reactive programming, since
    it's rapidly becoming a dominant approach to modern web application development.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveX library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rx library is a cross-platform library that uses the observer pattern to
    help developers manage asynchronous data changes over time. Simply put, ReactiveX
    is a library that allows us to create and manipulate Observable objects. In Angular
    2 projects, we use the RxJS library, which is basically a JavaScript version of
    the ReactiveX library. If you look closely at the previous chapter, you''ll be
    able to see that we already set it up and even used it in our authentication service.
    We did that by installing it using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported it in our entities as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We had to do this because the Angular team chose to use Observables quite extensively.
    And one of our first encounters with it was using the http client.
  prefs: []
  type: TYPE_NORMAL
- en: Using the http client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `http` module provides us with a standardized way to communicate with our
    RESTful endpoints. To use the `http` client, we''ll have to import and inject
    it into our entities and then use our `http` client instance to perform different
    HTTP requests. A simple example of using the http client to perform a POST request
    was presented in [Chapter 7](ch07.html "Chapter 7. Introduction to Angular"),
    *Introduction to Angular*, where we used it in our signin method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created a JSON string and set the request headers using the
    `RequestOptions` object before we called the `http` client `post()` methods. The
    `http` client method returns an Observable object that tracks an HTTP Response
    object. But since we want our service to provide data, we used the `map()` method
    to extract the response JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to use the `json()` method since Angular follows the ES2015 specification
    for the HTTP response object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we also catch any error using our `handleError()` method. So how
    do we use the Observable object returned from this method? If you look back at
    our `signin` component, you''ll be able to see how we used our authentication
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we called the authentication service's signin method and then
    subscribed to the returned Observable. We then handled any value event with the
    first arrow function and any error with the second arrow function. That's basically
    the way we work the HTTP client!
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP client offers various methods to handle different HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request(url, options)`: This method allows us to perform any HTTP request
    defined by the options object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: This method performs a `GET` HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post()`: This method performs a `POST` HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put()`: This method performs a `PUT` HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete()`: This method performs a `DELETE` HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods return a Response Observable object that can be subscribed
    or manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important thing to notice is that the HTTP client always returns a "cold"
    observable. This means that the request itself will not be sent until someone
    subscribes to the observable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn how to use the `http` client to communicate
    with your Express API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Angular module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second part of your CRUD module is the Angular module. This module will
    contain an Angular service that will communicate with the Express API using the
    `http` client, an Angular Article component that will contain four subcomponents
    with a set of templates that provide your users with an interface to perform CRUD
    operations. Before you begin creating your Angular entities, let''s first create
    the initial module structure. Go to your application''s `public/app` folder and
    create a new folder named `articles`. In this new folder, create the module file
    named `articles.module.ts` and paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we simply imported the modules we needed from the Angular packages
    and the components, service, and routes definition of our new module. Next, we
    created a new Angular module that imports the Angular modules and our routing
    configuration as a child router and then declares our new module components. Now,
    we can continue by creating our main component file. To do that, create a file
    named `articles.component.ts` inside your `public/app` folder and paste the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: import { Component } from '@angular/core';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we imported the basic Angular modules and the articles service
    we''ll shortly create. We then created a new component that uses `router-outlet`
    and injects our service. Next, we''ll need to create a routing configuration for
    our `articles` component. To do that, create a file named `articles.routes.ts`
    and paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we simply created a routing configuration for our component
    and its subcomponents. The code should be familiar, since it resembles the authentication
    routing we implemented in the previous chapter. Moreover, in our update and view
    paths, we defined a URL parameter in the form of a colon followed by the name
    of our parameter, in this case, the `articleId` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll need to import our articles module in our application module
    configuration. To do that, go back to your `public/app/app.module.ts` file and
    change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the configuration of our new module. Now we can move on to creating
    our module entities. We'll begin with our module service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Angular module service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for your CRUD module to easily communicate with the API endpoints,
    it is recommended that you use a single Angular service that will utilize the
    `http` client methods. To do that, go to your `public/app/articles` folder and
    create a new file named `articles.service.ts` with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's review this. First, we imported the `Observable` and `rxjs` library module.
    You might notice that we import the entire library, since we'll need to use various
    operators with our Observable object, for instance, the `map()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we imported the modules we needed from the Angular library and created
    our injectable service using the `@Injectable` decorator. Our service has one
    property to hold our API base URL and a constructor to inject the HTTP client.
    It contains an error handling method that deals with server errors. Our other
    methods are quite easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create()`: Accepts an article object and sends it to the server using an HTTP
    POST request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read()`: Accepts an `article ID` string and asks for an article object from
    the server using an HTTP GET request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update ()`: Accepts an article object and sends it to the server for an update
    using an HTTP PUT request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete()`: Accepts an `article ID` string and tries to delete it using an
    HTTP DELETE request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list()`: Requests for an array of article objects using an HTTP GET request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note how we map the response object to only send the JSON object and how we
    catch any error to modify the response so that our components will only have to
    deal with the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Our module infrastructure is ready for our subcomponents. In the
    next sections, you'll be able to see how easy our implementation becomes using
    our previous preparations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Create subcomponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our "Create" subcomponent will be taking care of creating new articles. Begin
    by creating a new folder named `create` inside your `public/app/articles` folder.
    In this folder, create a new file named `create.component.ts` and paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's review this. We started by importing the modules we need from the Angular
    library along with our `ArticlesService`. Then, we created our component with
    an empty article and `errorMessage` objects. Note how our Component's constructor
    injects the `Router` and our `ArticlesService` services. Then, we created a `create()`
    method that uses `ArticlesService` to create a new article object. In our observable
    subscription, we use the `Router` service to navigate to our View components along
    with the newly created `article ID`. In case of an error, we set our component's
    `errorMessage` property to the message. To finish up with our subcomponent, we'll
    need to create its template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `create` template will provide your user with an interface to create a
    new article. It will contain an HTML form and it will use your component''s `create`
    method to save the new article. To create your template, go to the `public/app/articles/create`
    folder and create a new file named `create.template.html`. In your new file, paste
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `create` template contains a simple form with two text input fields and
    a submit button. The text fields use the `ngModel` directive to bind the user
    input to our component's properties. It is also important to note the `ngSubmit`
    directive you placed in the `form` element. This directive tells Angular to call
    a specific component method when the form is submitted. In this case, the form
    submission will execute your component's `create()` method. The last thing you
    should notice is the error message at the end of the form that will be shown in
    case of any error. Next, we're going to implement the View subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the View subcomponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our "View" subcomponent will be taking care of presenting a single article.
    Our component will also contain a set of buttons that are visible only to the
    article creator, which will allow the creator to delete the article or navigate
    to the `edit` route. Begin by creating a new folder named `view` inside your `public/app/articles`
    folder. In this folder, create a new file named `view.component.ts` and paste
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We started by importing the modules we need from the Angular library along with
    our `ArticlesService` and `AuthenticationService`. Then, we created our component
    with an article property, a `currentUser` property, a `paramsObserver` property,
    an `allowEdit` flag, and an `errorMessage` property. Note how our component's
    constructor injects `Router`, `RouteParams`, and our `ArticlesService` and `AuthenticationService`
    services. Our constructor also sets the `currentUser` property using the `AuthenticationService`
    instance. In our `ngOnInit` method, which is being invoked when the component
    is initialized, we read the `article ID` parameter from the route parameters,
    and then we use the `ArticlesService` to fetch an existing article. We do this
    using `ActivatedRoute`, which supplies us with a `params` Observable. We unsubscribe
    to this Observable on our component's `ngOnDestroy` method. In our Observable
    subscription, we set the component's `article` property and determine whether
    the current user can edit the article. In case of an error, we use the `Router`
    service to navigate back to our `List` route. Lastly, we implemented a `delete()`
    method that uses `ArticlesService` to delete the viewed article and go back to
    the article list. To finish up with our subcomponent, we'll need to create its
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `view` template will provide your user with an interface to `view` an existing
    article. Your template will also contain a set of buttons only visible to the
    article creator, which will allow the creator to delete the article or navigate
    to the `edit` route. To create the template, go to the `public/app/articles/view`
    folder and create a new file named `view.template.html`. In your new file, paste
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `view` template contains a simple set of HTML elements presenting the article
    information using the `double curly braces` syntax. It is also important to note
    how you used the `ngIf` directive to present the article edit link and delete
    button only to the creator of the article. The edit link will direct the user
    to the `edit` subcomponent, while the delete button will call the `delete()` method
    of your controller. Next, we'll implement our edit component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Edit subcomponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our "Edit" subcomponent will be taking care of editing existing articles. Begin
    by creating a new folder named `edit` inside your `public/app/articles` folder.
    In this folder, create a new file named `edit.component.ts` and paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, we started by importing the modules we need from the Angular library
    along with our `ArticlesService`. Then, we created our component with an article
    property and an `errorMessage` property. In our constructor, we read the `article
    ID` from the route parameters and then we used `ArticlesService` to fetch an existing
    article. In our Observables subscription, we set the component's article property,
    and in case of an error, we use the `Router` service to navigate back to our List
    route. Lastly, we implemented an `update()` method that uses `ArticlesService`
    to update the viewed article and go back to the View route. To finish up with
    our subcomponent, we'll need to create its template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `edit` template will provide your user with an interface to update an existing
    article. It will contain an HTML form and it will use your component''s `update()`
    method to save the updated article. To create this template, go to the `public/app/articles/edit`
    folder and create a new file named `edit.template.html`. In your new file, paste
    the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `edit` template contains a simple form with two text input fields and a
    submit button. The text fields use the `ngModel` directive to bind the user input
    to the component's `article` property. It is also important to note the `ngSubmit`
    directive you placed in the `form` element. This time, the directive tells Angular
    that the form submission should execute your component's `update()` method. The
    last thing you should notice is the error message at the end of the form, which
    will be shown in the case of an editing error. Our final subcomponent is our List
    subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the List subcomponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our "List" subcomponent will be taking care of presenting a list of articles.
    We''ll begin by creating a new folder named `list` inside our `public/app/articles`
    folder. In this folder, create a new file named `list.component.ts` and paste
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We started by importing the modules we need from the Angular library along with
    our `ArticlesService`. Then, we created our component with an articles property
    and an `errorMessage` property. Note how our component's constructor injects `ArticlesService`
    and uses it to fetch a list of articles. Inside our Observables subscription,
    we set the component's articles property. Now all we have left to do is implement
    the component's template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `list` templatewill provide your user with an interface to view the list
    of existing articles. Our template will use the `ngFor` directive to render a
    list of HTML elements, each representing a single article. If there aren''t any
    existing articles, the view will offer the user to navigate to the `create` route.
    To create your view, go to the `public/app/articles/list` folder and create a
    new file named `list.template.html`. In your new file, paste the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `list` template contains a simple set of repeating HTML elements that represent
    the list of articles. It uses the `ngFor` directive to duplicate the list item
    for every article in the collection and displays each article's information. We
    then used `routerLink` to link to a single article view. It is also important
    to note how we used the `ngIf` directive to ask the user to create a new article
    in case there are no existing articles.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing your Angular subcomponents, you practically finished your first
    CRUD module! All that is left to do is provide the user with links to our new
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To finish our implementation, it would be great to provide the user with links
    to your new CRUD module routes. To do that, go to your `public/app/home/home.template.html`
    file and change it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This change will present our users with links to the new `Articles` component
    routes only when they''re logged in and hide it when they''re not. This is it!
    Everything is ready for you to test your new CRUD module. Use your command-line
    tool and navigate to the MEAN application''s root folder. Then, run your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once your application is running, use your browser and navigate to `http://localhost:3000`.
    You will see the sign-up and sign-in links; try to sign in and watch how the home
    view changes. Then, try to navigate to the `http://localhost:3000/articles` URL
    and see how the `list` component suggests that you create a new article. Continue
    to create a new article and try to edit and delete it using the components you
    created previously. Your CRUD module should be fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build your first CRUD module. You started
    by defining the Mongoose model and Express controller and learned how to implement
    each CRUD method. You also authorized your controller methods using Express middleware.
    Then, you defined a RESTful API for your module methods. You learned a bit about
    reactive programming and the observer pattern. You used the HTTP client to communicate
    with your API. Then, you created your Angular components and implemented the Angular
    CRUD functionality. After connecting the four parts of a MEAN application and
    creating your first CRUD module, in the next chapter, you'll use Socket.io in
    order to add real-time connectivity between your server and client applications.
  prefs: []
  type: TYPE_NORMAL
