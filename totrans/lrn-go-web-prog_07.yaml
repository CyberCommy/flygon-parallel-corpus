- en: Chapter 7. Microservices and Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is beginning to get a little more real now. In the previous
    chapter, we added some APIs and client-side interfaces to them.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices have become very hot in the last few years, primarily because
    they reduce the developmental and support weight of a very large or monolithic
    application. By breaking apart these monoliths, microservices enable a more agile
    and concurrent development. They can allow separate teams to work on separate
    parts of the application without worrying too much about conflicts, backwards
    compatibility issues, or stepping on the toes of other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll introduce microservices and explore how Go can work within
    them, to enable them and even drive their central mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum this all up, we will be covering the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservice approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros and cons of utilizing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the heart of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating between microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting a message on the wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from another service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the microservice approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've not yet encountered the term microservice or explored its meaning
    in depth, we can very quickly demystify it. Microservices are, in essence, independent
    functions of an overall application being broken apart and made accessible via
    some universally known protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice approach is, usually, utilized to break apart a very large
    monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your standard web application in the mid-2000s. When new functionality
    is needed, let's say a function that emails new users, it's added directly to
    the codebase and integrated with the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: As the application grows, so does the necessary test coverage. So, it increases
    the potential for critical errors too. In this scenario, a critical error doesn't
    just bring down that component, in this case the e-mailing system; it takes down
    the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a nightmare to track down, patch, and re-deploy, and it's exactly
    the type of nightmare that microservices were designed to address.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the e-mailing part of the application is separated into its own app, it
    has a level of isolation and insulation that makes finding problems much easier.
    It also means that the entire stack doesn''t fall down just because someone introduced
    a critical error into one small part of the whole app, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the microservice approach](img/B04294_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider the following basic example architecture, where an application is split
    into four separate concepts, which represent their own applications in the microservices
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Once, every single piece existed in its own application; now they are broken
    apart into smaller and more manageable systems. Communication between the applications
    happens via a message queue utilizing REST API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of utilizing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If microservices seem like a panacea at this point, we should also note that
    this approach does not come without its own set of issues. Whether the tradeoff
    is worth it or not depends heavily on an overall organizational approach.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, stability and error detection comprise a big production-level
    win for microservices. But if you think of the flip side of applications not breaking,
    it could also mean that issues go hidden for longer than they otherwise would.
    It's hard to ignore the entire site being down, but it could be hours before anyone
    realizes that e-mails have not been sent, unless some very robust logging is in
    place.
  prefs: []
  type: TYPE_NORMAL
- en: But there are other big pros to microservices. For one, utilizing an external
    standard communication protocol (REST, for example) means that you're not locked
    into a single language.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, some part of your application can be written better in Node
    than in Go, you can do that without having to rewrite an entire application. This
    is a frequent temptation for developers: rewriting the whole thing because the
    new and shiny language app or feature is introduced. Well, microservices safely
    enable this behavior—it allows a developer or a group of developers to try something
    without needing to go deeper than the specific function they wish to write.'
  prefs: []
  type: TYPE_NORMAL
- en: This, too, comes with a potentially negative scenario—since the application
    components are decoupled, so can the institutional knowledge around them be decoupled.
    Few developers may know enough to keep the service operating ideally. Other members
    of the group may lack the language knowledge to jump in and fix critical errors.
  prefs: []
  type: TYPE_NORMAL
- en: One final, but important, consideration is that microservice architecture generally
    means a distributed environment by default. This leads us to the biggest immediate
    caveat, which is the fact that this situation almost always means that eventual
    consistency is the name of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Since every message must depend on multiple external services, you're subject
    to several layers of latency to get a change enacted.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the heart of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering about one thing as you consider this system to design
    dissonant services that work in congress: what''s the communication platform?
    To answer this, we''ll say there is an easy answer and a more intricate one.'
  prefs: []
  type: TYPE_NORMAL
- en: The easy answer is REST. This is great news, as you're likely to be well versed
    in REST or you at least understand some portion of it from [Chapter 5](ch05.html
    "Chapter 5. Frontend Integration with RESTful APIs"), *Frontend Integration with
    RESTful APIs*. There we described the basics of API communication utilizing RESTful,
    stateless protocols and implementing HTTP verbs as actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which leads us to the more complex answer: not everything in a large or involved
    application can operate on REST alone. Some things require state or at least some
    level of long-lasting consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: For the latter problem, most microservice architectures are centered on a message
    queue as a platform for information sharing and dissemination. A message queue
    serves as a conduit to receive REST requests from one service and holds it until
    another service retrieves the request for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of approaches to communicate between microservices, as mentioned;
    REST endpoints provide a nice landing pad for messages. You may recall the preceding
    graphic, which shows a message queue as the central conduit between services.
    This is one of the most common ways to handle message passing and we'll use RabbitMQ
    to demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we'll show when new users register to an e-mail queue for the
    delivery of a message in our RabbitMQ installation, which will then be picked
    up by an emailing microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about RabbitMQ, which utilizes **Advanced Message Queuing
    Protocol** (**AMQP**) here: [https://www.rabbitmq.com/](https://www.rabbitmq.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: To install an AMQP client for Go, we'll recommend Sean Treadway's AMQP package.
    You can install it with a `go get` command. You can get it at [github.com/streadway/amqp](http://github.com/streadway/amqp)
  prefs: []
  type: TYPE_NORMAL
- en: Putting a message on the wire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of approaches to use RabbitMQ. For example, one allows multiple
    workers to accomplish the same thing, as a method for distributing works among
    available resources.
  prefs: []
  type: TYPE_NORMAL
- en: Assuredly, as a system grows, it is likely to find use for that method. But
    in our tiny example, we want to segregate tasks based on a specific channel. Of
    course, this is not analogous to Go's concurrency channels, so keep that in mind
    when you read about this approach.
  prefs: []
  type: TYPE_NORMAL
- en: But to explain this method, we may have separate exchanges to route our messages.
    In our example, we might have a log queue where messages are aggregated from all
    services into a single log location, or a cache expiration method that removes
    cached items from memory when they're deleted from the database.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, though, we'll implement an e-mail queue that can take a message
    from any other service and use its contents to send an e-mail. This keeps all
    e-mail functionality outside of core and supportive services.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in [Chapter 5](ch05.html "Chapter 5. Frontend Integration with RESTful
    APIs"), *Frontend Integration with RESTful APIs*, we added register and login
    methods. The one we're most interested in here is `RegisterPOST()`, where we allowed
    users to register to our site and then comment on our posts.
  prefs: []
  type: TYPE_NORMAL
- en: It's not uncommon for newly registered users to get an e-mail, either for confirmation
    of identity or for a simple welcome message. We'll do the latter here, but adding
    confirmation is trivial; it's just a matter of producing a key, delivering via
    e-mail and then enabling the user once the link is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're using an external package, the first thing we need to do is import
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that here we've included `text/template`, which is not strictly necessary
    since we have `html/template`, but we've noted here in case you wish to use it
    in a separate process. We have also included `bufio`, which we'll use as part
    of the same templating process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of sending an e-mail, it will be helpful to have a message and
    a title for the e-mail, so let''s declare these. In a production environment,
    we''d probably have a separate language file, but we don''t have much else to
    show at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These simply represent the e-mail variables we need to utilize when we have
    a successful registration.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're putting a message on the wire and yielding some responsibility for
    the application's logic to another service, for now we'll only need to ensure
    that our message has been received by RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll need to connect to the queue, which we can pass either by reference
    or reconnect with each message. Generally, you'll want to keep the connection
    in the queue for a long time, but you may choose to reconnect and close your connection
    each time while testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do so, we''ll add our MQ host information to our constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a connection, we''ll use the somewhat familiar `TCP Dial()`
    method, which returns an MQ connection. Here is our function for connecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can choose to pass the connection by reference or sustain it as a global
    with all applicable caveats considered here.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read a bit more about RabbitMQ connections and detecting disrupted connections
    at [https://www.rabbitmq.com/heartbeats.html](https://www.rabbitmq.com/heartbeats.html)
  prefs: []
  type: TYPE_NORMAL
- en: Technically, any producer (in this case our application) doesn't push messages
    to the queue; rather, it pushes them to the exchange. RabbitMQ allows you to find
    exchanges with the `rabbitmqctl` `list_exchanges` command (rather than `list_queues`).
    Here, we're using an empty exchange, which is totally valid. The distinction between
    a queue and an exchange is non-trivial; the latter is responsible for having defined
    the rules surrounding a message, en route to a queue or queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `RegisterPOST()`, let''s send a JSON-encoded message when a successful
    registration takes place. We''ll want a very simple `struct` to maintain the data
    we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll create a new `RegistrationData struct` if, and only if, the registration
    process succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we''ll need the function that actually sends our data, `MQPublish()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reading from another service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've sent a message to our message queue in our app, let's use another
    microservice to pluck that from the queue on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the flexibility of a microservice design, our secondary service
    will be a Python script that connects to the MQ and listens for messages on the
    e-mail queue, when it finds one. It will parse the message and send an e-mail.
    Optionally, it could publish a status message back on the queue or log it, but
    we won''t go down that road for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at experimenting with utilizing microservices as
    a way to dissect your app into separate domains of responsibility. In this example,
    we delegated the e-mail aspect of our application to another service written in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: We did this to utilize the concept of microservices or interconnected smaller
    applications as callable networked functions. This ethos is driving a large part
    of the Web of late and has myriad benefits and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: In doing this, we implemented a message queue, which operates as the backbone
    of our communications system, allowing each component to speak to the other in
    a reliable and repeatable way. In this case, we used a Python application to read
    messages sent from our Go application across RabbitMQ and take that e-mail data
    and process it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html "Chapter 8. Logging and Testing"), *Logging and Testing*,
    we'll focus on logging and testing, which we can use to extend the microservices
    concept so that we can recover from errors and understand where things might go
    awry in the process.
  prefs: []
  type: TYPE_NORMAL
