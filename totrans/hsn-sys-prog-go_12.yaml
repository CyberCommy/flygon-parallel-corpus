- en: Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover network programming. This will allow our applications
    to communicate with other programs that are running on any remote computer, on
    the same local network, or even on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with some theory about network and architectures. We will then
    discuss socket-level communication and explain how to create a web server. Finally,
    we will discuss how the Go built-in template engine works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, you can refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it requires OpenSSL to be installed on your machine. Many Linux
    distributions are already shipped with some OpenSSL versions. It can also be installed
    on Windows, using the official installer or a third-party package manager, such
    as Chocolatey or Scoop.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating via networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication between applications can happen through a network, even if the
    applications are on the same machine. In order to transfer information, they need
    to establish a common protocol that specifies what happens all the way from the
    application to the wire.
  prefs: []
  type: TYPE_NORMAL
- en: OSI model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Open Systems Interconnect** (**OSI**) model is a theoretical model that
    dates back to the early 1970s. It defines a standard of communication that works
    regardless of the physical or technical structure of a network, with the goal
    of providing interoperability for different networks.
  prefs: []
  type: TYPE_NORMAL
- en: The model defines seven different layers, numbered from one to seven, and each
    layer has a higher level of abstraction to the previous one. The first three layers
    are often referred to as **media layers**, while the other four are the **host
    layers**. Let's examine each, one by one, in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 1 – Physical layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first layer of the OSI model is the physical one, which is in charge
    of the transmission of unprocessed data from a device, similar to an Ethernet
    port, and its transmission medium, such as an Ethernet cable. This layer defines
    all the characteristics that are related to the physical/material nature of the
    connection—size, shape, voltages of the connector, frequencies, and timings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect defined by the physical layer is the direction of the transmission,
    which can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplex**: The communication is one way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half duplex**: The communication is two way, but the communication happens
    only in one direction at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full duplex**: Two way-communication, where both ends can communicate at
    the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many well-known technologies, including Bluetooth and Ethernet, include a definition
    of the physical layer they are using.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2 – Data link layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next layer is the data link, which defines how the data transfer should
    happen between two nodes that are directly connected. It is responsible for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Detection of communication errors in the first layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correction of the physical errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control of the flow/transmission rate between nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-world examples of data link layers definition are the ones for Ethernet
    (802.3) and Wi-Fi (802.11).
  prefs: []
  type: TYPE_NORMAL
- en: Layer 3 – Network layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network layer is the next layer, and it focuses on sequences of data, called
    packets, that can have a variable length. A packet is transmitted from one node
    to another, and these two nodes could be located on the same network or on different
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: This layer defines the network as a series of nodes connected to the same medium,
    identified by the previous two layers. The network is capable of delivering a
    message, knowing only its destination address.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 4 – Transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth layer is transport, which ensures that packets go from sender to
    receiver. This is achieved with **acknowledgement** (**ACK**) and **negative-acknowledgement**
    (**NACK**) messages from the destination, which can trigger a repetition of the
    messages, until they are received correctly. There are also other mechanisms in
    play, such as splitting a message into chunks for transmission (segmentation),
    reassembling the parts in a single message (desegmentation), and checking if the
    data was sent and received successfully (error control).
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model specifies five different transport protocols—TP0, TP1, TP2, TP3,
    and TP4\. TP0 is the simplest one, which executes only the segmentation and reassembly
    of messages. The other classes add other functionalities on top of it—for instance,
    retransmission or timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 5 – Session layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fifth layer introduces the concept of sessions, which is the temporary interactive
    exchange of information between two computers. It is responsible for creating
    connections and terminating them (while keeping track of the sessions) and allowing
    checkpointing and recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 6 – Presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The penultimate layer is the presentation layer, which takes care of syntax
    and semantics between applications, through dealing with complex data representation.
    It allows the last layer to be independent from the encoding used to represent
    the data. The presentation of the OSI model used ASN.1 encoding, but there is
    a wide range of different presentation protocols that are widely used, such as
    XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 7 – Application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last layer, the application layer, is the one that communicates with the
    application directly. The application is not considered as a part of the OSI model
    and the layer is responsible for defining the interfaces used by the applications. It
    includes protocols such as FTP, DNS, and SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP – Internet protocol suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Transmission Control Protocol/Internet Protocol** (**TCP/IP**), or internet
    protocol suite, is another model composed by fewer layers than the OSI, and it
    is a model that has been widely adopted.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 1 – Link layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first layer is the link layer, a combination of OSI's physical and data
    links, and it defines how the local networking communications will happen by specifying
    a protocol, such as MAC (which includes Ethernet and Wi-Fi).
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2 – Internet layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The internet layer is the second layer, and it can be compared to the OSI's
    network. It defines a common interface that allows different networks to communicate
    effectively without any awareness of the underlying topology of each one of them.
    This layer is responsible for communications between the nodes in a **Local Area
    Network** (**LAN**) and the global interconnected networks that compose the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 3 – Transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third layer is similar to the fourth OSI layer. It handles the end-to-end
    communication of two devices and it also takes care of the error check and recovery,
    leaving the upper layer unaware of the complexity of the data. It defines two
    main protocols—TCP, which allows the receiver to get the data in the correct sequence
    by using an acknowledgement system, and a **User Data Protocol** (**UDP**), which
    does not apply error control or acknowledgement from the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Layer 4 – Application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last layer, the application layer, sums up the last three levels of OSI—session,
    presentation, and application. This layer defines the architecture used by the
    applications, such as peer-to-peer or client and server, and the protocols used
    by the applications, such as SSH, HTTP, or SMTP. Each process is an address with
    a virtual endpoint of communication called *port*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding socket programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library allows us to easily interact with the transport layer,
    using both TCP and UDP connections. In this section, we will look at how to expose
    a service using a socket and how to look it up and use it from another application.
  prefs: []
  type: TYPE_NORMAL
- en: Network package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools needed to create and handle a TCP connection are located inside the
    `net` package. The main interface of the package is `Conn`, which represents a
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has four implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPConn`: Raw connection that uses the IP protocol, the one that TCP and UDP
    connection are built on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCPConn`: An IP connection that uses the TCP protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UDPConn`: An IP connection that uses the UDP protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnixConn`: A Unix domain socket, where the connection is meant for processes
    on the same machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we are going to look at how to use both TCP and UDP
    differently, and also how to use an IPConn to implement a custom implementation
    of a communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: TCP connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP is the protocol that is most used on the internet, and it enables delivery
    of data (bytes) that are ordered. The main focus of this protocol is reliability,
    which is obtained by establishing a two-way communication, where the receiver
    sends an acknowledgement signal each time it receives a datagram successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new connection can be created using the `net.Dial` function. It is a generic
    function that accepts different networks, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tcp`, `tcp4` (IPv4-only), `tcp6` (IPv6-only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udp`, `udp4` (IPv4-only), `udp6` (IPv6-only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip`, `ip4` (IPv4-only), `ip6` (IPv6-only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix` (socket stream), `unixgram` (socket datagram), and `unixpacket` (socket
    packet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A TCP connection can be created, specifying the `tcp` protocol, together with
    the host and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A more direct way of creating a connection is `net.DialTCP`, which allows you
    to specify both a local and remote address. It requires you to create a `net.TCPAddr`
    in order to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to receive and handle connections, there is another interface, `net.Listener`,
    which has four different implementations—one per connection type. For connections,
    there is a generic `net.Listen` function and a specific `net.ListenTCP` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to build a simple application that creates a TCP listener and connects
    to it, sending whatever comes from the standard input. The app should create a
    listener to start a connection in the background, which will send standard input
    to the connection, then accept it, and handle it. We will use the newline character
    as the delimiter for messages. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection creation is pretty simple. It creates the connection and reads
    messages from the standard input and forwards them to the connection by writing
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our use case, the connection that sends data will be closed with a special
    message, `\q`, which will be interpreted as a command. Accepting a connection
    in the listener creates another connection that represents the ones obtained by
    the dialing operation. The connection created by the listener will be receiving
    the messages from the dialing one and acting accordingly. It will interpret a
    special message, such as`\q`, with a specific action; otherwise, it will just
    print the message on screen, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example creates both a client and server in one application,
    but it could be easily split into two apps—a server (capable of handling more
    connections at once) and a client, creating a single connection to the server.
    The server will have an `Accept` loop that handles the received connection on
    a separate goroutine. The `handleConn` function is the same as we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The client will create the connection and send messages. `createConn` will
    be the same as we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the separated client and server, it's possible to test what happens when
    the client or server closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: UDP connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP is another protocol that is widely used on the internet. It focuses on low
    latency, which is why it is not as reliable as TCP. It has many applications,
    from online gaming, to media streaming, and **Voice over Internet Protocol** (**VoIP**).
    In UDP, if a packet is not received, it is lost and will not be sent back again
    as it would be in TCP. Imagine a VoIP call, where if there's a connection problem
    you will lose part of the conversation, but when you resume, you keep communicating
    almost in real time. Using TCP for this kind of application could result in latency
    accumulating for every packet loss—making the conversation impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we'll create a client and a server application. The
    server will be some sort of echo, sending back the message received from the client,
    but it will also reverse the message content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client will be pretty similar to the TCP one, with some exceptions—it will
    use the `net.ResolveUDPAddr` function to get the address and it will use `net.DialUDP`
    to get the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will be pretty different from the TCP one. The main difference is
    that with TCP, we have a listener that accepts different connections, which are
    handled separately; meanwhile, the UDP listener is a connection. It can receive
    data blindly or use the `ReceiveFrom` method that will also return the recipient''s
    address. This can be used in the `WriteTo` method to answer, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Encoding and checksum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a good practice to set some form of encoding between the clients and
    the server, and even better practice if the encoding includes a checksum to verify
    data integrity. We could improve the example from the last section with a custom
    protocol that does both encoding and checksum. Let''s start by defining the encoding
    function, where a given message will return the following byte sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Byte sequence** |'
  prefs: []
  type: TYPE_TB
- en: '| The first four bytes will follow a sequence | `2A 00 2A 00` |'
  prefs: []
  type: TYPE_TB
- en: '| Two bytes will be the message length stored using Little Endian order (least
    significant byte first) | `08 00` |'
  prefs: []
  type: TYPE_TB
- en: '| Four bytes for data checksum | `00 00 00 00` |'
  prefs: []
  type: TYPE_TB
- en: '| Followed by the raw message | `0F 1D 3A FF ...` |'
  prefs: []
  type: TYPE_TB
- en: '| Closing with the same starting sequence | `2A 00 2A 00` |'
  prefs: []
  type: TYPE_TB
- en: 'The `Checksum` function will be calculated by summing the message content,
    using a group of five bytes in Little Endian (least significant byte first), adding
    any spare byte left one by one, and then taking the first four bytes of the sum
    as a Little Endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a function that will encapsulate the message using the protocol
    we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need another function that does the opposite, checking whether a message
    is valid and extracting its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use them for encoding and decoding messages. For instance, we could
    improve the UDP client and server from the previous section and we could encode
    when sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can decode the bytes received for incoming messages in order to extract
    the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to verify that the content we received is valid, we are using the `MessageContent`
    utility function defined previously. This will check for headers, length, and
    checksum. It will only extract the bytes that compose the message.
  prefs: []
  type: TYPE_NORMAL
- en: Web servers in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Go's biggest and most successful applications is the creation of web
    servers. In this section, we will see what a web server actually is, how the HTTP
    protocol works, and how to implement a web server application using both the standard
    library and third-party packages.
  prefs: []
  type: TYPE_NORMAL
- en: Web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web server application is software that can serve content using the HTTP
    protocol (and some other related ones) over a TCP/IP network. There are many well-known
    web server applications, such as Apache, NGINX, and Microsoft IIS. Common server
    use case scenarios include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serving static files, such websites and related resources**: HTML pages,
    images, style sheets, and scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exposing a web application**: An application that runs in the server with
    an HTML-based interface, which requires a browser to access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exposing a web API**: Remote interfaces that are not used by the user but
    from other applications. Refer to [Chapter 1](27b19b4d-7890-4fdc-9619-5204d0a7a60d.xhtml), *An
    Introduction to System Programming*, for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP protocol is the cornerstone of a web server. Its design started in
    1989\. The main usage of HTTP is the request and response paradigm, where the
    client sends a request and the server returns back a response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Locators** (**URLs**) are unique identifiers for an HTTP
    request, and they have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol | `http` |'
  prefs: []
  type: TYPE_TB
- en: '| `://` | `://` |'
  prefs: []
  type: TYPE_TB
- en: '| Host | `www.website.com` |'
  prefs: []
  type: TYPE_TB
- en: '| Path | `/path/to/some-resource` |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | `?` |'
  prefs: []
  type: TYPE_TB
- en: '| Query (optional) | `query=string&with=values` |'
  prefs: []
  type: TYPE_TB
- en: 'From the preceding table, we can derive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There are several different protocols beside HTTP and its encrypted version
    (HTTPS), such as the **File Transfer Protocol** (**FTP**) and its secure counterpart,
    the **SSH File Transfer Protocol** (**S****FTP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The host could either be an actual IP or a hostname. When a hostname is selected,
    there is another player, a **Domain Name Server** (**DNS**), that acts as a phonebook
    between hostname and physical addresses. The DNS translates hostnames to IPs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path is the resource desired in the server and it is always absolute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query string is something added to a path after a question mark. It is a
    series of key value pairs in the form `key=value` and they are separated by an `&`
    sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP is a textual protocol and it contains some of the elements of the URL and
    some other information—method, headers, and body.
  prefs: []
  type: TYPE_NORMAL
- en: The request body is the information sent to server, such as form values, or
    uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Headers are metadata relative to the request, one per line, in a `Key: Value;
    extra data` form. There is a list of defined headers with specific functions,
    such as `Authorization`, `User-Agent`, and `Content-Type`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some methods express the action to execute on a resource. These are the most
    commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: A representation of the selected resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: Similar to `GET`, but without any response body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Submits a resource to the server, usually a new one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Submits a new version of a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Removes a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Requests specific change to a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what an HTTP request would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is a space separated triplet: method—path—protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's followed by one line per header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One empty line as separator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional request body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each request, there is a response that has a structure that is pretty similar
    to an HTTP request. The only part that differs is the first line that contains
    a different space-separated triplet: HTTP version—status code—reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The status code is an integer that represents the outcome of the request. There
    are four main status categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`100`: Information/request was received and will have further processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200`: A successful request; for instance, `OK 200` or `Created 201`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`300`: A redirection to another URL, temporary or permanent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`: A client-side error, such as `Not Found 404` or `Conflict 409`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: A server-side error, such as `Internal Server Error 503`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a what an HTTP response would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/2 and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most commonly used version of HTTP is HTTP/1.1 , dated 1997\.  In 2009, Google
    started a new project to create a faster successor to HTTP/1.1, named SPDY. This
    protocol eventually became what is now a version 2.0 of the **Hypertext Transfer
    Protocol**, **HTTP/2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is built in a way that existing web applications work, but there are new
    features for applications that are using the new protocol, including a faster
    communication speed. Some of the differences include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is binary (HTTP/1.1 is textual).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is fully multiplexed, and can request data in parallel, using one TCP connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses header compression to reduce overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servers can push responses to the client, instead of being asked by clients
    periodically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a faster protocol negotiation—thanks to the **Application Layer Protocol
    Negotiation** (**ALPN**) extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 is supported by all major modern browsers. Go version 1.6 included transparent
    support for HTTP/2 and version 1.8 introduced the ability to push responses from
    the server to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now see how to create a web server in Go, using the standard package.
    Everything is contained in the `net/http` package, which exposes a series of functions
    for making HTTP requests and creating HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Making a HTTP request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The package exposes a `http.Client` type that can be used to make requests.
    If the requests are simple `GET` or `POST`, then there are dedicated methods.
    The package also offers a function with the same name, but it''s just a shorthand
    to the respective methods for the `DefaultClient` instance. Check the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For any other kind of requirement, the `Do` method allows us to execute a specific `http.Request`.
    The `NewRequest` function allows us to specify any `io.Reader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`http.Client` has several fields and many of these are interfaces that allows
    us to use the default implementation or a custom one. The first is `CookieJar`
    that allows the client to store and reuse web cookies. A cookie is a piece of
    data that the browser sends to the client and the client can send back to the
    server to replace headers, such as authentication. The default client does not
    use a cookie jar. The other interface is `RoundTripper`, which has only one method, `RoundTrip`,
    which gets a request and returns a response. There is a `DeafultTransport` value
    used if no value is specified that can also be used to compose a custom implementation
    of `RoundTripper`. `http.Response` returned by the client has also a body, which
    is `io.ReadCloser`, and its closure is the responsibility of the application.
    That''s why it''s recommended to use a deferred `Close` statement as soon as the
    response is obtained. In the following example, we will implement a custom transport
    that logs the requested URL and modifies one header before executing the standard
    round tripper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this transport in a client that we will use to make a simple request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating a simple server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other functionality offered by the package is the server creation. The main
    interface of the package is `Handle`, which has one method, `ServeHTTP` ,that
    uses the request to write a response. Its simplest implementation is `HandlerFunc`,
    which is a function with the same signature of `ServeHTTP` and implements `Handler`
    by executing itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListenAndServe` function starts a HTTP server using the given address and
    handler. If no handler is specified, it uses the `DefaultServeMux` variable. `ServeMux`
    is special type of `Handler` that manages the execution of different handlers,
    depending on the URL path requested. It has two methods, `Handle` and `HandleFunc`,
    that allow the user to specify the path and the respective handler. The package
    also offers generic handler functions that are similar to what we have seen for
    the `Client`, they will call the methods with same name from the default `ServerMux`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a `customHandler` and create a simple
    server with some endpoints, including the custom one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Serving filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard package allows us to easily serve a certain directory in the
    filesystem, using the `net.FileServer` function, which, when given the `net.FileSystem`
    interface, returns a `Handler` that serves that directory. The default implementation
    is `net.Dir` , which is a custom string that represents a directory in the system.
    The `FileServer` function already has a protection mechanism that prevents us
    to use a relative path, such as`../../../dir`, to access directories outside the
    served one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample file server that uses the directory provided as an
    argument, as the root of the file served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Navigating through routes and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP method used is stored in the `Request.Method` field. This field can
    be used inside a handler to have different behaviors for each supported method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of the `http.Handler` interface is that we can define our custom
    types. This can make the code more readable and can generalize this method-specific
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the code much more readable, and it will be reusable for different
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Multipart request and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The request body is an `io.ReadCloser`. This means that it is the server's responsibility
    to close it. For a file upload, the body is not content of the file directly,
    but it is usually a multipart request, which is a request that specifies a boundary
    in the header and uses it inside the body to separate the message in parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a sample multipart message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the boundary has two dashes as a prefix and it's followed by
    a newline, and the final boundary also has two dashes as a suffix. In the following
    example, the server will handle a file upload, with a small form to send the request
    from a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define some constants that we will use in the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the handler function. The first part should show the template
    if the method is `GET`, as it executes the upload on `POST` and returns a not
    found status otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `upload` function will use the `Request.FormFile` method that returns the
    file and its metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want your web server to use HTTPS instead of relying on external applications,
    such as NGINX, you can easily do so if you already have a valid certificate. If
    you don''t, you can use OpenSSL to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first command generates a private key, while the second one creates a public
    certificate that you need for the server. The second command will also require
    a lot of additional information in order to create the certificate, from country
    name to email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is ready, in order to create an HTTPS server, the `http.ListenAndServe` function
    needs to be replaced with its secure counterpart: `http.ListenAndServeTLS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Third-party packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go open source community develops a lot of packages that integrate with
    `net/http`, implementing the `Handler` interface, but offer a set of unique capabilities
    that allow for an easier development of web servers.
  prefs: []
  type: TYPE_NORMAL
- en: gorilla/mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `github.com/gorilla/mux` package contains another implementation of `Handler` that
    enhances the capabilities of the standard `ServeMux`:'
  prefs: []
  type: TYPE_NORMAL
- en: Better URL matching to handlers using any element from the URL, including schema,
    method, host, or query values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL elements, such as host, paths, and query keys can have placeholders (which
    can also use regular expressions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes can be defined hierarchically with the help of subroutes, nested routes
    which test a part of the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlers can be also used as middleware, before the main handler, for all paths
    or for a subset of paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with an example of matching using other path elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables are another really useful feature, that allow us to specify placeholders,
    and get their values with the auxiliary function, `mux.Vars`, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Subrouter` is another helpful function to group same prefixes routes. This
    allows us to simplify the previous code to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Middleware is also very useful when combined with subroutes, to execute some
    common tasks as authentication and verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: gin-gonic/gin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `github.com/gin-gonic/gin` package is another Go web framework that extends
    the capabilities of a Go HTTP server with many shorthand and auxiliary functions.
    Its features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Its routing is fast and has very little memory footprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**: It allows to define and use intermediate handlers with a full
    control of their flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Panic-free**: It comes with middleware that recovers from panics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping**: It can group routes with the same prefix together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Errors**: It manages and collects error that happen during the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering**: It comes out of the box with renderers for most web formats
    (JSON, XML, HTML).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core of the package is `gin.Engine`, which is also a `http.Handler`. The
    `gin.Default` function returns an engine that uses two middlewares—`Logger`, which
    prints the result of each HTTP request received, and `Recovery`, which recovers
    from panics. The other option is to use the `gin.New` function, which returns
    an engine with no middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'It allows us to bind a handler to a single HTTP method with a series of the
    engine''s methods named after their HTTP counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any` (catch all for any HTTP method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also a `group` method that returns a route grouping for the selected
    path, which exposes all of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The handlers in this framework have a different signature. Instead of having
    a response writer and a request as arguments, it uses `gin.Context`, a structure
    that wraps both, and offers many shorthands and utilities. For instance, the package
    offers the possibility of using placeholders in the URL and the context enables
    these parameters to be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can also see in the example that the context offers a `String` method that
    enables us to write an HTTP status and the content of the response with a one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: Other functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are additional features for web servers. Some of them are already supported
    by the standard library (such as HTTP/2 Pusher) and others are available with
    experimental packages or third-party libraries (such as WebSockets).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 Pusher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed that Golang supports the HTTP/2 server side push
    functionality since version 1.8\. Let''s see how to use it in an application.
    Its usage is pretty simple; if the request can be casted to the `http.Pusher`
    interface, it can be used to push additional requests in the main interface. In
    this example, we use it to sideload a SVG image, together with the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will result in two separate requests for HTTP/1, and one single request
    for HTTP/2, where the second request is obtained using the push capabilities of
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP protocol achieves only one-way communication, while the WebSocket protocol
    is a full duplex communication between client and server. The Go experimental
    library offers support for WebSocket with the `golang.org/x/net/websocket` package,
    and Gorilla has another implementation with its own `github.com/gorilla/websocket`.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is far more complete, and it's used in the `github.com/olahol/melody`
    package, which implements a framework for an easy WebSocket communication. Each
    package offers different working examples on the WebSocket server and client pair.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with the template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very powerful tool is the Go templating engine, available in `text/template`.
    Its functionalities are replicated and extended in the `html/template` package,
    which constitutes another powerful tool for web development with Go.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax and basic usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template package enables us to separate presentation from data, using text
    files and data structures. The template engine defines two delimiters—left and
    right—for opening and closing actions that represent data evaluation. The default
    delimiters are `{{` and `}}`, and the template evaluates only what's included
    within these delimiters, leaving the rest untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Usually the data bound to the template is a structure or a map and it is accessible
    anywhere in the template with the `$` variable. Whether it's a map or a struct,
    the fields are always accessed in the same way, using the `.Field` syntax. If
    the dollar is omitted, the value is referred to the current context, which is
    `$` if it's not in special statements, such as loops. Outside of these exceptions,
    the `{{$.Field}}` and `{{.Field}}` statements are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: The flow in a template is controlled with a condition statement, `{{if}}`, and
    a loop statement, `{{range}}`, and both terminate with the `{{end}}` statement.
    The condition statement also offers the possibility of a chain `{{else if}}` statement
    to specify another condition, acting like a switch, and an `{{else}}` statement,
    which can be considered the default of a switch. `{{else}}` can be used with the
    `range` statement and it's executed when the argument of the range is `nil` or
    has zero length.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, parsing, and executing templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `template.Template` type is a collector of one or more templates and can
    be initialized in several ways. The `template.New` function creates a new empty
    template with the given name, which can be used to call the `Parse` method that
    uses a string to create a template. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/k-t0Ns1b2Mv.](https://play.golang.org/p/k-t0Ns1b2Mv)
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates can also be loaded and parsed from a filesystem, using `template.ParseFiles`,
    which takes a list of files, and `template.ParseGlob`, which uses the `glob` Unix
    command syntax to select a list of files. Let''s create a template file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use one of these two functions to load it and execute it with some sample
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When multiple templates are loaded, the `Execute` method will use the last one.
    If a specific template needs to be selected, there is another method, `ExecuteTemplate`,
    which also receives the template name as an argument, to specify which template
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `range` statement can be used in different ways—the simplest way is just
    calling `range` followed by the slice or map that you want to iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can specify the values, or the index and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When in a loop, the `{{.}}` variable assumes the value of the current element
    in the iteration. The following example loops a slice of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/MtU_d9CsFb-.](https://play.golang.org/p/MtU_d9CsFb-)
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is a use case of conditional statements that have also made
    use of the `lt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/eBKDcJ47rPU.](https://play.golang.org/p/eBKDcJ47rPU)
  prefs: []
  type: TYPE_NORMAL
- en: We will explore functions in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Template functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are an important part of the template engine and there are many built-in
    functions, such as comparison (`eq`, `lt`, `gt`, `le`, `ge`) or logical (`AND`,
    `OR`, `NOT`). Functions are called by their names, followed by arguments using
    space as separator. The function used in the previous example, `lt a b`, means
    `lt(a,b)`. When the functions are more nested, it's required to wrap functions
    and arguments in parentheses. For instance, the `not lt a b` statement means that
    the `X` function has three arguments, `not(lt, a, b)`. The correct version is
    `not (lt a b)`, which tells the template that the elements in the parentheses
    need to be solved first.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a template, custom functions can be assigned to it with the `Funcs`
    method and can be used in the template. This is very useful, as we can see in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available here: [https://play.golang.org/p/DdoKEOixDDB.](https://play.golang.org/p/DdoKEOixDDB)
  prefs: []
  type: TYPE_NORMAL
- en: The `|` operator can be used to link the output of a statement to the input
    of another statement, similar to how it happens in the Unix shell. For instance,
    the `{{"put" | printf "%s%s" "out" | printf "%q"}}` statement will produce `"output"`.
  prefs: []
  type: TYPE_NORMAL
- en: RPC servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Remote Procedure Call** (**RPC**) is a method of calling the execution of
    an application functionality from another system, using the TCP protocol. Go has
    native support for RPC servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go RPC server permits us to register any Go type, along with its methods.
    This exposes the methods with the RPC protocol and enables us to call them by
    name from a remote client. Let''s create a helper for keeping track of our progress
    in the book as we are reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s define a small helper method called `bookIndex` that returns
    the index of a book using its identifier—the ISBN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the operation that `ReadingList` will be capable of. It
    should be able to add and remove books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It should also be able to read and alter a book''s progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `SetProgress` changes the progress of a book, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`AdvanceProgress` adds pages to the progress of a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The error variables we are using in these functions are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Creating the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have the service that we can use to create an RPC server very easily.
    However, the type used has to respect some rules for its methods to make them
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: The method's type and method itself are both exported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method has two arguments, both exported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method returns an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method should look something like this: `func (t *T) Method(in T1, out
    *T2) error.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is create a wrapper for the `ReadingList` that satisfies these
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can redefine the book, add and remove functions using `Book`, which is an
    exported type, and built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For the progress, we have two inputs (`isbn` and `pages`), so we have to define
    a structure that contains both, since the input must be a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The defined type can be registered and used in an RPC server, which will use
    `rpc.HandleHTTP` to register the HTTP handler for the incoming RPC messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Creating the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client can be created using the RPC package''s `rpc.DialHTTP` function,
    using the same host-port to obtain a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a list of books that we are going to use for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering that the format package prints the address of pointers to built-in
    types, we are going to define a helper function to show the pointer''s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The client gets the operation to execute in the form of `type.method`, so we
    will be using the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will output each operation with its result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined how network connections are handled in Go. We started
    with some network standards. First, we discussed the OSI model, and then TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we checked the network package and learned how to use it to create and
    manage TCP connections. This included the handling of special commands and how
    to terminate the connection from the server side. Next, we saw how to do the same
    with UDP, and we have seen how to implement a custom encoding with checksum control.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the HTTP protocol, explained how the first version works,
    and then talked about the differences and improvements of HTTP/2\. Then, we learned
    how to make an HTTP request using Go, followed by how to set up a web server.
    We explored how to serve existing files, how to associate different actions to
    different HTTP methods, and how to handle multipart requests and file uploads. We
    set up an HTTPS server easily, and then we learned what advantages are offered
    by some third-party libraries for web servers. Finally, we demonstrated how the
    template engine works in Go, and how to build an RPC client/server easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to cover how to use the main data interchange
    format such as JSON and XML, which can also be used to create web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the advantage of using communication models?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a TCP and a UDP connection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who closes the request body when sending requests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who closes the body when receiving them in the server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
