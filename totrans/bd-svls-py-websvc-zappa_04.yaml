- en: Building a Flask-Based REST API with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how we can develop a Flask-based application and deploy
    it over a serverless infrastructure, we have created a complete web application
    along with a HTML rendering process, and we have used various Flask extensions
    to build the application in a very efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to develop a Flask-based RESTful API. This will
    cover the REST API implementation using Flask and deploying it using Zappa. In
    [Chapter 1](part0021.html#K0RQ0-8241a43bed654018b51365a570bcef1d), *Amazon Web
    Services for Serverless,* we saw the manual process of integrating the AWS Lambda
    and API Gateway, so now we will be deploying the REST API in an automated way
    using Zappa. Zappa will take care of the Flask REST API integration with API Gateway
    by configuring the proxy settings to pass the request to invoke Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on in our journey and develop a REST API over a serverless architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying the REST API using Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a Flask-based REST API, and therefore we have some prerequisites before
    starting the practical implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask 0.12.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-JWT 0.3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy 2.3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-Migrate 2.1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-RESTful 0.3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa 0.45.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to develop a Flask-based REST API that will be deployed as serverless
    on AWS Lambda. So, here, installing and configuring Flask would be in a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be creating a virtual environment and enabling it to install
    all the required packages. This can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to list all of the required packages in the `requirements.txt`file
    and we will install all of the packages at once. The following describes the content
    of the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can install all of these packages using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all of packages that will be installed in the virtual environment. Now,
    let's have a detailed explanation of these packages in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Flask extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask has a variety of extensions available that enhance the ability specific
    to any required feature. In our application, we are going to use multiple extensions,
    as mentioned in the previous section. These extensions follow a common pattern
    so that we can integrate them with Flask application objects.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to design a Flask-based REST API application that will have a basic
    authentication, authorization, and CRUD operation on the Todo model by following
    the REST API communication standard and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the usages of these extensions in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flask-JWT extension enables the feature of **JWT** (**JSON Web Token**)
    functionality in the Flask environment. While designing the REST API, the JWT
    token plays an important role to authenticate and authorize the API access. We'll
    look at a detailed description about JWT in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JWT** stands for **JSON Web Token**. It''s a standard pattern in order to
    implement security and authenticity access for REST API interfaces. The JWT token
    is an encoded form of data issued by the server application and is used to authenticate
    the client access. The client is required to add the JWT token in a HTTP request as
    an authorization header.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the JWT token to authenticate the REST API's access. In case
    you need to understand the JWT mechanism in detail, I recommend reading the JWT
    documentation at: [https://jwt.io/introduction/](https://jwt.io/introduction/).
  prefs: []
  type: TYPE_NORMAL
- en: Flask-RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flask-RESTful extension is designed to implement the REST API with the Flask
    framework. This extension follows the standard REST API implementation pattern
    and provides an easy way of REST API implementation. Before implementing the REST
    API, you must have a basic understanding of REST API standards, so let's have
    a look at the REST API basics.
  prefs: []
  type: TYPE_NORMAL
- en: Begining with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **REpresentational State Transfer.** It is a well-defined
    standard that''s used to implement server-client communication in order to persist data.
    REST follows the **JSON** (**JavaScript Object Notation**) data representation
    format to exchange the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST defines some verbs on the HTTP method to perform CRUD operations, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: To retrieve the list of records and specific records with postfix ID
    parameters in the root URL, which also return a response with a 200 status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: To create the record on the server and return a response with a 201
    status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: To update all record fields on the server and returns a response with
    a 200 status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: To update a specific field in the record set on the server and return
    a response with a 200 status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: To delete the entire record set with the help of a record-specific
    ID in the URL, and return a response with a 204 status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to see some practical work. Let's move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to design a REST API for performing CRUD operations on our todos
    model. Our application will have a basic authentication and authorization workflow
    in order to secure the REST API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the scaffolding for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`app`/`__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We configured the Flask extensions such as Flask-SQLAlchemy and Flask-Migration,
    which are straightforward. Flask-JWT integration requires a little bit more work
    as we need to define the `authenticate`and `identity`methods and use them as parameters
    while initializing the JWT object. These methods are responsible for authenticating
    the user and identifying the user.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from extension integration, we are going to create auth and todoapps as
    Flask blueprint objects and register them with the Flask application object using
    the `register_blueprint`method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a detailed description of each package and it's uses.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `config`package, we defined the application level configuration, which
    would be isolated as per the defined environment. The following is the content
    of the `config.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`config/config.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `config` file exposes the `config` object, which contains different configuration
    objects as per your environment. In a similar fashion, you can add more environment
    as per your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_sqlite_uri`method is defined to set the `db` file in the `tmp` directory
    because AWS Lambda requires the SQLite `.db` file in memory at the time of execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`config/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we combined the `db` session operations in order to perform specific transactions
    such as save, update, and delete. This will help us extend the features of a model
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is an essential feature to secure the REST API from unauthorized
    access. So, in order to implement the authentication layer, we are going to use
    the JWT mechanism. Here, we are going to design two REST APIs for registering
    a user and for login access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`auth/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic `User` model with only two fields, which are `email` and `password`.
    Now, we are going to design a signup API and a login API. The signup API will
    only accept two parameters, email and password, and will create a user record
    in the database. The login API will be used to authenticate the user's credentials
    and will return a JWT token which will be used with other APIs as an authorization
    header.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the signup and login APIs. The following is the code snippet of
    the resource file that includes the contents of the API implementation logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`auth/resources.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Flask-RESTful provides a `Resource` class, which is used to define the API resource.
    It follows the REST standard and provides an easy way to create an API. As we
    are going to use the signup API on the HTTP most `request` method, we created
    a `post` method. Similarly, we designed the login API, where we are authenticating
    the user's credentials and returning a token.
  prefs: []
  type: TYPE_NORMAL
- en: We have to return the custom method to generate the token since, at the time
    of writing, the Flask-JWT `PyPI` repository doesn't have an updated release, even
    though this feature has been added to the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`auth/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created the `Blueprint` object and configured it. Flask-RESTful
    provides an `API` class, and, using this class, we have registered our signup
    and login resources.  That's it. Now, we can hit the signup and login URL with
    JSON data to perform the operation. We will have a complete demonstration of these
    REST APIs after the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the todo API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start the todo API implementation. We need to have a todo REST API endpoint
    to perform the CRUD operations. As per the REST standard, there would be only
    one endpoint URL, such as `/todos/<todo_id>/`. This endpoint will be used to persist
    the todo data into the database. We will need to have a Todo model to persist
    the data. The following is the code snippet of the Todo model.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`todo/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`todo/resources.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined the `TodoResource` class, which will handle `GET`, `POST`,
    `PUT`, and `DELETE` HTTP requests. Based on the request type, we are performing
    the CRUD operation. We also used `reqparse`to defined the validation on the required
    data from the HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: In order to secure `TodoResource`, we have added the `jwt_required` methods
    in the list of decorators of the `TodoResource` class, which will apply to all
    associated methods. Now, the `TodoResource` API will only be available with a
    valid authorization header, otherwise it will respond with the unauthorized access
    error.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the complete working of this in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying the REST API using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are done with development, and now it's time to deploy the app as serverless
    in AWS Lambda. We already described the prerequisites to configure Zappa and its
    associated configuration in the preceding chapter, so here I assume that you have
    a configured Zappa along with an AWS configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have configured Zappa, you can initialize Zappa for your project. You
    need to run the `zappa init` command and follow the CLI questionnaire to configure
    your project with Zappa. I followed the default configuration settings suggested
    by Zappa. The `zappa init` command will generate the `zappa_settings.json` file,
    and we are free to modify this file as per our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Zappa maintains this JSON file in order to perform the deployment process. Now,
    we will move on to deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating deployment using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are done with Zappa initialization, it's time to deploy the application. Zappa
    provides a `zappa deploy` command to deploy the application. This command will
    perform the deployment process, where it will create the deployment package as
    a ZIP file, push it onto AWS S3, and configure the AWS Lambda with the API Gateway.
    We described the complete deployment process in detail in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we run this with the `zappa deploy dev`command, our application will be
    hosted as a serverless application on AWS Lambda. If you wanted to redeploy the
    same application, then you would need to run the `zappa update dev` command, which
    will update the existing application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at demonstrating the deployed application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating the deployed application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zappa generates a random URL for the deployed application, and, on every new
    deployment, it will generate the URL. However, if you are just updating the deployment,
    then it won't change the URL. This is the URL we got from the Zappa deployment
    process: [https://jrzlw1zpdi.execute-api.ap-south-1.amazonaws.com/dev/](https://jrzlw1zpdi.execute-api.ap-south-1.amazonaws.com/dev/).
    We have written the auth and todo APIs with some endpoints, so you won't see anything
    on the base URL. We will be using our API endpoints as defined in the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Sign up API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We designed the signup API with the endpoint as `/auth/signup`,which expects
    two parameters—`email` and `password`. This endpoint is responsible for creating
    the user record in the database. Once we get the successful response, we can use
    the same user credentials to perform the login and access other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the signup API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we use the Advanced REST Client application to test the API. As you can
    see, we are creating the user record with the signup API. The signup API responds
    with a 200 status.
  prefs: []
  type: TYPE_NORMAL
- en: Login API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have a user record available in the database and we can use it to perform
    a login operation. The login API is responsible for validating the user''s credentials
    and returning a JWT token. This JWT token will be used to authorize the todos
    API. The following is a screenshot of the login API being used through the REST
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see the login API execution, as we got the JWT token that will
    be used to authorize access to the todo API.
  prefs: []
  type: TYPE_NORMAL
- en: Todo API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the JWT token through the login API, let's execute the Todo
    API. However, here, we will be looking at different scenarios on the Todo API.
    Our Todo API has an endpoint called `todos/<todo_id>`.
  prefs: []
  type: TYPE_NORMAL
- en: Todo API without authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try the todo API without providing the authorization header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we got an unauthorized error from our application. Now, we are
    going to provide the authorization header with a JWT token.
  prefs: []
  type: TYPE_NORMAL
- en: Todo API with the authorization header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the JWT token returned by the login API and set the authorization
    header. The value of the authorization header will be `JWT <token>`.Now, let's
    execute the API with CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GET` request looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we got the list of all todo records available in the database. We gained
    access as we set the authorization header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` request looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we created a new todo record and got the response with a status code of `201`.
    Now, with the base URL, we can execute the `GET` and `POST` requests, but, to
    perform the `GET`, `PUT`, and `DELETE` functions on specific records, we are required
    to mention the `todo_id` in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` request without payload data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we got the validation error as we haven't provided any payload. We managed
    this validation with the help of the `reqparse`module of the `flask_restful` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GET` request with the todo ID looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have used the todo ID in the URL to view a specific record
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PATCH` request looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we updated the todo status and marked the todo records as finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PATCH` request with invalid data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we got the validation error as we defined the required choices using
    the `reqparse`module, as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DELETE` request looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we deleted the record with the HTTP `DELETE` request. That's it! We
    are done with the REST API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a Flask-based REST API and configured
    it with some extensions. With the help of the Flask-JWT extension, we implemented
    security. The Flask-RESTful extension provides an easy interface to design the
    REST API. Finally, we configured Zappa to deploy the application in a serverless
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see the Django application development
    as a serverless application on AWS Lambda. Stay tuned for it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need JWT implementation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `function_name` parameter in the Zappa settings file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
