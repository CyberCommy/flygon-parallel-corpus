- en: Project Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a new multiproject solution that will be the
    foundation of our example application. We will apply a Model View Controller pattern,
    separating the user interface and business logic. We will also introduce Qt’s
    unit testing framework—QtTest—and demonstrate how to integrate it into our solution.
    We will cover these things in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Projects, MVC, and unit testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a unit tests project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user interface project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering MVC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QObject base class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling project output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects, MVC, and unit testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scratchpad application we built in the previous chapter is a Qt project,
    represented by a `.pro` file. In a business environment, technical solutions are
    generally developed as part of company initiatives, and these initiatives are
    generally also called **projects**. To try and minimize confusion (and the number
    of times the word project appears!), we’ll use project to mean a Qt project defined
    by a `.pro` file and the word initiative to refer to projects in the business
    sense.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The initiative we will work on will be a generic client management system. It
    will be something that can be tweaked and re purposed for multiple applications—for
    a supplier managing customers, a health service managing patients, and so on.
    It will perform common tasks found over and over in real-world **Line of Business**
    (**LOB**) applications, principally adding, editing, and deleting data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Our scratchpad application is entirely encapsulated within a single project.
    For smaller applications, this is perfectly viable. However, with larger code
    bases, particularly with several developers involved, it often pays to break things
    up into more manageable pieces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a super lightweight implementation of the **Model View Controller**
    (**MVC**) architectural pattern. If you haven’t come across MVC before, it is
    primarily used to decouple business logic from the user interface. The user interface
    (View) relays commands to a switchboard style class (Controller) to retrieve the
    data and perform actions it needs. The controller in turn delegates the responsibility
    for the data, logic, and rules to data objects (Models):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39853104-b5e4-4dc3-985b-febae3c11f56.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: The key is that the **View** knows about the **Controller** and the **Model**,
    as it needs to send commands to the **Controller** and display the data held in
    the **Model**. The **Controller** knows about the **Model** as it needs to delegate
    work to it, but it doesn’t know about the **View**. The Model knows nothing about
    either the **Controller** or the **View**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: A key benefit of designing the application this way in a business environment
    is that dedicated UX specialists can work on the views while programmers work
    on the business logic. A secondary boon is that because the business logic layer
    knows nothing about the UI, you add, edit, and even totally replace user interfaces
    without affecting the logic layer. A great use case would be to have a “full fat”
    UI for a desktop application and a companion “half fat” UI for a mobile device,
    both of which can use the same business logic. With all this in mind, we will
    physically segregate our UI and business logic into separate projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at integrating automated unit tests into our solution. Unit
    testing and **Test Driven Development** (**TDD**) has really grown in popularity
    in recent times and when developing applications in a business environment, you
    will more than likely be expected to write unit tests alongside your code. If
    not, you should really propose doing it as it holds a lot of value. Don’t worry
    if you haven’t done any unit testing before; it’s very straightforward, and we’ll
    discuss it in more detail later in the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a way to aggregate these subprojects together so that we don’t
    have to open them individually. We will achieve this with an umbrella solution
    project that does nothing other than tying the other projects together. This is
    how we will lay out our projects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83ae32f5-c0eb-43b2-8d40-d977d7fb3a9c.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Project creation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how easy it is to set up a new project just
    by creating a few text files. However, we’ll create our new solution using Qt
    Creator.  We will use the new project wizard to guide us through creating a top-level
    solution and a single subproject.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'From the top menu, select File > New File or Project and then Projects > Other
    Project > Subdirs Project and click on Choose…:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab5a4f70-f441-44b3-bcc1-118ee4ccb301.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Subdirs Project is the template we need for our top-level solution project.
    Give it the name `cm` and create it in our `qt` projects folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/466aba05-c61f-436c-82d6-203ad4fe6731.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'On the Kit Selection pane, check the Desktop Qt 5.10.0 MinGW 32bit kit we installed.
    Feel free to select additional kits you want to try out if you have them installed,
    but it’s not necessary. Click on Next:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16fccb2b-40e0-484c-a43a-7e926efe6c68.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'As discussed, version control is beyond the scope of this book, so in the Project
    Management pane, select None from the Add to version control dropdown. Click on Finish
    & Add Subproject:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04cabdf6-7274-4e07-a775-ee9320205a4a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'We’ll add the user interface project as the first subproject. The wizard follows
    more or less the same pattern as the steps we''ve just followed, so perform the
    following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Select Projects > Application > Qt Quick Application - Empty and click on Choose...
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project Location dialog, give it the name `cm-ui` (for Client Management
    - User Interface), leave the location as our new `cm` folder, and click on Next.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Define Build System dialog, select the build system qmake and click on Next.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Define Project Details dialog, leave the default minimal Qt version of
    QT 5.9 and the Use Qt Virtual Keyboard box unchecked then click on Next.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Kit Selection dialog, pick the Desktop Qt 5.10.0 MinGW 32bit kit plus
    any other kits you wish to try and click on Next.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our top-level solution and UI projects are now up and running, so let’s add
    the other subprojects. Add the business logic project next, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In the Projects pane, right-click on the top-level `cm` folder and select New
    Subproject….
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Projects > Library > C++ Library and click on Choose....
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Introduction and Project Location dialog, pick Shared Library as the
    Type, name it `cm-lib`, create it in `<Qt Projects>/cm`, and then click on Next.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Select Required Modules dialog, just accept the default of QtCore and
    click on Next.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Class Information** dialog, we get the opportunity to create a new
    class to get us started. Give the class name `Client`, with the `client.h` header
    file and the `client.cpp` source file, and then click on Next.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will repeat the process to create our unit testing project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: New Subproject....
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Projects > Other Project > Qt Unit Test.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project name `cm-tests`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include QtCore and QtTest.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `ClientTests` test class with the `testCase1` test slot and the `client-tests.cpp` filename. Set
    the Type as Test and check Generate initialization and cleanup code.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip version control and Finish.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That was a lot of dialog boxes to get through, but we’ve now got our skeleton
    solution in place. Your project folders should look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a2a887e-58db-4347-8bf2-67aefbd91625.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: We’ll now take a look at each project in turn and make some tweaks before we
    start adding our content.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: cm-lib
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First off, head to file explorer and create a new subfolder underneath `cm-lib`
    called `source`; move `cm-lib_global.h` there. Create another subfolder in `source`
    called `models` and move both the `Client` class files there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往文件资源管理器，在`cm-lib`下创建一个名为`source`的新子文件夹；将`cm-lib_global.h`移动到其中。在`source`中创建另一个名为`models`的子文件夹，并将`Client`类文件都移动到其中。
- en: 'Next, back in Qt Creator, open up `cm-lib.pro` and edit it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Qt Creator中，打开`cm-lib.pro`并编辑如下：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As this is a library project, we do not need to load the default GUI module,
    so we exclude it using the `QT` variable. The `TARGET` variable is the name we
    wish to give our binary output (for example, `cm-lib.dll`). It is optional and
    will default to the project name if not provided, but we’ll be explicit. Next,
    rather than having a `TEMPLATE` of app as we saw in our scratchpad application,
    this time we use `lib` to give us a library. We add c++14 features via the `CONFIG`
    variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个库项目，我们不需要加载默认的GUI模块，因此我们使用`QT`变量将其排除。`TARGET`变量是我们希望给我们的二进制输出的名称（例如`cm-lib.dll`）。这是可选的，如果未提供，将默认为项目名称，但我们将明确指定。接下来，与我们在草稿应用程序中看到的`app`模板不同，这次我们使用`lib`来创建一个库。我们通过`CONFIG`变量添加了c++14特性。
- en: The `cm-lib_global.h` file is a helpful little bit of preprocessor boilerplate
    we can use to export our shared library symbols, and you’ll see that put to use
    soon. We use the `CMLIB_LIBRARY` flag in the `DEFINES` variable to trigger this
    export.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`cm-lib_global.h`文件是一个有用的预处理器样板，我们可以用它来导出我们的共享库符号，您很快就会看到它的用途。我们在`DEFINES`变量中使用`CMLIB_LIBRARY`标志来触发此导出。'
- en: Finally, we have slightly rewritten the `SOURCES` and `HEADERS` variable lists
    to account for the new file locations after we moved things around a bit, and
    we add the source folder (which is where all of our code will live) to the `INCLUDEPATH`
    so that the path is searched when we use `#include` statements.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们稍微重写了`SOURCES`和`HEADERS`变量列表，以考虑在我们移动了一些东西之后的新文件位置，并且我们将源文件夹（这是我们所有代码的所在地）添加到`INCLUDEPATH`中，这样当我们使用`#include`语句时就可以搜索到路径。
- en: Right-click on the `cm-lib` folder in the Projects pane and select Run qmake.
    When that has finished, right-click again and select **Rebuild**. Everything should
    be green and happy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗格中右键单击`cm-lib`文件夹，选择运行qmake。完成后，再次右键单击并选择**重新构建**。一切应该都是绿色和愉快的。
- en: cm-tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cm-tests
- en: 'Create new `source/models` subfolders and move `client-tests.cpp` there. Switch
    back to Qt Creator and edit `cm-tests.pro`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的`source/models`子文件夹，并将`client-tests.cpp`移动到那里。切换回Qt Creator并编辑`cm-tests.pro`：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This follows pretty much the same approach as with `cm-lib`, with the exception
    that we want a console app rather than a library. We don’t need the GUI module,
    but we will add the `testlib` module to get access to the Qt Test features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与`cm-lib`的方法相同，唯一的区别是我们想要一个控制台应用程序而不是一个库。我们不需要GUI模块，但我们将添加`testlib`模块以获取Qt测试功能的访问权限。
- en: There really isn’t much to this subproject just yet, but you should be able
    to run qmake and rebuild successfully.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个子项目还没有太多内容，但您应该能够成功运行qmake并重新构建。
- en: cm-ui
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cm-ui
- en: 'Create two subfolders this time: `source` and `views`. Move `main.cpp` into
    `source` and `main.qml` into `views`. Rename `qml.qrc` as `views.qrc` and edit
    `cm-ui.pro`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这次创建两个子文件夹：`source`和`views`。将`main.cpp`移动到`source`中，将`main.qml`移动到`views`中。将`qml.qrc`重命名为`views.qrc`，并编辑`cm-ui.pro`：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our UI is written in QML, which requires the `qml` and `quick` modules, so we
    add those. We edit the `RESOURCES` variable to pick up our renamed resource file
    and also edit the `QML_IMPORT_PATH` variable, which we will cover in detail when
    we get into custom QML modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的UI是用QML编写的，需要`qml`和`quick`模块，所以我们添加了这些。我们编辑`RESOURCES`变量以获取我们重命名的资源文件，并编辑`QML_IMPORT_PATH`变量，我们将在进入自定义QML模块时详细介绍。
- en: 'Next, edit `views.qrc` to account for the fact that we have moved the `main.qml`
    file into the `views` folder.  Remember to right-click and Open With > Plain Text
    Editor:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`views.qrc`以考虑我们已将`main.qml`文件移动到`views`文件夹中。记得右键单击并选择“使用其他应用程序打开”>“纯文本编辑器”：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we also need to edit a line in `main.cpp` to account for the file
    move:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要编辑`main.cpp`中的一行以考虑文件移动：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should now be able to run qmake and rebuild the `cm-ui` project. Before
    we run it, let’s take a quick look at the build configuration button now that
    we have multiple projects open:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行qmake并重新构建`cm-ui`项目。在运行之前，让我们快速看一下构建配置按钮，因为现在我们有多个项目打开了：
- en: '![](img/dff629a5-d049-416c-a917-5f3dccd1f080.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dff629a5-d049-416c-a917-5f3dccd1f080.png)'
- en: 'Note that now, along with the Kit and Build options, we must also select the
    executable we wish to run. Ensure that `cm-ui` is selected and then run the application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在除了工具链和构建选项之外，我们还必须选择要运行的可执行文件。确保选择了`cm-ui`，然后运行应用程序：
- en: '![](img/c87febe8-c33b-44c7-bafc-7e60d634a23e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c87febe8-c33b-44c7-bafc-7e60d634a23e.png)'
- en: Hello World indeed. It's fairly uninspiring stuff, but we have a multiproject
    solution building and running happily, which is a great start. Close the application
    when you simply can’t take any more fun!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是世界你好。这是相当令人失望的东西，但我们已经成功地构建和运行了一个多项目解决方案，这是一个很好的开始。当您无法再忍受更多乐趣时，请关闭应用程序！
- en: Mastering MVC
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC的掌握
- en: Now that our solution structure is in place, we’ll get started on the MVC implementation.
    As you’ll see, it is very minimal and incredibly easy to set up.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的解决方案结构已经就位，我们将开始MVC实现。正如您将看到的那样，它非常简单，非常容易设置。
- en: 'First, expand `cm-ui > Resources > views.qrc > / > views`, right-click on `main.qml`,
    select Rename, and rename the file as `MasterView.qml`. If you get a message about
    project editing, just select Yes to continue anyway:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，展开`cm-ui > Resources > views.qrc > / > views`，右键单击`main.qml`，选择重命名，将文件重命名为`MasterView.qml`。如果收到有关项目编辑的消息，请选择“是”以继续：
- en: '![](img/e30af2b8-81b4-4c6f-9ac3-df51ea1e6ecc.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e30af2b8-81b4-4c6f-9ac3-df51ea1e6ecc.png)'
- en: If you do get the error message, the file will still appear as `main.qml` in
    the Projects pane, but the file will have been renamed in the filesystem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到错误消息，文件仍将在项目窗格中显示为`main.qml`，但文件在文件系统中已被重命名。
- en: 'Next, edit `views.qrc` (right-click on it and select Open With > Plain Text
    Editor). Replace the content as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`views.qrc`（右键单击它，然后选择使用纯文本编辑器打开）。将内容替换为以下内容：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you recall how we load this QML file in `main.cpp`, the syntax is `qrc:<prefix><filename>`.
    We previously had a `/` prefix and a `views/main.qml` relative filename. This
    gave us `qrc:/views/main.qml`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们如何在`main.cpp`中加载这个QML文件，语法是`qrc:<prefix><filename>`。我们以前有一个`/`前缀和一个`views/main.qml`相对文件名。这给了我们`qrc:/views/main.qml`。
- en: A prefix of `/` isn’t terribly descriptive. As you add more and more QML files,
    it’s really helpful to organize them into blocks with meaningful prefixes. Having
    unstructured resource blocks also makes the Projects pane ugly and more difficult
    to navigate, as you just saw when you had to drill down through `views.qrc > /
    > views`. So, the first step is to rename the prefix from `/` to `/views`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`的前缀并不是非常描述性的。随着您添加更多的QML文件，将它们组织成具有有意义前缀的块会非常有帮助。拥有无结构的资源块也会使项目面板变得混乱，导航起来更加困难，就像您刚才在`views.qrc
    > / > views`中看到的那样。因此，第一步是将前缀从`/`重命名为`/views`。'
- en: However, with a prefix of `/views` and a relative filename of `views/main.qml`,
    our URL is now `qrc:/views/views/main.qml`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`/views`作为前缀和`views/main.qml`作为相对文件名，我们的URL现在是`qrc:/views/views/main.qml`。
- en: This is worse than it was before, and we still have a deep folder structure
    in `views.qrc`. Fortunately, we can add an *alias* for our file to make both of
    these problems go away. You can use the alias of a resource in place of the relative
    path, so if we assign an alias of `main.qml`, we can replace `views/main.qml`
    with simply `main.qml`, giving us `qrc:/views/main.qml`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以前更糟糕了，在`views.qrc`中我们仍然有一个深层的文件夹结构。幸运的是，我们可以为我们的文件添加一个*别名*来解决这两个问题。您可以使用资源的别名来代替相对路径，因此如果我们分配一个`main.qml`的别名，我们可以用`main.qml`来替换`views/main.qml`，得到`qrc:/views/main.qml`。
- en: That’s concise and descriptive, and our Projects pane is neater too.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简洁和描述性的，我们的项目面板也更整洁了。
- en: So, going back to our updated version of `views.qrc`, we have simply updated
    the name of the file from `main.qml` to `MasterView.qml`, consistent with the
    file rename we performed, and we have also provided a shortcut alias, so we don't
    have to specify views twice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们更新后的`views.qrc`版本，我们只是将文件名从`main.qml`更新为`MasterView.qml`，与我们执行的文件重命名一致，并且我们还提供了一个快捷别名，这样我们就不必两次指定views。
- en: 'We now need to update our code in `main.cpp` to reflect these changes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新`main.cpp`中的代码以反映这些更改：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should be able to run qmake, and build and run to verify that nothing has
    broken.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够运行qmake，并构建和运行以验证没有出现问题。
- en: 'Next, we’ll create a `MasterController` class, so right-click on the `cm-lib`
    project and select Add New… > C++ > C++ Class > Choose…:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`MasterController`类，因此右键单击`cm-lib`项目，然后选择添加新内容… > C++ > C++类 > 选择…：
- en: '![](img/2b36133d-dd2e-4811-9167-1b302283441b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b36133d-dd2e-4811-9167-1b302283441b.png)'
- en: Use the Browse… button to create the `source/controllers` subfolder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“浏览…”按钮创建`source/controllers`子文件夹。
- en: By selecting QObject as the base class and including it, Qt Creator will write
    some of the boilerplate code for us. You can always add it yourself later, so
    don’t feel like it’s a necessary part of creating a new class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择QObject作为基类并包含它，Qt Creator将为我们编写一些样板代码。您随后可以自己添加它，所以不要觉得这是创建新类的必要部分。
- en: Once you’ve skipped version control and created the class, declare and define
    it as follows. Our `MasterController` doesn’t do anything particularly exciting
    just yet, we’re just doing the groundwork.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您跳过了版本控制并创建了类，声明和定义如下。我们的`MasterController`目前还没有做任何特别激动人心的事情，我们只是在做基础工作。
- en: 'Here''s `master-controller.h`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`master-controller.h`：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All we’ve really added to the default implementation Qt Creator gave us is the `CMLIBSHARED_EXPORT` macro
    Qt Creator wrote for us in `cm-lib_global.h` to take care of our shared library
    exports, and to put the class inside a namespace.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正添加到Qt Creator默认实现的只是`CMLIBSHARED_EXPORT`宏，Qt Creator在`cm-lib_global.h`中为我们编写的，以处理我们的共享库导出，并将类放在一个命名空间中。
- en: I always have the project name as a root namespace and then additional namespaces
    that reflect the physical location of the class files within the source directory,
    so in this case, I use `cm::controllers`, as the class is located in the directory `source/controllers`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是将项目名称作为根命名空间，然后是反映源目录中类文件物理位置的其他命名空间，所以在这种情况下，我使用`cm::controllers`，因为该类位于`source/controllers`目录中。
- en: 'This is `master-controller.cpp`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`master-controller.cpp`：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I use a slightly unorthodox style in the implementation file—most people just
    add `using namespace cm::controllers;` at the top of the `.cpp` file. I often
    like to put the code within the scope of namespaces because it becomes collapsible
    in the IDE. By repeating the innermost namespace scope (*controllers* in this
    example), you can break your code up into collapsible regions much like you can
    in C#, which helps with navigation in larger files, as you can collapse the sections
    you’re not interested in. It makes no functional difference, so use whichever
    style you prefer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件中，我使用了一个略微不正统的风格——大多数人只是在`.cpp`文件的顶部添加`using namespace cm::controllers;`。我经常喜欢将代码放在命名空间的范围内，因为在IDE中可以折叠它。通过重复最内层的命名空间范围（在这个例子中是*controllers*），您可以将代码分解成可折叠的区域，就像在C#中一样，这有助于在更大的文件中进行导航，因为您可以折叠您不感兴趣的部分。这在功能上没有任何区别，所以使用您喜欢的风格。
- en: QObject
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QObject
- en: So, what is this funky **QObject** thingy we are inheriting from which keeps
    popping up? Well, it’s the base class for all Qt objects, and it gives us some
    powerful features for free.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们继承的这个古怪的**QObject**是什么东西？它是所有Qt对象的基类，并且它为我们提供了一些强大的功能。
- en: QObjects organize themselves into object hierarchies with a *parent* object
    assuming ownership of their *child* objects, which means we don’t have to worry
    (as much!) about memory management. For example, if we have an instance of a Client
    class derived from QObject that is the parent of an Address also derived from
    QObject, then the address is automatically destroyed when the client is destroyed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: QObjects将自己组织成对象层次结构，*parent*对象承担其*child*对象的所有权，这意味着我们不必太担心内存管理。例如，如果我们有一个从QObject派生的Client类的实例，它是从QObject派生的Address的父类，那么当客户端被销毁时，地址会自动被销毁。
- en: QObjects carry metadata that allows a degree of type inspection and is the backbone
    for interaction with QML. They can also communicate with each other via an event
    subscription mechanism where the events are emitted as *signals* and the subscribed
    delegates are known as *slots*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: QObjects携带元数据，允许一定程度的类型检查，并且是与QML交互的支柱。它们还可以通过事件订阅机制相互通信，其中事件被发射为*signals*，订阅的代理被称为*slots*。
- en: All you need to remember for now is that for any custom classes you write where
    you want to interact with it in the UI, ensure that it derives from QObject. Whenever
    you do derive from QObject, ensure that you always add the magical Q_OBJECT macro
    to your class before you do anything else. It injects a bunch of super complicated
    boilerplate code that you don’t need to understand in order to use QObjects effectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要记住的是，对于您编写的任何自定义类，如果您希望在UI中与之交互，请确保它派生自QObject。每当您从QObject派生时，请确保在做任何其他事情之前始终向您的类添加神奇的Q_OBJECT宏。它注入了一堆超级复杂的样板代码，您不需要理解就可以有效地使用QObjects。
- en: 'We are now at the point where we need to reference code from one subproject
    (`MasterController` in `cm-lib`) in another (`cm-ui`). We first need to be able
    to access the declarations for our `#include` statements. Edit the `INCLUDEPATH`
    variable in `cm-ui.pro` as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要引用一个子项目（`cm-lib`中的`MasterController`）中的代码到另一个子项目（`cm-ui`）中。我们首先需要能够访问我们的`#include`语句的声明。编辑`cm-ui.pro`中的`INCLUDEPATH`变量如下：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `\` symbol is a “continue on to the next line” indicator, so you can set
    a variable to multiple values spanning several lines. Just like console commands,
    ‘..’ means traverse up a level, so here we are stepping up out of the local folder
    (`cm-ui`) and then down into the `cm-lib` folder to get at its source code. You
    need to be careful that the project folders remain in the same location relative
    to each other, else this won’t work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`符号是“继续到下一行”的指示符，因此您可以将一个变量设置为跨越多行的多个值。就像控制台命令一样，‘..’表示向上遍历一个级别，所以这里我们从本地文件夹（`cm-ui`）中跳出，然后进入`cm-lib`文件夹以获取其源代码。您需要小心，项目文件夹保持相对位置不变，否则这将无法工作。'
- en: Just below this, we’ll tell our UI project where to find the implementation
    (compiled binary) of our library project. If you take a look at the filesystem
    alongside the top-level `cm` project folder, you will see one or more build folders,
    for example, build-cm-Desktop_Qt_5_9_0_MinGW_32bit-Debug. Each folder is created
    when we run qmake for a given kit and configuration and is populated with the
    output when we build.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们将告诉我们的UI项目在哪里找到我们的库项目的实现（已编译的二进制文件）。如果您查看与顶级`cm`项目文件夹并排的文件系统，您会看到一个或多个构建文件夹，例如，build-cm-Desktop_Qt_5_9_0_MinGW_32bit-Debug。每个文件夹在为给定的工具包和配置运行qmake时创建，并在构建时填充输出。
- en: Next, navigate to the folder relevant to the kit and configuration you are using,
    and you will find a cm-lib folder with another configuration folder inside it.
    Copy this file path; for example, I am using the MinGW 32 bit kit in Debug configuration,
    so my path is `<Qt Projects>/build-cm-Desktop_Qt_5_10_0_MinGW_32bit-Debug/cm-lib/debug`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到与您正在使用的工具包和配置相关的文件夹，您会发现一个带有另一个配置文件夹的cm-lib文件夹。复制这个文件路径；例如，我正在使用MinGW
    32位工具包进行调试配置，所以我的路径是`<Qt Projects>/build-cm-Desktop_Qt_5_10_0_MinGW_32bit-Debug/cm-lib/debug`。
- en: 'In that folder, you will find the compiled binaries relevant for your OS, for
    example, `cm-lib.dll` on Windows. This is the folder we want our `cm-ui` project
    to reference for the `cm-lib` library implementation. To set this up, add the
    following statement to `cm-ui.pro`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件夹中，您会找到与您的操作系统相关的已编译二进制文件，例如，在Windows上是`cm-lib.dll`。这是我们希望我们的`cm-ui`项目引用的`cm-lib`库实现的文件夹。为了设置这一点，将以下语句添加到`cm-ui.pro`中：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`LIBS` is the variable used to add referenced libraries to the project. The
    `-L` prefix denotes a directory, while `-l` denotes a library file. Using this
    syntax allows us to ignore the file extensions (`.a`, `.o`, `.lib`) and prefixes
    (lib...), which can vary between operating systems and let qmake figure it out.
    We use the special `$$` symbol to access the value of the `PWD` variable, which
    contains the working directory of the current project (the full path to `cm/cm-ui`
    in this case). From that location, we then drill up two directories with `../..`
    to get us to the Qt projects folder. From there, we drill back down to the location
    where we know the `cm-lib` binaries are built.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIBS`是用于向项目添加引用库的变量。`-L`前缀表示目录，而`-l`表示库文件。使用这种语法允许我们忽略文件扩展名（`.a`，`.o`，`.lib`）和前缀（lib...），这些可能因操作系统而异，让qmake自行解决。我们使用特殊的`$$`符号来访问`PWD`变量的值，该变量包含当前项目的工作目录（在这种情况下是`cm/cm-ui`的完整路径）。然后，我们从该位置向上两个目录，使用`../..`来到Qt项目文件夹。然后，我们再次向下钻取到我们知道`cm-lib`二进制文件构建的位置。'
- en: Now, this is painful to write, ugly as hell, and will fall over as soon as we
    switch kits or configurations, but we will come back and tidy up all this later.
    With the project references all wired up, we can head on over to `main.cpp` in
    `cm-ui`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个写起来很痛苦，丑陋得要命，一旦我们切换工具包或配置，它就会崩溃，但我们稍后会回来整理所有这些。项目引用都已连接好，我们可以前往`cm-ui`中的`main.cpp`。
- en: 'To be able to use a given class in QML, we need to register it, which we do
    in `main()` before we create the QML Application Engine. First, include the `MasterController`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在QML中使用给定的类，我们需要在创建QML应用程序引擎之前在`main()`中注册它。首先，包括`MasterController`：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, right after the `QGuiApplication` is instantiated but before the `QQmlApplicationEngine`
    is declared, add the following line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we are doing here is registering the type with the QML engine. Note that
    the template parameter must be fully qualified with all namespaces. We will add
    the type’s metadata into a module called CM with a version number 1.0, and we
    want to refer to this type as `MasterController` in QML markup.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we instantiate an instance of `MasterController` and inject it into the
    root QML context:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that you need to set the context property before loading the QML file,
    and you will also need to add the following header:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, we’ve created a controller, registered it with the QML engine, and it’s
    good to go. What now? Let’s do our first bit of QML.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: QML
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qt Modeling Language** (**QML**) is a hierarchical declarative language for
    user interface layout with a syntax similar to **JavaScript Object Notation**
    (**JSON**). It can bind to C++ objects via Qt’s meta object system and also supports
    inline JavaScript. It’s much like HTML or XAML but without the XMLness. If you
    are someone who likes JSON more than XML, this can only be a good thing!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open up `MasterView.qml`, and we’ll see what’s going on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you’ll see is a couple of `import` statements. They are similar
    to `#include` statements in C++—they bring in pieces of functionality that we
    want to use in the view. They can be packed and versioned modules as with QtQuick
    2.9, or they can be relative paths to local content.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Next, the QML hierarchy begins with a Window object. The scope of the object
    is represented by the subsequent `{}`, so everything within the braces is either
    a property or child of the object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties follow JSON property syntax, of the form key: value. A notable difference
    is that speech marks are not required unless you are providing a string literal
    as a value. Here, we are setting the `visible` property of the Window object to
    be `true` and the size of the window to be 640 x 480 pixels, and we are displaying
    Hello World in the title bar.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the title and add a simple message. Replace the Hello World title
    with Client Management and insert a Text component inside the body of the Window:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save your changes, and Run qmake and Run the application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a1da88e-5508-40df-b5f6-20da69d33968.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Let’s make `MasterController` start earning its keep and rather than hard-coding
    our welcome message in the UI, we’ll obtain it dynamically from our controller.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `master-controller.h` and add a new public property of the `QString` type called
    `welcomeMessage`, setting it to an initial value:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will also need to `#include <QString>`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to access this member from QML, we need to configure a
    new property. After the Q_OBJECT macro but before the first public access modifier,
    add the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are creating a new property of the QString type that QML can access. QML
    will refer to the property as `ui_welcomeMessage` and when called, will get (or
    set) the value in the `MEMBER` variable called `welcomeMessage`. We are explicitly
    setting the value of the variable up front and will not change it, so it will
    remain `CONSTANT`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You can simply name the property `welcomeMessage`, rather than `ui_welcomeMessage`.
    My personal preference is to explicitly name things that are solely intended for
    UI consumption with a ui_ prefix to differentiate them from member variables and
    methods. Do whatever works for you.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to `MasterView.qml`, and we will put this property to use. Change
    the `text` property of the `Text` component to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the QML editor recognizes `masterController` and even offers code completion
    for it. Now, rather than displaying a string literal as the message, the QML will
    access the `ui_welcomeMessage` property of the instance of `MasterController`
    we injected into the root context in `main()`, which will, in turn, get the value
    of the `welcomeMessage` member variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and Run, and you should now see the message coming from the `MasterController`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe3e204d-88f4-4203-9859-f16bde93e547.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: We now have a working mechanism for QML to call into C++ code and get hold of
    whatever data and business logic we want to provide it. Here, an important thing
    to note is that our `MasterController` knows nothing about the existence of `MasterView`, and
    this is a key part of the MVC pattern.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Project output
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let our `cm-ui` project know where to find the implementation of
    `cm-lib`, we used the `LIBS` variable in our project file. It was a pretty ugly
    folder name, but it’s only one line and everything has worked perfectly well,
    so it could be tempting to leave things as they are. However, look forward to
    when we are ready to produce our first build for testing or even production. We’ve
    written some really clever code, and everything is building and running beautifully.
    We switch the configuration from Debug to Release and...everything falls over.
    The problem is that we’ve hard-coded the library path in our project file to look
    in the `Debug` folder. Change to a different kit or another operating system and
    the problem is even worse, as you will have binary compatibility issues from using
    different compilers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set a few goals:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of the unwieldy `build-cm…` folders
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate all the compiled binary output into one common folder `cm/binaries`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide all temporary build artifacts in their own folders `cm/<project>/build`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create separate build and binary folders for different compilers and architectures
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect those compilers and architectures automatically
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, where do these funny long folder names come from in the first place? In
    Qt Creator, click on the Projects mode icon in the navigation bar. Down the left-hand
    side in the Build & Run section, select Desktop Qt 5.9.0 MinGW 32 bit > Build.
    Here, you will see the Build Settings for the MinGW kit in this solution and under
    the Shadow build checkbox, you will recognize the long build directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to leave shadow builds enabled as this gives us the capability to perform
    builds to alternative locations for different kits. We will control the exact
    output of our builds in the `.pro` files, but we still need to specify a build
    directory here to keep Qt Creator happy. Enter <Qt Projects>/shadow-builds. Repeat
    this setting for each build configuration (Debug/Release/Profile) using the dropdown
    at the top of the pane, and for all the kits you are using:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a8328e-26ef-439f-8546-7eb661821236.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: In your filesystem, delete any of the old `build-cm…` folders. Right-click on
    the solution folder and Run qmake. After qmake has finished, you should see that
    shell `cm-lib`, `cm-tests`, and `cm-ui` folders have been created in <Qt Projects>/shadow-builds
    and that the long `build-cm…` folders have not reappeared.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The first step for dynamically setting any relative path is to know which path
    you are currently on. We’ve already seen that in action in qmake when we used
    `$$PWD` to get the project working directory. To help us visualize what is going
    on, let’s introduce our first qmake function—`message()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to `cm.pro`—it doesn’t matter where in the file it goes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following line to `cm-lib.pro`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `message()` is a test function supported by qmake that outputs the supplied
    string parameter to the console. Note that you don’t need to surround the text
    with double quotes. When you save the changes, you will see the **Project Working
    Directory** (**PWD**) of both the solution project and the library project logged
    out to the General Messages console:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()`是qmake支持的测试函数，它将提供的字符串参数输出到控制台。请注意，您不需要用双引号括起文本。当您保存更改时，您将看到解决方案项目和库项目的**项目工作目录**（**PWD**）被记录到General
    Messages控制台中：'
- en: '`Project MESSAGE: cm project dir: C:/projects/qt/cm`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project MESSAGE: cm project dir: C:/projects/qt/cm`'
- en: '`Project MESSAGE: cm-lib project dir: C:/projects/qt/cm/cm-lib`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project MESSAGE: cm-lib project dir: C:/projects/qt/cm/cm-lib`'
- en: qmake actually takes multiple passes over `.pro` files, so whenever you use
    `message()`, you may see the same output several times over in the console. You
    can filter out the majority of duplicates using `message()` in conjunction with
    a scope—`!build_pass:message(Here is my message)`. This prevents the `message()`
    method from being called during the build pass.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: qmake实际上会对`.pro`文件进行多次处理，因此每当您使用`message()`时，您可能会在控制台中看到相同的输出多次。您可以使用`message()`与作用域一起来过滤掉大部分重复的内容——`!build_pass:message(Here
    is my message)`。这可以防止在构建过程中调用`message()`方法。
- en: 'If we look back at the default behavior of Qt Creator for shadow builds, we’ll
    see that the aim was to allow multiple builds to sit alongside each other. This
    is achieved by constructing distinct folder names containing the kit, platform,
    and build configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾Qt Creator对于影子构建的默认行为，我们会发现其目的是允许多个构建并存。这是通过构建包含工具包、平台和构建配置的不同文件夹名称来实现的：
- en: '`build-cm-solution-Desktop_Qt_5_10_0_MinGW_32bit-Debug`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-cm-solution-Desktop_Qt_5_10_0_MinGW_32bit-Debug`'
- en: You can see just by looking at the folder name that the contents are from a
    build of the **cm** project using the Qt 5.10.0 for Desktop MinGW 32bit kit in
    Debug mode. We’ll now reimplement this approach in a cleaner and more flexible
    way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看文件夹名称，您就可以看出其中的内容是使用Qt 5.10.0为Desktop MinGW 32位工具包在调试模式下构建的**cm**项目。我们现在将以更清晰和更灵活的方式重新实施这种方法。
- en: Rather than concatenating the information into one long folder name, we'll prefer
    a hierarchical structure consisting of the `Operating System > Compiler > Processor
    Architecture > Build Configuration` folders.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更喜欢一个分层结构，包括`操作系统 > 编译器 > 处理器架构 > 构建配置`文件夹，而不是将信息连接成一个很长的文件夹名称。
- en: 'Let’s first hard-code this path and then move on to automating it. Edit `cm-lib.pro`
    and add this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先硬编码此路径，然后再进行自动化。编辑`cm-lib.pro`并添加以下内容：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is to reflect that we are building with the MinGW 32bit kit on Windows
    in Debug mode. Replace *Windows* with *osx* or *Linux* if you are on a different
    OS. We’ve added another call to `message()` to output this destination directory
    in the General Messages console. Remember that `$$PWD` extracts the working directory
    of the `.pro` file being processed (`cm-lib.pro` in this case), so this gives
    us `<Qt Projects>/cm/cm-lib`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了反映我们正在使用MinGW 32位工具包在Windows上以调试模式构建。如果您使用不同的操作系统，请将*Windows*替换为*osx*或*Linux*。我们在General
    Messages控制台中添加了另一个`message()`调用以输出此目标目录。请记住，`$$PWD`提取正在处理的`.pro`文件（在本例中为`cm-lib.pro`）的工作目录，因此这给了我们`<Qt
    Projects>/cm/cm-lib`。
- en: Right-click on the `cm-lib` project, run qmake, and build. Ensure that you have
    the MinGW kit selected, along with Debug mode.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`cm-lib`项目，运行qmake并构建。确保选择了MinGW工具包以及调试模式。
- en: Navigate to `<Qt Projects>/cm/binaries/<OS>/gcc/x86/debug` in the filesystem,
    and you will see our library binaries without the associated clutter of build
    artifacts. This is a good first step, but if you now change the build configuration
    to Release or switch kits, the destination directory will remain the same, which
    is not what we want.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中导航到`<Qt Projects>/cm/binaries/<OS>/gcc/x86/debug`，您将看到我们的库二进制文件，而不会有构建工件的混乱。这是一个很好的第一步，但是如果您现在将构建配置更改为Release或切换工具包，目标目录将保持不变，这不是我们想要的。
- en: The technique we are about to implement will be used in all three of our projects,
    so rather than having to duplicate the configuration in all of our `.pro` files,
    let’s extract the configuration to a shared file and include it instead.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实施的技术将在我们的三个项目中使用，因此我们不必在所有的`.pro`文件中重复配置，让我们将配置提取到一个共享文件中并进行包含。
- en: 'In the root `cm` folder, create two new empty text files called `qmake-target-platform.pri`
    and `qmake-destination-path.pri`. In `cm-lib.pro`, `cm-tests.pro`, and `cm-ui.pro`, add
    these lines:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在根目录`cm`文件夹中，创建两个名为`qmake-target-platform.pri`和`qmake-destination-path.pri`的新空文本文件。在`cm-lib.pro`，`cm-tests.pro`和`cm-ui.pro`中添加以下行：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add these lines somewhere near the top of the `*.pro` files. The exact order
    doesn’t matter too much as long as they are before the `DESTDIR` variable is set.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*.pro`文件的顶部附近添加这些行。只要它们在设置`DESTDIR`变量之前，确切的顺序并不太重要。
- en: 'Edit `qmake-target-platform.pri` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`qmake-target-platform.pri`如下：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we are leveraging the platform detection capabilities of qmake to inject
    personalized flags into the `CONFIG` variable. On each operating system, different
    platform variables become available. For example, on Windows, the `win32` variable is
    present, Linux is represented by `linux`, and Mac OS X by `macx`. We can use these
    platform variables with curly braces to act like if statements:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了qmake的平台检测功能，将个性化标志注入`CONFIG`变量中。在每个操作系统上，不同的平台变量变得可用。例如，在Windows上，存在`win32`变量，Linux由`linux`表示，Mac
    OS X由`macx`表示。我们可以使用这些平台变量与花括号一起充当if语句：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can consider different combinations of platform variables to figure out what
    compiler and processor architecture the currently selected kit is using, and then
    add developer-friendly flags to the `CONFIG`, which we can use later in our `.pro`
    files. Remember that we are trying to construct a build path—`Operating System
    > Compiler > Processor Architecture > Build Configuration`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'When you save these changes, you should see the flags similar to the following
    in the General Message console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Try switching kits or changing the build configuration, and you should see
    different output. When I switch my kit to Visual Studio 2017 64 bit in Release
    mode, I now get this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the same project on a Linux machine with the MinGW 64 bit kit, I get this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On a Mac using Clang 64 bit, I get the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To get this to work on Windows, I had to make an assumption as `QMAKE_TARGET.arch` is
    not correctly detected for MSVC2017, so I assumed that if the compiler is MSVC2017,
    then it must be x64 as there was no 32 bit kit available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the platform detection is done, we can construct the destination
    path dynamically. Edit `qmake-destination-path.pri`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we create four new variables—*platform_path*, *compiler_path*, *processor_path*,
    and *build_path*—and assign default values to them all. We then use the `CONFIG`
    flags we created in the previous file and construct our folder hierarchy, storing
    it in a variable of our own, called `DESTINATION_PATH`. For example, if we detect
    Windows as the operating system, we add the `PLATFORM_WIN` flag to `CONFIG` and
    as a result of that, set `platform_path` to `windows`. Switching between kits
    and configurations on Windows, I now get these messages:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, I get this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On Linux, I get the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On Mac OS, this is what I get:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can just combine these platform detection and destination path creation
    tricks in one file, but by keeping them separate, you can use the flags elsewhere
    in your project files. In any case, we are now dynamically creating a path based
    on our build environment and storing it in a variable for later use.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to plug this `DESTINATION_PATH` variable into our project
    files. While we’re here, we can also structure our build artifacts using the same
    mechanism by adding a few more lines. Add the following to all three `*.pro` files,
    replacing the `DESTDIR` statement already in `cm-lib.pro`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Temporary build artifacts will now be placed into discreet directories within
    the build folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can fix the problem that brought us here in the first place. In
    `cm-tests` and `cm-ui`, we can now set the `LIBS` variable using our new dynamic
    destination path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can now right-click on the `cm` project, run qmake, and build to automatically
    build all three subprojects in one step. All the output will be sent to the correct
    place and the library binaries can be easily located by the other projects. You
    can switch kits and configurations and not have to worry about referencing the
    wrong libraries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took our project creation skills up to the next level, and
    our solution is now starting to take shape. We implemented an MVC pattern and
    bridged the gap between our UI and business logic projects. We dabbled with our
    first bit of QML and took a look at the cornerstone of the Qt framework, QObject.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We removed all those unsightly `build-cm…` folders, flexed our qmake muscles,
    and took control of where all of our files go. All binaries are now placed in
    the `cm/binaries` folder, organized by platform, compiler, processor architecture,
    and build configuration. All temporary build artifacts that aren’t required by
    the end user are now hidden away. We can freely switch kits and build configurations,
    and have our output automatically rerouted to the correct location.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](a1bf2971-bc20-4266-92fd-d005dfdb3338.xhtml), *User Interface*,
    we will design our UI and get stuck in some more QML.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
