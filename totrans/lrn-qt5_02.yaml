- en: Project Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a new multiproject solution that will be the
    foundation of our example application. We will apply a Model View Controller pattern,
    separating the user interface and business logic. We will also introduce Qt’s
    unit testing framework—QtTest—and demonstrate how to integrate it into our solution.
    We will cover these things in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Projects, MVC, and unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a unit tests project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user interface project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QObject base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling project output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects, MVC, and unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scratchpad application we built in the previous chapter is a Qt project,
    represented by a `.pro` file. In a business environment, technical solutions are
    generally developed as part of company initiatives, and these initiatives are
    generally also called **projects**. To try and minimize confusion (and the number
    of times the word project appears!), we’ll use project to mean a Qt project defined
    by a `.pro` file and the word initiative to refer to projects in the business
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: The initiative we will work on will be a generic client management system. It
    will be something that can be tweaked and re purposed for multiple applications—for
    a supplier managing customers, a health service managing patients, and so on.
    It will perform common tasks found over and over in real-world **Line of Business**
    (**LOB**) applications, principally adding, editing, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Our scratchpad application is entirely encapsulated within a single project.
    For smaller applications, this is perfectly viable. However, with larger code
    bases, particularly with several developers involved, it often pays to break things
    up into more manageable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a super lightweight implementation of the **Model View Controller**
    (**MVC**) architectural pattern. If you haven’t come across MVC before, it is
    primarily used to decouple business logic from the user interface. The user interface
    (View) relays commands to a switchboard style class (Controller) to retrieve the
    data and perform actions it needs. The controller in turn delegates the responsibility
    for the data, logic, and rules to data objects (Models):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39853104-b5e4-4dc3-985b-febae3c11f56.png)'
  prefs: []
  type: TYPE_IMG
- en: The key is that the **View** knows about the **Controller** and the **Model**,
    as it needs to send commands to the **Controller** and display the data held in
    the **Model**. The **Controller** knows about the **Model** as it needs to delegate
    work to it, but it doesn’t know about the **View**. The Model knows nothing about
    either the **Controller** or the **View**.
  prefs: []
  type: TYPE_NORMAL
- en: A key benefit of designing the application this way in a business environment
    is that dedicated UX specialists can work on the views while programmers work
    on the business logic. A secondary boon is that because the business logic layer
    knows nothing about the UI, you add, edit, and even totally replace user interfaces
    without affecting the logic layer. A great use case would be to have a “full fat”
    UI for a desktop application and a companion “half fat” UI for a mobile device,
    both of which can use the same business logic. With all this in mind, we will
    physically segregate our UI and business logic into separate projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at integrating automated unit tests into our solution. Unit
    testing and **Test Driven Development** (**TDD**) has really grown in popularity
    in recent times and when developing applications in a business environment, you
    will more than likely be expected to write unit tests alongside your code. If
    not, you should really propose doing it as it holds a lot of value. Don’t worry
    if you haven’t done any unit testing before; it’s very straightforward, and we’ll
    discuss it in more detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a way to aggregate these subprojects together so that we don’t
    have to open them individually. We will achieve this with an umbrella solution
    project that does nothing other than tying the other projects together. This is
    how we will lay out our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83ae32f5-c0eb-43b2-8d40-d977d7fb3a9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Project creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how easy it is to set up a new project just
    by creating a few text files. However, we’ll create our new solution using Qt
    Creator.  We will use the new project wizard to guide us through creating a top-level
    solution and a single subproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the top menu, select File > New File or Project and then Projects > Other
    Project > Subdirs Project and click on Choose…:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab5a4f70-f441-44b3-bcc1-118ee4ccb301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Subdirs Project is the template we need for our top-level solution project.
    Give it the name `cm` and create it in our `qt` projects folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/466aba05-c61f-436c-82d6-203ad4fe6731.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the Kit Selection pane, check the Desktop Qt 5.10.0 MinGW 32bit kit we installed.
    Feel free to select additional kits you want to try out if you have them installed,
    but it’s not necessary. Click on Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16fccb2b-40e0-484c-a43a-7e926efe6c68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As discussed, version control is beyond the scope of this book, so in the Project
    Management pane, select None from the Add to version control dropdown. Click on Finish
    & Add Subproject:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04cabdf6-7274-4e07-a775-ee9320205a4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll add the user interface project as the first subproject. The wizard follows
    more or less the same pattern as the steps we''ve just followed, so perform the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Projects > Application > Qt Quick Application - Empty and click on Choose...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project Location dialog, give it the name `cm-ui` (for Client Management
    - User Interface), leave the location as our new `cm` folder, and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Define Build System dialog, select the build system qmake and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Define Project Details dialog, leave the default minimal Qt version of
    QT 5.9 and the Use Qt Virtual Keyboard box unchecked then click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Kit Selection dialog, pick the Desktop Qt 5.10.0 MinGW 32bit kit plus
    any other kits you wish to try and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our top-level solution and UI projects are now up and running, so let’s add
    the other subprojects. Add the business logic project next, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Projects pane, right-click on the top-level `cm` folder and select New
    Subproject….
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Projects > Library > C++ Library and click on Choose....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Introduction and Project Location dialog, pick Shared Library as the
    Type, name it `cm-lib`, create it in `<Qt Projects>/cm`, and then click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Select Required Modules dialog, just accept the default of QtCore and
    click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Class Information** dialog, we get the opportunity to create a new
    class to get us started. Give the class name `Client`, with the `client.h` header
    file and the `client.cpp` source file, and then click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the Project Management dialog, skip version control (leave it as
    <None>) and click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will repeat the process to create our unit testing project:'
  prefs: []
  type: TYPE_NORMAL
- en: New Subproject....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Projects > Other Project > Qt Unit Test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project name `cm-tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include QtCore and QtTest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `ClientTests` test class with the `testCase1` test slot and the `client-tests.cpp` filename. Set
    the Type as Test and check Generate initialization and cleanup code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip version control and Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That was a lot of dialog boxes to get through, but we’ve now got our skeleton
    solution in place. Your project folders should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a2a887e-58db-4347-8bf2-67aefbd91625.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll now take a look at each project in turn and make some tweaks before we
    start adding our content.
  prefs: []
  type: TYPE_NORMAL
- en: cm-lib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First off, head to file explorer and create a new subfolder underneath `cm-lib`
    called `source`; move `cm-lib_global.h` there. Create another subfolder in `source`
    called `models` and move both the `Client` class files there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, back in Qt Creator, open up `cm-lib.pro` and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As this is a library project, we do not need to load the default GUI module,
    so we exclude it using the `QT` variable. The `TARGET` variable is the name we
    wish to give our binary output (for example, `cm-lib.dll`). It is optional and
    will default to the project name if not provided, but we’ll be explicit. Next,
    rather than having a `TEMPLATE` of app as we saw in our scratchpad application,
    this time we use `lib` to give us a library. We add c++14 features via the `CONFIG`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `cm-lib_global.h` file is a helpful little bit of preprocessor boilerplate
    we can use to export our shared library symbols, and you’ll see that put to use
    soon. We use the `CMLIB_LIBRARY` flag in the `DEFINES` variable to trigger this
    export.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have slightly rewritten the `SOURCES` and `HEADERS` variable lists
    to account for the new file locations after we moved things around a bit, and
    we add the source folder (which is where all of our code will live) to the `INCLUDEPATH`
    so that the path is searched when we use `#include` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `cm-lib` folder in the Projects pane and select Run qmake.
    When that has finished, right-click again and select **Rebuild**. Everything should
    be green and happy.
  prefs: []
  type: TYPE_NORMAL
- en: cm-tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create new `source/models` subfolders and move `client-tests.cpp` there. Switch
    back to Qt Creator and edit `cm-tests.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This follows pretty much the same approach as with `cm-lib`, with the exception
    that we want a console app rather than a library. We don’t need the GUI module,
    but we will add the `testlib` module to get access to the Qt Test features.
  prefs: []
  type: TYPE_NORMAL
- en: There really isn’t much to this subproject just yet, but you should be able
    to run qmake and rebuild successfully.
  prefs: []
  type: TYPE_NORMAL
- en: cm-ui
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create two subfolders this time: `source` and `views`. Move `main.cpp` into
    `source` and `main.qml` into `views`. Rename `qml.qrc` as `views.qrc` and edit
    `cm-ui.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our UI is written in QML, which requires the `qml` and `quick` modules, so we
    add those. We edit the `RESOURCES` variable to pick up our renamed resource file
    and also edit the `QML_IMPORT_PATH` variable, which we will cover in detail when
    we get into custom QML modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit `views.qrc` to account for the fact that we have moved the `main.qml`
    file into the `views` folder.  Remember to right-click and Open With > Plain Text
    Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we also need to edit a line in `main.cpp` to account for the file
    move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to run qmake and rebuild the `cm-ui` project. Before
    we run it, let’s take a quick look at the build configuration button now that
    we have multiple projects open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dff629a5-d049-416c-a917-5f3dccd1f080.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that now, along with the Kit and Build options, we must also select the
    executable we wish to run. Ensure that `cm-ui` is selected and then run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c87febe8-c33b-44c7-bafc-7e60d634a23e.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello World indeed. It's fairly uninspiring stuff, but we have a multiproject
    solution building and running happily, which is a great start. Close the application
    when you simply can’t take any more fun!
  prefs: []
  type: TYPE_NORMAL
- en: Mastering MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our solution structure is in place, we’ll get started on the MVC implementation.
    As you’ll see, it is very minimal and incredibly easy to set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, expand `cm-ui > Resources > views.qrc > / > views`, right-click on `main.qml`,
    select Rename, and rename the file as `MasterView.qml`. If you get a message about
    project editing, just select Yes to continue anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e30af2b8-81b4-4c6f-9ac3-df51ea1e6ecc.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do get the error message, the file will still appear as `main.qml` in
    the Projects pane, but the file will have been renamed in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit `views.qrc` (right-click on it and select Open With > Plain Text
    Editor). Replace the content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you recall how we load this QML file in `main.cpp`, the syntax is `qrc:<prefix><filename>`.
    We previously had a `/` prefix and a `views/main.qml` relative filename. This
    gave us `qrc:/views/main.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: A prefix of `/` isn’t terribly descriptive. As you add more and more QML files,
    it’s really helpful to organize them into blocks with meaningful prefixes. Having
    unstructured resource blocks also makes the Projects pane ugly and more difficult
    to navigate, as you just saw when you had to drill down through `views.qrc > /
    > views`. So, the first step is to rename the prefix from `/` to `/views`.
  prefs: []
  type: TYPE_NORMAL
- en: However, with a prefix of `/views` and a relative filename of `views/main.qml`,
    our URL is now `qrc:/views/views/main.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: This is worse than it was before, and we still have a deep folder structure
    in `views.qrc`. Fortunately, we can add an *alias* for our file to make both of
    these problems go away. You can use the alias of a resource in place of the relative
    path, so if we assign an alias of `main.qml`, we can replace `views/main.qml`
    with simply `main.qml`, giving us `qrc:/views/main.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s concise and descriptive, and our Projects pane is neater too.
  prefs: []
  type: TYPE_NORMAL
- en: So, going back to our updated version of `views.qrc`, we have simply updated
    the name of the file from `main.qml` to `MasterView.qml`, consistent with the
    file rename we performed, and we have also provided a shortcut alias, so we don't
    have to specify views twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to update our code in `main.cpp` to reflect these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to run qmake, and build and run to verify that nothing has
    broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create a `MasterController` class, so right-click on the `cm-lib`
    project and select Add New… > C++ > C++ Class > Choose…:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b36133d-dd2e-4811-9167-1b302283441b.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the Browse… button to create the `source/controllers` subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: By selecting QObject as the base class and including it, Qt Creator will write
    some of the boilerplate code for us. You can always add it yourself later, so
    don’t feel like it’s a necessary part of creating a new class.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve skipped version control and created the class, declare and define
    it as follows. Our `MasterController` doesn’t do anything particularly exciting
    just yet, we’re just doing the groundwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `master-controller.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All we’ve really added to the default implementation Qt Creator gave us is the `CMLIBSHARED_EXPORT` macro
    Qt Creator wrote for us in `cm-lib_global.h` to take care of our shared library
    exports, and to put the class inside a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: I always have the project name as a root namespace and then additional namespaces
    that reflect the physical location of the class files within the source directory,
    so in this case, I use `cm::controllers`, as the class is located in the directory `source/controllers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is `master-controller.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I use a slightly unorthodox style in the implementation file—most people just
    add `using namespace cm::controllers;` at the top of the `.cpp` file. I often
    like to put the code within the scope of namespaces because it becomes collapsible
    in the IDE. By repeating the innermost namespace scope (*controllers* in this
    example), you can break your code up into collapsible regions much like you can
    in C#, which helps with navigation in larger files, as you can collapse the sections
    you’re not interested in. It makes no functional difference, so use whichever
    style you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: QObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is this funky **QObject** thingy we are inheriting from which keeps
    popping up? Well, it’s the base class for all Qt objects, and it gives us some
    powerful features for free.
  prefs: []
  type: TYPE_NORMAL
- en: QObjects organize themselves into object hierarchies with a *parent* object
    assuming ownership of their *child* objects, which means we don’t have to worry
    (as much!) about memory management. For example, if we have an instance of a Client
    class derived from QObject that is the parent of an Address also derived from
    QObject, then the address is automatically destroyed when the client is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: QObjects carry metadata that allows a degree of type inspection and is the backbone
    for interaction with QML. They can also communicate with each other via an event
    subscription mechanism where the events are emitted as *signals* and the subscribed
    delegates are known as *slots*.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to remember for now is that for any custom classes you write where
    you want to interact with it in the UI, ensure that it derives from QObject. Whenever
    you do derive from QObject, ensure that you always add the magical Q_OBJECT macro
    to your class before you do anything else. It injects a bunch of super complicated
    boilerplate code that you don’t need to understand in order to use QObjects effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now at the point where we need to reference code from one subproject
    (`MasterController` in `cm-lib`) in another (`cm-ui`). We first need to be able
    to access the declarations for our `#include` statements. Edit the `INCLUDEPATH`
    variable in `cm-ui.pro` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `\` symbol is a “continue on to the next line” indicator, so you can set
    a variable to multiple values spanning several lines. Just like console commands,
    ‘..’ means traverse up a level, so here we are stepping up out of the local folder
    (`cm-ui`) and then down into the `cm-lib` folder to get at its source code. You
    need to be careful that the project folders remain in the same location relative
    to each other, else this won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Just below this, we’ll tell our UI project where to find the implementation
    (compiled binary) of our library project. If you take a look at the filesystem
    alongside the top-level `cm` project folder, you will see one or more build folders,
    for example, build-cm-Desktop_Qt_5_9_0_MinGW_32bit-Debug. Each folder is created
    when we run qmake for a given kit and configuration and is populated with the
    output when we build.
  prefs: []
  type: TYPE_NORMAL
- en: Next, navigate to the folder relevant to the kit and configuration you are using,
    and you will find a cm-lib folder with another configuration folder inside it.
    Copy this file path; for example, I am using the MinGW 32 bit kit in Debug configuration,
    so my path is `<Qt Projects>/build-cm-Desktop_Qt_5_10_0_MinGW_32bit-Debug/cm-lib/debug`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that folder, you will find the compiled binaries relevant for your OS, for
    example, `cm-lib.dll` on Windows. This is the folder we want our `cm-ui` project
    to reference for the `cm-lib` library implementation. To set this up, add the
    following statement to `cm-ui.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`LIBS` is the variable used to add referenced libraries to the project. The
    `-L` prefix denotes a directory, while `-l` denotes a library file. Using this
    syntax allows us to ignore the file extensions (`.a`, `.o`, `.lib`) and prefixes
    (lib...), which can vary between operating systems and let qmake figure it out.
    We use the special `$$` symbol to access the value of the `PWD` variable, which
    contains the working directory of the current project (the full path to `cm/cm-ui`
    in this case). From that location, we then drill up two directories with `../..`
    to get us to the Qt projects folder. From there, we drill back down to the location
    where we know the `cm-lib` binaries are built.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is painful to write, ugly as hell, and will fall over as soon as we
    switch kits or configurations, but we will come back and tidy up all this later.
    With the project references all wired up, we can head on over to `main.cpp` in
    `cm-ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use a given class in QML, we need to register it, which we do
    in `main()` before we create the QML Application Engine. First, include the `MasterController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, right after the `QGuiApplication` is instantiated but before the `QQmlApplicationEngine`
    is declared, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is registering the type with the QML engine. Note that
    the template parameter must be fully qualified with all namespaces. We will add
    the type’s metadata into a module called CM with a version number 1.0, and we
    want to refer to this type as `MasterController` in QML markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we instantiate an instance of `MasterController` and inject it into the
    root QML context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you need to set the context property before loading the QML file,
    and you will also need to add the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, we’ve created a controller, registered it with the QML engine, and it’s
    good to go. What now? Let’s do our first bit of QML.
  prefs: []
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qt Modeling Language** (**QML**) is a hierarchical declarative language for
    user interface layout with a syntax similar to **JavaScript Object Notation**
    (**JSON**). It can bind to C++ objects via Qt’s meta object system and also supports
    inline JavaScript. It’s much like HTML or XAML but without the XMLness. If you
    are someone who likes JSON more than XML, this can only be a good thing!'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open up `MasterView.qml`, and we’ll see what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you’ll see is a couple of `import` statements. They are similar
    to `#include` statements in C++—they bring in pieces of functionality that we
    want to use in the view. They can be packed and versioned modules as with QtQuick
    2.9, or they can be relative paths to local content.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the QML hierarchy begins with a Window object. The scope of the object
    is represented by the subsequent `{}`, so everything within the braces is either
    a property or child of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties follow JSON property syntax, of the form key: value. A notable difference
    is that speech marks are not required unless you are providing a string literal
    as a value. Here, we are setting the `visible` property of the Window object to
    be `true` and the size of the window to be 640 x 480 pixels, and we are displaying
    Hello World in the title bar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the title and add a simple message. Replace the Hello World title
    with Client Management and insert a Text component inside the body of the Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your changes, and Run qmake and Run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a1da88e-5508-40df-b5f6-20da69d33968.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s make `MasterController` start earning its keep and rather than hard-coding
    our welcome message in the UI, we’ll obtain it dynamically from our controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `master-controller.h` and add a new public property of the `QString` type called
    `welcomeMessage`, setting it to an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will also need to `#include <QString>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to access this member from QML, we need to configure a
    new property. After the Q_OBJECT macro but before the first public access modifier,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a new property of the QString type that QML can access. QML
    will refer to the property as `ui_welcomeMessage` and when called, will get (or
    set) the value in the `MEMBER` variable called `welcomeMessage`. We are explicitly
    setting the value of the variable up front and will not change it, so it will
    remain `CONSTANT`.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply name the property `welcomeMessage`, rather than `ui_welcomeMessage`.
    My personal preference is to explicitly name things that are solely intended for
    UI consumption with a ui_ prefix to differentiate them from member variables and
    methods. Do whatever works for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to `MasterView.qml`, and we will put this property to use. Change
    the `text` property of the `Text` component to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how the QML editor recognizes `masterController` and even offers code completion
    for it. Now, rather than displaying a string literal as the message, the QML will
    access the `ui_welcomeMessage` property of the instance of `MasterController`
    we injected into the root context in `main()`, which will, in turn, get the value
    of the `welcomeMessage` member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and Run, and you should now see the message coming from the `MasterController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe3e204d-88f4-4203-9859-f16bde93e547.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a working mechanism for QML to call into C++ code and get hold of
    whatever data and business logic we want to provide it. Here, an important thing
    to note is that our `MasterController` knows nothing about the existence of `MasterView`, and
    this is a key part of the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Project output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let our `cm-ui` project know where to find the implementation of
    `cm-lib`, we used the `LIBS` variable in our project file. It was a pretty ugly
    folder name, but it’s only one line and everything has worked perfectly well,
    so it could be tempting to leave things as they are. However, look forward to
    when we are ready to produce our first build for testing or even production. We’ve
    written some really clever code, and everything is building and running beautifully.
    We switch the configuration from Debug to Release and...everything falls over.
    The problem is that we’ve hard-coded the library path in our project file to look
    in the `Debug` folder. Change to a different kit or another operating system and
    the problem is even worse, as you will have binary compatibility issues from using
    different compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set a few goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of the unwieldy `build-cm…` folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate all the compiled binary output into one common folder `cm/binaries`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide all temporary build artifacts in their own folders `cm/<project>/build`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create separate build and binary folders for different compilers and architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect those compilers and architectures automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, where do these funny long folder names come from in the first place? In
    Qt Creator, click on the Projects mode icon in the navigation bar. Down the left-hand
    side in the Build & Run section, select Desktop Qt 5.9.0 MinGW 32 bit > Build.
    Here, you will see the Build Settings for the MinGW kit in this solution and under
    the Shadow build checkbox, you will recognize the long build directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to leave shadow builds enabled as this gives us the capability to perform
    builds to alternative locations for different kits. We will control the exact
    output of our builds in the `.pro` files, but we still need to specify a build
    directory here to keep Qt Creator happy. Enter <Qt Projects>/shadow-builds. Repeat
    this setting for each build configuration (Debug/Release/Profile) using the dropdown
    at the top of the pane, and for all the kits you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a8328e-26ef-439f-8546-7eb661821236.png)'
  prefs: []
  type: TYPE_IMG
- en: In your filesystem, delete any of the old `build-cm…` folders. Right-click on
    the solution folder and Run qmake. After qmake has finished, you should see that
    shell `cm-lib`, `cm-tests`, and `cm-ui` folders have been created in <Qt Projects>/shadow-builds
    and that the long `build-cm…` folders have not reappeared.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for dynamically setting any relative path is to know which path
    you are currently on. We’ve already seen that in action in qmake when we used
    `$$PWD` to get the project working directory. To help us visualize what is going
    on, let’s introduce our first qmake function—`message()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to `cm.pro`—it doesn’t matter where in the file it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to `cm-lib.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `message()` is a test function supported by qmake that outputs the supplied
    string parameter to the console. Note that you don’t need to surround the text
    with double quotes. When you save the changes, you will see the **Project Working
    Directory** (**PWD**) of both the solution project and the library project logged
    out to the General Messages console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Project MESSAGE: cm project dir: C:/projects/qt/cm`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Project MESSAGE: cm-lib project dir: C:/projects/qt/cm/cm-lib`'
  prefs: []
  type: TYPE_NORMAL
- en: qmake actually takes multiple passes over `.pro` files, so whenever you use
    `message()`, you may see the same output several times over in the console. You
    can filter out the majority of duplicates using `message()` in conjunction with
    a scope—`!build_pass:message(Here is my message)`. This prevents the `message()`
    method from being called during the build pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the default behavior of Qt Creator for shadow builds, we’ll
    see that the aim was to allow multiple builds to sit alongside each other. This
    is achieved by constructing distinct folder names containing the kit, platform,
    and build configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build-cm-solution-Desktop_Qt_5_10_0_MinGW_32bit-Debug`'
  prefs: []
  type: TYPE_NORMAL
- en: You can see just by looking at the folder name that the contents are from a
    build of the **cm** project using the Qt 5.10.0 for Desktop MinGW 32bit kit in
    Debug mode. We’ll now reimplement this approach in a cleaner and more flexible
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than concatenating the information into one long folder name, we'll prefer
    a hierarchical structure consisting of the `Operating System > Compiler > Processor
    Architecture > Build Configuration` folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first hard-code this path and then move on to automating it. Edit `cm-lib.pro`
    and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is to reflect that we are building with the MinGW 32bit kit on Windows
    in Debug mode. Replace *Windows* with *osx* or *Linux* if you are on a different
    OS. We’ve added another call to `message()` to output this destination directory
    in the General Messages console. Remember that `$$PWD` extracts the working directory
    of the `.pro` file being processed (`cm-lib.pro` in this case), so this gives
    us `<Qt Projects>/cm/cm-lib`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `cm-lib` project, run qmake, and build. Ensure that you have
    the MinGW kit selected, along with Debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `<Qt Projects>/cm/binaries/<OS>/gcc/x86/debug` in the filesystem,
    and you will see our library binaries without the associated clutter of build
    artifacts. This is a good first step, but if you now change the build configuration
    to Release or switch kits, the destination directory will remain the same, which
    is not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: The technique we are about to implement will be used in all three of our projects,
    so rather than having to duplicate the configuration in all of our `.pro` files,
    let’s extract the configuration to a shared file and include it instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root `cm` folder, create two new empty text files called `qmake-target-platform.pri`
    and `qmake-destination-path.pri`. In `cm-lib.pro`, `cm-tests.pro`, and `cm-ui.pro`, add
    these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Add these lines somewhere near the top of the `*.pro` files. The exact order
    doesn’t matter too much as long as they are before the `DESTDIR` variable is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `qmake-target-platform.pri` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are leveraging the platform detection capabilities of qmake to inject
    personalized flags into the `CONFIG` variable. On each operating system, different
    platform variables become available. For example, on Windows, the `win32` variable is
    present, Linux is represented by `linux`, and Mac OS X by `macx`. We can use these
    platform variables with curly braces to act like if statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can consider different combinations of platform variables to figure out what
    compiler and processor architecture the currently selected kit is using, and then
    add developer-friendly flags to the `CONFIG`, which we can use later in our `.pro`
    files. Remember that we are trying to construct a build path—`Operating System
    > Compiler > Processor Architecture > Build Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you save these changes, you should see the flags similar to the following
    in the General Message console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Try switching kits or changing the build configuration, and you should see
    different output. When I switch my kit to Visual Studio 2017 64 bit in Release
    mode, I now get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the same project on a Linux machine with the MinGW 64 bit kit, I get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On a Mac using Clang 64 bit, I get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To get this to work on Windows, I had to make an assumption as `QMAKE_TARGET.arch` is
    not correctly detected for MSVC2017, so I assumed that if the compiler is MSVC2017,
    then it must be x64 as there was no 32 bit kit available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the platform detection is done, we can construct the destination
    path dynamically. Edit `qmake-destination-path.pri`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create four new variables—*platform_path*, *compiler_path*, *processor_path*,
    and *build_path*—and assign default values to them all. We then use the `CONFIG`
    flags we created in the previous file and construct our folder hierarchy, storing
    it in a variable of our own, called `DESTINATION_PATH`. For example, if we detect
    Windows as the operating system, we add the `PLATFORM_WIN` flag to `CONFIG` and
    as a result of that, set `platform_path` to `windows`. Switching between kits
    and configurations on Windows, I now get these messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, I get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux, I get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac OS, this is what I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can just combine these platform detection and destination path creation
    tricks in one file, but by keeping them separate, you can use the flags elsewhere
    in your project files. In any case, we are now dynamically creating a path based
    on our build environment and storing it in a variable for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to plug this `DESTINATION_PATH` variable into our project
    files. While we’re here, we can also structure our build artifacts using the same
    mechanism by adding a few more lines. Add the following to all three `*.pro` files,
    replacing the `DESTDIR` statement already in `cm-lib.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Temporary build artifacts will now be placed into discreet directories within
    the build folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can fix the problem that brought us here in the first place. In
    `cm-tests` and `cm-ui`, we can now set the `LIBS` variable using our new dynamic
    destination path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can now right-click on the `cm` project, run qmake, and build to automatically
    build all three subprojects in one step. All the output will be sent to the correct
    place and the library binaries can be easily located by the other projects. You
    can switch kits and configurations and not have to worry about referencing the
    wrong libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took our project creation skills up to the next level, and
    our solution is now starting to take shape. We implemented an MVC pattern and
    bridged the gap between our UI and business logic projects. We dabbled with our
    first bit of QML and took a look at the cornerstone of the Qt framework, QObject.
  prefs: []
  type: TYPE_NORMAL
- en: We removed all those unsightly `build-cm…` folders, flexed our qmake muscles,
    and took control of where all of our files go. All binaries are now placed in
    the `cm/binaries` folder, organized by platform, compiler, processor architecture,
    and build configuration. All temporary build artifacts that aren’t required by
    the end user are now hidden away. We can freely switch kits and build configurations,
    and have our output automatically rerouted to the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](a1bf2971-bc20-4266-92fd-d005dfdb3338.xhtml), *User Interface*,
    we will design our UI and get stuck in some more QML.
  prefs: []
  type: TYPE_NORMAL
