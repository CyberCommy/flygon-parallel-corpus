- en: Chapter 2. COM and C++ for Windows 8 Store Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ was first released to the public in 1985 by Bjarne Stroustrup, its creator
    and original implementer. It was first named "C with Classes", extending the C
    language to include true object-oriented features. It was published in 1998 in
    an "official" form and started to gain real traction. In 1998, the ISO standard
    for the language appeared, later to be revised slightly in 2003.
  prefs: []
  type: TYPE_NORMAL
- en: Years went by without a new standard until 2011, in which finally a new C++
    standard was finalized (this process was going on for several years) by the standards
    committee. Going from 1998 to 2011 with nothing official in between made C++ less
    popular than it used to be, mostly because of new languages and platforms that
    appeared, mainly Java (over the various Java platforms) and C# (over the .NET
    platform). Data-driven applications, which traditionally were written in C++,
    were (and still are) written in Java (in the non-Microsoft world) and C# (and,
    to a small extent, other .NET-based languages such as Visual Basic, in the Microsoft
    world). C++ remained a language with many followers, but the lack of advancement
    has shown cracks in the C++ ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: This 13-year gap was not without progress in C++, but it was in the library
    domain, rather than the language domain. The most notable contribution was the
    boost library ([http://www.boost.org](http://www.boost.org)) that contributed
    a lot of high-quality libraries that extended the standard C++ libraries; and
    although boost was not an official standard, it has become a de-facto standard
    among the C++ community. In fact, parts of boost have made it to the new C++11
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C++ committee has decided to expedite matters for future standards and is
    planning a new standard in 2014 (and later in 2017); time will tell.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to C++11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++11 standard was developed for several years, first called "C++0x", where
    "x" was hoped to be a single digit, making the standard final in 2009 at the latest,
    but things didn't turn out that way and the standard was finalized in September
    2011\.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to replace "x" with "b", the hexadecimal equivalent of 11 and
    still maintain a single digit if so desired.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has many new features, some part of the core language and some part of
    the new standard libraries. 13 years is practically an eternity in computer years,
    and that's why there are so many additions to the language; in fact, at the time
    of writing, no compiler (Microsoft and non-Microsoft alike) exists that implements
    the entire C++11 standard. Visual Studio 2010 has implemented several features
    and Visual Studio 2012 implements some more features (and enhances existing features);
    it will probably take a while until all C++11 features are implemented by compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a comprehensive list of supported C++11 features in VS 2012 and VS 2010,
    refer to this blog post by the Visual C++ team: [http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx](http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx).
    More features are expected to be available in relatively frequent updates.'
  prefs: []
  type: TYPE_NORMAL
- en: New features in C++11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll take a look at some of the new C++11 language and library features, that
    make it easier to develop using C++, not necessarily related to Windows 8 Store
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: nullptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nullptr` is a new keyword that replaces the famous value `NULL` as a pointer
    that points nowhere. It doesn''t seem to be a major feature, but this makes any
    `#define` for `NULL` unnecessary and also resolves some inconsistencies. Consider
    the following overloaded functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Which function would be invoked by calling `f1(NULL)`? The (maybe surprising)
    answer is `f1(int)`. The reason is that `NULL` is defined as a simple zero by
    the Microsoft compiler, which is interpreted as an integer by the compiler and
    not a pointer; this means the compiler's overload resolution selects `f1(int)`,
    rather than `f1(const char*)`. `nullptr` solves that; calling `f1(nullptr)` invokes
    the correct function (that accepts an actual pointer). From a purist standpoint,
    it's hard to imagine a language where pointers are of prime importance, not having
    a dedicated keyword to indicate a pointer to nothing. This was mainly for compatibility
    reasons with the C language; now it's finally resolved.
  prefs: []
  type: TYPE_NORMAL
- en: In C++/CX (which we'll discuss later in this chapter), `nullptr` is used to
    indicate a reference to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: auto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `auto` keyword existed since the C language, being a redundant keyword
    that meant "automatic variable", meaning a stack-based variable. The following
    C declaration is legal, but adds nothing of real value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++11, `auto` is used to tell the compiler to automatically infer a variable''s
    type based on its initialization expression. Here are a few declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks ordinary enough. Let''s replace this with the `auto` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running these pieces of code produces the same result (displaying `10` and `20`
    when iterating through the `vector`).
  prefs: []
  type: TYPE_NORMAL
- en: Initializing `x` to `5` using `auto` isn't much better than specifying the actual
    type (`int`); in fact, it's less clear (by the way, `5` is an `int`, whereas `5.0`
    is `double`, and so on). The real power of `auto` is with complex types, such
    as the preceding iterator example. The compiler infers the correct type based
    on the initialization expression. There is no runtime benefit here, it's just
    compile time inference. But, it makes the code (usually) more readable and less
    error prone. The variable type is not some kind of void pointer, it's exactly
    as if the type was specified explicitly. If `x` is an `int`, it will continue
    to be an `int` forever. The programmer does not have to think too hard about the
    correct type, we know it's an iterator (in the preceding example), why should
    we care about the exact type? Even if we do care, why should we write the complete
    type (which may contain template arguments which further enlarge the type expression),
    as the compiler knows the exact type already? `auto` can simplify things, as we'll
    see later on, when dealing with nontrivial WinRT types.
  prefs: []
  type: TYPE_NORMAL
- en: What about the string initialization? In the non-`auto` case, we used `std::string`
    explicitly. What about the `auto` case? It turns out the type of `name` is `const
    char*` and not `std::string`. The point here is that sometimes we need to be careful,
    we may have to specify the exact type to prevent unwanted compiler inference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naturally, specifying something like `auto x;` does not compile, as `x` can
    be of any type—there must be an initialization expression. Similarly, specifying
    something like `auto x = nullptr;` fails to compile as well; again, because `x`
    can be any pointer type (and even non-pointer type with appropriate converting
    constructor).
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lambda functions, or simply lambdas, are a way to create anonymous functions,
    specified inline where needed. Let''s look at an example. Suppose we want to use
    the `transform` algorithm to take some items in a container and generate new items
    based on some transformation function. Here''s one prototype of `transform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `transform` template function accepts, as its last argument, a transformation
    function to be invoked on each and every item specified with the start and end
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to specify that function is by setting up a global (or a class static)
    function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`f1` is passed as the last argument to transform, making `v2` contain the square
    roots of the corresponding numbers in `v`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the "C way" of providing functions—through function pointers. One of
    its drawbacks is that a function cannot maintain state. In C++, we can use a function
    object, known as "functor"—an object masquerading as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the code to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: No state is maintained in this simple case, but it works because of the overloading
    of the function call operator; `transform` doesn't care, as long as it's something
    it can invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'This still isn''t ideal—in both cases we lose code locality—as the invoked
    function is somewhere else. Lambdas solve this by embedding the code exactly where
    it''s needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda function syntax may seem strange at first. The syntax has the following
    ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable capture list in square brackets (empty in the example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments to the function (as expected by its usage), in the previous example
    is an `int` as that's what `transform` expects, given input iterators that point
    to a collection of `int` types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual function body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An optional (and sometimes not so much) return type specifier using some new
    C++11 syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `std::begin` and `std::end` functions are new to C++11, providing a somewhat
    more convenient equivalent to the `begin` and `end` member functions of containers.
    These also work with WinRT collections, as we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to gain when using lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: Code locality is maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibility to use outer scope variables by "capturing" them inside the lambda.
    If it were a separate function, it would be difficult to "transfer" the values
    for the outer scope variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capturing variables can be done by value or by reference. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[=]` captures all outer scoped variables by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[x, y]` captures `x` and `y` by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[&]` captures all outer scope variables by reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[x, &y]` captures `x` by value, `y` by reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without capturing, the lambda function body can only use the arguments provided
    and its own declared variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use lambdas extensively, especially when dealing with asynchronous operations,
    as we'll see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smart pointers are not a language feature, but rather part of the new standard
    library. First introduced by boost, they provide automatic management of dynamically
    allocated objects. Consider this simple object allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very typical dynamic allocation. The problem with that is, well,
    it must be de-allocated at some point. This may seem easy enough, given the following
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even this seemingly simple code is problematic; what if the call to `Car::Drive`
    throws an exception? In that case, the call to delete is skipped and we have ourselves
    a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution? Wrapping the pointer by an automatically allocated object, for
    which the constructor and destructor do the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is known as **Resource Acquisition Is Initialization** (**RAII**). The
    `operator->` ensures accessing the `Car` instance is transparent, making the smart
    pointer smart enough not to interfere with the normal operations of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The destructor takes care of destroying the object. If an exception is thrown,
    the destructor is called no matter what (except catastrophic power failures and
    the like), ensuring the `Car` instance is destroyed before a `catch` handler is
    searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CarPtr` class is a very simple smart pointer, but it still may be useful
    at times. C++11 has a generic implementation of this idea in the form of the `std::unique_ptr<T>`
    class, where `T` is the type whose pointer is to be managed. In our case, we could
    have written the `Car` client code like so (we need to `#include <memory>` for
    this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actual definition of `unique_ptr<>` is more complex than the simple `CarPtr`
    shown here. For example, what about the assignment operator with a different `Car`
    object pointer? What about assignment to `nullptr`? Why should the destructor
    call `delete`—maybe the object was allocated in some other way? These and other
    details are handled by `unique_ptr<>` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '`unique_ptr<>` is simple enough, but what about objects that need to be passed
    around? Destroying the object in the destructor of the `unique_ptr` would be premature.
    For that, we need reference counting, so that when an object is passed to some
    function (or more interestingly, another thread), a counter should increment.
    When the smart pointer''s destructor is called, it should decrement the counter,
    and only if it reaches zero, should it actually destroy the object. That''s exactly
    the role of another new smart pointer class, `shared_ptr<T>`. Here''s an example
    with a `Car` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about `shared_ptr<>` is that it works on any type, the type does
    not need to have any special properties. `shared_ptr<>` allocates an extra reference
    count that is associated with the provided object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred way to initialize `shared_ptr<>` is by using the `std::make_shared<>`
    template function, that accepts parameters passed to the actual type''s constructor.
    It creates the object instance (for example `Car`) along with a reference counter,
    all in one block, hence the extra efficiency. In the `Car` example, this looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important not to mix smart pointers (like `shared_ptr<>`) with ordinary
    pointers, else the object may be destroyed while regular pointers to it are still
    used by other code fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the caveats of reference counting is the problem of cyclic references.
    For example, if some code creates object A, that creates an object B in its constructor
    and passes itself to B, where B holds a smart pointer back to A, and at some point
    the client lets go of its A smart pointer, the cycle will leave A and B alive
    forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Smart pointers](img/5022_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The original client doesn't even know that a memory leak has occurred. This
    is something to be aware of, and as we'll see later, the same problem exists with
    WinRT objects, which are reference counted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to avoid the issue is to use another smart pointer class from C++11,
    `std::weak_ptr<>`. As the name suggests, it holds a weak reference to the object,
    meaning it won''t prevent the object from self-destruction. This would be the
    way B would hold a reference to A in the previous diagram. If that''s the case,
    how can we access the actual object in case we need it? Or, more precisely, how
    do we know it actually still exists? Here''s the way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `weak_ptr<>::lock` function returns a `shared_ptr<>` to the object in question.
    If there is no object, the internal pointer would be null. If there is an object,
    then its ref count is incremented, protecting it from premature destruction even
    if the original `shared_ptr<>` is released. Adding the following line after the
    initialization of `spCar4` would show **Car gone** on the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another way to break the cycle. A can implement a specific method (for
    example `Dispose`), that must be called explicitly by the client. In that method,
    A will release its pointer to B, thus breaking the cycle. The problem here is
    somewhat similar to manually using `new`/`delete`—the function needs to be called
    at the correct time. If called too early it will make the object unusable; `weak_ptr<>`
    is usually preferred.
  prefs: []
  type: TYPE_NORMAL
- en: In today's C++, the recommended approach is to always use smart pointers and
    never use raw pointers. Using the `new` and `delete` operators is considered a
    maintenance headache, that could lead to memory leaks or corruptions because of
    premature object destruction. Smart pointers are cheap to pass around and guarantee
    correct behavior even in the face of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 has a lot of new features, both in the language and in the standard libraries.
    We've seen some of the useful ones, but there are certainly others, such as `rvalue`
    references that provide a way to avoid costly copying operations (and, in fact,
    are used in the container classes such as `std::vector<>`), a new `enum class`
    declaration that solves the outer scope problem of classic enums, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete treatment of the new C++11 features, use web resources such as
    Microsoft's Channel 9 ([http://channel9.msdn.com](http://channel9.msdn.com)),
    the Visual C++ team's blog ([http://blogs.msdn.com/b/vcblog/](http://blogs.msdn.com/b/vcblog/)),
    and Wikipedia ([http://en.wikipedia.org/wiki/C%2B%2B11](http://en.wikipedia.org/wiki/C%2B%2B11)).
    Also, the almost-final draft of the C++11 standard can be found at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: COM and WinRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The COM technology was created by Microsoft at around 1993\. It was first named
    OLE 2.0, because it was used to implement the **Object Linking and Embedding**
    (**OLE**) feature in the Microsoft Office suite. This feature allowed, for example,
    embedding (or linking) an Excel table inside a Word document. The first version
    of OLE (known as OLE 1.0) was implemented by something called **Dynamic Data Exchange**
    (**DDE**), which is a long time Windows feature that is based on messaging. Microsoft
    realized that OLE is just one possible use of a more general technology, and so
    renamed OLE 2.0 to COM.
  prefs: []
  type: TYPE_NORMAL
- en: 'COM contains many details, but is based on very few principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Client programs against interfaces, never against concrete objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components are loaded dynamically rather than statically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an interface? In object-oriented parlance, an interface is an abstraction
    that groups a set of related operations. This abstraction has no implementation,
    but various types may implement the interface in some appropriate way. A client
    can use different implementations because it relies on the interface (being a
    contract) alone and not on any particular implementation that may be provided
    indirectly, for example, by some factory component.
  prefs: []
  type: TYPE_NORMAL
- en: A COM interface is something more precise. It specifies a particular binary
    layout that is provided by the implementer of the interface and consumed by the
    client. Since the layout is known in advance, the contract presented is not just
    logical, but also a binary one. This leads to the possibility of mixing languages
    or technologies when using COM. A COM class can be authored in (say) C++, but
    consumed by Visual Basic or C#, assuming those languages (in this case the .NET
    platform) know the binary layout of the interfaces in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of a COM interface is a virtual table (also known as V-table), which
    is the most common mechanism of implementing virtual functions in C++, making
    C++ a natural choice for developing COM components and COM clients. Here''s a
    definition of a simple interface in C++, as a pure abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, interface names in COM start with a capital "I" and then a name
    in Pascal casing (for example `IAnimal`, `ILibrary`, `IObjectBuilder`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple (inline) implementation of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use any `ICar` interface pointer without knowing anything about the
    actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at an instance of the `Porche` class in memory, using the Visual Studio
    debugger, this is what we find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![COM and WinRT](img/5022_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first field in the instance is a pointer to a v-table (`vptr`). That v-table
    holds pointers to the actual implemented functions on that particular `ICar` implementation,
    `Porche`. Following the v-table pointer, we see the member variables declared
    by the implementation. But using an interface pointer, there's no way of knowing
    what member variables exist (if any); it's an implementation detail that should
    not concern clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define another interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Porche` class wants to implement `ICarrier` as well as `ICar`. Here''s
    the revised definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add some fields to manage objects mounted on the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And implement the two methods (functions) from `ICarrier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact implementation is not important in itself at this time, just the
    layout of the object in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![COM and WinRT](img/5022_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first two members of the `Porche` instance are the v-table pointers to
    `ICar` and `ICarrier` (in that order), each of which points to a virtual table
    of function pointers. Only then the instance member variables are placed. Here''s
    a diagram to show this perhaps more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![COM and WinRT](img/5022_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose a client holds an `ICar*` interface and wants to see if `ICarrier`
    is implemented by the object. Doing a C-style case (or `reinterpret_cast<>`) is
    going to simply make the same pointer value think it's pointing to another v-table,
    but it's not. In this case invoking `ICarrier::PlaceObject` would actually invoke
    `ICar::Start` because that's the first function in that v-table; and functions
    are invoked by offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is to query dynamically whether another interface is supported
    using the `dynamic_cast<>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, `dynamic_cast` adjusts the pointer to the correct v-table. In
    the `Porche` case, the value of `pCarrier` should be greater than `pCar` by pointer
    size (4 bytes in a 32-bit process, 8 bytes in a 64-bit process). We can verify
    that by printing their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![COM and WinRT](img/5022_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The offset is 4, since this code was compiled as 32 bit.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with `dynamic_cast<>` is that it's C++ specific. What would other
    languages do to get another interface on an object? The solution is to factor
    that functionality into every interface. Coupled with reference counting, this
    leads to the most fundamental interface in the world of COM, `IUnknown`.
  prefs: []
  type: TYPE_NORMAL
- en: The IUnknown interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `IUnknown` interface is the base interface of every COM interface. It encapsulates
    two pieces of functionality: querying for other interfaces that may be supported
    and managing the object''s reference count. Here''s its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`QueryInterface` allows getting another supported interface, based on the interface
    ID, which is a **Global Unique Identifier** (**GUID**)—a 128-bit number that''s
    generated by an algorithm that statistically guarantees uniqueness. The returned
    value, an `HRESULT` is the standard return type in COM (and WinRT). For `QueryInterface`,
    `S_OK (0)` means all is well and the requested interface exists (and is returned
    indirectly via the `ppvObject` argument) or `E_NOINTERFACE`, meaning no such interface
    is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All COM/WinRT interface methods are using the standard calling convention (`__stdcall`),
    which says the callee is responsible for cleaning the parameters on the call stack
    (rather than the caller). This matters in the 32-bit world, which has several
    calling conventions. Since COM is intended for cross technology access, this is
    part of the contract (in x64 only one calling convention exists, so this is not
    that important).
  prefs: []
  type: TYPE_NORMAL
- en: '`AddRef` increments the internal reference count of the object and `Release`
    decrements it, destroying the object if the count reaches zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that this is just an interface, and other implementations are possible.
    For example, `AddRef` and `Release` may do nothing for an object that always wants
    to remain in memory, such as a singleton. Most objects, however, are implemented
    as described.
  prefs: []
  type: TYPE_NORMAL
- en: Any COM interface must derive from `IUnknown`; this means that every v-table
    has at least three entries corresponding to `QueryInterface`, `AddRef`, and `Release`
    (in that order).
  prefs: []
  type: TYPE_NORMAL
- en: IInspectable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WinRT can be viewed as a better COM. One of the shortcomings of the `IUnknown`
    interface is that there is no standard way to ask the object to give back a list
    of interfaces it supports. WinRT defines a new standard interface, `IInspectable`
    (that of course derives from `IUnknown`) that provides this capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting method is `GetIids` , returning all interfaces supported
    by the object. This is used by the JavaScript engine running on top of WinRT because
    of the lack of static typing in JavaScript, but it's not generally useful for
    C++ clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The net result of all this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Every WinRT interface must inherit from `IInspectable`. This means every v-table
    always has at least six entries corresponding to the methods `QueryInterface`,
    `AddRef`, `Release`, `GetIids`, `GetRuntimeClassName`, and `GetTrustLevel` (in
    that order).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A WinRT type implements at least `IInspectable`, but will almost always implement
    at least another interface; otherwise, this object would be very dull.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following classic diagram depicts a WinRT object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IInspectable interface](img/5022_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a WinRT object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen, COM/WinRT clients use interfaces to call operations on objects.
    However, one thing was eluded thus far, how did that object come to be? The process
    of creation must be generic enough (and not C++ specific), so that other technologies/languages
    would be able to utilize it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll build a simple example that creates an instance of the WinRT `Calendar`
    class residing in the `Windows::Globalization` namespace, and call some of its
    methods. To remove all possible noise, we'll do that in a simple Win32 console
    application (not a Windows 8 Store app), so that we can focus on the details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last sentence also means that WinRT types (most of them, anyway) are accessible
    and usable from a desktop app, as well as a Store app. This opens up interesting
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use some new APIs that are part of the Windows Runtime infrastructure.
    These APIs start with the letters "Ro" (short for Runtime Object). To that end,
    we''ll need a specific `#include` and to link with the appropriate library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start implementing our main function. The first thing to do is
    to initialize WinRT on the current thread. This is accomplished using the `RoInitialize`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`RoInitialize` requires specifying the apartment model for the thread. This
    can be a **Single Threaded Apartment** (**STA**) denoted by `RO_INIT_SINGLETHREADED`
    or the **Multithreaded Apartment** (**MTA**) denoted by `RO_INIT_MULTITHREADED`.
    The concept of apartments will be discussed a bit later, and is unimportant for
    the current discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RoInitialize` is similar in concept to the classic COM `CoInitialize` (`Ex`)
    functions. WinRT apartments are pretty much the same as the classic COM apartments.
    In fact, since WinRT is built upon COM foundations, most things work very similarly.
    The object creation mechanism is very similar, with some changes to the details
    as we''ll soon see.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an actual object and get back an interface pointer, a call must be
    made to the `RoActivateInstance` API function. This function is prototyped as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first argument that's needed is the full name of the class, represented
    as an `HSTRING`. `HSTRING` is the standard WinRT string type, and represents an
    immutable array of Unicode (UTF-16) characters. Several WinRT APIs exist for creating
    and manipulating `HSTRING`. As we'll see a bit later, C++/CX provides the `Platform::String`
    class to wrap an `HSTRING` for ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `RoActivateInstance` is the resulting instance represented
    through an `IInspectable` interface pointer (recall that all WinRT objects must
    support this interface).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interested readers may be wondering why create a new string type. Surely, there
    are already plenty of those in the Microsoft space: `std::string`/`wstring` (C++),
    `CString` (ATL/MFC), and `BSTR` (COM). `BSTR` seems the most likely candidate
    as it''s not C++ specific. The new `HSTRING` is immutable, meaning it cannot change
    once created. Any apparent modification creates a new `HSTRING`. This attribute
    makes the `HSTRING` thread safe and more easily projectable to other platforms,
    such as .NET, where the `System.String` class is immutable as well, so there is
    no mismatch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `HSTRING`-related APIs, we''ll add `#include` to `<winstring.h>`.
    Now we can go ahead and create an `HSTRING` for the `Calendar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`HSTRING` is created with the `WindowsCreateString` WinRT API, passing the
    string literal and its length (here acquired with the help of `std::wstring`).
    Note, that the class name includes its full namespace where a dot (`.`) is the
    separator (and not the C++ scope resolution operator `::`).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can call `RoActivateInstance` (I've omitted any error checking in these
    code fragments so we can concentrate on the essentials) and get back an interface
    for the Calendar. Since this is `IInspectable`, it's not very interesting. We
    need a more specific interface for the Calendar, that is, we need to call `QueryInterface`
    to get a more interesting interface to work with.
  prefs: []
  type: TYPE_NORMAL
- en: What does `RoActivateInstance` do? How is that instance actually created? Where
    is it implemented?
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure is very similar to the classic COM creation mechanism. `RoActivateInstance`
    consults the Registry at `HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsRuntime\ActiavatableClassId`
    and looks for a key with the name **Windows.Globalization.Calendar**. Here''s
    a screenshot from **RegEdit.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a WinRT object](img/5022_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The screenshot shows the 64-bit key. For 32-bit processes, the key is under
    `HKLM\Software\Wow6432Node\Windows\WindowsRuntime\ActivatableClassId`. This is
    transparent to the process, as the Registry APIs, by default, go to the correct
    location based on the process "bitness".
  prefs: []
  type: TYPE_NORMAL
- en: 'Several values exist in the class **Name** key. The most interesting are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DllPath** – indicates where the implementing DLL resides. This DLL is loaded
    into the calling process address space, as we''ll see in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLSID** – the corresponding GUID of the class name. It''s not as important
    as in classic COM, because WinRT implementations are identified by the full class
    name and not the CLSID, as is evident by the first argument to `RoActivateInstance`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ActivationType** – indicates whether this class is activated in-process (DLL,
    value of 0) or out-of-process (EXE, value of 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the rest of this discussion, we''ll assume an in-process class. `RoActivateInstance`
    calls another function, `RoGetActivationFactory`, that does the actual work of
    locating the Registry key and loading the DLL into the process address space.
    Then, it calls an exported global function from the DLL named `DllGetActivationFactory`
    (the DLL must export such a function, otherwise the creation process fails), passing
    in the full class name, the requested factory interface ID, and an output interface
    pointer as the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That global function inside the DLL is responsible for returning a class factory,
    capable of creating actual instances. The class factory typically implements the
    `IActivationFactory` interface, with a single method (beyond `IInspectable`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Returning the class factory is the job of `RoGetActivationFactory`. Then `RoActivateInstance`
    takes over, and calls `IActivationFactory::ActivateInstance` to create the actual
    instance, which is the result of `RoActivateInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Readers familiar with classic COM may recognize the similarities: `RoActivateInstance`
    replaces the classic `CoCreateInstance`; `RoGetActivationFactory` replaces `CoGetClassObject`;
    `DllGetActivationFactory` replaces `DllGetClassObject`; and finally, `IActivationFactory`
    replaces `IClassFactory`. Overall, though, the steps are practically the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram sums up the creation process of a WinRT type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a WinRT object](img/5022_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Registry keys used in this sequence are relevant to desktop apps creating
    WinRT objects. The keys that a Store app activation uses are different, but the
    general sequence is the same.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, we have an `IInspectable` interface pointer to a Calendar
    instance. But we're interested in a more specific interface that would provide
    the true capabilities of the Calendar.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, the definition of the relevant interface is in a header file,
    named after the namespace where Calendar is placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface in question is named `ICalendar` in the `ABI::Windows::Globalization`
    namespace. We''ll add a `using` namespace for easier access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Application Binary Interface** (**ABI**) is a root namespace that we''ll
    discuss in a later section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need an `ICalendar`, we have to `QueryInterface` for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`pInst` is assumed to be some interface on an object (such as `IInspectable`).
    If that interface is indeed supported, we''ll get back a successful `HRESULT`
    (`S_OK`) and an interface pointer we can use. The `__uuidof` operator returns
    the **interface ID** (**IID**) of the interface in question; this is possible
    because of a `__declspec(uuid)` attribute attached to the declared interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the interface in any way we see fit. Here are some lines that
    get the current time and display it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, the reference count on the `Calendar` instance should be `2`.
    To clean up properly, we need to call `IUnknown::Release` on any obtained interface
    pointer (when created the ref count was `1`, and after `QueryInterface` it became
    `2`); also, since we created an `HSTRING`, it''s a good idea to destroy it; finally
    we''ll uninitialize WinRT on the current thread for good measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found in the `WinRTAccess1` project, part of the downloadable
    code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example used the `<windows.globalization.h>` header file to discover
    the declaration of the `ICalendar` interface, including its IID. However, since
    COM/WinRT is supposed to provide interoperability between languages/platforms,
    how would a non-C++ language be able to use that header file?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that other languages can't use that header file; it's specific
    to C/C++. What we need is a kind of "universal header file", based on a well-defined
    structure and, thus, usable by any platform. This is the role of metadata files.
  prefs: []
  type: TYPE_NORMAL
- en: The format of metadata files (with extension `.winmd`) is based on the metadata
    format created for .NET. This was simply convenient, as that format is rich, providing
    all the necessary ingredients for WinRT metadata as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In classic COM this metadata was stored in a type library. Type library format
    is not as rich as the .NET metadata format, and so wasn't used for WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WinRT metadata files reside in the `%System32%\WinMetadata` folder, and
    they are conveniently arranged based on namespaces (in fact, that''s a requirement).
    Here are the files on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WinRT metadata](img/5022_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view a metadata file, we can use any (relatively new) tool that is capable
    of showing .NET metadata, such as IL Disassembler (`ILDasm.exe`) from the Visual
    Studio 2012 tools, or Reflector ([http://www.reflector.net/](http://www.reflector.net/)).
    Opening `Windows.Globalization.winmd` in `ILDasm.exe` shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WinRT metadata](img/5022_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see all the classes and interfaces defined in the metadata file. Expanding
    the `ICalendar` interface node shows its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WinRT metadata](img/5022_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Double-clicking a method does not show its implementation, as it's not really
    .NET; there's no code there, it's just its metadata format.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the `Calendar` class? Expanding its node shows that it implements
    `ICalendar`. This gives anyone using the metadata (humans, as well as tools) the
    confidence to `QueryInterface` for this interface with a successful result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WinRT metadata](img/5022_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These metadata files are the result of building WinRT components. This way,
    any platform that understands the metadata format, can consume the classes/interfaces
    exposed by that component. We'll see an example later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Runtime Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Calendar usage example worked, but the code required was pretty verbose.
    The **Windows Runtime Library** (**WRL**) is a set of helper classes and functions
    that make it easier to work with WinRT types, both as a client and as a server
    (creator of components). WRL uses standard C++ (no non-standard extensions), keeping
    things pretty close to the metal. Let's see how we can simplify the Calendar example
    by using WRL.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include the WRL headers; there is a main header and a helper
    with some convenient wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add some `using` statements to shorten the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, we first need to initialize WinRT. A simple wrapper calls `RoInitialize`
    in its constructor and `RoUninitialize` in its destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To create and manage an `HSTRING`, we can use a helper class, `HString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The long identifier is the full Calendar class name defined in `<windows.globalization.h>`,
    so we don't have to provide the actual string. `HString` has a `Get()` member
    function that returns the underlying `HSTRING`; its destructor destroys the `HSTRING`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code could actually be simplified (and sped up) by using an `HSTRING`
    that references an existing string, thus preventing actual string allocation and
    copying. This is done with the `HString::MakeReference` static function that internally
    calls `WindowsCreateStringReference`. It effectively removes the need to destroy
    the `HSTRING`, because there was nothing allocated in the first place. This string
    reference is also known as "fast pass".
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the `Calendar` instance can be simplified by calling the `Windows::Foundation::ActivateInstance`
    template function that internally calls `RoActivateInstance` and queries for the
    requested interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`ComPtr<T>` is WRL''s smart pointer for WinRT interfaces. It calls `Release`
    correctly in its destructor, and provides the necessary operators (such as `->`)
    so that it''s invisible enough when accessing the underlying interface pointer.
    The rest of the code is pretty much the same, although no cleanup is necessary,
    as destructors do the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: WRL also provides classes that help implement WinRT components by implementing
    boilerplate code, such as `IInspectable`, activation factories, and so on. We
    will generally use C++/CX to create components, but WRL can be used if low-level
    control is required or language extensions are undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no project template that is installed by default with Visual Studio
    2012 to create WinRT components with WRL; however, such a template was created
    by Microsoft, and is available by searching online when invoking the **Tools**
    | **Extensions and Updates** menu item. This gives a decent starting point for
    creating a WinRT DLL component. The steps involved are somewhat similar to the
    steps used to create classic COM components with ATL defining interfaces and members
    in an **Interface Definition Language** (**IDL**) file, and implementing the required
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: C++/CX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WRL simplifies using and accessing WinRT objects, but it's still a way to go
    from the normal C++ experience when creating and using objects. Calling the `new`
    operator is far easier than using `Windows::Foundation::ActivateInstance` and
    working with a `ComPtr<T>` smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, Microsoft has created a set of extensions to the C++ language,
    called C++/CX that help to bridge the gap, so that working with WinRT objects
    is almost as simple as working with non-WinRT objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections discuss some of the more common extensions. We'll discuss
    more extensions throughout the book. First, we'll look at creating objects, then
    we'll examine various members and how to access them, and finally, we'll consider
    the basics of creating new WinRT types with C++/CX.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WinRT objects are instantiated in C++/CX by the keyword `ref new`. This creates
    a reference counted object (a WinRT object) and returns a handle to the object
    using the `^` (hat) notation. Here''s an example of creating a `Calendar` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The returned value in `cal` is a WinRT object. One thing that may be puzzling
    is that we're getting back a `Calendar` object and not an interface; but COM/WinRT
    clients can work with interfaces only; and where is `ICalendar` we were using
    before?
  prefs: []
  type: TYPE_NORMAL
- en: 'C++/CX provides a layer of convenience that allows using an object reference
    rather than an interface reference. However, the interface `ICalendar` is still
    there, and in fact that''s defined as the default interface for the `Calendar`
    class (the compiler is aware of that), but using the class directly seems more
    natural. We can verify that by adding a method call and looking at the generated
    code after adding a specific cast to `ICalendar` and comparing it to the original
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the generated code for these calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted portions are the same, proving that the actual call goes through
    an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers familiar with C++/CLI, the C++ extensions for .NET, may recognize the
    "hat" (^) and some other similar keywords. This is simply syntax borrowed from
    C++/CLI, but it has nothing to do with .NET. All WinRT stuff is pure native code,
    whether it's accessed using C++/CX or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the hat variable goes out of scope, `IUnknown::Release` is called automatically
    as expected. It''s also possible to use stack semantics with WinRT types, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The object is still allocated dynamically in the usual way. But it's guaranteed
    to be cleaned up when the variable goes out of scope. This means that it cannot
    be passed to other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After obtaining a reference to a WinRT object (or interface), members can be
    accessed with the arrow (`->`) operator, just like a regular pointer. Note, however,
    that the hat is not a pointer in the normal sense; for example, no pointer arithmetic
    is ever possible. The hat variable should be thought of as an opaque reference
    to a WinRT object.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing members through the reference is not exactly the same as accessing
    the object through a direct (or WRL-like) interface pointer. The main difference
    is error handling. All interface members must return an `HRESULT`; calling through
    a hat reference hides the `HRESULT` and instead throws an exception (something
    deriving from `Platform::Exception`) in case of failure. This is usually what
    we want, so that we can use the standard language facilities `try`/`catch` to
    handle errors and not have to check `HRESULT` for every call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference appears in case a method has a return value. The actual
    interface method must return an `HRESULT`, and as such adds an output argument
    (which must be a pointer) where the result would be stored on success. Since hat
    references hide the `HRESULT`, they make the return type the actual return value
    of the method call, which is very convenient. Here''s an example that uses the
    `ICalendar::Compare` method to compare this calendar''s date/time to another''s.
    Using WRL to create a second calendar and compare looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is obtained by passing the target variable as the last argument
    to the `Compare` call. Here''s the equivalent C++/CX version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `HRESULT` is nowhere to be found, and the actual result is returned directly
    from the method call. If an error had occurred, a `Platform::Exception` (or a
    derivative) would have been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What about static methods or properties? These exist, and can be accessed by
    the familiar `ClassName::MemberName` syntax. Curious readers may wonder how these
    are implemented, as COM does not have a notion of static members, everything must
    be accessed through an interface pointer, implying an instance must exist. The
    solution selected is to implement the static members on the activation factory
    (class factory), as it's typically a singleton, effectively giving out the same
    net result.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WinRT is striving for object orientation, at least where members are concerned.
    Methods are member functions, invoked as expected in C++. This was the case with
    `ICalendar::SetToNow()`, `ICalendar::AddMinutes()` , and `ICalendar::Compare()`,
    shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT also defines the notion of properties, which are really methods in disguise.
    A property can have a getter and/or a setter. Since C++ doesn't have the concept
    of properties, these are modeled as methods starting with `get_` or `put_`, while
    C++/CX provides field-like access to the properties for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that uses the `Hour` property defined on `ICalendar`. First,
    the WRL version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the C++/CX version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The existence of properties can be seen in the metadata file, in this case
    `Windows.Globalization.winmd`. Looking at the `Calendar` class (or the `ICalendar`
    interface), the red triangles indicate properties. Double-clicking any of them
    shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Methods and properties](img/5022_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible (with C++/CX) to access the actual method or property without
    the abstraction layer of mapping failed `HRESULT` to exception, if the need arises
    (this is faster, and is equivalent to WRL generated code). This is done by calling
    the member prefixed by `__abi_`, as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All these members return `HRESULT` as these are the actual calls through the
    interface pointer. Curiously enough, property setters must be prefixed by `set_`
    and not `put_`. This scheme also provides a way to call `IInspectable` methods,
    such as `GetIids`, which are otherwise inaccessible through a hat reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, there is no `Intellisense` for these calls, so red squigglies will
    show in the editor. The code compiles and runs as expected, though.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Delegates are the WinRT equivalent of function pointers. A delegate is a kind
    of field that can point to a method. Contrary to function pointers, a delegate
    can point to a static method or an instance method, as required. Delegates have
    built-in constructors that accept a method or a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term "delegate" is used because of its similarity to the same concept from
    the .NET world, where delegates serve much the same purpose as they do in WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example with the `IAsyncOperation<T>` interface, which we''ll discuss
    shortly when we look at asynchronous operations. Given an `IAsyncOperation<T>`
    (`T` is the return type expected from the operation), its `Completed` property
    is of type `AsyncOperationCompletedHandler<T>`, which is a delegate type. We can
    hook up the `Completed` property to a member function of the current instance
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `App::MyHandler` is prototyped like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Why this prototype? This is exactly the thing that a delegate defines: a certain
    prototype that must be followed, else the compiler complains.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to a named method, we can bind the delegate to a lambda function,
    which is more convenient in many cases. Here''s the equivalent lambda to the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The example captures no variables. The key point here is that the arguments
    to the lambda are exactly the same as the case with a named method.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a delegate really? It''s a WinRT class like any other, with a special
    constructor that allows binding to a method (named or lambda) and an `Invoke`
    method that actually executes the delegate. In C++/CX, the invocation can be performed
    by a function call operator `()`, just like any function. Assuming the previous
    declarations, we can invoke the `Completed` delegate in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The two lines are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically, the preceding code is syntactically correct, but we would never
    invoke an asynchronous operation completion ourselves. The owner of the operation
    will do the invocation (we'll look at asynchronous operations later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Delegates are not usually declared as properties as in the `IAsyncOperation<T>::Completed`
    property. There are two reasons for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Anyone can place `nullptr` in that property (or some other delegate), throwing
    away any previous delegate instance that might have been set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone can invoke the delegate, which is weird, as only the declaring class
    knows when the delegate should be invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we want is a way to use delegates to connect to interested methods, but
    do so in a safe way that does not allow arbitrary code to change the delegate
    directly or to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: This is where events come in. An event looks like a delegate, but in fact, it
    has two methods, one for registering a handler for the event and one for revoking
    the handler. In C++/CX, the `+=` and `-=` operators work on events, so that clients
    can register for notifications, but can never use the assignment operator to nullify
    or replace the delegate's value, because it's not exposed in that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using the `Application::Suspending` event that indicates
    to the interested parties that the application is about to be suspended, a good
    time to save a state (we''ll discuss the application lifecycle in [Chapter 7](ch07.html
    "Chapter 7. Applications, Tiles, Tasks, and Notifications"), *Applications, Tiles,
    Tasks and Notifications*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `SuspendingEventHandler` is a delegate type, meaning the method
    `OnSuspending` must be prototyped in a certain way, as defined by that delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, an event is just a pair of methods, implemented appropriately
    (Visual Studio intellisense shows events with a lightning-like icon). Here''s
    a look at the `Application::Suspending` event (other events are shown as well)
    as described via metadata, shown in `ILDasm.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](img/5022_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The inverted green triangle indicates the event member itself, while the `add_Suspending`
    and `remove_Suspending` are the actual methods called when the `+=` and `-=` C++/CX
    operators are used.
  prefs: []
  type: TYPE_NORMAL
- en: Defining types and members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining WinRT types can be done with WRL (by defining interfaces in an IDL
    file, implementing all boilerplate code, such as `IUnknown` and `IInspectable`
    implementations, activation factories, DLL global functions, and so on). This
    provides a very fine-grained way to create components, and is similar in spirit
    to the way COM components were authored with the **Active Template Library** (**ATL**).
  prefs: []
  type: TYPE_NORMAL
- en: With C++/CX, authoring reusable WinRT components is much easier than with WRL.
    In this section we'll build a simple component, and use it with C++ and C# clients
    (a JavaScript client would work just as well and is left as an exercise for the
    interested reader).
  prefs: []
  type: TYPE_NORMAL
- en: A WinRT component project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio 2012 includes a project template for creating a WinRT component
    that can then be used by any WinRT-compliant platform (or another WinRT component).
    We''ll create a new project of type **Windows Runtime Component**, named `Calculations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A WinRT component project](img/5022_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wizard adds a `Class1` class. We can delete that and add a new C++ class
    or do the renaming of files and class name. We''ll create a WinRT class named
    `Calculator`, defined with the following code in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A WinRT class must be defined inside a namespace by the `ref class` keyword.
    It must also be declared `public` so that it would be usable outside the component
    DLL. The class must also be marked `sealed`, meaning it cannot be inherited from;
    or, it can inherit from non-sealed classes, which currently are classes provided
    by the WinRT library residing in the `Windows::UI::Xaml` namespace. A detailed
    discussion of WinRT inheritance is outside the scope of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to give the class some useful content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding properties and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea for the `Calculator` class is to be an accumulating calculator. It
    should hold a current result (starting at zero, by default), and modify the result
    when new mathematical operations are performed. At any time, its current result
    can be obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are added as regular member functions, including constructors. Let''s
    add a constructor and a few operations (within the `public` section of the class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a read-only property to convey the current result. Here''s how to define
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `property` keyword is a C++/CX extension that defines a property, followed
    by its type and its name. Inside the curly braces, `get()` and `set()` methods
    can be declared (`set` must accept the value with the correct type). The missing
    `set()` method indicates this is a read-only property—a `get_Result` method would
    be created, but a `put_Result` method would not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to add a simple read/write property backed by a private field
    by placing a semicolon after the property name (with no curly braces at all).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add whatever `private` members we need to maintain a proper state;
    in this simple case, it''s just the current result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the CPP file, we need to implement all these members, to get away from **unresolved
    external linker** errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special in that code, except perhaps the syntax used to implement
    the `Result` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a WinRT component, a metadata (`.winmd`) file is created as part
    of the build process; this is the file that will be used to consume the component.
    Opening it with `ILDasm.exe` shows the result of the code just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding properties and methods](img/5022_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a few interesting points here. Since we've written a WinRT class,
    it must implement an interface, as WinRT/COM clients can only work with interfaces.
    In the `Calendar` case, the interface was named `ICalendar` (which was its default
    interface), but here we haven't specified any such interface. The compiler created
    such an interface automatically, and it's named `__ICalculatorPublicNonVirtuals`.
    This is the actual interface that defines all the methods and properties. The
    peculiar name hints that these methods are normally only callable from a reference
    to a `Calculator` object; in any case, the interface name is unimportant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clearly, the `Calendar` class was not created with C++/CX, as its default interface
    is named `ICalendar`. In fact, it was created with WRL, which allows complete
    control of every aspect of component authoring, including interface names; WRL
    was used to build all Microsoft-provided WinRT types.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting point concerns the overloaded constructors. Since a non-default
    constructor was provided, the default creation interface, `IActivationFactory`
    is insufficient, and so the compiler created a second interface, `ICalculatorFactory`,
    with a `CreateInstance` method accepting a double value. This is another feature
    that makes C++/CX easy to use—as the burden is on the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make it more interesting, let's add an event that fires in case an attempt
    is made to divide by zero. First, we need to declare a delegate that is appropriate
    for the event, or use one of the already defined delegates in WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''ll define a delegate of our own to show how
    it''s done with C++/CX. We add the following declarations just above the `Calculator`
    definition inside the `Calculations` namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The forward declaration is necessary, as the compiler has not yet stumbled upon
    the `Calculator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The delegate indicates it can bind to any method that accepts a `Calculator`
    instance. What should we do with this delegate declaration? We''ll add an event
    that clients can register for. The following declaration is added inside the `public`
    section of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This declares the event in the simplest possible way—the compiler implements
    the `add_DivideByZero` and `remove_DivideByZero` methods appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the implementation of the `Divide` method, so that the
    event fires in case the passed in value is zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the event invokes all registered observers (clients) for this event,
    passing itself as an argument (that may or may not be useful for clients).
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a WinRT component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to consume the `Calculator` class we just created. We'll build two
    clients, a C++ and a C# client, just to show the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Building a C++ client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create a blank C++ Store application project in the same solution and
    build a simple user interface in XAML to test the functionality of the calculator.
    The user interface details are unimportant for this discussion; the complete code
    can be found in the `CalcClient1` project, available in the downloadable code
    for this chapter. The UI looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a C++ client](img/5022_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the definition of our `Calculator`, we need to add a reference to the
    metadata file. This is available by right-clicking on the project node and selecting
    **References…**. In the shown dialog box, we select the **Calculations** project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a C++ client](img/5022_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the definitions are available, we can use them. In `MainPage.xaml.h`,
    we add a reference to a `Calculator` object, so that it exists for the lifetime
    of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainPage` constructor, we need to actually create the instance and
    optionally connect to the `DivideByZero` event (which we do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`_error` is a `TextBlock` element within the UI that shows the last error (if
    any). A `using namespace` for `Calculations` was also added so that the preceding
    code can compile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the **Calculate** button is clicked we need to perform the actual operation
    based on the currently selected index in the listbox that hosts the available
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: For this code to compile, a `using` `namespace` statement was added for `std`
    and an `#include` was added for `<sstream>`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We have consumed a WinRT component. Technically, there is no easy
    way to know in what language that was written. The only thing that matters is
    that it's a WinRT component.
  prefs: []
  type: TYPE_NORMAL
- en: Building a C# client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see how this works with another client—a Store app written with C#. First,
    we'll create a blank C# Store application (named `CalcClient2`) and copy the XAML
    as is to the C# project from the C++ client project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add a reference to the `winmd` file. Right-click on the project
    node and select **Add Reference…** or right-click on the **References** node and
    select **Add Reference…**. A similar dialog appears, allowing the selection of
    the `Calculations` project (or browsing the filesystem for the file if it's a
    different solution).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual code needed to use `Calculator` is similar to the C++ case, with
    the syntax and semantics of C# (and .NET). In `MainPage.xaml.cs`, we create a
    `Calculator` object and register for the `DivideByZero` event (using a C# lambda
    expression):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, a lambda expression can be written without specifying the exact types
    (as shown in the preceding code snippet); the compiler infers the types on its
    own (because the delegate type is known). It's possible (and legal) to write the
    type explicitly like `_calculator.DivideByZero += (Calculator calc) => { … };`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `using` `Calculations` statement was added at the top of the file. The button''s
    click event handler is pretty self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar the C# code that accesses the calculator is to the C++ version.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Binary Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Calculator` WinRT class created in the previous section leaves some questions.
    Suppose the following method was added to the public section of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler would refuse to compile this method. The reason has to do with
    the use of `std::wstring`. It''s a C++ type—how would that project into C# or
    JavaScript? It can''t. Public members must use WinRT types only. There is a boundary
    between the internal C++ implementation and the public-facing types. The correct
    way to define the method in question is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`Platform::String` is the C++/CX wrapper over a `HSTRING` WinRT, which is projected
    as `System.String` to C# and to a JavaScript `string` in that world.'
  prefs: []
  type: TYPE_NORMAL
- en: Private members in a WinRT class can be anything, and more often than not these
    are native C++ types (such as `wstring`, `vector<>`, and anything else that may
    have been migrated from older code).
  prefs: []
  type: TYPE_NORMAL
- en: Simple types, such as `int` and `double` are automatically mapped between C++
    and WinRT. The **Application Binary Interface** (**ABI**) is the boundary between
    WinRT types (that are consumable outside the component) and the native types that
    are specific to the language/technology (true not just for C++, but for C# as
    well).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows 8 Store applications promise to be "fast and fluid". This expression
    has several meanings, some of which are related to user experience and user interface
    design (which won't concern us here), and some related to application responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ever since the first version of the Windows OS, user interface was handled
    by a single thread in an application. Technically, a thread may create any number
    of windows, and that thread becomes the owner of those windows, and is the only
    thread that can handle messages targeting those windows (through a message queue).
    If that thread becomes very busy and does not handle messages quickly enough,
    the UI becomes less responsive; in extreme cases, if the thread is stuck for several
    seconds or longer (for whatever reason), the UI becomes completely unresponsive.
    This situation is pretty familiar and highly undesirable. The following diagram
    illustrates the entities involved in UI processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous operations](img/5022_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key to responsiveness is to free the UI thread as soon as possible and never
    block it for more than a few milliseconds. In the world of desktop apps, there's
    nothing stopping the developer from calling some long running operation (or some
    long I/O operation), thus preventing the thread from returning to its pumping
    messages activity, freezing the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In WinRT, Microsoft has made a conscious decision that if an operation may
    take longer than 50 milliseconds, then it should be made asynchronous rather than
    synchronous. The net result is that many methods are executed asynchronously,
    something that can potentially complicate code. Asynchronous means that the operation
    starts, but the call returns almost immediately. When the operation is complete,
    some callback is invoked, so that the application can take further steps. In between,
    though, the UI thread is doing nothing special and, thus, can pump messages as
    usual, keeping the UI responsive. The difference between synchronous and asynchronous
    calls can be illustrated with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous operations](img/5022_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous operations, although desirable, are more complicated by definition.
    The code is not sequential anymore. WinRT defines some interfaces that represent
    on-going operations. These interfaces are returned from various asynchronous methods
    that start an operation and allow the client to register for the time the operation
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of asynchronous operations and how we can handle them.
    We'll create a simple image viewer application that allows a user to browse for
    an image and show it (the complete source is in the `SimpleImageView` project
    available with this chapter's downloads). The user interface is not important
    at the moment, consisting of a button that initiates the user's selection process
    and an `Image` element that can show images. When the button is clicked we want
    to provide the user with a way to select image files and then convert the file
    to something an `Image` element can show.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WinRT class to use for selecting files is `Windows::Storage::Pickers::FileOpenPicker`.
    We''ll create an instance and set some properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers familiar with the desktop app world may wonder where the common open
    file dialog is, which is available through the Win32 API or other wrappers. That
    dialog cannot be used in a Store app for several reasons. The first is aesthetic;
    the dialog is ugly, compared to the modern UI that Windows 8 Store apps try to
    convey. Second, the dialog has a title bar and other such chrome, and as such
    is not suitable for the new world. And third (most importantly), `FileOpenPicker`
    is not just about selecting files from the filesystem. It actually works with
    the File Open Picker contract, implemented (for example) by the camera (if one
    is attached), so we can actually take a picture and then select it; the same is
    true for other sources, such as SkyDrive, Facebook, and so on. The common open
    file dialog has no such functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to show that picker and allow the user to select something. Looking
    at the `FileOpenPicker` API, we find the `PickSingleFileAsync` method. The `Async`
    suffix is the convention used in the WinRT API to indicate a method that starts
    an asynchronous operation. The result of picking a file should be an instance
    of `Windows::Storage::StorageFile`, but instead it returns an `IAsyncOperation<StorageFile^>`,
    which is an object representing the long running operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to work with this is to set the `Completed` property (a delegate) to
    a handler method that will be invoked when the operation completes (this can be
    a lambda function). When that function is called, we can call `IAsyncOperation<T>::GetResults()`
    to get the actual `StorageFile` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, that's not the end of it. Once the file is available, we need
    to open it, convert its data into a WinRT stream interface and then feed it to
    a `BitmapImage` object that can be rendered into an `Image` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that opening a `StorageFile` is an asynchronous operation, too
    (remember, that file can be from anywhere, such as SkyDrive or a network share).
    We repeat the same sequence after the file is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`_image` is the `Image` element that should display the resulting image using
    its `Source` property.'
  prefs: []
  type: TYPE_NORMAL
- en: This almost works. The "almost" part is a bit subtle. The previous lambda is
    called by a different thread than the thread that initiated the call. The UI thread
    started it, but it returned on a background thread. Accessing UI elements (such
    as the `Image` element) from a background thread causes an exception to be thrown.
    How can we fix that?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Dispatcher` object that is bound to a particular thread in
    the case of the UI and ask it to execute some piece of code (specified typically
    as a lambda) on the UI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`Dispatcher` is a property of `this` (or any UI element for that matter), that
    posts an operation to be executed by the UI thread when possible (typically almost
    immediately, assuming the UI thread is not blocked, which we work very hard to
    avoid).'
  prefs: []
  type: TYPE_NORMAL
- en: This whole sequence was not easy, and adding the `Dispatcher` to the mix complicates
    things further. Fortunately, there is an easier way to work with asynchronous
    operations—using the `task<T>` class.
  prefs: []
  type: TYPE_NORMAL
- en: Using tasks for asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `task<T>` class resides in the concurrency namespace and requires `#include`
    to `<ppltasks.h>`. This class is new to C++11, and is generally related to parallel
    programming, but here it serves a special purpose for invoking asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `task<T>` class represents an operation whose result is of type `T`. It
    handles the gory details of the `Completed` property registration, calling `GetResults`,
    and using the `Dispatcher` automatically to maintain thread affinity in case the
    operation was invoked from the UI thread (technically, a call from a Single Threaded
    Apartment). And all this with nice composition in case we need to invoke several
    asynchronous operations in sequence (which is true for the case in hand). Here''s
    the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_task<T>` function is a convenience that creates a `task<T>` with
    the correct `T`; `create_task<T>` allows using the `auto` keyword. An equivalent
    alternative would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The then instance method expects a function (sometimes called continuation,
    typically a lambda) that should execute upon completion of the asynchronous operation.
    It provides the result without any need to call `IAsyncOperation<T>::GetResults()`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the composition. After the `StorageFile` is available, another task is
    created and returned from the lambda. This initiates yet another asynchronous
    operation, to be resolved by the next `then` call.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the continuations run on the same thread as the operation initiator,
    if that initiator is running in an STA (which is the case for the UI thread).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This apartment awareness only works for operations returning `IAsyncAction<T>`
    or `IAsyncOperation<T>` (and their derivatives).
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An asynchronous operation, by definition, may be long running, so it's a good
    idea to expose an ability to cancel the operation (if possible). The `IAsync*`
    family of interfaces have a `Cancel` method that we can call (for example, from
    some **Cancel** button's click event handler), but it's difficult to expose the
    `IAsync*` object to outside code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the `task<>` class provides an elegant solution. A second parameter
    to the task constructor (or the `create_task` auxiliary function) is a `cancellation_token`
    object. This token is obtained from a `cancellation_token_source` object using
    its `get_token()` instance method. `cancellation_token_source` represents an operation
    that is cancellable. An outside caller can use its `cancel()` method to "signal"
    all `cancellation_token` objects (typically just one) that were handed out by
    the `cancellation_token_source`, causing the task(s) to call the `IAsync*::Cancel`
    method. The following diagram illustrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cancelling asynchronous operations](img/5022_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The net result is that if an operation is cancelled, a `task_canceled` exception
    is thrown. It''s propagated (if unhandled) down the `then` chain, so that it can
    be caught conveniently on the last `then`—in fact, it''s better to add a last
    `then` that does cancellation (and error) handling only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `task<>::get()` method is the one throwing the exceptions. Note that `task_canceled`
    does not derive from `Platform::Exception`, so it needs a separate `catch` clause
    to be caught.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some operations simply return a `nullptr` object to indicate cancellation. This
    is the case with the `FileOpenPicker` example. If the `StorageFile` object returned
    is `nullptr`, this means the user selected the **Cancel** button when selecting
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In asynchronous operations, exceptions may be thrown. One way to handle those
    is by adding `try`/`catch` blocks to the appropriate continuations. A more convenient
    approach is to handle all errors in the last `then` continuation, in much the
    same way as cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WinRT is a new library we want to use to get access to Windows 8 features in
    this new Store apps model. What about existing C++ libraries, such as the **Standard
    Template Library** (**STL**), **Active Template Library** (**ATL**), **Microsoft
    Foundation Classes** (**MFC**), or some other custom libraries? What about the
    raw Win32 API? In the following sections, we'll address the common Microsoft libraries
    and their use in Windows 8 Store apps.
  prefs: []
  type: TYPE_NORMAL
- en: STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL is part of the standard C++ libraries (and sometimes considered a synonym
    for it), and is fully supported in Windows 8 Store apps. In fact, some of the
    WinRT type wrappers know about STL, making it easier to interoperate.
  prefs: []
  type: TYPE_NORMAL
- en: MFC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MFC library was created more than 20 years ago, to provide a C++ layer over
    the Windows API (Win16 at the time of creation), mostly for easier creation of
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8 Store apps provide their own user interface that is very far from
    the Windows `User32.dll` APIs (which MFC wraps), making MFC obsolete and unusable
    in the new world. Existing code must be migrated to using XAML, user controls,
    control templates, or whatever is appropriate for the application in question.
  prefs: []
  type: TYPE_NORMAL
- en: ATL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ATL was created to assist in building COM servers and clients, easing the burden
    of implementing common functionality such as `IUnknown`, class factories, component
    registration, and the like. It can technically be used in Windows Store apps,
    but there's really no point. Anything on that level is covered by the WRL that
    was discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Win32 API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Win32 API (or the Windows API) is a huge set of mostly C-style functions and
    some COM component that has been, and still is, the low-level API to the Windows
    OS in user mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every documented function now includes an "applied to" clause, stating whether
    that API is usable in desktop apps, Store apps, or both. Why would some functions
    be unavailable in a Windows Store app? A few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Some functions are related to a user interface that is inappropriate for Windows
    Store. For example, `MessageBox` and `CreateWindowEx`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some functions have equivalents in the WinRT API (which is usually superior).
    For example `CreateFile` (although a new `CreateFile2` API exists that works with
    Store apps as well), `CreateThread`, and `QueueUserWorkItem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some functions are inappropriate in some other way, such as violating security
    constraints. For example `CreateProcess` and `EnumWindows`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a forbidden API fails to compile; that's because the Windows API headers
    have been changed to conditionally compile based on two constants, `WINAPI_PARTITION_APP`
    (for Store apps) and `WINAPI_PARTITION_DESKTOP` (for desktop apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, it''s possible to redefine a forbidden function and call it.
    Here''s an example that would work for the `MessageBox` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Linking to the appropriate library is required in this case, as `user32.dll`
    is not linked in, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this works, and a message box would appear if this function is called,
    don''t do it. The reason is simple: the Windows 8 Store certification process
    will fail any application that uses a forbidden API.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the allowed Windows API functions can be found at [http://msdn.microsoft.com/en-us/library/windows/apps/br205757](http://msdn.microsoft.com/en-us/library/windows/apps/br205757).
  prefs: []
  type: TYPE_NORMAL
- en: CRT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **C Runtime** (**CRT**) library contains a slew of functions, originally
    created as the support library for the C language. Many of those functions are
    unavailable in Store apps; usually there is a Win32 or WinRT equivalent. For a
    comprehensive list of unsupported functions, refer to [http://msdn.microsoft.com/EN-US/library/jj606124.aspx](http://msdn.microsoft.com/EN-US/library/jj606124.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: DirectX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DirectX is a set of low-level, COM-based APIs, originally created more than
    20 years ago, for the purpose of accessing the multimedia capabilities of the
    PC (graphics, audio, input, and so on) while leveraging the hardware capabilities
    (such as the graphic card). DirectX has been used for years mostly in the gaming
    industry.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8 comes with DirectX 11.1 installed, providing a base for creating high
    performance games and applications. It's fully supported with Store apps, and
    can even coexist with XAML-based UI.
  prefs: []
  type: TYPE_NORMAL
- en: C++ AMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++ **Accelerated Massive Parallelism** (**AMP**)is a relatively new library
    that has a lofty goal: the ability to use a mainstream programming language (C++)
    to execute code on CPU and non-CPU devices. Currently, the only other supported
    device is the **Graphics Processing Unit** (**GPU**).'
  prefs: []
  type: TYPE_NORMAL
- en: Modern GPUs are capable of much parallelism, but originally they have their
    own languages for programming arbitrary algorithms that may be unrelated to graphics
    per se. C++ AMP is an attempt to work with C++, but still be able to run the GPU
    (and other devices in the future).
  prefs: []
  type: TYPE_NORMAL
- en: C++ AMP is fully supported with Windows 8 Store apps (and requires a DirectX
    11 capable card).
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Runtime class library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WinRT provides a comprehensive class library, arranged in hierarchical namespaces;
    from strings and collections, to controls, to devices, to networking, to graphics;
    the API covers a lot of ground. Part of the journey into Windows Store apps is
    learning the various APIs and capabilities that are supported. This kind of knowledge
    evolves with time. During the course of this book, we'll discuss a fair amount
    of WinRT APIs, but certainly not all of it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll discuss some of the core types that are used
    frequently with Store apps and how they are mapped specifically (if at all) to
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WinRT defines its own string type, `HSTRING`. We have already met it a few times.
    Since `HSTRING` is just an opaque handle to an immutable string, Windows provides
    some functions for managing `HSTRING`, such as `WindowsCreateString` , `WindowsConcatString`
    , `WindowsSubString` , `WIndowsGetStringLen` , `WindowsReplaceString` , and others.
    Working with these APIs is not difficult, but very tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, an `HSTRING` is wrapped by a reference counted class, `Platform::String`,
    which provides the necessary calls behind the scenes to the appropriate APIs.
    It can be constructed given a raw Unicode character pointer (`wchar_t*`) and has
    a `Data()` method that returns a raw pointer back. This means that interoperating
    `Platform::String` with `std::wstring` is fairly easy. Here are a few example
    of using strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Notice the iterator-like behavior achieved with `Platform::begin` and `Platform::end`.
    As a general guideline, when authoring components, it's better to work with a
    `std::wstring` for all string operations, as `wstring` has a rich function set.
    Use `Platform::String` only at the ABI boundary; `Platform::String` has very little
    functionality built in.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standard C++ defines several container types, such as `std::vector<T>`, `std::list<T>`,
    `std::map<K, V>`, and others. These types, however, cannot cross the ABI boundary—they
    are C++ specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT defines its own collection interfaces that must be used across the ABI
    boundary. Here''s a class diagram with those interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collections](img/5022_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`IIterable<T>` has just one method: `First`, which returns an `IIterator<T>`,
    which is the WinRT iterator interface. It defines the methods `MoveNext` and `GetMany`
    and two properties: `Current` returns the current object the iterator points to
    and `HasCurrent` indicates whether there are any more items to iterate over.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IVector<T>` represents a sequence of items that are accessible by index. It''s
    a common type to use across the ABI. The C++ support library provides a stock
    implementation for `IVector<T>` named `Platform::Collections::Vector<T>`. This
    could be used as the underlying private type within a WinRT class, because it''s
    convertible to `IVector<T>` when needed. Note, however, that for heavy duty operations
    the STL `std::vector<T>` is more efficient. If `Vector<T>` is needed at some point,
    it has many constructors, some of which accept `std::vector<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IVectorView<T>` represents a read only view into a vector. It can be obtained
    from an `IVector<T>` by calling the `GetView` method. `VectorView<T>` is a C++
    private implementation that may be used if needed by custom implementations of
    `IVector<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IObservableVector<T>` inherits from `IVector<T>` and adds a single event,
    `VectorChanged`. This may be useful for clients that want notifications when items
    are added, removed, or replaced in the `IObservableVector<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `IMap*` series of interfaces manage key/value pairs, and are transferrable
    across the ABI boundary. `Platform::Collections::Map<K,V>` provides an implementation
    convertible to this interface, as a balanced binary tree, similar to `std::map<K,V>`
    (including the ability to change the ordering algorithm via a third template argument).
    `IMapView<K,V>` is a read-only view of a `IMap<K,V>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most useful collection type for the ABI is `IVector<T>`. If you can live
    with `Vector<T>` as the underlying implementation, do so. Otherwise, maintain
    a `std::vector<T>` and convert to `IVector<T>` only when crossing the ABI boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COM/WinRT does not work with exceptions. The reason may be obvious, exceptions
    are language or platform specific. They cannot be part of a binary standard that
    various platforms adhere to. Instead, COM uses `HRESULT`, which are just 32-bit
    numbers to indicate the success or failure of method calls.
  prefs: []
  type: TYPE_NORMAL
- en: C++, however (and most other modern languages, such as C#) support the notion
    of exceptions. Handling errors by catching exceptions is far easier and maintainable
    than checking `HRESULT` after each call (C-style of programming). That's why the
    calls made through C++/CX reference counted object (hat) translates a failed `HRESULT`
    into an exception object, derived from `Platform::Exception` that can be caught
    in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: This is also true the other way around; when implementing a component in C++/CX,
    the code can throw an exception derived from `Platform::Exception`; this exception
    cannot cross the ABI; instead, it's translated to an equivalent `HRESULT`, which
    is the thing that can cross the ABI. On the other side, it may be turned into
    an exception object again for that client platform, such as a C++ exception or
    a .NET exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of exception types deriving from `Platform::Exception` is predefined
    and cannot be extended, because each type maps directly to an `HRESULT`. This
    means it''s not possible to add new exception types, because C++/CX can''t know
    to which `HRESULT` to translate the exception when crossing the ABI. For custom
    exceptions, `Platform::COMException` can be used with some custom `HRESULT`. The
    complete table of exception types and their `HRESULT` equivalent is shown, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exceptions](img/5022_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the exception types in the table are self-explanatory. We'll discuss
    some of these exceptions later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throwing something that does not inherit from `Platform::Exception` will be
    translated to an `E_FAIL` `HRESULT`.
  prefs: []
  type: TYPE_NORMAL
- en: All exception types have an `HResult` property with the underlying `HRESULT`
    value and a `Message` property, which is a textual description of the exception
    (supplied by WinRT and cannot be changed).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with some of the new C++11 features that may be useful
    for WinRT development. We discussed COM, its concepts and ideas and how they are
    translated into WinRT. WRL provides helpers for accessing WinRT objects without
    language extensions. C++/CX provides language extensions that make it far easier
    to work with WinRT and to author WinRT components.
  prefs: []
  type: TYPE_NORMAL
- en: WinRT has some patterns and idioms we need to learn and get used to, such as
    ways to work with asynchronous operations, strings, collections, and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: The coverage in this chapter was not exhaustive, but it should give us enough
    power and understanding to start writing real applications. We'll take a look
    at some other C++/CX capabilities and other WinRT-related features in later parts
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive into building applications, starting with XAML
    and the way user interfaces are commonly built in WinRT.
  prefs: []
  type: TYPE_NORMAL
