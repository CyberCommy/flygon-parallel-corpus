- en: Chapter 4. Thread Carefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Premature optimization is the root of all evil."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*-Donald Knuth* |'
  prefs: []
  type: TYPE_TB
- en: 'We covered a very important concept in the previous chapter: content provider.
    We progressed in a step-by-step manner, covering essential questions such as how
    to create a content provider and how to use an existing system with a content
    provider in detail. We also covered how to use the content provider we created
    by means of creating a test application to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to use loaders, in particular, a loader
    called cursor loader. We will look at how to interact with a content provider
    asynchronously with the help of an example. We will discuss the important topic
    of security in the Android database and how we can ensure that data is secured
    in an Android model. Last but not least, we will also see some code snippets that
    will cover topics such as how to upgrade a database and how to ship a preloaded
    database with our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with CursorLoader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General tips and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data with CursorLoader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CursorLoader` is part of the loader family. Before we dive deep into an example
    explaining how to use `CursorLoader`, we will explore a bit about loaders and
    why it is important in the current scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introduced in HoneyComb (API level 11), **loaders** serve the purpose of asynchronously
    serving data in an activity or fragment. The need to have loaders arose from many
    things: calls to various time-consuming methods on the main UI thread in order
    to fetch data that leads to a clunky UI, and even in some cases, the dreaded ANR
    box. This is demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loaders](img/2951OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, the `managedQuery()` method, which was deprecated in API 11, was
    a wrapper around the `ContentResolver'squery()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, while highlighting how to fetch data from a content
    provider inside the query method, we used `getContentResolver.query()` instead
    of `managedQuery()`. Using deprecated methods can lead to problems with future
    releases and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders provide asynchronous loading of data for an activity of fragment on
    a non-UI thread. The loader or the subclasses of a loader perform their work in
    a separate thread and deliver their results to the main thread. The segregation
    of calls from the main thread and the posting of results on the main thread while
    working in a separate thread ensure that we have a responsive application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Post the loader era, we were faced with problems such as when an activity should
    be recreated due to a configuration change, for instance, rotation of a device's
    orientation. We had to worry about data and refetch data while creating a new
    instance. But with loaders, we don't have to worry about all these as loaders
    automatically reconnect to the last loader's cursor when being recreated after
    a device configuration change and refetch the data. As an added bonus, loaders
    monitor the data source and deliver new results when the content changes. In other
    words, loaders automatically get updated, and hence, there is no need to requery
    the cursor. Read more about keeping your Android application responsive and avoiding
    **application not responding** (**ANR**) messages at the Android developer website,
    [http://developer.android.com/training/articles/perf-anr.html](http://developer.android.com/training/articles/perf-anr.html).
  prefs: []
  type: TYPE_NORMAL
- en: Loader API's summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the loader API that consists of various classes and interfaces.
    In this section, we will look at the implementation aspect of loader API''s classes/interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class/interface | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LoaderManager` | This is an abstract class associated with an activity or
    fragment to manage a loader. Although there can be one or more loader instances,
    only one instance of `LoaderManager` per activity or fragment is permitted. It
    is responsible for dealing with the activity or fragment''s life cycle and particularly
    helpful when running long-running tasks. |'
  prefs: []
  type: TYPE_TB
- en: '| `LoaderManager.LoaderCallbacks` | This is a callback interface we must implement
    to interact with `LoaderManager`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Loader` | This is the base class for a loader. It''s an abstract class that
    performs asynchronous loading of data. We can implement our own subclass instead
    of using subclasses such as `CursorLoader`. |'
  prefs: []
  type: TYPE_TB
- en: '| `AsyncTaskLoader` | This is an abstract loader that provides `AsyncTask`
    to perform the work in the background, that is, on a separate thread; however,
    the result is delivered on the main thread. According to the documentation, it
    is advised to subclass `AsyncTaskLoader` instead of directly subclassing the `Loader`
    class. |'
  prefs: []
  type: TYPE_TB
- en: '| `CursorLoader` | This is a subclass of `AsyncTaskLoader` that queries `ContentResolver`
    on the background thread in a non-blocking manner and returns a cursor. |'
  prefs: []
  type: TYPE_TB
- en: Using CursorLoader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loaders provide us with a lot of handy features; one of them is that once our
    activity or fragment implements a loader, it need not worry about refreshing the
    data. A loader monitors the data source for us, reflects any changes, and even
    performs new loads; all of this is done asynchronously. Hence, we do not need
    to take care of implementing and managing threads, offloading queries on the background
    thread, and retrieving results once the query is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A loader can be in any one of the following three distinct states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Started state**: Once started, loaders remain in this state until stopped
    or reset. It executes loads, monitors any change, and reflects the same to the
    listeners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopped state**: Here, loaders continue to monitor changes but do not pass
    the result to the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reset state**: In this state, loaders release any resources they have held
    and do not perform the process of executing, loading, or monitoring data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now relook at our personal contact manager application and make the
    corresponding changes to implement `CursorLoader` in our application. `CursorLoader`,
    as the name suggests, is a loader that queries `ContentResolver` and returns a
    cursor. This is a subclass of `AsyncTaskLoader` and performs the cursor query
    on the background thread so that it does not block the application's UI. In the
    diagram, you can see the various methods of a loader callback and how they communicate
    with `CursorLoader` and `CursorAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CursorLoader](img/2951OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For implementing a cursor loader, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we need to implement the `LoaderManager.LoaderCallbacks<Cursor>`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the methods that reflect the distinct states of a loader: `onCreateLoader()`,
    `onLoadFinished()`, and `onLoaderReset()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To initiate a query, we will make a call to the `LoaderManager.initLoader()`
    method; this initializes the background framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CUR_LOADER` value is passed on to the `onCreateLoader()` method, which
    acts as an ID for the loader. A call to `initloader()` invokes `onCreateLoader()`,
    passing the ID we used to call `initloader()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a switch case to take the loader based on its ID and return `null` for
    an invalid ID. We create a URI object `contentUri` and pass it as a parameter
    to the `CursorLoader` constructor. A point to note is that we can implement a
    cursor loader using either this constructor or an empty unspecified cursor loader,
    `CursorLoader(Context context)`. Also, we can set values via methods such as `setUri(Uri)`,
    `setSelection(String)`, `setSelectionArgs(String[])`, `setSortOrder(String)`,
    and `setProjection(St``ring[])`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context`: This is the parent activity context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri`: We employ `contentURI`, using the `content://` scheme, to retrieve the
    content. It can be based on an ID or directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection`: This is a list of columns to be returned as we are prepared with
    the column names. Passing `null` will return all the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: This is formatted as a SQL `WHERE` clause, excluding the `WHERE`
    itself, acting as a filter declaring which rows to return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectionArgs`: We may include question marks in the selection, which will
    be replaced by the values bound as a string from `selectionArgs`, and they will
    appear in the order of their selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortOrder`: This tells us how to order rows, formatted as a SQL `ORDER BY`
    clause. A null value will use the default sort order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreateLoader` starts the query in the background, and when the query is
    finished, the cursor loader object is passed to the background''s framework, which
    calls `onLoadFinished()`, where we provide our adapter instance with the cursor
    object data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The adapter is a subclass of `CursorAdapter`. Instead of the traditional `getView()`
    method, which we get by extending `BaseAdapter`, we have the `bindView()` and
    `newView()` methods. We inflate our listview row layout in the view object in
    `newView`, and in bind view, we perform an action similar to the `getView()` method.
    We define our layout elements and associate theme with the relevant data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is invoked when the cursor loader is being reset. We clear out
    any reference to the cursor by passing `null` to the `changeCursor()` method.
    Whenever the data associated with a cursor changes, the cursor loader calls this
    method before it reruns the query to clear any past references, thereby preventing
    memory leaks. Once `onLoaderReset()` is set, the cursor loader will rerun its
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move on to our content provider where we have to make small changes
    to ensure that any changes we make to the database are reflected in our application''s
    list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to register `observer` in `ContentResolver` through the cursor in the
    query method of `ContentProvider`. We do this to watch the content URI for any
    changes, which can be the URI of a specific data row or table in our case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `insert()` method, we use the `notifyChange()` method to inform registered
    observers that a row was updated. By default, the `CursorAdapter` objects will
    get this notification. So, now when we add a new row of data by inserting a new
    contact in our application, the `insert()` method of `contentProvider` is invoked
    via a call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A similar action needs to be performed for the `delete()` and `update()` methods,
    both of which have been left as an exercise for the reader as most of the boilerplate
    code is present. Implementing a loader is simple and saves us from a lot of headache
    when it comes to threading, and a jarring UI is highly recommended to perform
    this task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`loadInBackground()` is another important method; this returns a cursor instance
    for a load operation and is called on the worker thread. Ideally, `loadInBackground`
    `()`should not directly return the result of the load operation, but we can achieve
    this by overriding the `deliverResult(D)` method. To cancel, we need to check
    the value of `isLoadInBackgroundCanceled()` as we do in the case of `AsyncTask`,
    where we check `isCancelled()`periodically.'
  prefs: []
  type: TYPE_NORMAL
- en: Data security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is the latest buzzword in town. The Android ecosystem ensures that
    our database is exposed to prying eyes; however, a rooted device can leave our
    database exposed, as we saw in [Chapter 2](ch02.html "Chapter 2. Connecting the
    Dots"), *Connecting the Dots*. With the help of a rooted device, an emulator and
    the `adb pull` command in our case, we pulled our database for inspection with
    the SQLite manager tool. Another important aspect is content providers; we need
    to be careful while setting permissions. We should make the process of applying
    appropriate permissions compulsory in order to inform users about the control
    that an app establishes over data, using the `contract` class.
  prefs: []
  type: TYPE_NORMAL
- en: ContentProvider and permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Sharing is Caring"), *Sharing is Caring*,
    we briefly covered the topic of permissions in the *Adding a provider to a manifest*
    section. Let''s elaborate a little more on this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, while adding the content provider to the manifest, we
    will also add our custom permissions. This will ensure two things, namely, stop
    an unauthorized action in an application and inform the users about permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will add the `permissions` tag to the manifest to indicate
    the set of permissions that other applications will require:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the application in which we want to access the content provider we
    use the `permission` tag, in our case, `Ch4-TestApp` in code bundle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When users install this application, they will get our custom permission message
    along with other permissions required by the application. For this step, instead
    of directly running the application from Eclipse, export an apk and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ContentProvider and permissions](img/2951OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have not defined the permission in the application and if the application
    tries to access the content provider, it will get the `SecurityException: Permission
    Denial` message.'
  prefs: []
  type: TYPE_NORMAL
- en: If the content provider we created is not meant to be shared, we will need to
    change the `android:exported="true"` property to `false`. This will make our content
    provider secure, and if someone tries to run a malicious query on it, they will
    encounter a security exception.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to share data only between our applications, Android provides a solution;
    we can use `android:protectionLevel` and set the permission to `signature` instead
    of `normal`. For this, both the apps, the one that implements the content provider
    and the one that wants to access it, have to be signed by the same key while they
    are exported. This is because a bonus signature permission does not require user
    confirmation. This does not confuse the user as it is done internally and also
    does not obstruct the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting critical data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed what kind of access rights other applications have
    on our database and how to efficiently share our content providers, and we also
    briefly discussed why we should not believe that the system is foolproof. In the
    most foolproof method, sensitive data will not be kept on the device but on the
    server instead, and it will use tokens to give access. If you have to store the
    data on the device's database, use encryption. Use a user-defined key to encrypt
    and decrypt sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore a way to use an encrypted database, which will not be readable
    if someone is able to extract it via means of a root or via exploiting backups.
    If someone tries to read it using SQLite Manager or some other tool, they will
    receive a friendly message, such as the one shown in the following screenshot;
    this is the database file that we will create in a moment with a library known
    as SQLCipher.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting critical data](img/2951OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'SQLCipher is an open source extension to SQLite that provides a transparent
    256-bit AES encryption of database files, as mentioned on their website. It is
    very easy to deploy SQLCipher. Now we''ll look at the steps to build a sample
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will download the necessary files from [http://sqlcipher.net/open-source](http://sqlcipher.net/open-source).
    Here, they have listed a community edition of the Android-based SQLCipher; download
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will create a new Android project in our eclipse environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the downloaded folder, we will find the `libs` folder; inside it, are
    a set of jars that we will need to work with SQLCipher. We will also notice that
    folders are named as `armeabi`, `armeabi-v7a`, and `x86`, and all of these contain
    the `.so` files. If you are familiar with Android NDK, this will not seem new.
    The `.so` file is a shared object file, which is a component of dynamic libraries.
    For different architectures, we require different `.so` files, hence the three
    folders. If you are running an x86 emulator, you will need the `x86` folder in
    your `libs` folder. For simplicity, we will copy all the folders to the `libs`
    folder. Copy the `asset` folder's content into our project's `asset` folder and
    navigate to the project's properties. It will look something like the following
    screenshot. You can also see these JAR files in the project's class path. The
    initial setup for this project is now complete.![Encrypting critical data](img/2951OS_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After completing the necessary setup part, let''s move to writing code to make
    a small test application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has two main methods: `InitializeSQLCipher()` and `runQuery()`.
    Inside `InitializeSQLCipher()`, we load our `.so` library files by invoking the
    `loadLibs()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we find the absolute path to the database and create a missing parent folder
    if any. With `openOrCreateDatabase()`, we will make a call to open an existing
    database or create one if the database is nonexistent. We will execute standard
    database calls to create a table with columns `a` and `b` and insert values in
    a row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will perform a simple query to fetch the values back to the `runQuery()`
    method. You will notice that apart from loading the library, all the core methods
    we used are pretty much standard, so where is the major change? Go to the `Ch4-PersonalContactManager`
    example in the code bundle and notice the packages we have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have SQLCipher packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is simple, familiar, and easy to implement. If you pull
    the database out and try to read it, you will find the error message, as we displayed
    earlier in a screenshot. The user will find no change, and even our app''s logic
    remains the same. In the screenshot, you can see the application screen we just
    built which encrypts the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting critical data](img/2951OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**OAuth** is an open standard for authorization. It provides client applications
    with a *secure delegated access* to server resources on behalf of a resource owner.
    It specifies a process for resource owners to authorize third-party access to
    their server resources without sharing their credentials, as explained in Wikipedia;
    read more about OAuth at [http://oauth.net/2/](http://oauth.net/2/).'
  prefs: []
  type: TYPE_NORMAL
- en: General tips and libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover some general and not so general workarounds and practices, which
    can be put to good use depending on the situation. For instance, in some cases,
    we need to have a prepopulated database of values that we will make use of in
    our Android application or upgrading a database, which seems trivial but can break
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the
    Dots*, we used `onUpgrade()` to show how a database is updated. If we go back
    to the example, you will notice that it executes a `Drop Table` command. What
    will happen here is that the original table will be dropped and a new table will
    be created by the call, `onCreate()`. This will lead to a loss of the existing
    data and hence is not suitable if we need to alter our database. The `onUpgrade()`
    function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One more challenge is to identify the version we are using here. The user might
    be running older versions of the application, so we have to keep in mind the different
    versions that an application has and whether those versions would bring about
    any changes in the database. For a new user, we need not worry because if the
    database does not exist, `onCreate()` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we have a proper upgrade, we will use the `DB_VERSION` constant
    in our `CustomSQLiteOpenHelper` class to tell our `onUpgrade()` method about the
    action to be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change the `DB_VERSION` constant to `3` to reflect the upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will take care of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the super class constructor is run, it compares the `DB_VERSION` constant
    of the stored SQLite `.db` file against the `DB_VERSION` we passed as a parameter
    and calls the `onUpgrade()` method if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Inside our `onUpgrade()` method, we have a switch case to make changes. Notice
    that we do not use the `break` statement because the user can be on an older version
    and may not have updated the application, as explained earlier. For instance,
    let's consider that a user is on a particular version of an application that is
    running `DB_VERSION =1` and he or she skips the next update that contained `DB_VERSION
    =2`, and eventually, a new version of the application with `DB_VERSION =3` is
    released. Now, we have a case where the user is still using an older version of
    the application and has not installed the new updates we have released. So, in
    this case, when the user installs the application, the `onUpgrade()` method will
    first execute `case 1` and then go to `case 2` to install updates that the user
    missed; finally, the user will install the updates of the third version, ensuring
    that all the database changes are reflected. Notice that there is no `break` statement.
    This is because we want to run all the cases where the `switch` statement obtains
    the value `1` and the last two statements where the switch case obtains the value
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also use the `if` statement. This will also behave as
    we intended as our test `DB_VERSION` constant was `1`, which will satisfy both
    the conditions and reflect the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Database minus SQL statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most parts of the book, we looked around for nooks and corners of Android
    and SQLite. For some, writing SQL statements would be just another day in the
    office, while for some, it will come across as a roller-coaster ride. This section
    will cover a library that enables us to save and retrieve SQLite database records
    without writing a single SQL statement. **ActiveAndroid** is an active record-style
    SQLite persistence for Android. According to the documentation, each database
    record is wrapped neatly into a class with methods such as `save()` and `delete()`.
    We will be using the example in the ActiveAndroid documentation and build a working
    sample based on it. Let's look at the steps required to get it up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the official site, [http://www.activeandroid.com/](http://www.activeandroid.com/),
    for an overview and download the files from [http://goo.gl/oW2kod](http://goo.gl/oW2kod).
  prefs: []
  type: TYPE_NORMAL
- en: Once you download the file, run `ant` on the root folder to build the JAR file.
    Once you run `ant`, you will find your JAR file in the `dist` folder. In Eclipse,
    make a new project, add the JAR file to the `libs` folder of the project, and
    then add the JAR file to the **Java Build Path** in the project properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'ActiveAndroid looks out for some global settings configured by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a class, extending the application class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add this application class to our manifest file and add metadata
    corresponding to our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this basic setup complete, we will now proceed on to creating our data
    model. The ActiveAndroid library supports annotation and we will use it in the
    following model classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to explore annotations and use them in your project and reduce
    boilerplate code, you can check out the following libraries for Android: Android
    Annotations, Square''s Dagger, and ButterKnife.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new category or item, we need to make a call to `save()`. In the code
    segment, we can see that an item object is created and associated with a particular
    category, and in the end, `save()` is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an item, we can call `item.delete()`. Similarly, to fetch values,
    we have relevant methods as well. The following is a call to fetch all of the
    data for a particular category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is lot more to be explored in ActiveAndroid. They have schema migration
    and type serialization; in addition to this, you can ship a prepopulated database
    by placing the database in the `asset` folder, and you can use content providers
    as well. In short, it is a well-built library for people looking for indirect
    ways to communicate with the database and perform database operations. It helps
    in accessing the database in the familiar form of Java methods instead of preparing
    SQL statements to perform the same action. The complete sample code is bundled
    in the `chapter 4` code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Shipping with a prepopulated database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build a database and put it inside our `asset` folder, which is a read-only
    directory. At runtime, we will check whether a database exists. If not, we will
    copy our database from the `asset` folder to `/data/data/yourpackage/databases`.
    In [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the Dots*,
    we used a tool called SQLite Manager; have a look at the third screenshot of the
    chapter. We are going to use the same tool to build our database now. If you pull
    your database as explained in that section or look at that screenshot, you will
    notice a few more tables along with your database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shipping with a prepopulated database](img/2951OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps to be followed to create a prepopulated database are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a prepopulated database, we need to create a table named `android_metadata`
    apart from the table we require. Using the SQLite Manager tool, we will create
    a new database named `contact`, then we will create the `android_metdata` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will insert a row in the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create the tables we require, in our case, `contact_table` using
    the SQL query we used in [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"),
    *Connecting the Dots*. In the `DatabaseManager` class, we will just replace the
    constants with the actual values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It is necessary to rename the primary ID field of our tables to `_id` if it
    is not already defined. This helps Android in identifying where to bind the ID
    field of our tables.
  prefs: []
  type: TYPE_NORMAL
- en: Let us fill a few rows of data. We can do this by running the `Insert` query
    or manually typing in the values using the tool. Now, copy the database file into
    the `asset` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in our original personal contact manager, we will modify our `DatabaseManager`
    class. The good part is that this is the only class we need to modify and the
    rest of the system will work as intended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the application runs and creates a new `DatabaseManager` class by passing
    the context, we will make a call to `createDatabase()` in which first of all we
    will check whether the database already exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If it doesn''t, we will create an empty database that we will replace with
    our database, which we copied into our `asset` folder. After copying the database
    from the `asset` folder, we will create a new `SQLiteDatabase` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another point to note is that the `onCreate()` method of our `CustomSQLiteOpenHelper`
    class will be empty as we are not creating a database and tables, but we are copying
    one. The sample code is bundled in the `chapter 4` code bundle. If this process
    looks tedious, don't worry; the Android developers' community has a solution for
    you. SQLiteAssetHelper is an Android library that will help you in managing database
    creation and version management, using an application's raw asset files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we have to follow a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the JAR file into our project's `libs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a library to Java Build Path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy our zipped database file into the `asset` folder of `projectassets/databases/your_database.db.zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ZIP file should contain only one `db` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of extending the framework's `SQLiteOpenHelper` class, we will extend
    the `SQLiteAssetHelper` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They also provide you with assistance to upgrade the database file, which needs
    to be placed in `assets/databases/<database_name>_upgrade_<from_version>-<to_version>.sql`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The library, documentation, and its corresponding sample can be found at [http://goo.gl/8XSSmR](http://goo.gl/8XSSmR).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a myriad of advanced topics in this chapter, ranging from loaders
    to the security of data. We implemented our cursor loader to understand how a
    loader works magic for our applications, and we delved into securing our database
    and understanding the concept of permissions while exposing our content provider
    to other applications. We also covered some tips such as shipping with a prepopulated
    database, upgrading a database without breaking the system, and using database
    queries without using SQL commands. This is in no way the only set of things we
    can achieve with database and Android. This chapter only serves as a nudge towards
    the vast programming possibilities out there.
  prefs: []
  type: TYPE_NORMAL
