- en: Chapter 1. Instant Flask Web Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Instant Flask Web Development*. We will progressively walk through
    web development in the Python programming language using Flask, a small but expressive
    framework which provides the essentials and enables you to build your own code
    patterns. We will build a simple scheduling application to keep track of appointments,
    including a database and a user interface, and we will build one piece at a time.
    We will build our application bottom-up, and you will see how everything fits
    together in later sections. This bottom-up approach will give you the building
    blocks you need to grow your project with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for development (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin our exploration of Flask web programming with everything in its place,
    setting up a development environment in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to [python.org](http://python.org) to get Python. Our application will run
    on Python 2.7 and Python 3.3+. Once you have Python, you do not need administrative
    access to your development machine, and you can even install Python for just your
    user according to the install instructions on [python.org](http://python.org).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python projects can manage packages using **virtualenv**, a user-writable area
    on the machine that is dedicated to a specific project. You can use virtualenv
    on Unix/Unix-like systems, Mac OS X, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the command line to get virtualenv up and running, then discuss the
    tools you need in your development environment. Before we get started, note the
    *Common Errors and how to solve them* subsection in the *There's more...* section
    in case you run into a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unix-style systems ship with a terminal emulator, which we will use throughout
    this book. The steps required to install Flask on Unix, Unix-like systems, and
    Mac OS X are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal in the directory where you would like your project to be located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download virtualenv from `pypi.python.org/pypi/virtualenv/1.9.1`. In the terminal,
    you can do this with `curl -O https://pypi.python.org/packages/source/v/virtualenv/virtualenv-1.9.1.tar.gz`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack virtualenv with `tar xvzf virtualenv-1.9.1.tar.gz`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a virtualenv tool named `env` with `python virtualenv-1.9.1/virtualenv.py
    env`. You can use any name you like; just be sure to make the changes in the commands
    here according to the name you choose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the virtualenv tool with `. env/bin/activate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Flask with `pip install Flask`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify whether Flask is installed with a simple smoke test, `python -m flask.config`.
    Nothing will be displayed if Flask is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can turn off the virtualenv with `deactivate` to continue using the terminal
    for other projects. Anytime you resume work on your Flask project, activate the
    virtualenv again with `. path/to/env/bin/activate`. The `.` command sources the
    activate script to set environment variables that point to the `python` executable
    in the virtualenv and enable import of the packages installed there.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, we will use `cmd.exe`. The steps to install Flask on Windows are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the Python installation and its `scripts` directory, which are `C:\Python33\`
    and `C:\Python33\Scripts\` by default, are in your current `PATH` variable. Use
    `Python27` if you are using Python 2.7, and note that Windows uses a semicolon
    in-between directories in `PATH`. Use `echo %PATH%` to see your `PATH` variable.
    In general, edit `PATH` by navigating to **Computer** | **Properties** | **Advanced**
    | **Environment Variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a shell in the directory where you would like your project to be located.
    Historically, you could run into scripts which fail on spaces in the filepath,
    which is why `C:\Python27\` is preferred to `C:\Program Files\Python27\`; keep
    that in mind if you see strange errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download `virtualenv.py` from [https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py](https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py)
    to the same directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a virtualenv named `env` with `python virtualenv.py env`. You can use
    any name you like; just be sure to make the changes in the commands here according
    to the name you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the virtualenv with `env\Scripts\activate.bat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Flask with `pip install Flask`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify whether Flask is installed with a simple smoke test, `python -m flask.config`.
    Nothing will be displayed if Flask is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can turn off the virtualenv tool with `deactivate` to continue using the
    command prompt for other projects. Anytime you resume work on your Flask project,
    activate the virtualenv tool again with `env\Scripts\activate.bat`, which is a
    batch file to set environment variables that point to the python executable in
    the virtualenv and enable import of the packages installed there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Windows, you can use PowerShell for a richer command-line environment
    by referring to [technet.microsoft.com/en-us/library/bb978526.aspx](http://technet.microsoft.com/en-us/library/bb978526.aspx),
    or you can work with `cmd.exe` if you do not have access to PowerShell by referring
    to [docs.python.org/2/using/windows.html](http://docs.python.org/2/using/windows.html).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python itself ships with a large collection of utilities in its standard library.
    With Python out of the box, you can immediately use any of the code listed at
    [docs.python.org/2/library/](http://docs.python.org/2/library/). The Python interpreter
    has several functions and objects which are always available, and several more
    which become available with an import statement as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Python community adds even more modules to import through collaborations
    on frameworks (including Flask) and toolkits published to the Python Package Index,
    PyPI (pronounced "pie p.i."), at [pypi.python.org](http://pypi.python.org). Packaging
    gets complicated, and pip and virtualenv aim to make a manageable workflow around
    use of third-party packages on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a lot more that can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Checklist for the development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the items you need to develop a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: A text editor for adding and editing source code. I use emacs and vim, which
    have highly productive keyboard shortcuts, and Sublime Text is a popular choice.
    There are many options; just be sure the editor is designed for code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python with a virtualenv tool, using the instructions in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terminal console to run your Flask code, one for each Flask application you
    run, as discussed in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terminal console to run Python's interactive interpreter. Here you can poke
    at APIs, experiment with code, verify unit functionality, and use Python's built-in
    `help(arg)` function to get online documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser. Firefox and Chrome have readily accessible JavaScript
    consoles and document inspectors for web pages. The JavaScript console and document
    inspector are essential for web user interface development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flask docs available at: [flask.pocoo.org/docs/](http://flask.pocoo.org/docs/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Werkzeug docs available at: [werkzeug.pocoo.org/docs/](http://werkzeug.pocoo.org/docs/).
    Werkzeug is Flask''s underlying web service implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jinja docs available at: [jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/).
    Jinja is Flask''s default template engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python docs available at: [docs.python.org/2/](http://docs.python.org/2/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control system. Track changes to your project. I personally recommend
    git, available at [git-scm.com](http://git-scm.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integrated development environment (IDE) can bundle these tools together
    in one application, and there are several available for Python. Personally, I
    find the best tool for each item in the checklist and put together my own environment
    as a collection of standalone tools and applications. I highly recommend having
    a stand-alone command-line available for code interaction, so that you can always
    get to the core of your code even if you have an IDE that you like.
  prefs: []
  type: TYPE_NORMAL
- en: (I find myself to be more productive doing everything on the command-line and
    in the terminal, but that's a matter of personal preference. Be sure to love your
    development environment, so that you can think clearly about your work.)
  prefs: []
  type: TYPE_NORMAL
- en: Common errors and how to solve them
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two common errors you will see in using a Python virtualenv are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `python` command is not found when you attempt to run Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"No module named flask" when you attempt to import Flask in your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both issues are caused by an incorrect environment variable named **PATH** in
    your command-line session, which is an ordered list of directories your system
    should search when loading a command. If `python` is not found, your PATH was
    not updated when you installed Python and you should revisit the Python installer.
    If `flask` is not found, you have either not activated your virtualenv or you
    have not installed Flask, and you should revisit the install instructions here.
  prefs: []
  type: TYPE_NORMAL
- en: Running a simple application (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started by running a simplest Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have activated your virtualenv tool as described in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Put this code into a file named `hello.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this application from the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If this runs correctly, you will see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*** Running on http://127.0.0.1:5000/**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a URL, which you can visit in your browser. When you do, your browser
    will display a plain page which says "**Hello, world!**" (without quotes). Note
    that the address `127.0.0.1` refers to localhost, such that Flask will only respond
    to requests from the host running the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Line-by-line, here is what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This creates a Python object `app,` which is a **WSGI** application. WSGI stands
    for **Web Service Gateway Interface**, and is the Python community's standard
    interface for hosting web projects. Any WSGI resource or tool that you find, you
    can apply to this `app` object, including WSGI middleware (if you do, wrap `app.wsgi_app`)
    and HTTP servers such as gunicorn or Apache `httpd` with `mod_wsgi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument given to the `Flask` class tells Flask how to find resources associated
    with your application: static files and templates. Passing `__name__` tells Flask
    to look at the current Python module—the `.py` file containing this code. Most
    of your applications will use `__name__`; the Flask docs describe this parameter
    in detail if you ever suspect `__name__` is not fulfilling your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next block sets up a function to handle web requests to the `''/''` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Every time Flask gets a request to the `'/'` URL, it will call the `hello` function.
    The Python web community calls these routed functions **view** functions. In general,
    view functions in Flask return strings for web responses, and here we provide
    a simple "Hello, world!" response for all the requests, to prove that things are
    working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final block tells Python to run a development web server, but to only do
    so if the current `.py` file is being called directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That is, this code block will run if you run the command `python hello.py` but
    not if you use `import hello` from another Python module.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are satisfied with the Hello World application, let's structure our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Project layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be building a simple scheduling application to manage appointments and
    display them. Let's move our one-file application into a directory setup for a
    larger application. Create the following file layout in your project, with a `sched`
    directory which contains subdirectories `static` and `templates`, both currently
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Move `hello.py` to `app.py` inside the `sched` directory. The `__init__.py`
    file is an empty file telling Python that `sched` is a package containing Python
    files. The `config.py`, `filters.py`, `forms.py`, and `models.py` files are currently
    empty files which we will fill in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Development server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to access your Flask application from another machine on the network,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The default port for Flask's development server is `5000`, and we will use `localhost`
    on port `5000` throughout this book. If this is already in use, or you would like
    to use a different port, you can set it via the second argument to the `run` method,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The development server given by `app.run` is for development only. When you
    are ready to publish your application, use an industrial strength web server as
    discussed in the later section on deploying and logging. Because we are using
    `app.run` for development only, let''s turn on the debug mode, which will provide
    an interactive debugger in the web browser when uncaught exceptions occur and
    will reload code on changes to existing Python files in your project. You should
    only use `''0.0.0.0''` and/or debug mode on a trusted network. Add `debug=True`
    to the run line, keeping any other arguments you already added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Command-line interface with Flask-Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use `manage.py` to manage our application using **Flask-Script**, with
    these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `requirements.txt` file is a conventional way to track all third-party Python
    packages. Set the file with the following listing, which is one package name per
    line. Run `pip install -r requirements.txt` with your virtualenv active and a
    working internet connection to install these dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run your application with `python manage.py runserver`. Run `python
    manage.py -h` to get help and `python manage.py runserver -h` to get help on the
    development server options. Use `python manage.py shell` to get an interactive
    Python interpreter with the Flask application loaded, which you can use to inspect
    your code and try new things interactively. By default, Flask-Script gives you
    the `runserver` and `shell` commands; you can add custom `manage.py` subcommands;
    refer to the Flask-Script docs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed, you can make the development server accessible from another
    machine on the network and change the port; here is the command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask-Script added Python 3 support earlier this month. This book now fully
    supports Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Routing URLs and accepting requests (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will connect URLs to Python functions in our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the project layout listed under the *Project Layout* section in the *Running
    a Simple Application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flask `app` object includes a `route` decorator to specify URL rules to
    use for a view function conveniently, which provides a declarative style for routing
    requests to Python callables. The following code routes five URL handling functions
    for the list, detail, creation, updating, and deletion of appointment records
    in our scheduling application. For now, we simply return a string describing what
    the handler is going to do, which we''ll implement later, so that you can see
    the URL routing in action from your browser. Place into `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `python manage.py runserver`, you can visit these URLs at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/appointments/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/appointments/1/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/appointments/1/edit/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/appointments/create/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/appointments/1/delete/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you test these URLs in your browser, you will find that the delete URL responds
    with a **405 Method Not Allowed** error. This is intentional, because the browser
    sends a `GET` reuest by default and we are only allowing `DELETE` methods. We
    do not want to delete a record on a `GET` request, but only when our delete button
    is pressed (built in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build URLs to your view functions using the `flask.url_for` function,
    which returns a string representation of the URL. This lets you program using
    clean identifiers in case URLs change, using the names of the target function
    and its arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument to `url_for` is called the endpoint, which by default is
    the name of the Python function wrapped by the `app.route` decorator. You can
    override the default using the `endpoint` keyword argument to `app.route`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main argument to `app.route` is the string URL rule as implemented by **Werkzeug**,
    Flask''s underlying toolkit for all things WSGI. Items listed in angle brackets
    `<argument>` are parsed as named arguments to pass into the view function. Flask
    uses a convention of `<converter:argument>` in the URL rule to parse the argument
    value before passing it to your view function, and only routing the URL if a value
    is correctly parsed. By default, Flask treats the argument as a string. The additional
    built-in converters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: The value of this converter is an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: The value of this converter is a floating point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The value of this converter is a string such as the default, but also
    accepts slashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define your own converters as shown in Flask's `app.url_map` documentation,
    but you may not need to, such that your view function can inspect the string argument
    and parse what it needs.
  prefs: []
  type: TYPE_NORMAL
- en: By default, if a URL rule ends in a trailing slash `/`, Flask will redirect
    requests without the trailing slash to the handler which includes it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are up and routing, there are a few things you should know about HTTP
    and Flask routes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common keyword argument to `app.route` is `methods`, giving Flask
    a list of HTTP methods to accept when routing, which when absent defaults to `GET`.
    Valid values are `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, and `OPTIONS`. RFC2068
    is a standards document which defines these methods. Briefly, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This option is used to reply with information on resource, most common'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This option is used to receive from browser/client updated information
    for resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This option is like `POST`, but repeat `PUT` calls on a resource should
    have no effect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Using this option removes the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: This option is like `GET`, but replies only with HTTP headers and not
    content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This option is used to determine which methods are available for
    resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask implements `HEAD` for you if `GET` is present, and `OPTIONS` for you in
    all cases. Old implementations of HTTP browsers only supported `GET` and `POST`,
    but we will add a `DELETE` request by JavaScript in a later section. It is up
    to you and your project to use the other HTTP methods, particularly in cases where
    the semantics of the methods are important.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to decorating functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@app.route` approach is a Python decorator, which you use at the time you
    define a function. As an alternative, you can use `app.add_url_rule,` which works
    exactly like `app.route` but is a simple method call and is not a decorator. You
    can provide `app.add_url_rule` with any Python callable, accepting the parameters
    in the URL rule, which will become `request.view_args` at the time of the request.
    If you have your own ideas on how to specify the URL routes of your application,
    you can use whatever tools you like with `app.add_url_rule` as a utility to wire
    up your Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Route collisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Flask routes your requests to unexpected places, look for collisions in
    your `app.route` calls. That is, if you have routes `/<path:foopath>` and `/foo/bar/baz/`,
    both will match on `/foo/bar/baz/`. The solution is to be as specific as possible
    in your route parameters, and avoid overly generic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with subdomains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can route subdomains using the `subdomain` keyword argument to `app.route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This subdomain argument uses the same parameter approach as other URLs, but
    note that proper subdomains are limited in what they can accept. Simple names
    are straightforward, but if you have specific requirements, see RFC2181 for name
    syntax and note that some HTTP clients do not support the full spec in subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: When you use subdomains, Flask needs to know the server name in order to parse
    the subdomain from the URL. Provide `SERVER_NAME` to `app.config`, as described
    in the section on configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also run into limitations while developing locally on your machine,
    because `localhost` does not accept subdomains. You can set your operating system''s
    hosts file (typically `/etc/hosts`). If your `SERVER_NAME` is `example.com` and
    your subdomain argument is `foo`, you can set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `hosts` file does not accept wildcards. If you have access to a domain name
    service, an alternative to hosts file is to set an A record and all of its subdomains
    (wildcard) in DNS to `127.0.0.1`, like the following example. This will route
    all subdomains for `local.example.com` on all machines to the local host.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This technique requires a DNS network call, so if you are working offline, you'll
    need to fall back on the hosts file.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests and responses (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will demonstrate how Flask handles incoming data on HTTP requests
    and how you can send responses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set aside the scheduling application and open a new Python file to explore Flask.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the core, Flask and Werkzeug provide request and response objects to represent
    incoming and outgoing data for your web application. Flask provides three different
    patterns for return values from your view functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: string, which can optionally use a template engine (introduced later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a response instance, an object with attributes representing HTTP response details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of `(string, status)` or `(string, status, http_headers)`, for convenience,
    such that you do not have to create a response instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see each of the response patterns in action. Each response will say **Hello,
    world!** with a 200 OK status code (the typical HTTP response on success), and
    the latter two functions tell the browser to display the response as plain text.
    The first function's response displays as though it were HTML because a string-only
    return object has no means to tell Flask how to set the content-type of the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As Flask prepares to call your view function and accepts its return value, it
    walks through each of the before-request and after-request callbacks you provide.
    Here, we set up a before-request function and an after-request function, purely
    for demonstration purposes to illustrate Flask's request and response handling.
    You can use these handlers to explore Flask behavior when you want to interact
    with what Flask docs are saying. When you run this code, keep in mind that browsers
    often automatically look for `/favicon.ico`, which can cause extra requests for
    your application when testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are commonly used features of the request object. See the Flask docs for
    the full list of incoming request data. To provide an example, each description
    includes an example value for a request hitting `/string/?foo=bar&foo=baz` from
    our browser.
  prefs: []
  type: TYPE_NORMAL
- en: '`endpoint`: This feature of the request object specifies the name of the request
    endpoint routed, for example, `return_string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This feature of the request object specifies the HTTP method of the
    current request, for example, `GET`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view_args`: This feature of the request object specifies the dict of view
    function arguments parsed from URL route rule, for example, `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args`: This feature of the request object specifies the dict of arguments
    parsed from the URL query string, for example, `request.args[''foo'']` is `''bar''`
    and `request.args.getlist(''foo'')` is `[''bar'', ''baz'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form`: This feature of the request object specifies the dict of form data
    from `POST` or `PUT` requests, for example, `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_agent`: This feature of the request object specifies the version identification
    provided by the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files`: This feature of the request object specifies the dict of file uploads
    from `POST` or `PUT` requests, which go here instead of `request.form`, for example,
    `{}`. Each value in the dict is a `FileStorage` object which behaves like a Python
    `file` object, but also includes a `save(filepath)` method to store uploaded files
    (after you validate the destination path).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_xhr`: `True`: This feature of the request object specifies when the incoming
    request is a JavaScript `XMLHttpRequest`, and `False` otherwise. This works with
    JavaScript libraries that provide the `X-Requested-With` HTTP header, set to `XMLHttpRequest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask uses a custom `dict` type `ImmutableMultiDict` which supports multiple
    values per key (accessed by the `getlist` method), in cases where HTTP allows
    multiple values for a given argument, such as the query string in the URL, for
    example, `?foo=bar&foo=baz`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used `app.before_request` and `app.after_request` in our demonstration code.
    Eventually, you will want objects to stick around in your code between the before-
    and after-request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Before and after a request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to keep an object around between the before and after request hooks,
    you can set an attribute on the `flask.g` object. The `g` object only lives for
    the duration of the request, and you can set anything you want on the `g` object.
    This is for convenience, for the things that you need throughout the request,
    but do not yet have a home. Do not abuse the `g` object by giving it objects that
    belong elsewhere, such as a database system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `g` object in action, where a random integer between 0 and 9 is
    set on `g.x` and logged before and after the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Handling static files (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is ready to serve files on your disk from the moment you serve your first
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to your scheduler project and look at the `static` folder inside the `sched`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put the files inside the `static` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build URLs for them using `flask.url_for('static', filename='path/to/filename')`
    where `path/to/filename` is the file path inside the static folder, using `/`
    regardless of the operating system you are using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, Flask looks for a folder named `static` next to your application,
    and serves the files there at the `/static/<path:filename>` URL, matching all
    the files in your `static` folder and its subdirectories. That is, if your application
    is at `app.py`, then by default, Flask will look at the `static` folder next to
    `app.py`. Placing a file at `/static/img/favicon.ico` next to `app.py` becomes
    available at the URL `/static/img/favicon.ico`, which is `http://localhost:5000/static/img/favicon.ico`
    in the default development server. (This favicon is wired up in the next section
    on templating.)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can customize how Flask handles static files.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files in production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you deploy your application, you will likely want to serve static files
    from an industrial strength HTTP server such as nginx or Apache httpd, which are
    highly optimized for static files. You can configure these servers to serve the
    `/static/` URL from the same `/static/` folder in your project. If you do not
    have access to these servers, you can use Flask's static file handling in production
    if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting static files elsewhere
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using static files served by another server at a URL other than `/static/`,
    you can add routes to your Flask application with the `build_only` option. This
    tells Flask how to build URLs with the `flask.url_for` function, without needing
    a `view` function or having Flask attempt to serve those files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom static file handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can build your own static file handler if you need to do any custom handling
    when serving files from the filesystem (for example, only serving a file to users
    who pay), for use in static files outside your static folder (for example, `/robots.txt`),
    or to override Flask''s built-in static view function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using a hard-coded directory and `send_from_directory` will mitigate directory
    traversal attacks, because the underlying implementation uses `flask.safe_join(directory,
    filename)` to sanitize the input, which you can use in your own code when handling
    filenames passed in as user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a custom static view function to do custom handling of static files, and
    not to change configuration of the `static` folder. If you just need to rename
    the `static` folder, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Flask serves static files at `/static/` where `static` is the name
    of the folder provided in the `static_folder` argument, with default `static`.
    If you want a different URL path from the folder name, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: HTTP caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Flask sends an HTTP header with the static file telling the browser
    to cache the file for 43200 seconds, or 12 hours. You can configure this using
    the `SEND_FILE_MAX_AGE_DEFAULT` configuration variable. For example, if you want
    aggressive caching on all static files, you can set this value to 2592000 seconds,
    or 30 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when increasing the HTTP cache length, because browsers will have
    stale files when you deploy changes. To work around that issue, change the static
    URL path on redeploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Directory index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask does not list the contents of the files in a static directory for user
    browsing; you have to link to the static files directly. If you need a directory
    index view, consider using an industrial strength static file web server such
    as nginx or Apache httpd.
  prefs: []
  type: TYPE_NORMAL
- en: Using a database (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our scheduler application needs data, and we want to store that data properly
    so that we can stop and start our application without losing our appointments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are working from the `models.py` file inside the `sched` directory of our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SQLAlchemy** provides a Python toolkit and object-relational manager for
    relational databases which use SQL. SQLAlchemy stands on its own, regardless of
    what web framework you use, and we can integrate it into Flask with Flask-SQLAlchemy,
    which will manage database connections with the Flask request lifecycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's model our appointment data structure using SQLAlchemy's declarative extension,
    which allows us to write Python classes to represent database tables. Note that
    Flask-SQLAlchemy includes some declarative functionality, but our application
    uses pure SQLAlchemy to make the code portable to any Python project and to let
    you reference the core SQLAlchemy docs, [docs.sqlalchemy.org](http://docs.sqlalchemy.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are modeling an `Appointment` class which maps objects to an `appointment`
    table. Start with a `Base` class and define an `Appointment` subclass. SQLAlchemy
    will find all subclasses of `Base` when working with the underlying database system.
    We then define columns on the `Appointment` class which will map attributes on
    every `Appointment` object that we use in our code, storing and retrieving values
    as columns in the `appointment` table in our database. In `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To load our domain model in our application, we configure our database on our
    Flask app and setup a `db` object to get ready for queries in our request handlers,
    in `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a couple of helpers as methods on the `Appointment` class. A `duration`
    property provides a calculation of the length of the appointment, in seconds,
    using the start and end times of the `appointment` object. The `__repr__` method
    tells Python how to represent the `appointment` object when printing it. This
    implementation will say `<Appointment: 1>` instead of Python''s default form of
    `<__main__.Appointment object at 0x26cf2d0>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `models.py`, in the `Appointment` class declaration, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each `Column` takes a type, which gives structure to the `appointment` record.
    We give keyword arguments to `Column` to define behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`primary_key`: `True` means that this field is the record identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: When no data is given, use this value. This can be a function which
    returns a value, for example, set `created` to the output of `datetime.now()`
    to provide the date/time at the time the database record is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupdate`: When a record is stored or updated, set its value to the return
    value of the given function, for example, set `modified` to the current date/time
    at the time the database record is updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullable`: When `False`, do not allow records to be stored which do not have
    a value set for this attribute, by raising an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL `sqlite:///sched.db` tells SQLAlchemy to use a SQLite database in the
    current working directory. Python ships with support for SQLite, which is an embedded
    relational database management system also available at, [sqlite.org](http://sqlite.org).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have only modeled our data and told Flask how to connect to a SQLite database.
    Let's try out some queries.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with SQLAlchemy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With an Appointment model definition in place, we can run some queries from
    Python. We can make some sample queries before building out our application''s
    view functions. Add the following code to the main script of `models.py`, inside
    an `if __name__ == ''__main__''` block. Add any statements or `print` calls that
    you want, in order to see how SQLAlchemy works and watch it run with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where is the web request? This section works with SQLAlchemy directly, outside
    a request context, in order to illustrate how SQLAlchemy works. This bottom-up
    approach helps you understand your building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: We start with an engine, which connects to the database and executes queries.
    If you would rather not create a file on disk, you can use a temporary in-memory
    database. The `sqlite://` URL tells SQLAlchemy to connect to a SQLite database,
    and because the filepath is omitted, it should connect to a temporary database
    in memory. That is, the `sqlite://` URL would provide a database which only exists
    for the duration of Python's process execution, and will not persist across calls
    to Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next we create a session and create the database tables. When the engine connects
    to the database and executes queries, the session represents an on-going conversation
    with the database and is the primary entry point for applications to use a relational
    database in SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we add some sample data. We generate times for our fake appointments using
    the current time `now` plus or minus some `timedelta`, which accepts days and
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To create, update, and delete an appointment record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here are some sample queries you can run to get an idea of how SQLAlchemy works.
    Each `appt` example is a Python object of type `Appointment`. Each `appts` example
    is a Python list of `Appointment` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy provides full SQL functionality. Be sure to refer to the SQLAlchemy
    docs when you are generating SQL queries from your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'About the `session` object: you will be using `db.session` (on the `db` object
    we added to `app.py` in this section) instead of session directly. Flask-SQLAlchemy
    will make sure that `db.session` is instantiated correctly and that data accessed
    through the database `session` in one web request does not interfere with the
    `session` in other requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Production database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite is great for development and can work in production, but when you deploy
    your code, you may want to use PostgreSQL or MySQL as your database management
    system. You can change the underlying database while keeping your models as they
    are by specifying a different database URL and installing the necessary package
    to bind to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL pattern: `postgresql://user:pass@localhost:5432/database_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install psycopg2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL pattern: `mysql://user:pass@localhost:3306/database_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install mysql-python`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to create tables when you connect to a clean database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy knows how to translate data definitions to all major relational database
    management systems, and when you need to use specific database features, it has
    support for SQL dialects as documented at [docs.sqlalchemy.org/en/rel_0_8/dialects/](http://docs.sqlalchemy.org/en/rel_0_8/dialects/).
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `Appointment` class uses an underlying table named `appointment`. I recommend
    singular table names with a primary key, always named `id`, but you can decide
    for yourself how to name your tables and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Custom SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At its core, SQLAlchemy is a Python toolkit to construct parameterized SQL expressions.
    At any point, if you need to write custom queries, you do not need to drop down
    to raw execute statement by passing strings—SQLAlchemy has the tools for you.
  prefs: []
  type: TYPE_NORMAL
- en: See the SQL Expression Language docs at [docs.sqlalchemy.org/en/rel_0_8/core/](http://docs.sqlalchemy.org/en/rel_0_8/core/).
  prefs: []
  type: TYPE_NORMAL
- en: Document stores and non-relational databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer another database management system, perhaps one which is document-oriented
    instead of relational, use the tools available for connecting to that database
    from Python. As you can see, we have kept the domain model declarations isolated
    in one file and hooked them into the Flask application object with a few lines
    of code. Our application code throughout this book will use SQLAlchemy APIs to
    query data, but you can translate these calls to the database of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms and file uploads (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get data from the user. Before we begin, remember to NEVER trust user
    input because sooner or later someone (or someone's script) with malicious intent
    will try to break your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are working from the `forms.py` file inside the `sched` directory of our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a data model, we need to present a form to the user in order
    to fill our database and validate user input to make sure it matches our schema.
    You can validate incoming data using any tools you like. We will use **WTForms**
    in our scheduler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: WTForms models forms with classes in a similar style to SQLAlchemy's declarative
    extension for modeling database tables. It takes the philosophy that forms should
    be modeled separately from the data, such that forms and data are separate concerns
    and often user forms (in the HTML user interface) do not line up exactly with
    the domain data (in the database modeled with SQLAlchemy). WTForms provides HTML
    form generation and validation of form data. In Flask, you will find submitted
    form data in `request.form` on the `POST` and `PUT` requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is our appointment''s form. Each attribute takes a label and a set of
    validators. The `Length(max=255)` validator ensures an input of maximum of 255
    characters, and the `required()` validator rejects an empty input. In `forms.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of `AppointmentForm` class is two-fold: render an input form in
    HTML and validate submitted data. This matches the SQLAlchemy-based `Appointment`
    class very closely. Where the `Appointment` model represents the domain and its
    persistence, this form class represents how to display a form in HTML and accept
    or reject the results.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is an opportunity to see what our code does before adding it to our Flask
    application, in our bottom-up approach. This section explains how WTForms works
    through some example code. You can add this code to the bottom of `forms.py` inside
    an `if name == '__main__'` block, and watch it run with `python forms.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the form to our application in a later section, let''s see the
    form in action on its own. We will print the values that WTForms creates so that
    we can understand what it is doing. If you are using Python 2, you will need to
    add a line to the top of your Python file in order to make your print expressions
    compatible between Python 2 and Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code prints the HTML representation of the `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When displayed in the browser, this form field renders as a very plain input
    as shown in the following screenshot. We will style our forms in a later section
    on HTML templating.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9628OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following code shows how to interact with the form's validation directly.
    You can instantiate the `AppointmentForm` with a dictionary of form data. You
    can give Flask's `request.form` object to `AppointmentForm`, but here we will
    build our own dictionary to see how it works. Since HTML forms support multiple
    values for a single argument, we cannot use Python's built-in `dict`. Instead
    we use Werkzeug's `ImmutableMultiDict` type and make dummy data for a `title`
    field and omit all of the other fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when `AppointmentForm` is given the dictionary form data, `form.validate()`
    will process it and return either `True` or `False` depending on whether the form
    data is valid (`True` means valid). Errors from validators are loaded on each
    of the fields in an `errors` list so that you can display errors in context, which
    we will do when rendering a template in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We handle file uploads a bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: Handling file uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are handling file uploads, you need to interact with Flask directly.
    These snippets will get you started. First, the HTML form will include these basic
    elements: `enctype=multipart/form-data` attribute on the `form` element and file
    input in the form of `"<input type=file name=...>"`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The code on the receiving end should look for a Werkzeug `FileStorage` object
    in the `request.files` dictionary by the name given on the file input element,
    and then sanitize the filename before saving the file to disk. Note that if you
    serve the file back with a Content-Type in the response which matches the filename's
    extension, you should only do so with file extensions you trust. Otherwise, an
    attacker could use your file-upload feature to embed JavaScript in your application,
    which will cause the user's browser to trust someone else's code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Templating with Jinja – setting a base template (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask ships with the Jinja templating engine to render any text format you need.
    Our scheduler will present HTML5 pages rendered by Jinja with a little style and
    a bit of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build templates using HTML, CSS, and JavaScript. You will need some
    familiarity with these to understand the responses we build in Flask. We will
    use Twitter's Bootstrap ([getbootstrap.com/2.3.2/](http://getbootstrap.com/2.3.2/))
    framework for CSS and the jQuery ([jquery.com](http://jquery.com)) library for
    JavaScript. Both include online documentation. Bootstrap also includes icons,
    which we can use in our application, provided by Glyphicons ([glyphicons.com](http://glyphicons.com)).
    We will use a free theme for Bootstrap from Bootswatch ([bootswatch.com](http://bootswatch.com)).
  prefs: []
  type: TYPE_NORMAL
- en: We are working from `base.html` inside the `templates` directory within the
    `sched` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This text shows templating by example. In our bottom-up approach, we will start
    with a base page structure before building out our specific application pages.
    Jinja has documentation on all of its template features. Be sure to refer to the
    docs at [http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/) to check
    out what Jinja provides.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use public **content delivery networks** (**CDNs**) for Bootstrap and
    jQuery, which will speed up our start time in our project. NetDNA provides a public
    CDN for Bootstrap. The jQuery project provides a CDN through MediaTemple. Whenever
    you are ready or prefer to move away from a CDN, simply download the files you
    need and serve them with your application''s static files, updating the links
    in the base template. The CDN URLs are, for use in the base template (where `...
    thing ...` identifiers are):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css](http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://code.jquery.com/jquery-1.9.1.min.js](http://code.jquery.com/jquery-1.9.1.min.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jinja supports template inheritance, where template files can extend an existing
    template. We will use this feature to layout our base structure, using the `block`
    template tag to indicate sections which child templates will fill. We provide
    a block to set the page title, add any additional content to the page head (which
    is useful for additional style and scripting), and fill the main content of the
    page. Jinja uses template tags `{% ... %}` to indicate Jinja-specific markup and
    directives. Here is our base template, in `templates/base.html`, with screenshots
    in the coming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This base template allows us to write focused pages which share a common structure
    and style. Any template you create in the templates directory can inherit the
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Render it with the `flask.render_template` function. If the file is named `index.html`
    inside the templates directory, you can render that template into a string with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ther's a lot more that can be done using Jinja templating
  prefs: []
  type: TYPE_NORMAL
- en: Using a template engine other than Jinja
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can choose any template engine you like. When you call `render_template`,
    you have a Python string, and Flask converts the string into a `Response` object.
    If you prefer a different approach to templating, build a string and return it
    from your view functions. Flask bundles Jinja to provide a default templating
    environment for quick start, and for the community to build Flask extensions which
    are guaranteed a common environment.
  prefs: []
  type: TYPE_NORMAL
- en: Manage web packages with Bower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manage downloaded static files using Bower, a package manager for web
    tools, [bower.io](http://bower.io). With Bower, you would list dependencies using
    a `bower.json` file, use `bower install` to load these files, and then serve the
    files in your application's static area.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new record (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we provide a web form to create a new appointment as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new record (Intermediate)](img/9628OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from the `app.py` file from `sched` and the `templates`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We provide a `view` function to do both GET and POST handling for the form.
    Here, we pull together `db.session` from the database section and `AppointmentForm`
    from the forms section. In `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we build out the input fields, we can create a utility for ourselves
    which will display all of the WTForms features for a given field: label, input,
    and errors. Jinja has macros, which are similar to Python functions. We will create
    a macro to render an `edit` field from `AppointmentForm`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For inputs, we can follow Bootstrap conventions with `control-group` and `controls`
    page elements, which will let us completely control the form flow from CSS. We
    want to start a new template with our macro, so that we can reuse it in other
    templates we create. In `templates/appointment/common.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now we can build a form using our new macro. Starting a new template, we can
    extend the base and import the macro. When extending the base, we provide blocks
    title and main, using the same syntax as the base template. You can set variables
    within a template, for use within that template, using `{% set ... %}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `templates/appointment/edit.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On GET, the form is rendered with an action to POST the data to the same URL.
    On POST, the view function validates the data and adds it to the database. If
    the validation fails, the POST renders the template again, but this time the form
    object has errors.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja uses template syntax `{{ ... }}` to print a Python object in context to
    the template's output. We use a simple `if` statement to add the error class if
    the field has errors, which will highlight the input when errors exist (thanks
    to Bootstrap style). We use a `for` loop to lay down a help span for each error
    on the field. The use of `**kwargs` will catch all arguments which are given beyond
    the macro's call signature; this lets us pass in all WTForm field options through
    the macro. The `kwargs` feature only works in Jinja macros when `catch_kwargs=true`.
  prefs: []
  type: TYPE_NORMAL
- en: CSS classes `form-horizontal`, `span3`, and `span5` tell Bootstrap how to layout
    the form on its grid system. The `placeholder` attribute is a feature in HTML5
    to show a watermarkin the input when there is no content.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a record (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With content going into the database, let''s get it back out as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a record (Intermediate)](img/9628OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from the `app.py` file from the `sched` folder and
    the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We provide a simple query to get an appointment by database ID. In `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the same macro approach to displaying an appointment. A template
    macro will give us a tool to display an appointment any time we need it. In `templates/appointment/common.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the macro in `templates/appointment/detail.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a request comes in for a database ID that does not exist, we tell Flask to
    abort with a **404 Not Found** response. The `flask.abort` function is implemented
    as an exception, so Python will stop execution in the current function when `abort`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: We will also implement a few utilities for Jinja named filters, which formats
    the output of a Python object before it goes into the template's output, in the
    form of `{{ foo | filter }}`. We will build filters `date`, `datetime`, `duration`,
    and `nl2br.` On your first pass through in implementing these, simply omit these
    from your template; use `{{ appt.start }}` instead of `{{ appt.start | date }}`.
    This will give you a clearer idea of why we are building the filter.
  prefs: []
  type: TYPE_NORMAL
- en: For individual fields which may not exist, we use Python's `or` behavior. When
    used for display or assignment, `or` expression is "shortcut" until a true value
    is hit, and that value is used. This approach lets us provide a default display
    value in a simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a record (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we provide an edit page for existing appointments, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing a record (Intermediate)](img/9628OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from the `app.py` file from the `sched` directory and
    `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The edit workflow is a mix of add and detail views. We get an appointment,
    and if it exists, we display a form to edit it. In `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In `templates/appointment/edit.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We reuse the same template as the create form, but we say **Edit** instead of
    **Add**. Since this is very simple logic, we can use an `if` statement in the
    template. Flask lets us inspect the request object in the template. If you find
    your project does a lot of request inspection, you should consider a design pattern
    which moves this logic back into your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all records (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t want users to keep track of the database IDs of their appointments,
    so we provide a view, which will list all the appointments that they have, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing all records (Simple)](img/9628OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from the `app.py` file from the `sched` directory and
    the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We query for all appointments, in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In `templates/appointment/index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We query for all appointments in ascending order by appointment start time.
    SQLAlchemy declarative classes include helpers on column attributes that let us
    provide SQL clauses, here with `.asc()` to indicate the `sort` field. In the appointment
    list template, we iterate over all appointment records and reuse our display macro
    and switch off the features which only apply to the detail view, using the call
    signature we created.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We kept the appointment list simple. If you are new to database identifiers,
    you may be wondering how the appointment URLs are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Database identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A note on those database IDs: they are system generated by our database management
    system and SQLAlchemy. That is, they are meaningless outside of our application.
    IDs make for good URLs, but not for human memory. This view is one where you can
    get creative and use the day, week, month, and year calendar metaphors. You can
    do that, but that will live mostly in HTML, CSS, and JavaScript. For our simple
    scheduler application, we just list out the appointments in a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a record (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are all set with our appointment interactions. Wait; how do we delete appointments?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from `sched`'s `app.py` file and `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We build an Ajax handler, in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A little jQuery will wire up all delete links to use this handler, in `templates/base.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We provide our first view function which does not render HTML, but uses a minimal
    Ajax interacting with JSON. It accepts HTTP DELETE requests and does the work.
    We do not have to expose delete functionality through GET requests, which would
    let users accidentally delete database records by browsing. This is particularly
    important when we publish code which can be hit by search engines and other robots.
    Crawling all of our pages would delete our entire database! Flask provides a `jsonify`
    function to turn a Python dictionary into a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: How do you get a browser to send a DELETE request? With JavaScript. The jQuery
    library makes Ajax calls a lot simpler than JavaScript alone. We add a jQuery
    hook which will take all delete links and submit an ajax call when they are clicked.
    The on-click callback grabs the deletion URL from the delete link, and sends it
    as a DELETE request. On success, it redirects the current browser window to the
    appointment list. By placing this script into the base template, it will make
    all delete links functional on the appointment list and detail pages.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We only cover Ajax briefly here; it deserves an entire book.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ajax simply means that we render a web page and have the browser communicate
    with our web service without necessarily having to reload the page. That is, render
    the page once, and update the content displayed on the page without refreshing
    the entire page. This was originally called AJAX for "asynchronous JavaScript
    and XML", but has become a common word among web developers and can mean any serialization
    format, here JSON instead of XML.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom template filters in Jinja (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up our templates, we need to clean up the display of some of our fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We move to the `filters.py` file from the `sched` directory and work with `app.py`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to display time with a clean format. In `filters.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Add more filters here, and provide a hook to initialize the Flask application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the initialization hook in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jinja supports an environment where Python functions are provided in the template
    as filters. We have a `datetime` field on our appointment, so we provide some
    formatting for it. You can call attributes and methods directly within the template,
    `{{ dt.strftime('%Y-%m-%d') }}`, but defining a filter lets us specify how to
    format all dates centrally while still exposing parameters. You can call `{{ dt
    | datetime }}` with our datetime filter to get the default functionality that
    we defined, as well as `{{ dt | datetime('%Y-%m-%d') }}` where the argument in
    the template call is passed in as an argument after the value being filtered.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the full code for filters in the source code files downloadable
    on the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: Additional filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of `sched` includes filters for default date formatting,
    duration formatting for the appointment records, and the `nl2br` filter to preserve
    user-entered line breaks in the appointment description field (since HTML normalizes
    whitespace otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: Sending error responses (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will send an error page to the user with style.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are working from the `app.py` file inside the `sched` directory of our project,
    and in the `templates` directory inside `sched`. Create a directory named `error`
    inside the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user hits a **Not Found** page, we want to display a page that will
    direct them back to the appointment list. You can tell Flask how to render responses
    for error cases, typically for HTTP error codes. We will provide a custom 404
    Not Found page as shown in the following screenshot:![How to do it...](img/9628OS_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flask provides `app.errorhandler` to tell Flask how to handle certain kinds
    of errors, taking either `4xx` or `5xx` HTTP status codes or Python exception
    classes. Decorate a function which accepts an `Exception` instance and returns
    a response. Be sure to include the HTTP status code in the Flask response, by
    providing `404` in a tuple response with the rendered template string. In the
    following code, we render a not-found template, which provides a link back to
    the appointment list. In `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In `templates/error/not_found.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `navbar` element in the base template will help users navigate back to a
    known page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `app.errorhandler` decorator accepts exception classes or HTTP status codes
    as integers. Following are some HTTP status codes to get you started. You can
    use these with `flask.abort(status_code)` in your view functions to jump directly
    to an error response, and define a custom `app.errorhandler` to provide a styled
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 400 Bad Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 401 Unauthorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 403 Forbidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 Not Found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 405 Method Not Allowed (you may have forgotten methods in your route)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 410 Gone (and not coming back)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 Internal Server Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
    for the full list.
  prefs: []
  type: TYPE_NORMAL
- en: The `500` error handler will display anytime your code has an uncaught exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask provides a very useful debugger to inspect your errors in development.
  prefs: []
  type: TYPE_NORMAL
- en: Handling specific exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can provide a custom error page on Python exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Flask's debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a good place to discuss Flask's debugger. When a Flask application has
    `app.config['DEBUG']` set to `True`, any uncaught exception in the application
    code will display a developer-friendly debugger in the browser. This debugger
    makes the Python stack trace interactive, letting you run code at any point in
    the stack frame and viewing code in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can trigger exceptions intentionally for a quick peek at your stack. Write
    in an exception and hit the route in your web browser. My two favorite exceptions
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Only use this in development on a secured machine, since the interactive interpreter
    allows execution of Python code from the browser. If the interactive interpreter
    becomes unresponsive in the browser, either the development server has shut down
    or has moved on to new requests, forgetting about your error.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have assumed that anyone who can access the `sched` application should
    be able to create, display, edit, list, and delete appointment records in the
    database. Our Flask application needs to authenticate users and protect our database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We return to the `models.py` file inside the `sched` directory of our project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with a database record for the user with a unique e-mail address,
    in `models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a means to store a password hash (continuing in User definition):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a means to validate a password (continuing in User definition):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a place to store user records, so that we can verify whether an authentication
    request is for a valid user in our application. However, we do not want to store
    the password in clear text, which would let anyone with read access to the database
    table know how to login as a valid user in the application. This may not seem
    important the first time you come across the idea, but you do not want to handle
    the responsibility of storing everyone's passwords, especially if users reuse
    passwords across applications. (This should be a hint as to why that is a bad
    idea.)
  prefs: []
  type: TYPE_NORMAL
- en: Werkzeug provides utilities to hash a password and verify that the provided
    password matches that hash. We store the hash and not the clear-text password.
    Anytime `user.password` is set on a `User` instance, the password is immediately
    hashed using a Python descriptor and SQLAlchemy's synonym hook. The synonym lets
    us have `user.password` behave just like every other SQLAlchemy object attribute,
    but when `user.password` is accessed, getting the value will call `_get_password`
    and setting it will call `_set_password`, which will store a hashed value.
  prefs: []
  type: TYPE_NORMAL
- en: We can now authenticate using e-mail, password, and a SQLAlchemy query object
    with `User.authenticate(query, email, password)`, which returns a `user, bool`
    pair (tuple), where `user` is the matching user object and the Boolean value indicates
    whether the authentication is valid.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to integrate our e-mail/password authentication into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Appointment relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can build a relationship between appointments and users so that we display
    only the current user''s appointments when we load schedules. Update the `Appointment`
    class in `models.py` to include a foreign-key relationship to `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Accessing an `Appointment` object will now provide the `appointment.user` property
    to access the `User` object for the owner of that appointment. Because we used
    `ForeignKey`, SQLAlchemy knows how to fetch the related `User` record when accessing
    an `Appointment` object.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP is stateless, meaning that one request has no information about the previous
    requests. We need to open a session that is retained from request-to-request,
    so that we can authenticate the user in one request and use that authentication
    in each of the following requests that the user makes in a given sitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will see how to handle the session, adding a `current_user`
    object to our code which will represent the `User` database object which matches
    the currently authenticated user. Now that we''ve added a relationship between
    `User` and `Appointment` in `models.py`, we need to update `app.py` for every
    case where we create or retrieve an `Appointment` object. Change the `Appointment`
    object creation line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then verify whether the current `Appointment` is for the current User when
    retrieving records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Database migration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing `models.py` means that we need to update the database structure of
    the database we have been using in development, or the production database if
    we have already deployed the `sched` application. If the only changes we have
    made are to add tables, then we can simply make another call to `Base.metadata.create_all(engine)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes in development, this is the easiest method: just destroy the development
    database, run `create_all` again, then start adding data again. Setting up initial
    development or test data can be cumbersome, so you might want to invest in **fixtures**,
    which you load before running your application development server. There are several
    projects in the Python community to do this, including `fixture` at [pypi.python.org/pypi/fixture](http://pypi.python.org/pypi/fixture).'
  prefs: []
  type: TYPE_NORMAL
- en: For column changes, we need to provide an automation to change the live database,
    especially for production databases, which people are using. If you are familiar
    with SQL, you can write your own `ALTER TABLE` statements and provide your own
    scripts. If you would like a toolkit to manage this, SQLAlchemy's creator Mike
    Bayer has written Alembic as a tool to perform migrations in SQLAlchemy, [alembic.readthedocs.org](http://alembic.readthedocs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with existing services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do new users get started? With user authentication in place for `sched`,
    you need to provide a means to register users with your application. This can
    be as simple as creating `User` objects from the Python interactive interpreter,
    or it could be a user signup form within your application.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can reduce the `User` implementation to the core application
    data that you need and use an existing service to authenticate your users externally,
    creating new `User` objects on the first such authentication. This will keep users
    from having to remember yet another password and speed up your user acquisition
    process.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID ([openid.net](http://openid.net)) provides an open standard to perform
    this style of authentication. Popular services such as Google have their own documentation
    for authentication and authorization using existing user accounts, [developers.google.com/accounts/](http://developers.google.com/accounts/).
  prefs: []
  type: TYPE_NORMAL
- en: Handling sessions and users (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since HTTP is stateless, we need to track some data across requests with a session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to work from the `app.py` file from the `sched` directory and
    the `models.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask provides a `session` object, which behaves like a Python dictionary,
    and persists automatically across requests. You can, in your Flask application
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask-Login provides a simple means to track a user in Flask''s session. Update
    requirements.txt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then load Flask-Login into `sched`''s request handling, in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask-Login requires four methods on the `User` object, inside `class User`
    in `models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask-Login provides a **UserMixin** (`flask.ext.login.UserMixin`) if you prefer
    to use its default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then provide routes to log the user in when authenticated and log out. In
    `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We then decorate every view function that requires a valid user, in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On `login_user`, Flask-Login gets the user object's ID from `User.get_id` and
    stores it in Flask's session. Flask-Login then sets a `before_request` handler
    to load the user instance into the `current_user` object, using the `load_user`
    hook we provide. The `logout_user` function then removes the relevant bits from
    the session.
  prefs: []
  type: TYPE_NORMAL
- en: If no user is logged in, then `current_user` will provide an anonymous user
    object which results in `current_user.is_anonymous()` returning `True` and `current_user.is_authenticated()`
    returning `False`, which allows application and template code to base logic on
    whether the user is valid. (Flask-Login puts `current_user` into all template
    contexts.) You can use `User.is_active` to make user accounts invalid without
    actually deleting them, by returning `False` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: View functions decorated with `login_required` will redirect the user to the
    login view if the current user is not authenticated, without calling the decorated
    function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask's session supports display of messages and protection against request
    forgery.
  prefs: []
  type: TYPE_NORMAL
- en: Flashing messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to display a simple message to indicate a successful operation
    or a failure quickly, you can use Flask''s flash messaging, which loads the message
    into the session until it is retrieved. In application code, inside request handling
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In template code, where you can use the `''success''` category for conditional
    display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Cross-site request forgery protection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malicious web code will attempt to forge data-altering requests for other web
    services. To protect against forgery, you can load a randomized token into the
    session and into the HTML form, and reject the request when the two do not match.
    This is provided in the Flask-SeaSurf extension, [pythonhosted.org/Flask-SeaSurf/](http://pythonhosted.org/Flask-SeaSurf/)
    or the Flask-WTF extension (which integrates WTForms), [pythonhosted.org/Flask-ETF/](http://pythonhosted.org/Flask-ETF/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the world (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once satisfied with your application, you can deploy your application which
    would be available to the world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need a computer which is online and accessible to your target users. Install
    Python and place `requirements.txt` in a folder where you have command-line access,
    just as we did for your development environment (virtualenv is production-appropriate),
    then create your database tables. You can deploy to any operating system: Windows
    and any Unix-like systems (including Mac OS X).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a clean Ubuntu 12.04 server installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `pip` and `gunicorn` programs in virtualenv. Load into the nginx configuration,
    changing localhost to your domain name if you have one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Then add the gunicorn process into the server's boot order instead of running
    it by hand. See your operating system's documentation. For Unix-like systems,
    supervisord provides management of long-running applications, [supervisord.org](http://supervisord.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anytime nginx receives a matching request, it sends a proxy request to the HTTP
    server running on port `5000`, which is gunicorn in our application, and passes
    along the response. Note that gunicorn does not automatically reload your application
    on code updates. You can reload with process signals as described in [docs.gunicorn.org/en/latest/faq.html](http://docs.gunicorn.org/en/latest/faq.html).
  prefs: []
  type: TYPE_NORMAL
- en: See [docs.gunicorn.org/en/latest/deploy.html](http://docs.gunicorn.org/en/latest/deploy.html)
    for additional documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployment has many options; the configuration is entirely up to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Handling static files with nginx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flask provides a static file handler for convenience. Now that we have an optimized
    HTTP server in place, we can have it serve static files directly. The following
    configuration block shows how to serve static files with nginx and proxy all other
    requests to Flask. Adjust the configuration according to your setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `/var/www/myproject` to the filepath containing the `sched` folder from
    our project layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `/static/` if you changed the default static route in Flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The updated server configuration, to handle static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Deployable on any OS with HTTP proxying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I prefer to run applications in production using HTTP proxying with application
    code served by stand-alone, independent operating system processes. Most industrial
    strength HTTP servers include a means to proxy requests to another web service,
    just as we demonstrated with nginx. gunicorn only runs on Unix-like systems, but
    cherrypy ([cherrypy.org](http://cherrypy.org)) provides a cross-platform WSGI
    server. You can start your application with a script which follows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Windows server deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run your Python application directly within Windows Server IIS, see the NWSGI
    project at [nwsgi.codeplex.com](http://nwsgi.codeplex.com).
  prefs: []
  type: TYPE_NORMAL
- en: Other deployment options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the Flask docs at [flask.pocoo.org/docs/deploying/](http://flask.pocoo.org/docs/deploying/).
  prefs: []
  type: TYPE_NORMAL
