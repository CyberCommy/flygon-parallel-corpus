- en: Chapter 2. Visual Scripting with Flowgraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE flowgraph is a powerful node-based visual scripting system, aiding
    developers in rapidly prototyping features and creating level specific logic without
    having to work with complicated codebases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss the concept of flowgraphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new flowgraphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug our flowgraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom flowgraph node (flownode) in Lua, C#, and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept of flowgraphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years, writing code has been the primary, if not the exclusive method of
    creating behaviors and logic for games. Let's take the example of a level designer,
    building a combat section for the latest title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the said designer would have to ask a programmer to create the
    logic for this scenario. This has several problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a disconnect between the design and the implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers are forced into spending time which is really a designer's job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The designer has no immediate feedback on how his/her section plays out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the problem that CryENGINE's **flowgraph**, often referred to as **FG**,
    solves. It provides a set of flownodes, best thought of as convenient Lego blocks
    of logic, which the designer can utilize to piece together entire scenarios. No
    more requests to the game code team; designers can go ahead and realize their
    ideas instantly! We'll discuss creating the nodes themselves in more detail later,
    but for now, let's take a look at some simple flowgraphs, so you can take your
    first steps into CryENGINE game logic!
  prefs: []
  type: TYPE_NORMAL
- en: Opening the Flowgraph Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to open up Sandbox. Sandbox contains the Flowgraph Editor
    as one of its many useful tools, and it can be opened via **View** | **Open View
    Pane**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always have a level loaded when opening the Flowgraph Editor, as
    flowgraphs are unique to levels. Flick back to [Chapter 1](ch01.html "Chapter 1. Introduction
    and Setup"), *Introduction and Setup*, if you've forgotten how to create a new
    level!
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening the Flowgraph Editor](img/5909_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You've just accessed your first Sandbox tool! You should be presented with a
    new window with lots of subsections and features, but don't fret, let's tackle
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: A tour of the Flowgraph Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flowgraphs are saved on the disk as XML files, but can be parsed and edited
    by the Flowgraph Editor in order to provide a visual interface to the process
    of creating game logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![A tour of the Flowgraph Editor](img/5909_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section of the Editor contains all the flownodes in your project, organized
    into neat categories. Let''s take a quick look inside this, open up the **Misc**
    folder. You should be presented with a set of nodes, assigned to categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components](img/5909_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Terminology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Graph**: This refers to a context containing a set of nodes linked to each
    other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: This is a visual representation of a class that can receive data
    and events from its input ports, as well as send data via its output ports. It
    is connected to other nodes in graphs to create logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: This is a visual representation of a function. Nodes can specify
    multiple input and output ports, and can then send or receive events from them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be missing the node marked as **Debug** here; CryENGINE assigns categories
    to nodes as a way of indicating where it's appropriate for them to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Release**: This node is suitable for use in production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced**: While this node is suitable for use in production, it may have
    complex behavior in certain situations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug**: This node should only be used for internal tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obsolete**: This node should not be used, and this node will not be visible
    in the components list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, while working on a level that''s intended to be shipped to the
    public, you might not want to accidentally include any Debug nodes! We can enable
    or disable the viewing of the first three categories inside the Flowgraph Editor
    via **View** | **Components**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Component categories](img/5909_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flowgraph types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating a new flowgraph, we'll want to know of what type our purpose
    is most relevant to. Different flowgraph types allow for specialization, for example,
    to create **UI graphs** that handle the layout and drawing of the player's user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flowgraph types](img/5909_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AI Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are flowgraphs you can create to wrap up AI behaviors into convenient
    nodes that can be reused elsewhere. We'll address these later when you learn about
    **Artificial Intelligence** (**AI**).
  prefs: []
  type: TYPE_NORMAL
- en: UI Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryENGINE allows you to script your user interfaces and in-game heads-up-displays
    using flowgraphs, via a system of UI events. We'll discuss these in [Chapter 7](ch07.html
    "Chapter 7. The User Interface"), *The User Interface*.
  prefs: []
  type: TYPE_NORMAL
- en: Material FX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryENGINE supports convenient designer-editable flowgraphs to control how material
    events are handled, for example, spawning a dirt particle and obscuring the player's
    screen with a layer of dust when the ground is shot nearby.
  prefs: []
  type: TYPE_NORMAL
- en: FG Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can package up flowgraphs into handy modules for reuse across different
    situations. We'll describe these in depth later.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is where we'll spend most of our time in this chapter! 90 percent of the
    time,a flowgraph is assigned to an entity, otherwise known as the **graph entity**,
    and this logic takes place in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryENGINE supports prefabs, a collection of entities packaged into a single
    convenient file for reuse. Any entity flowgraphs inside a prefab will be displayed
    in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flowgraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how the Flowgraph Editor works, let's
    dive right in and create our first flowgraph! You can close the Flowgraph Editor
    for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The flowgraph entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flowgraph entity is an extremely lightweight CryENGINE object, designed
    to be used when you need a flowgraph that isn't applied to any specific entity.
    Like all entities, it can be found in **RollupBar** inside Sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not sure what an entity is, skip this section until you have read
    [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"), *Creating
    and Utilizing Custom Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The flowgraph entity](img/5909_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spawning FlowgraphEntity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select **FlowgraphEntity** and then either double-click and click again on the
    viewport, or click and drag it into the level. You should now see a whole new
    set of options in **RollupBar**, including entity params, material layers, but
    mostly important for us, the **Entity:** **FlowgraphEntity** section.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a new flowgraph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the **Entity: FlowgraphEntity** section, we need to find the **Flow
    Graph** subsection, and then click on the **Create** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching a new flowgraph](img/5909_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From here, you'll be presented with the option to assign your flowgraph to a
    group. Whether you do or not isn't really important for now, but it's useful for
    grouping related graphs together, particularly when working on larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groups are used to create a structure for flowgraphs, allowing developers to
    sort different graphs into folders.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, you should see the Flowgraph Editor appear with a faint grid
    overlaid on the background. We're now ready to start creating logic!
  prefs: []
  type: TYPE_NORMAL
- en: Adding nodes into flowgraphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest method of adding a node into a new graph is to browse through the
    **Components** list and drag new nodes in. However, this isn't very efficient
    if you know the name of the node you want to add. Therefore, you can also use
    the *Q* shortcut key inside the Flowgraph Editor to bring up the search function,
    and just type in the name of the node you'd like to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we''re going to begin with the **Misc:Start** node, which is a
    simple node used to set off other events when the level is loaded, or when an
    Editor test session is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding nodes into flowgraphs](img/5909_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Input and output ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the node is placed, you should see your first example of a node''s input
    and output ports. In this case, we have two input values, **InGame** and **InEditor**,
    as well as a single output port, conveniently named **output** in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Input and output ports](img/5909_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Input ports are used to feed data into the node, or trigger events, and output
    ports are used to relay data and events to other nodes in the graph. In this example,
    the **Misc:Start** node can be edited to define in which game contexts it will
    actually be executed. Perhaps you have some debugging logic you'd like to only
    run in the Editor, in which case we could set **InGame** to false, or zero.
  prefs: []
  type: TYPE_NORMAL
- en: Port types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to specify what type of data a port will handle, we need to know its
    port type. We can tell which type a port is in the Flowgraph Editor by looking
    at its color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a list of the available port types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Void**: This is used for ports that don''t pass a specific value, but are
    activated to signal an event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int**: This is used when the port should only receive integer values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**: This is used to indicate that the port handles floating point values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EntityId**: This indicates that the port expects an entity identifier. (Refer
    to [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"),
    *Creating and Utilizing Custom Entities* for more information on entity IDs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vec3**: This is used for ports that handle three-dimensional vectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: In this, the port expects a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bool**: This is used when the port expects a Boolean value of true or false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linking ports with different types will result in the value being automatically
    converted.
  prefs: []
  type: TYPE_NORMAL
- en: Target entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flownodes can feature a target entity, allowing the user to link an entity from
    the current level to the flownode. This is useful for nodes that are meant to
    impact entities in the game world, for example the **Entity:GetPos** node, as
    shown in the following screenshot, gets the world transformation of the specified
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also specify entities dynamically by linking an **EntityId** output port
    to the **Choose Entity** port.
  prefs: []
  type: TYPE_NORMAL
- en: '![Target entities](img/5909_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two ways of assigning an entity to a node that supports it:'
  prefs: []
  type: TYPE_NORMAL
- en: By linking another flownodes' **EntityId** output to the **Choose Entity** input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By right-clicking on the **Choose Entity** input and selecting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assign selected entity**: This links the node to the entity currently selected
    in the Editor viewport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assign graph entity**: This links the node to the entity this graph is assigned
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking flownodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single flownode isn''t capable of much; let''s connect two, and build a proper
    graph! For demonstration purposes, we''ll use the **Time:TimeOfDay** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking flownodes](img/5909_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To create a link between ports as shown in the previous screenshot, simply click
    on an output port and drag your cursor to an input port with the mouse button
    held down. Release the mouse, and the connection should be created!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also edited the value of the **Time** input port; input ports can either
    be fed data via output ports, or have their values edited directly in the Editor.
    To do this, just click on the node and see the **Inputs** section of the Flowgraph
    Editor. From there, you can simply edit the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking flownodes](img/5909_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see valuable information about the node: for example, here we
    can see that this node is used to set the time of day, and the speed at which
    time passes in game.'
  prefs: []
  type: TYPE_NORMAL
- en: With this done, you can close the Flowgraph Editor for now. Flowgraphs don't
    have to be saved manually; they're automatically saved with the level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although flowgraphs save with the level, it is good practice to save manually
    often using **File** | **Save** to avoid losing your work.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our flowgraph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in the previous chapter, testing logic in the CryENGINE is incredibly
    simple using Sandbox. Simply press the *Ctrl* + *G* shortcut key combination,
    and watch as you enter game mode. Now, when you do this, you should see the lighting
    and general atmosphere of the level changing,as you've just changed the time of
    day!
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you've just taken your first step to creating games using CryENGINE!
    It doesn't seem like much right now, but let's make this graph do a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: The stock flownode overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make something a little more complex, we're going to need an understanding
    of what nodes the CryENGINE provides for us by default.
  prefs: []
  type: TYPE_NORMAL
- en: Building a clock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful nodes we have access to, at least for debugging purposes,
    is the **HUD:DisplayDebugMessage** node. It allows you to display information
    in the game window, optionally with a timeout. With that in mind, let's build
    a little debug clock based on the time information we learnt about earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The **Time:TimeOfDay** node outputs the current time in the CryENGINE time format,
    which is defined as hours plus minutes divided by 60\. For example, 1:30 p.m.
    would be expressed as 13.5 in CryENGINE time. We now know we're going to need
    some mathematical operations, so it's time to check the Math flownode category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is get the time in hours by rounding the current
    time down. To do this, place **Math:Floor**, then connect the **CurTime** output
    from our **Time:TimeOfDay** node to Floor''s **A** input port. Then, feed this
    into a Debug Message node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a clock](img/5909_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jump into game right now, and you should see the current time in hours displayed
    on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to subtract our new value from our original to get the minutes
    portion. To do this, we need **Math:Sub** to subtract the rounded hours from the
    original **CurTime** value. After that, a **Math:Mul** node will scale up the
    new time by 60, so your graph should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a clock](img/5909_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember to set **posY** of the second Debug node to move it down which will
    enable you to see both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: If you jump in game again, you should now see the current hours and minutes
    printed!
  prefs: []
  type: TYPE_NORMAL
- en: Listening for player input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if now, we wanted to allow the player to test moving through different
    times of the day? Generally speaking, it's the easiest way to set up a key listener,
    where we fire an event when a certain key is pressed. Fortunately CryENGINE encapsulates
    this functionality nicely into a single node, **Input:Key**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now set it up so that pressing the *P* key will make time move extremely
    fast, and that pressing *O* will stop it again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Input:Key** node is a Debug node. It is generally considered a bad practice
    to use Debug nodes in production, as unexpected results may occur, so please don't
    use this node for actual game logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the **Speed** value of our **Time:TimeOfDay** node, but in this
    case, we''ll also need to feed two values in! CryENGINE provides a node called
    **Logic:Any** that features multiple input ports and just passes on any data given
    to it, which we can use here to receive both input values. We use two key nodes
    which call **Math:SetNumber** nodes, and the **Logic:Any** node then relays this
    information to our **Time:TimeOfDay** node, as well as calling **SetSpeed**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening for player input](img/5909_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jump in game now, and press *P* to start the day moving! Press *O* again, and
    the time of day should freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Executing on a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have noticed that our clock isn''t updating correctly any more. This
    is because most nodes won''t output data unless triggered; in this case, we''ll
    get no output if we don''t trigger either **GetTime** or **SetTime**. We have
    two options for calling this: we can either use **Time:Time** to execute it every
    frame, or **Time:Timer**.'
  prefs: []
  type: TYPE_NORMAL
- en: The latter can control the granularity of the tick, but in this case, we probably
    want it to be updated every frame while moving fast, so let's keep it simple.
    Connect the **tick** output to our **GetTime** input, and our clock should be
    updating correctly once again!
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing on a loop](img/5909_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flowgraph modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flowgraph module system allows flowgraphs to be exported as a module that
    can be triggered from another graph.
  prefs: []
  type: TYPE_NORMAL
- en: By creating modules, we can reuse logic in multiple levels without having to
    maintain several versions of the same graph. It's also possible to send and receive
    unique data to and from the modules, allowing dynamic logic in a very modular
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with creating your own module, open the Flowgraph Editor and select
    **File** | **New FG Module...** | **Global**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a module](img/5909_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the resulting **Save** dialog box, save the module with a name of your choice.
    You''ll then be shown the default view of a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a module](img/5909_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The module contains two nodes by default; **Module:Start_MyModule** and **Module:End_MyModule**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Module:Start_MyModule** contains three output ports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start**: This is called when the module is loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: This is called when the module should be updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: This is called when the module should cancel, and it is connected
    to the **Cancel** input of **Module:End_MyModule** by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module:End_MyModule** contains two input ports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Success**: This should be called when finalizing the module, and passes a
    "success" status to the caller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: This is used to end the module prematurely, and passes a "cancelled"
    status to the caller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, to fill your module with logic, simply connect the **Start** output
    port to your logic nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To call an existing module, find the relevant node in the Module node category.
    The call nodes are named as `Module:Call_<ModuleName>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling a module](img/5909_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then simply trigger the **Call** port to activate your module, and **Cancel**
    to abort it.
  prefs: []
  type: TYPE_NORMAL
- en: Module parameters/ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From what we've learned previously, we're able to call modules with a void port.
    This is not optimal in all cases, as you might want to pass additional data to
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow this, the module system exposes module parameters. By selecting **Tools**
    | **Edit Module...** in the Flowgraph Editor, we can add a set of parameters to
    our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Module parameters/ports](img/5909_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This action opens the **Module Ports** window, which allows us to add and remove
    ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Module parameters/ports](img/5909_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By selecting **New Input** or **New Output**, we'll be able to add new ports
    that can be used when activating the module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Module parameters/ports](img/5909_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a new input or output will automatically output its **Module:Start_MyModule**
    or **Module:End_MyModule** node, allowing you to receive the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Module parameters/ports](img/5909_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All **Module:Call_MyModule** nodes are also updated automatically, giving you
    access to the new parameter right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Module parameters/ports](img/5909_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom flownodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, CryENGINE provides many useful nodes by default, encompassing
    a whole range of functionality. However, as a programmer, you'll often find that
    designers will request access to some hidden functionality that the flowgraph
    isn't capable of providing by default.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say you're creating a role-playing game, and you have an
    experience system. There are plenty of ways to reward the player with experience
    in the code you've written, but a level designer also wants to be able to make
    use of this functionality at arbitrary points in a level.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, you're well-placed to create a custom flownode; you can create
    a simplified representation of the system that exists in code, perhaps allowing
    the designer to simply specify the number of experience points to award to the
    player when the node is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: For now though, we're going to take a look at something a little simpler. Let's
    pretend we have no existing CryENGINE nodes to work with, and we'd like to implement
    the **Math:Mul** node we saw earlier. To recap, it's just a simple node that implements
    multiplication inside a flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom flownodes](img/5909_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a custom node in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 1](ch01.html "Chapter 1. Introduction and Setup"), *Introduction
    and Setup*, we took a first look at compiling and running the GameDLL, packaged
    here as `MiniMonoGameSample.sln` for Visual Studio. Let's load that up again,
    making sure that any CryENGINE instances such as the Launcher or Sandbox are closed,
    as we're going to overwrite the `CryGame.dll` file that's used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard practice for CryENGINE games is to have a filter in the GameDLL
    project, **CryGame**, called **Nodes**. If this doesn't exist, go ahead and create
    it now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing nodes](img/5909_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new node file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nodes are never referenced in other areas of the project, so it's fine to simply
    implement a node as a single `.cpp` file without a header.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, let''s just add a new file, `TutorialNode.cpp`, and create the
    basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Breaking down of code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firstly, we included `stdafx.h`; this provides common functionality and some
    standardized "includes" for your file. This is also required to compile files.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we included a second file, `Nodes/G2FlowBaseNode.h`. While it's
    not strictly a CryENGINE component, this file is widely used in CryENGINE games
    to encapsulate node functionality into an easily accessible base class.
  prefs: []
  type: TYPE_NORMAL
- en: We then create our actual class definition. We inherit from the aforementioned
    base node, and then specify that our node is an instanced node; generally speaking,
    you'll work with instanced nodes in CryENGINE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryENGINE uses some limited Hungarian notation prefixes as you see here. Classes
    are `CMyClass`, structs become `SMyData`, and interfaces are `IMyInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: It's also common to use the `m_` prefix for fields, such as `m_memberVariable`,
    and `p` for pointer variables, such as `*pAnInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make node registration easier, CryENGINE exposes `REGISTER_FLOW_NODE`
    pre-processor macro. This system will automatically handle registration of your
    node during startup.
  prefs: []
  type: TYPE_NORMAL
- en: The node functions overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purposes of the node we are creating, we don''t need to store any private
    information, so simply make all node information public using the C++ modifier
    as the first line inside your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then start off by implementing two functions, the constructor and the `Clone`
    method. We don''t need any logic in either of these, so the implementations are
    very simple; the constructor doesn''t initialize anything, and `Clone` simply
    returns a new instance of the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're also introduced to `SActivationInfo` for the first time. This struct
    contains information about the node's present state, as well as the graph it's
    contained within, and we'll be using this elsewhere later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, three more functions are required for our node to at least compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`ProcessEvent` is where we''ll be doing most of our node logic; this function
    is called when interesting things happen to our node, such as ports being triggered.
    `GetConfiguration` controls how the node will be displayed, as well as what input
    and output ports it contains. `GetMemoryUsage` doesn''t need any extra implementation
    from us, so we can just add a reference to this node for memory usage tracking.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it would be a good point to verify that your code compiles; if not, check
    whether you've declared all the function signatures correctly, and included the
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GetConfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, `GetConfiguration` is where we set up how our node can
    be used in the Flowgraph Editor. Firstly, let''s set up `enum` to describe our
    input ports; we''re going to use two values, left and right, as well as an activation
    port to trigger the calculation. Declare this inside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we also need an output port for the calculation, so let''s create
    `enum` with a single value for that also. It''s not required, but it''s a good
    practice to be consistent, and most nodes will have more than one output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With those declared, we can start building up our node. Ports are defined as
    entries in a constant static array declared in `GetConfiguration`, and are constructed
    using some helper functions, namely `InputPortConfig<T>` for a specific type of
    value, as well as `InputPortConfig_AnyType` for allowing all values, and `InputPortConfig_Void`
    for ports that use no data.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, we know that a void input will be required for our trigger
    input on top of two float templated ports. We'll also need a float output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get to specify the name of the port, the description, as
    well as a default value for ports that use data. They should match the order of
    the enums that we declared earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing port names for nodes that are already used will break existing graphs.
    Fill in the optional `humanName` parameter to change the display name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we repeat that process, except we use the output set of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Assigning arrays to the node configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the process of creating our ports, we need to assign these arrays
    to our `config` parameter, as well as provide a description and category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you compile the code now, the node should be fully visible in the Editor.
    But as you'll see, it does nothing yet; to fix that, we have to implement `ProcessEvent`!
  prefs: []
  type: TYPE_NORMAL
- en: Flownode configuration flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `SFlowNodeConfig` struct allows you to assign optional flags to the flownode,
    listed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EFLN_TARGET_ENTITY`: This is used to indicate that this node should support
    a target entity. To obtain the currently assigned target entity, have a look at
    `SActivationInfo::pEntity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EFLN_HIDE_UI`: This hides the node from the user in the flowgraph UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EFLN_UNREMOVEABLE`: This disables the ability for the user to remove the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To append a flag within `GetConfiguration`, in this case to support a target
    entity, simply add the flag to the `nFlags` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implementing ProcessEvent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ProcessEvent` is where we catch all the interesting events for our node, such
    as ports being triggered. In our case, we want to perform a calculation whenever
    our `Activate` port is triggered, so we need to check for port activations. First
    though, we can save ourselves some processing by checking which event we''d like
    to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Usually you'll be handling more than one event, so it's good to get into the
    habit of using a `switch` statement here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that, let''s take a look at the various flownode functions we use to
    check for activations, to retrieve data, and then trigger an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, we use our activation information in all these functions to represent
    the current state. We can then retrieve values using the `GetPort*` functions
    for the various port types, and then trigger an output with data.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to load up the Editor and test; if all's gone well, you should be
    able to see your node in the Tutorial category. Congratulations, you've just written
    your first C++ code for CryENGINE!
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing ProcessEvent](img/5909_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a custom node in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CryMono also supports the creation of custom nodes using idioms that C# developers
    will feel accustomed to, such as attribute metaprogramming. To get started with
    C# CryENGINE scripts, open up the sample scripts solution in `Game/Scripts/CryGameCode.sln`.
    Add a new `.cs` file to the flownodes folder, and we'll start creating the same
    node in C#, so you can see how the creation varies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s create a basic skeleton node. We need to bring the correct
    namespace into scope for the `Flowgraph` classes, as well as set up some basic
    attributes for our node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As in C++, nodes aren't referenced anywhere else in the project, so we assign
    a separate namespace for our nodes to keep them from polluting the main namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `FlowNodeAttribute` class in place of `GetConfiguration` to set up
    metadata for our node, such as the correct category and visibility level. Your
    node must include this attribute and inherit it from `FlowNode` in order to be
    registered by the CryENGINE; there's no need for any manual registration calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that attributes can be placed without the last `Attribute` of its name.
    For example, `FlowNodeAttribute` can be placed as both `[FlowNodeAttribute]` and
    `[FlowNode]`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inputs are defined as functions in CryMono, and they take either a single parameter
    which defines the data type, or no parameter for void ports. They also need to
    be decorated with the `Port` attribute. In our case, let''s set up the same three
    inputs we had in the C++ version of the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll come back to the implementation of `Activate` in just a second. While
    you can override the port name by setting optional parameters in the attribute,
    it's easier way to just let your function name define how the node appears in
    the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Outputs are stored as instances of either `OutputPort` or `OutputPort<T>`,
    if values are required. Let''s add our `Result` output now as a property on the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Activate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump back to our `Activate` input; again, we need to retrieve our two
    values and then fire an output. The `FlowNode` class has convenient functions
    for these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Next time you open the Flowgraph Editor, you''ll see your new **CSharpTutorial:Multiplier**
    node, with the exact same functionality as the C++ equivalent you implemented
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Activate](img/5909_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations once again, as you've taken your first step to writing game
    code using the .NET platform and CryENGINE!
  prefs: []
  type: TYPE_NORMAL
- en: Target entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding support for target entities in CryMono is easy, simply set the `TargetsEntity`
    property in your `FlowNode` attribute to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can then obtain the entity instance via `FlowNode.TargetEntity`, assuming
    it was assigned inside the flowgraph containing the node.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learnt why flowgraphs can be useful to empower designers,
    and created our own flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: We've also investigated a selection of the existing nodes provided by CryENGINE,
    and then created our own nodes in two programming languages. You should now have
    a good understanding of the flowgraph system, and how to use it to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, we'll look at some of the additional things flowgraphs can
    achieve, including designing user interfaces, implementing material effects, creating
    special flownodes to represent entities in the world, and wrapping up AI functionality
    into convenient reusable modules.
  prefs: []
  type: TYPE_NORMAL
- en: For now, if you'd like to explore the world of flowgraphs more, why not have
    a go at figuring out how more of the stock nodes can be implemented? Familiarize
    yourself with the differences between writing C++ and C# nodes, and see which
    you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to experiment with CryMono in particular, try editing your node
    scripts and saving them with Sandbox running; you may be pleasantly surprised
    to find that they're recompiled and reloaded in the background! This should help
    you test new node ideas without having your experimentation hindered by compile
    times and restarts.
  prefs: []
  type: TYPE_NORMAL
