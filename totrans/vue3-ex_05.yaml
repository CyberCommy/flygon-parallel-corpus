- en: '*Chapter 5*: Building a Multipurpose Calculator Mobile App with Ionic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first four chapters, we have built various kinds of web applications
    with Vue 3\. We can also create mobile applications with Vue 3, but we can't create
    them with Vue 3 alone. We can create mobile apps with mobile app frameworks that
    use Vue 3 as its base framework. In [*Chapter 4*](B14405_04_ePub_RK.xhtml#_idTextAnchor046),
    *Building a Photo Management Desktop App*, we built a web app with Vue Router
    so that we could have multiple pages in our app. Vue Router lets us create apps
    that are slightly complex.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will move further from our knowledge of building web apps
    so that we can start building mobile apps. The app we will build is a calculator
    app that lets us convert currencies and calculate tips. It will also remember
    the calculations that we made so we can go back to redo them easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ionic Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Ionic Vue mobile app project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the packages for our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the calculators to our calculator app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter's project can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ionic Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ionic Vue** is a mobile app framework that lets us build apps with TypeScript
    and Vue. It also has versions based on React and Angular. It comes with many components
    that we can add to our app, just like any other UI framework. They include common
    things such as inputs, menus, icons, lists, and much more. A compiled Ionic app
    runs in a web view, so we can use web technologies such as local storage, geolocation,
    and other browser APIs in our apps.'
  prefs: []
  type: TYPE_NORMAL
- en: It also comes with built-in tools that let us build mobile apps automatically,
    without the need to set up everything from scratch ourselves. Ionic Vue creates
    components that use the Composition API by default, so we will use that to build
    Vue apps that are more modular and work better with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Composition API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composition API works better with TypeScript because it does not reference
    the `this` keyword, which has a dynamic structure. Instead, everything that is
    part of the Composition API, including its libraries, are compatible with it functions,
    which have clear parameters and return types. This lets us define TypeScript type
    definitions for them easily. Vue Router 4 and Vuex 4 are compatible with Vue 3's
    Composition API, so we can use them together in our Ionic Vue app.
  prefs: []
  type: TYPE_NORMAL
- en: With the Composition API, we still have the component object, but its structure
    is completely different from what we have in the Options API. The only property
    that is the same between the options and the Composition API is the `components`
    property. They both let us register components in both APIs. Our component logic
    is mostly in the `setup()` method. This is where we define our reactive properties,
    computed properties, watchers, and methods. Third-party libraries may also provide
    us with hooks, which are functions that we can call in our setup function to give
    us functionality that we want from the library. For example, Vuex 4 gives us the
    `useStore` hook so that we can gain access to the store. Vue Router 4 comes with
    the `useRouter` hook to let us navigate in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The way we define reactive and computed properties is different from the options
    API. In the options API, which we used in the previous chapters, we define and
    initialize our reactive properties in the `data()` method. In the Composition
    API, we call the `ref` function to define reactive properties that hold primitive
    values; we then call `reactive` to define reactive properties that have object
    values. To define computed properties in the Composition API, we call the `computed`
    function with a callback that references other reactive properties to create the
    computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers are created with the `watch` function. It takes a callback to return
    the reactive property we want to watch the value for. The second argument we pass
    into the `watch` function is a callback that lets us do something when the watched
    value changes. We can get the latest value of the reactive property being watched
    with the first parameter of the callback. The third argument contains the options
    for the watchers. We can set the deep and immediate properties in there as we
    do with watchers in the Options API.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are also added to the `setup` function. We can use arrow functions or
    regular functions to define them since the value of this doesn't matter. Reactive
    properties and methods must be returned in the object we return in the `setup()`
    method to expose them to the template. This way, they can be used in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TypeScript** is a language made by Microsoft that is an extension of JavaScript.
    It provides us with compile-time checking for data types in our code. However,
    it doesn''t provide us with extra runtime data type checks since TypeScript compiles
    to JavaScript before they are run. With the Composition API, our components do
    not reference the `this` keyword, so we don''t have to worry about it having the
    wrong value.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of using TypeScript is to ensure the type safety of primitive values,
    objects, and variables, which do not exist within JavaScript. In JavaScript, we
    can assign anything to any variable. This is, of course, going to be a problem
    since we may assign things to data types that we wouldn't usually. Also, functions
    can take anything as parameters and we can pass in any argument in any order into
    functions, so we may run into problems there if we pass in arguments that a function
    doesn't expect. Also, things may become `null` or `undefined` anywhere, so we
    must make sure that only places where we expect things to be null or undefined
    have those values. JavaScript functions can also return anything, so TypeScript
    can also restrict that.
  prefs: []
  type: TYPE_NORMAL
- en: Another big feature of TypeScript is that we can create interfaces to restrict
    the structure of objects. We can specify object properties and their types so
    that we can restrict objects to have the given properties, and so that the properties
    have the data types that we specify. This prevents us from assigning objects to
    variables and parameters that we don't expect, and it also provides us with autocomplete
    functionality in text editors that support TypeScript that we can't get with JavaScript
    objects. This is because the structures of objects are set. Interfaces can have
    optional and dynamic properties to let us maintain the flexibility of JavaScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: To retain the flexibility of JavaScript, TypeScript comes with union and intersection
    types. **Union** types are where we have more than one type joined together with
    a logical OR operator. A variable with a union type means that a variable can
    be one of the list of types that is of the union type. **Intersection** types
    are multiple types joined together with a logical AND operator. A variable with
    a type set to an intersection type must have all the members of all the types
    in the intersection.
  prefs: []
  type: TYPE_NORMAL
- en: To keep type specifications short, TypeScript comes with the `type` keyword,
    which lets us create a type alias. Type aliases can be used like regular types,
    so we can assign type aliases to variables, properties, parameters, return types,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In our mobile app, we will add pages for a tip calculator, currency converter,
    and a home page with a past list of calculations. We have any calculations that
    we have made in local storage so that we can go back to them later. The history
    is saved to local storage via the `vuex- persistedstate` plugin. This plugin is
    compatible with Vuex 4 and it lets us save the Vuex state to local storage directly,
    without us writing any extra code to do that ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at the basics of Vue's Composition API, TypeScript, and
    Ionic, we can start building our app with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Ionic Vue mobile app project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create our Ionic Vue project by installing the Ionic CLI. First, we
    must install the Ionic CLI by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create our Ionic Vue project by going to the folder where we
    want our project folder to be running. We can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `sidemenu` option lets us create an Ionic project with a side menu added
    to its pages. This will save us time with we're creating the menus and pages.
    The `--type vue` option lets us create an Ionic Vue project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get help with all the options and look at an explanation of each by
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ionic –help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ionic <command> --help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ionic <command><subcommand> --help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should run `ionic <command> --help` in our project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using Capacitor and Genymotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ionic Vue projects are served and built with Capacitor. Capacitor will open
    the project in Android Studio; then, we can launch it from there and preview our
    app in an emulator or device. For this project, we will preview our app with the
    Genymotion emulator. It is fast and has a plugin that lets us launch from Android
    Studio. We can download Genymotion emulator from [https://www.genymotion.com/download/](https://www.genymotion.com/download/)
    and Android Studio can be downloaded from [https://developer.android.com/studio](https://developer.android.com/studio).
  prefs: []
  type: TYPE_NORMAL
- en: Once we've installed Genymotion, we must create a virtual machine from the Genymotion
    UI. To do this, we can click the *plus* button, and then add the device that we
    want. We should add a device that has a recent version of Android, such as Android
    7 or later. The other options can be chosen according to our preference. To install
    the Genymotion plugin for Android Studio, follow the instructions at [https://www.genymotion.com/plugins/](https://www.genymotion.com/plugins/).
    This will let us run our Android Studio project in Genymotion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `package.json` file in our project, if we don''t see the `ionic:serve`
    and `ionic:build` scripts in the scripts section, we can add them by writing the
    following code inside the scripts section of our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can run `ionic build` to build our code so that it can be served with
    Capacitor later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done that, we can run the following command to add the dependencies
    for an Android project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is also required so that we can run our project as an Android app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve run those commands, we can run the following command so that we
    can run our app with live reload and make network access available from Genymotion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can access the internet just like any other app can. It also runs
    the `ionic:serve` script so that we can preview our app in the browser. Previewing
    our app in the browser is faster than in the emulator, so we may want to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Genymotion emulator'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.1_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Genymotion emulator
  prefs: []
  type: TYPE_NORMAL
- en: If we want to preview in Genymotion, we can go to Android Studio, which should
    open automatically once we run the `ionic capacitor run` command. Then, we can
    press *Alt*+*Shift*+*F10* to open the run app dialog, and then choose the app
    to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our Vue Ionic project, we must install a few more packages
    so that we can create our mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the packages for our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must install some dependencies that are needed in the project, but they aren't
    installed yet. We can use Axios to make HTTP requests to get the exchange rate.
    The `uuid` module lets us generate unique IDs for our history entries. Vuex doesn't
    come with the Ionic project, so we have to install that. We must also install
    the `vuex-persistedstate` module so that we can save Vuex state data to local
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install these packages, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next version of Vuex is the 4.x version, which is compatible with Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the calculators to our calculator app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our project ready, we can start working on our app. We start
    with adding the route definition to map URL paths to the page components that
    we will create. Then we will work on the components for each feature. And then
    we will add the Vuex store with code to persist the store data to local storage
    so we can use the data whenever we want.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will work on adding routing to our calculator app. In the `src/router/index.ts`
    file, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we have the `routes` array, which we can use to add the routes
    for the pages that we are going to add to our calculator app. The `routes` array
    is of the `Array<RouteRecordRaw>` type. This means that the objects in the `routes`
    array must have the path and component properties. The `path` property must be
    a string, while the component can be a component or function that returns a promise
    that resolves to a component. If the objects don't match the structure specified
    by `Array<RouteRecordRaw>`, the TypeScript compiler will give us an error when
    we build the code.
  prefs: []
  type: TYPE_NORMAL
- en: The code is built whenever we change any code file since we have the `livereload`
    option set, so we will get compiler errors almost immediately. This prevents most
    data type-related errors from occurring during runtime. The type definitions are
    built into the `vue-router` module, so we don't have to worry about missing data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the currency converter page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add the currency converter page. To add it, first, create the
    `src/views/CurrencyConverter.vue` file. Then, we must add the header to the template
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ion-page` component is the page container that lets us add content inside
    it. The `ion-toolbar` component adds a toolbar to the top of the page. The `ion-buttons`
    component is a container for buttons and inside it, we must add the `ion-menu-button`
    to the start slot so that we can add a menu button to the top-left corner of the
    screen. The `ion-menu- button` component will open the left-hand side menu when
    we click it. The `ion-title` component contains the page title. It is located
    at the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must add the `ion-content` component to add the content to the currency
    converter page. For instance, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the `ion-list` component so that we can add a list to our page.
    It lets us add a list of items to our app. In `ion-list`, we add `ion-item` to
    add a list item component. `ion-label` lets us add the label into the list item.
    The `color` property of the label text is set by the `color` prop. The `amountValid`
    prop is a computed property that checks whether the `amount` reactive property
    is valid. The `ion-input` component renders an input into our app. We set `type`
    to `number` to make the input a numeric input.
  prefs: []
  type: TYPE_NORMAL
- en: The `placeholder` prop lets us add a placeholder to our app. The `ion-text-right`
    class lets us put the input on the right-hand side. This is a class that comes
    with the Ionic framework. The `v-model` directive lets us bind the `amount` reactive
    property to the inputted value so that we can use the inputted value in the component
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The `fullscreen` prop of `ion-content` makes the page full screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add more items to the `ion-list` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added more `ion-items` to our `ion-list`. The `ion-select` component
    lets us add the currency to convert from dropdown, which lets us choose the currency
    that the amount is in. We bind `fromCurrency` to the value we selected in the
    dropdown to get the selected item inside our component code. The `ok-text` prop
    sets the OK text in the dropdown, while the `cancel-text` prop contains the text
    for the cancel button. The `ion-select` component lets us show a dialog with radio
    buttons that lets us display the items for us to choose from. Then, when we click
    or tap on the **OK** button, we can select the item.
  prefs: []
  type: TYPE_NORMAL
- en: The `ion-select-option` component lets us add options to the select dialog box.
    We use the `v-for` directive to loop through the `fromCurrencies` reactive property,
    which is a computed property that we create from filtering out the `selected`
    option from the **Currency to Convert To** dialog, which we will add later. This
    way, we can't select the same currency in both dropdowns, so currency conversion
    makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add another select dialog to let us select the currency that
    we want to convert the amount into. To do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `toCurrencies` reactive property is a computed property that contains an
    entry that has the value of `fromCurrency` filtered out. This means we can't select
    the same currency in both dropdowns.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the **Calculate** button, which lets us calculate the converted
    amount. We will add the `calculate()` method shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add another `ion-list`. This will add a list that adds the labels
    to display the converted amount. To do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have displayed the amount and `fromCurrency` that we entered. We also
    displayed the result and the `toCurrency` option that we selected. We called `toFixed`
    with argument `2` to round the result to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the script tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add a `script` tag with the `lang` attribute set to `ts` so that
    we can add the TypeScript code. First, we will add the `import` statements in
    order to add the components and other items that we will use in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See this book's GitHub repository for the full list of components that can be
    registered.
  prefs: []
  type: TYPE_NORMAL
- en: The `computed` function lets us create the computed properties that we can use
    with the Composition API. The `reactive` function lets us create reactive properties
    that have objects as values. The `ref` property lets us create computed properties
    that have primitive values. The `watch` function lets us create watchers that
    can be used with the Composition API.
  prefs: []
  type: TYPE_NORMAL
- en: The `currenciesArray` variable is an array of currencies that we will use to
    create the `fromCurrencies` and `toCurrencies` computed properties. The `axios`
    object lets us use the Axios HTTP client to make HTTP requests. The `useStore`
    variable is a function that lets us get access to our Vuex store. The `CurrencyConversion`
    interface provides the interface that we use to restrict the structure for the
    object that we add to the history list. The `uuidv4` variable is a function that
    lets us create UUIDs, which are unique IDs that we assign to the history entries
    to identify them. The `useRoute` function lets us access the route object to get
    the current URL path and other parts of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will register the components by adding the `components` property and
    the component we imported into it. To do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See this book's GitHub repository for the full list of components that can be
    registered. We just put all the `import` components into the `component` property
    to register them.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the setup method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will start working on the `setup()` method and add the reactive and
    computed properties to it. We will also add the watchers, which let us watch for
    route changes. First, we will write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We call the `useStore()` method to return the store object, which contains the
    Vuex store. We need the Vuex store to commit mutations, which lets us add entries
    to our history. Because we will add the `vuex-persistsedstate` plugin to our Vuex
    store, the history entries will be added to local storage automatically. Similarly,
    we call the `useRoute` function to return the route object, which lets us get
    access to the route object. We need the route object to let us watch the query
    string for the `id query` parameter. If we find an item by their ID, then we can
    set the `fromCurrency`, `toCurrency`, and `amount` values by using their values
    from the Vuex store, which we get from local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we call the `ref` function to create the `amount` reactive properties,
    which are number values. The `fromCurrency` and `toCurrency` reactive properties
    are string values and they contain the currency code of the currency that we choose.
    The `currencies` reactive property is a reactive array that is set to `currenciesArray`
    as its initial value. The arguments that we pass into `ref` and `reactive` are
    the initial values for each reactive property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add the computed properties by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We call the `computed` function with a callback to create the computed property.
    Like with the options API, we return the value that we want for the computed property.
    The only thing that's different is that we get the value of a primitive value
    reactive property with the `value` property. The `fromCurrencies` reactive property
    is created by filtering the currencies entry with the abbreviation that has the
    same value as `toCurrency`. `toCurrencies` is created by filtering the currencies
    entry with the abbreviation value, which is the same as the value of `fromCurrency`.
  prefs: []
  type: TYPE_NORMAL
- en: The `amountValid` computed property lets us determine whether the amount that's
    entered inside `ion-input` is valid. We want it to be a number that's at least
    `0`, so we return that condition so that we can check for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add these methods to our `CurrencyConverter` component by adding
    more items to the `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `addToHistory()` method lets us add a history entry to our Vuex store and
    local storage so that we can show the activities on the **Home** page. This way,
    we can choose them later and do the same calculation. In the signature, we annotate
    the type of the entry parameter with the `CurrencyConversion` interface so that
    we know we are adding the right thing to the Vuex store and local storage. We
    commit `addToHistory` to the store with the history entry as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the calculate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `calculate()` method, we reset the value of result to `0`. Then, we call
    `addToHistory` to add the entry to the history. The `id` property is generated
    from the `uuidv4` function to generate a unique ID for the entry. We set the other
    properties from the reactive property values. The `value` property is required
    to access primitive value reactive properties.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use Axios to get the exchange rate from the free to use Exchange Rate
    API. We just have to set the base query parameter to the code of the currency
    that we are converting from. Finally, we compute the result of the converted value
    by multiplying the amount by the exchange rate retrieved from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to finish off the `CurrencyConverter` component, we add the watcher for
    the query string. We watch the `queryID` parameter, which will change if we open
    the history entry from the home page. To add the watcher, we can write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To create the watcher, we pass in a function that returns `route.query` to return
    the query object. The `route` variable is assigned to the returned value of the
    `useRoute` function that we called earlier. Then, we get the query object's value
    from the first parameter of the function in the second argument. We get the `id`
    property from the query object. Then, we get the history state from the store,
    which contains all the entries we stored in local storage. Local storage is automatically
    synchronized by `vuex-persistedstate` to the Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `history.find()` method to find the entry by its `id`. Then, an
    entry is returned, and we set the `retrieved` property values to the reactive
    properties values. This automatically populates them when we choose an entry from
    the history.
  prefs: []
  type: TYPE_NORMAL
- en: In the third argument, we have an object that has the immediate property set
    to `true` so that the watcher runs immediately when the component is being mounted.
  prefs: []
  type: TYPE_NORMAL
- en: We return everything that we want to expose to the templates with the `return`
    statement at the end. We include all the reactive properties, computed properties,
    and methods so that they can be used in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''re finished with the project, the currency converter should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Currency Converter'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.2_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Currency Converter
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Tips calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add the `TipsCalculator` page component. To add it, we must add
    the `src/views/TipCalculator.vue` file. Inside it, we will start by adding the
    template and a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ion-header` is almost the same as the `CurrencyConverter` one, except the
    `ion-title` content is different.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `ion-content` component to add the content for the page. To
    do this, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added `ion-list` and the ion items for the form controls.
    We have one that lets us enter the subtotal on the page. This is the amount before
    the tip. The second `ion-item` component lets us add the `country ion-select`
    control. It lets us choose a country so that we can get the tip rate for that
    country. The tipping rate is computed from the `tippingRate` computed property.
    `ion-select-option` is created from the `countries` reactive array property, which
    provides the list of countries that we can choose from to get their tipping rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the display for the tipping rate and the **Calculate Tip**
    button. To do this, we will write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We just display the `tippingRate` computed property's value and the **Calculate
    Tip** button. We add a click handler by adding the `@click` directive and setting
    that to the `calculateTip()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the template is the calculated results. We add `ion-list`
    to component to add the results. We display the tip and the subtotal added together.
    To add it, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the TypeScript code for the `TipsCalculator` component. Its
    structure is similar to the `CurrencyConverter` component. First, we add the imports
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We import all the components and libraries as we did with `CurrencyConverter.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we register the components as we did with `CurrencyConverter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the reactive properties and get the store and route within
    the `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We call `useStore` and `useRoute` as we did within `CurrencyConverter`. Then,
    we create the `subtotal` reactive property with the `ref` function. Since its
    value is a number, we use the `ref` function to create it. The `country` array's
    reactive property is created with the reactive function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must add some computed properties by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we computed the tipping rate according to the country we selected.
  prefs: []
  type: TYPE_NORMAL
- en: The `amountValid` computed property lets us check whether the `subtotal` value
    is valid. We want to it to be `0` or bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the rest of the items to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `result` reactive property contains the result of the tip calculation. The
    `tip` property contains the tip amount. Finally, the `total` property contains
    the total of both `subtotal` and `tip`.
  prefs: []
  type: TYPE_NORMAL
- en: The `calculateTip()` method lets us calculate the tip. The value of the `result`
    property is initiated to `0` first. Then, we check if `amountValid` is true. If
    it's not, we stop running the function. Otherwise, we add the history entry to
    the store and local storage with the `addToHistory` function. Next, we do the
    tip calculation with the last two lines of the `calculateTip()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the watcher to the `setup()` method by writing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Just like in `CurrencyConverter.vue`, we watch the parsed query string object
    and populate the value from the history entry if it is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we return all the items we want to expose to the template, including
    any reactive and computed properties and the method with the `return` statement.
    Once we''ve finished the project, we should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Tips Calculator'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.3_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Tips Calculator
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add the `Home.vue` page component, which will let us view the
    calculations that we have done so far. We can redo the calculation by opening
    the page for the calculation with the values populated from our history. To add
    the calculation history list, we will start with its template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have used the same header that we've used on the other pages, but this one
    has a different title.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we render the `historyWithTypes` computed property to render the items
    from the history. If the `type` property is set to `tip`, we render the tip calculation
    data. Otherwise, we show the currency conversion data. In each row, we have the
    **Open** button, which calls the `go()` method when we click it. This takes us
    to the page with the given values from the history that have been populated on
    the page by the watchers of `CurrencyCoverter` or `TipsCalculator`. The **Delete**
    button calls the `deleteEntry()` method, which deletes the entry by its index.
    We must remember to set the `key` prop to the unique ID for each entry so that
    Vue can keep track of them properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the imports by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add the `type` alias for our history entries and register the
    component code by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We create the `HistoryEntry` TypeScript type alias, which is the union of the
    `CurrencyConversion` and `TipCalculation` interfaces. Objects of the `HistoryEntry`
    type must have the structure of either the `CurrencyConversion` or `TipCalculation`
    interface. Then, we register the components just like we registered the other
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the `setup()` method to add the component''s logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the store and the router as usual with `useStore` and `useRouter`, respectively.
    Then, we get the history state from the Vuex store with the `history` computed
    property. Then, we use the `history` computed property to create the `historyWithTypes`
    computed property. This lets us add the `type` property to the object so that
    we can distinguish the types of items in the template easily. In the `map` callback,
    we set the return type to `HistoryEntry & { type: string }` to create an intersection
    type with the interfaces that `HistoryEntry` is composed of and the `{ type: string
    }` type. `HistoryEntry & { type: string` } is the same as `CurrencyConversion
    & { type: string } | TipCalculation & { type: string }` since the `&` operator
    distributes when it''s used with the union `(|)` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: The `go()` method lets us navigate to the right page with the `id` property
    as the value of the `id` query parameter when we call `router.push`. The `path`
    property contains the URL path we specified in the route definitions, while the
    `query` property contains the object that is used to form the query string after
    the path.
  prefs: []
  type: TYPE_NORMAL
- en: The `deleteEntry()` method lets us delete an entry by committing the `removeHistoryEntry`
    mutation to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'We return all the methods and computed properties so that they can be used
    in the template. The **Home** page should look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Home screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.4_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Home screen
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Vuex store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to create the Vuex store. To do this, we will create the `src/vue/index.ts`
    file and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the interfaces and the same type alias as `Home.vue`. We created
    the Vuex store with the `createStore` function. The `plugins` property is set
    to the array that the `createPersistedState` function returns to let us save the
    store state to local storage. We have the history state in the `state()` method.
    The `mutations()` method has the `addToHistory` mutation, which lets us add entries
    to the history array state. We also have `removeHistoryEntry`, which lets us remove
    history items from the history state by its index. We must remember to export
    the store at the end so that we can import it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to add the list of countries and currencies. To add them, we
    will create the `src/constants.ts` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The full file's content can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter05/src/constants.ts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add the interfaces we imported by adding the `src/interfaces.ts`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main.ts`, we must add the store to our app by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We added `.use(store)` so that we can use the store in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in `App.vue`, we must update to change the items of the left menu.
    In the template, we must write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `ion-menu-toggle` component contains the menu items we can click or tap
    on to go to the given page, as specified by the `router-link` prop. The `ion-router-outlet`
    component is where the pages we created earlier are created. The `ion-icon` component
    lets us show the icon for each entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add the imports for `App.vue` by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add the component logic by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we registered the components and added the `appPages` property to render
    the items. It is not a reactive property as we didn''t create it with reactive,
    but we can use it our template since we returned it. Now, we will add some styles
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add some global styles by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By creating the project, we have learned how to use the Composition API, which
    is used by Ionic to create the Vue project. We also learned how to add type annotations
    with TypeScript to our JavaScript code to prevent data type errors in our code.
    And finally, we learned how to create mobile apps from web apps with Ionic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Ionic Vue, we can create mobile apps easily with Vue 3\. It makes use of
    the composition API, TypeScript, and Vue Router, along with the components provided
    by Ionic, to create good-looking apps that can work as web or mobile apps. It
    also comes with all the tools required to preview the app in a device or emulator
    and build it into an app package that we can deploy to app stores.
  prefs: []
  type: TYPE_NORMAL
- en: With the Composition API, we can add the logic like we can with the Vue Options
    API, but we can add them all with functions instead of referencing them. Ionic
    Vue also makes TypeScript the default language of components. This lets us prevent
    type errors at compile time to reduce the chance of type errors happening at runtime.
    This is a convenience feature that reduces frustration with JavaScript development.
    We made use of interfaces, union and intersection types, and type aliases to define
    types for objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to build a travel booking app with
    PrimeVue and Express.
  prefs: []
  type: TYPE_NORMAL
