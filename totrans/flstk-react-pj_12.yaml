- en: Following Best Practices and Developing MERN Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we elaborate on some of the best practices applied while building
    the four MERN applications in this book, along with other practices not applied
    in this book, but that should be considered for real-world applications to ensure
    reliability and scalability as complexity grows. Finally, we wrap up with suggestions
    on enhancing, and steps for extending the applications built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns with modularity in the app structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the options for CSS styling solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering with data for selected views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ES6 class for stateful vs purely functional components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding on using Redux or Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security enhancements for storing user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add new features to existing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns with modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building out the MERN stack applications, we followed a common folder
    structure across each application, which divided and grouped the code based on
    relevance and common functionality. The idea behind creating these smaller and
    distinct sections in the code is to make sure each section addresses a separate
    concern, so individual sections can be reused, as well as developed and updated
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the application folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More specifically, in the application folder structure, we kept the client-side
    and server-side code separate with further subdivisions within these two sections.
    This gave us some freedom to design and build the frontend and backend of the
    application independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `client` and `server` sections, we divided the code further into subfolders
    that mapped to unique functionalities, such as models, controllers, and routes
    in the server to a specific feature, such as grouping all components related to
    a user on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the server side, we divided the code according to functionality by separating
    code that defines business models from code implementing routing logic and code
    that responds to client requests at these routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this structure, each folder contains code with a specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**models**: This folder is meant to contain all the Mongoose schema model definitions
    in separate files, each file representing a single model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**routes**: This folder contains all routes that allow the client to interact
    with the server - placed in separate files where each file may be associated with
    a model in the models folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**controllers**: This contains all the controller functions that define logic
    to respond to incoming requests at the defined routes, divided into separate files
    corresponding to relevant model and route files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated throughout the book, these specific separations of concerns
    for the code on the server side allowed us to extend the server developed for
    the skeleton application by just adding the required model, route, and controller
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client-side code for the MERN applications consist primarily of React components.
    In order to organize the component code and related helper code in a reasonable
    and understandable manner, we separated the code into folders related to a feature
    entity or unique functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding structure, we placed all the auth-related components and helper
    code in the `auth` folder, common and basic components, such as the `Home` and `Menu`
    components, in the `core` folder, then we made `post` and `user` folders for all
    post-related or user-related components in the respective folders.
  prefs: []
  type: TYPE_NORMAL
- en: This separation and grouping of components based on features allowed us to extend
    the frontend views in the skeleton application for each application that followed,
    by adding a new feature-related component code folder, as required, to the client
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we demonstrate further the advantages
    of this modularized approach of separating the application code, as we outline
    the general workflow that can be adopted to add a new feature to any of the existing
    applications developed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When discussing user interface implementations for the applications in this
    book, we chose not to focus on the details of the CSS styling code applied and
    relied mostly on the default Material-UI stylings. But given that implementing
    any user interface requires considering styling solutions, we will briefly look
    at some of the options available.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to adding CSS styles to the frontend, there are a number of options,
    each with pros and cons. In this section, we will discuss the two most common
    options, which are  external style sheets and inline styles, along with a newer
    approach of writing CSS in JavaScript, or more specifically JSS, which is used
    in Material-UI components and hence also for the applications in this book.
  prefs: []
  type: TYPE_NORMAL
- en: External style sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External style sheets allow us to define CSS rules in separate files that can
    be injected into the necessary view. Placing CSS styles this way in external style
    sheets was once considered the better practice because it enforced the separation
    of style and content, allowing reusability and also maintaining modularity if
    a separate CSS file is created for each component.
  prefs: []
  type: TYPE_NORMAL
- en: However, as web development technologies continue evolving, the demands of better
    CSS organization and performance are no longer met by this approach. For example,
    using external style sheets while developing frontend views with React components
    limits control over updating styles based on the component state. Moreover, loading
    external CSS for React applications requires additional Webpack configurations
    with `css-loader` and `style-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: When applications grow and share multiple style sheets, it also becomes impossible
    to avoid selector conflicts because CSS has a single global namespace. Hence,
    though external style sheets may be enough for simple and trivial applications,
    as an application grows, other options for using CSS become more relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inline CSS is a style defined and applied directly to individual elements in
    the view. Though this takes care of some of the problems faced with external style
    sheets, such as eliminating the issue of selector conflicts and allowing state-dependent
    styles, it takes away reusability and introduces a few problems of its own, such
    as limiting the CSS features that can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Using only inline CSS for a React-based frontend has important limitations for
    growing applications, such as poor performance because all the inline styles are
    recomputed at each render, and inline styles are slower than class names to begin
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Inline CSS may seem like an easy fix in some cases, but does not serve as a
    good option for overall usage.
  prefs: []
  type: TYPE_NORMAL
- en: JSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSS allows us to write CSS styles using JavaScript in a declarative way. This
    also means all the features of JavaScript are now available for writing CSS, making
    it possible to write reusable and maintainable styling code.
  prefs: []
  type: TYPE_NORMAL
- en: JSS works as a JS to CSS compiler that takes JS objects, where keys represent
    class names, with values representing corresponding CSS rules, and then generates
    the CSS along with scoped class names.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, JSS generates unique class names by default when it compiles JSON
    representations to CSS, eliminating the chances of selector conflicts faced with
    external style sheets. Moreover, unlike inline styles, CSS rules defined with
    JSS can be shared across multiple elements and all CSS features can be used in
    the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Material-UI uses JSS to style its components, and as a result we used JSS to
    apply Material-UI themes and also custom CSS to the components developed for the
    frontend views in all the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Selective server-side rendering with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed the frontend of the base skeleton application in [Chapter
    4](e161ddf5-86d2-4511-a7df-558b512f46ed.xhtml), *Adding a React Frontend to Complete
    MERN*, we integrated basic server-side rendering to be able to load client-side
    routes directly from the browser address bar when the request goes to the server.
    In this SSR implementation, while rendering the React components server-side,
    we did not consider loading the data from the database for the components that
    displayed data. The data only loads in these components when the client-side JavaScript
    takes over after the initial load of the server-side rendered markup.
  prefs: []
  type: TYPE_NORMAL
- en: We did update this implementation to add server-side rendering with data for
    the individual media detail pages in the MERN Mediastream application discussed
    in [Chapter 9](3e7c6b91-643a-4af2-8b06-c5ae75356984.xhtml), *Customizing Media
    Player and Improve SEO*. In this case, we decided to render this specific view
    with data by injecting data into the server-side generated markup of the React
    frontend. The reasoning behind this selective server-side rendering with data
    only for specific views can be based on certain desired behaviors for the view
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: When is SSR with data relevant?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing server-side rendering with data for all the React views in an
    application can become complicated and additional work when it is necessary to
    consider views with client-side authentication or consisting of multiple data
    sources. In many cases, it may be unnecessary to tackle these complexities if
    the view does not require server-side rendering with data. In order to judge whether
    a view needs to be server-rendered with data, answer the following questions for
    the specific view to make your decision:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it important for the data to be displayed in the initial load of the view
    when JavaScript may not be available in the browser?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the view and its data need to be SEO-friendly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data in the initial load of the page may be relevant from a usability
    persepective, so it really depends on the use case for the specific view. For
    SEO, server-side rendering with data will give search engines easier access to
    the data content in the view, so if this is crucial for the view in question,
    then adding server-side rendering with data is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Using ES6 class for stateful vs pure functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building UI with React components, composing the views with more stateless
    functional components can make the frontend code manageable, clean, and easier
    to test. But some components will need the state or lifecycle hooks to be more
    than pure presentational components. In this section, we look at what it takes
    to build stateful and stateless functional React components, when to use one or
    the other and how often.
  prefs: []
  type: TYPE_NORMAL
- en: React components with ES6 class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components defined using ES6 class have access to lifecycle methods, the `this`
    keyword, and can manage state with `setState` when building stateful components.
    Stateful components allow us to build interactive components that can manage changing
    data in state, and propagate any business logic that needs to be applied across
    the UI. Generally, for complex UI, stateful components should be higher-level
    container components that manage the state of the smaller stateless functional
    components they are composed of.
  prefs: []
  type: TYPE_NORMAL
- en: React components as pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components can be defined as stateless functional components using the
    ES6 class syntax or as pure functions. The main idea is a stateless component
    does not modify state and receives props.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code defines a stateless component using the ES6 class syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can also be defined using JavaScript pure functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A pure function always gives the same output when given the same input without
    any side effects. Modeling React components as pure functions enforces creation
    of smaller, more defined, and self-contained components that emphasize UI over
    business logic as there is no state manipulation in these components. These kinds
    of components are composable, reusable, and easy to debug and test.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the UI with stateful components and stateless functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While thinking about the component composition for a UI, design the root or
    a parent component as a stateful component that will contain child components
    or the composable components that only receive props and cannot manipulate state.
    All the state-changing actions using `setState` and life-cycle issues will be
    handled by the root or parent component.
  prefs: []
  type: TYPE_NORMAL
- en: In the applications developed for this book, there is a mixture of stateful
    higher-level components and smaller stateless components. For example, in the
    MERN Social application, the `Profile` component modifies the state for stateless
    child components, such as the `FollowProfileButton` and `FollowGrid` components.
    There is scope for refactoring some of the larger components that were developed
    in this book into smaller, more self-contained components, and this should be
    considered before extending the applications to incorporate more features.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway that can be applied to new component design or refactoring
    existing components, is that as the React application grows and gets more complex,
    it is better to have more stateless functional components added to higher-level
    stateful components that are in charge of managing state for its inner components.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux or Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When React applications begin to grow and get more complex, managing communication
    between components can become problematic. When using regular React, the way to
    communicate is to pass down values and callback functions as props to the child
    components. But this can be tedious if there are a lot of intermediary components
    that the callback must pass through. To address these state communication and
    management-related issues as the React application grows, people turn to using
    React with libraries and architecture patterns such as Redux and Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is outside the scope of this book to delve into the details of integrating
    React with the Redux library or the Flux architecture, but the reader may consider
    these options for their growing MERN applications while keeping the following
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux and Flux utilize patterns that enforce changing states in a React application
    from a central location. A trick to avoid using Redux or Flux in React applications
    of manageable sizes, is moving all state changes up the component tree to parent
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller applications work just as well without Flux or Redux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about using React with Redux at [https://redux.js.org/](https://redux.js.org/),
    and Flux at [facebook.github.io/flux/](http://facebook.github.io/flux/).
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the MERN applications developed for this book, we kept the auth-related security
    implementations simple by using JSON Web Tokens as an authentication mechanism
    and by storing hashed passwords in the User collection. In this section, we will
    go over these choices and point to possible enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: JSON web tokens – client-side or server-side storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the JWT authentication mechanism, the client side becomes responsible for
    maintaining user state. Once the user signs in, the token sent by the server is
    stored and maintained by the client-side code on browser storage, such as `sessionStorage`.
    Hence, it is also up to the client-side code to invalidate the token by removing
    it when a user signs out or needs to be signed out. This mechanism works out well
    for most applications that need minimal authentication to protect access to resources.
    However, for instances where it may be necessary to track user sign-ins, sign-outs,
    and to let the server know that a specific token is no longer valid for sign-in,
    just the client-side handling of the tokens is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: For these cases, the implementation discussed for handling JWT tokens on the
    client side can be extended to storage on the server side as well. In the specific
    case of keeping track of invalidated tokens, a MongoDB collection can be maintained
    by the server to store these invalidated tokens as reference, somewhat similar
    to how it is done for storing session data on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to be cautious about and to keep in mind is that storing and maintaining
    auth-related information on both the client and server side may be overkill in
    most cases. Hence it is entirely up to the specific use case and the related trade-offs
    to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Securing password storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While storing user credentials for authentication in the User collection, we
    made sure that the original password string provided by the user is never stored
    directly in the database. Instead we generated a hash of the password along with
    a salt value using the `crypto` module in Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `user.model.js` from our applications, we defined the following functions
    to generate the hashed `password` and `salt` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, every time a user enters a password to sign in, a
    hash is generated with the salt. If the generated hash matches the stored hash,
    then the password is correct, otherwise the password is wrong. So in order to
    check whether a password is correct, the salt is required, and hence it is stored
    with the user details in the database along with the hash.
  prefs: []
  type: TYPE_NORMAL
- en: This is standard practice for securing passwords stored for user authentication,
    but there are other advanced approaches that may be explored if a specific application's
    security requirements demand it. Some options that can be considered include multi-iteration
    hashing approaches, other secure hashing algorithms, limiting login attempts per
    user account, and multi-level authentication with additional steps such as answering
    security questions or entering security codes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though discussing and writing test code is outside the scope of this book, it
    is crucial for developing reliable software. In this section, first we will look
    at the testing tools available to test the different parts of a MERN application.
    Then, to help get started with writing test code for the MERN applications developed
    in this book, we will also discuss a real example of adding a client-side test
    to the MERN Social application from [Chapter 5](8af4986f-1f37-45f2-ba05-85caa119a652.xhtml),
    *Starting with a Simple Social Media Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a comprehensive testing framework for JavaScript. Though it is more
    commonly known for testing React components, it can be used for general-purpose
    testing with any JavaScript library or framework. Among the many JavaScript testing
    solutions in Jest, it provides support for mocking and snapshot testing, comes
    with an assertion library, and tests in Jest are written in the **behavior driven
    development** (**BDD**) style. Besides testing the React components, Jest can
    be also be adapted to write test code for the Node-Express-Mongoose-based backend
    as required. Hence, it is a solid testing option to add test code for the MERN
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Jest, read the docs at [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test to the MERN Social application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Jest, we will add a client-side test to the MERN Social application and
    demonstrate how to get started with adding tests to MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing the test code, first we will set up for testing by installing
    the necessary packages, defining the test run script, and creating a `tests` folder
    for the test code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following npm packages will be required in order to write test code and
    run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jest**: To include the Jest testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**babel-jest**: To compile JS code for Jest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**react-test-renderer**: To make a snapshot of the DOM tree rendered by a React
    DOM without using a browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install these packages as `devDependencies`, run the following `npm install`
    command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Defining the script to run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run the test code, we will update the run scripts defined in `package.json`,
    to add a script for running tests with `jest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the command line, if we run `npm run test`, it will prompt Jest to find the
    test code in the application folders and run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tests folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the client-side test in the MERN Social application, we will create a
    folder called `tests` in the client folder, which will contain test files relevant
    to testing the React components. When the test command is run, Jest will look
    for the test code in these files.
  prefs: []
  type: TYPE_NORMAL
- en: The test case for this example will be a test on the `Post` component, and tests
    for the `Post` component will be added in a file called `post.test.js` in the
    `tests` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Test case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write a test to check whether the `delete` button on a post is only
    visible when the signed-in user is also the creator of the post. This means that
    the delete button will only be a part of the Post view, if the `user._id` of the
    authenticated user is the same as the `postedby` value of the post data being
    rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to implement this test case, we will add code which takes care of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dummy data for a post and an `auth` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks `auth-helper.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the test and within the test definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declares the `post` and `auth` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the return value of the mocked `isAuthenticated` method to the dummy `auth`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `renderer.create` to create the `Post` component with the required dummy
    props passed and wrapped in `MemoryRouter` to provide the props related to `react-router`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates and matches snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in `post.test.js` to incorporate the steps described for this specific
    test will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Generating a snapshot of the correct Post view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time this test is run, we will provide it with the values required
    to generate the correct snapshot of the Post view. The correct snapshot for this
    test case will contain the delete button when the `user._id` of the auth object
    is equal to the `postedBy` value of the post object. This snapshot generated when
    the test is first run will be used for comparison for future test executions.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing in Jest basically records snapshots of rendered component structures
    to compare them to future renderings. When the recorded snapshot and the current
    rendering don’t match, the test fails, indicating that something has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Running and checking the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the code that we just added to the `post.test.js`, the dummy `auth` object
    and `post` object refer to the same user, thus running this test in the command
    line will prompt Jest to generate a snapshot that will contain the delete option
    and also pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, go into the project folder from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The test output will show that the test passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd786cee-c6d3-4d46-8eab-b7dfc375cff2.png)'
  prefs: []
  type: TYPE_IMG
- en: The recorded snapshot that is generated, when this test runs successfully for
    the first time, is added automatically to a `_snapshots_` folder in the `tests`
    folder. This snapshot represents the state where the delete button is rendered
    in the view since the authenticated user is also the creator of the post.
  prefs: []
  type: TYPE_NORMAL
- en: We can now check whether the test actually fails when the component is rendered
    with an authenticated user that is not the creator of the post. To perform this
    check, we will update the dummy data objects by changing `user._id` to not match
    the `postedBy` value, then run the test again. This will give us a failed test,
    as the current rendering will no longer have a delete button that is present in
    the recorded snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the test log pictured next, the test fails and indicates that the
    rendered tree does not match the recorded snapshot since the elements representing
    the delete button are missing in the received value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c11456c-887a-450f-ba95-0a8eb79dd656.png)'
  prefs: []
  type: TYPE_IMG
- en: With this screenshot, we have a client-side test for checking whether a signed-in
    user can view the `delete` button on their posts. Using this setup, more tests
    can be added for the MERN application utilizing the capabilities of Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test code will make the application you develop reliable and also help
    ensure code quality. Another good practice for improving and maintaining code
    quality is using a linting tool with your project. Linting tools perform static
    analysis on the code to find problematic patterns or behaviors that violate specified
    rules and guidelines. Linting code in a JavaScript project can improve overall
    code readability and also help find syntax errors before the code is executed.
    For linting in MERN-based projects, you can explore ESLint, which is a JavaScript
    linting utility that allows developers to create their own linting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the bundle size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you develop and grow a MERN application, chances are the size of the bundles
    produced with Webpack will also grow, especially if large third-party libraries
    are used. Larger bundle sizes will effect performance and increase the initial
    load time of the application. We can make changes in the code to ensure we don’t
    end up with large bundles and also utilize features packed in Webpack 4 to help
    optimize bundling. In this section, we will highlight some key concepts that can
    give us control in producing smaller bundles and decreasing load time.
  prefs: []
  type: TYPE_NORMAL
- en: Before going into the code to update it for bundle size optimization, you can
    also get familiar with the default optimization options that are now part of Webpack
    4\. In the MERN applications, we used the `mode` config to utilize the default
    settings for both development and production mode. To get an overview of the options
    available, check out this article at [https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a).
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of loading all the code at once in one bundle, we can use the code-splitting
    feature supported by Webpack to lazy-load parts of the application code as currently
    needed by the user. After we modify the application code to introduce code splitting,
    Webpack can create multiple bundles rather than one large bundle. These bundles
    can be loaded dynamically at runtime, allowing us to improve the performance of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about code splitting support in Webpack and how to make necessary
    changes to the setup and configuration, check out the guides in the documentation
    at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to introduce code splitting for the application code,
    but the most important syntax you will come across for this purpose is the dynamic
    `import()`. In the next section, we will look at how to use `import()` with our
    MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic import()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic `import()` is a new function-like version of the regular import and
    it enables the dynamic loading of JS modules. Using `import(moduleSpecifier)`
    will return a promise for the module namespace object of the requested module. When
    using regular static imports, we import a module at the top of the code and then
    use it in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to use dynamic `import()` instead of adding the static import at
    the beginning, the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This allows importing and loading the module when the code requires it. While
    bundling the application code, Webpack will treat calls to `import()` as split
    points and automatically start code splitting by placing the requested module
    and its children into a separate chunk from the main bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to optimize the bundling of the frontend React code by applying code
    splitting at a given component, we need to pair dynamic `import()` with React
    Loadable—a higher-order component for loading components with promises. As an
    example, we will look at the shopping cart developed in [Chapter 7](b73b9122-dd0c-45dc-ac34-94ce990e0437.xhtml),
    *Extending the Marketplace for Orders and Payments*. While building the interface
    of the cart, we composed the `Cart` component by importing and adding the `Checkout`
    component to the view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To introduce code splitting here and import the `Checkout` component dynamically,
    we can replace the static import at the beginning with a `Loadable` Checkout,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Making this change and using Webpack to build the code again will produce a
    `bundle.js` file of reduced size, and generate another smaller bundle file representing
    the split code, which will now only load when the `Cart` component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Using this mechanism, we can apply code splitting across our application code
    as required. The thing to keep in mind is that effective code splitting will depend
    on using it correctly and applying it at the right places in the code—places that
    will benefit in optimization from resource-load prioritization.
  prefs: []
  type: TYPE_NORMAL
- en: Route-based code splitting can be an effective approach for introducing code
    splitting in React apps that use routes to load components in the view. To learn
    more about implementing code splitting, specifically with React Router, check
    out the article at [https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapters in this book, as we developed each application, we added
    features by extending the existing code in a common and repeatable number of steps.
    In this final section, we will review these steps and set a guideline for adding
    more features to the current versions of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the server code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a specific feature, that will require data persistence and APIs to allow
    the views to manipulate the data, we can start by extending the server code and
    adding the necessary models, routes, and controller functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the data persistence aspect of the feature, design the data model considering
    the fields and values that need to be stored. Then, define and export a Mongoose
    schema for this data model in a separate file in the `server/models` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, design the APIs relevant for the desired feature, in order to manipulate
    and access the data that will be stored in the database based on the model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the APIs decided, add the corresponding controller functions that will
    respond to the requests to these APIs in a separate file in the `server/controllers`
    folder. The controller functions in this file should access and manipulate the
    data for the model defined for this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the implementation of the server-side APIs, corresponding routes
    need to be declared and mounted on the Express app. In a separate file in the
    `server/routes` folder, first declare and export the routes for these APIs, assigning
    the relevant controller functions that should be executed when a specific route
    is requested. Then, load these new routes on the Express app in the `server/express.js`
    file, like the other existing routes in the application.
  prefs: []
  type: TYPE_NORMAL
- en: This will produce a working version of the new backend APIs that can be run
    and checked from a REST API client application, before going on to build and integrate
    frontend views for the feature being developed.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the client code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the client side, first design the views required for the feature, and determine
    how these views will incorporate user interaction with the data relevant to the
    feature. Then add the fetch API code to integrate with the new backend APIs, define
    the new components that represent these new views, and update the existing code
    to include these new components in the frontend of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the API fetch methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the client folder, create a new folder to house the components and helper
    code relevant to the feature module being developed. Then to integrate the new
    backend APIs, add and export the corresponding fetch methods in a separate file
    in this new components folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create and export new React components that represent views for the desired
    feature, in separate files in the new folder. Integrate auth into these new components
    using the existing auth-helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: Loading new components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to incorporate these new components into the frontend, the components
    either need to be added into existing components or rendered at their own client-side
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Updating frontend routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If these new components need to be rendered at individual routes, update the
    `MainRouter.js` code to add new routes that load these components at given URL
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with existing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the new components will become part of existing views, import the component
    into the existing component to add it to the view as desired. The new components
    can also be integrated with existing components, such as in the `Menu` component,
    by linking to new components that were added with individual routes.
  prefs: []
  type: TYPE_NORMAL
- en: With the components integrated and connected with the backend, the new feature
    implementation is complete. These steps can be repeated to add on new features
    to the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we reviewed and elaborated on some of the best practices
    used while building the MERN applications in this book, highlighted areas of improvement,
    gave pointers to address issues that may crop up when applications grow, and finally
    set down the guidelines to continue developing more features into the existing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that modularizing the application's code structure helped extend the
    application easily, choosing to use JSS over inline CSS and external style sheets
    kept the styling code contained and easy to work with, and only implementing server-side
    rendering for specific views as required kept unnecessary complications out of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the benefits of creating fewer stateful components that are composed
    of smaller and more defined stateless functional components, and how this can
    be applied while refactoring existing components or designing new components to
    extend the applications. For growing applications that may run into issues of
    managing and communicating state across hundreds of components, we pointed to
    options such as Redux or Flux that may be considered to address these issues.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that may have higher demands for stricter security enforcement,
    we looked back at our existing implementation of user auth with JWT and password
    encryption, and discussed possible extensions for improved security.
  prefs: []
  type: TYPE_NORMAL
- en: We used Jest to demonstrate how test code can be added to the MERN applications,
    and discussed how good practices, such as writing test code and using a linting
    tool, can improve code quality besides ensuring reliability in an application.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at bundle optimization features, such as code splitting, that
    can help to improve performance by reducing the initial bundle size, and by lazy-loading
    parts of the application as required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed and set down the repeatabe steps that were used throughout
    the book, and can be used as a guideline moving forward to extend the MERN applications
    by adding more features.
  prefs: []
  type: TYPE_NORMAL
