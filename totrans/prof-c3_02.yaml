- en: Chapter 2. Mastering of Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will master the box model, floating troubleshooting positioning,
    and display types. After this chapter, you will be more aware of the foundations
    of HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gaining knowledge about the traditional box model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of floating elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundations of positioning elements on a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining knowledge about display types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional box model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An understanding of the box model is the foundation of CSS theories. You have
    to know the impact of width, height, margin, and borders on the size of the box
    and how you can manage it to match the elements on a website. The main questions
    for coders and frontend developers in interviews are based on box model theories.
    Let's begin this important chapter, which will be the foundation for every upcoming
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: Padding/margin/border/width/height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ingredients of the final width and height of the box are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paddings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For better understanding of the box model, the following is an image from Google
    Chrome inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For more clarity and better understanding of the box model, let''s analyze
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding image, you can see that in the box model, we have the following
    four edges:'
  prefs: []
  type: TYPE_NORMAL
- en: Content edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margin edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The width and height of the box are based on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Width/height of content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The width and height of content in the box with default box-sizing are controlled
    by the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Min-width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max-width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min-height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max-height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing about the box model is how background properties will behave.
    The background will be included in the content section and in the padding section
    (to the padding edge).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get a code and try to point to all elements of the box model.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view from the inspector of Google Chrome is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check how the areas of the box model are placed in the following specific
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The basic task for the interviewed frontend developer is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The box/element is described with the styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please count the final `width` and `height` (the real space which is needed
    for this element) of this element.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, the problem is to count the width and height of the box.
  prefs: []
  type: TYPE_NORMAL
- en: '*The ingredients* of width are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally for the width of space taken by the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Margin left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margin right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The ingredients* of height are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Border bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally for height of space taken by the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Margin top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margin bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, when you sum the elements, you will have the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Space width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Space height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check it in the real browser as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Padding/margin/border/width/height](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Omitting problems with the traditional box model (box-sizing)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic theory of the box model is pretty hard to learn. You need to remember
    all the elements of width/height, even if you set the width and height. The hardest
    thing for beginners to understand is padding, which shouldn't be counted as a
    component of width and height. It should be *inside* the box and it should impact
    on this value. To change these behaviors with CSS3, supported since Internet Explorer
    8, comes box-sizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What does it give to you? Finally, the counting of box width and height will
    be easier because box padding and the border are inside the box. So if we are
    taking our previous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can count the width and height easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the space taken by the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Space width = 140px (because the 20px margin is on both sides left and right)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space height = 240px (because the 20px margin is on both sides top and bottom)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample from Google Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Omitting problems with the traditional box model (box-sizing)](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, if you do not want to repeat all the problems of the traditional
    box model, you should use it globally for all elements. Of course, it''s not recommended
    for old projects, for example, a new client who needs some small changes in the
    old project. If you add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can cause more harm than good because of the inheritance of this property
    for all elements, which are now based on the traditional box model. But for all
    new projects, you should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Floating elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Floating boxes are the most used in modern layouts. The theory of floating boxes
    was used especially in grid systems and inline lists in CSS frameworks. For example,
    class and mixin inline lists (in the Zurb Foundation framework) are based on floats.
  prefs: []
  type: TYPE_NORMAL
- en: Possibilities of floating elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Elements can be floated to the left and right side. Of course, there is a method
    to reset floats too. The possible values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Most known floating problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are using floating elements, you can have some issues. The most known
    problems with floated elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Too big elements (because of width, margin left/right, padding left/right, and
    badly counted width, which is based on the box model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not cleared floats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these problems provide specific effects, which you can easily recognize
    and then fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements which are too big can be recognized when they are not in one line,
    as they should be. What you should check first is if the box-sizing: border-box
    is applied, and then check width, padding, and margin.'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily recognize floats that are not cleared when the floating structure
    of some elements from next container are *floated*. This means that you have no
    clear fix in your floating container.
  prefs: []
  type: TYPE_NORMAL
- en: Defining clear fix/class/mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When I started developing HTML and CSS code, there was a method to clear the
    floats with `.cb` or `.clear` classes, both of which were defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This element was added in a container right after all the floated elements.
    This is important to remember about clearing the floats because containers that
    contains floating elements won''t inherit the height of the highest floating element
    (which will have a height equal to `0`),for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Nowadays, there is a better and faster way to clear floats. You can do this
    with the `clear fix` element, which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can use it in HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The main reason to switch on `clear fix` is that you save one tag (with the
    `clearboth` class). Recommended usage is based on the `clear fix` mixin, which
    you can define in SASS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, every time you need to clear floating in some container, you need
    to invoke it. For example, let us take the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The container can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Example of using floating elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most known usage of float elements is grids. A grid is mainly used to structure
    the data displayed on a web page. In this chapter, let's check just a short draft
    of a grid. In the upcoming chapters, we will focus on automatization of creating
    the grid with mixins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create some HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And also create some SASS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The final effect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of using floating elements](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we created a structure of a basic grid. In places where HTML
    code is placed `Lorem` here is a full `lorem ipsum` to illustrate the grid system.
  prefs: []
  type: TYPE_NORMAL
- en: Display types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few display types in CSS whose definition and behaviors are the
    foundation of frontend developers. The most known and basic display values are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline-block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table/table-cell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flex (this will be described further in this book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Block elements always start from a new line. The most important properties
    of block elements are width and height, which can be changed from CSS code. For
    better understanding, let''s check the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Block elements](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is easy to see that all the block elements are taking as much width as they
    can.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mainly used HTML block-level elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`article`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aside`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blockquote`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`div`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`footer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1`, `h2`, `h3`, `h4`, `h5`, `h6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`section`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ul`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inline elements can be described as elements that take as much space as they
    need. It can be best described using the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inline elements](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The mainly used HTML inline-level elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acronym`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dfn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`samp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bdo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`br`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textarea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline-block display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inline elements are elements that gather properties of inline and block elements.
    Inline elements take as much space as they need, but additionally you can set
    their width, height, and padding. On the following image which is added (after
    the code listings), you can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Described with SASS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiled to CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Inline-block display](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can easily see, the first element is a block element and it takes as
    much width as it can. The second element is inline. The third is a block element
    with a set width (300 pixels). The fourth element is inline with a set width (300
    pixels) but it is not applied to this element because it has no proper display
    type. In addition, the last element is a span whose normal display type is inline
    but is set in CSS to inline block. After this operation, you can set the width
    of the element, and, additionally, it naturally floats to the previous inline
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you use other types of elements – navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most known problem related to types of display is inline navigations. For
    better understanding, let''s create a markup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to make the elements in one line is to use `float:left`, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The second idea is to use `display: inline-block` on the `li` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Where can you use other types of elements – problem of equal boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a one problem, which is repeating on web pages, and you will need to
    append some JavaScript code to apply the same height. It was necessary to do that
    back in the days. Firstly, the heights of boxes were measured and then the bigger
    height was set as the height, which would be applied to another box. Finally,
    the height would be applied to all equalized boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, you can use a table-cell value of display.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'SASS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect in the browser is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Where can you use other types of elements – problem of equal boxes](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: CSS elements positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding of positions in CSS is one of the key skills of frontend developers.
    It helps you to change the behavior of each element on a web page. Additionally,
    with a mix of positions, you can change the behavior of the inner (child) elements.
  prefs: []
  type: TYPE_NORMAL
- en: Static, relative, absolute, fixed – differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The position static is a default value of the position, which includes every
    element on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The position relative is making an element relative to itself. You can easily
    understand it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And create the SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What you should see before appending the styles is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static, relative, absolute, fixed – differences](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, after appending the styles you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static, relative, absolute, fixed – differences](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when we change the position to `relative` and move it with property
    top, left, right, or bottom, we will move the element from its current position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, relatively positioned elements can be set as a scope for inner
    elements with the position absolute, for example, HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect in the browser is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static, relative, absolute, fixed – differences](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The orange box is a `.relative` element. The smaller box is absolutely positioned
    and related with the `relative` element.
  prefs: []
  type: TYPE_NORMAL
- en: The position `absolute` can be used as in the preceding example. But what will
    happen when there isn't a parent relative element? Absolutely positioned elements
    will be related with HTML DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixed* elements are strictly fixed to the browser. So when you apply position:
    `fixed` to any element and give it top: `0` and left: `0`, this element will be
    stuck to the top-left corner of the browser. Even when the scroll action is done,
    the element won''t change its position related to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code will show you how fixed elements are behaving.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `body` element has `padding-top`,
    which is equal to the height of the `.fixed` element. This is caused by the `fixed`
    element that normally when you remove the padding `fixed` element will be over
    the `body` content (it will cover this element). The following screenshot shows
    the browser before the scroll action and the next screenshot shows the browser
    after the scroll action. Both screenshots contain the border of the browser to
    show the proper scroll action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Static, relative, absolute, fixed – differences](img/00027.jpeg)![Static,
    relative, absolute, fixed – differences](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Important properties, which you can add to elements with positions, `relative`/`fixed`/`absolute`,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z-index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common problem during the coding of the position is overriding the `left`
    value by applying the `right` value. A sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `.element` will be still stuck to its left position. How do you append it
    to the right position?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Lists with fixed images (on the right or left) and descriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a pretty common problem relating to lists. Lists of articles with fixed
    images (with fixed width and height) on the one side and with elastic content
    on the right could be pretty problematic without the positions `relative` and
    `absolute`. Following is an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS code after compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect in the browser is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists with fixed images (on the right or left) and descriptions](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The effect after resize of the browser is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists with fixed images (on the right or left) and descriptions](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you want to get the image on the right side, you will need to make the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiled CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect in the browser is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists with fixed images (on the right or left) and descriptions](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter builds strong fundamentals for professional usage of CSS. You gathered
    the knowledge about the box model, positions, and floating elements. The next
    chapter is going to be a story about pseudoclasses.
  prefs: []
  type: TYPE_NORMAL
