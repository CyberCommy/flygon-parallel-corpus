- en: Sorting and Its Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序及其应用
- en: 'Sorting is a very common algorithm that we use to rearrange a list of numbers
    or objects in an ascending or descending order. A more technical definition of
    sorting is as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是我们用来重新排列一组数字或对象以升序或降序排列的非常常见的算法。排序的更技术性的定义如下：
- en: In computer science, a sorting algorithm is an algorithm that puts elements
    of a list in a certain order.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，排序算法是一种将列表中的元素按照特定顺序排列的算法。
- en: Now, let's assume that you have a list of *n* items, and you want to sort them.
    You take all the `n` items and determine all the possible sequences in which you
    can place these items, which, in this case, would be `n!` in total. We now need
    to determine which of these `n!` series does not have any inverted pairs to find
    out the sorted list. An inverted pair is defined as a pair of elements whose position
    in the list is represented by `i, j` where `i < j`, but the values `x[i] > x[j]`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您有一个包含*n*个项目的列表，并且您想对它们进行排序。您取出所有*n*个项目，并确定您可以将这些项目放置在所有可能的序列中，这种情况下总共有`n!`种可能。我们现在需要确定这些`n!`序列中哪些没有任何倒置对，以找出排序后的列表。倒置对被定义为列表中位置由`i，j`表示的一对元素，其中`i
    < j`，但值`x[i] > x[j]`。
- en: 'Of course, the preceding method is tedious and requires some heavy computation.
    In this chapter we will be discussing the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述方法是繁琐的，需要一些繁重的计算。在本章中，我们将讨论以下主题：
- en: Types of sorting algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法的类型
- en: Creating an API for a book management system (such as a library)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图书管理系统（如图书馆）创建API
- en: Insertionsort Algorithm to sort the book data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序算法用于对书籍数据进行排序
- en: Mergesort Algorithm to sort the book data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序算法用于对书籍数据进行排序
- en: Quicksort Algorithm to sort the book data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序算法用于对书籍数据进行排序
- en: Performance Comparision of the different sorting algorithms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同排序算法的性能比较
- en: Let's take a look at some of the more optimal types of sorting as listed above,
    which can be employed in various scenarios.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下上面列出的一些更优化的排序类型，可以在各种场景中使用。
- en: Types of sorting algorithms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法的类型
- en: We all know that there are different types of sorting algorithms, and most of
    us would have heard of the names of these different types of algorithms at various
    times in our programming careers. The big difference between sorting algorithms
    and data structures is that the former always has the same goal, irrespective
    of which type of algorithm is used. That makes it very easy and important for
    us to compare the different sorting algorithms on various fronts, which in most
    of the cases boils down to speed and memory usage. We need to make this determination
    before we pick a particular sorting algorithm based on the type of the data that
    we have at hand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道有不同类型的排序算法，大多数人在编程生涯中的某个时候都听说过这些不同类型的算法的名称。排序算法和数据结构之间的主要区别在于，无论使用哪种类型的算法，前者总是有相同的目标。这使得我们非常容易和重要地在各个方面比较不同的排序算法，大多数情况下都归结为速度和内存使用。在选择特定的排序算法之前，我们需要在手头的数据类型基础上做出这一决定。
- en: 'Keeping the above in mind, we will compare and contrast the following three
    different types of algorithms:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到以上情况，我们将比较和对比以下三种不同类型的算法：
- en: Insertionsort
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Mergesort
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Quicksort
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Mergesort and Quicksort are the algorithms that v8 engine uses internally to
    sort the data; when the dataset size is too small (<10) the Mergesort is employed,
    else quicksort. Insertionsort, on the other hand, is an algorithm which is much
    simpler to implement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序和快速排序是v8引擎在内部用于对数据进行排序的算法；当数据集大小太小（<10）时，使用归并排序，否则使用快速排序。另一方面，插入排序是一种更简单的算法。
- en: However, before we jump into the implementation of each of these sorting algorithms,
    let's take a quick look at the use case and then set up the prerequisites for
    the same.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入讨论每种排序算法的实现之前，让我们快速看一下用例，然后设置相同的先决条件。
- en: Use cases of different sorting algorithms
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同排序算法的用例
- en: In order to test the different sorting algorithms, we will create a small express
    server, which will contain one endpoint to get a list of all books sorted by the
    number of pages in each of the books. In this example, we will start with an unordered
    list of books from a JSON file, which will serve as our data store.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试不同的排序算法，我们将创建一个小型的express服务器，其中将包含一个端点，用于获取按每本书的页数排序的所有书籍列表。在这个例子中，我们将从一个JSON文件开始，其中包含一个无序的书籍列表，这将作为我们的数据存储。
- en: In production applications, the sorting should be deferred to your database
    query and should not be done as a part of the application logic to avoid pain
    and confusion when dealing with scenarios such as filtering and paginated requests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用中，排序应该推迟到数据库查询，并且不应作为应用逻辑的一部分来完成，以避免在处理筛选和分页请求等场景时出现痛苦和混乱。
- en: Creating an Express server
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Express服务器
- en: 'The first thing that we do to set up our project is to create the directory
    in which we want to write our application; to do so, run the following command
    in the terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置项目的第一步是创建一个目录，我们想要在其中编写我们的应用程序；为此，在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once created, step into the directory by running `cd` and then run the npm
    initialization command to set it up as a Node.js project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，通过运行`cd`进入目录，然后运行npm初始化命令将其设置为Node.js项目：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will ask you a series of questions, which you can answer or leave empty
    for default answers, either of which is fine. Once your project is initialized,
    add the following npm package as we have done in previous chapters to help us
    set up the express server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将询问您一系列问题，您可以回答或留空以获得默认答案，两者都可以。项目初始化后，添加以下npm包，如前几章所做，以帮助我们设置express服务器：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once added, we are now ready to create our server. Add the following code to
    a new file at the root of the project and call it `index.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，我们现在准备创建我们的服务器。在项目的根目录中添加以下代码到一个新文件中，并将其命名为`index.js`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have set up a single endpoint that returns `OK` and our server is running
    on port `3000`. Let''s also add a shortcut in scripts of our `package.json` file
    to start the application easily:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, to test these changes, run `npm start` from your root folder and open `localhost:3000`
    in your browser. You should note an `OK!` message on the screen as defined by
    our route in the `index.js` file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Mocking library books data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the mock data of our library books, which we want to sort
    and return when the users request the list of books. In this chapter, we will
    focus on sorting the library books by the number of pages in each book, so we
    can add only the page count and the ID of the book for simplicity, as shown in
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We want to test the performance of each of these algorithms, so let's add 5,000
    of these books to ensure that we have enough data to test the performance. Also,
    we will add these page counts randomly between 300 and 2,000 pages, and since
    we have a total of 5,000 books, there will be an obvious duplication of page sizes
    across different books.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample script that you can use to generate this data if
    you want to use this script; ensure that you install the `uuid` npm module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, create a file at the root of the project called `generator.js` and add
    the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, to run it, run the `node generator.js` command from the root, which will
    generate the `books.json` file with the data similar to the records shown in the
    preceding code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Insertionsort API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create an endpoint that uses Insertionsort to sort and return our
    data based on the page count.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: What is Insertionsort
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insertionsort, as the name suggests, is a type of sort in which we extract elements
    from the input dataset one by one and then insert them in the sorted result dataset
    after determining where the element should be placed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We can straight away determine that this approach will require an extra set
    (of the same size as the input) to hold the results. So, if we have a `Set` of
    10 elements as the input, we will need another `Set` for the output whose size
    would be 10 as well. We can switch around this approach a little bit so that our
    sorting happens in-memory. Performing an action in-memory means that we will not
    request for any more memory (by creating extra sets of the same size as the input).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly chalk up the pseudo code for Insertionsort:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implementing Insertionsort API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the preceding pseudo-code described, implementing Insertionsort is
    very easy. Let''s first create a folder called `sort` and then create a file called
    `insertion.js` in which we will add our insertion class, as shown in the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in the pseudo code and the actual implementation, we will take
    each value and compare it with values before it, which does not sound like a very
    good thing to do when you have 5,000 items in a random order; and that is true,
    Insertionsort is a preferred choice only when the dataset is almost sorted and
    there are a few inverted pairs in the entire dataset.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to improve this functionality is by changing the way we determine the
    position at which we want to insert in the sorted list. Instead of comparing it
    with all the previous values, we can instead perform a binary search to determine
    where the data should be moved to in the sorted list. So, by slightly modifying
    the preceding code, we get the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once implemented, we will now need to define the route for using this sort
    on our dataset. To do so, first, we will import the JSON data, which we earlier
    created, and then use that in our endpoint, which we specifically create to sort
    the data using Insertionsort:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can restart our server and try to hit the endpoint at `localhost:3000/insertion`
    either from the browser or postman, as shown in the following screenshot, to see
    the response containing sorted data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37231e17-b848-4451-b0a8-15d945bda797.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Mergesort API
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create the endpoint, which uses Mergesort to sort and return our
    data based on the page count.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个端点，使用Mergesort对基于页面计数的数据进行排序并返回。
- en: What is Mergesort
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Mergesort
- en: Mergesort is a type of divide and conquer sorting algorithm in which the entire
    dataset is first divided into subsets of one element each—these subsets are then
    joined and sorted repeatedly until we get one sorted set.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Mergesort是一种分而治之的排序算法，首先将整个数据集划分为每个元素一个子集，然后重复地将这些子集连接和排序，直到得到一个排序好的集合。
- en: This algorithm uses both recursion and divide and conquer methods. Let's take
    a look at the pseudo code for such an implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法同时使用了递归和分而治之的方法。让我们来看看这种实现的伪代码。
- en: Pseudo code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'Based on what we have known so far about the mergesort, we can come up with
    the pseudo code for the implementation, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止对mergesort的了解，我们可以得出实现的伪代码，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note in the preceding code, we first recursively divide the input dataset, then
    sort and combine the dataset back. Now, let's implement this sorting algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们首先递归地将输入数据集划分，然后对数据集进行排序和合并。现在，让我们实现这个排序算法。
- en: Implementing Mergesort API
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Mergesort API
- en: 'Let''s now create our Mergesort class alongside the Insertionsort class, which
    we earlier created, and call it `merge.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的Mergesort类，以及之前创建的Insertionsort类，并将其命名为`merge.js`：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have the class, we can now add a new endpoint to use this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个类，我们现在可以添加一个新的端点来使用这个类：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, restart your server and test the changes made:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动服务器并测试所做的更改：
- en: '![](assets/7933b749-866e-43ec-bdde-05cfb564cf67.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7933b749-866e-43ec-bdde-05cfb564cf67.png)'
- en: Quicksort API
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quicksort API
- en: Similar to Mergesort, Quicksort is also a type of divide and conquer algorithm.
    In this section, we will create the endpoint that will use this algorithm to sort
    and return our dataset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mergesort类似，Quicksort也是一种分而治之的算法。在本节中，我们将创建一个端点，使用这个算法对数据集进行排序并返回。
- en: What is Quicksort
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Quicksort
- en: Quicksort divides the set into two smaller subsets of low and high values based
    on a preselected pivot value, and these smaller subsets are then recursively sorted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Quicksort根据预先选择的枢轴值将集合分为两个较小的低值和高值子集，然后递归地对这些较小的子集进行排序。
- en: The selection of the pivot values can be done in several ways, and it is the
    most important aspect of the algorithm. One way is to simply pick the first, last,
    or the median values from the set. Then, there are custom partition schemes, such
    as Lomuto or Hoare (which we will use later in this chapter), which can be used
    to achieve the same. We will explore a couple of these implementations in this
    section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 选择枢轴值可以通过几种方式完成，这是算法中最重要的方面。一种方法是简单地从集合中选择第一个、最后一个或中间值。然后，还有自定义的分区方案，如Lomuto或Hoare（我们将在本章后面使用），可以用来实现相同的效果。我们将在本节中探讨其中一些实现。
- en: Let's take a look at the pseudo code for this implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个实现的伪代码。
- en: Pseudo code
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'The pseudo code for quicksort is very obvious based on what we have discussed
    so far:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止讨论的内容，quicksort的伪代码非常明显：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can note in the preceding code, the algorithm is not very complex once
    we abstract out the logic to get the pivot.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所注意到的，一旦我们抽象出获取枢轴的逻辑，算法就不是很复杂。
- en: Implementing the Quicksort API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Quicksort API
- en: 'First, let''s create the Quicksort class, which will sort the elements based
    on the pivot as the first element in the set passed. Let''s create a file called
    `quick.js` under the `sort` folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建Quicksort类，它将根据传递的集合中的第一个元素作为枢轴来对元素进行排序。让我们在`sort`文件夹下创建一个名为`quick.js`的文件：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That was straightforward, now, let''s quickly add the endpoint to access this
    algorithm to sort our books and return them to the requested user:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这很直接了当，现在，让我们快速添加一个端点来访问这个算法，对我们的书进行排序并将它们返回给请求的用户：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, now, restart the server to access the new endpoint that is created. We
    can see here that the approach is not ideal as it is requesting additional memory
    to contain the low and the high values compared to the pivot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在重新启动服务器以访问新创建的端点。我们可以看到这里的方法并不理想，因为它需要额外的内存来包含低值和高值，与枢轴相比。
- en: So, instead, we can use the previously discussed Lomuto or Hoare Partition Schemes
    to perform this operation in memory and reduce the memory costs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用之前讨论过的Lomuto或Hoare分区方案来在内存中执行此操作，并减少内存成本。
- en: Lomuto Partition Scheme
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lomuto分区方案
- en: 'The Lomuto Partition Scheme is very similar to the simple sort function that
    we implemented earlier. The difference is that once we select the last element
    as the pivot, we need to keep adjusting its position by sorting and swapping the
    elements in memory, as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Lomuto分区方案与我们之前实现的简单排序函数非常相似。不同之处在于，一旦我们选择最后一个元素作为枢轴，我们需要通过在内存中对元素进行排序和交换来不断调整其位置，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, let''s consider the following data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下数据：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we call our partition with this dataset, our pivot is first the last element
    `3` (indicating `pages: 3`), the low value is 0 (so is our pointer) and high value
    is 4 (the index of the last element).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们使用这个数据集调用我们的partition时，我们的枢轴首先是最后一个元素`3`（表示`pages: 3`），低值为0（所以是我们的指针），高值为4（最后一个元素的索引）。'
- en: 'Now, in the first iteration, we see that the value of the `j^(th)` element
    is greater than the pivot, so we swap the `j^(th)` value with the low current
    pointer position; since both of them are the same, nothing happens on the swap,
    but we do increment the pointer. So, the dataset remains the same:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在第一次迭代中，我们看到第`j`个元素的值大于枢轴，所以我们将第`j`个值与低当前指针位置交换；由于它们两者相同，交换时什么也不会发生，但我们会增加指针。因此，数据集保持不变：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the next iteration, the same thing happens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，同样的事情发生了：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the third iteration, the value is smaller, so nothing happens and the loop
    continues:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次迭代中，值较小，所以什么也不会发生，循环继续：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the fourth iteration, the value (`5`) is greater than the pivot value, so
    the values swap and the pointer increments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the control breaks out of the `for` loop, and we finally place our data
    in the correct position by swapping for the pivot one last time, which gives us
    the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After this, we can return the position of the pointer, which is nothing but
    the new position of the pivot. In this example, the data is sorted in the first
    iteration, but there can, and will, be scenarios where such is not the case, hence
    we repeat the process recursively for the subsets to the left and right of the
    pivot position.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Hoare Partition Scheme
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hoare Partition Scheme, on the other hand, takes a pivot value from the middle
    of the dataset and then starts parsing the values from the low and high end to
    determine the actual position of the pivot; this results in fewer number of operations
    as compared to the Lomuto Scheme:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can put this all together into our `Quick` class and update our API
    to use the newly created method, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we update our API call signature, we get the following in our `index.js`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On restarting the server and accessing the endpoint, we get the following result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19f51739-0563-46d2-bbe3-db4a92dce4ce.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding screenshot that the quicksort is marginally faster
    than the Mergesort for the given dataset.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Performance comparison
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a few sorting algorithms listed and implemented, let's quickly
    take a look at their performance. We briefly talked about some performance enhancements
    while we were implementing these algorithms; we will try to quantify this performance
    enhancement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will first install the node module called `benchmark` to create
    our test suite:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have installed the benchmark framework, we can add our tests to a file
    called `benchmark.js` at the root of the project, which will run the different
    sorting algorithms described in the preceding section:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s now update the scripts tag of our `package.json` file to update and
    run the tests:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To see the changes, run the `npm run test` command from the root of the project,
    and we will see something similar in the terminal:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is something that we use frequently. It is important to know how sorting
    algorithms work and how we can use these based on the type of dataset. We made
    some critical changes from the base approach to ensure that we are optimizing
    our algorithms and finished off with some statistics on how efficiently these
    algorithms perform when compared side by side. However, of course, one might think
    about whether performance tests are necessary to check whether an algorithm is
    better than another. We will be discussing that in our next chapters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
