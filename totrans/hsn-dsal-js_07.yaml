- en: Sorting and Its Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sorting is a very common algorithm that we use to rearrange a list of numbers
    or objects in an ascending or descending order. A more technical definition of
    sorting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, a sorting algorithm is an algorithm that puts elements
    of a list in a certain order.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's assume that you have a list of *n* items, and you want to sort them.
    You take all the `n` items and determine all the possible sequences in which you
    can place these items, which, in this case, would be `n!` in total. We now need
    to determine which of these `n!` series does not have any inverted pairs to find
    out the sorted list. An inverted pair is defined as a pair of elements whose position
    in the list is represented by `i, j` where `i < j`, but the values `x[i] > x[j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the preceding method is tedious and requires some heavy computation.
    In this chapter we will be discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an API for a book management system (such as a library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertionsort Algorithm to sort the book data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mergesort Algorithm to sort the book data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quicksort Algorithm to sort the book data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance Comparision of the different sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at some of the more optimal types of sorting as listed above,
    which can be employed in various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Types of sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that there are different types of sorting algorithms, and most of
    us would have heard of the names of these different types of algorithms at various
    times in our programming careers. The big difference between sorting algorithms
    and data structures is that the former always has the same goal, irrespective
    of which type of algorithm is used. That makes it very easy and important for
    us to compare the different sorting algorithms on various fronts, which in most
    of the cases boils down to speed and memory usage. We need to make this determination
    before we pick a particular sorting algorithm based on the type of the data that
    we have at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the above in mind, we will compare and contrast the following three
    different types of algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: Insertionsort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mergesort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quicksort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mergesort and Quicksort are the algorithms that v8 engine uses internally to
    sort the data; when the dataset size is too small (<10) the Mergesort is employed,
    else quicksort. Insertionsort, on the other hand, is an algorithm which is much
    simpler to implement.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we jump into the implementation of each of these sorting algorithms,
    let's take a quick look at the use case and then set up the prerequisites for
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of different sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test the different sorting algorithms, we will create a small express
    server, which will contain one endpoint to get a list of all books sorted by the
    number of pages in each of the books. In this example, we will start with an unordered
    list of books from a JSON file, which will serve as our data store.
  prefs: []
  type: TYPE_NORMAL
- en: In production applications, the sorting should be deferred to your database
    query and should not be done as a part of the application logic to avoid pain
    and confusion when dealing with scenarios such as filtering and paginated requests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Express server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that we do to set up our project is to create the directory
    in which we want to write our application; to do so, run the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, step into the directory by running `cd` and then run the npm
    initialization command to set it up as a Node.js project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ask you a series of questions, which you can answer or leave empty
    for default answers, either of which is fine. Once your project is initialized,
    add the following npm package as we have done in previous chapters to help us
    set up the express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once added, we are now ready to create our server. Add the following code to
    a new file at the root of the project and call it `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have set up a single endpoint that returns `OK` and our server is running
    on port `3000`. Let''s also add a shortcut in scripts of our `package.json` file
    to start the application easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, to test these changes, run `npm start` from your root folder and open `localhost:3000`
    in your browser. You should note an `OK!` message on the screen as defined by
    our route in the `index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking library books data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the mock data of our library books, which we want to sort
    and return when the users request the list of books. In this chapter, we will
    focus on sorting the library books by the number of pages in each book, so we
    can add only the page count and the ID of the book for simplicity, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We want to test the performance of each of these algorithms, so let's add 5,000
    of these books to ensure that we have enough data to test the performance. Also,
    we will add these page counts randomly between 300 and 2,000 pages, and since
    we have a total of 5,000 books, there will be an obvious duplication of page sizes
    across different books.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample script that you can use to generate this data if
    you want to use this script; ensure that you install the `uuid` npm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a file at the root of the project called `generator.js` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, to run it, run the `node generator.js` command from the root, which will
    generate the `books.json` file with the data similar to the records shown in the
    preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Insertionsort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create an endpoint that uses Insertionsort to sort and return our
    data based on the page count.
  prefs: []
  type: TYPE_NORMAL
- en: What is Insertionsort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insertionsort, as the name suggests, is a type of sort in which we extract elements
    from the input dataset one by one and then insert them in the sorted result dataset
    after determining where the element should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: We can straight away determine that this approach will require an extra set
    (of the same size as the input) to hold the results. So, if we have a `Set` of
    10 elements as the input, we will need another `Set` for the output whose size
    would be 10 as well. We can switch around this approach a little bit so that our
    sorting happens in-memory. Performing an action in-memory means that we will not
    request for any more memory (by creating extra sets of the same size as the input).
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly chalk up the pseudo code for Insertionsort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Insertionsort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the preceding pseudo-code described, implementing Insertionsort is
    very easy. Let''s first create a folder called `sort` and then create a file called
    `insertion.js` in which we will add our insertion class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in the pseudo code and the actual implementation, we will take
    each value and compare it with values before it, which does not sound like a very
    good thing to do when you have 5,000 items in a random order; and that is true,
    Insertionsort is a preferred choice only when the dataset is almost sorted and
    there are a few inverted pairs in the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to improve this functionality is by changing the way we determine the
    position at which we want to insert in the sorted list. Instead of comparing it
    with all the previous values, we can instead perform a binary search to determine
    where the data should be moved to in the sorted list. So, by slightly modifying
    the preceding code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once implemented, we will now need to define the route for using this sort
    on our dataset. To do so, first, we will import the JSON data, which we earlier
    created, and then use that in our endpoint, which we specifically create to sort
    the data using Insertionsort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can restart our server and try to hit the endpoint at `localhost:3000/insertion`
    either from the browser or postman, as shown in the following screenshot, to see
    the response containing sorted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37231e17-b848-4451-b0a8-15d945bda797.png)'
  prefs: []
  type: TYPE_IMG
- en: Mergesort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create the endpoint, which uses Mergesort to sort and return our
    data based on the page count.
  prefs: []
  type: TYPE_NORMAL
- en: What is Mergesort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mergesort is a type of divide and conquer sorting algorithm in which the entire
    dataset is first divided into subsets of one element each—these subsets are then
    joined and sorted repeatedly until we get one sorted set.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm uses both recursion and divide and conquer methods. Let's take
    a look at the pseudo code for such an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on what we have known so far about the mergesort, we can come up with
    the pseudo code for the implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note in the preceding code, we first recursively divide the input dataset, then
    sort and combine the dataset back. Now, let's implement this sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Mergesort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create our Mergesort class alongside the Insertionsort class, which
    we earlier created, and call it `merge.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the class, we can now add a new endpoint to use this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, restart your server and test the changes made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7933b749-866e-43ec-bdde-05cfb564cf67.png)'
  prefs: []
  type: TYPE_IMG
- en: Quicksort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to Mergesort, Quicksort is also a type of divide and conquer algorithm.
    In this section, we will create the endpoint that will use this algorithm to sort
    and return our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: What is Quicksort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quicksort divides the set into two smaller subsets of low and high values based
    on a preselected pivot value, and these smaller subsets are then recursively sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The selection of the pivot values can be done in several ways, and it is the
    most important aspect of the algorithm. One way is to simply pick the first, last,
    or the median values from the set. Then, there are custom partition schemes, such
    as Lomuto or Hoare (which we will use later in this chapter), which can be used
    to achieve the same. We will explore a couple of these implementations in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the pseudo code for this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudo code for quicksort is very obvious based on what we have discussed
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can note in the preceding code, the algorithm is not very complex once
    we abstract out the logic to get the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Quicksort API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create the Quicksort class, which will sort the elements based
    on the pivot as the first element in the set passed. Let''s create a file called
    `quick.js` under the `sort` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That was straightforward, now, let''s quickly add the endpoint to access this
    algorithm to sort our books and return them to the requested user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Also, now, restart the server to access the new endpoint that is created. We
    can see here that the approach is not ideal as it is requesting additional memory
    to contain the low and the high values compared to the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead, we can use the previously discussed Lomuto or Hoare Partition Schemes
    to perform this operation in memory and reduce the memory costs.
  prefs: []
  type: TYPE_NORMAL
- en: Lomuto Partition Scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lomuto Partition Scheme is very similar to the simple sort function that
    we implemented earlier. The difference is that once we select the last element
    as the pivot, we need to keep adjusting its position by sorting and swapping the
    elements in memory, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s consider the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call our partition with this dataset, our pivot is first the last element
    `3` (indicating `pages: 3`), the low value is 0 (so is our pointer) and high value
    is 4 (the index of the last element).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the first iteration, we see that the value of the `j^(th)` element
    is greater than the pivot, so we swap the `j^(th)` value with the low current
    pointer position; since both of them are the same, nothing happens on the swap,
    but we do increment the pointer. So, the dataset remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next iteration, the same thing happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third iteration, the value is smaller, so nothing happens and the loop
    continues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fourth iteration, the value (`5`) is greater than the pivot value, so
    the values swap and the pointer increments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the control breaks out of the `for` loop, and we finally place our data
    in the correct position by swapping for the pivot one last time, which gives us
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After this, we can return the position of the pointer, which is nothing but
    the new position of the pivot. In this example, the data is sorted in the first
    iteration, but there can, and will, be scenarios where such is not the case, hence
    we repeat the process recursively for the subsets to the left and right of the
    pivot position.
  prefs: []
  type: TYPE_NORMAL
- en: Hoare Partition Scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hoare Partition Scheme, on the other hand, takes a pivot value from the middle
    of the dataset and then starts parsing the values from the low and high end to
    determine the actual position of the pivot; this results in fewer number of operations
    as compared to the Lomuto Scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can put this all together into our `Quick` class and update our API
    to use the newly created method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we update our API call signature, we get the following in our `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On restarting the server and accessing the endpoint, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19f51739-0563-46d2-bbe3-db4a92dce4ce.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding screenshot that the quicksort is marginally faster
    than the Mergesort for the given dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Performance comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a few sorting algorithms listed and implemented, let's quickly
    take a look at their performance. We briefly talked about some performance enhancements
    while we were implementing these algorithms; we will try to quantify this performance
    enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will first install the node module called `benchmark` to create
    our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have installed the benchmark framework, we can add our tests to a file
    called `benchmark.js` at the root of the project, which will run the different
    sorting algorithms described in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now update the scripts tag of our `package.json` file to update and
    run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the changes, run the `npm run test` command from the root of the project,
    and we will see something similar in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is something that we use frequently. It is important to know how sorting
    algorithms work and how we can use these based on the type of dataset. We made
    some critical changes from the base approach to ensure that we are optimizing
    our algorithms and finished off with some statistics on how efficiently these
    algorithms perform when compared side by side. However, of course, one might think
    about whether performance tests are necessary to check whether an algorithm is
    better than another. We will be discussing that in our next chapters.
  prefs: []
  type: TYPE_NORMAL
