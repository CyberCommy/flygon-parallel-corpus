- en: Working with SVG and CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on the intersection between SVG and CSS. While JavaScript
    is the most powerful tool for working with SVG, SVG without CSS wouldn't be nearly
    as popular as it has become. SVG, as you've learned, is well-suited for the modern
    web and is often the best answer to an RWD question. Because of that, it's been
    wholeheartedly embraced by designers and developers for producing images for the
    web.
  prefs: []
  type: TYPE_NORMAL
- en: This preference for SVG is a good one for the web as a whole and should be cultivated.
    This chapter will hopefully illustrate why.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS background images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to optimize data URIs for SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG sprites versus icon fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the different ways of embedding SVG interact with CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using common CSS properties to manipulate SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SVG-specific CSS properties to manipulate SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic CSS animations and transitions with SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS background images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've already seen examples of using CSS for background images all the way
    back in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*. This section will add some more details to using SVG
    in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this initial, basic example, we add an SVG image of a stylized letter R
    as the background image of a `div`. One important aspect is setting the `background-size`
    property. The natural size of the SVG image is `458` by `392`. In this case it''s
    set to be half that size in order to fit into the size of the `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9e4f359-a25f-4ec2-aab1-06ecd07114a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Other than providing for high pixel density displays (which *is* a great feature),
    this doesn't get you much beyond what a PNG provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an environment where relative units are being used, you can leverage SVG''s
    ability to scale with `contain` or `cover` as the value of `background-size` to
    really take advantage of SVG. In the following example, the same previous logo
    is applied as a background image, alongside some text. All of the metrics are
    relative, using the root em (rem) unit. The background image is set with a `background-size`
    value of `contain`. `contain` ensures that the logo will be shown, *in its entirety*,
    constrained by the height and width of the containing element. Since we''re using
    an SVG image as the background image, the base font for the document (and therefore
    the calculation of the *root em*) could scale from 16 pixels (the browser default)
    to 1,600 pixels and the SVG background would be able to scale to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04b8f8c6-75a8-4ef7-8070-fe306cc8ecd3.png)'
  prefs: []
  type: TYPE_IMG
- en: There's not much here that's new,  but it's such an important use for SVG on
    the modern web it's worth taking some time to reinforce the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Data URLs for SVG background images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re performance-minded, you might be wondering about the technique of
    embedding a background image directly in your CSS via a data: URL. Data URLs allow
    you to embed files directly into a document via a special `data: URL`.  This technique
    allows you to save an HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with binary formats such as JPGs or PNGs, the image data needs
    to be `base64`-encoded. While this will work with SVG images, it''s actually faster
    ([https://css-tricks.com/probably-dont-base64-svg/](https://css-tricks.com/probably-dont-base64-svg/)) to
    embed the SVG images as an SVG source. This works because, in addition to `base64`-encoded
    data, you can directly embed text. SVG is, of course, a text format.  You just
    need to do a couple of things to the SVG to make it work properly. You should
    read the full article by Taylor Hunt for the details ([https://codepen.io/tigt/post/optimizing-svgs-in-data-uris](https://codepen.io/tigt/post/optimizing-svgs-in-data-uris))
    but the basic steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Use single quotes for attribute values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL-encode any non-safe characters (`<`, `>`, `#`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double quote the data URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Converting the initial example, we get code that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While this is actually pretty straightforward to prep by hand (the example here
    was hand-coded), there are some tools available that can do this for you if you're
    looking to squeeze out all the bytes. There's a node module ([https://www.npmjs.com/package/mini-svg-data-uri](https://www.npmjs.com/package/mini-svg-data-uri))
    and a SASS function ([https://codepen.io/jakob-e/](https://codepen.io/jakob-e/))
    that can help you build this capability into your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: SVG sprites and icon sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section isn't strictly about CSS, but does discuss a replacement for a
    common CSS-driven solution for adding icons to applications so this seems such
    as the best place to discuss it.
  prefs: []
  type: TYPE_NORMAL
- en: If you're reading this book you're probably somewhat familiar with the idea
    of icon fonts such as GLYPHICONS ([http://glyphicons.com/](http://glyphicons.com/)) or
    Font Awesome ([https://fontawesome.com/icons?from=io](https://fontawesome.com/icons?from=io)).
    If you're not, they are fonts that, instead of representing characters that can
    be read as language (as in, the characters that you're reading right now), they
    present different images that can be used as icons for a site or application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could create an interface for a video player using *Font Awesome*
    without having to design a single element.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample shows what that implementation might look such as.
    In addition to Font Awesome, the following example uses Bootstrap styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic pattern for Font Awesome is to include the icons as an empty element.
    In this case an `i`. Each one has two common classes: `fa` and `fa-2x`. These
    indicate that the element is a Font Awesome icon and that it should render at
    `2x` the normal size. After that, the individual icons are added with `fa-`classes
    that indicate the type of icon to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5cedaab-822a-4474-918e-f3d7a4018eb1.png)'
  prefs: []
  type: TYPE_IMG
- en: That's all very clean and easy to understand. Because of that, these icon fonts
    are very popular. I've used them in multiple environments and I am impressed with
    their general ease of use and the ability they offer to get up and running very
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, there are downsides to using icon fonts. Two prominent downsides
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessibility: There are ways to do icon fonts well with regard to accessibility
    ([https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html](https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html)),
    but out of the box, you''re inserting gibberish characters into an empty element.
    Screen readers can read that nonsense, creating a confusing experience for users
    who rely on AT to browse the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Semantics: Empty elements are *empty. *Icon fonts using `i` or `span` don''t
    really hold any meaning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other issues including the finicky nature of loading web fonts in
    general and problems for dyslexic users ([https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/](https://cloudfour.com/thinks/seriously-dont-use-icon-fonts/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is, if you''re interested in better semantics, better accessibility
    and more straightforward implementation, there''s an SVG alternative to icon fonts:
    using *SVG sprites*. To be fair, SVG sprites aren''t a perfect solution either
    as the most elegant variation on them requires an IE/Edge-shaped workaround,.
    But for certain configurations (specifically single-page apps) SVG sprites are
    a great choice for icon delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we're going to use Front Awesome v5 which provides SVG Versions
    of all of their icons to replicate the previous set of controls.
  prefs: []
  type: TYPE_NORMAL
- en: Here's how the same controls are implemented using SVG sprites.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's look at a detail of the sprite file itself. In it, all of the icons
    are defined as a `symbol` element that corresponds to the same name referenced
    via the class name for the CSS icon. Each `symbol` element includes the accessible
    `title` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the icons in the set is represented in the file `fa-solid.svg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the HTML file, things are slightly different, but all in all the pattern
    is much the same. We still link to Bootstrap for convenience. We no longer link
    to anything from Font Awesome in the `head`. We just have a small block of CSS
    to size the icons on our page. In a real-world example, you might do a bit more
    to style these, but for now this is enough to make it functional.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the document, we have a new pattern. Instead of the `button.btn
    > i.fa` pattern, we have `button.btn > svg > use`, with the use pointing to a
    specific symbol in the `fa-solid.svg` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, we have an Internet Explorer shaped wrinkle. Internet Explorer
    won''t allow you to `use` an element from an external document. The script *svg4everybody*
    polyfills that shortcoming and allows you to link to external SVG in IE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I mentioned how single-page apps can be treated differently. If you're working
    on a single-page application and want to use SVG icons, you can *inline *the symbols
    in your page and use them without any polyfill script in all modern browsers.
    With single-page apps you might be inlining things such as CSS already to save
    on HTTP requests, so adding a section of SVG inline in your document can be part
    of the same process.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going to detail how this might work from a build or page creation perspective,
    since there are many ways to do this (either as part of a build process or through
    a server-side templating system), but the output might look something such as
    the following code sample.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference is the definition of the symbols in the inline `svg`
    element at the top of the `body`. This adds complexity to the page, but saves
    on HTTP requests. So if you're building a single-page app and don't need to rely
    on caching a separate sprite file, this is going to be slightly faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, the references are directly to a document fragment of the
    same page, as opposed to linking to a separate file. This means we don''t need
    svg4everybody and Internet Explorer is happy to support `use`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with icon fonts, SVG sprites are fully customizable with CSS.  You've already
    seen an example where we changed the size and color of the icons in the preceding
    examples. As you read through the rest of the chapter, you'll encounter the many
    ways that you can manipulate SVG with CSS. It's quite a powerful combination!
  prefs: []
  type: TYPE_NORMAL
- en: Styling inline SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to focus on some of the many ways you can manipulate inline
    SVG elements with CSS. This section will not be exhaustive, but will cover many
    of the most common properties that you'll use when working with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'These fall into two classes of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: CSS properties that you're probably familiar with from working with CSS and
    HTML, and that will also work with SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS properties that are specific to SVG itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the familiar CSS properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using common CSS properties to manipulate SVGs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to focus on common CSS properties that work with SVG.
    With a couple of exceptions, most of the ones you'll actually pay attention to
    are related to text.
  prefs: []
  type: TYPE_NORMAL
- en: Basic font properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've worked with CSS for any length of time, you've likely manipulated
    the font face and style for an element. Those same properties are available for
    SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows four `text` elements. The first shows no styles
    applied to it and shows the default rendering of a `text` element in SVG. The
    next three elements are enhanced by CSS styles. The first class `text` adds the
    excellent Raleway typeface (available as a Google web font) and a new `font-size`
    (`2em`). The next two classes, `text-italic` and `text-bold`, build on that with
    the use of `font-style` and `font-weight` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, you can see the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd2446b2-db15-4324-8731-57c1a383cef4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case you were wondering, the shorthand properties also work as well. So
    simply defining a `font` property is supported, as the following code sample shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders in the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b27ab70-50bb-4be0-8422-6dc36a9e99e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Text properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next set of CSS properties supported in SVG all relate to blocks of text.
    So not just the individual glyph, as defined by the font properties, but the way
    that a larger grouping of glyphs fit together.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample illustrates several of them. The first class, `text`,
    again changes the `font-family` and `font-size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we have several other classes that show SVG support for text
    properties. The first illustrates support for `direction`, which allows you to
    define blocks of text that will work properly in languages that is read right-to-left
    (for example, Farsi, Arabic, and  Hebrew). This example simply anchors the English-based
    property definition to the right side of the box. Following that, we set the `letter-spacing`
    (tracking) property to a roomy `1em`, add an underline using `text-decoration`,
    and set the `word-spacing` to  `2em`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, that sample looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1833428-1f15-4a59-9831-75cc1435644c.png)'
  prefs: []
  type: TYPE_IMG
- en: Miscellaneous CSS properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final example in this section shows support for the cursor, display, and
    visibility properties. Of these, the most useful will be cursor. In this example,
    we change the `cursor` of a `rect` element to be the help cursor. Drag handles,
    resize handles, clickable pointers, and so on are all going to be common values
    used in interactive SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Following that we use the `display` and `visibility` properties to hide elements.
    While the differences between the two are obvious in HTML, there's less practical
    difference between the two properties in SVG. In HTML elements with `display:none`
    are not factored into the rendering of the document. They do not effect the overall
    flow of the document. They're in the DOM and are accessible from JavaScript but
    they're, in effect, ignored by the rendering engine. Elements set with `visibility:hidden`,
    on the other hand, remain part of the flow of the document. A 200-pixel high `div`
    will still take up 200 pixels. It will just do so invisibly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since most elements in SVG are positioned with `(x,y)` properties on a coordinate
    system, the differences between the two might be subtle. SVG elements with `visibility:hidden`
    normally don''t have any flow to interrupt (`tspan` would be one exception) so
    there''s no practical difference in layout. The one difference is in the way JavaScript
    events are handled. We''ll look at this in more depth later, both in the next
    section and in the later JavaScript chapters. But depending on how the `pointer-events` property
    is set, `visibility:hidden` elements might still interact with the user through
    JavaScript events. By default they will not, but it''s still possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, when hovering over the element with the mouse cursor
    this sample looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ebea4ad-6971-40de-91aa-5b93cc6f53b9.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're familiar with CSS, then you'll know there are other possible values
    for `display`. While I'm sure there are valid use cases for setting an SVG element
    to have another `display` value, it's not going to be something you'll commonly
    do, so I'm not going to talk about that here.
  prefs: []
  type: TYPE_NORMAL
- en: Using SVG-specific CSS properties to manipulate SVGs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will talk about the different CSS properties that you can use to
    work with SVG. Most of these properties have already been seen in previous chapters
    as attributes of specific SVG elements. You'll find that the combination of these
    representational attributes and the possibility of using CSS for sharing styles
    across SVG elements and SVG documents represents a powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: CSS properties will override presentation attributes, but will not override `style` attributes
    (which really just means that SVG + CSS behaves the way you would expect it to
    if you're familiar with the way that CSS specificity works ([https://css-tricks.com/specifics-on-css-specificity/](https://css-tricks.com/specifics-on-css-specificity/))).
  prefs: []
  type: TYPE_NORMAL
- en: Color and painting properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first example illustrates the ability to change the fill of an element.
    The `fill` property accepts any valid CSS color value ([https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)),
    as well as a link to a paint server (for example, a `pattern` defined in a `defs`
    section). `fill-opacity` changes the opacity of the fill itself (as the alpha
    value in an `rgba` color definition does) and not the whole element, as the CSS `opacity`
    property would.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define four classes. The first two, `red-fill` and `blue-fill`,
    define two different primary colors, red and blue, for fills. The third, `half-opacity`, defines
    `50%` opacity. The final one, `gradient`, defines the fill as a link to a paint
    server defined in the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'They''re then applied with the same `class` attribute you would use with a
    regular HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8ff0f54-974e-4d07-9667-36978aed3bc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Stroke properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very useful set of properties that are available to manipulate SVG from
    CSS are related to strokes. All of the stroke properties are available as CSS
    properties. Similar to the `fill` properties, these are going to come in very
    handy in creating consistent interfaces and visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows the usage of `stroke` and `stroke-width` as part of a base
    `stroke` class. This sets up a common stroke style so that we can apply the other
    stroke manipulation properties to our examples. Following that, we set the two
    dash properties, `stroke-dashoffset` and `stroke-dasharray`, and apply those to
    the first two `rect` elements using the `stroke-dasharray` and `stroke-dashoffset`
    classes. After that, we apply `stroke-linecap` to a `line` element using the `stroke-linecap-join`
    class.  Following that, we apply the `stroke-linejoin-round` class to a final
    `rect` element.
  prefs: []
  type: TYPE_NORMAL
- en: The `property/value` pairs match the same patterns you learned about in [Chapter
    2](fcc9b174-2f03-4b20-96be-5c62deae4581.xhtml), *Getting Started with Authoring
    SVG*, when you initially learned about these presentation attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these are available as CSS properties, which should help you to create
    consistent reusable stroke patterns for elements in your SVG document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/392f79ea-a0e4-4cd0-a038-2548045f2cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: Text properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will introduce some SVG-specific text properties. The first few
    examples deal with the baseline of text in SVG. Depending on the sort of work
    you're doing, you may never have to tweak a text element's baseline (the visual
    plane on which a line of text sits). But you *may* have to, especially if you're
    doing work with multi-lingual layouts or complicated text-based illustrations
    (like a logo). So it's worth introducing you to these properties. The baseline
    related properties are `alignment-baseline`, `dominant-baseline`, and `baseline-shift`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to those, this section will also look at the `text-anchor` property,
    which changes the anchor point of a `text` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a brief note about the baseline properties, there''s more to them than this,
    but the following description will give you enough of a foundation to get what''s
    going on in the code sample.  This is *probably* enough for you to get by using
    these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dominant-baseline` is used to adjust the baseline for a `text` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alignment-baseline` is used to adjust the baseline for a child element relative
    to the baseline of its parent `text` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseline-shift` is probably the most useful, providing the common *subscript*
    and *superscript* functionality by shifting the dominant baseline up or down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dominant-baseline` and `alignment-baseline` accept similar values. The two
    used here are *hanging*, which drops the text off the bottom of the text box,
    and *middle, *which centers the text vertically on the bottom of the text box.
    In this example `dominant-baseline` is applied to `text` elements with the two
    different values and `alignment-baseline` is applied to two different child `tspan`
    elements with the two different values.'
  prefs: []
  type: TYPE_NORMAL
- en: Following that, the common superscript and subscript patterns are created with
    the `super` and `sub` values of `baseline-shift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `text-anchor` property is illustrated by three different values
    applied to a text element centered in the middle of the viewport. `text-anchor` aligns
    text to different points in the text box: `start`, `middle`, and to `end` of the
    sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code sample that follows illustrates the usage of these baseline attributes
    as well as the usage of the `text-anchor` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, these effects are visible in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bf69f05-021a-4376-a4e3-29783c150d53.png)'
  prefs: []
  type: TYPE_IMG
- en: The darker bands show the initial textbox based on the *x*, *y* position of
    the text element. You can see how `hanging` and `middle` clearly shift the baseline
    of the font in reference to the *x*, *y* position.
  prefs: []
  type: TYPE_NORMAL
- en: The `text-anchor` example is illustrated with the addition of a line that indicates
    the `(x,y)` position of those text elements. They are placed at the center of
    the SVG element, which illustrates the effect of that property on a text element.
  prefs: []
  type: TYPE_NORMAL
- en: Compositing properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browser support for the compositing properties is pretty crummy at present.
    Microsoft doesn't have full support for the `clip` properties, at the time of
    writing, and mask property support is terrible across the board). That's unfortunate,
    as they'd present powerful options for defining and reusing clip-paths and masks.
  prefs: []
  type: TYPE_NORMAL
- en: The one working example I'm going to show illustrates how to define a `clip-path`
    using CSS. There are two variations. The first simply references a `clipPath`
    element by `id`. This is straightforward and works in modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The second example allows for greater separation of concerns. Instead of having
    to define an element with a path to use for clipping, you can provide polygon
    coordinates directly to CSS. `polygon`, `circle`, and `inset` are available values
    for this property. This syntax replaces the now deprecated `clip` property. If
    you're familiar with `clip`, you should note a couple of things. First, notice
    that there is no direct replacement for the `rect` value. Thankfully, as we show
    here, polygon is more than enough to replace `rect`. Secondly, `clip-path` does *not*require
    an element to be absolutely positioned (although, that's not a particular concern
    when using this property in SVG).
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for the polygon value is slightly different from the one used for
    a `polygon` element's `path` attribute. Instead of the commas being arbitrary
    and there just for legibility (as is the case with a d attribute of a path element),
    the pairs of points in this CSS property need to be comma-separated and require
    units. Otherwise, it works the same way as a `polygon` in SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example replicates the rectangle seen in the `clipPath` example by mapping
    out the points as a `polygon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91606b93-28e5-4e81-b24c-cc3c041b39d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As I mentioned, support for the `mask` properties is problematic, so I don''t
    have fully realized examples. There are three patterns that are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is similar to the `clip-path` property. You can define a `mask-image`
    property and pass a mask image into it via a `url`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is to use a portion of a linked image using a fragment identifier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The third, and most interesting option, would allow you to create masks in
    the property value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This technology isn't ready for prime time yet, but it's good to know what's
    on the horizon, especially as it would allow you to reuse masks defined in a central
    place using nothing but a CSS class.
  prefs: []
  type: TYPE_NORMAL
- en: Interactivity properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final CSS property we're going to look at is the `pointer-events` property.
    The `pointer-events` property indicates whether or not an SVG element can become
    the target of pointer events (inclusive of all inputs, including mouse, pen, or
    touch inputs).
  prefs: []
  type: TYPE_NORMAL
- en: The basic way to implement `pointer-events` is to turn them on or off. The following
    example shows this in action. This example will also include a little bit of JavaScript,
    so you can get a small head start on [Chapter 6](042dd9c1-7b3e-4b8e-a3f6-f719dd8ae77c.xhtml),
    *JavaScript and SVG*, where we'll dive headlong into manipulating SVG with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this sample, we have two `rect` elements. One is set with a class of `pointer-default`.
    This class has a single property, `pointer-events` set to `visiblePainted`. `visiblePainted`
    is the default value for `pointer-events` on an SVG element. It indicates that
    the entire visibly painted area of the element should accept mouse events. That
    means both the border and the fill.
  prefs: []
  type: TYPE_NORMAL
- en: The second `rect` has a class of `pointer-none`. The value of its single property,
    `pointer-events`, is `none`. This indicates that the element should not receive
    mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the page there's a small JavaScript block that shows the property
    in action. It also illustrates the sort of differences you might encounter when
    working with SVG and JavaScript. In it, we use some core **Document Object Model**
    (**DOM**) methods to attach a click event handler to each of the `rect` elements. 
    First, we use `document.querySelectorAll` to get a reference to all of the `rect`
    elements on the page. If you're unfamiliar with it, `querySelectorAll` can be
    thought of as a standardized, browser-native version of the famous jQuery interface.
    You pass in a CSS selector and it returns a static `nodeList` containing the results
    of your query.
  prefs: []
  type: TYPE_NORMAL
- en: We immediately loop through the array-like `nodeList` with the convenience method,
    `forEach`, and attach event handlers to each of the nodes. This event handler
    is designed to change the text of the adjacent `text` element whenever a square
    is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: If you're used to using `innerHTML` to set text content, you will notice the
    property `textContent` used here instead. Why? SVG doesn't have an `innerHTML`
    (*which makes sense, since it's not HTML*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this in the browser, you''ll see that only clicks on the `rect` with
    the default `pointer-events` value will change the text. The `rect` with `pointer-events`
    set to `none` doesn''t do anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustration shows the page after both `rect` elements were clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff426ca6-ed41-4900-b59c-42a1565b380d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table illustrates the other possible values for this property.
    They offer a lot of control in the way you can interact with SVG elements. Depending
    on how much precise interactivity you''re planning on doing, you might end up
    taking advantage of that precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| `visiblePainted` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over a  *painted area*. With this value
    the painted area includes the `stroke` (if it''s set to a value other than `none`)
    and the `fill` (if it''s set to a value other than `none`). |'
  prefs: []
  type: TYPE_TB
- en: '| `visibleFill` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over the interior (the `fill` area), whether
    or not the `fill` is set.  |'
  prefs: []
  type: TYPE_TB
- en: '| `visibleStroke` | The element can be targeted if the `visibility` property
    is set to `visible` and the pointer is over the perimeter (the `stroke` area),
    whether or not the `stroke` is set.  |'
  prefs: []
  type: TYPE_TB
- en: '| `visible` | The element can be targeted if the `visibility` property is set
    to `visible` and the pointer is over the interior or perimeter, whether or not
    the fill or stroke are set.  |'
  prefs: []
  type: TYPE_TB
- en: '| `painted` | The element can be targeted if the `visibility` property is set
    to `visible` and the pointer is over a  *painted area*. With this value the painted
    area includes the `stroke` (if it''s set to a value other than `none`) and the `fill` (if
    it''s set to a value other than `none`. The value of the `visibility` property
    isn''t taken into account. |'
  prefs: []
  type: TYPE_TB
- en: '| `fill` | The element can be targeted if the pointer is over the interior
    (the `fill` area), whether or not the fill is set. The value of the `visibility` property
    isn''t taken into account. |'
  prefs: []
  type: TYPE_TB
- en: '| `stroke` | The element can be targeted if the pointer is over the perimeter
    (the `stroke` area), whether or not the fill is set. The value of the `visibility` property
    isn''t taken into account. |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | The element can be targeted if the pointer is over the interior or
    perimeter of the element. The values of the stroke, `fill`, and `visibility` properties
    aren''t taken into account. |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | The element does not receive pointer events. |'
  prefs: []
  type: TYPE_TB
- en: Styles in standalone SVG images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While all the examples so far have been about inline SVG inside an HTML document,
    you can also use CSS within a standalone SVG image. The following SVG image shows
    using CSS to adjust the display of multiple SVG `text` elements. Interesting details
    include the **character data** (`<![CDATA[ ]]>`) block wrapping the styles contained
    in the `style` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4f236f0-0d64-4253-9d0d-4b2414e2bf44.png)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't dealt with a lot of XML (and it's not nearly as common as it
    once was, so that might be the case), `CDATA` is used to indicate to the XML parser
    that the section might contain characters that could be interpreted as XML, but
    shouldn't be.  JavaScript (with the prevalence of `<` and `>`) is the most common
    use case (and the one you'll know if you were building websites in 1999) but CSS
    could potentially fall into the same trap, so it's good to use it here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to note is the absence of external style sheets. If you're going
    to create an SVG image that will be imported as an `img src` or as a background
    image in CSS, it needs to be entirely self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, this works much like the HTML and CSS combination that''s
    likely familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendered in the browser, this image looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0bc4eea-e9b3-4b85-aec7-39a2cd30e670.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic CSS animations and transitions with SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting ways to work with SVG and CSS is with CSS *animations*
    and *transitions*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animations**: This allow you to assign animations to elements. These animations
    are defined as a series of changes to CSS properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitions**: This allow you to control the time it takes for CSS property
    changes to take effect. Instead of immediately changing, they *transition* between
    states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are a very powerful set of features and are an important conceptual and
    technical addition to your SVG toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: CSS animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS animations in SVG work the same way as they do in HTML, with the addition
    of the ability to use the SVG-specific properties.
  prefs: []
  type: TYPE_NORMAL
- en: Basic animation format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic pattern is as follows. SVG is simple. It''s a single `rect` element.
    The CSS has two interesting components. The first is the class `rect`, which references
    one property, `animation`. `animation`; this is a shorthand property that maps
    to a whole series of `animation-`properties. In this case, we''re setting two
    of them. The first of the mapped properties is `animation-name`, which references
    the animation defined in the `@keyframes` animation named `movement`. The second
    one we''re setting is the `animation-duration`, which we set to three seconds
    (`3s`). The `@keyframes` animation is where the magic happens. In it, we set two
    sets of keyframes. The first set marks the initial (`0%`) and final state (`100%`)
    of the animation with the same property, a CSS `transform` with a `translate`
    function set to `(0,0)`. This is the initial (and finishing) state. We''re going
    to animate against the `transform` property in the next keyframe. In it, set for
    the middle of the animation (`50%`), we translate the `rect` 400 pixels to the
    right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect is that the rectangle slowly moves from left to right and then back
    again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f592bd8f-a4fc-4746-a77f-feb2083f8cab.png)'
  prefs: []
  type: TYPE_IMG
- en: Animating a clip path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One relatively simple example (from a CSS perspective) of how powerful animations
    can be with SVG is animating a clip path. Using the `polygon` option we just learned
    about, you can animate between two (or more) shapes defined as a `clip-path`.
    If they have the *same number of points*, the browser will smoothly animate between
    positions defined as keyframes in your animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows just that. In this example we create a class `stars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stars` has one `animation` property. It references the `@keyframe stars` block
    defined later on in the style sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument you're already familiar with, `animation-duration`. Once
    again this is set to three seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third property is potentially new to you. The property value `infinite`
    maps to the `animation-iteration-count` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`animation-iteration-count` accepts either a number indicating the specific
    number of times an animation should run or the keyword `infinite`, which indicates
    that the animation should play forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@keyframes` follow the same pattern as the previous animation. We have
    equivalent starting and finishing states (0% and 100%). These are defined as a
    polygon `clip-path` that illustrates a star. The mid-point of the animation (`50%`),
    redefines the polygon as a square. Since the number of points needs to be equivalent
    between the states of an animation, this means that we''re defining many more
    than four points to animate between these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following time-lapse screenshot shows how the animation unfolds over the
    three seconds that it runs. Be sure to run it in a supporting browser to see how
    interesting this effect can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19aaa7d0-e34e-42d7-9c8a-ba4621dccb08.png)'
  prefs: []
  type: TYPE_IMG
- en: Animating multiple properties and assigning multiple animations to an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two more things to note about animations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can animate multiple CSS properties at one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also apply multiple animations to the same element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code sample shows how these two features work. There are three
    important sections. The first is the single class,  `rect`. It has *two* comma-separated
    arguments for the `animation` property, the animations `box` and `change-color-and-fade`. 
    `box` defines two square `clip-path` properties, one `50` pixels from the edge
    of the rectangle, the other `10` pixels in from the edge. `change-color-and-fade` changes
    the background color from red to blue and the opacity from `.5` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run in the browser, the animation goes through the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e162bfce-9e69-44cc-bddc-08569c2627f2.png)'
  prefs: []
  type: TYPE_IMG
- en: CSS transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final CSS property we're going to look at in this chapter is the CSS `transition`
    property. `transition` allows you to define the way that the browser animates
    between changes in property values. Instead of the properties changing immediately,
    they can transition more smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how this works. In it we have a small, single-value
    bar chart that fills up when the user hovers over it, showing imaginary progress
    against a goal.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS is full of classes to define the text. You'll notice many properties
    you've learned about throughout this chapter. In addition to those, which you
    should have at least some familiarity with after working with them in this chapter,
    there are classes that define the bar chart, one of which is more interesting
    than the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, `the-bar`, defines the outline of the bar chart. The second, `fill-the-bar`, 
    defines the *progress* part of the bar. It has no stroke and a green fill. The
    interesting part for our purposes is the `transition` property. `transition` is
    a shorthand property for a group of related `transition-`properties. In this case
    we''re using `transition-property` (`transform`) and `transition-duration` (`3s`).
    This indicates that the browser should watch for changes to the `transform` property
    on this element and transition the changes to that property over three seconds.
    Also in this class we define a `scaleY transform` with a value of `1` and anchor
    the `transform` to the `bottom` of the element with `transform-origin`. We need
    a baseline `scaleY` so the browser has a matching property to animate against. `fill-the-bar:hover`
    changes the scale to `7.5` which, given the way this is configured, fills up the
    bar to `75%` of the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run in the browser; the transition grows slowly until it fills the appropriate
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da3c849a-47d6-4b3b-9915-14ddb28b1bfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned a lot in this chapter. CSS is one of the linchpin technologies
    for making fast, maintainable modern websites and applications, and understanding
    the intersection between SVG and CSS is important.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter started with details about the common use case of using SVG for
    CSS background images, including interesting details about using SVG data URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, you learned about SVG sprites and icon sets and how and why
    they can be used in place of the common font icon sets so popular on the web today.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, you learned about styling inline SVG, including detailed ways
    to manipulate the font and the flow of lines of text. Following that, you learned
    about many SVG-specific properties including those controlling the `fill`, `stroke`,
    and text of elements. After that, you learned about some cutting edge compositing
    properties, such as `clip-path` and `mask-image`, which are powerful, even if
    browser support isn't fully there yet.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you learned about using CSS to improve consistency and ease of authoring
    in standalone SVG images.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about basic CSS animations and transitions with SVG, a
    powerful pattern to add interactivity and movement to your sites and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll take all that we've learned about getting SVG onto the page and
    making sure it looks right, and we'll add JavaScript to the mix, so we can start
    to interact with SVG in increasingly interesting ways.
  prefs: []
  type: TYPE_NORMAL
