- en: Chapter 12. Improving Web Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering `$_POST` data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating `$_POST` data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding the PHP session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing forms with a token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a secure password generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding forms with a CAPTCHA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting/decrypting without `mcrypt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will show you how to set up a simple yet effective mechanism
    for filtering and validating a block of post data. Then, we will cover how to
    protect your PHP sessions from potential session hijacking and other forms of
    attack. The next recipe shows how to protect forms from **Cross Site Request Forgery**
    (**CSRF**) attacks using a randomly generated token. The recipe on password generation
    shows you how to incorporate PHP 7 true randomization to generate secure passwords.
    We then show you two forms of **CAPTCHA**: one that is text based, the other using
    a distorted image. Finally, there is a recipe that covers strong encryption without
    using the discredited and soon-to-be-deprecated `mcrypt` extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering $_POST data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of filtering data can encompass any or all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing unwanted characters (that is, removing `<script>` tags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing transformations on the data (that is, converting a quote to `&quot;`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting or decrypting the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption is covered in the last recipe of this chapter. Otherwise, we will
    present a basic mechanism that can be used to filter `$_POST` data arriving following
    form submission.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you need to have an awareness of the data that will be present
    in `$_POST`. Also, perhaps more importantly, you will need to be aware of the
    restrictions imposed by the database table in which the form data will presumably
    be stored. As an example, have a look at the database structure for the `prospects`
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you have completed an analysis of the data to be posted and stored, you
    can determine what type of filtering is to occur, and which PHP functions will
    serve this purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an example, if you need to get rid of leading and trailing white space, which
    is completely possible from user supplied form data, you can use the PHP `trim()`
    function. All of the character data has length limits according to the database
    structure. Accordingly, you might consider using `substr()` to ensure the length
    is not exceeded. If you wanted to remove non-alphabetical characters, you might
    consider using `preg_replace()` with the appropriate pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now group the set of desired PHP functions into a single array of callbacks.
    Here is an example based on the filtering needs for the form data that will eventually
    be stored in the `prospects` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define an array that matches the field names expected in `$_POST`.
    In this array, we specify the key in the `$filter` array, along with any parameters.
    Note the first key, `*`. We will use that as a wildcard to be applied to all fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We then loop through the data set (that is, coming from `$_POST`) and apply
    the callbacks in turn. We first run all callbacks assigned to the wildcard (`*`)
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to implement a wildcard filter to avoid redundant settings.
    In the preceding example, we wish to apply filters that represent the PHP functions
    `strip_tags()` and `trim()` for every item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we run through all callbacks assigned to a particular data field. When
    we''re done, all values in `$data` will be filtered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the code shown in steps 4 through 6 into a file called `chap_12_post_data_filtering_basic.php`.
    You will also need to define an array to simulate data that would be present in
    `$_POST`. In this case, you could define two arrays, one with *good* data, and
    one with *bad* data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you will need to loop through the filter assignments, presenting the
    good and bad data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the output might appear for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the names were truncated and tags were removed. You will also note
    that although the e-mail address was filtered, it is still not a valid address.
    It's important to note that for proper treatment of data, it might be necessary
    to *validate* as well as to filter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building
    Scalable Websites*, the recipe entitled *Chaining $_POST filters*, discusses how
    to incorporate the basic filtering concepts covered here into a comprehensive
    filter chaining mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Validating $_POST data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary difference between filtering and validation is that the latter does
    not alter the original data. Another difference is in intent. The purpose of validation
    is to confirm that the data matches certain criteria established according to
    the needs of your customer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic validation mechanism we will present here is identical to that shown
    in the preceding recipe. As with filtering, it is vital to have an idea of the
    nature of the data to be validated, how it fits your customer's requirements,
    and also whether it matches the criteria enforced by the database. For example,
    if in the database, the maximum width of the column is 128, the validation callback
    could use `strlen()` to confirm that the length of the data submitted is less
    than or equal to 128 characters. Likewise, you could use `ctype_alnum()` to confirm
    that the data only contains letters and numbers, as appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another consideration for validation is to present an appropriate validation
    failure message. The validation process, in a certain sense, is also a *confirmation*
    process, where somebody presumably will review the validation to confirm success
    or failure. If the validation fails, that person will need to know the reason
    why.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this illustration, we will again focus on the `prospects` table. We can
    now group the set of desired PHP functions into a single array of callbacks. Here
    is an example based on the validation needs for the form data, which will eventually
    be stored in the `prospects` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice, for the alpha and alnum callbacks, we allow for whitespace by first
    removing it using `str_replace()`. We can then call `ctype_alpha()` or `ctype_alnum()`,
    which will determine whether any disallowed characters are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define an array of assignments that matches the field names expected
    in `$_POST`. In this array, we specify the key in the `$validator` array, along
    with any parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use nested `foreach()` loops to iterate through the block of data one
    field at a time. For each field, we loop through the callbacks assigned to that
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of echoing the output directly, as shown, you might log the validation
    success/failure to be presented to the reviewer at a later time. Also, as shown
    in [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building Scalable
    Websites*, you can work the validation mechanism into the form, displaying validation
    messages next to their matching form elements.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the code shown in steps 3 through 5 into a file called `chap_12_post_data_validation_basic.php`.
    You will also need to define an array of data that simulates data that would be
    present in `$_POST`. In this case, you use the two arrays mentioned in the preceding
    recipe, one with *good* data, and one with *bad* data. The final output should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Building Scalable Websites"), *Building
    Scalable Websites*, the recipe entitled *Chaining $_POST validators* discusses
    how to incorporate the basic validation concepts covered here into a comprehensive
    filter chaining mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding the PHP session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP session mechanism is quite simple. Once the session is started using
    `session_start()` or the `php.ini session.autostart` setting, the PHP engine generates
    a unique token that is, by default, conveyed to the user by way of a cookie. On
    subsequent requests, while the session is still considered active, the user's
    browser (or equivalent) presents the session identifier, again usually by way
    of a cookie, for inspection. The PHP engine then uses this identifier to locate
    the appropriate file on the server, populating `$_SESSION` with the stored information.
    There are tremendous security concerns when the session identifier is the sole
    means of identifying a returning website visitor. In this recipe, we will present
    several techniques that will help you to safeguard your sessions, which, in turn,
    will vastly improve the overall security of the website.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, it''s important to recognize how using the session as the sole
    means of authentication can be dangerous. Imagine for a moment that when a valid
    user logs in to your website, that you set a `loggedIn` flag in `$_SESSION`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In your program logic, you allow the user to see sensitive information if `$_SESSION[''isLoggedIn'']`
    is set to `TRUE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If an attacker were to obtain the session identifier, for example, by means
    of a successfully executed **Cross-site scripting** (**XSS**) attack, all he/she
    would need to do would be to set the value of the `PHPSESSID` cookie to the illegally
    obtained one, and they are now viewed by your application as a valid user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One quick and easy way to narrow the window of time during which the `PHPSESSID`
    is valid is to use `session_regenerate_id()`. This very simple command generates
    a new session identifier, invalidates the old one, maintains session data intact,
    and has a minimal impact on performance. This command can only be executed after
    the session has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another often overlooked technique is to ensure that web visitors have a logout
    option. It is important, however, to not only destroy the session using `session_destroy()`,
    but also to unset `$_SESSION` data and to expire the session cookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another easy technique that can be used to prevent session hijacking is to
    develop a finger-print or thumb-print of the website visitor. One way to implement
    this technique is to collect information unique to the website visitor over and
    above the session identifier. Such information includes the user agent (that is,
    the browser), languages accepted, and remote IP address. You can derive a simple
    hash from this information, and store the hash on the server in a separate file.
    The next time the user visits the website, if you have determined they are logged
    in based on session information, you can then perform a secondary verification
    by matching finger-prints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using `md5()` as it's a fast hashing algorithm and is well suited for
    internal usage. It is *not recommended* to use `md5()` for any external use as
    it is subject to brute-force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how a session is vulnerable, code a simple login script that
    sets a `$_SESSION[`''`isLoggedIn`''`] flag` upon successful login. You could call
    the file `chap_12_session_hijack.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add code that displays a simple login form. To test for session
    vulnerability, follow this procedure using the `chap_12_session_hijack.php` file
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: Change to the directory containing the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `php -S localhost:8080` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using one browser, open the URL `http://localhost:8080/<filename>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login as user `test` with a password as `password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to see **You Can Now See Super Secret Information!!!**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refresh the page: each time, you should see a new session identifier.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the value of the `PHPSESSID` cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open another browser to the same web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the cookie sent by the browser by copying the value of `PHPSESSID`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For illustration, we are also showing the value of `$_COOKIE` and `$_SESSION`,
    shown in the following screenshot using the Vivaldi browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then copy the value of `PHPSESSID`, open a Firefox browser, and use a tool
    called Tamper Data to modify the value of the cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the next screenshot that we are now an authenticated user without
    entering the username or password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now implement the changes discussed in the preceding steps. Copy the
    file created previously to `chap_12_session_protected.php`. Now go ahead and regenerate
    the session ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize variables and determine the logged in status (as before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a session thumb-print using the remote address, user agent, and
    language settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the login is successful, we store thumb-print info and login status in the
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check for the logout option and implement a proper logout procedure:
    unset `$_SESSION` variables, invalidate the session, and expire the cookie. You
    can also remove the thumb-print file and implement a redirect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if the operation is not login or logout, you can check to see whether
    the user is considered logged in, and if the thumb-print doesn''t match, the session
    is considered invalid, and the appropriate action is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the same procedure as mentioned previously using the new `chap_12_session_protected.php`
    file. The first thing you will notice is that the session is now considered invalid.
    The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this is that the thumb-print does not match as you are now using
    a different browser. Likewise, if you refresh the page of the first browser, the
    session identifier is regenerated, making any previously copied identifier obsolete.
    Finally, the logout button will completely clear session information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an excellent overview of website vulnerabilities, please refer to the article
    present at [https://www.owasp.org/index.php/Category:Vulnerability](https://www.owasp.org/index.php/Category:Vulnerability).
    For information on session hijacking, refer to [https://www.owasp.org/index.php/Session_hijacking_attack](https://www.owasp.org/index.php/Session_hijacking_attack).
  prefs: []
  type: TYPE_NORMAL
- en: Securing forms with a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe presents another very simple technique that will safeguard your
    forms against **Cross Site Request Forgery** (**CSRF**) attacks. Simply put, a
    CSRF attack is possible when, possibly using other techniques, an attacker is
    able to infect a web page on your website. In most cases, the infected page will
    then start issuing requests (that is, using JavaScript to purchase items, or make
    settings changes) using the credentials of a valid, logged-in user. It's extremely
    difficult for your application to detect such activity. One measure that can easily
    be taken is to generate a random token that is included in every form to be submitted.
    Since the infected page will not have access to the token, nor have the ability
    to generate one that matches, form validation will fail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, to demonstrate the problem, we create a web page that simulates an infected
    page that generates a request to post an entry to the database. For this illustration,
    we will call the file `chap_12_form_csrf_test_unprotected.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a script called `chap_12_form_unprotected.php` that responds
    to the form posting. As with other calling programs in this book, we set up autoloading
    and use the `Application\Database\Connection` class covered in [Chapter 5](ch05.html
    "Chapter 5. Interacting with a Database"), *Interacting with a Database*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see the process button has been pressed, and even implement
    a filtering mechanism, as covered in the *Filtering $_POST data* recipe in this
    chapter. This is to prove that a CSRF attack is easily able to bypass filters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we insert the filtered data into the database using a prepared statement.
    We then redirect to another script, called `chap_12_form_view_results.php`, which
    simply dumps the contents of the `visitors` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The result, of course, is that the attack is allowed, despite filtering and
    the use of prepared statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implementing the form protection token is actually quite easy! First of all,
    you need to generate the token and store it in the session. We take advantage
    of the new `random_bytes()` PHP 7 function to generate a truly random token, one
    which will be difficult, if not impossible, for an attacker to match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output of `random_bytes()` is binary. We use `base64_encode()` to convert
    it into a usable string. We then further process it using `urlencode()` so that
    it is properly rendered in an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we render the form, we then present the token as a hidden field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then copy and alter the `chap_12_form_unprotected.php` script mentioned
    previously, adding logic to first check to see whether the token matches the one
    stored in the session. Note that we unset the current token to make it invalid
    for future use. We call the new script `chap_12_form_protected_with_token.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test how an infected web page might launch a CSRF attack, create the following
    files, as shown earlier in the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chap_12_form_csrf_test_unprotected.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chap_12_form_unprotected.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then define a file called `chap_12_form_view_results.php`, which dumps
    the `visitors` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From a browser, launch `chap_12_form_csrf_test_unprotected.html`. Here is how
    the output might appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the attack was successful despite filtering and the use of prepared
    statements!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, copy the `chap_12_form_unprotected.php` file to `chap_12_form_protected.php`.
    Make the change indicated in step 8 in the recipe. You will also need to alter
    the test HTML file, copying `chap_12_form_csrf_test_unprotected.html` to `chap_12_form_csrf_test_protected.html`.
    Change the value for the action parameter in the `FORM` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the new HTML file from a browser, it calls `chap_12_form_protected.php`,
    which looks for a token that does not exist. Here is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, go ahead and define a file called `chap_12_form_protected.php` that
    generates a token and displays it as a hidden element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we display and submit data from the form, the token is validated and the
    data insertion is allowed to continue, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on CSFR attacks, please refer to [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  prefs: []
  type: TYPE_NORMAL
- en: Building a secure password generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common misconception is that the only way attackers crack hashed passwords
    is by using **brute force attacks** and **rainbow tables**. Although this is often
    the first pass in an attack sequence, attackers will use much more sophisticated
    attacks on a second, third, or fourth pass. Other attacks include *combination*,
    *dictionary*, *mask*, and rules-based. Dictionary attacks use a database of words
    literally from the dictionary to guess passwords. Combination is where dictionary
    words are combined. Mask attacks are similar to brute force, but more selective,
    thus cutting down the time to crack. Rules-based attacks will detect things such
    as substituting the number 0 for the letter o.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that by simply increasing the length of the password beyond
    the magic length of six characters exponentially increases the time to crack the
    hashed password. Other factors, such as interspersing uppercase with lowercase
    letters randomly, random digits, and special characters, will also have an exponential
    impact on the time to crack. At the end of the day, we need to bear in mind that
    a human being will eventually need to enter the passwords created, which means
    that need to be at least marginally memorable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords should be stored as a hash, and never as plain text. MD5 and SHA*
    are no longer considered secure (although SHA* is much better than MD5). Using
    a utility such as `oclHashcat`, an attacker can generate an average of 55 billion
    attempts per second on a password hashed using MD5 that has been made available
    through an exploit (that is, a successful SQL injection attack).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Security\PassGen` class that will hold the
    methods needed for password generation. We also define certain class constants
    and properties that will be used as part of the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define low-level methods that will be used for password generation.
    As the names suggest, `digits()` produces random digits, and `special()` produces
    a single character from the `SPECIAL_CHARS` class constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we are frequently using the new PHP 7 function `random_int()` in
    this example. Although marginally slower, this method offers true **Cryptographically
    Secure Pseudo Random Number Generator** (**CSPRNG**) capabilities compared to
    the more dated `rand()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the tricky part: generating a hard-to-guess word. This is where the
    `$wordSource` constructor parameter comes into play. It is an array of websites
    from which our word base will be derived. Accordingly, we need a method that will
    pull a unique list of words from the sources indicated, and store the results
    in a file. We accept the `$wordSource` array as an argument, and loop through
    each URL. We use `md5()` to produce a hash of the website name, which is then
    built into a filename. The newly produced filename is then stored in `$sourceList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file doesn''t exist, or is zero-byte, we process the contents. If the
    source is HTML, we only accept content inside the `<body>` tag. We then use `str_word_count()`
    to pull a list of words out of the string, also employing `strip_tags()` to remove
    any markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then remove any words that are too short, and use `array_unique()` to get
    rid of duplicates. The final result is stored in a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a method that *flips* random letters in the word to uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to define a method that chooses a word from our source.
    We choose a word source at random, and use the `file()` function to read from
    the appropriate cached file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So that we do not always produce passwords of the same pattern, we define a
    method that allows us to place the various components of a password in different
    positions in the final password string. The algorithms are defined as an array
    of method calls available within this class. So, for example, an algorithm of
    `[''word'', ''digits'', ''word'', ''special'']` might end up looking like `hElLo123aUTo!`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor accepts the word source array, minimum word length, and location
    of the cache directory. It then processes the source files and initializes the
    algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are able to define the method that actually generates the password.
    All it needs to do is to select an algorithm at random, and then loop through,
    calling the appropriate methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you will need to place the code described in the previous recipe into
    a file called `PassGen.php` in the `Application\Security` folder. Now you can
    create a calling program called `chap_12_password_generate.php` that sets up autoloading,
    uses `PassGen`, and defines the location of the cache directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to define an array of websites that will be used as a source
    for the word-base to be used in password generation. In this illustration, we
    will choose from the Project Gutenberg texts *Ulysses* (J. Joyce), *War and Peace*
    (L. Tolstoy), and *Pride and Prejudice* (J. Austen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the `PassGen` instance, and run `generate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few example passwords produced by `PassGen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An excellent article on how an attacker would approach cracking a password
    can be viewed at [http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/](http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/).
    To find out more about brute force attacks you can refer to [https://www.owasp.org/index.php/Brute_force_attack](https://www.owasp.org/index.php/Brute_force_attack).
    For information on `oclHashcat`, see this page: [http://hashcat.net/oclhashcat/](http://hashcat.net/oclhashcat/).'
  prefs: []
  type: TYPE_NORMAL
- en: Safeguarding forms with a CAPTCHA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CAPTCHA** is actually an acronym for **Completely Automated Public Turing
    Test to Tell Computers and Humans Apart**. The technique is similar to the one
    presented in the preceding recipe, *Securing forms with a token*. The difference
    is that instead of storing the token in a hidden form input field, the token is
    rendered into a graphic that is difficult for an automated attack system to decipher.
    Also, the intent of a CAPTCHA is slightly different from a form token: it is designed
    to confirm that the web visitor is a human being, and not an automated system.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several approaches to CAPTCHA: presenting a question based on knowledge
    only a human would possess, text tricks, and a graphics image that needs to be
    interpreted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image approach presents web visitors with an image with heavily distorted
    letters and/or numbers. This approach can be complicated, however, in that it
    relies on the GD extension, which may not be available on all servers. The GD
    extension can be difficult to compile, and has heavy dependencies on various libraries
    that must be present on the host server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The text approach is to present a series of letters and/or numbers, and give
    the web visitor a simple instruction such as *please type this backwards*. Another
    variation is to use ASCII "art" to form characters that a human web visitor is
    able to interpret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you might have a question/answer approach with questions such as *The
    head is attached to the body by what body part*, and have answers such as *Arm*,
    *Leg*, and *Neck*. The downside to this approach is that an automated attack system
    will have a 1 in 3 chance of passing the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a text CAPTCHA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this illustration, we will start with the text approach, and follow with
    the image approach. In either case, we first need to define a class that generates
    the phrase to be presented (and decoded by the web visitor). For this purpose,
    we define an `Application\Captcha\Phrase` class. We also define properties and
    class constants used in the phrase generation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor, as you would expect, accepts values for the various properties,
    with defaults assigned so that an instance can be created without having to specify
    any parameters. The `$include*` flags are used to signal which character sets
    will be present in the base string from which the phrase will be generated. For
    example, if you wish to only have numbers, `$includeUpper` and `$includeLower`
    would both be set to `FALSE`. `$otherChars` is provided for extra flexibility.
    Finally, `$suppressChars` represents an array of characters that will be removed
    from the base string. The default removes uppercase `O` and lowercase `l`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We then define a series of getters and setters, one for each property. Please
    note that we only show the first two in order to conserve space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We next need to define a method that initializes the base string. This consists
    of a series of simple if statements that check the various `$include*` flags and
    append to the base string as appropriate. At the end, we use `str_replace()` to
    remove the characters represented in `$suppressChars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of letters that can be confused with numbers (that is, the letter `O`
    can be confused with the number `0`, and a lowercase `l` can be confused with
    the number `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to define the core method that generates the random phrase
    that the CAPTCHA presents to website visitors. We set up a simple `for()` loop,
    and use the new PHP 7 `random_int()` function to jump around in the base string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we turn our attention away from the phrase and onto the class that will
    produce a text CAPTCHA. For this purpose, we first define an interface so that,
    in the future, we can create additional CAPTCHA classes that all make use of `Application\Captcha\Phrase`.
    Note that `getImage()` will return text, text art, or an actual image, depending
    on which class we decide to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For a text CAPTCHA, we define a `Application\Captcha\Reverse` class. The reason
    for this name is that this class produces not just text, but text in reverse.
    The `__construct()` method builds an instance of `Phrase`. Note that `getImage()`
    returns the phrase in reverse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Generating an image CAPTCHA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The image approach, as you can well imagine, is much more complicated. The phrase
    generation process is the same. The main difference is that not only do we need
    to imprint the phrase on a graphic, but we also need to distort each letter differently
    and introduce noise in the form of random dots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define a `Application\Captcha\Image` class that implements `CaptchaInterface`.
    The class constants and properties include not only those needed for phrase generation,
    but what is needed for image generation as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor needs to accept all the arguments required for phrase generation,
    as described in the previous steps. In addition, we need to accept arguments required
    for image generation. The two mandatory parameters are `$imageDir` and `$imageUrl`.
    The first is where the graphic will be written. The second is the base URL, after
    which we will append the generated filename. `$imageFont` is provided in case
    we want to provide TrueType fonts, which will produce a more secure CAPTCHA. Otherwise,
    we''re limited to the default fonts which, to quote a line in a famous movie,
    *ain''t a pretty sight*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, still in the constructor, we check to see whether the `imagecreatetruecolor`
    function exists. If this comes back as `FALSE`, we know the GD extension is not
    available. Otherwise, we assign parameters to properties, generate the phrase,
    remove old images, and write out the CAPTCHA graphic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of removing old images is extremely important; otherwise we will
    end up with a directory filled with expired CAPTCHA images! We use the `DirectoryIterator`
    class to scan the designated directory and check the access time. We calculate
    an old image file as one that is the current time minus the value specified by
    `IMAGE_EXP_TIME`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to move on to the main show. First, we split the `$imageRGB`
    array into `$red`, `$green`, and `$blue`. We use the core `imagecreatetruecolor()`
    function to generate the base graphic with the width and height specified. We
    use the RGB values to colorize the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define *x* and *y* margins based on image width and height. We then
    initialize variables to be used to write the phrase onto the graphic. We then
    loop a number of times that matches the length of the phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If `$imageFont` is specified, we are able to write each character with a different
    size and angle. We also need to adjust the *x* axis (that is, horizontal) value
    according to the size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we''re stuck with the default fonts. We use the largest size of
    `5`, as smaller sizes are unreadable. We provide a low level of distortion by
    alternating between `imagechar()`, which writes the image normally, and `imagecharup()`,
    which writes it sideways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add noise in the form of random dots. This is necessary in
    order to make the image harder for automated systems to detect. It is also recommended
    that you add code to draw a few lines as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a random image filename using our old friend `md5()` with the
    date and a random number from `0` to `9999` as arguments. Note that we can safely
    use `md5()` as we are not trying to hide any secret information; we''re merely
    interested in generating a unique filename quickly. We wipe out the image object
    as well to conserve memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire construct is in a `try/catch` block. If an error or exception is
    thrown, we log the message and take the appropriate action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the methods required by the interface. Note that `getImage()`
    returns an HTML `<img>` tag, which can then be immediately displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Be sure to define the classes discussed in this recipe, summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Subsection | The steps it appears in |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Captcha\Phrase` | Generating a text CAPTCHA | 1 - 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Captcha\CaptchaInterface` |   | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Captcha\Reverse` |   | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\Captcha\Image` | Generating an image CAPTCHA | 2 - 13 |'
  prefs: []
  type: TYPE_TB
- en: 'Next, define a calling program called `chap_12_captcha_text.php` that implements
    a text CAPTCHA. You first need to set up autoloading and use the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, be sure to start the session. You would use appropriate measures
    to protect the session as well. To conserve space, we only show one simple measure,
    `session_regenerate_id()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can define a function that creates the CAPTCHA; retrieves the phrase,
    label, and image (in this case, reverse text); and stores the value in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is a good time to initialize variables and determine the `loggedIn` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then check to see whether the login button has been pressed. If so,
    check to see whether the CAPTCHA phrase has been entered. If not, initialize a
    message informing the user they need to enter the CAPTCHA phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If the CAPTCHA phrase is present, check to see whether it matches what is stored
    in the session. If it doesn''t match, proceed as if the form is invalid. Otherwise,
    process the login as you would have otherwise. For the purposes of this illustration,
    you can simulate a login by using hard-coded values for the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also want to add code for a logout option, as described in the *Safeguarding
    the PHP session* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run `setCaptcha()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, don''t forget the view logic, which, in this example, presents a basic
    login form. Inside the form tag, you''ll need to add view logic to display the
    CAPTCHA and label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate how to use the image CAPTCHA, copy the code from `chap_12_captcha_text.php`
    to `cha_12_captcha_image.php`. We define constants that represent the location
    of the directory in which we will write the CAPTCHA images. (Be sure to create
    this directory!) Otherwise, the autoloading and use statement structure is similar.
    Note that we also define a TrueType font. Differences are noted in **bold**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important!**'
  prefs: []
  type: TYPE_NORMAL
- en: Fonts can potentially be protected under copyright, trademark, patent, or other
    intellectual property laws. If you use a font for which you are not licensed,
    you and your customer could be held liable in court! Use an open source font,
    or one that is available on the web server for which you have a valid license.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in the `setCaptcha()` function, we use the `Image` class instead
    of `Reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable initialization is the same as the previous script, and login processing
    is identical to the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Even the view logic remains the same, as we are using `getImage()`, which,
    in the case of the image CAPTCHA, returns directly usable HTML. Here is the output
    using a TrueType font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not inclined to use the preceding code to generate your own in-house
    CAPTCHA, there are plenty of libraries available. Most popular frameworks have
    this ability. Zend Framework, for example, has its Zend\Captcha component class.
    There is also reCAPTCHA, which is generally invoked as a service in which your
    application makes a call to an external website that generates the CAPTCHA and
    token for you. A good place to start looking is [http://www.captcha.net/](http://www.captcha.net/)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the protection of fonts as intellectual property, refer
    to the article present at [https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces](https://en.wikipedia.org/wiki/Intellectual_property_protection_of_typefaces).
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting/decrypting without mcrypt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a little-known fact among members of the general PHP community that the
    `mcrypt` extension, the core of most PHP-based encryption considered secure, is
    anything but secure. One of the biggest issues, from a security perspective, is
    that the `mcrypt` extension requires advanced knowledge of cryptography to successfully
    operate, which few programmers have. This leads to gross misuse and ultimately
    problems such as a 1 in 256 chance of data corruption. Not good odds. Furthermore,
    developer support for `libmcrypt`, the core library upon which the `mcrypt` extension
    is based, was *abandoned* in 2007, which means the code base is out-of-date, bug-ridden,
    and has no mechanism to apply patches. Accordingly, it is extremely important
    to understand how to perform strong encryption/decryption *without* using `mcrypt`!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution to the problem posed previously, in case you're wondering, is to
    use `openssl`. This extension is well maintained, and has modern and very strong
    encryption/decryption capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use any `openssl*` functions, the `openssl` PHP extension must be
    compiled and enabled! In addition, you will need to install the latest OpenSSL
    package on your web server.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need to determine which cipher methods are available on your
    installation. For this purpose, you can use the `openssl_get_cipher_methods()`
    command. Examples will include algorithms based on **Advanced** **Encryption Standard**
    (**AES**), **BlowFish** (**BF**), **CAMELLIA**, **CAST5**, **Data** **Encryption
    Standard** (**DES**), **Rivest** **Cipher** (**RC**) (also affectionately known
    as **Ron's** **Code**), and **SEED**. You will note that this method shows cipher
    methods duplicated in upper and lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will need to figure out which method is most appropriate for your
    needs. Here is a table that gives a quick summary of the various methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Method | Published | Key size (bits) | Key block size (bytes) | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `camellia` | 2000 | 128, 192, 256 | 16 | Developed by Mitsubishi and NTT
    |'
  prefs: []
  type: TYPE_TB
- en: '| `aes` | 1998 | 128, 192, 256 | 16 | Developed by Joan Daemen and Vincent
    Rijmen. Originally submitted as Rijndael |'
  prefs: []
  type: TYPE_TB
- en: '| `seed` | 1998 | 128 | 16 | Developed by the Korea Information Security Agency
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cast5` | 1996 | 40 to 128 | 8 | Developed by Carlisle Adams and Stafford
    Tavares |'
  prefs: []
  type: TYPE_TB
- en: '| `bf` | 1993 | 1 to 448 | 8 | Designed by Bruce Schneier |'
  prefs: []
  type: TYPE_TB
- en: '| `rc2` | 1987 | 8 to 1,024defaults to 64 | 8 | Designed by Ron Rivest (one
    of the core founders of RSA) |'
  prefs: []
  type: TYPE_TB
- en: '| `des` | 1977 | 56 (+8 parity bits) | 8 | Developed by IBM, based on work
    done by Horst Feistel |'
  prefs: []
  type: TYPE_TB
- en: 'Another consideration is what your preferred block cipher **mode of operation
    is**. Common choices are summarized in this table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Mode | Stands For | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ECB | Electronic Code Book | Does not require **initialization vector** (**IV**);
    supports parallelization for both encryption and decryption; simple and fast;
    does not hide data patterns; not recommended!!! |'
  prefs: []
  type: TYPE_TB
- en: '| CBC | Cipher Block Chaining | Requires IV; subsequent blocks, even if identical,
    are XOR''ed with previous block, resulting in better overall encryption; if the
    IVs are predictable, the first block can be decoded, leaving remaining message
    exposed; message must be padded to a multiple of the cipher block size; supports
    parallelization only for decryption |'
  prefs: []
  type: TYPE_TB
- en: '| CFB | Cipher Feedback | Close relative of CBC, except that encryption is
    performed in reverse |'
  prefs: []
  type: TYPE_TB
- en: '| OFB | Output Feedback | Very symmetrical: encrypt and decrypt are the same;
    does not supports parallelization at all |'
  prefs: []
  type: TYPE_TB
- en: '| CTR | Counter | Similar in operation to OFB; supports parallelization for
    both encryption and decryption |'
  prefs: []
  type: TYPE_TB
- en: '| CCM | Counter with CBC-MAC | Derivative of CTR; only designed for block length
    of 128 bits; provides authentication and confidentiality; **CBC-MAC** stands for
    **Cipher Block Chaining - Message Authentication Code** |'
  prefs: []
  type: TYPE_TB
- en: '| GCM | Galois/Counter Mode | Based on CTR mode; should use a different IV
    for each stream to be encrypted; exceptionally high throughput (compared to other
    modes); supports parallelization for both encryption and decryption |'
  prefs: []
  type: TYPE_TB
- en: '| XTS | XEX-based Tweaked-codebook mode with ciphertext Stealing | Relatively
    new (2010) and fast; uses two keys; increases the amount of data that can be securely
    encrypted as one block |'
  prefs: []
  type: TYPE_TB
- en: Before choosing a cipher method and mode, you will also need to determine whether
    the encrypted contents needs to be unencrypted outside of your PHP application.
    For example, if you are storing database credentials encrypted into a standalone
    text file, do you need to have the ability to decrypt from the command line? If
    so, make sure that the cipher method and operation mode you choose are supported
    by the target operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The number of bytes supplied for the **IV** varies according to the cipher
    method chosen. For best results, use `random_bytes()` (new in PHP 7), which returns
    a true **CSPRNG** sequence of bytes. The length of the IV varies considerably.
    Try a size of 16 to start with. If a *warning* is generated, the correct number
    of bytes to be supplied for that algorithm will be shown, so adjust the size accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform encryption, use `openssl_encrypt()`. Here are the parameters that
    should be passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Parameter | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Data | Plain text you need to encrypt. |'
  prefs: []
  type: TYPE_TB
- en: '| Method | One of the methods you identified using `openssl_get_cipher_methods()`.
    identified as follows:*method* - *key_size* - *cipher_mode*So, for example, if
    you want a method of AES, a key size of 256, and GCM mode, you would enter `aes-256-gcm`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Password | Although documented as *password*, this parameter can be viewed
    as a *key*. Use `random_bytes()` to generate a key with a number of bytes to match
    the desired key size. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Until you gain more experience with `openssl` encryption, it is
    recommended you stick with the default value of `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| IV | Use `random_bytes()` to generate an IV with a number of bytes to match
    the cipher method. |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, suppose you wanted to choose the AES cipher method, a key size
    of 256, and XTS mode. Here is the code used to encrypt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt, use the same values for `$key` and `$iv`, along with the `openssl_decrypt()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to see which cipher methods are available, create a PHP script called
    `chap_12_openssl_encryption.php` and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you can add values for the plain text to be encrypted, the method, key,
    and IV. As an example, try AES, with a key size of 256, using the XTS operating
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To encrypt, you can use `openssl_encrypt()`, specifying the parameters configured
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also want to base 64-encode the result to make it more usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt, use the same `$key` and `$iv` values. Don''t forget to un-encode
    the base 64 value first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output showing the base 64-encoded cipher text, followed by the
    decrypted plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you supply an incorrect number of bytes for the IV, for the cipher method
    chosen, a warning message will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP 7, there was a problem when using `open_ssl_encrypt()` and `open_ssl_decrypt()`
    and the **Authenticated Encrypt with Associated Data** (**AEAD**) modes supported:
    GCM and CCM. Accordingly, in PHP 7.1, three extra parameters have been added to
    these functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$tag` | Authentication tag passed by reference; variable value remains the
    same if authentication fails |'
  prefs: []
  type: TYPE_TB
- en: '| `$aad` | Additional authentication data |'
  prefs: []
  type: TYPE_TB
- en: '| `$tag_length` | 4 to 16 for GCM mode; no limits for CCM mode; only for `open_ssl_encrypt()`
    |'
  prefs: []
  type: TYPE_TB
- en: For more information, you can refer to [https://wiki.php.net/rfc/openssl_aead](https://wiki.php.net/rfc/openssl_aead).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an excellent discussion on why the `mcrypt` extension is being deprecated
    in PHP 7.1, please refer to the article at [https://wiki.php.net/rfc/mcrypt-viking-funeral](https://wiki.php.net/rfc/mcrypt-viking-funeral).
    For a good description of block cipher, which forms the basis for the various
    cipher methods, refer to the article present at [https://en.wikipedia.org/wiki/Block_cipher](https://en.wikipedia.org/wiki/Block_cipher).
    For an excellent description of AES, refer to [https://en.wikipedia.org/wiki/Advanced_Encryption_Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).
    A good article that describes encryption operation modes can be seen at [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some of the newer modes, if the data to be encrypted is less than the block
    size, `openssl_decrypt()` will return no value. If you *pad* the data to be at
    least the block size, the problem goes away. Most of the modes implement internal
    padding so this is not an issue. With some of the newer modes (that is, `xts`)
    you might see this problem. Be sure to conduct tests on short strings of data
    less than eight characters before putting your code into production.
  prefs: []
  type: TYPE_NORMAL
