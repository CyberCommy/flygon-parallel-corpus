- en: Chapter 6. Improving Performance of 2D/3D Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once upon a time, gaming on the mobile platform was limited to black-and-white
    pixel games, and other mediums of gaming were also heavily dependent on pixel
    graphics. Times have changed now. 3D games are running on handhelds with ease.
    However, the requirement of 2D assets has not changed yet. Even in a hardcore
    3D game, 2D assets are mandatory. Few games are fully 2D.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the performance of 2D and 3D games here with the help of the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D game development constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D game development constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rendering pipeline in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering through OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing 2D assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing 3D assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common game development mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D/3D performance comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D game development constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the perspective of 2D game development, the main constraints are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D art assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D rendering system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D art assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Art asset constraints are mainly limited to graphical or visual assets, which
    include images, sprites, and fonts. It is not difficult to understand that a larger
    asset will take more time to process and render than a smaller asset, resulting
    in less performance quality.
  prefs: []
  type: TYPE_NORMAL
- en: Sets of 2D art assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not possible to deliver maximum display quality with a single set of assets
    in Android game development. This is the reason most Android game developers choose
    high-resolution assets as their base build. This normally performs well for high-configuration
    hardware platforms, but does not provide quality performance on low-configuration
    devices. Many developers opt for the option of porting for multiple resolution
    hardware platforms. This again takes time to complete the project.
  prefs: []
  type: TYPE_NORMAL
- en: Same asset set for multiple resolutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many times, developers choose to ignore a set of hardware platforms. Mostly,
    in the mobile gaming industry, it is a common practice to choose higher resolution
    art assets and fit them into lower resolution devices by scaling down. Nowadays,
    most hardware platforms have better RAM. Hence, this process has become convenient
    for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Number of assets drawn on screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Game performance does not always depend on the asset size; it also depends on
    the number of assets that are being drawn on screen. The concept of a sprite sheet
    has evolved to reduce the number of drawing elements on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the system issues a call for a draw instruction for a single art
    asset. As the number of assets increases, it takes more such draw instructions
    to complete the rendering in each game loop cycle. Obviously, this process slows
    down the processor, and the game performance becomes poor.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite sheet can consist of multiple assets within a single image. So, it
    takes only one draw instruction to render all the assets of the sprites. However,
    the physical size of the sprite sheet is restricted. The maximum size varies for
    different devices with different hardware platforms. Most conveniently, 1024x1024
    sprites are the safest option to use, as they are supported by almost all the
    available devices in the current scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Use of font files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost every game uses custom or special fonts other than the default system
    font of Android. In those cases, the font source file has to be included in the
    game build. There are multiple ways to use different fonts. We will discuss three
    of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Sprite font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitmap font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TrueType font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite font
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a typical old school technique but is still effective in some cases.
    The developer creates a sprite sheet that contains all the necessary characters.
    All the characters are mapped within a data file. This mapping is used to clip
    each character and form words accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some advantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers have total control of mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character stylization can be customized as per requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast processing speed can be achieved; however, it will depend on development
    efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some disadvantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: They increase development overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system efficiency entirely depends on the developer's skill set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very difficult to map characters in the case of multi-language support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change takes a lot of iteration to achieve perfection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This style is not usually used nowadays as we have many designer and stylish
    fonts available.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap font
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitmap font system is inherited from the sprite font. It is updated with
    a predefined mapping style and a library to support development process. It also
    uses one or more sprite sheets with one data file. The working principle of bitmap
    font is the same as sprite font. There are a lot of tools available to create
    such fonts with a bit of stylization directly from the TrueType font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some advantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: It is compatible with any existing codebase, irrespective of the rendering framework,
    whether it is OpenGL, DirectX, Direct Draw, or GDI+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to integrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can manipulate the style of the existing TrueType font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some disadvantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: The same disadvantages of the sprite font are applicable here, only with less
    development overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling up the bitmap font results in blurry output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TrueType font
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the universal format of font that is supported by most platforms, including
    Android. It is the fastest way to integrate various fonts in games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some advantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: Universal font style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum platform support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy multi-language implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a vector font, so it has no scaling issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy special character availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some disadvantages of this font:'
  prefs: []
  type: TYPE_NORMAL
- en: Using this font style may cost a few kilobytes extra to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all scripting languages are supported by TTF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D rendering system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android provides a scope to render 2D assets onto the canvas through an API
    framework. Canvas can be used with `Drawable` objects in `View` or `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas acts as an interface of the actual drawing surface upon which all the
    graphical objects can be drawn. Draw on the canvas happens within the `onDraw()`
    callback method. The developer just needs to specify graphical objects along with
    their position on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Canvas itself has a set of default drawing methods to render almost each type
    of graphical objects. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawBitmap()` method is used to draw image objects in the bitmap format.
    However, images need not be in bitmap format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drawRect()` and `drawLine()` methods are used to draw primitive shapes
    on the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drawText()` method can be used to render text on canvas using a specific
    font style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas can be used within a view in the Android architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 2D mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '2D mapping is based on a simple 2D coordinate system. The only difference is
    the opposite *y* axis in comparison with the conventional coordinate system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2D mapping](img/B05069_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Android 2D, the origin is located in the top-left corner of the canvas. All
    the geometrical calculations are based on this mapping. However, it has no direct
    effect on the performance like the 2D canvas-based application has. Many developers
    are used to mapping their graphic assets based on the conventional system, and
    they reverse the vertical axis to render it on the canvas. This requires some
    additional calculation.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more performance constraint regarding the 2D rendering systems.
    A common development approach across the world is to have a minimum set of graphic
    assets and use them as much as possible. Often, this leads to rendering the same
    pixel multiple times. This affects the processing speed and hence the FPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, bitmap **A**, bitmap **B**, bitmap **C**, and bitmap **D** are
    being rendered on a canvas in such a way that **A**, **B**, and **C** overlap
    each other, and **D** remains separate. The following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Pixels in the region **R0** where only one bitmap is drawn will be rendered
    once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pixels in region **R1** where two bitmaps are overlapping will be rendered twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pixels in region **R2** where three bitmaps are overlapping will be rendered
    three times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2D mapping](img/B05069_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, in regions **R1** and **R2**, all the pixels are rendered multiple times.
    In this system, the pixel data information will append to the previous data, resulting
    in the final pixel value. In this system, the processing overhead increases. Hence,
    performance decreases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even today, it is a common practice for 2D game programming. The reasons are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transparency blending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular graphical assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low build size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy construction of screens by overlapping multiple assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, there may be a scenario where a device has a very low-performing
    graphics processor, and rendering the same pixel multiple times has a major impact
    on performance. In this scenario, the double buffer mechanism helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The double buffering system refers to creating a buffered displayable asset
    in which the display screen is created using graphic assets. Then, this buffered
    object is drawn on the screen only once. It prevents the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Flickering of screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple draws of one pixel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tearing of assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D physics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2D physics takes only the *x-y* plane into consideration for all the calculations.
    There are plenty of 2D physics engines available in market. **Box2D** is the most
    popular one. A physics engine consists of every mechanism and calculation of real-time
    physics.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time physics calculation is much complicated than is required in games.
    Let's discuss a few available physics engines.
  prefs: []
  type: TYPE_NORMAL
- en: Box2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Box2D is an open source physics engine based on C++. It consists of almost
    every aspect of solid physics that can be used in various games. A few of its
    mentionable features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic collision detection of rigid bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision state callbacks, such as collision enter, exit, stay, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polygonal collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical, horizontal, and projectile motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friction physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torque and momentum physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gravity effects based on pivot point and joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LiquidFun
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LiquidFun is a physics engine with all aspects of liquid physics. This engine
    is actually based on Box2D. Google released this open source physics engine to
    cover the liquid physics formula and mechanism. LiquidFun can be used for Android,
    iOS, Windows, and a few other popular platforms. LiquidFun supports every feature
    of Box2D, along with liquid particle physics. This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Wave simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liquid fall and particle simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liquid stir simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solid and liquid dynamic collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liquid mixing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance impact on games
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Collision detection is a costly process. Multi-edge and polygonal collisions
    increase the process overhead. The number of rigid bodies and collision surfaces
    have the maximum impact on performance. This is why liquid physics is slower than
    solid physics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the major impacts:'
  prefs: []
  type: TYPE_NORMAL
- en: Each transformation of any rigid body requires a refresh on the collision check
    of the entire system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physics engine is responsible for repetitive transform change, which is
    responsible for heavy processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each and every possible force on the rigid body is calculated in the physics
    engine. Not all the games require every calculation. Game development does not
    always required real-time implementation of physics. However, real-time visualization
    is required for games.
  prefs: []
  type: TYPE_NORMAL
- en: 2D collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most games use the box-colliding system to detect most collisions. Rectangular
    collision detection is the cheapest possible method, which can be used inside
    games to detect collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, triangular and circular collision detection is also used for 2D games
    for collision detection accuracy. There needs to be a balance of using such methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to detect the collision between two circles, we can
    opt for any of these systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Considering each circle a rectangle and detecting the collision between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering one circle a rectangle and detecting the collision between the circle
    and rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the actual circular collision detection method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider two circles having origins *O1* and *O2* and diameters *R1*
    and *R2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*O1* is located at *(Ox1, Oy1)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*O2* is located at *(Ox2, Oy2)*'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we imagine the circles as rectangles on a 2D canvas, then it will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rectangle collision](img/B05069_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rectangular collision detection refers to this formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input feed will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*xMin1 = x1* (minimum co-ordinate on *x* axis of first rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*yMin1 = y1* (minimum co-ordinate on *y* axis of the first rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*xMax1 = x1m* (maximum co-ordinate on *x* axis of the first rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*yMax1 = y1m* (maximum co-ordinate on *y* axis of the first rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*xMin2 = x2* (minimum co-ordinate on *x* axis of the second rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*yMin2 = y2* (minimum co-ordinate on *y* axis of the second rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*xMax2 = x2m* (maximum co-ordinate on *x* axis of the second rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: '*yMax2 = y2m* (maximum co-ordinate on *y* axis of the second rectangle)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the given circumstances, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x1 = Ox1 – (R1 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y1 = Oy1 – (R1 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x1m = Ox1 + (R1 / 2) = x1 + R1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y1m = Oy1 + (R1 / 2) = y1 + R1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x2 = Ox2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y2 = Oy2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The condition for colliding or not colliding these two rectangles will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Rectangle and circle collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, considering only the second circle as a rectangle, we will have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rectangle and circle collision](img/B05069_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have already discussed the general idea of the coordinate system for
    the same system, we can directly derive the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Px1 = Ox2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Py1 = Oy2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Px2 = Ox2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Py2 = Oy2 + (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Px3 = Ox2 + (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Py3 = Oy2 + (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Px4 = Ox2 + (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Py4 = Oy2 – (R2 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*radius1 = (R1 / 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*distanceP1 = squareRoot(((Px1 – Ox1)* (Px1 – Ox1)) + ((Py1 – Oy1)* (Py1 –
    Oy1)))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*distanceP2 = squareRoot(((Px2 – Ox1)* (Px2 – Ox1)) + ((Py2 – Oy1)* (Py2 –
    Oy1)))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*distanceP3 = squareRoot(((Px3 – Ox1)* (Px3 – Ox1)) + ((Py3 – Oy1)* (Py3 –
    Oy1)))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*distanceP4 = squareRoot(((Px4 – Ox1)* (Px4 – Ox1)) + ((Py4 – Oy1)* (Py4 –
    Oy1)))*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The colliding and non-colliding condition would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Circle and circle collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the actual collision detection system is between the circle and circle
    collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Circle and circle collision](img/B05069_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Logically, this is the simplest procedure to find out the circular collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, calculate the distance between the two origins of the circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*originDistance = squareRoot ( ((Ox2 – Ox1)* (Ox2 – Ox1)) + ((Ox2 – Ox1)* (Ox2
    – Ox1)))*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to check whether the distance is less than or equal to the sum
    of the radius of the two circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Performance comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the first approach, it will take a minimum clock cycle to execute the checking.
    However, it is not that accurate. Particularly when developers work with a bigger
    circle, the lack in accuracy becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: The third approach is perfectly accurate, but takes more time to process. In
    the case of many circles colliding in runtime, this process and mathematical calculation
    may cause performance delay.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is, overall, the worst possible way to solve this problem.
    However, this approach may be used in a very specific situation. When a developer
    wants to detect circle and rectangle collisions accurately, then only this approach
    can be tried.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting these sorts of collision may have multiple solutions. The approaches
    and solutions you have learned here are few of the most efficient solutions from
    the point of view of performance.
  prefs: []
  type: TYPE_NORMAL
- en: When detecting rectangle and circle collisions accurately, there is one more
    popular approach by creating a bigger round rectangle by increasing the width
    and height by the diameter of the circle. This procedure is heavier but more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 3D game development constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D game development in Android native is very complicated. The Android framework
    does not support direct 3D game development platforms. 2D game development is
    directly supported by Android Canvas. The developer requires OpenGL support to
    develop 3D games for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Development is supported by Android NDK, which is based on C++. We will discuss
    a few constraints of 3D development for Android with OpenGL support.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides the OpenGL library for development. The developer needs to
    set up scenes, light, and camera first to start any development process.
  prefs: []
  type: TYPE_NORMAL
- en: Vertices and triangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vertex refers to a point in 3D space. In Android, `Vector3` can be used to define
    the vertices. A triangle is formed by three such vertices. Any triangle can be
    projected onto a 2D plane. Any 3D object can be simplified to a collection of
    triangles surrounding its surface.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a cube surface is a collection of two triangles. Hence, a cube
    can be formed of 12 triangles as it has six surfaces. The number of triangles
    has a heavy impact on the rendering time.
  prefs: []
  type: TYPE_NORMAL
- en: 3D transformation matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each 3D object has its own transformation. `Vector` can be used to indicate
    its position, scaling, and rotation. Generally, this is referred through a matrix
    called a transform matrix. A transformation matrix is 4 x 4 in dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume the matrix to be *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D transformation matrix](img/B05069_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*{a, b, c, e, f, g, i, j, k}* represents linear transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{d, h, l}* represents perspective transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{m, n, o}* represents translations along the *x*, *y*, and *z* axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{a, f, k}* represents local scaling along the *x*, *y*, and *z* axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{p}* represents overall scaling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{f, g, i, k}* represents rotation along the *x* axis where *a = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{a, c, i, k}* represents rotation along the *y* axis where *f = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*{a, b, e, f}* represents rotation along the *z* axis where *k = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any 3D object can be translated using this matrix and a respective transform
    3D vector. Naturally, matrix calculation is heavier than 2D simple linear calculation.
    As the number of vertices increases, the number of calculations increases as well.
    This results in performance drop.
  prefs: []
  type: TYPE_NORMAL
- en: 3D object and polygon count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any 3D model or object has surfaces referred to as polygons. Fewer of polygons
    implies fewer of triangles, which directly decreases the vertices count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D object and polygon count](img/B05069_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a simple example of a polygonal distribution of a 3D object surface.
    A six-sided polygon has four triangles and six vertices. Each vertex is a 3D vector.
    Every processor takes time to process each vertex. It is recommended that you
    keep a check on the total polygon count, which will be drawn in each draw cycle.
    Many games suffer a significant amount of FPS drop because of a high and unmanaged
    polygon count.
  prefs: []
  type: TYPE_NORMAL
- en: Android is specifically a mobile OS. Most of the time, it has limited device
    configuration. Often, managing the poly count of 3D games for Android becomes
    a problem for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 3D rendering system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android uses OpenGL to provide a 3D rendering platform with both framework and
    NDK. The Android framework provides `GLSurfaceView` and `GLSurfaceView.Renderer`
    to render 3D objects in Android. They are responsible for generating the model
    on screen. We have already discussed the 3D rendering pipeline through OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: '3D rendering maps all the objects on a 3D world coordinate system following
    the right-hand thumb system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D rendering system](img/B05069_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3D mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 3D mesh is created with vertices, triangles, and surfaces. A mesh is created
    to determine the shape of the object. A texture is applied to the mesh to create
    the complete model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mesh is the trickiest part of 3D model creation, as basic optimization
    can be applied here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the procedure of creating the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D mesh](img/B05069_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A 3D model can contain more than one mesh, and they may even be interchangeable.
    A mesh is responsible for the model detailing quality and for the rendering performance
    of the model. For Android development, it is recommended that you keep a certain
    limit of vertices and triangles for meshes to render performance.
  prefs: []
  type: TYPE_NORMAL
- en: Materials, shaders, and textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the formation of the model structure through the mesh, the texture is
    applied on it to create the final model. However, the texture is applied through
    a material and manipulated by shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Materials, shaders, and textures](img/B05069_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Textures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Textures are 2D images applied to the model to increase detailing and view the
    quality of a model. This image is mapped through the surfaces of the mesh so that
    each surface renders a particular clip of the texture.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shaders are used to manipulate the quality, color, and other attributes of the
    texture to make it more realistic. Most of the time, it is not possible to create
    a texture with all the attributes properly set. A 3D model visibility is dependent
    on light source, intensity, color, and material type.
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The material determines the texture attribute and shader property. The material
    can be termed as a container for the shader and texture before applying it to
    the mesh to create the model.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collision detection for 3D Android games can be categorized into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive colliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These colliders consist of basic 3D elements such as cubes, spheres, cylinders,
    prisms, and so on. This collision detection system follows certain geometric patterns
    and rules. That's why it is comparatively less complicated than the arbitrary
    mesh collider.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the developer assigns primitive colliders to many models to
    increase the performance of the game. This approach is obviously less accurate
    than actual collider.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh colliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mesh colliders can detect actual arbitrary collision detection. This collision
    detection technique is process heavy. There are few algorithms to minimize the
    process overhead. **quadtree**, **kd-tree**, and **AABB tree** are a few examples
    of such collision detection techniques. However, they do not minimize the CPU
    overhead significantly.
  prefs: []
  type: TYPE_NORMAL
- en: The oldest but most accurate method is triangle to triangle collision detection
    for each surface. To simplify this method, each mesh block is converted to boxes.
    A special AABB tree or quadtree is generated to reduce the vertex check.
  prefs: []
  type: TYPE_NORMAL
- en: This can be further reduced to **octree** vertex mapping by merging two box
    colliders. In this way, the developer can reduce the collision check to reduce
    CPU overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Ray casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ray casting is a geometric system to detect the surfaces of 3D graphical objects.
    This system is used to solve the geometric problems of 3D computer graphics. In
    the case of 3D games, all 3D objects are projected in a 2D view. It is not possible
    to determine depth without ray casting in the case of a 2D electronic display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ray casting](img/B05069_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each ray from the origin projected on different objects can detect the shape
    of the object, distance from the plane, collision detection, rotation, and scaling
    of the objects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Android games, ray casting is vastly used to handle touch input
    on the screen. Most of the games use this method to manipulate the behavior of
    3D objects used in the game.
  prefs: []
  type: TYPE_NORMAL
- en: From the point of view of development performance, ray casting is a quite costly
    system to use in a major scale. This requires a series of geometrical calculation,
    resulting in a processing overhead. As the number of rays increases, the process
    gets heavier.
  prefs: []
  type: TYPE_NORMAL
- en: It is always a best practice to keep a control on using multiple rays casting
    at one point.
  prefs: []
  type: TYPE_NORMAL
- en: Concept of "world"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word "world" in 3D games is a real-time simulation of the actual world with
    a regional limitation. The world is created with 3D models, which refer to actual
    objects in the real world. The scope of the game world is finite. This world follows
    a particular scale, position, and rotation with respective cameras.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of camera is a must for simulating such a world. Multiple cameras
    can be used to render different perspectives of the same world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the gaming industry, a game world is created according to requirements.
    This means that the worlds of different games are different. But a few of the
    parameters remain the same. These parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Finite elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of the game world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A world consists of the elements that are required in game design. Each game
    may require different elements. However, there are two things that are common
    across the games: sky and terrain. Most of the elements are usually placed on
    the terrain, and the light source is in the sky. However, many games offer different
    light sources at different scopes of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements can be divided into two categories: movable objects and static objects.
    A game''s rigid bodies are associated with such elements. Normally, static objects
    do not support motion physics.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing objects in the world is necessary for performance. Each object has
    a certain number of vertices and triangles. We have already discussed the processing
    overhead of the vertices of 3D objects. Generally, world optimization is basically
    the optimization of each element in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Light sources in the game world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A game world must have one or more light sources. Lights are used to expose
    the elements in the world. Multiple light sources have a great visual impact on
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The game development process always requires at least one good light artist.
    Modern games use light maps to amplify the visual quality. The light and shadow
    play in the game world is entirely dependent on light mapping.
  prefs: []
  type: TYPE_NORMAL
- en: There is no doubt that light is a mandatory element in the game world. However,
    the consequence of processing light and shadow is a large amount of processing.
    All the vertices need to be processed according to a light source with a particular
    shader. Use of extensive light sources results in low performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Light sources can be of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Area light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spot light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directional light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of light source is used to light a rectangular or circular region.
    By nature, it is a directional light and lights the area with equal intensity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Spot light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A spot light is used to focus on a particular object in a conical directional
    shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Point light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A point light illuminates in all directions of the source. A typical example
    is a bulb illumination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Directional light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A directional light is a set of parallel light beams projected on a place in
    a 3D world. A typical example is sunlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ambient light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An ambient light is a set of arbitrary light beams in any direction. Usually,
    the intensity of this kind of light source is low. As a light beam does not follow
    a particular direction, and it does not generate any shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**L1**, **L2**, **L3**, and **L4** are ambient light sources here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume light**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A volume light is a modified type of point light. This kind of light source
    can be converted into a set of light beams within a defined geometrical shape.
    Any light beam is a perfect example of such a light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Light sources in the game world](img/B05069_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cameras in the game world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The camera is the last but the most important element of the game world. A camera
    is responsible for the rendering of the game screen. It also determines the elements
    to be added in the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of camera used in a game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perspective camera**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of camera is typically used to render 3D objects. The visible scale
    and depth is fully dependent on this type of camera. The developer manipulates
    the field of view and near/far range to control the rendering pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cameras in the game world](img/B05069_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Orthographic camera**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of camera is used to render objects from a 2D perspective, irrespective
    of the objects. An orthographic camera renders objects on the same plane, irrespective
    of the depth. The developer manipulates effective width and height of the camera
    to control the 2D rendering pipeline. This camera is typically used for 2D games
    and to render 2D objects in a 3D game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cameras in the game world](img/B05069_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Besides this, the game camera can also be categorized by their nature and purpose.
    Here are the most common variations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed camera**'
  prefs: []
  type: TYPE_NORMAL
- en: A fixed camera does not rotate, translate, or scale during the execution. Typically,
    2D games use such cameras. A fixed camera is the most convenient camera in terms
    of processing speed. A fixed camera does not have any runtime manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotating camera**'
  prefs: []
  type: TYPE_NORMAL
- en: This camera has a rotating feature during runtime. This type of camera is effective
    in the case of sports simulation or surveillance simulation games.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving camera**'
  prefs: []
  type: TYPE_NORMAL
- en: A camera can be said to be moving when the translation can be changed during
    runtime. This type of camera is typically used for an aerial view of the game.
    A typical use of this sort of camera is for games such as *Age Of Empires*, *Company
    Of Heroes*, *Clash Of Clans*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Third-person camera**'
  prefs: []
  type: TYPE_NORMAL
- en: This camera is mainly the part of gameplay design. This is a moving camera,
    but this camera follows a particular object or character. The character is supposed
    to be the user character, so all the actions and movements are tracked by this
    camera including the character and object. Mostly, this camera can be rotated
    or pushed according to the actions of the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**First-person camera**'
  prefs: []
  type: TYPE_NORMAL
- en: When the player plays as the main character, this camera is used to implement
    a typical view of the eyes of the player. The camera moves or translates according
    to the actions of the player.
  prefs: []
  type: TYPE_NORMAL
- en: The rendering pipeline in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now have a look at the types of rendering pipeline in Android.
  prefs: []
  type: TYPE_NORMAL
- en: The 2D rendering pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of the 2D Android drawing system through Canvas, all the assets
    are first drawn on the canvas, and the canvas is rendered on screen. The graphic
    engine maps all the assets within the finite Canvas according to the given position.
  prefs: []
  type: TYPE_NORMAL
- en: Often, developers use small assets separately that cause a mapping instruction
    to execute for each asset. It is always recommended that you use sprite sheets
    to merge as many small assets as possible. A single draw call can then be applied
    to draw every object on the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question is how to create the sprite and what the other consequences
    are. Previously, Android could not support images or sprites of a size more than
    1024 x 1024 pixels. Since Android 2.3, the developer can use a 4096 x 4096 sprite.
    However, using such sprites can cause permanent memory occupancy during the scopes
    of all the small assets. Many low-configuration Android devices do not support
    such large images to be loaded during an application. It is a best practice that
    developers limit themselves to 2048 x 2048 pixels. This will reduce memory usage
    peak, as well as significant amounts of draw calls to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The 3D rendering pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android uses OpenGL to render assets on the screen. So, the rendering pipeline
    for Android 3D is basically the OpenGL pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have look at the OpenGL rendering system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The 3D rendering pipeline](img/B05069_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s have a detailed look at each step of the preceding rendering flow
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The **vertex shader** processes individual vertices with vertex data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **control shader** is responsible for controlling vertex data and patches
    for the tessellation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **polygon arrangement** system arranges the polygon with each pair of intersecting
    lines created by vertices. Thus, it creates the edges without repeating vertices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tessellation** is the process of tiling the polygons in a shape without overlap
    or any gaps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **geometry shader** is responsible for optimizing the primitive shape. Thus
    triangles are generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After constructing the polygons and shapes, the model is **clipped** for optimization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vertex post processing** is used to filter out unnecessary data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mesh is then **rasterized**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **fragment shader** is used to process fragments generated from rasterization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the pixels are **mapped** after fragmentation and **processed** with the
    processed data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mesh is added to the **frame buffer** for final rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimizing 2D assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any digital game cannot be made without 2D art assets. There must be 2D assets
    in some form inside the game. So, as far as game component optimization is concerned,
    every 2D asset should also be optimized. Optimization of 2D assets means these
    three main things.
  prefs: []
  type: TYPE_NORMAL
- en: Size optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each asset frame should only contain the effective pixels to be used in games.
    Unnecessary pixels increase the asset size and memory use during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Data optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all images require full data information for pixels. A significant amount
    of data might be stored in each pixel, depending on the image format. For example,
    full screen opaque images should never contain transparency data. Similarly, depending
    on the color set, images must be formatted in 8-bit, 16-bit, or 24-bit format.
  prefs: []
  type: TYPE_NORMAL
- en: Image optimization tools can be used to perform such optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Process optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The larger the amount of data compressed during optimization, the more time
    it takes to decompress it and load it to memory. So, image optimization has a
    direct effect on the processing speed.
  prefs: []
  type: TYPE_NORMAL
- en: From another point of view, creating an image atlas or sprite sheet is another
    way to reduce the processing time of images.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing 3D assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A 3D art asset has two parts to be optimized. A 2D texture part is to be optimized
    in the same 2D optimization style. The only thing the developer needs to consider
    is after optimization, the shader should have the same effect on the structure.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the 3D asset optimization entirely depends on the number of vertices
    and the model polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the polygon count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very obvious that a large number of polygons used to create a mesh can
    create more details. However, we all know that Android is a mobile OS, and it
    always has hardware limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The developer should count the number of polygons used in the mesh and the total
    number of polygons rendered on the screen in a single draw cycle. There is always
    a limitation depending on the hardware configuration.
  prefs: []
  type: TYPE_NORMAL
- en: So, limiting the polygon and vertex count per mesh is always an advantage in
    order to achieve a certain frame rate or performance.
  prefs: []
  type: TYPE_NORMAL
- en: Model optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Models are created with more than one mesh. Using a separate mesh in the final
    model always results in heavy processing. This is a major effort for the game
    artist. Multiple overlaps can occur if multiple meshes are used. This increases
    vertex processing.
  prefs: []
  type: TYPE_NORMAL
- en: Rigging is another essential part of finalizing the model. A good rigger defines
    the skeleton with the minimum possible joints for minimum processing.
  prefs: []
  type: TYPE_NORMAL
- en: Common game development mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always possible to look into each and every performance aspect at
    every development stage. It is a very common practice to use assets and write
    code in a temporary mode and use it in the final game.
  prefs: []
  type: TYPE_NORMAL
- en: This affects the overall performance and future maintenance procedure. Here
    are few of the most common mistakes made during game development.
  prefs: []
  type: TYPE_NORMAL
- en: Use of non-optimized images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An artist creates art assets, and the developer directly integrates those into
    the game for the debug build. However, most of the time, those assets are never
    optimized, even for the release candidate.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason there may be plenty of high-bit images where the asset contains
    limited information. Alpha information may be found in opaque images.
  prefs: []
  type: TYPE_NORMAL
- en: Use of full utility third-party libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The modern day development style does not require each and every development
    module to be written from scratch. Most of the developers use a predefined third-party
    library for common utility mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these packages come with most of the possible methods, and
    among them, very few are actually used in games. Developers, most of the time,
    use these packages without any filtration. A lot of unused data occupies memory
    during runtime in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Often, a third-party library comes without an editing facility. In this case,
    the developer should choose such packages very carefully, depending on their specific
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Use of unmanaged networking connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern Android games, the use of Internet connectivity is very common. Many
    games use server-based gameplay. In such cases, the entire game runs on the server
    with frequent data transfers between the server and the client device. Each data
    transfer process takes time, and the connectivity drains the battery charge significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Badly managed networking states often freeze the application. A significant
    amount of data is handled, especially for real-time multiplayer games. In this
    case, a request and response queue should be created and managed properly. However,
    the developer often skips this part to save development time.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of unmanaged connections is unnecessary packet data transferred
    between the server and client. So, there is an extra parsing process involved
    each time data is transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Using substandard programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed programming styles and standards. The modular programming
    approach may increase a few extra processes, but the longer management of programming
    demands modular programming. Otherwise, developers end up repeating code, and
    this increases process overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management also demands a good programming style. In few cases, the developer
    allocates memory but often forgets to free the memory. This causes a lot of memory
    leakage. At times, the application crashes due to insufficient memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Substandard programming includes the following mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the same variables multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating many static instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing non-modular coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper singleton class creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading objects at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a shortcut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the funniest fact among ill-practiced development styles. Taking a shortcut
    during development is very common among game developers.
  prefs: []
  type: TYPE_NORMAL
- en: Making games is mostly about logical development. There may be multiple ways
    of solving a logical problem. Very often, the developer chooses the most convenient
    way to solve such problems. For example, the developer mostly uses the bubble
    sorting method for most of the sorting requirements, despite knowing that it is
    the most inefficient sorting process.
  prefs: []
  type: TYPE_NORMAL
- en: Using such shortcuts multiple times in a game may cause a visible process delay,
    which directly affects the frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: 2D/3D performance comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android game development in 2D and 3D is different. It is a fact that 3D game
    processing is heavier than 2D games. However, the game scale is always the deciding
    factor.
  prefs: []
  type: TYPE_NORMAL
- en: Different look and feel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3D look and feel is way different than 2D. The use of a particle system in 3D
    games is very common to provide visual effects. In the case of 2D games, sprite
    animation and other transformations are used to show such effects.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between 2D and 3D look and feel is dynamic light and shadow.
    Dynamic light is always a factor for greater visual quality. Nowadays, most 3D
    games use dynamic lighting, which has a significant effect on game performance.
    In the case of 2D games, light management is done through assets. So, there is
    no extra processing in 2D games for light and shadow.
  prefs: []
  type: TYPE_NORMAL
- en: In 2D games, the game screen is rendered on a Canvas. There is only one fixed
    point of view. So, the concept of camera is limited to a fixed camera. However,
    in 3D games, it is a different case. Multiple types of camera can be implemented.
    Multiple cameras can be used together for a better feel of the game. Rendering
    objects through multiple cameras causes more process overhead. Hence, it decreases
    the frame rate of the game.
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant performance difference between using 2D physics and 3D
    physics. A 3D physics engine is far more process heavy than a 2D physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: 3D processing is way heavier than 2D processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a common practice in the gaming industry to accept less FPS in 3D games
    in comparison to 2D games. In Android, the standard accepted FPS for 2D games
    is around 60 FPS, whereas a 3D game is acceptable even if it runs at as low as
    40 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical reason behind this is that 3D games are way heavier than 2D games
    in terms of process. The main reasons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex processing**: In 3D games, each vertex is processed on the OpenGL
    layer during rendering. So, increasing the number of vertices leads to heavier
    processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh rendering**: A mesh consists of multiple vertices and many polygons.
    Processing a mesh increases the rendering overhead as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D collision system**: A 3D dynamic collision detection system demands each
    vertex of the collider to be calculated for collision. This calculation is usually
    done by the GPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3D physics implementation**: 3D transformation calculation completely depends
    on matrix manipulation, which is always heavy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple camera use**: Use of multiple cameras and dynamically setting up
    the rendering pipeline takes more memory and clock cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android has a wide range of device configuration options supported by the platform.
    In the previous chapters, we have already seen such variations. Running the same
    game on different configurations does not produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Performance depends on the following factors.
  prefs: []
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many processors used for Android devices in terms of the number of
    cores and the speed of each core. Speed decides the number of instructions that
    can be executed in a single cycle. There was a time when Android used to have
    a single core CPU with speed less than 500 MHz. Now we have multicore CPUs with
    more than 2 GHz speed on each core.
  prefs: []
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Availability of RAM is another factor that decides performance. Heavy games
    require a greater amount of RAM during runtime. If RAM is limited, then frequent
    loading/unloading processes affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: GPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GPU decides the rendering speed. It acts as the processing unit for graphical
    objects. A more powerful processor can process more rendering instructions, resulting
    in better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Display quality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Display quality is actually inversely proportional to the performance. Better
    display quality has to be backed by better GPU, CPU, and RAM, because better displays
    always consist of bigger resolution, with better dpi and more color support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see various devices with different display quality. Android itself has
    divided the assets by this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LDPI**: Lowest dpi display for Android (~120 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MDPI**: Medium dpi display for Android (~160 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HDPI**: High dpi display for Android (~240 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XHDPI**: Extra high dpi display for Android (~320 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XXHDPI**: Extra extra high dpi display for Android (~480 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XXXHDPI**: Extra extra extra high dpi display for Android (~640 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be easily predicted that the list will include more options in the near
    future, with the advancement of hardware technology.
  prefs: []
  type: TYPE_NORMAL
- en: Battery capacity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Battery capacity is an odd factor in the performance of the application. More
    powerful CPUs, GPUs, and RAM demand more power. If the battery is incapable of
    delivering power, then processing units cannot run at their peak efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize these factors, we can easily make a few relational equations with
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU is directly proportional to performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPU is directly proportional to performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM is directly proportional to performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display quality is inversely proportional to performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Battery capacity is directly proportional to performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope of 3D games is increasing day by day with more quality and performance.
    However, this requires hardware support for the running Android platform. Old
    devices are not obsolete yet.
  prefs: []
  type: TYPE_NORMAL
- en: It becomes a serious problem when the same application runs on various devices.
    This becomes a challenge for developers to run the same application across devices.
  prefs: []
  type: TYPE_NORMAL
- en: There are many technical differences between 2D and 3D games in terms of rendering,
    processing, and assets. The developer should always use an optimized approach
    to create assets and write code. One more way of gaining performance is to port
    the games for different hardware systems for both 2D and 3D games.
  prefs: []
  type: TYPE_NORMAL
- en: We can see a revolutionary upgrade in hardware platforms since the last decade.
    Accordingly, the nature of games has also changed. However, the scope of 2D games
    is still there with a large set of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are many frameworks and engines available for developing 2D and 3D games.
    Support for multiple operating systems has also increased its value for both 2D
    and 3D games.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance is more of a logical task than a technical one. There
    are a few tools available to do the job, but it is the developer's decision to
    choose them. So, selecting the right tool for the right purpose is necessary,
    and there should be a different approach to making 2D and 3D games.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed the rendering processes in both 2D and 3D development.
    We will further enhance rendering with the help of shaders in Android and try
    to explore various techniques of optimizing Android games later in this book.
  prefs: []
  type: TYPE_NORMAL
