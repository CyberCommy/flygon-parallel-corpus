- en: Addressing Cross-Cutting Concerns
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of concerns that you need to have when writing clean code—core
    concerns and cross-cutting concerns. **Core concerns** are the reasons for the
    software and why it is being developed. **Cross-cutting concerns** are the concerns
    that are not part of the business requirements and that form the core concerns,
    but must be addressed in all areas of the code, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a4fd4a9-d664-4351-985d-fc1b37687b68.png)'
  prefs: []
  type: TYPE_IMG
- en: It is the cross-cutting concerns that we will be covering in this chapter by
    building a reusable class library that you can modify or extend to your liking.
    Cross-cutting concerns include configuration management, logging, auditing, security,
    validation, exception-handling, instrumentation, transactions, resource pooling,
    caching, and threading and concurrency. We will use the decorator pattern and
    the PostSharp Aspect Framework to help us build our reusable library, which is
    injected at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: As you read through this chapter, you will see how **attribute programming** can
    result in using a lot less boilerplate code, as well as code that is smaller,
    more readable, and easier to maintain and extend. This leaves only the required
    business code in your methods with the boilerplate code
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed many of these ideas already. However, they are mentioned here
    again as they are cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-Oriented Programming** (**AOP**) with PostSharp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project – cross-cutting concerns reusable library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have the skills to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the decorator pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the proxy pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply AOP using PostSharp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your own reusable AOP library that addresses your cross-cutting concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, you will need Visual Studio 2019 and PostSharp
    installed. For the code files for this chapter, refer to [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11).
    Let's start by looking at the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decorator design pattern is a structural pattern that is used to add new
    functionality to an existing object without changing its structure. The original
    class is wrapped in decorator class wraps and new behaviors and operations are
    added to an object at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adc0e574-a40d-4c5f-b12b-397bf35ff3b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Component` interface and the members it contains are implemented by the
    `ConcreteComponent` class and the `Decorator` class. `ConcreteComponent` implements
    the `Component` interface. The `Decorator` class is an abstract class that implements
    the `Component` interface and contains the reference to a `Component` instance.
    The `Decorator` class is the base class for components. The `ConcreteDecorator`
    class inherits from the `Decorator` class and provides a decorator for components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to write an example that wraps an operation in a `try`/`catch`
    block. Both `try` and `catch` will output a string to the console. Create a new
    .NET 4.8 console application named `CH10_AddressingCrossCuttingConcerns`. Then,
    add a folder called `DecoratorPattern`. Add a new interface called `IComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things simple, our interface only has a single operation of the `void` type.
    Now that we have our interface in place, we need to add an abstract class that
    implements the interface. Add a new abstract class called `Decorator` that implements
    the `IComponent` interface. Add a member variable to store our `IComponent` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_component` member variable, which stores the `IComponent` object, is
    set via the constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the constructor sets the component we will be decorating.
    Next, we add our interface method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve declared the `Operation()` method as `virtual` so that it can be overridden
    in the derived classes. We''ll now create our `ConcreteComponent` class, which
    implements `IComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our class consists of one operation, which throws `NotImplementedException`.
    Now, we can write about the `ConcreteDecorator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteDecorator` class inherits the `Decorator` class. The constructor
    takes an `IComponent` parameter and passes it to the base constructor, where the
    member variable is then set. Next, we''ll override the `Operation()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our overridden method, we have a `try`/`catch` block. In the `try` block,
    we write a message to the console and execute the base class'' `Operation()` method.
    In the `catch` block, when an exception is encountered, a message is written,
    followed by the error message. Before we can use our code, we need to update the `Program` class.
    Add the `DecoratorPatternExample()` method to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `DecoratorPatternExample()` method, we create a new concrete component.
    We then pass it into the constructor of a new concrete decorator. Then, we call
    the `Operation()` method on the concrete decorator. Add the following two lines
    to the `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two lines execute our example and then wait for the user to press a key
    before exiting. Run the code and you should see the same output as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/664bec75-738c-4c02-b795-f06f6e2d0a52.png)'
  prefs: []
  type: TYPE_IMG
- en: That concludes our look at the decorator pattern. Now, it's time to look at
    the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The proxy pattern is a structural design pattern providing objects that act
    as substitutes for real service objects used by clients. Proxies receive client
    requests, perform the required work, and then pass the request to service objects.
    Proxy objects are interchangeable with services as they share the same interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a2acc31-3b52-44c5-8ddf-421e7e7aba54.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of when you would want to use the proxy pattern is when you have
    a class that you do not want to change, but where you do need additional behaviors
    to be added. Proxies delegate work to other objects. Unless a proxy is a derivative
    of a service, proxy methods should finally refer to a `Service` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at a very simple implementation of the proxy pattern. Add a folder
    to the root of your `Chapter 11` project called `ProxyPattern`. Add an interface
    called `IService` with a single method to handle a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Request()` method performs the work that carries out the request. Both
    the proxy and the service will implement this interface to use the `Request()` method.
    Now, add the `Service` class and implement the `IService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Service` class implements the `IService` interface and handles the actual
    service `Request()` method. This `Request()` method will be called by the `Proxy` class.
    The final step to implementing the proxy pattern is to write the `Proxy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Proxy` class implements `IService` and has a constructor that accepts
    a single `IService` parameter. The `Request()` method of the `Proxy` class is
    called by the client. The `Proxy.Request()` method will do what it needs to do
    and will be responsible for calling `_service.Request()`. So that we can see this
    in action, let''s update our `Program` class. Add the `ProxyPatternExample()` call to
    the `Main()` method. Then, add the `ProxyPatternExample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test method runs the `Request()` method of the `Service` class direction.
    Then, it runs the same method via the `Request()` method of the `Proxy` class.
    Run the project and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff58bd4b-08a3-41b8-bdba-bef5e252a020.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have a working understanding of the decorator and proxy patterns,
    let's take a look at AOP with PostSharp.
  prefs: []
  type: TYPE_NORMAL
- en: AOP with PostSharp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AOP can be used with OOP. An **aspect** is an attribute applied to classes,
    methods, parameters, and properties that, at compile-time, weaves code into the
    class, method, parameter, or property to which it is applied. This approach allows
    the cross-cutting concerns of a program to be moved from the business source code
    to a class library. The concerns are added where needed as attributes. The compiler
    then weaves the required code in at runtime. This keeps your business code small
    and readable. In this chapter, we will be using PostSharp. You can download it
    from [https://www.postsharp.net/download](https://www.postsharp.net/download).
  prefs: []
  type: TYPE_NORMAL
- en: So, how does AOP work with PostSharp?
  prefs: []
  type: TYPE_NORMAL
- en: You add the PostSharp package to your project. Then, you annotate your code
    with attributes. The C# compiler builds your code into binary, and then PostSharp
    analyzes the binary and injects the implementation of the aspects. Although the
    binaries are modified with injected code at compile-time, your project's source
    code remains unaltered. This means you can keep your code nice, clean, and simple,
    which in turn makes maintenance, reuse, and extending existing code bases much
    easier in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: PostSharp has some really good ready-made patterns for you to utilize. These
    cover **Model-View-ViewModel** (**MVVM**), caching, multi-threading, longing and
    architecture validation, and more. But the good news is that if there is nothing
    that meets your requirements, then you can automate your own patterns by extending
    the aspect framework and/or the architecture framework.
  prefs: []
  type: TYPE_NORMAL
- en: With the aspect framework, you develop your simple or composite aspect, apply
    it to the code, and validate its usage. As for the architectural framework, you
    develop your custom architectural constraints. Before we delve into the cross-cutting
    concerns, let's briefly take a look at extending the aspect and architectural
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: You need to add the `PostSharp.Redist` NuGet package when writing aspects and
    attributes. Once done, if you find that your attributes and aspects are not working,
    then right-click on the project and select Add PostSharp to Project. After you've
    done this, your aspects should work.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the aspect framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to develop a simple aspect and apply it to some
    code. Then, we will validate the usage of our aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Developing our aspect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our aspect will be a simple one that is composed of a single transformation.
    We will derive our aspect from a primitive aspect class. Then, we will override
    some methods known as **advice**. If you would like to know how to create a composite
    aspect, you can read how to do so at [https://doc.postsharp.net/complex-aspects](https://doc.postsharp.net/complex-aspects).
  prefs: []
  type: TYPE_NORMAL
- en: Injecting behaviors before and after the method execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `OnMethodBoundaryAspect` aspect implements the decorator pattern. You have
    already seen how to implement the decorator pattern earlier in this chapter. With
    this aspect, you can execute logic before and after the execution of a target
    method. The following table provides a list of the advice methods that are available
    in the `OnMethodBoundaryAspect` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Advice** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEntry(MethodExecutionArgs)` | Used when the method''s execution starts,
    before any user code. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnSuccess(MethodExecutionArgs)` | Used when the method''s execution succeeds
    (that is, returns without an exception), after any user code. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnException(MethodExecutionArgs)` | Used when the method execution fails
    with an exception, after any user code. It is equivalent to a `catch` block. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnExit(MethodExecutionArgs)` | Used when the method execution exits, whether
    successfully or with an exception. This advice runs after any user code and after
    the `OnSuccess(MethodExecutionArgs)` or `OnException(MethodExecutionArgs)` method
    of the current aspect. It is equivalent to a `finally` block. |'
  prefs: []
  type: TYPE_TB
- en: 'For our simple aspect, we are going to look at all the methods in use. Before
    we begin, add PostSharp to your project. If you have already downloaded PostSharp,
    you can right-click on your project and then select Add PostSharp to Project.
    After that, add a new folder to your project called `Aspects`, and then add a
    new class called `LoggingAspect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[PSerializeable]` attribute is a custom attribute that, when applied to
    a type, causes PostSharp to generate a serializer for use by `PortableFormatter`.
    Now, override the `OnEntry()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnEntry()` method is executed before any user code. Now, override the
    `OnSuccess()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSuccess()` method runs after the user code has completed without exception.
    Override the `OnExit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnExit()` method executes when the user method completes successfully
    or unsuccessfully and exits. It is equivalent to a `finally` block. Finally, override
    the `OnException()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `OnException()` method executes when method execution fails with an exception,
    after any user code. It is equivalent to a `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write two methods that we can apply `LoggingAspect` to.
    We''ll add `SuccessfulMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`SuccessfulMethod()` uses `LoggingAspect` and prints a message to the console.
    Now, let''s add `FailedMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`FailedMethod()` uses `LoggingAspect` and prints a message to the console.
    Then, it performs a division by zero operations, which results in `DivideByZeroException`.
    Call both of these methods from your `Main()` method, and then run through your
    project. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2169d706-6075-45f7-a0c7-668e69855318.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the debugger will cause the program to exit. That's it. As you
    can see, creating your own PostSharp aspects to meet your needs is a simple process.
    Now, we will look at adding our own architectural constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the architectural framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An architectural constraint is the adoption of custom design patterns that must
    be respected across all modules. We will implement a scalar constraint that validates
    an element of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our scalar constraint, called `BusinessRulePatternValidation`, will validate
    that any class deriving from the `BusinessRule` class must have a nested class
    named `Factory`. Start by adding the `BusinessRulePatternValidation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`MulticastAttributeUsage` designates that this validation aspect will only
    work with classes and inheritance allowed. Let''s override the `ValidateCode()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ValidateCode()` method checks whether the target object has a nested `Factory`
    type. If the `Factory` type is not present, then an exception message is written
    to the output window. Add the `BusinessRule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `BusinessRule` class is empty and devoid of `Factory`. It has our `BusinessRulePatternValidation`
    attribute assigned to it, which is an architectural constraint. Build your project
    and you will see the message in the output window. We will now start to build
    a reusable class library that you can extend and use in your own projects to address
    cross-cutting concerns using AOP and the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Project – cross-cutting concerns reusable library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be working through writing a reusable library for addressing
    various cross-cutting concerns. It will have limited functionality, but it will
    give you the knowledge you need to further expand the project for your own needs.
    The class library you will be creating will be a .NET standard library so that
    it can be used for apps that target both .NET Framework and .NET Core. You will
    also create a .NET Framework console application to see the library in action.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET standard class library called `CrossCuttingConcerns`.
    Then, add a .NET Framework console application to the solution called `TestHarness`.
    We will be adding reusable functionality to address various concerns, starting
    with caching.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the caching concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Caching** is a storage technique for improving performance when accessing
    various kinds of resources. The cache used can be memory, a filesystem, or a database.
    The type of cache you use will be dependent on the needs of the project. For our
    demonstration, we will be using memory caching to keep things simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Caching` to the `CrossCuttingConcerns` project. Then,
    add a class called `MemoryCache`. Add the following NuGet packages to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostSharp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostSharp.Patterns.Common`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostSharp.Patterns.Diagnostics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Runtime.Caching`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update the `MemoryCache` class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetItem()` method takes the name of the cached item, `itemName`, the length
    of time the item is to remain in the cache, `timeInCache`, and the function to
    call to place the item in the cache if it is not already there, `itemCacheFunction`.
    Add a new class to the `TestHarness` project and call it `TestClass`. Then, add
    the `GetCachedItem()` and `GetMessage()` methods, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `GetCachedItem()` method gets a string called `"Message"` from the cache.
    If it is not in the cache, then it will be stored in the cache by the `GetMessage()` method for
    30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `Main()` method in the `Program` class to call the `GetCachedItem()`
    method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `GetCachedItem()` stores the item in the cache and then returns
    it. The second call obtains the item from the cache and returns it. The sleeping
    thread invalidates the cache, and so the last call stores the item in the cache
    before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding file logging capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our project, the logging, auditing, and instrumentation processes will send
    their output to a text file. So, we will need a class to manage adding the files
    if they don''t exist, and then adding the output to those files and saving them.
    Add a folder to the class library called `FileSystem`. Then, add a class called
    `LogFile`. Set the class as `public static` and add the following member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_location` variable is assigned the folder for the entry assembly. The
    `_filename` variable is assigned the name of the file with the file extension.
    We need to add the `Logs` folder at runtime (if it does not exist). So, we will
    add the `AddDirectory()` method to the `FileSystem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddDirectory()` method checks whether the location exists. If it does
    not exist, then the directory is created. Next, we need to deal with adding the
    file if it does not exist. So, add the `AddFile()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AddFile()` method, we combine the location and filename. If the filename
    already exists, then we exit the method; otherwise, we create the file. If we
    don''t use the `using` statement, we will encounter `IOException` when we create
    our first record, but subsequent saves will be fine. So, by using the `using`
    statement, we avoid the exception and log the data. We can now write a method
    that actually saves the data to a file. Add the `AppendTextToFile()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `AppendTextToFile()` method takes a filename and text and sets the location
    to that of the entry assembly. It then ensures that the file and directory exist.
    Then, it saves the text to the specified file. Our file logging capabilities are
    now taken care of, so now, we can move on to look at our logging concern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the logging concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most applications need some form of logging. The usual methods of logging are
    to the console, filesystem, event logs, and database. In our project, we will
    only focus on console and text file logging. Add a folder called `Logging` to
    the class library. Then, add a file called `ConsoleLoggingAspect` and update it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[PSerializable]` attribute informs PostSharp to generate a serializer
    for use by `PortableFormatter`. `ConsoleLoggingAspect` inherits from `OnMethodBoundaryAspect`.
    The `OnMethodBoundaryAspect` class has methods that we can override to add code
    before a method body executes, after a method body executes, when a method body
    executes successfully, and when an exception is encountered. We will override
    these methods to output a message to the console. This can be a very useful tool
    when it comes to debugging to see whether code actually gets called and whether
    it successfully completes or encounters an exception. We will start by overriding
    the `OnEntry()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnEntry()` method executes before the body of our methods do, and our
    override prints out the name of the method been executed and its own name. Next,
    we''ll override the `OnExit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnExit()` method executes after the body of our methods have finished
    executing, and our override prints out the name of the method that has been executed
    and its own name. Now, we''ll add the `OnSuccess()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSuccess()` method executes after the body of the method it is applied
    to has finished and returns without exception. When our override executes, it
    prints out the name of the executed method and its own name. The last method we
    will override is the `OnException()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnException()` method executes when an exception is encountered, and in
    our override, we print out the name of the method and the argument''s object.
    To apply the attribute, use `[ConsoleLoggingAspect]`. To add a text file logging
    aspect, add a class called `TextFileLoggingAspect`. `TextFileLoggingAspect` is
    identical to `ConsoleLoggingAspect`, apart from the contents of the overridden
    methods. The `OnEntry()`, `OnExit()`, and `OnSuccess()` methods call the `LogFile.AppendTextToFile()`
    method and append the contents to the `Log.txt` file. The `OnException()` method
    does the same, except it appends the contents to the `Exception.log` file. Here
    is the `OnEntry()` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That is our logging taken care of. Now, we'll move on to adding our exceptions
    concern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the exception-handling concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is inevitable with software that exceptions will be experienced by users
    of the software. So, there needs to be some way to log them. The normal way of
    logging exceptions is to store the error in a file on the user''s system, such
    as with `Exception.log`. That''s what we''ll do in this section. We will inherit
    from the `OnExceptionAspect` class and write our exception data to the `Exception.log` file,
    which will be located in the `Logs` folder of our application. `OnExceptionAspect`
    wraps the tagged method in a `try`/`catch` block. Add a new folder to the class
    library called `Exceptions`, and then add a file called `ExceptionAspect` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExceptionAspect` class is assigned the `[PSerializable]` aspect and inherits
    from `OnExceptionAspect`. We have three properties: `message`, `ExceptionType`,
    and `FlowBehavior`. `message` contains the exception message, `ExceptionType`
    contains the type of exception encountered, and `FlowBehavior` determines whether
    execution continues once the exception is handled or whether the process terminates.
    The `GetExceptionType()` method returns the type of exception that was thrown.
    The `OnException()` method starts by constructing the error message. It then logs
    the exception to file by calling `LogFile.AppendTextToFile()`. Finally, the flow
    of the exception''s behavior is set to continue.'
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do to use the `[ExceptionAspect]` aspect is add it as an attribute
    to your method. We have now covered exception-handling. So, we'll move on to adding
    our security concern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the security concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The security needs will be specific to the project being worked on. The most
    common concerns are that users are authenticated and authorized to access and
    use various parts of the system. In this section, we will use the decorator pattern
    to implement a secure component with role-based methods.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a very large subject in itself and beyond the scope of this book.
    There are many good APIs out there, such as the various Microsoft APIs. Refer
    to [https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/) for
    more information, and for OAuth 2.0, refer to [https://oauth.net/code/dotnet/](https://oauth.net/code/dotnet/).
    We will leave you to select and implement your own method of security. In this
    chapter, we simply add our own custom-defined security using the decorator pattern.
    You can use this as a base for implementing any of the aforementioned security
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder called `Security` and add an interface to it called `ISecureComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our secure component interface contains the preceding four methods, which are
    self-explanatory. The `dynamic` keyword means that any type of data can be passed
    in as a parameter and that any type of data can be returned from the `GetData()`
    method. Next, we need an abstract class that implements the interface. Add a class
    called `DecoratorBase`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DecoratorBase` class implements `ISecureComponent`. We declare a member
    variable of the `ISecureComponent` type and set it in the default constructor.
    We need to add the missing methods of `ISecureComponent`. Add the `AddData()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This method will take any type of data and then pass it into the call to the
    `AddData()` method of `_secureComponent`. Add the missing methods for `EditData()`,
    `DeleteData()`, and `GetData()`. Now, add a class called `ConcreteSecureComponent`,
    which implements `ISecureComponent`. For each method, write a message to the console.
    For the `DeleteData()` and `EditData()` methods, also return a value of `1`. Return
    `"Hi!"` for `GetData()`. The `ConcreteSecureComponent` class is the class that
    executes the secure work that we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way to validate the user and obtain their role. The role will be
    checked before executing any methods. So, add the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things simple, the struct takes a username and password and sets the
    appropriate role. Restricted users have fewer privileges than administrators.
    The final class for our security concern is the `ConcreteDecorator` class. Add
    the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConcreteDecorator` class inherits the `DecoratorBase` class. Our constructor
    takes a type of `ISecureComponent` and passes it to the base class. Add the `AddData()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`AddMethod()` checks the user''s role against the allowed `Administrator` and
    `Restricted` roles. If the user is in one of these roles, then the `AddData()`
    method is executed in the base class; otherwise, `UnauthorizedAccessException`
    is thrown. The rest of the methods follow this same pattern. Override the rest
    of the methods, but make sure the `DeleteData()` method can only be executed by
    administrators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now put our security concerns to work. Add the following line to the
    top of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We are declaring and instantiating a concrete decorator object and passing
    in the concrete secure object. This object will be referenced in our data methods.
    Update the `Main()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We assign the username and password to the `Credentials` struct. This causes
    `Role` to be set. We then call the `DoWork()` method. The `DoWork()` method will
    be responsible for calling the data methods. We then pause for the user to press
    any key and exit. Add the `DoWork()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoSecureWork()` method calls each of the data methods that call the data
    methods on the concrete decorator. Add the `AddData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`[ExceptionAspect]` is applied to the `AddData()` method. This will ensure
    any errors are logged to the `Exceptions.log` file. The parameter is set to `true`,
    and so the error message will also be printed in the console window. The method
    itself calls the `AddData()` method on the `ConcreteDecorator` class. Add the
    rest of the methods by following the same procedure. Then, run your code. You
    should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/847bde47-fa68-4381-aba1-0c89cd4987ae.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a working role-based object, complete with exception handling. Our
    next step is to implement our validation concern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the validation concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All user-entered data should be validated as it could be malicious, incomplete,
    or in the wrong format. You need to ensure that your data is clean and cannot
    cause harm. For our demonstration concern, we will implement null validation.
    Start by adding a folder called `Validation` to the class library. Then, add a
    new class called `AllowNullAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This attribute allows nulls on parameters, return values, and properties. Now,
    add the `ValidationFlags` enum to a new file of the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'These flags are used to determine what items an aspect can be applied to. Next,
    we''ll add a class called `ReflectionExtensions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsCustomAttributeDefined()` method returns `true` if the attribute type
    is defined on this member, and `false` otherwise. The `AllowsNull()` method returns
    `true` if the `[AllowNull]` attribute is already applied, and `false` if not.
    The `MayNotBeNull()` method checks to see whether nulls are allowed, whether the
    parameter is optional, and what type of value the parameter is. A Boolean value
    is then returned by performing logical `AND` operations on these values. It''s
    time to add `DisallowNonNullAspect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has the `[PSerializable]` attribute applied to inform PostSharp
    to generate a serializer for `PortableFormatter`. It also inherits the `OnMethodBoundaryAspect`
    class. We then declare variables to hold the input and output arguments as validated
    parameter names, return value validation and the member name, and check whether
    the item being validated is a property. The default constructor is configured
    to allow the validator to be applied to all public members. We also have a constructor
    that takes a `ValidationFlags` value and a `ValidationFlags` property. Now, we''ll
    override the `CompileTimeValidate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This method ensures that the aspect is correctly applied at compile-time. If
    the aspect is applied to a wrong type of member, then `false` is returned. Otherwise,
    it returns `true`. We now override the `OnEntry()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This method checks the *input arguments* to validate. If any arguments are
    `null`, then `ArgumentNullException` is thrown; otherwise, the method exits without
    throwing an exception. Let''s override the `OnSuccess()` method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSuccess()` method validates the *output parameters* to validate. If
    any arguments are null, then `InvalidOperationException` will be thrown. The next
    thing we need to do is add `private class` for extracting method information.
    Add the following class to the bottom of the `DisallowNonNullAspect` class before
    the closing brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following three constructors to the `MethodInformation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'These constructors differentiate between constructors and methods and perform
    the necessary initialization of the method. Add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateInstance()` method creates a new instance of the `MethodInformation`
    class based on the `MethodInfo` data of the method passed in and returns that
    instance. Add the `GetMethodInformation()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This method casts `methodBase` to `ConstructorInfo` and checks for `null`. If
    `ctor` is not `null`, then a new `MethodInformation` class is generated based
    on the constructor. However, if `ctor` is `null`, then `methodBase` is cast to
    `MethodInfo`. If the method is not `null`, then the `CreateInstance()` method
    is called, passing in the method. Otherwise, `null` is returned. Finally, add
    the following properties to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: These properties are properties of the method that has the aspect applied. We
    have now finished writing our validation aspect. You can now use the validator
    to allow nulls by attaching the `[AllowNull]` attribute. You can disallow nulls
    by attaching `[DisallowNonNullAspect]`. Now, we'll add our transaction concern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the transaction concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transactions are processes that must run to completion or rollback. Add a new
    folder to the class library called `Transactions`*, *and then add the `RequiresTransactionAspect`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnEntry()` method starts the transaction, the `OnSuccess()` method completes
    the exception, and the `OnExit()` method disposes of the transaction. To use the
    aspect, add `[RequiresTransactionAspect]` to your method. To log any exceptions
    that prevent the completion of the transaction, you can also assign the `[ExceptionAspect(consoleOutput:
    false)]` aspect. Next, we''ll add our resource pool concern.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the resource pool concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resource pools are a good way to improve performance when multiple instances
    of an object are expensive to create and destroy. We will create a very simple
    resource pool for our needs. Add a folder called `ResourcePooling`, and then add
    the `ResourcePool` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This class creates a new resource generator and stores resources in `ConcurrentBag`.
    When an item is requested, it issues a resource from the pool. If one does not
    exist, then it is created, added to the pool, and issued to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The code you've just seen shows you how to use the `ResourcePool` class to create
    a pool, obtain a resource, and return it to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the configuration settings concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuration settings should always be centralized. Since desktop applications
    store their settings in the `app.config` file and web applications store their
    settings in `Web.config`, we can use `ConfigurationManager` to access the application
    settings. Add the `System.Configuration.Configuration` NuGet library to your class
    library and test the harness. Then, add a folder called `Configuration` and the
    following `Settings` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will get and set app settings in the `Web.config` file and the `App.config`
    file. To include the class in your files, add the following `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows you how to use the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using the static import, you don't have to include the `class` prefix. You can
    extend the `Settings` class to get connection strings or to do whatever configuration
    you need in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the instrumentation concern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final cross-cutting concern is that of instrumentation. We use instrumentation
    to profile our application and see how long it takes for methods to execute. Add
    a folder to the class library called `Instrumentation`, and then add the `InstrumentationAspect`
    class, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the instrumentation aspect only applies to methods, times the
    start and stop times of the method, and logs the profile information to the `Profile.log`
    file. If an exception is encountered, then the exception is logged to the `Exception.log`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a functional and reusable cross-cutting concerns library. Let's
    summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned some valuable information. We started off by looking at the decorator
    pattern and then the proxy pattern. The proxy pattern provides objects that act
    as substitutes for real service objects used by clients. A proxy receives a client
    request, performs the necessary work, and then passes the request to the service
    object. Since proxies share the same interfaces as the services they substitute,
    they are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: After covering the proxy pattern, we then moved onto AOP with PostSharp. We
    saw how we can use aspects and attributes together to decorate code so that at
    compile-time, it injects code to perform the required operations, such as exception
    handling, logging, auditing, and security. We extended the aspect framework by
    developing our own aspect and looked at how to use PostSharp and the decorator
    pattern to address the cross-cutting concerns of configuration management, logging,
    auditing, security, validation, exception handling, instrumentation, transactions,
    resource pooling, caching, threading, and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at using tools to help you improve your code
    quality. But before then, test your knowledge and then further your reading.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a cross-cutting concern and what does AOP stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an aspect and how do you apply one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an attribute and how do you apply one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do the aspects and attributes work together?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the build process work with aspects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PostSharp home page: [https://www.postsharp.net/](https://www.postsharp.net/download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
