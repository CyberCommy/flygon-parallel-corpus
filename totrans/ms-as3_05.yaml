- en: Assets and Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this book, we have covered layouts, design, and the libraries and
    tools that support them. We then went on to explore developing for different screen
    sizes, shapes, and densities, as well as other form factors. This is the last
    chapter in the UI development module where we will look at how Android Studio
    manages various assets and resources, such as icons and other drawables.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio is very accommodating when it comes to including drawables in
    our projects and, particularly, when it comes to vector graphics, which are invaluable
    to an Android developer, as they scale nicely across different screen sizes and
    densities, and this is catered for with a very valuable tool, the vector asset
    studio. Along with this, there is an asset studio to generate and configure bitmap
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Vector drawables are widely used for in-app icons and in components such as
    menus, tabs, and the notification area and are also very flexible when it comes
    to animating icons and transforming them from one icon to another icon, a very
    useful space-saving function on small screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating icons with asset studios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building adaptive icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating material launcher icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a material icon plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating vector assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing vector assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing dynamic layouts with plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting prominent colors from an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are very few, if any, apps that do not employ some forms of icons and
    even if these are only launcher and, action icons, the correct choices and design
    make the difference between a successful UI and a confusing one.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not essential, Google is very keen that we use material design
    icons. This is an attempt to create a uniform user experience across the platform
    to counter the perception that iOS offers a more consistent feel. This is unsurprising,
    as iOS is a closed system that places a lot of restrictions on the developer.
    Google, on the other hand, prefers to offer a far more creative freedom to developers.
    In the past, this has led Apple devices to gain a reputation for being generally
    slicker than Android and, to counter this, Google introduced material design guidelines,
    which have gone on to far exceed original expectations and can now be found on
    many other platforms, including iOS.
  prefs: []
  type: TYPE_NORMAL
- en: As would be expected, Android Studio provides tools to assist us in incorporating
    these design features and drawables. This comes in the form of Asset Studio. This
    facilitates the creation and configuration of all manner of icons, from brightly
    colored detailed launcher icons to fully customized and scalable vector graphic
    action and notification icons. Along with API level 26, Android introduced Adaptive
    Icons that can display as different shapes on different devices and perform simple
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asset Studio comes with two separate interfaces: one for general images and
    one for vector graphics. We will look at the first of these in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Image Asset Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating images for different screen configurations, we often have to create
    several versions of the same image and this is usually not a great deal of work.
    When it comes to icons, on the other hand, we may have several individual icons
    and dozens of versions, making resizing and scaling them a tedious process. Fortunately,
    Android Studio provides a neat solution to this in the form of Image Asset Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Device manufacturers are perhaps even more concerned with creating a consistent
    look and feel across their models. This is particularly apparent when it comes
    to the way launcher icons are displayed on their home screens. An ideal situation
    would be if developers could design a single icon and manufacturers could then
    fit that into a uniform shape, such as a square or circle, depending on its location
    on a device and the manufacturer's own design ideals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Image Asset Studio achieves this by creating a two-layered icon that uses our
    original imagery and a plain background layer that a mask can be applied to in
    order to create the desired overall shape, often one of the three following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e21fe8-da87-44d0-9670-6f448e910fec.png)'
  prefs: []
  type: TYPE_IMG
- en: Adaptive icons
  prefs: []
  type: TYPE_NORMAL
- en: 'The Image Asset Studio can be opened by selecting New | Image Asset from your
    project''s drawable context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d11bba09-ec4b-48cf-8586-b6735f08a1d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Asset Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several stages to create icons that will work across the widest range
    of devices and API levels, and these stages are represented by the following three
    tabs in the wizard: Foreground Layer, Background Layer, and Legacy. There are
    some valuable features included in each of these tabs, which will be outlined
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Layered icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The foreground layer is where we apply our imagery. This can be our own artwork,
    in the case of a launcher icon, or clip art/text, if we are creating action icons.
    The wizard automatically generates an icon for each possible usage, including
    a Play Store icon, which involves creating an entirely new asset. The Show Safe
    Zone feature is, without doubt, the most useful of the preview features, as it
    displays a bounding circle that our asset should not extend beyond if our icon
    is to display correctly on all devices and platforms. The Resize: control allows
    us to quickly ensure that none of our icons extend beyond this zone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting Trim: as a scaling option will remove any excess pixels before creating
    the finished icon, meaning that redundant transparent pixels are removed from
    the top layer, often significantly reducing its file size.'
  prefs: []
  type: TYPE_NORMAL
- en: The background layer of an adaptive icon needs to be large enough to allow any
    trimming required to create the shapes and sizes shown in the preceding image.
    The default `ic_launcher_background.xml` produces a vector graphic describing
    a grid. This is very helpful when it comes to positioning and sizing our artwork,
    but it is not intended for use in a completed application. Google recommends that
    you use plain backgrounds with no borders or external shadows and, although Material
    guidelines allow some internal shading, the simplest solution is to use a color
    rather than an image for the background layer. This also allows us to select a
    prominent color from our theme, further promoting our brand.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d18238f-a8b7-42c3-bdcc-dfd16b44248e.png)'
  prefs: []
  type: TYPE_IMG
- en: Asset background selection
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image uses an icon from the clip art selection, which demonstrates
    nicely the purpose of the guidelines when it comes to designing our own.
  prefs: []
  type: TYPE_NORMAL
- en: The source image can only be selected when editing the foreground layer, regardless
    of the tab you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy tab allows us to ensure that our icons will still work on devices
    that run API level 25 and lower and provides us with all the design features that
    devices running these earlier versions need, such as the elongated rectangular
    icon that suited many of these devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb4cbc81-2154-4ca8-a0b5-9e0121e8a6a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Editing legacy icons
  prefs: []
  type: TYPE_NORMAL
- en: Many developers are also accomplished artists and will be more than comfortable
    to design launcher icons from scratch. For these readers, it is important to know
    that the specified dimensions of launcher icons have changed since the inception
    of API level 26\. Although icons had been designed for a `48 x 48 px` grid, they
    must now be `108 x 108 px`, with the central `72 x 72 px` representing the portion
    that must remain visible at all times. However, there is no guarantee what manufacturers
    in the future may do with these guidelines and, as always, it is advisable to
    test all assets against as many real devices as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The guidelines given here are not only useful to ensure our imagery is not unnecessarily
    clipped, but also to cater for the pulse and jiggle animations now included by
    many manufacturers. These are often used to indicate the success or failure of
    an attempted user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not, of course, strictly necessary to use the built-in asset studio to
    create adaptive icons, and once the basics are grasped, we can, of course, design
    and include our own directly as an XML. This can be done using the `android:roundIcon`
    identifier in a manifest file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Adaptive icons can then be added to any XML layout using the `adaptive-icon`
    attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although the set of included action icons is comprehensive, it is always good
    to have as much choice as possible, and a much larger and constantly updated collection
    can be found at [material.io/icons/](http://material.io/icons/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615b0235-0a87-4edb-b1ca-4b6d884a081c.png)'
  prefs: []
  type: TYPE_IMG
- en: Material icons
  prefs: []
  type: TYPE_NORMAL
- en: The Image Asset Studio is great for generating the small, in-app icons that
    we use on tabs, action bars, and so on, but it is limited when it comes to launcher
    icons, which should be bright and colorful and, in material terms, 3D. For this
    reason, launcher icons deserve a small section of their own.
  prefs: []
  type: TYPE_NORMAL
- en: Launcher icon tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, launcher icons are created using an external editor and,
    as we shall see, there are Studio plugins to assist us in creating stylish Android
    icons. One of the best tools is an online, alternative, and enhanced version of
    Asset Studio itself. It was created by the Google designer Roman Nurik and can
    be found on GitHub at [romannurik.github.io/AndroidAssetStudio](http://romannurik.github.io/AndroidAssetStudio).
  prefs: []
  type: TYPE_NORMAL
- en: This online version offers over half a dozen different icon generators, including
    features not included in the native version as well as a neat icon animator. The
    launcher icon generator is of interest here, as it allows us to set material features
    not offered in the IDE such as elevation, shadow, and scoring.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best things about this editor is the way it displays the material
    design icon keylines.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74245e77-6b10-488e-8fea-59e8729fc068.png)'
  prefs: []
  type: TYPE_IMG
- en: Launcher icon keylines
  prefs: []
  type: TYPE_NORMAL
- en: The design of what Google call *product* icons is beyond the scope of this book,
    but Google has some very interesting guidelines on the matter, which can be found
    at [material.io/guidelines/style/icons](https://material.io/guidelines/style/icons.html).
  prefs: []
  type: TYPE_NORMAL
- en: However, when you configure your launcher icons, you will need some kind of
    external graphics editor at some point. There are some tools that can help us
    integrate Android Studio with these editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android Material Design Icon Generator is a fantastic plugin from JetBrains
    and does precisely what its title suggests. It does not need to be downloaded,
    as it can be found in the plugin repository. If you want to use it with another
    IDE, it can be downloaded from the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[github.com/konifar/android-material-design-icon-generator-plugin](http://github.com/konifar/android-material-design-icon-generator-plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to Android Studio plugins, perform the following simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the settings dialog from File | Settings....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Plugins dialog and click on Browse repositories....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type Material into the search box and select and install the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/190a2f6a-e708-443d-b5e1-ac1f7d0d5bec.png)'
  prefs: []
  type: TYPE_IMG
- en: The plugins repository
  prefs: []
  type: TYPE_NORMAL
- en: Restart Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plugin can now be opened from most New... submenus or with *Ctrl* + *Alt*
    + *M*. The icon generator is simple, but offers all the important functions, such
    as being able to create both bitmap and vector images and a choice of all density
    groupings, as well as color and size selectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41b24384-4dc0-43e1-b9e8-5689197f2637.png)'
  prefs: []
  type: TYPE_IMG
- en: The Android Material Design Icon Generator plugin
  prefs: []
  type: TYPE_NORMAL
- en: The icon generator also has a handy link to the ever growing GitHub material
    design icon repository.
  prefs: []
  type: TYPE_NORMAL
- en: Sympli is a sophisticated, but expensive, design tool that works with the graphics
    editor of your choice and Android Studio via a Studio plugin. It generates icons
    and other assets automatically and is designed to be used among teams. It can
    be found at [sympli.io](https://sympli.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Although not a Studio plugin as such, there is a handy Python script on GitHub
    that GIMP users can find at [github.com/ncornette/gimp-android-xdpi](https://github.com/ncornette/gimp-android-xdpi).
  prefs: []
  type: TYPE_NORMAL
- en: Simply download the script and save it in your GIMP `plug-ins` folder as `gimpfu_android_xdpi.py`.
    It can then be accessed from the image's Filter menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/146fe493-a3f5-46fc-bdc0-1d27c930fccc.png)'
  prefs: []
  type: TYPE_IMG
- en: Automatic icon generation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, this plugin provides all the main
    choices we need to make when converting a single image into a set of icons.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to create and configure icons using these tools is useful and time
    saving, but there are many times when we will not use bitmaps for our icons at
    all, and instead use vector graphics, which only require an image for all densities.
  prefs: []
  type: TYPE_NORMAL
- en: Vector graphics load more slowly than raster images, but, once loaded, are a
    little faster. Very large vector images load slowly, so they should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Vector drawables are cached as correctly sized bitmaps at runtime. If you want
    to display the same drawable at different sizes, create a vector graphic for each.
  prefs: []
  type: TYPE_NORMAL
- en: For those who fancy creating vector images from scratch, there are some very
    useful free tools.
  prefs: []
  type: TYPE_NORMAL
- en: Method Draw is an online **Scaleable Vector Graphics** (**SVG**) editor that
    offers a simple, but very functional, set of tools to generate simple vector images,
    such as those we want for our action and notification icons. Creations can be
    downloaded as `.svg` files and imported directly into Studio. It can be found
    at `editor.method.ac`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a more sophisticated tool, Boxy SVG Editor is available on the Chrome
    Web Store, but it works offline and offers features similar to packages such as
    Inkscape or Sketch.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Asset Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vector graphics asset studio performs the same function as the raster graphics
    version, but it is more fun to work with. When dealing with preset icons, it is
    even simpler to use a sibling that requires nothing more than the selection of
    the material icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83f83504-d68e-477d-ba45-e614ba9f62c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Vector Asset Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, an asset like this is saved in XML as a `VectorDrawable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Android vector drawables are a similar, and somewhat simplified, version of
    the SVG format, familiarly associated with `.svg` files. As with raster assets,
    it is very easy to use existing icons. Only when we want to modify these or create
    our own does it become interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not necessary to learn SVG or even understand the `pathData`
    of a `VectorDrawable`, but it is good to understand a little of the process and
    some of the tools at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Vector drawables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vector studio allows us to import SVG files and convert them into VectorDrawables.
    There are many ways to obtain vector graphics, and many graphic editors can convert
    from other formats. There are also some very good online tools to convert other
    formats to SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[image.online-convert.com/convert-to-svg](http://image.online-convert.com/convert-to-svg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And JetBrains plugin is also available from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[plugins.jetbrains.com/plugin/8103-svg2vectordrawable](https://plugins.jetbrains.com/plugin/8103-svg2vectordrawable)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is unlikely that you will do much when you write your own SVG objects, but
    it is useful to see how the process operates, as these steps demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following code as a `.svg` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open an Android Studio project and then navigate to the vector studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Local File and then the SVG file created in the preceding code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Next and Finish to convert to the following `VectorDrawable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is usually a good idea to color vector icons black and color them using the
    `tint` property. This way, one icon can be reused with different themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SVG `<polygon>` is easy to understand, as it is a simple list of points
    defining the corners of the shape. The `android:pathData` string, on the other
    hand, is a little more cryptic. It is most easily explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M` is move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100,10`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l` line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-60,188`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l` line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`150,-120`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l` line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-180,0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l` line to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`150,120 z`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(end path)`'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding format uses caps to indicate absolute positions and lowercase
    to indicate relative ones. We can also create vertical and horizontal lines with
    `V`(`v`) and `H`(`h`), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is actually not necessary to include the final coordinate if the path end
    qualifier, z, is provided. Also, a character can be omitted if it is the same
    as the one before, as is the case with the `line-to` command previousl; consider
    the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding string could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are two sets of image dimensions, as you might expect--`viewportWidth`
    and `viewportHeight`; that refer to the canvas size of the original SVG image.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem unnecessary to concern ourselves with the vector data itself, as
    this is generated by the asset studio; but, as we shall see next, when it comes
    to animated icons (as well as other animated vector graphics), an understanding
    of the inner structure of a vector drawable can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Animated icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone with an Android device will be familiar with the animated icon. Perhaps
    the best known example is the way the hamburger icon transforms into an arrow
    and vice versa when a navigation drawer is opened and closed. The use of vector
    graphics makes this process remarkably simple. Provided that both the icons have
    the same number of points, any icon can be transformed into any other.
  prefs: []
  type: TYPE_NORMAL
- en: Using space efficiently is essential on a mobile device, and animating action
    icons not only looks good, but also saves space and, if applied intelligently,
    will convey meaning to the user as well.
  prefs: []
  type: TYPE_NORMAL
- en: Vector images are easily transformed from one to another by mapping points on
    the original image onto the target image. This is done with the `AnimatedVectorDrawable`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods of animating these drawables. Firstly, we can apply
    a number of predefined animations, such as rotation and translation. We can also
    use built-in interpolation techniques to *morph* from one drawable to another,
    regardless of the number of points. We will take a look at both of these techniques.
    However, first, we will examine how to use the image paths to control the animation,
    as this gives us the most control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image represents an arrow icon animating from pointing left,
    to pointing right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7d7807-59fe-497e-8189-986b2cc9c1cc.png)'
  prefs: []
  type: TYPE_IMG
- en: An animated arrow icon.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps demonstrate how to create such an animated vector drawable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by storing the paths to the two arrows as strings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As both paths are recorded as strings, we only need to define one vector drawable--call
    it `ic_arrow_left.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `res/animator`  folder and the `arrow_animation.xml` file, inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this to create our animated drawable, `ic_arrow_animated.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this in action, use the following Java snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By animating a vector's path, we can easily create new animations by reordering
    our points.
  prefs: []
  type: TYPE_NORMAL
- en: The key to this process is the `ObjectAnimator` class in the `arrow_animation` file.
    This class is far more powerful than it might seem here. In this example, we selected
    the `pathData` property to animate, but we could have animated almost any property
    we choose. In fact, any numerical property, including colors, can be animated
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: The object animator provides an opportunity to create imaginative new animations,
    but only for extant properties. However, what if we want to animate a value that
    we defined or, perhaps, a variable, reflecting some app-specific data? In these
    circumstances, we can take advantage of the ValueAnimator, from which the ObjectAnimator
    is descended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roman Nurik''s online asset studio also has a powerful and easy-to-use animated
    icon generator , which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[romannurik.github.io/AndroidIconAnimator](http://romannurik.github.io/AndroidIconAnimator)'
  prefs: []
  type: TYPE_NORMAL
- en: Using path data, this way offers a very flexible animation framework, particularly
    when we want to morph one icon into another, as it changes its function, as is
    often seen with toggle action such as play/pause. However, this is not our only
    option, as there are ready-made animations that we can apply to our vector assets
    and ways to transform icons into others that do not share the same number of points.
  prefs: []
  type: TYPE_NORMAL
- en: Other animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Morphing path data is one of the the most fun ways to animate icons (and other
    drawables), but sometimes we just need a simple symmetrical motion, such as rotation
    and translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to apply one of these animation types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a vector drawable of your choice and save its `pathData` as a string.
    Here, we have taken the data from the asset studio using the `ic_first_page_black_24dp`
    icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/51ba20b3-18b6-437e-a642-5027584ccb5f.png)'
  prefs: []
  type: TYPE_IMG
- en: the ic_first_page_black_24dp icon
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, create an XML asset for this; here, we will call it `ic_first_page.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, create an object animator, call it `rotation.xml` this time, and
    complete it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the animated version of the icon, as we did before, by setting
    a target. Here, the file is called `ic_animated_page.xml`, and it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The animation can be called by first adding it to our layout, as we would do
    with any other icon, and calling it from code like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The biggest difference here, apart from the animation type, is the inclusion
    of our `<path>` within a `<group>`. This is normally used for when there is more
    than one target, but, in this case, it is because it allows us to set a pivot
    point for the rotation with `vectorX/Y`. It also has equivalent settings for `scaleX/Y`,
    `translateX/Y`, and `rotate`.
  prefs: []
  type: TYPE_NORMAL
- en: To change an icon's transparency, set `alpha` in `<vector>`.
  prefs: []
  type: TYPE_NORMAL
- en: Having to build a project to test simple graphical features, such as these animated
    icons, can be very time-consuming. Jimu Mirror is a layout preview plugin that
    displays animations and other moving components. It connects via a device or emulator,
    and through a sophisticated hot-swapping process, layouts can be edited and retested
    within seconds. Jimu is not open source, but is not overly expensive and is available
    on a free trial. It can be downloaded from [www.jimumirror.com](http://www.jimumirror.com).
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is primarily to examine how Android Studio and associated
    tools can facilitate the generation of application icons. This has led us to take
    a look at Android drawables in general, both bitmaps and vector graphics. We explored
    other drawables briefly, earlier in the book, and now that we looked more deeply
    into the matter, now is a good time to revisit these drawables.
  prefs: []
  type: TYPE_NORMAL
- en: General drawables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw earlier how to convert a black icon into a color to match our app or
    current activity using tinting. With other images, there are times when they take
    up a considerable amount of the screen, and we want to apply the reverse and have
    our icons colored so that they match our graphics. Fortunately, Android provides
    a support library to extract prominent and dominant colors from any bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: The palette library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying our own themes to our apps can produce very stylish-looking interfaces,
    especially when we are dealing with text, icons, and images we created ourselves
    to suit the app. Many apps incorporate the user's own images and, in these cases,
    there is no way of knowing in advance how to select a pleasing design. The **palette
    support library** provides us with this functionality, allowing fine control over
    text, icon, and background coloring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to extract the prominent colors from a
    bitmap drawable:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android Studio project and open the Project Structure dialog from
    the `File` menu or *Ctrl* + *Alt* + *Shift* + *S*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Dependency tab from your app Module and add a Library dependency from
    the + icon in the top-right corner, using the search tool to find the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/954defd3-33a5-43dc-84ec-7867eb1057f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Library dependency selector
  prefs: []
  type: TYPE_NORMAL
- en: 'This will add the following line to your `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Create a layout with a large image view and at least two text views. Call these
    text views `text_view_vibrant` and `text_view_muted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your main Java activity and add the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the preceding `TextViews` with their XML counterparts, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the bitmap declared in step 5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following clause to extract prominent vivid and muted colors
    from the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/21cb6ae8-5d1e-40cc-9534-da97d4dba86d.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracted colors
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method outlined is effective but crude. There is a lot more that
    can be done with the palette library, and we need to know quite a few things to
    be able to take best advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a `default_color` by the palette is needed, as the extraction of
    these colors is not always possible and sometimes fails. This often happens with
    *washed out* images with very few colors and also with highly irregular images
    with little definition. Somewhat ironically, the scan can also fail when presented
    with over-saturated graphics with many colors and with very regular patterns where
    no color, if any, dominates.
  prefs: []
  type: TYPE_NORMAL
- en: One very important point when extracting these palettes is that working with
    large bitmaps can present a serious drain on device resources and all work with
    bitmaps should not, where possible, be performed on the current thread. The preceding
    example took no account of this, but the library has a listener class that allows
    us to perform these tasks asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following listener, instead of the preceding one, to react once the
    bitmap is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we extracted just two colors, using `Palette.getVibrantColor()`
    and `Palette.getMutedColor()`. These often suit our purposes very well, but if
    they do not, there are lighter and darker versions of each, and these can be accessed
    using getters, such as `getDarkVibrantColor()` or `getLightMutedColor()`.
  prefs: []
  type: TYPE_NORMAL
- en: The palette library has more features than we have space for here, such as being
    able to select text coloring to match analyzed images, and as it is not exclusive
    to Android Studio, it is likely that readers switching from other IDEs will already
    be familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: The Studio features we have covered in this book show how useful the IDE is
    when it comes to developing layouts and UIs, but, of course, this is just half
    the story. No matter how well put together our layouts are, they are as good as
    useless without logic behind them, and this is where Android Studio really starts
    to come into its own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only in this chapter, but also in the previous three chapters, we saw how
    Android Studio makes the designing and testing of our graphical layouts over a
    wide range of devices and factors both simple and intuitive. Having been specifically
    designed for Android's eccentricities, Studio is also the first to integrate new
    design features, such as the constraint layout, which has revolutionized designing
    of visual activities.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters done till now have covered all the fundamental design considerations
    catered for by the IDE and hopefully introduced the reader to the wealth of features
    that simplify and clarify this often complex process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin the process of bringing these designs to
    life as we see how Android Studio facilitates the often complex processes of coding,
    testing, and debugging our applications. These essential processes often overlap
    and most developers will find themselves having to revisit each as they fine-tune
    their work. Android Studio guides developers through and around this course, enabling
    them to track and evaluate as they go.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio has helped you to turn your ideas into delightful layouts. The
    next step is to bring these layouts to life with your logic. As one might imagine,
    the IDE is as helpful when it comes to logic as it has been when it was applied
    to design.
  prefs: []
  type: TYPE_NORMAL
