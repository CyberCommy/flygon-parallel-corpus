- en: Chapter 6. Redis in Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web in the present scenario is the ubiquitous platform through which the world
    today communicates. From a simple portal to massively scalable e-commerce, collaborative
    web sites, banking, social media, web applications over mobile networks, and so
    on, everyone uses web protocols as an interface to interact with the outside world.
    What we normally see as web platform is just a small part of the application that
    is under web operations, backend web applications, such as supply chain management,
    order management, online, offline analytics, and so on, are also web applications
    or use web protocols to integrate for example HTTP, SOAP, REST and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons for the web's success is its effective simplicity, open standards,
    and multiple channels through which it can operate. The fact that it's popular
    is forcing people and companies to come out with solutions that are simple, cost
    effective, high performing, and easy to maintain and develop. This new breed of
    software should have intrinsic or extrinsic capabilities to scale and perform
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Redis, the datastore that is more like a Swiss army knife, is multi-faceted
    and a proof to those capabilities we saw in previous chapters. In this chapter,
    we will extend and map the capabilities of Redis for components used in web domain
    and a create few proof of concept for components which form an inherent part of
    any web application.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the concepts of Redis better, let's make a sample web application
    and use Redis as a datastore. This sample web application is no way a complete
    end-to-end web application but intends to highlight the areas where Redis can
    come in handy. The solution itself is not complete in terms of functionality but
    intends to be a demo which practitioners can take forward and extend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple E-Commerce**, as we intend to call this demo website, is a Redis backed
    website which does not have a web page but communicates via simple services. The
    idea is to expose simple services and not bring in webpages (containing HTML,
    CSS and so on) to decouple services from the presentation layer. As we are moving
    more towards the era of single page application, it becomes imperative that we
    take an approach where the application residing in the client browser memory does
    all the coordination and the traditional web server does the job of serving the
    request via services it exposes. The advantage of this mechanism is that development
    and testing becomes easy as every service is independent of other service and
    there is no tight coupling with the presentation aspect of a web app. As we all
    have been involved in web development at one time or another, we can understand
    the frustration we face when we see a bug and when a considerable amount of time
    is spent in debugging whether the problem arose because of the client side code
    or the business methods it was calling. With the rising capabilities of single
    page application, this problem can be taken care of to a large extent since the
    business methods are exposed as independent services and can be tested separately
    from the presentation component. One of the salient features of a single page
    application is that it takes away a lot of compute activity from the server side
    to the client side (browser) which results in more compute resource for the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple e-commerce – a Redis backed e-commerce site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This sample e-commerce site, like other e-commerce sites, has products which
    the registered user can browse, purchase, and so on. The website also recommends
    products based on the users'' browsing and purchasing habits. In parallel, the
    website gives real time statistics of the activities happening in the website
    and provides you with capabilities to do real-time and soft-real-time analytics.
    So, let''s get cracking and build this website, and like in any design, let''s
    divide the requirement into commands, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session and catalogue management**: The following commands are offered as
    service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register user**: Command name is `register`; this command will register the
    user to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See my data**: Command name is `mydata`; this command will allow the user
    to see his/her data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit my data**: Command name is `editmydata`; this command will allow the
    user to edit his data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Login user**: Command name is `login`; this command will log in the user
    and generates a session-ID for the user to communicate with the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relogin user**: Command name is `relogin`; this command will again log the
    user but the session-ID will remain the same. All the session or profile data
    of the user will also remain the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logout user**: Command name is `logout`; this command will log out the user
    and kill his session or profile data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add to cart**: Command name is `add2cart`; this command will add the item
    to the shopping cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See my shopping cart**: Command name is `showmycart`; this command will show
    the items in the shopping cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit my shopping cart**: Command name is `editcart`; this command will edit
    user preference in the shopping cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buy products**: Command name is `buy`; this command will buy the items in
    the shopping cart of the user. For the current application, we will not take you
    to some merchant''s site but instead we will generate a sample receipt for you.
    The idea is to have analysis, so when somebody buys the product we give credit
    points for that product which will help us for our recommendation service. The
    credit point for buying is `10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commission product**: Command name is `commission`; this command will commission
    the product and create its profile in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display product**: Command name is `display`; this command will display the
    product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browse products**: Command name is `browse`; this command will log the product
    the user is currently browsing. The idea is that when somebody browses the product,
    we give credit points for the product which will help us for our recommendation
    service. The credit point for browsing is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online Analytics**: Following commands come under this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recommend**: Command name is `recommendbyproduct`; this command will recommend
    other products similar to the current product based on their popularity which
    the user is browsing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User''s statistics**: Command name is `stats`; this command will show the
    user''s statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display by category**: Command name is `displaytag`; this command will display
    the products under a category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display by category history**: Command name is `taghistory`; this command
    will display the history by category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visits for a book**: Command name is `visittoday`; this will give total number
    of unique visitors in a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Purchases for a book**: Command name is `purchasestoday`; this will give
    the total number of unique visitors who purchased the item in a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The design is kept very simple for this simple e-commerce site. To understand
    the entire application, have a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple e-commerce – a Redis backed e-commerce site](img/0123OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple design for out simple e-commerce site
  prefs: []
  type: TYPE_NORMAL
- en: 'The prerequisites for this exercise are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: Any browser with a `REST` plugin or HTTP client plugin. I will
    be using Chrome browser with a `REST` client plugin called `POSTMAN`. If you are
    comfortable with any other plugin then be my guest. The application would work
    without any problem if we replace this client with a pure Java program, for example
    Apache Http Client. The services in this simple e-commerce application are `Get`
    based. In production system, we should have `POST` but for display purposes, `Get`
    is chosen here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: Any web application server. We will be using Tomcat. You can use
    any web application server of your choice but creation of servlets should be done
    accordingly. If you want to use something like Node.js, then code will change
    accordingly but design philosophy would remain the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datastore**: Needless to say that Redis will be the datastore here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we dive into the code, it is important to understand the evolution process
    that led to a state wherein we are using Redis. As discussed earlier, the two
    categories on the basis of which this web application is segregated are stated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Session and catalogue management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's spend some time and understand how they have evolved over a period of
    time and how Redis comes into picture. We will understand the code for this application
    thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every web application has session in one way or another. Session management
    captures information of user activity which can be used for the user and by the
    user. Information for the shopping cart or the wish list can be used by the user,
    and the same information can be used by the back-end systems to analyze user preferences
    and pass promotional and campaign management schemes back to the user. This is
    one of the common use cases in the e-commerce platform. Information stored in
    session management is always the recent information and the end user expects performance
    around it, or in other words, the user outsources his recent memory to the system
    and expects the system to take care of it. The end user might not know the level
    of detailing and activity that happens behind the scene but expects the information
    stored in a session to be acted upon fast and as efficiently as his brain.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the user expects even more than what his brain can process; be
    it shopping cart purchases, or putting things in a wish list, or reminding him
    of a certain activity which he might have forgotten. In other words, the end users
    are closest to this data as compared to any other data. They remember this data
    and expect the system to match it, which results in more personalized involvement
    of the user with the system or the website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Session management](img/0123OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User and his interaction with an e-commerce platform
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram is a representation of how the user interacts with the
    system (website). When the user browses a website, he/she has an idea of what
    he is looking for. Let's say in our case it's some music he is looking for and
    after searching for the music, the user will put the music tracks in the shopping
    cart. It is also possible that the user might be interested in some other music
    CD of the same genre or interested in the comments of the other buyers in the
    *comments section*. At this point, the user might be interested in buying his/her
    music CD in the shopping cart or keeping it in the shopping cart to buy it in
    near future. One thing the user expects here is that when he logs into the system
    again, the system should remember the products that he had put in the shopping
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: There are couple of things that are happening here. Firstly, the user is interacting
    with the system and the system is responding by storing the user's choices, recording
    the user's activities, and so on. Secondly, the user has pushed information which
    he might find interesting, thus offering him wide choices as well as educating
    him about what people are commenting about the product, thereby helping him take
    a decision. In this section, we will be talking more about the part where the
    user is storing his information, and call it session management.
  prefs: []
  type: TYPE_NORMAL
- en: Session data has high importance and stays in the users' mind, but the lifespan
    of this data is short (until the time the product is delivered or until the attention
    shifts to another product). This is where session management comes into picture
    and in this section we are going to go a bit deeper as to how Redis can help us
    in solving this highly critical problem.
  prefs: []
  type: TYPE_NORMAL
- en: To handle session data, the earliest and easiest option has been using the memory
    of the application server itself. Back in the day the web application had limited
    capability and offered limited services. Usage of application server memory was
    the order of the day. But as the web became more accessible, and people started
    to use web more in their daily lives, websites grew rapidly and to survive competition
    between web applications had to exist. This required the web application to have
    more compute and memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: '![Session management](img/0123OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling web application with memory to store session data
  prefs: []
  type: TYPE_NORMAL
- en: The common technique was to replicate the data and load balance the system so
    that all the web servers were in the same state and requests could be catered
    from any of the web applications. This technique had some issues as the session
    management was tightly coupled with the web servers, it provided limited scalability,
    and when concurrency increased this pattern became an anti-pattern. Another limitation
    this technique had was that as data in session management grew, this pattern proved
    problematic since session data was stored in the memory and the amount of memory
    that could be allocated for session management was contested by the memory requirement
    of business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The next logical step was to decouple the session management from the web application
    servers executing business logic. This step was in the right direction since now
    it provided more scalability as the web servers were free from doing the session
    management which required syncing up state with peers frequently.
  prefs: []
  type: TYPE_NORMAL
- en: '![Session management](img/0123OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling web application with RDBMS to store session data
  prefs: []
  type: TYPE_NORMAL
- en: This approach, though in the right direction, had some problems—mainly with
    the choice of datastore used. RDBMS are used to store relational data and are
    very efficient in dealing with those types of data. Session data on the other
    hand is more like key value pair and does not have the kind of relationship that
    is expected out of transactional data. The problem with storing session data in
    RDBMS was that performance took a hit since RDBMS was never engineered for this
    kind of data though scaling out of web application server was much easier.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in this evolution process was using a datastore which provided
    the scalability and also performance. The obvious choice was to use a cache engine
    which stores information in the memory so that performance becomes faster and
    the scalability remains good, because session data decoupled from web application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Session management](img/0123OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling web application with cache as front end over RDBMS to store session
    data
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is from functional requirements and from maintainability
    perspective. From a maintainability perspective, the cache engine depends upon
    RDBMS for data persistence since most of the caching engines do not have disk
    persistence and depend upon RDBMS for fault management. There are some cache engines
    that provide persistence mechanisms, but the big problem comes from a functional
    perspective since they store everything as a key value where value is a string.
    It is the responsibility of the program to convert the data in string to the information
    pattern they are interested in and then take the value out. Take for example the
    value stored for a user profile which has hundreds of attributes stored in the
    session data. If the user were to take few attributes out, then in that case the
    user has to fetch the entire dataset, construct the object, and then fetch the
    required attributes. Another problem is that many a times we need session data
    for a fixed duration of time and after that the usability of the data is not there.
    In those cases, cache engines and RDBMS do not prove beneficial since they do
    not have a in-built mechanism of *time to live* for data then to store. To achieve
    this feature, we have to write a trigger to clean the data from RDBMS and then
    from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Redis comes in handy in these cases, where we store information the way we want
    to use, as it provides data structures to hold values. In case of session management,
    we can have a map to logically group attributes under it. If we need to take values
    out, we can select the values that we want to change or add more attributes to
    it. Moreover, the performance aspect in Redis also makes it suitable for session
    management. Redis also has features called **time to live** (**TTL**) feature
    to clean the data after the time is over. This way we can have separate TTL for
    the keys we require depending upon the requirement and also change the TTL at
    runtime. Redis can be used to have scalable and high performing session management.
  prefs: []
  type: TYPE_NORMAL
- en: '![Session management](img/0123OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling web application with cache as front end over RDBMS to store session
    data
  prefs: []
  type: TYPE_NORMAL
- en: Catalogue management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Catalogue management is the information about the products and items which the
    website is keen to offer. The information stored under catalogue management can
    be a product's cost, dimension, color, and so on, that is meta information of
    a product. This information, unlike session information, is read centric. But
    like session data, catalogue data has seen evolution starting with RDBMS systems
    which were the natural choice back then because of lack of choices to store data.
    The problem with RDBMS system was that it did not offer performance. Also, the
    fixed schema centric systems added to the problems since the meta information
    of products changed with the products themselves. Some products had color, length,
    breadth, and height whereas some had author, number of pages, and ISBN. Creating
    schemas to accommodate this requirement was always cumbersome and, at some point
    or another we have faced this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![Catalogue management](img/0123OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Catalogue management with RDBMS as datastore
  prefs: []
  type: TYPE_NORMAL
- en: The natural evolution process to overcome this fixed schema problem was to store
    the information in XML format and to cache this information in some caching engine.
    This mechanism helped the designers and architects to overcome the problem of
    fixed schema and performance. But this technique came with its own share of problems;
    the data which was in XML had to be converted to a programming language object
    before usage. The other problem was that if a property value had to be changed,
    then either the value was changed in the XML first and then changed in the RDBMS,
    or the value was changed in the RDBMS first and then in the cache. These techniques
    had problems in maintaining consistent state across RDBMS and the cache engines,
    and it required special attention especially if the property was related to the
    cost of the product.
  prefs: []
  type: TYPE_NORMAL
- en: '![Catalogue management](img/0123OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling state management between cache engine and RDBMS
  prefs: []
  type: TYPE_NORMAL
- en: Redis once again comes in handy to store catalogue data. Redis being schema
    less and as a datastore provides data structures, such as maps which can be used
    to store as many properties as the product requires. Apart from that, it also
    provides capability to change, add, and read the properties without bringing the
    entire dataset to work upon. Another advantage of having Redis is that we need
    not do *object to data* conversions, and vice versa, as this does away the very
    need to have hundreds of data objects in the system; thus making the code base
    smaller and development faster.
  prefs: []
  type: TYPE_NORMAL
- en: Online analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Online analytics or real-time analytics is a relatively new requirement that
    is gaining popularity. The whole idea behind online analytics is to provide a
    richer and engaging user experience to the user. Online analytics works in a way
    where data is collected, analyzed, and crunched in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: In good old early days of web revolution, analytics had only one principle stake
    holder which was the website management team. They used to collect the data and
    do analysis in the offline mode, and then used to apply it for business usage.
    This technique of offline analysis is still needed. However, in today's world
    when everything is connected to social media, it is imperative that the user's
    views, his/her social group, and his/her opinion should be reflecting in his/her
    shopping experience. For example, let's say a user and his social group are talking
    favorably about some music or book. When the user checks into his favorite e-commerce
    site, the home page of that site has this product in the recommendation section.
    This gives high probability that the user might end up buying the product. This
    degree of personalization is very important for the website to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: The kind of analysis that is happening in this case is in soft real-time, that
    is when the user is interacting with his social group, data in parallel is getting
    crunched and the context is getting created which is used by the website to create
    a personalized shopping experience for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Another kind of analysis that happens is based on the context the user creates
    while browsing products in the website. This context creation is collaborative
    in nature though the users might be unaware of this fact. The higher the number
    of users searching for a product or buying the product, the more popular the product
    becomes. The complexity in this type of analytics is that it's real-time and performance
    is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, if we compare the offline analytics engine with real-time analytics,
    the difference is that the analytics engine which was outside the realm of business
    logic becomes a part of the business logic, practically sharing the same compute
    resource. Another difference is that the amount of data is relatively small in
    case of real-time analytics but its contextual data from a user''s shopping perspective
    is what makes it important from a business perspective. The following figure explains
    the difference between offline and online (real-time) analytics in a concise manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online analytics](img/0123OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Offline and online analytics in web application
  prefs: []
  type: TYPE_NORMAL
- en: Now if the same real-time were to be done using a datastore such as RDBMS, the
    problem would be in performance because this kind of crunching will consume a
    lot of computing resources, and other business use cases executing in parallel
    might take a hit because of this. RDBMS such as Oracle, can provide the capability
    of scaling but they come with a price, that is they are pretty expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Redis can be a very good datastore which can be used for online analytics. As
    Redis is memory-based, it's very fast and achieving scalability in Redis is much
    easier. On top of it, Redis provides data structures such as Set and Sorted set,
    which can be very helpful for segregating and aggregating data for real-time analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage Redis has to offer is that it's open source and runtime resource
    requirement of Redis is very less. Moreover, the concurrent calls handling capability
    in Redis is pretty impressive.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample application that we will develop, we will see some real-time analytics
    in form of a recommendation engine which will recommend products based on its
    popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation – simple e-commerce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin with some code to get a clear understanding of how to use Redis
    for our session, catalogue management, and online analytics. But before we do
    that, let''s finalize on the buckets which we will be creating to store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bucket name "<username>@userdata"**: This bucket will store user profile
    data such as name, email, phone number, address, and so on. From the application''s
    perspective, this bucket will be `sessionID` of the user which will bind this
    bucket to `"<sessionID>@sessiondata"`. The data structure used here is Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<sessionID>@sessiondata"**: This bucket will store session data
    of the user such as lastlogin and loginstatus. Apart from session data, this will
    also store the user name as this is the key which will bind `"<username>@userdata"`
    bucket to this bucket. The data structure used here is Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<sessionID>@browsinghistory"**: This bucket will store the browsing
    history of the user based on his session ID. Data structure used here is Sorted
    Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<name>@purchasehistory"**: This will give the purchase history
    of the user. Data structure used here is Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<sessionID>@shoppingcart"**: This bucket will store the shopping
    cart items of the user. Data structure used here is Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "sessionIdTracker"**: This will track the total number of users
    in the system. Data structure used here is Bitmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<productname>"**: This will store the product attributes. Being
    schemaless, it can store any number of attributes for the product. Data structure
    used here is Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<tags>"**: This will store the product mapped to this tag. For
    example, `"Learning Redis"` can be tagged under tags such as Redis, NoSQL, database,
    and so on. Data structure used here is Sorted Set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<productname>@visit"**: This will store the number of unique
    visitors. In production system, this can be made on a daily basis to give a statistics
    of how many people visited this product on a day-to-day basis and help calculate
    how many people visited the site on a monthly basis. Data structure used here
    is Bitmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket name "<productname>@purchase"**: This will store the number of unique
    visitors who purchased the product. Like the previous bucket, this bucket can
    be made on a daily basis to give an aggregate count for a week or month. Data
    structure used here is Bitmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a hang of how our database is going to look like, let's get
    to the servlets which are going to accept service request from the browser and
    send a HTTP response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two servlets in this simple e-commerce website. They will be accepting
    all the commands and are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UserApp servlet**: This will cater to all the commands pertaining to the
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProductApp servlet**: This will cater to all the commands pertaining to the
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing that we have to keep in mind is that the order of execution is not
    dependent upon the order in which the servlets or the command within the servlet
    is listed. For example, there is no point in registering or logging in unless
    we have provisioned a few products in the system, or there is no point seeing
    recommendation unless we have browsed or bought few products as this will create
    the graph data for the recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a hang of all the utility class that will be used in the code listing
    in the rest of the chapter. The list of all such classes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commands**: This is the parent and abstract class for all the commands that
    will be implemented in the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Default command**: This is default command which will get into action if
    the command passed in the URL is not recognized by the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Argument**: The primary goal of this class is to wrap all the name value
    attributes coming in the request and to put it in a map which can be used in the
    program later on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the utility classes across the application, let's get
    to the classes which will be instrumental in giving a shape to the application.
  prefs: []
  type: TYPE_NORMAL
- en: ProductApp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ProductApp servlet will contain commands around product management. The code
    for ProductApp servlet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the first servlet ready, let''s look into the commands which
    we are implementing for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CommisionProductCommand`: This will implement the `commission` command. The
    implementation of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=commission&args=name=Redisbook-1:cost=10:catagory=book:author=vinoo:tags=Redis@5,NoSql@3,database@2,technology@1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This, for all reasons, is the first command that should get called
    since this command is going to provision products into the system. The two parts
    in the URL that need to be focused on are the `command` which is equal to `commission`,
    and the argument part, that is `args`. Here `args` contains the attributes of
    the book, for example `name=Redisbook-1`. The attribute `tags` represents the
    words the book will be associated with. The tags for this book are `Redis@5`,
    `NoSQl@3`, `database@2`, and `technology@1`. The tags are associated with the
    weights that will come into play whenever recommendation engine kicks in. Whenever
    a user is browsing for `Redisbook-1`, he will be shown more recommendations for
    Redis books. Here the user will be shown five books on Redis, three books on NoSQL,
    and so on and so forth. For the sake of simplicity in this application, the sum
    total of weights should be 10.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for successful product commissioning
  prefs: []
  type: TYPE_NORMAL
- en: To create test data, commission few test books with different weights, few with
    the same tags, and few with slightly different tags. Make sure that the sum total
    of weights is equal to 10.
  prefs: []
  type: TYPE_NORMAL
- en: '`Display command`: This will implement the `display` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=display&args=name=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This program will display the attributes of the book. The two
    parts in the URL that need to be focused on are the command which is equal to
    display, and the argument part, that is args. Here, args contains a single attribute
    called name.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for successful displaying of a product attributes
  prefs: []
  type: TYPE_NORMAL
- en: '`DisplayTagCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-com/productApp?command=displaytag&args=tagname=nosql`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This program will display books on the basis of hits for a book.
    The two parts in the URL that need to be focused on are the `command`, which is
    equal to `displaytag`, and the argument part, that is `args`. Here `args` contains
    a single attribute called `tagname`. Since I have already commissioned a book
    into the system, the output is as shown in the next image. Visit this tag later
    when a user starts browsing for products; the order will change when you fire
    the same command.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for successful displaying of a products belonging to a tag that is
    NoSQL
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateTag`: This will implement the `UpdateTagCommand` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=updatetag&args=sessionid=<sessionID
    of the user>:productname=<product name which the user is browsing or has bought>:action=<browse
    or buy>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command is called when a user is browsing a product or purchasing
    a product. The idea behind this command is that when a user is browsing a product
    or purchasing a product, it is gaining popularity, and so proportionally, the
    popularity of the product should increase among other products in the same tag.
    So in short, it helps calculate the most popular product in its category (tags).
    To test this command, make sure you create some dummy users and make them log
    into the system and then hit the `browse` command URL or `buy` command URL.'
  prefs: []
  type: TYPE_NORMAL
- en: '`VisitTodayCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=visitstoday&args=productname=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command can be executed if we want to check how many unique
    users visited the product. The data structure implementing this use case is a
    Bitmap. Bitmap in Redis has a consistent performance irrespective of the data
    it holds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying total number of viewers in a day for the product redisbook-1
  prefs: []
  type: TYPE_NORMAL
- en: '`PurchasesTodayCommand`: This will implement the `purchasestoday` command.
    The implementation of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=purchasestoday&args=productname=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command can be executed if we want to check how many unique
    users purchased the given product. The data structure implementing this use case
    is a Bitmap. Bitmap in Redis has a consistent performance irrespective of the
    data it holds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying total number of buyers in a day for the product redisbook-1
  prefs: []
  type: TYPE_NORMAL
- en: '`TagHistoryCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=Redis`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command can be executed if we want to see the tag history
    of a product. The ranking of the product is based on the points accumulated by
    individual products belonging to the tag. In the following sample we have shown
    the rankings for the tag `Redis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying tag history for the tag redis
  prefs: []
  type: TYPE_NORMAL
- en: 'Test URL: `http://localhost:8080/simple-ecom/productApp?command=taghistory&args=tagname=nosql`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command can be executed if we want to see the tag history
    of a product. The ranking of the product is based on the points accumulated by
    individual products belonging to the tag. In the following sample we have shown
    the rankings for the tag `nosql` to showcase the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductApp](img/0123OS_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying tag history for the tag nosql
  prefs: []
  type: TYPE_NORMAL
- en: UserApp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UserApp servlet will contain commands around user management and analytics
    over user. The code for UserApp servlet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the first servlet ready, let''s look into the commands which
    we are implementing for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegistrationCommand`: This will implement the `register` command. The code
    for the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=register&args=name=vinoo:password=******:address=test
    address`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will register the user into the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `register`,
    and the argument part, that is `args`. This represents attributes in key value
    pairs. Following figure represents the success scenario if the registration is
    a success. The next logical step would be to log in the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying user registration
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginCommand`: This will implement the `login` command. The code for the command
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=login&args=name=vinoo:password=******`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will log in the user into the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `login`,
    and the argument part, that is `args`. The argument will contain the name and
    password. The important part that needs to be focused on is that upon execution,
    this command will return a session ID code. This session ID is needed in most
    of the commands the user will execute. So if you are running a sample of this,
    make sure to store this number in a text pad for later use. In production system,
    this can be stored in the memory of the browser or client. The following figure
    tells me that the session ID generated for me is **26913441**. I will be using
    this for the rest of the samples I execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying user login and user session ID
  prefs: []
  type: TYPE_NORMAL
- en: '`MyDataCommand`: This will implement the `mydata` command. The code for the
    command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=mydata&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will show user''s data from the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `mydata`,
    and the argument part, that is `args`. The argument has only session ID as the
    key value pair in the URL. The following figure shows the outcome of the command.
    Some of the attributes are not shown as they could not be accommodated in the
    figure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for displaying user data
  prefs: []
  type: TYPE_NORMAL
- en: '`EditMyDataCommand`: This will implement the `editmydata` command. The code
    for the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=editmydata&args=name=vinoo:password=******:address=changed
    address:phone=9111111119:sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will show user''s data from the system. The two parts
    in the URL that need to be focused on are the `command`, which is equal to `mydata`,
    and the argument part, that is `args`. The argument has new and edited key value
    pairs. Make sure that the session ID is correct in the URL. The following figure
    is what you should be seeing in the output. Now you can always go back and execute
    the previous command `mydata` which will show the newer values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for successful editing of user data
  prefs: []
  type: TYPE_NORMAL
- en: '`BrowseCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=browse&args=sessionid=26913441:browse=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will show the product''s data from the system. The
    two parts in the URL that need to be focused on are the `command`, which is equal
    to `browse`, and the argument part, that is `args`. The argument has session ID
    of the user and name of the product that the user is browsing. There are a couple
    of things that are happening here. The user gets to see the product details and
    in the background a request is sent to the `updatetag` command to increase the
    popularity of the respective product. In our case, the product is `Redisbook-1`.
    For the sake of testing, browse all the products you have commissioned into the
    system multiple numbers of times.'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot when user wants to browse a product and see its details
  prefs: []
  type: TYPE_NORMAL
- en: '`RecommendByProductCommand`: This will implement the `recommendbyproduct` command.
    The code for the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will recommend products based on the product being
    browsed. The two parts in the URL that need to be focused on are the `command`,
    which is equal to `recommendbyproduct`, and the argument part, that is `args`.
    The argument has session ID of the user and product `Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: This command will recommend top products for the user based on the purchase
    and browse history of the product. This will factor in what categories the product
    belongs to and the weight that needs to be factored for product display. This
    in a way is the online real-time analytics that kicks into action when the user
    is browsing a product. In the figure, maximum number of results are for `Redis`
    tag as that is the tag that has got the maximum weight. In production, some filtering
    needs to be done for duplicate results that might occur for similar products that
    share the same tags. This filtering can be done at the client side, thus saving
    the compute resource at the server side.
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot when user wants to browse a product and see other recommended products
  prefs: []
  type: TYPE_NORMAL
- en: '`Add2CartCommand`: This will implement the `add2cart` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=add2cart&args=sessionid=26913441:product=Redisbook-1@2,Redisbook-4@1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will put products and their quantities into the shopping
    cart. The two parts in the URL that need to be focused on are the `command`, which
    is equal to `add2cart`, and the argument part, that is `args`. The argument contains
    two key value pairs. First is the session ID and second is the name of the product
    and the quantity separated by special character `@`. The following figure shows
    that I have successfully added the products in my shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot when user wants to add products to his cart
  prefs: []
  type: TYPE_NORMAL
- en: '`ShowMyCartCommand`: This will implement the `showmycart` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=showmycart&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will put products and their quantities into the shopping
    cart. The two parts in the URL that need to be focused on are the `command`, which
    is equal to `showmycart`, and the argument part, that is `args`. The argument
    contains the session ID only. The following figure shows my shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot when user wants to see his cart
  prefs: []
  type: TYPE_NORMAL
- en: '`EditCartCommand`: This will implement the `editcart` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=editcart&args=sessionid=26913441:product=Redisbook-4@0,Redisbook-2@1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will edit the products and their quantities in the
    shopping cart. The two parts in the URL that need to be focused upon are the `command`,
    which is equal to `editcart`, and the argument part, that is `args`. The argument
    contains key value pairs of the products and their new quantities. If the quantity
    is marked as `0`, then the product will be removed from the shopping cart. On
    executing the `showmycart` command again, the cart should reflect the newer values.
    The following figure shows the newer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot when user wants to see his cart after editing his cart
  prefs: []
  type: TYPE_NORMAL
- en: '`BuyCommand`: This will implement the `browse` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=buy&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will buy the products in the shopping cart. Since
    this is a demo website, there is no connection to the payment gateway, but the
    intention of having this command was to increase the `hit` counter when a purchase
    is made. When a product is bought, the recommendation engine increases its points
    by `10` as compared to `1` when the product is browsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Doing dummy purchase
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it would be pretty interesting to go back and revisit the `recommendbyproduct`
    command. The order in which the products got displayed would change, since every
    buy gives `10` points to the product popularity. The `recommendbyproduct` is for
    the product `Redisbook-1`. And the test URL is as follows: `http://localhost:8080/simple-ecom/userApp?command=recommendbyproduct&args=sessionid=26913441:productname=Redisbook-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for rearranged product list after successful purchase (online analytics)
  prefs: []
  type: TYPE_NORMAL
- en: '`MyStatusCommand`: This will implement the `stats` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=stats&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will give the browsing history of the user. Here
    the result will be listed on the basis of frequency at which the user is revisiting
    a particular product. The two parts in the URL that need to be focused on are
    the `command`, which is equal to `stats`, and the argument part, that is `args`.
    The argument contains the session ID of the user. The following figure represents
    the browsing history of the user with session ID **26913441**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for viewing browsing history of a user
  prefs: []
  type: TYPE_NORMAL
- en: '`MyPurchaseHistoryCommand`: This will implement the `mypurchasehistory` command.
    The implementation of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=mypurchasehistory&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will give the purchasing history of the user. Here
    the result will be listed on the basis of dates on which the user bought particular
    products. The two parts in the URL that need to be focused on are the `command`,
    which is equal to `stats`, and the argument part, that is `args`. The argument
    is session ID of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![UserApp](img/0123OS_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot for viewing purchase history of a user
  prefs: []
  type: TYPE_NORMAL
- en: '`ReloginCommand`: This will implement the `relogin` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=relogin&args=name=vinoo:password=******`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will again check the user and password of the user
    and return back the associated session ID of the user. The idea is to have session
    which can exist many shopping and browsing sessions of a user.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LogoutCommand`: This will implement the `logout` command. The implementation
    of the command is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Test URL: `http://localhost:8080/simple-ecom/userApp?command=logout&args=sessionid=26913441`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: This command will log out the user from the system, and based
    on the session ID, delete all the datastore of the user, such as purchase history,
    shopping cart, and browsing history.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a hang of the commands, let's look into the package which will
    take care of the connection management and other functional calls with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: RedisDBManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is the backbone of this application; it is responsible for connecting
    with the database and managing the connection pool. It also has some utility functions.
    The implementation is explained by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ProductDBManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class extends the `RedisDBManager` and is responsible for product related
    functional calls to the data base. This class is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: AnalyticsDBManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class extends the `RedisDBManager` and is responsible for analytics-related
    functional calls to the data base. The class is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ShoppingCartDBManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class extends the `RedisDBManager` and is responsible for shopping cart-related
    functional calls to the data base. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: UserCartDBManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class extends the `RedisDBManager` and is responsible for user related
    functional calls to the data base. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So in this chapter, we learnt how to make a simple e-commerce site with Redis
    as its backbone. Also, we learnt how Redis can come handy for doing online analytics.
    This sample site lacked the capability for scalability which we learnt in the
    previous chapters. I would urge the readers to add that capability to this code
    base as an exercise and have fun with this awesome datastore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will divulge how to use Redis in business applications,
    and make a few applications that are commonly used in all the business applications.
  prefs: []
  type: TYPE_NORMAL
