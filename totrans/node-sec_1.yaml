- en: Chapter 1. Introduction to Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js has ushered in the age of server-side JavaScript, the next logical
    step from the renaissance that client-side JavaScript has experienced over the
    last few years. While Node.js is not the first server-side JavaScript implementation,
    it has certainly become the most popular. By leveraging the best features of JavaScript
    as a language and nurturing a vibrant community, Node.js has become a tremendously
    popular platform and framework, with no signs of slowing down. A great description
    of what Node is can be found at [http://nodejs.org/](http://nodejs.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a platform built on Chrome's JavaScript runtime for easily building
    fast, scalable network applications. Node.js uses an event-driven, non-blocking
    I/O model that makes it lightweight and efficient, perfect for data-intensive
    real-time applications that run across distributed devices.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: History of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project began as the brain-child of Ryan Dahl back in 2009\. At JSConf.eu
    (a conference held annually in Europe) that year, he made his presentation and
    changed the face of JavaScript development. His speech included an impressive
    demonstration of a complete IRC server that had been written in roughly 400 lines
    of JavaScript. During his presentation, he outlined why he started the project,
    why JavaScript became such an integral part of it, and what goals he sought to
    accomplish along the way in the field of server programming – particularly with
    regards to how we deal with input and output (I/O).
  prefs: []
  type: TYPE_NORMAL
- en: Later that year, the **npm** project began, with the goal of managing packages
    for Node.js applications, as well as creating a publicly available registry for
    sharing code between Node.js developers. As of version 0.6.3 of Node.js, npm is
    deployed and installed alongside Node.js, making it the de facto package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How Node.js differs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes Node.js different from other platforms is in how it approaches I/O.
    It uses an event-loop in conjunction with asynchronous I/O, which allows it to
    achieve a high level of concurrency with a light footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, when a program needs some sort of external input, it does so in
    a synchronous fashion. The following line of code should be very familiar to any
    programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All we are doing here is querying a SQL database for a list of all users, and
    then we are printing out the first user''s name. When querying a database like
    this, there are many intermediary steps that need to be taken, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a connection to the database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmitting the request over the network to that server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server itself needs to process the request after receiving it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server must transmit the response back over the network to our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This list does not cover all the specifics, as there are many more factors
    than are necessary for the point to be made. By looking at our source code, this
    is treated as an instantaneous action, but we know better. We often neglect this
    wasted time because it is so fast that we don''t notice it happening. Consider
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The Cost of I/O |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| L1-cache | 3 cycles |'
  prefs: []
  type: TYPE_TB
- en: '| L2-cache | 14 cycles |'
  prefs: []
  type: TYPE_TB
- en: '| RAM | 250 cycles |'
  prefs: []
  type: TYPE_TB
- en: '| Disk | 41,000,000 cycles |'
  prefs: []
  type: TYPE_TB
- en: '| Network | 240,000,000 cycles |'
  prefs: []
  type: TYPE_TB
- en: Each I/O operation has a cost, which is paid directly in a program that uses
    synchronous I/O. There could easily be millions and millions of clock cycles that
    occur before the program can progress.
  prefs: []
  type: TYPE_NORMAL
- en: When writing an application server, a program like this can only serve one user
    at a time, and the next user cannot be served until all the I/O and processing
    is complete for the previous user. This is unacceptable of course, so the easiest
    solution is to create a new thread for each incoming request, so they can run
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the **Apache** web server works, and it is not difficult to implement.
    However, as the number of simultaneous users increase, the amount of memory used
    also increases. Each of those threads requires overhead at the operating system
    level, and it adds up pretty quickly. In addition, the overhead of context switching
    between those threads is more time consuming than desired, further compounding
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The **nginx** web server uses an event loop at its core to handle processes.
    By doing so, it is able to handle more simultaneous users at once, with fewer
    resources. An event loop requires that the bits of processing be broken up into
    small pieces, and run in a single queue. This removes the high cost of creating
    threads, switching back and forth between those threads, and requires less demand
    of the overall system. At the same time, it fills in the processing gaps, particularly
    those that occur during the wait for I/O to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js takes the event-driven model that nginx uses to such great success,
    and it exposes that same capability for many types of applications. In Node.js,
    all I/O is entirely asynchronous and does not block the rest of the application
    thread. The Node.js API accepts function parameters (usually known as a "callback
    function") for all I/O operations. Node.js then fires off that I/O operation,
    and lets another thread outside the application do the processing. After that,
    the application is free to continue handling other requests. Once the requested
    operation is complete, the event-loop is notified, and the callback function is
    invoked with the results.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, waiting for I/O to complete is the most expensive part of many
    applications in terms of raw processing time. With Node.js, the time spent waiting
    for I/O is completely detached from the rest of your application's processing
    time. Your application just uses callback functions to process results as simple
    events, and JavaScript's ability to use closure retains the function's context,
    despite being executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to take up the task of writing a multi-threaded application, you
    would have to concern yourself with concurrency problems like deadlocks, which
    are very difficult (if not impossible) to reproduce and debug in real-world applications.
    With Node.js, your primary application logic runs on a single thread, free of
    such concurrency problems, while the time-consuming I/O is handled on your behalf
    by Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other platform, Node.js has an API developers can use to write their
    applications. JavaScript itself lacks a standard library, particularly for performing
    I/O. This actually turned out to be one of the reasons that Ryan Dahl chose JavaScript.
    As the core API can be built from the ground up, without needing to worry about
    creating conflicts with a standard library, in case it is done wrong (given JavaScript's
    history, this is not an unreasonable assumption).
  prefs: []
  type: TYPE_NORMAL
- en: 'That core library is minimalistic, but it does include modules for the essentials.
    This includes, but is not limited to: filesystem access, network communication,
    events, binary data structures, and streams. Many of these APIs, while not difficult
    to use, are very low-level in implementation. Consider this "Hello World" demonstration
    straight from the Node.js website (with comments added):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This server uses the **http** core module to set up a web server that simply
    sends "Hello World" to anyone who makes a request of it. This is a simple example,
    but without comments, this consists of only six lines of code in all.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js team has opted to keep the core library limited in scope, leaving
    the community of developers to create the modules they need for everything else,
    such as database drivers, unit-testing, templating, and abstractions for the core
    API. To aid in this process, Node.js has a package manager called npm.
  prefs: []
  type: TYPE_NORMAL
- en: npm is the tool that handles installing dependencies for Node.js applications.
    It opts for locally bundled dependencies, rather than using a single global namespace.
    This allows different projects to have their own dependencies, even if the version
    varies between those projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/supportand](http://www.packtpub.com/supportand)
    register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to allowing for the use of third-party modules, npm also makes contributing
    to the registry a public affair. Adding a module to the registry is as simple
    as a single command, making the barrier to enter extremely low. Today, the npm
    registry has over 42,000 packages listed and is growing faster by the day.
  prefs: []
  type: TYPE_NORMAL
- en: With the registry growing so fast, it's obvious there is a vibrant ecosystem
    behind it. I can personally attest to the fact that the Node.js developer community
    is very friendly, extremely prolific, and has an enormous amount of enthusiasm.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Node.js applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to securing your application, there are many factors to consider.
    We will start by examining JavaScript itself, then analyze Node.js as a platform,
    and reveal some of the internals that are relevant to the discussion. After that,
    we will investigate considerations and patterns for your applications as a whole.
    Last, we will survey vulnerabilities at the request and response level of your
    applications. By the end of this book, you should have enough understanding of
    the internals of Node.js to not only address what we are discussing here, but
    also to grasp any future vulnerability that may appear for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the history of the Node.js project itself, and
    gave some background to the development environment and community. In the next
    chapter, we will start by looking at security features present within the JavaScript
    language itself.
  prefs: []
  type: TYPE_NORMAL
