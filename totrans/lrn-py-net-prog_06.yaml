- en: Chapter 6. IP and DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every computer that is connected to a network needs an IP address. In [Chapter
    1](ch01.html "Chapter 1. Network Programming and Python"), *Network Programming
    and Python*, an introduction to TCP/IP networking was presented. The IP address
    labels a machine''s network interface with a numeric identifier, which also identifies
    the location of the machine, albeit with limited reliability. **Domain Name System**
    (**DNS**) is a core network service that maps the names to the IP addresses and
    vice-verse. In this chapter, we will mainly focus on manipulating the IP and DNS
    protocols with the help of Python. In addition to this, we will briefly discuss
    the **Network Time Protocol** (**NTP**), which helps in synchronizing the time
    with a centralized time server. The following topics will be discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the network configuration of a local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating the IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GeoIP look-ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with NTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the network configuration of a local machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before doing anything else, let's ask in the Python language, *What's my name?*.
    In networking terms, this is equivalent to finding out the machine's name or the
    host's name. On the shell command-line, this can be discovered by using the `hostname`
    command. In Python, you can do this by using the socket module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we would like to see the local machine IP. This can be seen by using the
    `ifconfig` command in Linux and by using the `ipconfig` command in the Windows
    OS. But, we''d like to do this in Python by using the following built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is the IP of the first network interface. It can also
    show us the IP of the loopback interface (127.0.0.1) if your DNS or hostfile has
    not been configured properly. In Linux/UNIX, the following line can be added to
    your `/etc/hosts` file for obtaining the correct IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This process is known as a host-file based name resolution. You can send a query
    to a DNS server and ask for the IP address of a specific host. If the name has
    been registered properly, then you will get a response from the server. But, before
    making a query to the remote server, let us first discover some more information
    about the network interface and the gateway machine of your network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every LAN, a host is configured to act as a gateway, which talks to the
    *outside* world. In order to find the network address and the netmask, we can
    use the Python third-party library netifaces (version > 0.10.0 ). This will pull
    all the relevant information. For example, you can call `netifaces.gateways()`
    for finding the gateways that are configured to the outside world. Similarly,
    you can enumerate the network interfaces by calling `netifaces.interfaces()`.
    If you would like to know all the IP addresses of a particular interface *eth0,*
    then you can call `netifaces.ifaddresses(''eth0'')`. The following code listing
    shows the way in which you can list all the gateways and IP addresses of a local
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, then this will print a summary of the local network configuration,
    which will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating IP addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often you will need to manipulate IP addresses and perform some sort of operations
    on them. Python3 has a built-in `ipaddress` module to help you in carrying out
    this task. It has convenient functions for defining the IP addresses and the IP
    networks and for finding lots of useful information. For example, if you would
    like to know how many IP addresses exist in a given subnet, for instance, `10.0.1.0/255.255.255.0`
    or `10.0.2.0/24`, then you can find them with the help of the code snippet shown
    here. This module will provide several classes and factory functions; for example,
    the IP address and the IP network has separate classes. Each class has a variant
    for both IP version 4 (IPv4) and IP version 6 (IPv6). Some of the features have
    been demonstrated in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: IP network objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us import the `ipaddress` module and define a `net4` network.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can find some useful information, such as `netmask`, the network/broadcast
    address, and so on, of `net4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `netmask` properties of `net4` will be displayed as an `IP4Address` object.
    If you are looking for its string representation, then you can call the `str()`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can find the network and the broadcast addresses of `net4,`
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'How many addresses does `net4` hold in total? This can be found by using the
    command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, if we subtract the network and the broadcast addresses, then the total available
    IP addresses will be 254\. We can call the `hosts()` method on the `net4` object.
    It will produce a Python generator, which will supply all the hosts as `IPv4Adress`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the individual IP addresses by following the standard Python
    list access notation. For example, the first IP address would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the last IP address by using the list notation for accessing
    the last item of a list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also find the subnet information from the `IPv4Network` objects, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Any `IPv4Network` object can tell about its parent supernet, which is the opposite
    of the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Network interface objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `ipaddress` module, a convenient class is used for representing an interface''s
    IP configuration in detail. The IPv4 Interface class takes an arbitrary address
    and behaves like a network address object. Let us define and discuss our network
    interface `eth0,` as shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network interface objects](graphics/6008OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, a network interface eth0 with the
    `IPv4Address` class has been defined. It has some interesting properties, such
    as IP, network address, and so on. In the same way as with the network objects,
    you can check if the address is private, reserved, or multicast. These address
    ranges have been defined in various RFC documents. The `ipaddress` module's help
    page will show you the links to those RFC documents. You can search this information
    in other places as well.
  prefs: []
  type: TYPE_NORMAL
- en: The IP address objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IP address classes have many more interesting properties. You can perform
    some arithmetic and logical operations on those objects. For example, if an IP
    address is greater than another IP address, then you can add numbers to the IP
    address objects, and this will give you a corresponding IP address. Let''s see
    a demonstration of this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The IP address objects](graphics/6008OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Demonstration of the `ipaddress` module
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `eth0` interface has been defined with a private IP address, which
    is `192.168.1.1,` and `eth1` has been defined with another private IP address,
    which is `192.168.2.1`. Similarly the loopback interface `lo` is defined with
    IP address `127.0.0.1`. As you can see, you can add numbers to the IP address
    and it will give you the next IP address with the same sequence.
  prefs: []
  type: TYPE_NORMAL
- en: You can check if an IP is a part of a specific network. Here, a network net
    has been defined by the network address, which is `192.168.1.0/24,` and the membership
    of `eth0` and `eth1` has been tested against that. A few other interesting properties,
    such as `is_loopback`, `is_private,` and so on, have also been tested here.
  prefs: []
  type: TYPE_NORMAL
- en: Planning IP addresses for your local area network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are wondering how to pick-up a suitable IP subnet, then you can experiment
    with the `ipaddress` module. The following code snippet will show an example of
    how to choose a specific subnet, based on the number of necessary host IP addresses
    for a small private network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, then it will show an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: GeoIP look-ups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, it will be necessary for many applications to look-up the location
    of the IP addresses. For example, many website owners can be interested in tracking
    the location of their visitors and in classifying their IPs according to criteria,
    such as country, city, and so on. There is a third-party library called **python-geoip,**
    which has a robust interface for giving you the answer to your IP location query.
    This library is provided by MaxMind, which also provides the option for shipping
    a recent version of the Geolite2 database as the `python-geoip-geolite2` package.
    This includes the GeoLite2 data created by MaxMind, which is available at [www.maxmind.com](http://www.maxmind.com)
    under the creative commons Attribution-ShareAlike 3.0 Unported License. You can
    also buy a commercial license from their website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to use this Geo-lookup library.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will show an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about this package from the developer's website,
    which is at [http://pythonhosted.org/python-geoip/](http://pythonhosted.org/python-geoip/).
  prefs: []
  type: TYPE_NORMAL
- en: DNS look-ups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IP address can be translated into human readable strings called domain names.
    DNS is a big topic in the world of networking. In this section, we will create
    a DNS client in Python, and see how this client will talk to the server by using
    Wirshark.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few DNS cleint libraries are available from PyPI. We will focus on the `dnspython`
    library, which is available at [http://www.dnspython.org/](http://www.dnspython.org/).
    You can install this library by using either the `easy_install` command or the
    `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Making a simple query regarding the IP address of a host is very simple. You
    can use the `dns.resolver` submodule, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make a reverse look-up, then you need to use the `dns.reversename`
    submodule, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create an interactive DNS client script that will do a complete
    look-up of the possible records, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script with some input, then you will have an output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting DNS client/server communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, perhaps you noticed how we captured network packets between
    the client and the server by using Wireshark. Here is an example of the session
    capturing, while a Python package was being installed from PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting DNS client/server communication](graphics/6008OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FDNS client/server communication
  prefs: []
  type: TYPE_NORMAL
- en: In Wireshark you can specify `port 53` by navigating to **Capture** | **Options**
    | **Capture filter**. This will capture all the DNS packets that were sent to/from
    your machine.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following screenshot, the client and the server have several
    request/response cycles the DNS records. It was started with a standard request
    for the host's address (A) and it was followed by a suitable response.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting DNS client/server communication](graphics/6008OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look deep inside a packet, then you can see the request format of the
    response from the server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting DNS client/server communication](graphics/6008OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: NTP clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final topic that will be covered in this chapter is NTP. Synchronizing time
    with a centralized time server is a key step in any corporate network. We would
    like to compare the log files between various servers and see if the timestamp
    on each server is accurate; the log events may not then co-relate. Many authentication
    protocols, such as Kerberos, strictly rely on the accuracy of the time stamp reported
    by the client to the servers. Here, a third-party Python `ntplib` library will
    be introduced, and then the communication between the NTP client and the server
    will be investigated.
  prefs: []
  type: TYPE_NORMAL
- en: To create an NTP client, you need to call the ntplib's `NTPCLient` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have selected `pool.ntp.org,` which is a load-balanced webserver. So,
    a pool of the NTP servers will be ready to respond to the client's request. Let's
    find more information regarding this from the response that was returned by an
    NTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The detailed response will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding information was supplied by the NTP server to the client. This
    information can be used to determine the accuracy of the supplied time server.
    For example, the stratum value 2 indicates that the NTP server will query another
    NTP server with the stratum value 1, which may have a directly attached time source.
    For more information about the NTP protocol, you may either read the RFC 958 document
    at [https://tools.ietf.org/html/rfc958](https://tools.ietf.org/html/rfc958) or
    visit [http://www.ntp.org/](http://www.ntp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the NTP client/server communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be able to learn more about NTP by looking at captured packets. For
    this purpose, the preceding NTP client/server communication has been captured
    as shown in the following two screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: The first screenshot shows the NTP client request. If you look inside the flag
    fields, then you will see the client's version number.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the NTP client/server communication](graphics/6008OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the NTP server response has been shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the NTP client/server communication](graphics/6008OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the standard Python libraries for IP address manipulation were
    discussed. Two third-party libraries `dnspython` and `ntplib` have been presented
    to interact with the DNS and the NTP servers respectively. As you have seen through
    the aforementioned examples, these libraries provide you with the necessary interface
    for talking to those services.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will introduce socket programming in Python. This
    is another interesting and popular topic for networking programmers. There, you
    will find both low and high-level Python libraries for programming with BSD sockets.
  prefs: []
  type: TYPE_NORMAL
