- en: Embracing Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every profession and industry has its own set of standards. Whether formal or
    informal, they govern the way of doing things. The software industry tends to
    formalize standards into documents that establish various specifications and procedures
    designed to ensure the quality and reliability of products and services. They
    further incite the compatibility and interoperability processes, which otherwise
    might not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the code into the context of products, various coding standards have
    emerged over the years. Their use yields greater code quality and reduced cognitive
    friction over our codebase. With code quality being one of the pillars of sustainable
    software development, it's no surprise standards are of impeccable importance
    to any professional developer.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to PHP, there are several layers of standards we need to take
    into consideration. There are coding standards specific to the language itself,
    and those specific to the individual library, framework, or platform. While some
    of these standards follow each other, others tend to clash sometimes. Usually,
    this clash is about little things, such as putting the opening function bracket
    in a new line or leaving it on the same line. That being the case, specific library,
    framework, and platform standards should take precedence over the pure language
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2009, at the **php[tek]** conference in Chicago, a number of developers
    joined forces and founded the *PHP Standards Group*. Organized around the mailing
    list at `standards@lists.php.net`, the initial goal was to establish the proper
    autoloading standard. Autoloading was a serious challenge for framework and platform
    developers. Different developers were using different conventions when naming
    their class files. This had a serious impact on interoperability. The **PHP Standards
    Recommendations**, codenamed **PSR-0**, set out to solve this issue by outlining
    practices and constraints that must be followed for autoloader interoperability.
    At its early stages, group acceptance into the PHP community was quite reserved.
    They had yet to earn the right to call themselves that in the eyes of the community.
    Two years later, the group renamed itself into **Framework Interoperability Group**,
    abbreviated to **PHP-FIG**. To this date, PHP-FIG has produced several PSRs, reaffirming
    its position among developers with each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The PHP-FIG and its PSRs were predated by the PEAR Coding Standard, which is
    still quite dominant today. It focuses mostly on the elements of the PHP language
    itself. These elements address the way we write functions, variables, classes,
    and so on. The PSRs on the other hand mostly focus on the interoperability side
    of things. The PHP-FIG and PEAR intersect within the bounds of PSR-1 and PSR-2;
    this makes developers free to follow a single set of standards now, the ones provided
    by the PHP-FIG group.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a detailed look at currently published and accepted
    PSR standards:'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-1 - basic coding standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-2 - coding style guide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-3 - logger interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-4 - autoloading standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-6 - caching interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-7 - HTTP message interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PSR-13 - hypermedia links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the PSRs, there is an extensive use of the **MUST**, **MUST NOT**,
    **REQUIRED, SHALL,** **SHALL NOT**, **SHOULD**, **SHOULD NOT**, **RECOMMENDED**,
    **MAY**, and **OPTIONAL** keywords. The meaning of these keywords is described
    in more detail under RFC 2119 ([http://www.ietf.org/rfc/rfc2119.txt](http://www.ietf.org/rfc/rfc2119.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: PSR-1 - basic coding standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PSR-1 is the basic coding standard. It outlines the rules our code should follow,
    as seen by the members of PHP-FIG. The standard itself is quite short.
  prefs: []
  type: TYPE_NORMAL
- en: '*Files MUST use only <?php and <?= tags***.** At one time, PHP supported several
    different tags (`<?php ?>`, `<? ?>`, `<?= ?>`, `<% %>`, `<%= %>`, `<script language="php"></script>`).
    The use of some depend on the configuration directives `short_open_tag` (`<? ?>`)
    and `asp_tags` (`<% %>`, `<%= %>`). The PHP 7 release removed ASP tags (`<%`,
    `<%=`), and the script tag (`<script language="php">`) altogether. The use of
    only `<?php ?>` and `<?= ?>` tags is now recommended in order to maximize compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Files MUST use only UTF-8 without BOM for PHP code***.** The **byte order
    mark** (**BOM**) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), appearing
    at the beginning of a document. When used correctly, BOM is invisible. The HTML5
    browsers are required to recognize the UTF-8 BOM and use it to detect the encoding
    of the page. PHP, on the other hand, can experience issues with BOM. Positioned
    at the start of the file, BOM clashes with PHP headers by causing the page to
    begin output before the header command is interpreted.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Files SHOULD either declare symbols (classes, functions, constants, and so
    on) or cause side-effects (for example, generate output, change .ini settings,
    and so on) but SHOULD NOT do both***.** Quite often, the simplicity of PHP becomes
    its downside. The language is quite loose when it comes to its use. We can easily
    start from a blank file and code an entire application in it. This implies having
    dozens of different classes, functions, constants, variables, includes, requires,
    and other directives, all stacked one next to another. While this might come in
    handy for a quick prototyping, it is, by no means, an approach to be taken when
    building our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Namespaces and classes MUST follow an autoloading PSR: [PSR-0, PSR-4].* Autoloading
    plays a big role in PHP. The concept cuts down the use of require constructs by
    pulling in our classes and functions automatically from various files. By default,
    the language itself provides the `__autoload()` and `spl_autoload_register()`
    functions to assist with that. The PHP-FIG group produced two autoloading standards.
    The PSR-0 standard was the first PSR to come out, and it soon became widely adopted
    across many PHP frameworks. As of October 2014, PSR-0 has been marked as deprecated,
    leaving PSR-4 as an alternative. We will touch upon PSR-4 in more detail later
    on. For the moment, it''s suffice to say that the code written for PHP 5.3 and
    after must use formal namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Class names MUST be declared in* **StudlyCaps***.* The class names, among
    other things, sometimes comprise of multiple words. Imagine, for example, the
    class in charge of XML parsing. Reasonably enough, we might call it `Xml_Parser`,
    `XmlParser`, `XML_Parser`, `XMLParser`, or some similar combination. There are
    many different rules used to squeeze together multiple words that contribute to
    better readability of the code, such as camel case, kebab case, snake case, and
    so on. This standard proposes the use of StudlyCaps, where capitalization of letters
    varies arbitrarily. They resemble the , but might be carried out in a more random
    fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Class constants MUST be declared in all upper case with underscore separators.*
    The PHP system has two types of constants, the ones that live outside the class
    and are defined using the define construct, and the other ones that live inside
    the class. Given that constants represent immutable variables, their name is supposed
    to stand out. This standard clearly states that any class constant name should
    be fully capitalized. It, however, avoids any recommendation regarding the property
    names. We are free to use any of the following combinations (`$StudlyCaps`, `$camelCase`,
    or `$under_score`) as long as we are being consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Method names MUST be declared in camelCase.* Functions enclosed within a class
    are called **methods**. The naming pattern here differs from previously mentioned
    StudlyCaps, as it uses camelCase, which is less arbitrary. More specifically,
    lowercase camelCase is used, which implies method names starting with lowercase
    letters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The official, full-length *PSR-1 Basic Coding Standard* guide is available at
    [http://www.php-fig.org/psr/psr-1/](http://www.php-fig.org/psr/psr-1/).
  prefs: []
  type: TYPE_NORMAL
- en: PSR-2 - coding style guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PSR-2 is an extension of PSR-1\. This means that when talking about PSR-2, the
    PSR-1 standard is sort of implicitly understood. The difference is that PSR-2
    expands beyond basic class and function formatting by enumerating a set of rules
    on how to format PHP code. The outlined style rules are derived shared similarities
    across the various PFP-FIG member projects.
  prefs: []
  type: TYPE_NORMAL
- en: '*Code MUST follow a coding style guide PSR (PSR-1).* Goes to say that every
    PSR-2 code is implicitly PSR-1 compliant.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code MUST use 4 spaces for indenting, not tabs.* The spaces versus tabs dilemma
    is quite an old one in the programming world. There are those who the PHP-FIG
    group voted for the use of spaces, whereas 4 spaces represent what is usually
    a single tab indent. The benefit of a space over a tab is consistency. Whereas,
    a tab could show up as a different number of columns depending on the environment,
    a single space is always one column. While this might not be the most convincing
    argument of all, the standards goes on to say that 4 spaces constitute for a single
    indent. Think of it as 4 spaces for what was once a single indent. Most modern
    IDE editors nowadays, such as PhpStorm, handle this automatically for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '*There MUST NOT be a hard limit on line length; the soft limit MUST be 120
    characters; lines SHOULD be 80 characters or less.* The 80 characters line length
    argument is as old as programming itself. The IBM punch card, designed in 1928,
    had the 80 columns with 12 punch locations each, one character to each column.
    This 80 characters per row design choice was later passed on to character-based
    terminals. Although the display device advancements are far beyond these limitations,
    even today, some command prompts remain set at 80 columns. This standard basically
    says that while we might use any length we want, it is highly preferable to keep
    it below 80 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '*There MUST be one blank line after the namespace declaration, and there MUST
    be one blank line after the block of use declarations.* Although this is not a
    technical requirement imposed by the language itself, the standard mandates it.
    The requirement itself is more of a cosmetic nature. The resulting use impacts
    code readability for the better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Opening braces for classes MUST go on the next line, and closing braces MUST
    go on the next line after the body.* Similarly, this is not a technical requirement
    of the language, rather a cosmetic one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Opening braces for methods MUST go on the next line, and closing braces MUST
    go on the next line after the body.* Again, this is a cosmetic type of requirement,
    it is not really imposed by the language itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Visibility MUST be declared on all properties and methods; abstract and final
    MUST be declared before the visibility; static MUST be declared after the visibility.* Visibility
    is merely a shorthand for what is officially called **access modifiers**. The
    class methods in PHP can use more than one access modifier. The order of access
    modifiers in such cases is not relevant; we can easily say `abstract public function`
    and `public abstract function` or `final public function` and `public final function`.
    The same goes when we add the `static` access modifier to the mix, where we effectively
    might have three different access modifiers on a single method. This standard
    clearly specifies that the `abstract` and `final` modifiers, if used, need to
    be set first, while the `static` modifiers, if used, need to follow `public` and
    `private` modifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code demonstrates an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code demonstrates an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Control structure keywords MUST have one space after them; method and function
    calls MUST NOT.* This is a rather cosmetic requirement, which merely affects code
    readability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code demonstrate an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Opening braces for control structures MUST go on the same line, and closing
    braces MUST go on the next line after the body.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code demonstrates an example to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code demonstrates an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Opening parenthesis for control structures MUST NOT have a space after them,
    and closing parenthesis for control structures MUST NOT have a space before them.*
    The closing parenthesis space might be a bit confusing here to grasp, because,
    earlier, we saw the standard enforcing spaces for indention instead of tabs. This means
    that we will have spaces preceding closing brackets. However, there should only
    be enough space to represent the actual indention at the point of the closing
    bracket, nothing more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The demonstrates an example to avoid (notice the space on line 7, after the
    opening curly brace):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2aab1815-76f4-4efd-8201-1109cdbd24ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The demonstrates an example to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a86bc8b6-a227-41b7-aaf3-520416bc1094.png)The official, full-length
    *PSR-2 Coding Style* guide is available at [http://www.php-fig.org/psr/psr-2/](http://www.php-fig.org/psr/psr-2/).'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-3 - logger interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging different type of events is a common practice for applications. While
    one application might categorize these types of events into errors, informational
    events, and warnings, others might throw in more elaborate levels of severity
    logging. The same goes for the actual format of the log message itself. Goes to
    say that every application might easily have its own flavor of logging mechanism.
    This stands in a way of interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: The PSR-3 standard sets out to fix this by defining a standard for the actual
    logger interface. Such a standardized interface then enables us to write PHP application
    logs in a simple and universal way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *syslog protocol* (RFC 5424), defined by **Internet Engineering Task Force**
    (**IETF**), differentiates the following eight severity levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emergency`: This states the system is unusable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert`: This states action must be taken immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`critical`: This states critical conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This states error conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning`: This states warning conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notice`: This states normal but significant condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: This states informational messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: This states debug-level messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PSR-3 standard builds upon the RFC 5424 by specifying `LoggerInterface`,
    which exposes a special method for each of the eight severity levels, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can also notice the ninth `log()` method, whose signature differs than the
    first eight. The `log()` method is more of a convenience method, whose level parameter
    needs to indicate one of the eight severity levels. Calling this method must have
    the same result as calling the level-specific methods. Every method accepts a
    string as `$message`, or an object with a `__toString()` method. Trying to call
    these methods with an unknown severity level must throw `Psr\Log\InvalidArgumentException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$message` string may contain one or more placeholders, which the interface
    implementors might interpolate with key-value parameters passed into the `$context`
    string, as shown in the following abstract example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Without going into the implementation details, it's suffice to say that PSR-3
    is a simple standard set to sort an important role of a logger mechanism. Using
    the logger interface, we are freed from having to rely on a specific logger implementation. We
    can type-hint our application code against `LoggerInterface` to acquire a PSR-3
    compliant logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using **Composer** with our project, we could easily include the
    `psr/log` package into it. This would enable us to integrate a PSR compliant logger
    with our project in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `LoggerInterface` interface and defining all of its methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting the `AbstractLogger` class and defining the `log` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `LoggerTrait` and defining the `log` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is much easier to use an existing Composer package, such as `monolog/monolog` or
    `katzgrau/klogger`, and avoid writing our own logger implementation altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Monolog* project is a nice example of a popular and robust PHP library
    that implements the PSR-3 logger interface. It can be used to send our logs to
    files, sockets, inboxes, databases, and various web services.The official, full-length
    *PSR-3: Logger Interface* guide is available at [http://www.php-fig.org/psr/psr-3/](http://www.php-fig.org/psr/psr-3/).'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-4 - autoloading standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To this date, the PHP-FIG group has released two autoloading standards. Predating
    PSR-4 was PSR-0\. It was the first standard released by the PHP-FIG group. Its
    class naming had certain backward compatibility features aligned with an even
    older PEAR standard. Whereas, each level of the hierarchy was separated with a
    single underscore, indicating pseudo-namespaces and directory structure. The PHP
    5.3 release then brought official namespace support to the language. PSR-0 allowed
    both the old PEAR underscore mode and the use of the new namespace notation. Allowing
    the underscores for some time to follow eased the transition to namespaces and
    encouraged wider adoption. Pretty soon, Composer came on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Composer is a popular dependency manager for PHP that deals with packages and
    libraries by installing them in a `vendor/` directory of our project.
  prefs: []
  type: TYPE_NORMAL
- en: With Composer's `vendor/` directory philosophy, there was no single main directory for
    PHP sources as with PEAR. PSR-0 became a bottleneck and was marked as deprecated
    as of October 2014.
  prefs: []
  type: TYPE_NORMAL
- en: PSR-4 is the recommended autoloading standard nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to PSR-4, a fully qualified class name now has the form as per the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The term *class* here does not just refer to classes. It also refers to *interfaces*,
    *traits*, and other similar structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this into context, let''s take a look at the partial class code taken
    from the *Magento 2* commerce platform, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Subscriber` class is defined within the `Subscriber.php` file
    present at  `vendor\Magento\module-newsletter\Model\`, relative to the root of
    the *Magento* project. We can see `__construct` using all sorts of fully classified
    class names. The Magento platform has these types of robust constructors all over its
    codebase because of the way it handles dependency injection. We can imagine the
    amount of additional code needed to individually `require` all of these classes
    manually if it weren't for the unified autoloading standard.
  prefs: []
  type: TYPE_NORMAL
- en: The PSR-4 standard also states that the autoloader implementation must not throw
    an exception or raise an error of any level. This is to ensure that possible multiple
    autoloaders do not break one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official, full-length *PSR-4: Autoloader Standard* guide is available at
    [http://www.php-fig.org/psr/psr-4/](http://www.php-fig.org/psr/psr-4/).'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-6 - caching interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance issues are the ever-hot topic of application development. The effects
    of poorly performing applications can sometimes have serious financial impact.
    Back in 2007, Amazon reported a 100 ms increase in [https://www.amazon.com/](https://www.amazon.com/)
    load time and their sales decreased by 1%. Several studies have also shown that
    nearly half of the users are likely to abandon the website if the page load time
    is over 3 seconds. To address the performance issues, we look into caching solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Both browsers and servers allow caching of various resources, such as images,
    web pages, CSS/JS files. Sometimes, however, this is not enough as we need to
    be able to control the caching of various other bits on the application level,
    such as objects themselves. Over time, various libraries rolled out their own
    caching solutions. This made it tough for developers, as they needed to implement
    specific caching solutions in their code. This made it impossible to easily change
    caching implementation later on.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, the PHP-FIG group brought forth the PSR-6 standard.
  prefs: []
  type: TYPE_NORMAL
- en: This standard defines two main interfaces, `CacheItemPoolInterface` and `CacheItemInterface`,
    for working with **Pool** and **Items**. The pool represents a collection of items
    in the caching system. Whereas, item represents a single **key**/value pair stored
    within the pool. The key part acts as a unique identifier, so it must be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet reflects the PSR-6 `CacheItemInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet reflects the PSR-6 `CacheItemPoolInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Libraries that implement the PSR-6 standard must support the following serializable
    PHP data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compound structures such as arrays and objects are always tricky ones. The
    standard says that the indexed, associative, and multidimensional arrays of arbitrary
    depth must be supported. Since arrays in PHP are not necessarily of a single data
    type, this is the one to be careful about. Objects might utilize the PHP `Serializable`
    interface, `__sleep()` or `__wakeup()` magic methods, or similar language functionality.
    The important bit is that any data passed to libraries that implement PSR-6 is
    expected to come back exactly as passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several PSR-6 cache implementations available via Composer, all of
    which support tags. The following is a partial list of the most popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cache/filesystem-adapter`: Using filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/array-adapter`: Using a PHP array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/memcached-adapter`: Using Memcached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/redis-adapter`: Using Redis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/predis-adapter`: Using Redis (Predis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/void-adapter`: Using Void'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/apcu-adapter`: Using APCu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/chain-adapter`: Using chain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache/doctrine-adapter`: Using Doctrine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily add any one of these caching libraries to our project just by
    using `Composer require new/package`. The PSR-6 compliance makes it possible for
    us to easily swap these libraries in our project without changing any of its code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Redis* is an open source in-memory data structure store used as a database,
    cache, and message broker. It is quite popular with PHP developers as a caching
    solution. The official *Redis* page is available at [https://redis.io/](https://redis.io/).The
    official, full-length *PSR-6: Caching Interface* guide is available at [http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/).'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-7 - HTTP message interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP protocol has been around for quite some time now. Its development was
    initiated by Tim Berners-Lee at CERN way back in 1989\. Throughout the years,
    **Internet Engineering Task Force** (**IETF**) and the **World Wide Web Consortium**
    (**W3C**) defined series of standards for it, known as **Requests for Comments**
    (**RFCs**). The first definition of HTTP/1.1 occurred in RFC 2068 in 1997, and
    was later deprecated by RFC 2616 in 1999\. Over a decade later, HTTP/2 was standardized
    in 2015\. Although HTTP/2 is now supported by major web servers, HTTP/1.1 is still
    widely used.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying HTTP communication comes down to requests and responses, commonly
    referred to as **HTTP messages**. Abstracted away from average consumers, these
    messages form the foundation of web development, and are therefore of interest
    to every web application developer. While RFC 7230, RFC 7231, and RFC 3986 spec
    out the details of HTTP itself, PSR-7 describes common interfaces for representing
    the HTTP messages in accordance with these RFCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'PSR-7 defines a total of the following seven interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\MessageInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\RequestInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\ServerRequestInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\ResponseInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\StreamInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\UriInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Http\Message\UploadedFileInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be fetched via Composer as a part of the `psr/http-message` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code reflects the PSR-7 `Psr\Http\Message\MessageInterface`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `MessageInterface` methods common to both the request and response
    type of message. Messages are considered immutable. A class that implements the `MessageInterface` interface
    needs to assure this immutability by returning a new message instance for every
    method call that changes the message state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code reflects the PSR-7 `Psr\Http\Message\RequestInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `RequestInterface` interface extends  `MessageInterface` serving as a representation
    of an outgoing, client-side request. Like previously mentioned messages, requests
    are also considered immutable. This means that the same class behavior applies.
    If the class method is to change the request state, the new instance of request
    needs to be returned for every such method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Psr\Http\Message\ServerRequestInterface` definition reflects
    the PSR-7 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The implementations of `ServerRequestInterface` serve as a representation of
    an incoming server-side HTTP request. They too are considered immutable; this
    means that the same rules of state changing methods apply as previously mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet reflects the PSR-7 `Psr\Http\Message\ResponseInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With only three methods defined, the implementations of `ResponseInterface`
    serve as a representation of an outgoing server-side response. These types of
    messages are considered immutable as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code reflects the PSR-7 `Psr\Http\Message\StreamInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`StreamInterface` provides a wrapper around the common PHP stream operations, including
    serialization of the entire stream to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code reflects the PSR-7 `Psr\Http\Message\UriInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `UriInterface` interface here represents the URIs according to RFC 3986. The
    interface methods force the implementor to provide methods for most common operations
    around the URI object. The instances of URI objects are also considered immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet reflects the PSR-7 `Psr\Http\Message\UploadedFileInterface` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `UploadedFileInterface` interface represents a file uploaded through an
    HTTP request, which is a frequent role of web applications. The handful of methods
    force the class implementation to cover the most common actions performed on files.
    Like with all of the previous interfaces, class implementation needs to ensure
    object immutability.
  prefs: []
  type: TYPE_NORMAL
- en: '*Guzzle* is a popular PSR-7 compliant HTTP client library that makes it easy
    to work with requests, responses, and streams. It is available at [https://github.com/guzzle/guzzle](https://github.com/guzzle/guzzle),
    or as a Composer `guzzlehttp/guzzle` package.The official, full-length *PSR-7:
    HTTP Message Interface* guide is available at [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/).'
  prefs: []
  type: TYPE_NORMAL
- en: PSR-13 - hypermedia links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hypermedia links form an essential part of any web application, whether
    we are speaking about HTML or API formats. At the very minimum, each hypermedia
    link consists of a URI representing the target resource and a relationship defining
    how the target resource relates to the source. The target link must be an absolute
    URI or a relative URI, as defined by RFC 5988, or possibly a URI template as defined
    by RFC 6570.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PSR-13 standard defines a series of interfaces that outline a common hypermedia
    format and a way to represent links between these formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Psr\Link\LinkInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Link\EvolvableLinkInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Link\LinkProviderInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Psr\Link\EvolvableLinkProviderInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These interfaces can be fetched via Composer as a part of the `psr/link` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\LinkInterface` definition,
    which represents a single readable link object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\LinkProviderInterface` definition,
    which represents a single link provider object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\EvolvableLinkInterface` definition,
    which represents a single evolvable link value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\EvolvableLinkProviderInterface` definition,
    which represents a single evolvable link provider value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: here means that object instances of these interfaces exhibit the same behavior
    as those in PSR-7\. By default, objects need to be immutable. The moment an object
    state needs to change, that change should be reflected into a new object instance. Thanks
    to PHP's copy-on-write behavior, this is easy for the class to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The copy-on-write behavior is a built-in mechanism of PHP code, whereas PHP
    takes care of avoiding unnecessary variable duplicates. Until one or more bytes
    of variable are changed, the variable is not being copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official, full-length *PSR-13: Hypermedia Links* guide is available at
    [http://www.php-fig.org/psr/psr-13/](http://www.php-fig.org/psr/psr-13/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP-FIG group addresses a wide range of things through its PSRs. Some of
    them focus on the structure and readability of the code, others strive for increased
    interoperability by defining numerous interfaces. These PSRs, directly or indirectly, contribute
    to improved quality of our project and the third-party libraries we might use.
    The RFC 2119 standard was a common base for each of the PSR. It removes any ambiguity
    around may, must, should, and similar words that describe the standard. This ensures that
    the documentation gets read just as PHP-FIG intended it. While we might not be
    in touch with each of the standards on a day-to-day basis, it is worth paying
    attention to them when choosing the libraries for our project. Standard compliant
    libraries, such as Monolog, usually mean more flexibility, as we can easily switch
    between different libraries in later stages of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will look into configuration options, mechanisms, and libraries
    behind error handling and logging.
  prefs: []
  type: TYPE_NORMAL
