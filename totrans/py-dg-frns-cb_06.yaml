- en: Reading Emails and Taking Names Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing EML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing MSG files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering Takeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatâ€™s in the box?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing PST and OST mailboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The he-said-she-said game is often thrown out the window once computer evidence
    is added to the fray. The email plays a major role in most types of investigations.
    The email evidence extends to both business and personal devices, as it is widely
    used to send files, communicate with peers, and to receive notifications from
    online services. By examining email, we can learn what social media, cloud storage,
    or other sites are used by the custodian. We can also look for data exfiltration
    outside of an organization or investigate the source of a phishing scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover recipes that expose this information for investigations,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the EML format using built-in libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the `win32com` library to extract information from Outlook MSG files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving Google Gmail with Takeouts and parsing the preservation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in libraries to read from MBOX containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading PST files with `libpff`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing EML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: The EML file format is widely used for storing email messages, as it is a structured
    text file that is compatible across multiple email clients. This text file stores
    email headers, body content, and attachment data as plain text, using `base64`
    to encode binary data and the **Quoted-Printable** (**QP**) encoding to store
    content information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All libraries used in this script are present in Python's standard library.
    We will use the built-in `email` library to read and extract key information from
    the EML files.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the `email` library, visit [https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an EML parser, we must:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept an argument for an EML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read values from the headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse information from each of the sections of the EML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display this information for ease of review in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by importing libraries for argument handling, EML processing, and
    decoding base64 encoded data. The `email` library provides classes and methods
    necessary to read EML files. We will use the `message_from_file()` function to
    parse data from the provided EML file. `Quopri` is a new library to this book
    which we use to decode the QP encoded values found in the HTML body and attachments.
    The `base64` library, as one might expect, allows us to decode any base64 encoded
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler accepts one positional argument, `EML_FILE`,
    which represents the path to the EML file we will process. We use the `FileType`
    class to handle the opening of the file for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, we read the file-like object into the `email` library
    using the `message_from_file()` function. We can now use the resulting variable,
    `emlfile`, to access the headers, body content, attachments, and other payload
    information. Reading the email headers is simply a matter of iterating through
    a dictionary provided by the library''s `_headers` attribute. To handle the body
    content, we must check if this message contains multiple payloads and, if so,
    pass each to the designated processing function, `process_payload()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `process_payload()` function begins by extracting extracting the MIME type
    of the message using the `get_content_type()` method. We print this value to the
    console and, on a newline, we print a number of `"="` characters to distinguish
    between this and the remainder of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one line, we extract the message body content using the `get_payload()`
    method and decoding the QP encoded data with the `quopri.decodestring()` function.
    We then check the there is a character set of the data and, if we do identify
    a character set, use the `decode()` method on the content while specifying the
    character set. If the encoding is unknown, we will try to decode the object with
    UTF8, the default when leaving the `decode()` method empty, and Windows-1252:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With our decoded data, we check the content MIME type to properly handle the
    storage of the email. The first condition for HTML information, specified by the
    `text/html` MIME type, is written to an HTML document in the same directory as
    the input file. In the second condition, we handle binary data under the `Application`
    MIME type. This data is conveyed as `base64` encoded values, which we decode before
    writing to a file in the current directory using the `base64.b64decode()` function.
    The binary data has the `get_filename()` method, which we can use to accurately
    name the attachment. Note that the output file must be opened in `"w"` mode for
    the first type and `"wb"` mode for the second. If the MIME type is other than
    what we have covered here, we print the body to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this code, we see the header information first printed to the
    console, followed by the various payloads. In this case, we have a `text/plain`
    MIME content first, containing a sample message, followed by an `application/vnd.ms-excel`
    attachment that we export, and another `text/plain` block showing the initial
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00064.jpeg)![](../images/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing MSG files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7 or 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Email messages can come in many different formats. The MSG format is another
    popular container for storing message content and attachments. In this example,
    we will learn to parse MSG files using the Outlook API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires the installation of the third-party library `pywin32`.
    This means the script will only be compatible on Windows systems. We will also
    need to install `pywin32,` as we did in [Chapter 1](part0029.html#RL0A0-260f9401d2714cb9ab693c4692308abe),
    *Essential Scripting and File Information Recipes*.
  prefs: []
  type: TYPE_NORMAL
- en: To install `pywin32`, we need to access its SourceForge page at [https://sourceforge.net/projects/pywin32/](https://sourceforge.net/projects/pywin32/)
    and download the version that matches your Python installation. To check our Python
    version, we can import the `sys` module and call `sys.version` within an interpreter.
    Both the version and the architecture are important when selecting the correct
    `pywin32` installer. We also want to confirm we have a valid installation of Outlook
    that has been setup on our machine, as the `pywin32` bindings rely on resources
    provided by Outlook. We are ready to create the script after running the `pywin32`
    installer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an MSG parser, we must:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept an argument for an MSG file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print general metadata about the MSG file to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print recipient-specific metadata to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the message content to an output file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export any attachments embedded within the message to appropriate output files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin by importing libraries for argument handling, `argparse` and `os`,
    followed by the `win32com` library from `pywin32`. We also import the `pywintypes`
    library to properly catch and handle `pywin32` errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler accepts two positional arguments, `MSG_FILE`
    and `OUTPUT_DIR`, which represent the path to the MSG file to process and the
    desired output folder, respectively. We check if the desired output folder exists
    and create it if it does not. Afterwards, we pass the two inputs to the `main()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function we call the `win32com` library to set up the Outlook
    API configuring it in such a way that allows access to the `MAPI` namespace. Using
    this `mapi` variable, we can open an `MSG` file with the `OpenSharedItem()` method
    and create an object we will use for the other functions in this recipe. These
    functions include: `display_msg_attribs()`, `display_msg_recipients()`, `extract_msg_body()`,
    and `extract_attachments()`. Let''s now turn our attention to each of these functions,
    in turn, to see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display_msg_attribs()` function allows us to display the various attributes
    of a message (subject, to, BCC, size, and so on). Some of these attributes may
    not be present in the message we are parsing, however, we attempt to export all
    values regardless. The `attribs` list shows, in order, the attributes we try to
    access from the message. As we iterate through each attribute, we use the built-in
    `getattr()` method on the `msg` object and attempt to extract the relevant value,
    if present, and `"N/A"` if not. We then print the attribute and its determined
    value to the console. As a word of caution, some of these values may be present
    but only set to a default value, such as the year `4501` for some dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display_msg_recipients()` function iterates through the message and displays
    recipient details. The `msg` object provides a `Recipients()` method, which accepts
    an integer argument to access recipients by index. Using a `while` loop, we try
    to load and display values for available recipients. For each recipient found,
    as in the prior function, we use of `getattr()` method with a list of attributes,
    called `recipient_attrib`, to extract and print the relevant values or, if they
    are not present, assign them the value `"N/A"`. Though most Python iterables use
    zero as the first index, the `Recipients()` method starts at `1`. For this reason,
    the variable `i` will start at `1` and be incremented until no further recipients
    are found. We will continue to try and read these values until we receive a `pywin32`
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extract_msg_body()` function is designed to extract the body content from
    the message. The `msg` object exposes the body content in a few different formats;
    in this recipe, we will export the HTML, using the `HTMLBody()` method, and plaintext,
    using the `Body()` method, versions of the body. Since these objects are byte
    strings, we must first decode them, which we do with the `cp1252` code page. With
    the decoded content, we open the output file for writing, in the user-specified
    directory, and create the respective `*.body.html` and `*.body.txt` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `extract_attachments()` function exports attachment data from the
    MSG file to the desired output directory. Using the `msg` object, we again create
    a list, `attachment_attribs`, representing a series of attributes about an attachment.
    Similar to the recipient function, we use a `while` loop and the `Attachments()`
    method, which accepts an integer as an argument to select an attachment by index,
    to iterate through each attachment. As we saw before with the `Recipients()` method,
    the `Attachments()` method starts its index at `1`. For this reason, the variable
    `i` will start at `1` and be incremented until no further attachments are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For each attachment, we print its attributes to the console. The attributes
    we extract and print are defined in the `attachment_attrib` list at the beginning
    of this function. After printing available attachment details, we write its content
    using the `SaveAsFile()` method and supplying it with a string containing the
    output path and desired name of the output attachment (which is obtained using
    the `FileName` attribute). After this, we are ready to move onto the next attachment
    and so we increment variable `i` and try to access the next attachment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we execute this code, we see the following output, along with several files
    in the output directory. This includes the body as text and HTML, along with any
    discovered attachments. The attributes of the message and its attachments are
    displayed in the console window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thereâ€™s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider adding more fields to the parser by referencing the properties of an
    MSG object on MSDN at [https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other libraries for accessing MSG files exist, including the `Redemption` library.
    This library provides handlers to access header information, along with many of
    the same attributes shown in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering Takeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Easy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: N/A'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: Google Mail, popularly known as Gmail, is one of the more widely-used webmail
    services. Gmail accounts not only function as email addresses, but a gateway into
    the slew of other services that Google offers. In addition to providing access
    to mail through the web or **Internet Message Access Protocol** (**IMAP**) and
    **Post Office Protocol** (**POP**) mail protocols, Google has developed a system
    for the archival and acquisition of mail and other associated data stored in a
    Gmail account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe, believe it or not, actually does not involve any Python and instead
    requires a browser and access to a Google account instead. The purpose of this
    recipe is to acquire the Google account mailbox in the MBOX format which we parse
    in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initiate a Google Takeout, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Login to the Google account in question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to account settings and the Create Archive feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select desired Google products to archive and begin the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the archived data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start the Google Takeout process by logging into the account and selecting
    the My Account option. We can also navigate to [https://myaccount.google.com](https://myaccount.google.com)
    if the My Account option is not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the My Account dashboard, we select the Control your content link under
    the Personal info & privacy section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the Control your content section, we are presented with an option to
    CREATE ARCHIVE. This is where we start the Google Takeout collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When selecting this option, we are presented with an option to manage existing
    archives or generate a new one. When generating a new one, we are presented with
    check boxes for each Google product we wish to include. Drop-down arrows provide
    sub-menus altering the export format or content. For example, we can choose how
    Google Drive Documents are exported as Microsoft Word, PDF, or plaintext formats.
    In this instance, we will leave the options as defaults, ensuring the Mail option
    is set to collect All mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With the desired content selected, we can configure the format of the archive.
    Google Takeout allows us to select both an archive file type and a maximum segment
    size for ease of download and access. We can also select how we would like to
    access the Takeout. This option can be set to send a download link to the account
    being archived (the default option) or upload the archive to the account's Google
    Drive or other third-party cloud services, which may modify more information than
    necessary to preserve this data. We elect to receive the email and then select
    Create archive to start the process!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And now we must wait. Depending on the size of the data being preserved this
    can take a considerable amount of time, as Google has to gather, convert, and
    compress all of the data for you.
  prefs: []
  type: TYPE_NORMAL
- en: When you receive the notification email, select the provided link to download
    the archive. This archive is only available for a limited time, so it is important
    to collect it as soon as you are notified.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After downloading the data, extract the archive's contents and look at the internal
    folder structure and provided data. Each of the products selected is given a folder
    containing the relevant content or folder structure for the product. In this instance,
    we are most interested in mail, provided in the MBOX format. In the next recipe,
    we will show how to parse this MBOX data using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Thereâ€™s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you prefer a more direct route for this acquisition, you can navigate to
    [https://takeout.google.com/settings/takeout](https://takeout.google.com/settings/takeout)
    after logging into the account. From here you can choose the products for export.
  prefs: []
  type: TYPE_NORMAL
- en: Whatâ€™s in the box?!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 3.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Any'
  prefs: []
  type: TYPE_NORMAL
- en: MBOX files are often found in association with UNIX systems, Thunderbird, and
    Google Takeouts. These MBOX containers are text files with special formatting
    that split messages stored within. Since there are several formats for structuring
    MBOX files, our script will focus on those from Google Takeout, using the output
    from the prior recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All libraries used in this script are present in Python's standard library.
    We use the built-in `mailbox` library to parse the Google Takeout structured MBOX
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the `mailbox` library, visit [https://docs.python.org/3/library/mailbox.html](https://docs.python.org/3/library/mailbox.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement this script, we must:'
  prefs: []
  type: TYPE_NORMAL
- en: Design arguments to accept a file path to the MBOX file and an output the report
    its contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop a custom MBOX reader that handles encoded data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract message metadata including attachment names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write attachments to the output directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an MBOX metadata report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by importing libraries for argument handling, followed by the `os`,
    `time`, and `csv` libraries required for creating the script''s output. Next,
    we import the `mailbox` library to parse the MBOX message format and `base64`
    to decode binary data in attachments. Lastly, we bring in the `tqdm` library to
    provide a progress bar related to the message parsing status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler accepts two positional arguments, `MBOX`
    and `OUTPUT_DIR`, which represent the path to the MBOX file to process and the
    desired output folder, respectively. Both of these arguments are passed to the
    `main()` function to kick off the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function starts with a call to the `mailbox` libraryâ€™s `mbox`
    class. Using this class, we can parse a MBOX file by providing the path to the
    file and an optional argument for the factory, which in our case, is a custom
    reader function. Using this library, we now have an iterable object containing
    message objects we can interact with. We use the built-in `len()` method to print
    the number of messages contained within the MBOX file. Let''s first look at how
    the `custom_reader()` function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This recipe requires a number of functions to function (see what we did there...),
    but the `custom_reader()` method is a bit different than the others. This function
    is a reader method for the `mailbox` library. We need to create this function
    due to the fact that the default reader does not handle encoding such as `cp1252`.
    We can add other encodings into this reader, though ASCII and `cp1252` are the
    two most common encodings for MBOX files.
  prefs: []
  type: TYPE_NORMAL
- en: 'After using the `read()` method on the input data stream, it tries to decode
    the data using the ASCII codepage. If this is unsuccessful, it instead relies
    on the `cp1252` codepage to get the job done. Any errors that are encountered
    when decoding with the `cp1252` codepage are replaced by the replacement character
    `U+FFFD` by supplying the `decode()` method with the `errors` keyword setting
    it to `"replace"`. We use the `mailbox.mboxMessage()` function to return the decoded
    content in the appropriate format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `main()` function, we prepare a few variables before we begin processing
    the messages. Namely, we set up the `parsed_data` results list, create an output
    directory for attachments, and define the `columns` for the MBOX metadata report.
    These columns will also be used to extract information from the message using
    the `get()` method. Two of these columns will not extract information from the
    message object and, instead, will contain data we assign after processing attachments.
    For consistency, we will keep these values in the `columns` list, as they will
    default to an `"N/A"` value anyways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we begin to iterate through the messages, we implement a `tqdm` progress
    bar to track the iteration process. Since the `mbox` object has a length property,
    we do not need to provide any additional arguments to `tqdm`. Inside of the loop,
    we define the `msg_data` dictionary to store message results and then try to assign
    message properties through a second `for` loop using the `get()` method to query
    for `columns` keys in the `header_data` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in an `if` statement, we check if the `message` has a payload and, if
    it does, we use the `write_payload()` method supplying it the `message` object
    and the output attachments directory as its inputs. If no payloads exist for the
    `message`, the two attachment-related columns will remain with the default `"N/A"`
    values. Otherwise, we count the number of attachments found and join a list of
    their paths together into a comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After each message is processed, its data is appended to the `parsed_data`
    list. After every message has been processed, the `create_report()` method is
    called and passed the `parsed_data` list and the desired output CSV name. Let''s
    backtrack a bit and look at the `write_payload()` method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Since messages can have a wide variety of payloads, we need to craft a dedicated
    function to handle the various `MIME` types. The `write_payload()` method is such
    a function. This function begins by extracting the payload with the `get_payload()`
    method and performing a quick check to see if the payload content consists of
    multiple parts. If it does, we call this function recursively to handle each subsection,
    by iterating through the payloads and appending the output to the `export_path`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the payload is not multi-part, we determine its MIME type using the `get_content_type()`
    method and creating logic to handle the data source appropriately by category.
    Data types, including application, image, and video, are generally represented
    as `base64`-encoded data, allowing binary information to be transmitted as ASCII
    characters. For this reason, the majority of the formats, including some within
    the text category, require us to decode the data before providing it for writing.
    In other instances, the data already exists as a string and can be written as-is
    to the file. Regardless, the method is generally the same, the data is decoded
    (if necessary) and its contents are written to the filesystem using the `export_content()`
    method. Lastly, a string representing the path to the exported item is appended
    to the `export_path` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `else` statement adds an additional `if-elif` statement to the payload
    to determine if the export contains a filename. If it does, we treat it as the
    others, however, if it does not, it is likely a message body stored as HTML or
    text. While we could export each message body by modifying this section, it would
    generate a large amount of data for this example and so we choose not to. Once
    we have finished exporting data from the message, we return the list of paths
    for the data exported to the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `export_content()` function starts by calling the `get_filename()` function,
    a method that extracts the filename from the `msg` object. Additional processing
    is performed on the filename to extract an extension, if present, though the generic
    `.FILE` extension is used if none is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we perform additional formatting to create a unique filename by integrating
    the time, represented as a Unix time integer, followed by the determined file
    extension. This filename is then joined to the output directory to form a full
    path for writing the output. This unique filename ensures that we do not mistakenly
    overwrite already present attachments in the output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last segment of code in this function handles the actual export of file
    content. This `if` statement handles the different file modes (`"w"` or `"wb"`),
    based on the source type. After writing the data, we return the file path used
    in the export. This path will be added to our metadata report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function, `get_filename()`, extracts filenames from the message to
    accurately represent the names of these files. The filenames can be found within
    the `"Content-Disposition"` or `"Content-Type"` properties and are generally found
    prepended with a `"name="` or `"filename="` string. For both properties, the logic
    is largely the same. The function first replaces any newline characters with one
    space and then splits the string on a semicolon and space. This delimiter generally
    separates the values within these properties. Using list comprehension, we identify
    which element contains a `name=` substring and use that as the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the two content properties are empty, we assign a generic `NO_FILENAME`
    and continue preparing the filename. After we extract the potential filename,
    we remove any characters that are not alphanumeric, a space, or a period to prevent
    errors with writing the file to the system. With our filesystem-safe filename
    ready, we return it for use in the previously discussed `export_content()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we have reached the point where we are ready to discuss the CSV metadata
    report. The `create_report()` function, is similar to what we have seen variations
    of throughout this book, it creates a CSV report from a list of dictionaries using
    the `DictWriter` class. Ta-da!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This script creates a CSV report and directory full of attachments. The first
    screenshot shows the first few columns and rows of the CSV report and how the
    data is displayed to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This second screenshot displays the last few columns of these same rows and
    reflects how attachment information is reported. These file paths can be followed
    to access the corresponding attachments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Parsing PST and OST mailboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Hard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: The **Personal Storage Table** (**PST**) file is commonly found on many systems
    and provides access to archived email. These files, generally associated with
    the Outlook application, contain message and attachment data. These files are
    commonly found in the corporate setting, as many business environments continue
    to leverage Outlook for internal and external email management.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires the installation of the `libpff`, and its Python bindings,
    `pypff`, to function. Available on GitHub, this library provides tools, and Python
    bindings, to handle and extract data from PST files. We will set up this library
    in Ubuntu 16.04 with bindings for Python 2 for ease of development. This library
    can be built for Python 3 as well, though we will use the Python 2 bindings for
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must install a number of dependencies before installing the required library.
    Using the Ubuntu `apt` package manager, we will install the following eight packages.
    You may want to keep this Ubuntu environment handy as we will use it extensively
    [Chapter 8](part0241.html#75QNI0-260f9401d2714cb9ab693c4692308abe), *Working with
    Forensic Evidence Container Recipes* and onwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dependencies installed, navigate to the GitHub repository and download
    the desired release for the library. This recipe was developed using the `libpff-experimental-20161119`
    release of the `pypff` library. Next, once the contents of the release are extracted,
    open a terminal and navigate to the extracted directory and execute the following
    commands for the release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `pypff` library, visit [https://github.com/libyal/libpff](https://github.com/libyal/libpff).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can check the library installation by opening a Python interpreter,
    importing `pypff`, and running the `pypff.get_version()` method to ensure we have
    the correct release version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We extract PST message content following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a handle for the PST file using `pypff`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through all folders and messages within the PST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store relevant metadata for each message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a metadata report based on the contents of the PST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script begins by importing libraries for argument handling, writing spreadsheets,
    performing regular expression searches, and processing PST files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler accepts two positional arguments, `PFF_FILE`
    and `CSV_REPORT`, which represent the path to the PST file to process and the
    desired output CSV path, respectively. We forego a `main()` function in this recipe
    and immediately begin by using the `pypff.file()` object to instantiate the `pff_obj`
    variable. Following that, we use the `open()` method and attempt to access the
    user-supplied PST. We pass this PST to the `process_folders()` method and store
    the returned list of dictionaries in the `parsed_data` variable. After using the
    `close()` method on the `pff_obj` variable, we write the PST metadata report using
    the `write_data()` function by passing it the desired output CSV path and processed
    data dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe consists of several functions that handle different elements of
    the PST file. The `process_folders()` function handles the folder processing and
    iteration. As we process these folders, we print their names, the number of subfolders,
    and the number of messages within that folder to the console. This can be accomplished
    by calling the `number_of_sub_folders` and `number_of_sub_messages` attributes
    on the `pff_folder` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Following these print messages, we setup up the `data_list` which is responsible
    for storing processed message data. As we iterate through the messages within
    the folder, we call the `process_message()` method to create the dictionary object
    with the processed message data. Immediately afterward, we add the folder name
    to the dictionary before appending it to the list of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second loop iterates through subfolders, recursively calling the `process_folders()`
    function and passing it the subfolder to process and appending the resulting list
    of dictionaries to the `data_list`. This allows us to walk through the PST and
    extract all of the data before we return the `data_list` and write the CSV report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process_message()` function is responsible for accessing the various attributes
    of the message, including the email header information. As seen in previous recipes,
    we use a list of object attributes to build a dictionary of results. We then iterate
    through the `attribs` dictionary and, using the `getattr()` method, append the
    appropriate key-value pairs to the `data_dict` dictionary. Lastly, if email headers
    are present, which we determine by using the `transport_headers` attribute, we
    update the `data_dict` dictionary with additional values extracted from the `process_headers()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process_headers()` function ultimately returns a dictionary containing
    extracted email header data. This data is displayed as key-value pairs, delimited
    by a colon and space. Since content within a header may be stored on a new line,
    we use regular expression to check that there is a key at the start of the line
    followed by a value. If we do not find a key matching the pattern (any number
    of letters or a dash character followed by a colon), we will append the new value
    to the prior key, as the header displays information in a sequential fashion.
    At the end of this function, we have some specific lines of code, using `isinstance()`,
    to handle the dictionary value assignments. This code checks the key type to ensure
    that values are assigned to keys in a manner that will not overwrite any data
    already associated with a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `write_data()` method is responsible for creating the metadata
    report. Since we may have a great number column names from the email header parsing,
    we iterate through the data and extract distinct column names if they are not
    already defined in the list. Using this method, we ensure that dynamic information
    from the PST is not excluded. In the `for` loop, we are also reassigning values
    from `data_list` into `formatted_data_list`, primarily to convert list values
    into a string to more easily write the data to the spreadsheet. The `csv` library
    does a nice job ensuring that commas within a cell are escaped and handled appropriately
    by our spreadsheet application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `csv.DictWriter` class, we open the file, write the header, and each
    of the rows to the output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When this script runs, a CSV report is generated which should look similar
    to the one shown as shown in the following screenshot. While scrolling horizontally,
    we can see the columns specified at the top in the header row; especially with
    the email header columns, the majority of these columns only containing a handful
    of values. As you run this code against more email containers in your environment,
    make note of the columns that are most useful and commonly found in the PSTs you
    process to expedite analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Thereâ€™s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This process can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This library also handles **Offline Storage Table** (**OST**) files, which are
    generally associated with Outlookâ€™s offline storage of mail content. Find and
    test this script on an OST file and, if necessary, modify it to support this other
    common mail format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this instance, we could also leverage the `Redemtion` library for accessing
    information within Outlook.
  prefs: []
  type: TYPE_NORMAL
