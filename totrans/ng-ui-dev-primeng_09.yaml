- en: Miscellaneous Use Cases and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Miscellaneous use cases and best practices introduce more interesting features
    of the PrimeNG library. You will learn about file uploading, drag-and-drop capabilities,
    displaying collection of images, practical CRUD implementation, deferred page
    loading, blocking page pieces, displaying confirmation dialog with guarded routes,
    and more. Despite a comprehensive set of components, users sometime have special
    requirements for existing components regarding their functionality or need new,
    custom components.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is also exclusively to facilitate the start of component
    development on top of the PrimeNG infrastructure. We will go through the complete
    process of building reusable components and develop a custom wizard component.
    The wizard can be used for workflows, which involve multiple steps to complete
    a task. Furthermore, after reading this chapter, readers will be aware of the
    state-of-the-art state management in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: File uploading in all its glory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning draggable and droppable directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying collection of images with Galleria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD sample implementation with DataTable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring mechanism to optimize page loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking page pieces during long-running AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process status indicator in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting colors with ColorPicker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying confirmation dialog with guarded routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom wizard component with Steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to state management with @ngrx/store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File uploading in all its glory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FileUpload component provides a file upload mechanism with enhanced features
    compared to the basic HTML `<input type="file">` file upload definition. The component
    provides an HTML5-powered UI with capabilities such as drag and drop, uploading
    multiple files, progress tracking, validations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: File uploading component works in all modern browsers as well as IE 10 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: Basic, multiple, and automatic file uploading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two properties are required in order to be able to work with the file upload--the
    name of the request parameter to identify the uploaded files at backend and the
    remote URL to upload files. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The component presents itself as a panel with three buttons: Choose, Upload,
    Cancel, and a content section with selected files. The Choose button displays
    a file dialog to select one or multiple files. Once selected, the files can be
    uploaded or canceled by the next two buttons, respectively. Filename and size
    are always shown by default. In addition, for images, you will see a preview as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/78ae9854-3b08-4ab8-ad72-3c6b316006e0.png)The width of the previewed
    image can be adjusted with the `previewWidth` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'File upload also provides a simpler UI with just one button Choose and without
    the content section. You can activate this UI by setting the `mode` attribute
    to `"basic"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the only one file can be selected from the file dialog. Setting
    the `multiple` option to `true` allows selecting multiples files at once. Setting
    the `auto` option to `true` starts the uploading immediately without the need
    to press any buttons. The buttons Upload and Cancel buttons are hidden in the
    auto uploading mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: File selection can also be done by dragging one or more files from the filesystem
    and dropping them onto the content section of the FileUpload component.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the backend for the FileUpload component cannot be
    mocked with Angular''s mock API. In the demo application on GitHub, we use a simple
    local server `json-server` ([https://github.com/typicode/json-server](https://github.com/typicode/json-server))
    to fake the backend. Otherwise, you will face exceptions. After installation,
    the server can be started as using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/a5560d89-9e9e-4c47-853f-62a86546fe3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `db.json` file in the project root only has a definition of endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are able to use the faked remote URL without getting any exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/fileupload).'
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions by file types and size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, any file types can be uploaded. The file size is not limited either.
    You can restrict file types and size by setting the `accept` and `maxFileSize`
    options, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the example, only images with the maximum size `50000` bytes may be uploaded.
    Violation of those rules causes validation messages to appear in the content section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b7b2e59f-1f93-46c0-8fa4-654a24b21359.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Possible values of the `accept` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `<file extension>` | A file extension starting with dot, for example, `.gif`,
    `.png`, `.doc` and so many. |'
  prefs: []
  type: TYPE_TB
- en: '| `audio/*` | All sound files. |'
  prefs: []
  type: TYPE_TB
- en: '| `video/*` | All video files. |'
  prefs: []
  type: TYPE_TB
- en: '| `image/*` | All image files. |'
  prefs: []
  type: TYPE_TB
- en: '| `<media type>` | A valid media type according to IANA Media Types ([http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)).
    For example, `application/pdf`. |'
  prefs: []
  type: TYPE_TB
- en: To specify more than one value, separate the values with a comma, for example,
    `accept="audio/*,video/*,image/*"`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Validation messages can be customized using the following four options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property name** | **Description** | **Default value** |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidFileSizeMessageSummary` | Summary message of the invalid file size.
    The placeholder `{0}` refers to the file name. | `{0}: Invalid file size,` |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidFileSizeMessageDetail` | Detail message of the invalid file size.
    The placeholder `{0}` refers to the file size. | `maximum upload size is {0}.`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidFileTypeMessageSummary` | Summary message of the invalid file type.
    The placeholder `{0}` refers to the file type. | `{0}: Invalid file type,` |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidFileTypeMessageDetail` | Detail message of the invalid file type.
    The placeholder `{0}` refers to the allowed file types. | `allowed file types:
    {0}` |'
  prefs: []
  type: TYPE_TB
- en: 'The next code snippet and screenshot demonstrate custom messages. They also
    show how you can set custom labels for buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/4a0b5240-b316-4cf0-8c01-c5d79b20c19e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The UI is fully customizable by three named `ng-template` tags. You can customize
    the toolbar, the content section, and the area with selected files. The next code
    snippet shows a fully customizable UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot shows the initial UI state when no file was selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee31c045-cea1-4256-bbba-fdf0e6382d30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After selection from the file dialog, the UI looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5f74e9a-b298-4421-8c5a-a5e8f5c9dd14.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that only PDF files may be selected. The `ng-template` with `pTemplate="file`
    gets the `File` instance as an implicit variable. This instance has a property
    `name`, which we leverage in our custom UI.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official documentation to read more about `File` at [https://developer.mozilla.org/en-US/docs/Web/API/File](https://developer.mozilla.org/en-US/docs/Web/API/File).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next level of customization is callback events, which are fired at a certain
    point of time. There are `onBeforeUpload`, `onBeforeSend`, `onUpload`, `onError`,
    `onClear`, `onSelect`, and `uploadHandler` events. The next code snippet demonstrates
    two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onBeforeUpload` event is fired shortly before uploading. The registered
    callback gets an event object with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xhr`: The `XMLHttpRequest` instance ([https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formData`: The `FormData` object ([https://developer.mozilla.org/en/docs/Web/API/FormData](https://developer.mozilla.org/en/docs/Web/API/FormData)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use this callback to customize the request data such as post parameters
    or header information. For example, we could set a token `jwt` to send it to the
    server. Just write the following callback method in the component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, the token has really been sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26e47c65-840a-45f4-a456-e92b49a2e667.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `onUpload` event is triggered when all selected files have finished uploading.
    They passed event object has the mentioned `XMLHttpRequest` instance and an array
    of objects of type `File`. We can iterate over files and gather them together
    for further processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to provide a custom uploading implementation by setting `customUpload="true"`
    and defining a custom upload handler. An example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is up to you how to implement the `smartUploader` callback. The callback
    has an access to the `event.files`, which is an array of objects of type `File`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning draggable and droppable directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drag and drop is an action, which means grabbing an object to a different location.
    The components capable of being dragged and dropped enrich the web and make a
    solid base for modern UI patterns. The drag-and-drop utilities in PrimeNG allow
    us to create draggable and droppable user interfaces efficiently. They make it
    abstract for the developers to deal with the implementation details at the browser
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the `pDraggable` and `pDroppable` directives.
    We will introduce a DataGrid component containing some imaginary documents and
    make these documents draggable in order to drop them onto a recycle bin. The recycle
    bin is implemented as a DataTable component, which shows properties of dropped
    documents. For the purpose of better understanding the developed code, a picture
    comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e80f0fd-6adf-4d31-a4a1-ee8ff9990472.png)'
  prefs: []
  type: TYPE_IMG
- en: This picture shows what happens after dragging and dropping three documents.
  prefs: []
  type: TYPE_NORMAL
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/dragdrop).'
  prefs: []
  type: TYPE_NORMAL
- en: Draggable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pDraggable` is attached to an element to add a drag behavior. The value of
    the `pDraggable` attribute is required--it defines the scope to match draggables
    with droppables. By default, the whole element is draggable. We can restrict the
    draggable area by applying the `dragHandle` attribute. The value of `dragHandle`
    can be any CSS selector. In DataGrid, with available documents, we only made the
    panel''s header draggable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The draggable element can fire three events when the dragging process begins,
    proceeds, and ends. These are `onDragStart`, `onDrag`, and `onDragEnd`, respectively.
    In the component class, we buffer the dragged document at the beginning and reset
    it at the end of the dragging process. This task is done in two callbacks: `dragStart`
    and `dragEnd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the shown code, we used the `Document` interface with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the demo application, we set the cursor to `move` when the mouse is moved
    over any panel''s header. This trick provides a better visual feedback for the
    draggable area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also set the `dragEffect` attribute to specify the effect that is allowed
    for a drag operation. Possible values are `none`, `copy`, `move`, `link`, `copyMove`,
    `copyLink`, `linkMove`, and `all`. Refer to the official documentation to read
    more details at [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed).
  prefs: []
  type: TYPE_NORMAL
- en: Droppable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pDroppable` is attached to an element to add a drop behavior. The value of
    the `pDroppable` attribute should have the same scope as `pDraggable`.'
  prefs: []
  type: TYPE_NORMAL
- en: Droppable scope can also be an array to accept multiple droppables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The droppable element can fire four events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `onDragEnter` | Invoked when a draggable element enters the drop area. |'
  prefs: []
  type: TYPE_TB
- en: '| `onDragOver` | Invoked when a draggable element is being dragged over the
    drop area. |'
  prefs: []
  type: TYPE_TB
- en: '| `onDrop` | Invoked when a draggable is dropped onto the drop area. |'
  prefs: []
  type: TYPE_TB
- en: '| `onDragLeave` | Invoked when a draggable element leaves the drop area. |'
  prefs: []
  type: TYPE_TB
- en: 'In the demo application, the whole code of the droppable area looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a document is dragged and dropped into the recycle bin, the dropped
    document is removed from the list of all available documents and added to the
    list of deleted documents. This happens in the `onDrop` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both available and deleted documents are updated by creating new arrays instead
    of manipulating existing arrays. This is necessary in data iteration components
    to force Angular run change detection. Manipulating existing arrays would not
    run change detection and the UI would not be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Recycle Bin area gets a red border while dragging any panel with document.
    We achieved this highlighting by setting `ngClass` as `[ngClass]="{''dragged-doc'':
    draggedDoc}"`. The style class `dragged-doc` is enabled when the `draggedDoc`
    object is set. The style class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a collection of images with Galleria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Galleria component can be used to display a collection of images with a
    transition effect.
  prefs: []
  type: TYPE_NORMAL
- en: Get it up and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection of images is created programmatically--it is an array of objects
    with the following three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: The path of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The title text in the caption section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alt`: A description in the caption section below the title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a `GalleriaComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the HTML code, the collection is referenced via the input property `images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The developed UI looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8606b121-9daa-4fe5-b66b-095bd94c7649.png)'
  prefs: []
  type: TYPE_IMG
- en: The width and height of the content panel can be customized with the `panelWidth`
    and `panelHeight` attributes. The `showCaption` attribute enables displaying titles
    and descriptions in the caption section.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, there is an area with small images called **filmstrip**. The
    visibility of the filmstrip is enabled by default with the `showFilmstrip` attribute.
    You can disable it by setting the attribute to `false`. The width and height of
    the frames visualized in the filmstrip can be customized with the `frameWidth`
    and `frameHeight` attributes, respectively. All values should be provided in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `activeIndex` attribute, which can be used to set the position
    of the displayed image. For example, if you want to display the second image on
    the initial page load, you can set `activeIndex="1"`. The default value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Auto play mode and effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The auto play mode turns a slideshow on. The auto play mode is enabled by default.
    In the example, we disabled the slideshow by setting `[autoPlay]="false"`. The
    transition between images in the auto play mode happens within `4000` milliseconds.
    This time interval can be customized with the `transitionInterval` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'While iterating through the images, it is possible to apply transition effects.
    The `effect` attribute can have the values `blind`, `bounce`, `clip`, `drop`,
    `explode`, `fade` (the default), `fold`, `highlight`, `puff`, `pulsate`, `scale`,
    `shake`, `size`, `slide`, and `transfer`. The `effectDuration` attribute can also
    be used to decide on the duration of the transition. Its default value is `250`
    milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is only one event `onImageClicked`, which is fired when a displayed image
    is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The invoked callback gets an event object. Beside index of the clicked image
    and the native click event, the passed in event object keeps the entire image
    instance from the collection. We could access the source URL in the callback and
    open the image in a new browser tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/galleria).'
  prefs: []
  type: TYPE_NORMAL
- en: CRUD sample implementation with DataTable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PrimeNG was created for enterprise applications. Implementing a **CRUD** (**create,
    read, update**, and **delete**) scenario is easily done. The example in this section
    demonstrates such a scenario with employees that are taken as domain model objects.
    Employees can be fetched, created, updated, and deleted. All CRUD operations happens
    via Angular's HTTP service, which communicates with a mock backend. We will improve
    our CRUD implementation later on in the section *Introduction to state management
    with @ngrx/store*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain model object `Employee` is defined using the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The mock backend is not shown here because it is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/crud-datatable).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EmployeeService` class with CRUD operations is worth to be listed here.
    It exposes four methods with `Observable` as return value so that the component
    class can invoke `subscribe()` to receive delivered data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Employees are presented in DataTable when they are fetched from the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df796d51-9d45-47dc-8557-1337eeec05e8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, only the Add button is enabled when no employee is selected.
    The Add and Edit buttons trigger displaying a dialog box for employee's personal
    data. The Save button creates a new or updates an existing employee depending
    on what you have chosen before--the Add or the Edit button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf3e848d-90ed-47da-9d43-9e6bf91bf104.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Operations triggered by buttons fade in appropriate messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/78029f0b-94a1-482c-868b-2bf49041a430.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The table is implemented with `p-dataTable` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `p-dataTable` is bound to the array property `employees`. An employee
    can be selected by the click of a row and gets saved in the `selectedEmployee`
    property. The buttons Edit and Remove are disabled when `selectedEmployee` is
    not set. We will skip the code of the dialog for the sake of brevity. The most
    interesting part is the component class. The employees are fetched by means of
    `EmployeeService` in the `ngOnInit()` lifecycle callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's explore other CRUD methods in details. The `add()` method constructs an
    empty employee instance and the `edit()` method clones the selected employee.
    Both are used in the dialog. The property `displayDialog` is set to `true` to
    force displaying the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: This property is bound in the view to dialog's visibility as follows `[(visible)]="displayDialog"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Save button in the dialog invokes the `save()` method where we check if
    the employee exists with the help of `id`. Only employees that have been saved
    before contain `id` because `id` is assigned in the backend. An existing employee
    should be updated and the new one should be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The employee will be updated or created in the backend and the `employees`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a new instance of the `employees` array is created instead of
    manipulating the existing one. This is necessary in data iteration components
    to force Angular run change detection. Manipulating elements in the existing array
    don't update the array's reference. As a result, the change detection would not
    run and the UI would not be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Observable` provides a `finally` method where we can reset values
    of properties.
  prefs: []
  type: TYPE_NORMAL
- en: The function passed in to the `finally` method as a parameter is invoked after
    the source observable sequence terminates gracefully or exceptionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove()` method gets invoked by the Remove button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The sequence logic is similar to the other CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring mechanism to optimize page loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large-scale applications always need best practices to improve the page loading
    time. It is not advisable to wait for the landing page to display until all contents
    in the page have been fully loaded. PrimeNG provided a defer directive which postpones
    the content loading until the component appears in the view port. The content
    will be lazily loaded when it becomes visible by the page scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pDefer` directive is applied to a container element and the content needs
    to be wrapped with `ng-template` directive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The defer directive is very helpful to lazily load huge datasets when you use
    data iteration components such as `p-dataTable`, `p-dataList`, `p-dataGrid`, and
    so on. The `onLoad` callback is used to query data from the data source on demand
    when the component becomes visible through page scrolling. The query is not initiated
    on page load so that the page is loaded quickly. A concrete example is implemented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadData()` method fetches the employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Blocking page pieces during long-running AJAX calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BlockUI component allows us to block any piece of a page, for example, during
    AJAX calls. The BlockUI component adds a layer over the target element and gives
    the appearance and behavior of blocking user interaction. It is very handy if
    you have, for example, a large DataTable component and CRUD operations take much
    time. You can block almost everything--even the whole page. In this section, we
    will demonstrate how to deal with BlockUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BlockUI component blocks a blockable *target* component. The `target` property
    points to a template reference variable of such target component. The visibility
    of BlockUI is controlled by the Boolean property `blocked`. For instance, the
    following BlockUI blocks the Panel component when the property `blocked` is set
    to `true` and unblocks it otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The default value of `target` is the `document` object. That means, if no `target`
    is provided, the whole page is blocked. As you can also see, it is possible to
    place any custom content within the `p-blockUI` tag. The custom content gets displayed
    on a semi-transparent layer.
  prefs: []
  type: TYPE_NORMAL
- en: We will leverage the CRUD example from the previous section to demonstrate the
    BlockUI component in action. For the sake of brevity, only two buttons will be
    available--a Reload button, which performs data fetching, and a Remove button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s specify the blocking as--the Reload button should block the whole page
    and the Remove button should only block the table. Furthermore, we want to display
    a loading indicator and the text Loading... as shown in the picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/feb94132-b48a-483a-b0bd-32f317c12a80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These acceptance criteria results in two BlockUI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties `blockedTable` and `blockedPage` are set to `true` immediately
    on button clicks. After CRUD operations are done, the properties are set to `false`.
    This approach is outlined in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The semi-transparent layer over blocked components can be customized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.ui-blockui.ui-widget-overlay {opacity: 0.5;}`The complete demo application
    with instructions is available on GitHub at'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/blockui).'
  prefs: []
  type: TYPE_NORMAL
- en: Process status indicator in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ProgressBar component indicates a status of some process, task, or whatever.
    It can deal with static as well as dynamic values. A dynamic value is a value
    changing in time. The next code snippet demonstrates two progress bars, with a
    static and dynamic value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The dynamic value gets produced every 800 milliseconds from 1 to 100 with the
    `Observable` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, a growl message with the text Process completed will be displayed.
    A snapshot picture is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50d4b3f1-76c9-44ec-ad9a-056f384d6574.png)The complete demo application
    with instructions is available on GitHub at'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/progressbar).'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting colors with ColorPicker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ColorPicker is a graphical user interface input widget used to select colors
    from a two-dimensional square box. The component uses the `ngModel` directive
    for two-way value binding. Basically, it supports three kinds of color formats
    such as hex, RGB, and HSB with a hex default type. The color format is denoted
    with the `format` attribute, for example, as `format="rgb"`. ColorPicker is an
    editable component and can be used in model-driven forms as well. A basic example
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The component has to define the `string` type color property for default hex
    values, whereas the color property should be object type for RGB and HSB formats
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The color picker will display the selected color as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f08baae-7b66-4b76-9ad1-f9e8e5938237.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the color picker is displayed in overlay format, but this default
    behavior can be changed using the `inline` property, which allows a inline format
    by enabling the inline setting. The color picker component in the inline format
    would be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also supports the `onChange` callback with an `event` object
    as argument. The `event` object holds the browser event and the selected color
    value to notify the changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Like other input components, ColorPicker supports model-driven forms, disabled
    property to disable the user interactions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The complete demo application with instructions is available on GitHub at [https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/colorpicker).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying confirmation dialog with guarded routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Angular 2+, you can protect routes with guards. The most likely used guard
    types are `CanActivate` and `CanDeactivate`. The first guard type decides if a
    route can be activated, and the second one decides if a route can be deactivated.
    In this section, we will discuss `CanDeactivate`. This is an interface having
    only one method `canDeactivate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can return `Observable<boolean>`, `Promise<boolean>`, or `boolean`.
    If the value of `boolean` is `true`, the user can navigate away from the route.
    If the value of `boolean` is `false`, the user will stay on the same view. If
    you want to protect your route from navigating away under some circumstances,
    you have to do three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that implements the `CanDeactivate` interface. The class acts
    as a guard, which will be checked by the router when navigating away from the
    current view. As you can see, the interface expects a generic component class.
    This is the current component rendered within the `<router-outlet>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register this guard as provider in a module annotated with `@NgModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add this guard to the router configuration. A router configuration has the `canDeactivate`
    property where such guards can be added multiple times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might want to check out an example from the official Angular documentation
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html](https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we would like to implement a typical use case where we will check
    if there are some unsaved input changes made by user. If the current view has
    unsaved input values and the user tries to navigate away to another view, a confirmation
    dialog should be shown. We will use ConfirmDialog from PrimeNG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/407c81bb-0838-45cf-9f48-359c6c51e854.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, hitting the Yes button leads to navigating to another view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f151ef4-5da8-4c08-b7e2-bf4f21e3f420.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hitting the No button prevents the the process of navigating from the current
    route. Let''s create the first view with an `input` element, a `submit` button,
    and the `<p-confirmDialog>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding component for this template keeps the `dirty` state of the
    form, which indicates that the form is being edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not implement any sophisticated algorithms in order to check if the
    input value was really changed. We just check the form''s `dirty` state. If the
    form is not being edited, the navigation on submit should be fine. No need to
    ask the user about unsaved changes. Now, we have to inject the PrimeNG `ConfirmationService`
    into our guard implementation, which is required to display a confirmation dialog,
    and use it like this within the `canDeactivate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is a problem. The `confirm` method doesn''t return required `Observable<boolean>`,
    `Promise<boolean>`, or `boolean`. The solution is to create and return an `Observable`
    object by invoking `Observable.create()`. The `create` method expects a callback
    with one parameter `observer: Observer<boolean>`. Now we need to do two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the call `this.confirmationService.confirm()` into the callback's body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass `true` or `false` to the subscriber by invoking `observer.next(true)` and
    `observer.next(false)` respectively. The subscriber is the PrimeNG's component
    `ConfirmDialog` which needs to be informed about user's choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full implementation of the `UnsavedChangesGuard` is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already said, the guard is registered in the router configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer `Promise` instead of `Observable`, you can return `Promise` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/guarded-routes).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom wizard component with Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PrimeNG has a component called Steps, which indicates the steps in a workflow.
    The usage is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `model` is a collection of objects of type `MenuItem` which we met in the
    [Chapter 7](26ecdd8d-1f1d-4a09-8f2e-c018120abc0b.xhtml), *Endless Menu Variations*.
    The property `activeIndex` points to an index of the active item (step) in the
    collection of items. The default value is `0` what means that the first item is
    selected by default. We can also make the items clickable by setting `[readonly]="false"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the PrimeNG showcase to see Steps in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.primefaces.org/primeng/#/steps](https://www.primefaces.org/primeng/#/steps)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On basis of `<p-steps>`, we will implement a wizard like behavior with two
    custom components named `<pe-steps>` and `<pe-step>`. The prefix `pe` should hint
    at "PrimeNG extensions". The component `<pe-steps>` acts as container for multiple
    steps. The basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can grasp this structure as wizard. The navigation between wizard''s steps
    happens by clicking on Breadcrumb items (clickable steps), navigation buttons,
    or setting step''s index (`activeIndex`) programmatically. The next screenshot
    shows how the wizard and the navigation could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/389d35fa-c440-4ef3-a8f0-31315349667b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before starting the implementation, let''s specify the API. The `<pe-step>`
    component has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Default** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `styleClass` | `string` | `null` | Style class of single Step component |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | `string` | `null` | Label of this Step shown earlier |'
  prefs: []
  type: TYPE_TB
- en: '**Styling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Element** |'
  prefs: []
  type: TYPE_TB
- en: '| `pe-step-container` | Container element of a single Step component |'
  prefs: []
  type: TYPE_TB
- en: 'The `<pe-steps>` component has:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Default** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `activeIndex` | `number` | `0` | Index of the active step (two way binding)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `styleClass` | `string` | `null` | Style class of wizard''s container element
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stepClass` | `string` | `null` | Style class of each Step component |'
  prefs: []
  type: TYPE_TB
- en: '**Events**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | `label`: Label of currently shown step | Callback invoked when
    switching steps |'
  prefs: []
  type: TYPE_TB
- en: 'Equipped with this knowledge, we can implement `StepComponent` and `StepsComponent`.
    The first one has `ng-content` in the template to be able to put custom content.
    The component class has two specified inputs. Furthermore, there is a property
    `active`, which indicates whether the step is currently shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The second component is more complicated. It iterates over child components
    of the type `StepComponent` and creates items in the life cycle method `ngAfterContentInit()`.
    The property `active` of the child component is set to `true` if it matches `activeIndex`.
    Otherwise, it is set to `false`. This allows to display exactly one step in the
    workflow. The complete listing would go beyond the size of this book. We will
    only show an excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The fully implemented and documented components are available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/primeng-extensions-wizard).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the implemented wizard distributable, we need to create `WizardModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WizardModule` class can be imported in any PrimeNG application as usually
    with `imports` inside `@NgModule`. A concrete usage example to the shown picture
    looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding component implements the `next()` and `ok()` methods, and
    the event callback `onChange()`. To go forwards, you can simple write `next()
    {this.activeIndex++;}`. Consult the GitHub project for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard component can be published to the `npm` repository with `npm run
    update`. There is no running demo app and no `npm start` command in the project
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to state management with @ngrx/store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management in large Angular applications was a weak point over the last
    few years. In AngularJS 1, the state management is often done as a mix of services,
    events, and `$rootScope`. In Angular 2+, the application state and data flow are
    cleaner but there is still no unified state management in Angular core. Developers
    often use *Redux--*a predictable state container for JavaScript applications ([http://redux.js.org](http://redux.js.org)).
    The Redux architecture is best known for its use with the *React* library ([https://facebook.github.io/react](https://facebook.github.io/react)),
    but it can be utilized with Angular too. One of the popular Redux-like state containers
    designed for Angular is *ngrx/store* ([https://github.com/ngrx/store](https://github.com/ngrx/store)).
  prefs: []
  type: TYPE_NORMAL
- en: Redux principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redux follows three basic principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The whole state of the application is stored in a single immutable state tree
    called *store*. No state management is allowed outside the store. A central immutable
    store has a lot of benefits. You can improve the performance by using `ChangeDetectionStrategy.OnPush`
    because with immutable data, Angular only needs to check object references to
    detect changes. Furthermore, the undo/redo functionality is easy done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Actions* are used to send information from the application to the store. Only
    actions are source of information for the store. Actions are plain JavaScript
    objects having `type` and `payload` properties. The `type` property describes
    a kind of state change we want. The `payload` property is the data being sent
    to the store in order to update it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State changes are made through pure functions called *reducers*. Pure functions
    are functions that don't mutate objects, but return brand new objects instead.
    We can grasp reducers as processing steps in the store that allow state transitions.
    The reducer operates on the current state and returns a new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the data flow is bi-directional. User inputs in one component can
    affect other components and vice versa. The data flow in Redux applications is
    uni-directional. Changes in the view trigger actions. Actions are dispatched to
    the store. Reducers perform state changes in response to actions by taking the
    previous state with the dispatched action and returning the next state as a new
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.assign()` and the `spread` operator can help in returning new objects
    ([http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html](http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several components can subscribe to the store to observe state changes over
    time and propagate them to the view. The following diagram memorizes described
    Redux principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/303e29da-5ae2-4124-8a37-e878191e1794.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A classic Redux store provides two important APIs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch actions using `store.dispatch(action)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register listeners for change notification using `store.subscribe(callback)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you see, if you use a Redux store, you don't need to synchronize the state
    between components manually.
  prefs: []
  type: TYPE_NORMAL
- en: A predictable state management allows to debug applications with co, called
    time-travelling debugger. You need to install `store-devtools` ([https://github.com/ngrx/store-devtools](https://github.com/ngrx/store-devtools))
    with an appropriate Chrome extension.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD application with @ngrx/store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a practical example, we will reuse the same CRUD sample implementation
    from the section *CRUD sample implementation with DataTable*. Start off by adding
    the `ngrx` dependencies for a Redux-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we need to define a shape for the store. In real applications,
    most likely available employees and currently selected employee might be shared
    across several components. Hence the store could be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to define actions which consist of types and optional payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice is to create *Action Creator Services* encapsulating associated
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md](https://github.com/ngrx/ngrx.github.io/blob/master/store/recipes/actions/action_services.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the service `CrudActions` with four CRUD actions and associated
    action creators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The core part is the reducer. The reducer function takes a state and an action
    and then uses a `switch` statement to return a new state depending on the action
    type. The current state will not be mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is also a `default` switch statement which just returns
    the current state in case the provided action doesn't match any of the predefined
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can configure `AppModule` with the `ngrx/store` module. It is done
    by importing the `StoreModule` that should call the `provideStore` method with
    the name of our reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, you can provide multiple reducers as well. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Internally, `@ngrx/store` uses the `combineReducers` method to create a *meta-reducer*
    which calls the specified reducers with the correct state slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is dispatching the actions and selecting the data. We can inject
    `CrudActions` into `EmployeeService` and create corresponding actions for every
    CRUD operation. Return values are of the type `Observable<Action>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the component class, we receive actions and dispatch them by calling `store.dispatch(action)`.
    Dispatching the actions will only be demonstrated for two CRUD operations: loading
    all employees and removing one employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting the data in `@ngrx/store` is achieved by calling `store.select()`.
    The `select` method expects a name of the reducer function to select slice(s)
    of state for displaying in view(s). The return value of the `select` method is
    `Observable`, which allows subscription to the store''s data. The next code snippet
    demonstrates such subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The lifecycle method `ngOnInit` is a good place for subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: The complete demo application with instructions is available on GitHub at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter9/redux).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned more PrimeNG components and directives for
    various use cases. The chapter explained interesting features of FileUpload, Draggable,
    Droppable, Galleria, Defer, BlockUI, ProgressBar, and more. You have seen a real-world
    implementation of CRUD application with DataTable and mocked backend. A best practice
    with ConfirmationDialog and guarded routes was demonstrated as well. After reading
    this chapter, you are equipped with necessary knowledge to be able to create different
    custom components for the next few Angular and PrimeNG web applications. The Redux
    architecture is not a foreign concept anymore. You are best prepared for an advantageous
    state management in complex web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter gives an introduction to the unit and e2e testing with modern
    frameworks. You will learn how to test and debug Angular applications. Tips on
    test-driven development will not be missing either.
  prefs: []
  type: TYPE_NORMAL
