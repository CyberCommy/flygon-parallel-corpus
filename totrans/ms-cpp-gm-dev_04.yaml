- en: Building the Asset Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Games are essentially a collection of assets or content packaged in a fun and
    engaging way. Handling all the needed content for a video game can be a large
    challenge in itself. Having a structure in place to import, convert, and consume
    these assets is a necessity in any real project. In this chapter, we are going
    to explore the topic of developing and implementing an asset pipeline. The following
    are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing model meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an asset pipeline?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](00070916-c402-4eb3-88d6-f3e02a4d8455.xhtml), *Building a Strong
    Foundation*, we took a look at how we can use the structure of helper and manager
    classes to wrap multiple methods into an easy to consume interface to work with
    various pieces of the project. We are going to use these techniques throughout
    the next few sections to build our own custom framework/content pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Handling audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we are going to ease ourselves into the process, by looking
    at how to handle audio assets in our game projects. To help us with the process
    we are going to again use a helper library. There are literally hundreds of different
    libraries to help with the use of audio. Some of the more popular choices are
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: FMOD ([http://www.fmod.org](http://www.fmod.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wwise ([https://www.audiokinetic.com/products/wwise/](https://www.audiokinetic.com/products/wwise/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAudio2 ([https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee415813(v=vs.85).aspx))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAL ([https://www.openal.org/](https://www.openal.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDL_mixer ([https://www.libsdl.org/projects/SDL_mixer/](https://www.libsdl.org/projects/SDL_mixer/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each library has its own strengths and weaknesses. Choosing the right one for
    your project boils down to a few different questions you should ask yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Does this library meet your technical needs? Does it have all the features you
    want?
  prefs: []
  type: TYPE_NORMAL
- en: Does it meet the project's budget constraints? A lot of the more robust libraries
    have a large price tag.
  prefs: []
  type: TYPE_NORMAL
- en: Is this library's learning curve within your own, or team's, skill range? Picking
    an advanced API with a bunch of cool features might seem like a good idea, but
    if you spend more time trying to understand the API than implementing it, that
    could be detrimental.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this book, I chose to use `SDL_mixer API` for a few reasons.
    First, it is fairly easy to get started with, compared to some of the others.
    Second, it matches my project's needs very well. It has support for FLAC, MP3,
    and even Ogg Vorbis files. Third, it connects well with the rest of the project's
    framework since it is an extension to the SDL library we are already using. Lastly,
    I chose this API because it is open source and has a simple license that does
    not require me to pay the creator a share of my game's proceeds in return for
    using the library.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by taking a look at the declaration and implementation of a few
    different classes we will need. The file we are looking at is the `AudioManager.h` file
    that can be found in the `Chapter04` folder of the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the necessary includes, the `SDL/SDL_mixer.h`, `string`, and
    `map` implementations. Like all other engine components, we have been building,
    we wrap these declarations in the `BookEngine` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `"AudioManager.h"` file, we have the declaration of a few helper
    classes. The first one is the `SoundEffect` class. This class defines the structure
    of the sound effect object to be used in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These can include sounds like the player jumping, weapon fire, and really anything
    we will play in a short burst.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the class definition, we need a `friend` class statement that will allow
    this class access to the `AudioManager` class methods and variables, including
    private ones. Next we have the definition of the `Play` function. This function
    will simply play the sound effect and take just one argument, the number of times
    to loop through the sound. By default, we set this to `0`, if you pass `-1` as
    the number of loops it will set the sound effect to loop indefinitely. The last
    definition is for a private variable of type `Mix_Chunk`. `Mix_Chunk` is a `SDL_mixer`
    object type that stores the audio data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Mix_Chunk` object structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the internals of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allocated`: If this is set to `1`, `struct` has its own allocated buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abuf`: This is a pointer to the audio data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alen`: This is the length of the audio data, in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: This is a per sample volume value between 0 and 128'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next helper class we have in the `AudioManager.h` file is the `Music` class.
    Like the sound effect, the `Music` class defines the structure of a `Music` object.
    This can be used for sounds like the loading screen music, background music, and
    really any sound we wish to play for an extended time or will need to stop, start,
    and pause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the class definition, we again start with a `friend` class statement so
    that the `Music` class will have access to the needed parts of the `AudioManager`
    class. Next we have a `Play` function, and just like the `SoundEffect` class,
    it takes a single argument to set the amount of loops the sound will go through.
    After the `Play` function, we have three more functions, `Pause()`, `Stop()`,
    and `Resume()` function. These three functions are just wrappers to the underlining
    SDL_mixer API calls, for pausing, stopping, and resuming the music, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a private declaration for the `Mix_Music` object. `Mix_Music`
    is the SDL_mixer datatypes used for music data. It supports the loading of WAV,
    MOD, MID, OGG, and MP3 sound files. We will see more about this in the implementation
    section next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After the two `Music` and `SoundEffect` helper classes, we now come to the `AudioManager`
    class definition. The `AudioManager` class will do most of the heavy lifting on
    our side, it will load, hold, and manage creation and deletion of all music and
    sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: Our declaration of the class starts like most others with a default constructor
    and destructor. Next we have an `Init()` function. This function will handle the
    setup or initialization of our audio system. We then have a `Destroy()` function
    that will handle the deletion and cleanup of our audio system. After the `Init`
    and `Destroy` functions, we have two loader functions, `LoadSoundEffect()` and
    `LoadMusicEffent()` function. Both of these functions take a single argument,
    a standard string that holds the path to the audio file. These functions will
    load the audio files and return a `SoundEffect` or `Music` object depending on
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: The private section of our class has three objects. The first two private objects
    are maps of either type `Mix_Chunk` or `Mix_Music`. This is where we will store
    all the effects and music we will need. By storing a list of sound effects and
    music files we load, we are creating a cache. If we need the file at a later time
    in the project, we can then check these lists and save some valuable loading time.
    The last variable, `m_isInitialized`, holds a Boolean value to specify whether
    the `AudioManager` class has been initialized or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the declaration of the `AudioManager` and helper classes, let''s
    move on to the implementation where we can take a closer look at some of the functions.
    You can find the `AudioManager.cpp` file in the `Chapter04` folder of the code
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation starts out with the includes, default constructor, and destructor.
    Nothing new here, only thing of note is that we call `Destroy()` function from
    the destructor. This allows us two methods of cleaning up the class, through the
    destructor or by explicitly calling the `Destroy()` function on the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function in the `AudioManager` class implementation is the `Init()`
    function. This is the function that will setup all the needed components for our
    manager. The function starts out with a simple check to see if we have already
    initialized the class; if we have, we throw an exception with a debug message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After we check that we haven''t already, we move on to initializing the SDL_mixer
    objects. We do this by calling the `Mix_Init()` function and passing in a bitwise
    combination of flags to set the supported file types. This can be a combination
    of FLAC, MOD, MP3, and OGG. In this example, we are passing the flags for OGG
    and MP3 support. We wrap this call in an if statement to check if the `Mix_Init()` function
    call had any issues. If it does run into an error, we throw another exception
    with a debug message containing the error information returned from the `Mix_Init()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the  `SDL_mixer` function has been initialized, we can call `Mix_OpenAudio`
    to configure the `frequency`, `format`, `channels`, and `chunksize` to use. It
    is important to note that this function must be called before any other `SDL_mixer`
    functions. The function definition looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the arguments mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`frequency`: This is the output sampling frequency in samples per second, Hz.
    In the example, we use `MIX_DEFAULT_FREQUENCY` define, which is 22050, a good
    value for most cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This is the output sample format; again, in the example, we set this
    to the default value by using `MIX_DEFAULT_FORMAT` define, which is the same as
    using `AUDIO_S16SYS` or Signed 16-bit samples, in system byte order. To see the
    full format, define list, see the `SDL_audio.h` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channels`: This is the number of sound channels in the output. 2 channels
    for stereo, 1 for mono. The value 2 is used for our example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chunksize`: This is the bytes used per output sample. We use `1024` bytes
    or 1 **megabyte** (**mb**) for our chunksize.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the last thing we do in this function is to set the `m_isInitalized`
    Boolean value to true. This will stop us from accidentally trying to initialize
    the class again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function in the `AudioManager` class is the `Destroy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I will not go through this function line by line as it is self-explanatory.
    The basic overview is; check if `AudioManager` has been initialized, if it has
    then we use the `Mix_FreeChunk()` function to free each of the sound and music
    resources we have created. Finally we use `Mix_CloseAudio()` and `Mix_Quit()` to
    shutdown, clean up, and close the SDL_mixer API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoadSoundEffect` is the next function we have to look at. This function
    much like its name suggests is the function that loads sound effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first step in this function is to create a `SoundEffect` object to temporarily
    hold the data until we return the effect to the calling method. We simply call
    this variable, effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created our holding variable, we do a quick check to see if this
    effect we need has already been created and stored in our cache, the map object,
    `m_effectList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting way we do it here is by creating an iterator variable and assigning
    it the result of `Map.find()`, where the argument passed is the location of the
    sound file we want to load. The cool thing about this method is that if the sound
    effect is not found in the cache, the iterator value will be set to the index
    of the end object of the map, allowing us to do a simple check that you shall
    see as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the iterator value trick, we simply do a check to see if the value of
    `iter` variable matches the return value of the `Map.end()` function; if it does,
    this means that the sound effect is not in the cache list and should be created.
  prefs: []
  type: TYPE_NORMAL
- en: To load the sound effect, we call the `Mix_LoadWAV()` function with the argument
    of the files path location as a `c` string. We assign the returning object to
    a `Mix_Chunk` pointer called chunk.
  prefs: []
  type: TYPE_NORMAL
- en: We then check to see if the value of the chunk is a `nullptr` pointer,indicating
    that the loading function has hit an error. If it is a `nullptr` pointer, we throw
    an exception with some debug information provided by the handy `Mix_GetError()`
    function. If successful, we assign our temporary holder, the effect's member `m_chunk`,
    the value of chunk, which is our loaded sound effects data.
  prefs: []
  type: TYPE_NORMAL
- en: Next we add this newly loaded effect into our cache so that we can save some
    effort in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if our check on the `iter` value returns false, that means the
    sound effect we are trying to load is in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The true beauty of the iterator tick is now revealed. The lookup result, that
    is the result of the line `auto iter = m_effectList.find(filePath);`, when it
    finds the sound effect will then point to that effect in the list. So all we have
    to do is assign the holder variable effects member value `m_chunk` to the `iter`
    second value, which is the data value for the effect. The last thing we do in
    the `LoadSoundEffect()` function is return the effect variable to the calling
    method. This completes the process and our sound effect is now ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `LoadSoundEffect()` function, comes the `LoadMusic()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I am not going to go over this function in detail, because as you can see it
    is very much like the `LoadSoundEffect()` function, but instead of wrapping the
    `Mix_LoadWAV()` function, it instead wraps the `Mix_LoadMUS()` of the `SDL_mixer`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two function implementations in the `AudioManager.cpp` file do not
    belong to the `AudioManager` class itself, but instead are implementations of
    the `Play` functions for both the `SoundEffect` and `Music` helper classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I won't step through each function line by line, instead I would like to simply
    point out how these functions create wrappers around the SDL_mixer, `Mix_PlayChannel`,
    and `Mix_PlayMusic` functions. This is in essentially the point of the `AudioManager`
    class, it is simply a wrapper that abstracts the process of loading the files
    and creating the objects directly. This helps us to create an expandable framework,
    the pipeline, without the worry of the underlying mechanisms. This means that
    at any time we could, in theory, replace the underlying library with another or
    even multiple libraries, without disturbing the code that calls the manager class
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: To round out this example, let's take a look at how we would use this `AudioManager`
    in a demo project. You can find this demo in the `Chapter04` folder of the code
    repository, labeled `SoundExample`. Credit for the music goes to Bensound ([http://www.bensound.com](http://www.bensound.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the `GameplayScreen.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We add two new objects to the private declarations, one for the `AudioManager`
    named `m_AudioManager` and one for the `Music` object, named `m_bgMusic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GameplayScreen.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To initialize, load, and play our music file, we need to add three lines to
    the `GameplayScreen` classes `OnEntry()`.
  prefs: []
  type: TYPE_NORMAL
- en: The first line `m_AudioManager.Init()` sets up the `AudioManager` and initializes
    all the components as we saw earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we load the music file, in this case the `bensound-epic.mp3` file, and
    assign it to the `m_bgMusic` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line, `m_bgMusic.Play()`, starts the music track playing. By not passing
    in the amount of times to loop the music track, it defaults to `-1`, which means
    it will continue to loop until the program stops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That handles the playing of the music track, but we need to add a couple of
    more function calls to clean up the `AudioManager` when the game is ended and
    to stop the music if we switch screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the music from playing when we leave this screen, we add the following
    to the `GameplayScreen` class `OnExit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To clean up the `AudioManager` and stop any potential memory leaks, we call
    the following in the `GameplayScreen` class `Destroy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will in turn handle the destruction and clean-up of any audio assets we
    have loaded as we covered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in place now, if you run the `SoundExample` demo, you will hear
    some epic adventure music start to play, and continuously loop if you are patient
    enough. Now that we have some sound in the game, let's step it up a bit and look
    at how we can get some visual assets into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Working with textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A texture, if you are unfamiliar with the term, can basically be thought of
    as an image. These textures can be applied to a simple geometric square, two triangles,
    to make an image. This type of image is commonly referred to as a `Sprite`. We
    use a `Sprite` class in the demo at the end of this section. It is also important
    to note that textures can be applied to more complex geometry and are used in
    3D modeling to skin objects. Textures will play a larger part as we continue with
    the demos later on in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Resource manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start at the high level class, the `ResourceManager`. This manager class
    will be responsible for maintaining resource objects in a cache as well as providing
    a simple, abstracted interface to acquiring the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration file, `ResourceManager.h`, is a simple class consisting of
    one public function `GetTexture`, and one private member of type `TextureCache`.
    The `GetTexure` will be the function we expose to other classes. It will be responsible
    for returning the texture object. The `TextureCache` is like the cache we used
    in `AudioManager`, it will hold loaded textures for later use. Let''s move on
    to the implementation so we can see how this is setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `ResourceManager` implementation is really just an abstracted call to the
    underlying structure. When we call the `GetTexture` function of the `ResourceManager` class
    we are expecting to get a `GLTexture` type back. As the caller of this function,
    I don't need to worry about the internal workings of `TextureCache` or how the
    object is parsed. All I have to do is specify the path of the texture I wish to
    load and the asset pipeline does the rest. This should be the ultimate goal of
    the asset pipeline system regardless of the methods, the interfaces should be
    sufficiently abstract to allow developers and designers to import and consume
    assets in the project without the implementation of the underlying systems becoming
    a blocker.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will look at this example texture system that is the core underneath
    the simplicity of the `ResourceManager` class interface.
  prefs: []
  type: TYPE_NORMAL
- en: Texture and TextureCache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier we saw two new objects introduced that comprise the structure of the
    `ResourceManager` class, the `GLTexture` and `TextureCache`. In the coming sections,
    we will take a look at these two classes in more detail so we can see how these
    classes connect to other systems to build a robust asset management system, all
    leading back to the simple interface of `ResourceManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with we will take a look at the class, `GLTexture`. This class is
    comprised solely of a `struct` that describes the attributes of our texture. Here
    is the code for the `GLTexture` class in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the `GLTexture` class is really just a wrapper for a `struct`,
    also called `GLTexture`. This `struct` holds some simple values. A `GLuint id`,
    used to identify the texture and two integer values, `width` and `height`, which
    of course hold the textures/images height and width. This `struct` could easily
    be included in the `TextureClass`, I chose to implement it this way to, one, make
    it a little easier to read, and two, to allow some flexibility for future development.
    Again we want to make sure that our asset pipeline allows for the adaption of
    different needs and the inclusion of new asset types.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the `TextureCache` class, as we did with our audio assets, it is
    a good idea to create a cache for our image files. This again will provide us
    quicker access to the needed image files by saving them in a map and returning
    them as needed. We only have to create a new texture if it does not already exist
    in the cache. I tend to favor this type of implementation with a cache mechanism
    when building any system that works with assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these examples provide a basic implementation, they are a great starting
    points for creating more robust systems, with memory management and other components
    integrated. The following is the declaration of the `TextureCache` class, it should
    look very familiar from the preceding audio example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the implementation of the `TextureCache` class, in the `TextureCache.cpp`
    file, let''s take a look at the `GetTexture()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This implementation again will look very similar to the `AudioManager` example
    we saw earlier. The main line to pay attention to here is the line that calls
    the `ImageLoader` class to load the image file, `GLTexture newTexture = ImageLoader::LoadPNG(texturePath);`.
    This call is the heavy lifting aspect of the class, and as you can see we again
    are abstracting the underlying system and simply providing a `GLTexture` as the
    return type from our `GetTexture` class. Let's jump ahead and look at the implementation
    of the `ImageLoader` class in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The ImageLoader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the structure in place to pass our texture object back up to
    our calling resource manager, we need to implement to class that actually loads
    the image file. The `ImageLoader` is that class. It will handle the loading, processing,
    and creating of the texture. This simple example will load a **Portable Network
    Graphics** (**PNG**) format image.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are focusing on the structure of the asset pipe here, I am going to
    stick to the core sections of the class. I will assume some knowledge of OpenGL's
    buffer and texture creation. If you are not familiar with OpenGL, I highly recommend
    the OpenGL bible series as a great reference. We will be looking at some of these
    features later on when we look at some of the advanced rendering and animation
    techniques in the future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the `ImageLoader.h` file has only a single declaration for
    a `LoadPNG` function. This function takes one parameter, which is the path to
    the image file and it will return a `GLTexture`. Here is the `ImageLoader` in
    its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the implementation, inside of the `ImageLoader.cpp` file, let''s
    go through the `LoadPNG` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create a few temporary variables to hold our working
    data. An unsigned `long` for `height` and `width`, a `GLTexture` object, which
    we then initialize all its fields to `0`. Then we have two vector containers of
    unsigned char's. The `in` vector will be the container that will house the raw
    encoded data to be read in from the PNG. The `out` vector will hold the decoded
    data that has been converted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have two function calls. The first we call a function that uses the
    `IOManager` class `ReadFileToBuffer` function to read in the image files raw data.
    We pass in the `pathToFile`, and the vector in; the function will then fill the
    vector with the raw encoded data. The second call is to the `DecodePNG` function;
    this is the call to the single function library I mentioned before. This library
    will handle the reading of the raw data, decoding, and filling of the out vector
    container with the decoded data. The function takes four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the vector to hold the decoded data, in our case the `out` vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the `width` and the `height` variables, which the `DecodePNG`
    function will fill in with the images values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is a reference to a container that holds the encoded data, in our
    case, the `in` vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last parameter is the size of the buffer, the size of the vector `in`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two calls are the major part of this class, they complete the system that
    comprise the image loading component of our asset pipeline. We won't dive into
    the reading of the raw data and decoding right now. In the next section, we will
    see a similar technique to load 3D models, where we will see how to read and decode
    data in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the function will handle the uploading and processing of the image
    in OpenGL, again I am not going to spend time on this section of the function.
    We will see more of the OpenGL framework's calls as we move forward and I will
    go into more depth at that time. This example is built specifically for OpenGL,
    it however could easily be replaced with more generic code, or code specific to
    another graphics library.
  prefs: []
  type: TYPE_NORMAL
- en: Minus the `IOManger` and `DecodePNG` classes, this rounds out the image handling
    of the asset pipeline. As hopefully you can see, having a structure in place,
    such as we have seen, allows a lot of flexibility under the hood while providing
    a simple interface that requires little knowledge of the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a texture returned with a simple one line call, `ResourceManger::GetTexture(std::string
    pathToTextureFile)`, let''s bring this example full circle and see how we plug
    into this system to create a `Sprite` (2D image) from the loaded texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the texture example project, jumping into the `Sprite` class, if we focus
    on the `Init()`, we see where our simple interface allows us to call the `ResourceManager` classes
    `GetTexture` to return the handled image. That's it, very simple! Of course this
    is not limited to just sprites we can use this function to load textures for other
    uses, such as modeling and GUI uses. We can also expand this system to load more
    than just PNG's, in fact I would challenge you to spend some time building this
    out for more file formats, DDS, BMP, JPG, and others. The `ResourceManager` itself
    has a lot of room for improvement and growth. This basic structure is easily repeatable
    for other assets, such as sound, 3D models, fonts, and everything else. In the
    next section, we dive a little deeper and will look at the loading of 3D models
    or meshes as they are commonly referred to.
  prefs: []
  type: TYPE_NORMAL
- en: To see the whole system at work, run the texture example project, you will be
    presented with a very nice image of the sun, provided by the kind folks at NASA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/3a736c0d-67d0-48d3-af09-1d555fcdf520.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa594644-04dd-475e-8dbf-230a26edc3bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Importing models – meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Models or meshes are representations of objects in a three-dimensional space.
    These models could be anything from the player''s character to a small scenery
    object, such as a table or chair. Loading and manipulating these object is a huge
    part of the game engine and the underlying systems. In this section, we will look
    at the process of loading in a 3D mesh. We will walk through a simple file format
    that describes the object in three-dimensional terms. We will look at how to load
    this file format and parse it into a readable format to share with the graphics
    processor. Finally, we will touch on the steps used by OpenGL to render the object.
    Let''s dive right in and begin with the `Mesh` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our `Mesh` class declaration file, `Mesh.h`, is pretty simple. We have the `normal`
    constructor and destructors. Then we have two more functions exposed as `public`.
    The `Init()` function, which will initialize all of the `Mesh` components, and
    the `Draw` function, which will do the actual processing to pass the information
    to the renderer. In the `private` declarations, we have a bunch of variables to
    hold the mesh's data. The first is the `GLuint m_vao` variable. This variable
    will hold a handle to the OpenGL vertex array object, I won't go into this in
    detail right now, refer to the OpenGL documentation for a quick break down.
  prefs: []
  type: TYPE_NORMAL
- en: The next two `GLuint` variables, `m_vertexbuffer` and `m_uvbuffer` are holders
    for, like their names suggest, buffers of data for the `vertex` and `uv` information.
    More on this in the implementation that follows. After the buffers, we have a
    `GLTexture` variable `m_texture`. You will remember this object type from earlier;
    this will house the mesh's texture. The last three variables are vectors of `glm
    vec3`. These hold the Cartesian coordinates for the `vertices`, texture `uvs`,
    and `normal` of the `Mesh`. In this current example, we will not be using the
    normal values.
  prefs: []
  type: TYPE_NORMAL
- en: 'That gives us a good understanding of what our `Mesh` class will need; now
    we can move on to the implementation. We will walk through the class, diverting
    to other classes as they arise. Let''s begin in the `Mesh.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mesh.cpp` file starts out with the constructor implementation. The `Mesh`
    constructor sets the values of the two buffers and the vertex array object to
    zero. We do this so we can do a simple check later on to see if they have been
    initialized or for deletion, which we will see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor for the `Mesh` class handles the deletion of the `Buffer` and
    `Vertex` arrays. We do a simple check to see if they are not set to zero, meaning
    they have been created, and then delete them if they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Moving on to the `Init()` function, we start off with the loading of our assets.
    Here we the texture that our model will need using a familiar helper function
    the `ResourceManager` class `GetTexture` function. We also load `Mesh`, in this
    case an OBJ format model called `Dwarf_2_Low.obj`, provided by andromeda vfx on
    [TurboSquid.com](https://www.turbosquid.com/). This happens through the use of
    the `LoadOBJ` function. Let's jump out of our `Mesh` class for a minute and look
    at how this function is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MeshLoader.h` file, we see the declaration of the `LoadOBJ` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadOBJ` function takes four parameters, the file path to the OBJ file
    to load, and three vectors that will be filled with the data found in the OBJ
    file. The function also has a return type of a Boolean, this is for a simple error
    checking ability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on and see how this function is put together and how it will
    parse the data to fill the vectors we created, it is important to understand the
    structure of the file we are using. Luckily for us the OBJ file is an open file
    format and can actually be read in plain text in any text editor. It is also possible
    for you to create very simple models by hand with the OBJ format. To give you
    an example let''s look at the `cube.obj` file as viewed in a text editor. Side
    note, you can view an OBJ formatted model 3D rendering in Visual Studio; it even
    has basic editing tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is a lot of data packed into these files. Remember this
    is just a simple cube model being described. Take a look at the dwarf OBJ file
    to get an even deeper sense of the data contained. The important parts to us are
    the `v`, `vt`, `vn`, and `f` lines. The `v` lines describe the geometric vertices
    of the `Mesh`, that is the `x`, `y`, `z` values of the model in local space (coordinates
    with a origin that is relative to the model itself). The `vt` lines describe the
    texture vertices for the model, this time the values are normalized x and y coordinates,
    normalized meaning they are a value between `0` and `1`. The `vn` lines are the
    descriptions of the vertex normals, we won''t use these in our current example,
    but these values give normalized vector units that are perpendicular to the vertex.
    These are very useful values to know when computing things like lighting and shading.
    The following figure depicts the vertex normals of a dodecahedral shaped mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad51a2a6-61ac-40c0-a653-2051ae5fa0e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The last set of lines, the `f` lines, describe the faces of the mesh. These
    are groups of three vector values that make a single face, a triangle, of the
    mesh. These are again local space x, y, and z coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file once rendered in our example engine will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86bfbce9-6b72-4de1-a863-f627e9343062.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay that is the OBJ file format in a nutshell, now let''s move ahead and take
    a look at how we will parse this data and store it in buffers for our renderer
    to use. Inside the `MeshLoader.cpp` file, we find the implementation of the `LoadOBJ()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the `LoadOBJ` function, a few holder variables are created. The first
    line of variable declarations is a set of three vectors of integers. These will
    hold the indices of the `vertices`, `uvs`, and `normals`. After the indices, we
    have three more vectors. Two `vec3` vectors for the `vertices` and `normal`, and
    one `vec2` vector for the `uvs`. These vectors will hold the temporary values
    for each, allowing us to perform some calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we start a `try` block that will house the core logic for the function.
    We do this so we can throw some exception if any issues arise and catch them internally
    at the end of this function. The first line in the `try` block, `std::ifstream
    in(path, std::ios::in);` attempts to load the file at the location we passed in.
    The `ifstream`, which, as you might have noticed, is part of the standard library,
    is used to define a stream object that can be used to read in character data from
    a file. It is very common to see `ifstream` used in modern I/O systems, it is
    the C++ replacement for the commonly seen `fopen`, which is actually C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then test to see if there were any errors loading the file with the
    simple if statement `if(!in)`, which is the same as checking the state flags directly
    such as `in.bad() == true; or in.fail() == true`. If we do encounter an error,
    we throw an exception with a debug message. We handle this exception later in
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next we need to create a loop so we can traverse the file and parse the data
    as needed. We do this using a `while()` loop using the `std::getline(in, line)`
    function as the parameter. The `std::getline` returns a single line of characters
    until it reaches an end of line character. The `parameters std::getline()` takes
    are the stream containing the characters, in our case `in` and a `std::string`
    object that will hold the function's output.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using this as the `while` loop''s condition parameter, we will continue
    to step through the input file, line by line, until we reach the end of the file.
    The time during which the condition will become false, we will stop the loop.
    This is a very handy method of stepping through files to parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inside of our `while` loop, the first thing we want to try and parse is the
    vertex data in the OBJ file. If you remember from our earlier explanation, the
    vertex data is contained in a single line, denoted by a `v`. Then to parse our
    vertex data, we should first test to see if the line is a vertex (`v`) line. The
    `std::string()` object has a handy method that allows you to select a defined
    amount of characters from the string. This method is the `substr()`, the `substr()`
    method can take two arguments, the starting position and the ending position of
    the characters in the string. This creates a substring object that we can then
    test against.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the `substr()` method to take the first two characters
    of the string, line, and then test to see if they match the string `"v "` (notice
    the space). If this condition is `true`, that means we have a vertex line and
    can then move on to parsing it into a useful form for our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is pretty self-explanatory, but let''s highlight some important parts.
    The first is the `std::istringstream` object `v`. A `stringstream` is a special
    object that provides a string buffer with a convenient way to manipulate strings
    much like it was an I/O object (`std::cout`). This means you can treat it like
    a stream using the `>>` and `<<` operators, but also use it like a `std::string`
    using the `str()` method. We use our string stream object to house a new collection
    of characters. These new characters are provided by the method call to `line.substr(2)`.
    This time by only passing one argument, `2`, to the `substr` method, we are telling
    it to return the rest of the line starting at the second character. What this
    does is return the values `x`, `y`, and `z` of the vertex line without the `v`
    denotation. Once we have this new collection of characters, we can step through
    each one and assign it to the double variable it matches. As you can see, this
    is where we use the unique nature of the string stream object to stream out the
    character to its variable, the `v >> x;``v >> y; v >> x;` line. At the end of
    the `if` statement we then turn these `x`,`y`,`z` doubles into a `vec3` and finally
    push the newly created `vec3` to the back of the temp `vertices` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For the textures we do much of the same thing. The major difference, besides
    checking for `"vt"`, is that we are only looking for two values, or `vec2` vector''s.
    The other note here is that we invert the `v` coordinate since we are using texture
    formats, which are inverted. Remove if you want to use TGA or BMP format loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For the normals, we do the exact same as we did for the vertices, but look
    for `vn` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the faces, a collection of triangles, we do something a little differently.
    First we check to see if we have a `"f "` line. If we do, we setup a few arrays
    to hold the indexes of the `vertex`, `uv`, and `normal`. We then convert our `std::string`,
    line, to a character array, which is referred to as C string, with the line `const
    char* cstring = line.c_str();`. We then use another C function, `sscanf_s` to
    parse the actual string and separate out each character into the specific index
    array element. Once this statement finishes, the `sscanf_s()` function will return
    an integer value of the element''s set, which we give to the variable matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `matches` variable to check and see if it is equal to `9`,
    which means we have nine elements and it is a format we can work with. If the
    value of matches is not `9`, that means we have a format that we are not setup
    to handle, so we throw an exception with a simple debug message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we do in the `"f "` or face line if statement, is to take all
    the separated elements and push them into the corresponding indices vector. We
    use these values to build the actual mesh data next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To create our final mesh data to give the output vectors, we create another
    loop to step through the model data, this time using a for loop and the amount
    of vertices as the condition. We then create three variables to hold the current
    index to each `vertex`, `uv`, and `normal`. Each time we go through this loop,
    we set this index to the value of `i`, which increments each step through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then thanks to these index values, we can get the attributes for each `vertex`,
    `uv`, and `normal`. We set these in either a `vec2` or `vec3`, which is what we
    will need for the output vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last step is to push these new values into their specific output
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we have the `catch` block to match the `try` block from the top. This
    catch is very simple, we take the reason member object from the incoming `Exception`
    object and use it to print the debug message to the error log file. We also return
    false from the `LoadOBJ()` function to let the calling object know that there
    was an error. If there is nothing to catch, we simply return true, to let the
    calling object know everything worked as expected. We are now ready to use this
    function to load our OBJ files and produce useful data for the rendering system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, moving back to the `Mesh.cpp` file, we will continue on and use this loaded
    data to draw the model with the example engine. I won''t spend too much time on
    each function, again this is specific to the OpenGL API, but could be written
    in a more generic way or to use another graphics library such as DirectX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we check to see if the vertex array object has already been generated;
    if it has not, we go ahead a make one using our `m_vao` as the referenced object.
    Next we bind the VAO, this will allow us to use it for all subsequent OpenGL calls
    in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we check if our vertex buffer has been created; if not we create one using
    the `m_vertexbuffer` variable as the referenced object. We do the same for the
    `uvbuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The last things we do in our `Meshes Init()` function, is to bind the `vertex`
    and `uv` buffers and then upload the data to those buffers on the graphics card
    with the use of the OpenGL, `glBindBuffer()` and `glBufferData()` functions. Check
    out the OpenGL documentation for more detailed information on these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `Mesh` class `Draw()` function, we start out setting up the texture
    in the OpenGL API framework. We do this with the function calls `glActiveTexture()`,
    which activates the texture, and `glBindTexture()`, which does the actual binding
    of the texture data in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next we bind the buffers and set the attributes for both the vertex data and
    texture coordinate data. Again, I won't focus on the details here, the code has
    comments to explain the parameters of each. For more information on the functions,
    I recommend viewing the OpenGL documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After all the data is bound, and all the attributes are set, we can call the
    function to actually draw the `Mesh` object. In this case, we use the `glDrawArrays()`
    function, passing in `GL_TRIANGLES` as the method of drawing. This means we want
    to render the vertex data using triangles. For fun try changing this value to
    `GL_POINTS`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: At the end of our draw call, we have one last step to complete, the clean up.
    After every OpenGL draw call, it is required to disable the used attributes that
    have been set, and to unbind the used buffers. The `glDisableVertexAttribArray()`
    and `glBindBuffer()` functions are used for these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GameplayScreen.cpp` file, we add our call to initialize the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then start to draw it by simply adding a call to the model''s `Draw()`
    function in the `Draw()` function of `GameplayScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! If you run the `ModelExample`, you will see the output of the
    dwarf model on screen. I have also added a simple 3D camera to the game so you
    can move around the model. `W`, `A`, `S`, and `D` for moving the camera up, left,
    right, and down in game space. Use the mouse to look around.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b10abf5-6f28-4d57-9bda-a5ada9fa57a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the output on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f83fd587-2824-447e-867f-26f6bff4ddee.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a very important part of development, the handling
    of assets. We took a look at the process of importing, processing, and managing
    content, such as sound, images, and 3D objects. With this groundwork system in
    place, we can move on to rounding out the rest of the systems needed for game
    development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at developing the core gameplay systems needed,
    including state systems, physics, cameras, and GUI/HUD systems.
  prefs: []
  type: TYPE_NORMAL
