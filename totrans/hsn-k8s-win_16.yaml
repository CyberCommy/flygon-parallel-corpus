- en: Development Workflow with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's face it—Kubernetes application development is not simple. In the previous
    chapters, we have been mainly focusing on the cluster provisioning and operations
    side of Kubernetes, which has its own complexities. As a software developer working
    with Kubernetes on Windows, you will have quite different challenges. In fact,
    you may need to switch your design approach to cloud-first, cloud-native, Kubernetes-first,
    or another modern approach. You have seen that Kubernetes is good at handling
    Windows applications that were never meant to be hosted in a container at design
    time, but to fully use the power of Kubernetes, you have to reverse this dependency
    and start thinking about Kubernetes as the center of the design and your development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate a few popular tools that you can use in
    your development workflow on Windows, starting with basic integrations for Visual
    Studio 2019 and Visual Studio Code, and ending with advanced snapshot debugging
    using Azure Application Insights. You will also learn how to use Helm (version
    3) for creating redistributable packages for your Kubernetes application. And
    as a cherry on top, we will introduce Azure Dev Spaces, which greatly simplifies
    Kubernetes development for the whole team.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using developer tooling with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging applications using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging containerized applications using Azure Application Insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Kubernetes dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on microservices in a team using Azure Dev Spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later; 64-bit) installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Visual Studio 2019 Community (or any other edition) if you want to
    edit the source code for the application and debug it. Please note that, for the
    Snapshot Debugger feature, you need the Enterprise edition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code, if you want to manage Kubernetes clusters using
    a graphical interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chocolatey package manager for Windows ([https://chocolatey.org/](https://chocolatey.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows/Linux Kubernetes cluster deployed using the **Azure Kubernetes Service **(**AKS**) engine,
    ready to deploy the Voting application from the previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Chocolatey package manager is not mandatory, but it makes the installation
    process and application version management much easier. The installation process
    is documented at [https://chocolatey.org/install](https://chocolatey.org/install).
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, you will need your own Azure account in order to create Azure
    resources for the Kubernetes cluster. If you haven't already created the account
    for the previous chapters, you can read more about how to obtain a limited free
    account for personal use at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Kubernetes cluster using the AKS engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying a Hybrid Azure Kubernetes
    Service Engine Clu**ster*. The deployment of the Voting application to Kubernetes
    has been covered in [Chapter 10](4e5931bc-4267-4631-a5fe-bc140827257d.xhtml), *Deploying
    Microsoft SQL Server 2019 and ASP.NET MVC Application*.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this book chapter from the official
    *GitHub* repository at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Using developer tooling with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your everyday development of .NET applications on Windows, you will most
    likely use Visual Studio 2019 or Visual Studio Code. In this section, we will
    show you how to install additional extensions for Kubernetes that allow you to
    bootstrap applications for container orchestrators.
  prefs: []
  type: TYPE_NORMAL
- en: Support for managing Windows containers in Kubernetes is currently very limited
    in Visual Studio 2019 and Visual Studio Code. You will not be able to use most
    of the features, such as integration with Azure Dev Spaces, although this is likely
    to change in the future. In the case of .NET Core, you can develop on Windows
    and rely on Linux Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at how you can enable Kubernetes support for Visual
    Studio 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest version of Visual Studio comes with a predefined Azure development workloadthat
    you can easily install from the Visual Studio Installer application directly.
    You do not need to install any additional extensions in order to have Kubernetes
    support in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used Visual Studio Tools for Kubernetes (now deprecated) in the
    previous editions of Visual Studio, then you can expect a similar functionality
    in the Azure development workload in the latest version of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install an Azure development workload, please go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the start menu for Windows, search for the Visual Studio Installer application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your version of Visual Studio, click More, and select Modify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Azure development and accept the changes by clicking Modify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3b8a6b8d-896c-4139-a5e6-890ef713949c.png)'
  prefs: []
  type: TYPE_IMG
- en: Wait for the installation to finish and launch Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can create new projects for the type container application for Kubernetes,
    which uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASP.NET* Core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm charts for packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Dev Spaces for fast iterative development on AKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to add Kubernetes/Helm support for an existing ASP.NET
    Core:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project in Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add | Container Orchestrator Support
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Kubernetes/Helm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, Visual Studio 2019 currently has limited features for managing
    Kubernetes clusters. Alternatively, you can use Visual Studio Code for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Visual Studio Code you can use two *official* extensions from Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes** **(**`ms-kubernetes-tools.vscode-kubernetes-tools`**)**: Enables
    you to explore Kubernetes clusters in the tree view, manage Kubernetes objects,
    and provide IntelliSense for editing manifest files and Helm charts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Dev Spaces (**`azuredevspaces.azds`**)**: Enables Azure Dev Spaces
    integration, similar to what you have in Visual Studio 2019.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install these two extensions, open Visual Studio Code and go through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Extensions panel (*Ctrl *+ *Shift *+ *X*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for Kubernetes in Marketplace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the same for Azure Dev Spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right menu, you can now use the Kubernetes panel, which automatically
    loads your kubeconfig. This extension is especially great for working with workspaces
    containing manifest files, as you get autocompletion, YAML syntax highlighting,
    and validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage your cluster from the tree view or by using commands (*Ctrl *+ *Shift *+ *P*)—this
    can be used instead of executing `kubectl` commands in PowerShell. For example,
    you can follow logs for your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/29d93186-f70d-493f-b6f0-14feb40a227f.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio Code is currently the most useful and advanced tool you can use
    in Windows for working with Kubernetes and Helm. In the next section, we will
    show how you can use Helm for packaging applications.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging applications using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications need packaging for easy redistribution and dependency management.
    In Windows, you can use Chocolatey, in Ubuntu you can use **APT **(short for Advanced
    Package Tool), and for Kubernetes you can use Helm as a package manager([https://v3.helm.sh/](https://v3.helm.sh/)).
    There are a couple of alternatives, such as Kustomize (which comes with native
    support in `kubectl`) and Kapitan, but, in general, Helm is currently regarded
    as the industry standard, with the largest official repository of Helm charts
    ([https://github.com/helm/charts](https://github.com/helm/charts)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main use cases for Helm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying popular software to your Kubernetes cluster. Packages are distributed
    as Helm charts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your own applications as Helm charts. This can include packaging a product
    for consumption by the end users or using Helm as an internal package and dependency
    manager for microservices in your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the applications receive proper upgrades, including dependency
    management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring software deployments for your needs. Helm charts are basically generic
    **Yet Another Markup Language** (**YAML**) parametrized templates for Kubernetes
    manifests. Helm uses Go templates ([https://godoc.org/text/template](https://godoc.org/text/template))
    for parametrization. If you are familiar with Go then you will be at home; if
    not, then you will find it pretty similar to other templating systems, such as Mustache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the architecture of Helm has drastically changed with the recent
    release of version 3.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, Helm required a dedicated service deployed on Kubernetes called
    Tiller, which was responsible for actual communication with Kubernetes API. This
    has caused various problems, including security and RBAC (short for Role-Based
    Access Control) issues. As of Helm 3.0.0, Tiller is no longer needed and chart
    management is done by the client. You can read more about the differences between
    older Helm versions in the official FAQ at [https://helm.sh/docs/faq/#changes-since-helm-2](https://helm.sh/docs/faq/#changes-since-helm-2).
  prefs: []
  type: TYPE_NORMAL
- en: Helm is distributed as a client (library) with a CLI similar to kubectl. All
    operations in Helm can be performed using the client now. Let's install Helm on
    your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is recommended that you install Helm on a Windows machine using Chocolatey.
    To install Helm, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window as an administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following installation command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the installation is finished, verify that you are running version `3.0.0`
    or higher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether you have any repositories that have been added using the `helm
    repo list` command. If you don''t (as in version 3.0.0), add the official `stable`
    repository and update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try searching for some Helm charts—for example, let''s check whether there
    is a chart for Microsoft SQL Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Helm Hub** ([https://hub.helm.sh/](https://hub.helm.sh/)) offers a user-friendly
    interface for browsing the official Helm repository ([https://github.com/helm/charts](https://github.com/helm/charts)).'
  prefs: []
  type: TYPE_NORMAL
- en: We have found a stable chart for SQL Server running in Linux containers. It
    is based on version 2017, but we can still use it for our Voting application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Microsoft SQL Server using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now walk through how to deploy Microsoft SQL Server to our AKS Engine
    cluster. The structure of each chart is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `root` directory, you can find a detailed readme with a description of
    how to install the chart and what the possible parameters are ([https://github.com/helm/charts/tree/master/stable/mssql-linux](https://github.com/helm/charts/tree/master/stable/mssql-linux)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Chart.yaml` file contains chart metadata, including dependency information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templates` directory contains all Go templates for Kubernetes manifests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `values.yaml` file defines the default values for the chart that can be
    overridden using CLI parameters or by providing a YAML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of installing a Helm chart is straightforward: define the right
    values for your needs (and possibly analyze the templates to understand what is
    happening) and run the `helm install` command. Looking at the chart for SQL Server,
    we need to specify the following `values.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy SQL Server using Helm, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the preceding file as `values.yaml` in your current directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create prerequisites. We need the `dev-helm` namespace and the `azure-disk` StorageClass.
    Create the following `prereq.yaml` manifest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\prereq.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute a dry run of the Helm chart installation. You will be able to see which
    Kubernetes manifest files would be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will perform a dry run of the installation of `stable/mssql-linux`
    as a `demo-mssql` Helm release in the `dev-helm` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are happy with the result, perform the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the deployment of SQL Server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check the status using the Helm CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use a SQL Server Management Studio or SQL Tools container to verify that SQL
    Server is running properly. You can use an external IP address for the service—we
    have exposed a LoadBalancer service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commands for managing Helm releases are namespace-scoped in a similar manner
    to kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using Helm is very efficient for quickly bootstrapping complex
    applications in your cluster. Now, let's prepare a Helm chart for our Voting application.
    We will use an SQL Server chart as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Helm chart for our Voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to package our Voting application as a Helm chart, we will use the
    manifest files from the previous chapter that we used for the Horizontal Pod Autoscaler
    demonstration. You can find the base manifest files in the GitHub repository for
    the book at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/02_voting-application-base](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/02_voting-application-base).
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare the Helm chart, we need to go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather all the required Kubernetes manifest files and determine which parts
    should be parameterized. We will use these for creating Helm template files and
    the `default values` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define all of the dependencies for our application and define the proper parameter
    values for them. We will inject these parameters into the `default values` file
    for our parent chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the Entity Framework database migrations into post-installation and
    post-upgrade Helm hooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The majority of the work here is transforming the raw Kubernetes manifest files
    into Helm templates. We will show only the relevant parts of this process in the
    next few steps. For the best coding experience, use Visual Studio Code for editing
    the Helm charts. You can find the final Helm chart for our Voting application
    in the Github repository at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/03_voting-application-helm](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/03_voting-application-helm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Please go through the following steps to create your Helm chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s uninstall the SQL Server Helm release from the cluster. We will
    install this chart automatically as a dependency in the Voting application parent
    chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create a Helm chart scaffolding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a directory named `voting-application` that contains the basic
    structure and templates for your Helm chart. We will reuse most of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the chart directory using `cd .\voting-application\` and modify
    the chart metadata in the `Chart.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The most important bits of the code here deal with defining the proper dependencies
    and setting the proper `apiVersion`, which will be used as a Docker image tag
    in the templates. Add `mssql-linux` with the latest chart version (`0.10.1`) from
    the official stable repository at `https://kubernetes-charts.storage.googleapis.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `templates` directory using the `cd .\templates\` command. We
    will use `reuse _helpers.tpl` (which contains template helper functions), `service.yaml`,
    `serviceaccount.yaml`, and `ingress.yaml` in the original form. These manifest
    templates will produce exactly what we need without any changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to define a manifest template for our Deployment named `deployment.yaml`;
    you should inspect the original `deployment.yaml` file in the chart scaffolding,
    as you can use the majority of it in our template. The final version of this template
    can be found at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/templates/deployment.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/templates/deployment.yaml).
    As an example, let''s explain how you can parametrize the Docker image tag and
    inject the SQL Server password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze it step by step. The `{{ include "voting-application.fullname"
    . }}` phrase shows you how to include a template defined in `_helpers.tpl` and
    use it as the Deployment name. If there is some more advanced templating logic,
    you should always use this file for defining reusable templates.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker image for the pod container is defined as `"{{ .Values.image.repository
    }}:{{ .Chart.AppVersion }}"`; you use `.Values` for referencing variables defined
    in the `values.yaml` file and `.Chart` for referencing chart metadata. And finally,
    we have used `{{ .Release.Name }}-mssql-linux-secret` in order to reference the
    secret created by the dependent SQL Server chart.
  prefs: []
  type: TYPE_NORMAL
- en: You need to know the internals of the dependent chart to know what value should
    be used ([https://github.com/helm/charts/blob/master/stable/mssql-linux/templates/secret.yaml](https://github.com/helm/charts/blob/master/stable/mssql-linux/templates/secret.yaml)[).](https://github.com/helm/charts/blob/master/stable/mssql-linux/templates/secret.yaml)
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Helm does not have an easy referencing process for such values
    from dependent charts, so you have to either hardcode the name by following the
    conventions used by Helm (which we did) or define a dedicated template in `_helpers.tpl`
    (which is a more clean approach, but also more complex).
  prefs: []
  type: TYPE_NORMAL
- en: To define RBAC roles and RoleBindings, we create two additional template files, `rolebinding.yaml`
    and `role.yaml`. You can find the contents in [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/03_voting-application-helm/templates](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/03_voting-application-helm/templates).
    Defining RBAC manifests for the application can be made conditional; you can see
    this practice in the official Helm charts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last manifest that we need to define is a Helm hook ([https://helm.sh/docs/topics/charts_hooks/](https://helm.sh/docs/topics/charts_hooks/))
    for running Entity Framework database migrations ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/templates/post-install-job.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/templates/post-install-job.yaml)).
    A hook is just like any other manifest template, but it has additional annotations
    that ensure that the manifest is applied at a certain point in the lifecycle of
    a chart release. Additionally, if the hook is a Kubernetes job, Helm can wait
    to finish the job and provide cleanup. We want this hook to be a job, the same
    kind that we have already used for EF migrations, and we want it to be executed
    after the release is installed or upgraded. Let''s see how we can define the annotations
    for our job in the `post-install-job.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The key annotation that turns a manifest template into a hook is `"helm.sh/hook"`.
    We use `post-install` and `post-upgrade` values to ensure that the hook is executed
    after installation and after the upgrade of the Helm release. The `"helm.sh/hook-weight"` phrase
    is used for determining the order of hooks, which in our case doesn't matter,
    as we have only one hook.
  prefs: []
  type: TYPE_NORMAL
- en: The `"helm.sh/hook-delete-policy"` phrase defines the cases in which the job
    instances should be automatically deleted. We would like to delete them only on
    a successful hook execution; otherwise, we want to leave the resources so that
    we can debug the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we specify the job `backoffLimit` as `10`; we need this in
    case of a long SQL Server pod creation, which, in this case, can take even a few
    minutes; if we don't do this, the hook will fail too quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is providing default template values in the `values.yaml` file
    in the root directory of the chart ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/values.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter12/03_voting-application-helm/values.yaml)).
    Let''s take a look at some important bits in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can organize the values; however, they are already conveniently arranged.
    For example, everything regarding the Docker image is grouped into the image node,
    and then you can reference the image repository name in the chart as `{{ .Values.image.repository
    }}`. A very important thing to remember is to provide a proper `nodeSelector`,
    which ensures that the pods are scheduled for Windows nodes only. Lastly, you
    define the values for a dependent chart using its name.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used `mssql-linux` because this is the chart that we reference
    in the `Chart.yaml` file. You can read more about managing dependencies and defining
    the values in the documentation at [https://helm.sh/docs/topics/charts/#chart-dependencies](https://helm.sh/docs/topics/charts/#chart-dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: Many aspects of Helm are based on conventions. You can find more about the best
    practices for implementing charts in the documentation at [https://helm.sh/docs/topics/chart_best_practices/](https://helm.sh/docs/topics/chart_best_practices/).
    Use the `helm lint` command to check whether there are any issues with your chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chart for our Voting application is ready. Now, we will install this chart
    to our Kubernetes cluster in the `dev-helm` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window in the `root` directory of the chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that all the dependent charts are fetched from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a `dry run` of the Helm chart installation to check the manifest files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will print all the resolved manifest files that will be applied
    to the installation of the chart in the current directory,`.` , with the default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, install the chart. We need to provide an extended timeout for the installation
    as our Entity Framework database migration job may need a few minutes to succeed.
    This depends on how quickly SQL Server is initialized and ready to connect. Use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation will take a bit of time; you can observe the progress of the
    Deployment for individual Kubernetes objects in a separate PowerShell window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the installation ends, use `kubectl get -n dev-helm svc -w voting-application`
    to get the external IP address of the LoadBalancer service for our Voting application.
    Navigate to the address in a web browser and enjoy!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/171f7646-087d-479b-af81-98ec8625ced1.png)'
  prefs: []
  type: TYPE_IMG
- en: In a production environment, you should use a Helm chart repository to manage
    your charts. You can learn more about setting up a repository at [https://v3.helm.sh/docs/topics/chart_repository/](https://v3.helm.sh/docs/topics/chart_repository/).
    Additionally, to manage releases for Helm charts *declaratively*, similar to `kubectl
    apply`, you may consider using `Helmfile` ([https://github.com/roboll/helmfile](https://github.com/roboll/helmfile)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to easily add Azure Application Insights
    to your ASP.NET MVC application running in a Windows container. We will also show
    you how to perform an upgrade of the Helm release that we have just installed.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a containerized application using Azure Application Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Application Insights is a part of Azure Monitor, which provides **application
    performance management** (**APM**) capabilities for your applications. It is a
    large platform, with a rich **UI** (short for **user interface**) in the Azure
    portal, which provides the following features (among others):'
  prefs: []
  type: TYPE_NORMAL
- en: Request monitoring and tracing, including distributed tracing between multiple
    microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception monitoring and snapshot debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting performance counters for the host machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart anomaly detection and alerting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy log collection and analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most interesting feature for us is snapshot debugging, which can help diagnose
    issues in production Deployments where running with an attached remote debugger
    is not advised. For this, you will need Visual Studio 2019 Enterprise edition
    if you would like to analyze the snapshots using Visual Studio. Alternatively,
    you can perform analysis in the Azure portal itself, which has a lightweight web-based
    debugger available.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use zero-instrumentation application monitoring for Kubernetes
    applications running on Azure using out-of-band instrumentation provided by the
    Istio service mesh, as explained at [https://docs.microsoft.com/en-us/azure/azure-monitor/app/kubernetes](https://docs.microsoft.com/en-us/azure/azure-monitor/app/kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Azure Application Insights together with snapshot debugging, we need
    to go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable Azure Application Insights in the Visual Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.ApplicationInsights.SnapshotCollector` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure snapshot debugging and modify the Serilog configuration to use the
    sink for sending logs to `System.Diagnostics.Trace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a demonstration exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a new Docker image and push it to Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade the Helm release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, we will be able to analyze trace maps, application logs, and exceptions
    directly in the Azure portal. Please note that this log collection solution is
    different from what we demonstrated in [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    a Hybrid Azure Kubernetes Service Engine Cluster, *where we used Azure Log Analytics
    for AKS Engine. They use the same Azure services, but, in the new solution, we
    will get application logs only—you will not see Kubernetes or container runtime
    logs in Azure Log Analytics views.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Azure Application Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please go through the following steps to enable Azure Application Insights in
    our Voting application. Alternatively, you can use the ready source code available
    in the Github repository at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/04_voting-application-azure-application-insights-src](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter12/04_voting-application-azure-application-insights-src).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to do so, you need to provide your own Azure Application Insights
    key in the later steps during the Helm release upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `VotingApplication` solution in Visual Studio 2019.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Solution Explorer, right-click on the `VotingApplication` project, choose
    Add and select Application Insights Telemetry...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/30d776a5-31b6-4ab1-80f8-18b010f920b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Get Started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to Azure and provide a new Resource Group and Resource name (or use
    the default ones).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Register. The operation will take a few minutes. Once this time has passed,
    a new Azure Application Insights instance will be created in your Azure subscription,
    and the appropriate NuGet packages will be added to the Visual Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the resource for CodeLens and enable it to collect traces from `System.Diagnostics`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6bc49f59-621a-410b-be48-85af04691aec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We do not want to have the instrumentation key hardcoded into the Docker image.
    Application Insights supports the ability to inject the key `APPINSIGHTS_INSTRUMENTATIONKEY`
    environment variable. Navigate to the `ApplicationInsights.config` file in the
    solution, find the following XML node, write down the key for further usage, and
    remove the XML node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for all occurrences of your instrumentation key in the solution. You
    will find one more in `_Layout.cshtml`; replace it with the following value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Right-click the `VotingApplication` project in the Solution Explorer and select Manage
    Nuget Packages.... Install the following NuGet package in `Microsoft.ApplicationInsights.SnapshotCollectorandSerilog.Sinks.Trace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the snapshot debugger. In the `ApplicationInsights.config` file,
    ensure that, in the root node `ApplicationInsights`, you have the following XML
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the Serilog sink in the `NinjectWebCommon.cs` file in the `RegisterServices`
    method. Your logger configuration should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `HomeController.cs` file, add a new controller action, `TestException`,
    which we will use for testing the snapshot debugging. It should just throw an
    unhandled exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our Voting application is fully configured to use Azure Application
    Insights. We can now upgrade the Helm release using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a new Docker image with a `1.5.0` tag, just like we did in the previous
    chapters, and push it to the Docker Hub. In our case, it will be called `packtpubkubernetesonwindows/voting-application:1.5.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory with the Helm chart for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chart.yaml` file, use `1.5.0` (the same as the Docker image tag) as
    the `appVersion`. As suggested by our best practices, change the version of the
    chart—for example, use `0.2.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `values.yaml` file, add your instrumentation key and increase `replicaCount`
    to `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to inject the instrumentation key to the pod template into `Deployment`
    for our Voting application. Modify `templates\deployment.yaml` so that `azureApplicationInsightsKey`
    is injected into the `APPINSIGHTS_INSTRUMENTATIONKEY` environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a `dry run` for the upgrade of the Helm release using the new version
    of our chart. You should see the instrumentation key being properly resolved in
    the output manifests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `upgrade`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Wait for all replicas to be upgraded to the new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, your application should be running and sending all of the telemetry to
    Azure Application Insights. You can navigate to Application Insights from Azure
    Portal ([https://portal.azure.com/](https://portal.azure.com/)) or open it directly
    from Visual Studio by right-clicking `Application Insights` under Connected Services
    and selecting Open Application Insights Portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65469ece-eb53-4068-9744-6e3c85d08d35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can explore multiple features that are available out of the box with the
    current configuration—for example, visualizing the telemetry data as an application
    map that shows the dependencies between the different components in your application
    and what their current status is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/33d80fe8-3a56-446b-9125-dfe93e71be40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are interested in the overall performance of end-user requests, you
    can check out the dedicated dashboard based on the ASP.NET MVC telemetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be8d2e57-0963-4d58-bd84-9408a76d409b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And, of course, you can inspect application **logs**, which are delivered by
    the Serilog sink. The most important feature in this view is the possibility of
    running complex queries using the Kusto language ([https://docs.microsoft.com/en-us/azure/kusto/query/](https://docs.microsoft.com/en-us/azure/kusto/query/)),
    which is designed for analyzing log data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e74cf28b-f712-4327-8309-a3eecd6e91db.png)'
  prefs: []
  type: TYPE_IMG
- en: You can learn more about the Azure Application Insights features in the official
    documentation at [https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how you can use the snapshot debugger in order to debug your
    containerized application, even when you do not have access to a remote debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure Application Insights service offers the snapshot debugger, which is
    a feature for monitoring exception telemetry from your application, including
    production scenarios. Whenever there is an unhandled exception (top-throwing),
    the snapshot debugger collects managed memory dumps that can be analyzed directly
    in Azure Portal or, for more advanced scenarios, Visual Studio 2019 Enterprise
    edition. Visual Studio will have this feature installed by default if you selected
    the ASP.NET workload in the installer.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot debugging can be configured for regular .NET applications that are
    not using ASP.NET MVC. You can find out more in the documentation at [https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm#configure-snapshot-collection-for-other-net-applications](https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm#configure-snapshot-collection-for-other-net-applications).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous paragraphs, we already enabled snapshot debugging in our application
    by installing the `Microsoft.ApplicationInsights.SnapshotCollector` NuGet package
    and providing additional configurations. Now, we can test this feature in our
    Voting application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your web browser, navigate to the test endpoint that always throws an exception:
    `http://<serviceExternalIp>/Home/TestException`. Trigger this endpoint twice; by
    default, we have to hit the same exception more than once to trigger snapshot
    collection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see the default error page for our Voting application. At the same
    time, the snapshot has already been collected, without any noticeable performance
    impact for the end user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Application Insights for our Voting application in Azure Portal
    ([https://portal.azure.com/](https://portal.azure.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Failures pane and select the Operations button when viewing the Operations
    tab or select the Exceptions button when viewing the Exceptions tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f00421e9-9bb6-4d2b-aa14-0d431bea4df8.png)'
  prefs: []
  type: TYPE_IMG
- en: From the right, select a Sample operation pane and open one of the exception
    occurrences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the beginning, you will not see any snapshots on the timeline; you have
    to first add the Application Insights Snapshot Debugger Role. To do that, click
    (Don''t see snapshot? Troubleshoot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2beb9c1c-48b1-493a-ad2e-b73b14f082aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Add Application Insights Snapshot Debugger Role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/47b1975f-5151-46d7-be97-cec1263a1e2e.png)'
  prefs: []
  type: TYPE_IMG
- en: After that, a basic health check will be executed. Please bear in mind that
    it takes a few minutes until the snapshots are uploaded, so, if you experience
    any health check failures, retry in a few minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, back in the End-to-end transaction details view, you will see small icons
    representing the debug snapshots. Click one of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fa796b3d-87c8-4e5c-8b67-afa9124ecc56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Debug Snapshot view offers you lightweight debugger capabilities, including
    code decompilation. To analyze the snapshot in Visual Studio 2019 Enterprise,
    click the Download Snapshot button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6fc7d714-5866-483e-8907-6faf0d492e8a.png)'
  prefs: []
  type: TYPE_IMG
- en: When the file downloads, open it in Visual Studio by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, click Debug with Managed Only or Debug Managed Memory, depending
    on your needs. The second option is really useful when you are analyzing memory
    leaks and other memory-related issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may need to select your source code location in order to see the source
    code view ([https://docs.microsoft.com/en-us/visualstudio/debugger/specify-symbol-dot-pdb-and-source-files-in-the-visual-studio-debugger?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/specify-symbol-dot-pdb-and-source-files-in-the-visual-studio-debugger?view=vs-2019)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can use all of the debugging tools that you have always used—for example,
    you can analyze the Parallel Stacks view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c5ef3a45-6b7a-4bcd-b478-1198d6e22864.png)'
  prefs: []
  type: TYPE_IMG
- en: If you run into any other problems while using the snapshot debugger, check
    the official troubleshooting guide at [https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-troubleshoot](https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-troubleshoot).
  prefs: []
  type: TYPE_NORMAL
- en: The snapshot debugger has even more features, which make it possible to set
    live snap points so that you can create snapshots without waiting for an exception.
    Unfortunately, right now, this feature is only available for Azure App Service
    workloads or managed AKS clusters running applications in Linux containers. You
    can find more in the documentation at [https://docs.microsoft.com/en-us/visualstudio/debugger/debug-live-azure-applications?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/debug-live-azure-applications?view=vs-2019).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at Kubernetes Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Dashboard ([https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard))
    is the default, web-based user interface for deploying, managing, and troubleshooting
    applications running on Kubernetes. Generally, it is recommended that you use
    declarative kubectl management of the cluster instead of using Dashboard, but
    it is still a useful tool for having cluster overview, analyzing logs, and quickly
    executing into pod containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Dashboard, you have to first install it. You have the following options
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy using the official manifest by running `kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta6/aio/deploy/recommended.yaml`.
    You can double-check the latest version in the documentation at [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Helm chart using the `helm install kubernetes-dashboard stable/kubernetes-dashboard` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In AKS Engine, use the `kubernetes-dashboard` add-on, which is enabled by default
    in the cluster ApiModel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to know that there are strict compatibility rules for the Kubernetes
    API and Kubernetes Dashboard. You can check the matrix in the official releases
    page at [https://github.com/kubernetes/dashboard/releases](https://github.com/kubernetes/dashboard/releases).
    Currently, AKS Engine is deployed with version `1.10.1` of Dashboard, which is
    notcompatible with the latest versions of the Kubernetes API. This means that
    we will deploy Dashboard using the official manifest. The AKS Engine cluster is
    by default an RBAC-enabled cluster, so we need to configure RBAC in order to use
    Dashboard as a cluster administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy and configure RBAC, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy Kubernetes Dashboard using the official manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `serviceaccount.yaml` manifest file for `admin-user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f serviceaccount.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `clusterrolebinding.yaml` manifest file to give this user a `cluster-admin`
    role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f clusterrolebinding.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get the bearer token for this user, use the following snippet in PowerShell
    and copy the value after `token:`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When granting the `cluster-admin` role to the ServiceAccount that will be used
    to access the dashboard, you need to understand any security implications. Anyone
    who has the token for the `admin-user` ServiceAccount will be able to perform
    any actions in your cluster. In production scenarios, consider creating roles
    that expose only the necessary functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to access Dashboard. To do this, please go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the PowerShell window, start a proxy for connecting to the API using the `kubectl
    proxy` command. The dashboard is not exposed as an external service, which means
    we have to use the proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the web browser and navigate to `http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticate using the token option and provide the bearer token that we have
    retrieved in the previous steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be redirected to the overview of your cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b3b0106c-e10f-4eb6-8a4f-c1d177661e02.png)'
  prefs: []
  type: TYPE_IMG
- en: The Kubernetes Dashboard has multiple features that cover many functionalities
    provided by `kubectl`. In the next sections, we will explore how to access the
    container logs and execute into pod containers, as they are useful in debugging
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing pod container logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes Dashboard gives you an easy interface for accessing pod container
    logs quickly. To access logs for one of the pods for our Voting application, go
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the menu, navigate to Workloads | Pods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find one of the pods for our Voting application. On the right side, click the
    three-dot button and select Logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be redirected to the logs view where you can inspect the logs in real
    time, just as if you used the `kubectl logs` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f1bdcda2-64d6-401e-9035-804a7701cd73.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's see how to `exec` into a pod container.
  prefs: []
  type: TYPE_NORMAL
- en: Executing commands in a pod container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a similar fashion as for accessing logs, you can exec into a Pod container
    in order to run ad-hoc commands. This approach can be useful when debugging issues
    or quickly introducing configuration changes in development clusters. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the menu, navigate to Workloads | Pods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find one of the pods for our Voting application. On the right side, click the
    three-dot button and select `e``xec`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The PowerShell terminal will open after a few seconds. You can run any arbitrary
    PowerShell commands and modify the container state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9bcc0f38-0253-4aad-9c48-fc299a9b338d.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully deployed Kubernetes Dashboard and you
    are now equipped with yet another useful debugging tool. In the next section,
    you will learn how you can improve your development environment for Kubernetes
    using Azure Dev Spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Working on microservices in a team using Azure Dev Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Dev Spaces ([https://docs.microsoft.com/en-us/azure/dev-spaces/](https://docs.microsoft.com/en-us/azure/dev-spaces/)),
    also known as **AZDS** (short for** Azure Dev Spaces**), is one of the latest
    offerings from Microsoft for an enhanced Kubernetes development experience. This
    service provides a rapid and iterative development experience for teams using
    AKS clusters. Please note that currently, only managed AKS clusters are supported,
    which means that you cannot use AKS Enginefor this service. What is more, the
    current version does not support the development of Windows container applications;
    it is possible to interact with existing Windows pods, but they will not be managed
    by AZDS ([https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers](https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers)).
    From this point of view, AZDS is not useful for Windows container application
    development, but, as it is likely to receive this support soon, we are going to
    give you an overview of this offering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of AZDS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can minimize the local development environment setup. You can debug and
    test all components of your distributed application directly in AKS, without replacing
    or mocking up dependencies (dev/prod parity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can organize the Kubernetes cluster into shared and private Dev Spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run independent updates of microservices without affecting the rest of
    the AKS cluster and other developers. You can develop your own version of a service,
    test it in isolation, and, when you are ready to share it with other team members,
    update the instance so that it is visible to everyone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It fully integrates with Visual Studio Code and Visual Studio 2019, including
    their remote debugging features. It can also be managed from the Azure CLI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can connect your local machine to a Kubernetes cluster and test or debug
    local applications (with or without containers) with all the dependencies ([https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/connect](https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/connect)).
    This feature is similar to telepresence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a faster development loop using incremental code compilation directly
    in the container whenever code changes are detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create an AKS cluster, you can use the Powershell script that we provided
    in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes Concepts
    and Windows Support* ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script can also create a cluster with a two-node Linux pool only. Go through
    the following steps to create an AKS cluster with AZDS enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the script and execute it with the appropriate parameters. You need
    to select an Azure location that supports AZDS ([https://docs.microsoft.com/en-us/azure/dev-spaces/about#supported-regions-and-configurations](https://docs.microsoft.com/en-us/azure/dev-spaces/about#supported-regions-and-configurations))
    and select the Kubernetes version that is available in the location (use the `az
    aks get-versions --location <azureLocation>` command). In this example, we will
    create an AKS cluster instance named `devspaces-demo` in the `westeurope` location
    and Kubernetes version `1.15.4`. Be sure to select a cluster name that does not
    contain reserved words or trademarks, or later you will not be able to enable
    AZDS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The cluster Deployment can take about 15 minutes. When it is completed, a new
    context for `kubectl` named `aks-windows-cluster` will be added and set as the
    default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable AZDS for the cluster using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The AZDS CLI will be installed. Use the `default` namespace as the Dev Space
    when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the AKS cluster has AZDS enabled, we can demonstrate how easy it is
    to create a new ASP.NET Core 3.0 Kubernetes application in Visual Studio 2019
    and debug it directly in the cluster. Go through the following steps to create
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio 2019 and select Create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Container Application for Kubernetes template and click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the project name and location and click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Web Application (Model–View–Controller) type and click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to introduce small changes to the default configuration. In the `charts\azds-demo\values.yaml`
    file, ensure that `ingress` is enabled using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Kestrel listens on port `5000`. We need to change the port to `80`
    in order to be compatible with Dockerfile and Kubernetes Service. In the `Program.cs`
    file, ensure that the application startup looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Projects that have AZDS support enabled have the `azds.yaml` file, which defines
    the Dev Spaces configuration, Dockerfile, and `charts` directory with the Helm
    chart, ready to be deployed to the cluster by AZDS. Now, let''s deploy the application
    to the `default` Dev Space in our AKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the launch settings for your project, select Azure Dev Spaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c2194bff-518a-4187-8584-4d5809bdd7c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Select devspaces demo AKS cluster and default space, and mark it as Publicly
    accessible, and continue by clicking OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AZDS will build the Dockerfile, install the Helm chart, and attach the debugger.
    In the web browser, the Ingress public endpoint will be automatically opened—for
    example, [h](http://default.azds-demo.2dpkt6cj7f.weu.azds.io/)[t](http://default.azds-demo.2dpkt6cj7f.weu.azds.io/)[tp:/](http://default.azds-demo.2dpkt6cj7f.weu.azds.io/)[/default.azds-demo.2dpkt6cj7f.weu.azds.io/](http://default.azds-demo.2dpkt6cj7f.weu.azds.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `HomeController.cs` file, add the breakpoint in the index controller
    action. Refresh the web page in the browser. You will see that the breakpoint
    is caught exactly as if the application was debugged in a local environment!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stop debugging and introduce a change in the `Index.cshtml` file. For example,
    change the main header to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the application again, using the Azure Dev Spaces configuration. In
    the Output window, you will see that the application is quickly rebuilt, and, after
    a while, the web browser with the modified main page opens again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/80e79be7-9d30-4521-8e2b-44251f7bbf39.png)'
  prefs: []
  type: TYPE_IMG
- en: For more AZDS scenarios in team development, please check the official documentation
    at [https://docs.microsoft.com/en-us/azure/dev-spaces/team-development-netcore-visualstudio](https://docs.microsoft.com/en-us/azure/dev-spaces/team-development-netcore-visualstudio).
  prefs: []
  type: TYPE_NORMAL
- en: And all of this has happened directly on the AKS cluster. As you can see, development
    iterations are much faster than they are in a normal dev-loop when building a
    Docker image, pushing it, and rolling out a new Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: To delete the AKS cluster, use the `az group delete --name aks-windows-resource-group
    --yes` command.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully set up Azure Dev Spaces for your AKS
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has focused on how you, as a developer, can improve your development
    experience with Kubernetes clusters. First, we learned how to configure essential
    development extensions for Visual Studio Code and Visual Studio 2019\. Next, you
    learned how to use Helm for packaging Kubernetes applications, first by using
    an official Helm chart for Microsoft SQL Server and later by creating a dedicated
    chart for our Voting application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to integrate Azure Application Insights into your application
    and how you can leverage advanced features such as the snapshot debugger in order
    to debug problems in production scenarios for Windows pods. Using our new Docker
    image with Application Insights instrumentation, we learned how to perform a Helm
    release upgrade. We introduced Kubernetes Dashboard, which is the most commonly
    used web UI for Kubernetes. Lastly, you learned what the Azure Dev Spaces service
    is and how you can use it to increase the development iteration speed when working
    with AKS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the important topic of security, especially
    in the context of Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Helm and why should you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the biggest difference between Helm versions two and three?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement automatic Entity Framework database migrations in a Helm
    chart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you perform a rollout of a new version of your application that is installed
    as a Helm chart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the snapshot debugger and how can you use it in production scenarios?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it not recommended that you use Kubernetes Dashboard to modify resources
    in the cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using Azure Dev Spaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find answers to these questions in the *Assessments* section of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about Kubernetes features and how to manage applications,
    please refer to the following PacktPub books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are interested in learning more about Azure Application Insights, please
    refer to the following PacktPub books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Azure for Developers* ([https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure for Architects - Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/azure-architects-second-edition](https://www.packtpub.com/virtualization-and-cloud/azure-architects-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information regarding Helm, you can check out the following PacktPub
    book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes - Second Edition* ([https://www.packtpub.com/application-development/mastering-kubernetes-second-edition](https://www.packtpub.com/application-development/mastering-kubernetes-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
