- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are some of the reasons running a virtual machine would be preferable
    to a bare-metal installation?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual machine can run inside the current preferred operating system, instead
    of replacing it or setting up a complicated dual-boot solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine can be snapshotted, which means the entire state of the machine
    is preserved and can be restored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many different operation systems can run on a single machine, concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are some of the downsides of running a virtual machine as opposed to
    a bare-metal installation?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a little overhead from the virtualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More resources (CPU/RAM/disk) will always be used compared to running a bare-metal
    installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the difference between a type-1 and type-2 hypervisor?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type-1 hypervisors are installed directly on the physical machine (e.g. VMWare
    vSphere, KVM, Xen), while type-2 hypervisors are installed in an already running
    operating system (for example, VirtualBox, VMWare Workstation Player).
  prefs: []
  type: TYPE_NORMAL
- en: '**In which two ways can we start a virtual machine on VirtualBox?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally, which opens a new window with the terminal console (or GUI, if a desktop
    environment is installed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headless, which runs the virtual machine as a server, without a GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What makes an Ubuntu LTS version special?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LTS stands for Long Term Support. Ubuntu LTS versions are guaranteed updates
    for five years, instead of the nine months for regular Ubuntu releases.
  prefs: []
  type: TYPE_NORMAL
- en: '**What should we do if, after the Ubuntu installation, the virtual machine
    boots to the Ubuntu installation screens again?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should check if either the virtual hard disk in higher in the boot order
    than the optical drive, or we unmount the ISO from the optical drive so only the
    virtual hard disk is a valid boot target.
  prefs: []
  type: TYPE_NORMAL
- en: '**What should we do if we accidentally reboot during installation, and we never
    end up at the Ubuntu installation (but instead see an error)?** We should ensure
    the optical disk is higher in the boot order than the virtual hard disk AND we
    need to make sure the ISO is mounted on the optical disk.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Why did we setup NAT forwarding for the virtual machine?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So we're not limited to using the terminal console, but instead we can use richer
    SSH tooling such as PuTTY or MobaXterm.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why is syntax highlighting an important feature for text editors?** It makes
    it easy to spot syntax error, by using colors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How can we extend the functionality already provided by Atom?** We can install
    extra Packages, or even write our own.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What are the benefits of autocomplete when writing shell scripts?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reduces typing, especially for multi-line constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it easier to find commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How could we describe the difference between Vim and GNU nano?** Nano is
    simple, Vim is powerful.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which are the two most interesting modes in Vim?** Normal mode and Insert
    mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the .vimrc file?** It is used to configure persistent options for
    Vim, such as the color scheme and how to handle tabs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What do we mean when we call nano a WYSIWYG editor?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WYSIWYG stands for What You See Is What You Get, which means you can start typing
    at your cursor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why would we want to combine GUI editors with command-line editors?** Because
    it''s easier to write in GUI editors, but easier to troubleshoot with command-line
    editors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a file system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A software implementation of the way data is stored on and retrieved from a
    physical medium.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which Linux specific file systems are most common?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ext4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Btrfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**True of false: multiple file system implementations can be used concurrently
    on Linux?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True; the root file system is always a single type, but different parts of the
    file system tree can be used to mount other file system types on.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the journaling feature present on most Linux file system implementations?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Journaling is the mechanism which ensures writes to disks cannot fail halfway.
    It greatly improves reliability of the file system.
  prefs: []
  type: TYPE_NORMAL
- en: '**On which point in the tree is the root file system mounted?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the highest point, on `/.`
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the PATH variable used for?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is used to determine from which directory binaries can be used. You can check
    the contents of the PATH variable with the command 'echo $PATH'.
  prefs: []
  type: TYPE_NORMAL
- en: '**In which top-level directory are configuration files stored according to
    the Filesystem Hierarchy Standard?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `/etc/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where are process logs commonly saved?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `/var/log/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many file types does Linux have?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '**How does the Bash autocomplete function work?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For commands that support the autocomplete function, you can use TAB once to
    get the correct argument (if there is a single possibility), or TAB twice for
    a list of possible arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which three permissions are used for Linux files?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which three types of ownership are defined for Linux files?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which command is used to change the permissions on a file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`chmod`'
  prefs: []
  type: TYPE_NORMAL
- en: '**What mechanism controls the default permissions for newly created files?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`umask`'
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the following symbolic permission described in octal:** rwxrw-r--'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0764\. 7 from rwx on the first three places (user), 6 from `rw-` on the second
    three places (group), and 4 from `r--` on the last three places (others).
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the following octal permission described symbolically:** 0644'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rw-r--r--. First 6 is ReadWrite, then two 4s which are just Reads.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which command allows us to gain superuser privileges?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Which commands can we use to change ownerships for a file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`chown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chgrp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How can we arrange for multiple users to share access to files?** We make
    sure they share group membership, and create a directory in which only members
    of those groups are allowed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which types of Advanced Permissions does Linux have?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special File Permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access Control Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which command do we use to copy files in Linux?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cp`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between moving and renaming files?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technically, there is no difference. Functionally, moving changes the directory
    a file is in, while renaming keeps the file in the same directory. Both are handled
    in Linux by the `mv` command.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is the** `rm` **command, used to remove files under Linux, potentially
    dangerous?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can be used to recursively delete directories and anything in them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not (by default) present an 'Are you sure?' prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to delete files using wildcards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the difference between a hard link and a symbolic (soft) link?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hard links refer to the data on the filesystem, while symbolic links refer to
    the file (which, in turn, refers to the data on the filesystem).
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the three most important operating modes of `tar`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Archiving mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which option is used by `tar` to select the output directory?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-C`'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the biggest difference between `locate` and `find` when searching
    on filename?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate allows partly named matches by default, while find requires specifying
    wildcards if that partial matches are desired.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many options of `find` can be combined?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As many as the search requires! This is exactly what makes `find` so incredibly
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What do we, by convention, do as the first thing when we learn a new programming
    or scriping language?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We print the string "Hello World".
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the shebang for Bash?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#!/bin/bash'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is the shebang needed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we're running the script without specifying which program we should use,
    the shebang will allow Linux to use the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: '**In what three ways can we run a script?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using the program which we want to run it with: `bash script.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By setting the executable permission and prefixing the scriptname with ./:
    ``./script.sh``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By setting the executable permission and using the fully qualified path to
    the file: `/tmp/script.sh`'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Why do we place such emphasis on readability when creating shell scripts?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scripts are much easier to use if the person using them can easily understand
    what the script does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If anyone other than yourself needs to edit the script (and you can consider
    yourself 'someone else' too after a few months!) it helps tremendously if it's
    simple to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Why do we use comments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So we can explain things in the script which might not be obvious by just looking
    at the commands. Furthermore, it also allows us to give some design rationale
    if that helps clarify the script.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we recommend including a script header for all shell scripts you write?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If gives a bit of information on the author, age and description to the script.
    It helps give context to the script, which can be very helpful when the script
    is not working as expected, or needs to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which three types of verbosity have we discussed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verbosity in comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbosity in commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbosity in command output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the KISS principle?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: KISS, which stands for *Keep It Simple, Stupid*, is a design recommendation
    which helps us to remember that we should keep things simple, as that often increases
    usability and readability, while even being the best solution most of the times
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a variable?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable is a basic building block for programming languages, which is used
    to store run-time values that can be referenced multiple times in the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need variables?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables are great for storing information you need multiple times. In this
    case, if you need to change the information, it's a single operation (in the case
    of a constant). In the case of a real variable, it allows us to reference run-time
    information in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, proper variable naming allow us to grant extra context to our script,
    increasing readability.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a constant?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A constant is a special type of variable, since its value is determined is fixed
    and used throughout the script. Normal variables are often mutated multiple times
    during execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are naming conventions especially important for variables?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bash allows us to name our variables almost anything. Because this can become
    confusing (which is never a good thing!) it is important to pick one naming convention
    and stick to it: this increases consistency and coherence for our scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are positional arguments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you call a Bash script, any other text passed after the `bash scriptname.sh`
    command can be accessed in the script, as this text is considered the *arguments*
    to the script. Each word not enclosed in quotes is handled as a single argument:
    a multi-word argument should be enclosed in quotes!'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a parameter and an argument?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arguments are used to fill the parameters of a script. Parameters are the *static
    variable names* which are used in the script logic, whereas the arguments are
    the *run-time values* used as the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we make a script interactive?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `read` command. We can store the values that the users gives in
    a variable of our choice, otherwise we can use the default $REPLY variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we create a script that we can use both non-interactive and interactively?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By combining (optional) positional arguments with the `read` command. To verify
    that we have all the information we need before starting the logic of the script,
    we use the `if-then` construct coupled with the `test` command to see if all our
    variables are populated.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why do we need an exit status?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So commands can signal to their callers if they succeeded or failed in a simple
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between exit status, exit code and return code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An exit code and return code refer to the same thing. An exit status is a *concept*,
    which is brought to life by the exit/return code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which flag do we use with test to test for:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*An existing directory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -d
  prefs: []
  type: TYPE_NORMAL
- en: '*A writable file*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -w
  prefs: []
  type: TYPE_NORMAL
- en: '*An existing symbolic link*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -h (or -L)
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the preferred shorthand syntax for `test -d /tmp/`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[[ -d /tmp/ ]]. Note that a space after [[ and before ]] is mandatory, or the
    command will fail!'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we print debug information in a Bash session?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the -x flag, either in the shell with `set -x` or when calling a script
    with `bash -x`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we check if a variable has content?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if [[ -n ${variable} ]] to check if the variable is non-zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [[ ! -z ${variable} ]] to check if the variable is not zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the Bash format for grabbing a return code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $?.
  prefs: []
  type: TYPE_NORMAL
- en: '**Of || and &&, which is the logical AND and which the OR?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|| is OR, && is AND.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the Bash format for grabbing the number of arguments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $#.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we make sure it does not matter from which working directory the
    user calls the script?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By providing a `cd $(dirname $0)` at the beginning of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do Bash parameter expansions help us when dealing with user input?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows us to remove capital letters so we can more easily compare to expected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a search pattern?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular expression syntax which allows us to find pieces of text with specified
    characteristics, such as length, content and location on a line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are regular expressions considered greedy?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most regular expression try to find as much data as they can that match the
    search pattern. This includes whitespace and other punctuation, which is a logical
    separation for humans but not necessarily for a machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which character in search patterns is considered a wildcard for any one character,
    except newlines?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dot (.).
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the asterisk used in Linux regular expression search patterns?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The * is used in combination with another character to allow it to form a repeating
    character. Example search pattern: spe*d will match spd, sped, speed, speeeeeeeeed,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are line anchors?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The special characters used to denote line beginnings and endings. ^ for the
    beginning of the line, $ for the line end.
  prefs: []
  type: TYPE_NORMAL
- en: '**Name three character types.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any of these are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: alphanumeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: alphabet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: blanks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is globbing?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Globbing is accomplished when you use a * or ? on the command-line when interacting
    with files or file paths. Globbing allows us to easily manipulate (move, copy,
    delete, and so on) files that are matched on the globbing pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is possible in the extended regular expression syntax, that is not possible
    with normal regular expressions under Bash?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more repeating characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exact number of repeating characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range of repeating characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternation with more than a single character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What would be a good rule of thumb between deciding to use `grep` or `sed`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your goal can be achieved with a single `grep` statement, choose simplicity.
    If it cannot be achieved in that manner, choose `sed` for more powerful syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are regular expressions on Linux/Bash so hard?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many different implementations that are similar. With regular expressions
    and their difficulty as-is, this confusion does not help. Only practice and experience
    will remedy this!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does an if-then(-else) statement end?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the reverse of the word if: `fi`'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we use regular expression search patterns in a conditional evaluation?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By employing the =~ comparison symbol. For example: `[[ ${var} =~ [[:digit:]]
    ]]`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need the `elif` keyword?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to sequentially test for more than one condition, we can use else
    if (`elif`).
  prefs: []
  type: TYPE_NORMAL
- en: '**What is *nesting*?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an `if-then-else` statement or loop within another if-then-else statement
    or loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we get information about how to use shell builtins and keywords?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using the command `help`, followed by the builtin or keyword we want information
    about. For example: `help [[`'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the opposite keyword of `while`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`until`. A while loop runs until the condition is no longer *true,* an until
    loop runs until the condition is no longer *false*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why would we choose the for loop over the while loop?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for` is more powerful and has many convenient shorthand syntaxes which would
    be hard or unreadable with `while`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is brace expansion and on which characters can we use it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Brace expansion allows us to write very short code, which generates a whitespace
    delimited list based on ASCII characters. For example: `{1..10}` prints the numbers
    1 through 10, with spaces in between. We can also use this for uppercase or lowercase
    letters, or any range in the ASCII character set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Which two keywords allows us to have more granular control over loops?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`break` and `continue`. `break` stops the current loop, while `continue` jumps
    to the next iteration in the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**If we are nesting loops, how can we employ loop control to influence outer
    loops from an inner loop?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By adding a number higher than 1 to the `break` or `continue` keyword. Example:
    `break 2` exits from both the inner and one outer loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are file descriptors?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A handle to files or devices used by Linux as an interface for input/output.
  prefs: []
  type: TYPE_NORMAL
- en: '**What do the terms stdin, stdout and stderr mean?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stdin, standard input. Used for input to commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stdout, standard output. Used for normal output of commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stderr, standard error. Used for error output of commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to stdin, stdout and stderr map to the default file descriptors?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stdin is bound to fd0, stdout to fd1, and stderr to fd2.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between the output redirections `>`, `1>` and `2>`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`>` and `1>` are equal, and refer to redirecting stdout. `2>` is used to redirect
    stderr.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between `>` and `>>`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`>` will overwrite the file if it already has content, while `>>` will append
    to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can both stdout and stderr be redirected at the same time?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using `&>` (and `&>>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By binding stderr to stdout, using `2>&1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By piping with `|&`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which special devices can be used to act as a black hole for output?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: /dev/null and /dev/zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does a pipe do, with regards to redirections?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It binds the stdout/stderr of a command to the stdin of another command.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we send output to both the terminal and a log file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By piping through the `tee` command, preferably with `|&` so both stdout and
    stderr is forwarded.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a typical use-case for a *here string*?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use a here string if we want to supply input directly to stdin of a command.
    `bc` is a good example of this.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**In which two ways can we define a function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: name() {
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function name {
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some advantages of functions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Easy to reuse code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitates code sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracting complex code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is the difference between a globally scoped variable and a locally scoped
    one?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locally scoped variables are only valid within a function, globally scoped variables
    can be used throughout the entire script (even in functions).
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we set values and attributes on variables?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `declare` command.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can a function use arguments passed to it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same way as a script can: by using $1, $#, $@, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we return a value from a function?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By outputting it to stdout. The command that calls the function should know
    to capture the output, using command substitution.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does the `source` command do?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes commands from a file in the current shell. If the sourced file contains
    only function definitions, these are loaded to be used later (but still only in
    the current shell).
  prefs: []
  type: TYPE_NORMAL
- en: '**Why would we want to create a function library?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lot of utility functions, such as argument checking, error handling and color
    setting, never change and can sometimes be complex to figure out. If we do this
    once properly, we can then use the predefined functions from our library without
    needing to duplicate code from older scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is scheduling?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scheduling allows us to define when and how a script should run, without the
    need for the user to be interactive at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '**What do we mean with ad-hoc scheduling?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ad-hoc scheduling, which we normally do with `at` on Linux, is scheduling that
    is not periodically repeated, but often a one-time job at a fixed time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where does the output of commands run with `at` normally go?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, `at` tries to use `sendmail` to send a local mail to the user who
    owns the queue/job. If sendmail is not installed, the output is gone.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is scheduling for the `cron` daemon most often implemented?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a user-bound crontab.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which commands allows you to edit your personal crontab?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command `crontab -e`. Furthermore, you can list the current crontab with
    `crontab -l` and remove the current crontab with `crontab -r`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which five fields are present in the crontab timestamp syntax?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: minute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: hour
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: day-of-month
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: month-of-year
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: day-of-week
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which are the three most important environment variables for the crontab?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PATH
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SHELL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MAILTO
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How can we inspect the output for scripts or commands we have scheduled with
    `cron`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can either use redirection in the crontab to write the output to a file,
    or we can use the Linux local mail functionality to send us the output. Most of
    the times, redirecting output to a log file is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: '**If our scheduled scripts do not have enough output for us to effectively
    work with log files, how should we remedy this?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the echo command in multiple places in your script, to signal a message
    to the reader that execution is doing what is expected. Example of this are: ''Step
    1 completed successfully, continuing.'' and ''Script execution was a success,
    exiting.''.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why are flags often used as *modifiers* whereas positional parameters are
    used as *targets*?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flags often modify the behavior: it can make a script more or less verbose,
    or perhaps write the output somewhere. Often, a command manipulates a file, which
    is then considered the primary *target* for what the command actually tries to
    achieve.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we run `getopts` in a `while` loop?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All flags are parsed sequentially, and when `getopts` can no longer find new
    flags it will return an exit code different from 0, which will exit the `while`
    loop at exactly the right moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need a ?) in the case statement?** We cannot trust the user to
    correctly use all flags all the time. ?) matches any flag we have not specified,
    which we can then use to inform the user of incorrect usage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Why do we (sometimes) need a :) in the case statement?** The :) is used when
    the optstring specifies an argument for an option, but the user has not given
    it. It allows you to inform the user of the missing information (and you will
    most probably abort the script at this point).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Why do we need a separate optstring is we''re resolving all options anyway?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the optstring will tell `getopts` which options have arguments and which
    do not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we need to substract 1 from the OPTIND variable when we use it in
    `shift`?** The OPTIND variable always refers to the *next possible index*, which
    means it is always 1 ahead of the final flag that was found. Because we only need
    to shift away the flags (which are seen as positional arguments!), we need to
    make sure we reduce the OPTIND by 1 before we shift.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is it a good idea to mix options with positional arguments?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the added complexity of dealing with both options and positional
    arguments, it is often better to specify the *target* of your operation as a flag
    argument for the `-f` flag; -f is almost universally excepted as a file reference,
    which will always be considered as a logical target for most operations.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is *parameter substitution*?** Nothing more than the run-time substitution
    of the variable name with its value at that moment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How can we include default values for our defined variables?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the ${variable:-value} syntax, where *variable* is the name and *value*
    the default value. This will only be used if the value is null or empty ('').
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we use parameter expansion to handle missing parameter values?**
    While you would normally use an `if [[ -z ${variable} ]]; then`, parameter expansion
    allows you to use the following syntax to generate an error message and `exit
    1`: ${1:?Name not supplied!}'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What does ${#*} do?** It is the same as $#, which we use to determine the
    number of arguments passed to our shell script. The general ${#name} syntax allows
    us to get the length of the value of the *name* variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How does *pattern substitution* work when talking about parameter expansions?**
    *Pattern substitution* allows us to take the value of a variable and modify it
    slightly, by doing a search/replace for a *pattern*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How is *pattern removal* related to *pattern substitution*****?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing a pattern is the same as replacing a pattern with nothing. With pattern
    removal, we get the added flexibility of search both from the beginning of the
    text (prefix) and from the end (suffix). Pattern removal is great when working
    with file paths.
  prefs: []
  type: TYPE_NORMAL
- en: '**What types of case modifications can we perform?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lowercasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upercasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing the casing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Which two things can we use to get a substring from a variables'' value?**
    We need an *offset*, or a *lenght*, or  the combination of both (most common).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
