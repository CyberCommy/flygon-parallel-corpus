- en: Chapter 11. Database Connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is a database-agnostic framework, which means that the database fields
    provided by Django are designed to work across different databases, such as **SQLite**,
    **Oracle**, **MySQL**, and **PostgreSQL**. In fact, they also work on several
    third-party database backends. PostgreSQL is a great database for Django in production,
    whereas SQLite is used for a development environment, and you will end up doing
    a lot of work if you don't want to use RDBMS for your project. This chapter will
    give you the detailed difference between the two types and will show you which
    is a better fit for Django, and, also, how we can actually implement them in our
    Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will deal with in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL versus NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django with relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django with NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a database system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-page application project—URL shortener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First of all, let's see the difference between SQL and NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: SQL versus NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL databases, or relational databases, have been around for a very long time;
    in fact, the databases were roughly assumed as SQL databases until the new term
    was coined—which is NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we are talking about the high-level differences between SQL and NoSQL.
    The following are the differences between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SQL database (RDBMS) | NoSQL database |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SQL databases are relational databases (RDBMS) | NoSQL databases are nonrelational
    or distributed databases |'
  prefs: []
  type: TYPE_TB
- en: '| SQL databases are based on tables and its relationship with other tables
    | NoSQL are document based, key-value pairs, graph database, or wide column stores
    |'
  prefs: []
  type: TYPE_TB
- en: '| A SQL database stores its data in rows of a table | NoSQL is a collection
    of key-value pairs, documents, graph database, or wide column stores |'
  prefs: []
  type: TYPE_TB
- en: '| SQL databases have a predefined schema | NoSQL has a dynamic schema |'
  prefs: []
  type: TYPE_TB
- en: '| SQL databases are vertically scalable | NoSQL databases are horizontally
    scalable |'
  prefs: []
  type: TYPE_TB
- en: '| SQL database examples are MySQL, Oracle, SQLite, PostgreSQL, and MS SQL |
    NoSQL database examples are MongoDB, BigTable, Redis, RavenDB, Cassandra, HBase,
    Neo4j, and CouchDB |'
  prefs: []
  type: TYPE_TB
- en: Let's try to understand the basic features of some of the famous SQL and NoSQL
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following sections deal with different SQL databases and their usage.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL – open source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Being one of the most popular databases in the world, MySQL has some benefits
    that make it suitable for all kinds of business problems. The following are a
    few important benefits of MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replication**: MySQL supports replication, that is, by replicating a MySQL
    database, the work load can be significantly reduced from one machine, and an
    application can be easily scaled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sharding**: When the number of write operations are very high, sharding helps
    by partitioning the application server that divides the database into small chunks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, PostgreSQL is the most popular database within the Django
    community. It also has the widest feature set of the core-supported databases.
  prefs: []
  type: TYPE_NORMAL
- en: Evolved PostgresSQL's advanced queries and features have made it possible to
    achieve the complex line of conventional SQL query into much simpler lines to
    write query. However, the implementation of arrays, hstore, JSON, and so on is
    kind of tricky with the conventional SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This concept was introduced when horizontal scaling was tough and RDBMS-based
    databases were not able to scale as much as they were expected to. It is often
    termed as Not only SQL. It provides a mechanism to store and retrieve data other
    than the traditional SQL methods.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoDB is one of the most popular document-based NoSQL databases, as it stores
    data in JSON-like documents. It is a nonrelational database with a dynamic schema.
    It was developed by the founders of **DoubleClick**. It is written in **C++**
    and is currently used by some big companies, such as The New York Times, Craigslist,
    and MTV Networks. The following are some of the benefits and strengths of MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: For simple queries, it gives good performance, as all the related
    data is in a single document that eliminates join operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: It is horizontally scalable, that is, you can reduce the workload
    by increasing the number of servers in your resource pool instead of relying on
    a standalone resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manageable**: It is easy to use for both developers and administrators. This
    also gives MondoDB the ability to share databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic schema**: It gives you the flexibility to evolve your data schema
    without modifying the existing data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CouchDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CouchDB is also a document-based NoSQL database. It stores data in the form
    of JSON documents. The following are some of the benefits and strengths of CouchDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema less**: As a member of the NoSQL family, it also has a schema-less
    property that makes it more flexible, as it has the form of JSON documents to
    store data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP query**: You can access your database documents using your web browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conflict resolution**: It has automatic conflict, which is useful when you
    are going to use a distributed database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy replication**: Replicating is fairly straightforward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Redis is another open source NoSQL database that is mainly used because of
    its lightening speed. It is written in the ANSI C language. The following are
    some of the benefits and strengths of Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data structures**: Redis provides efficient data structures to such an extent
    that it is sometimes called as a data structure server. The keys stored in a database
    can be hashes, lists, and strings, and can be sorted or unsorted sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis as cache**: You can use Redis as a cache by implementing keys with
    limited time to improve the performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Very fast**: It is considered as one of the fastest NoSQL servers, as it
    works with the in-memory dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a database system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django supports several database engines. Interestingly, however, you only need
    to learn one API in order to use any of these database systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is possibly because of Django's database layer that abstracts access to
    the database system.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about this later, but, for now, you only need to know that regardless
    of which database system you choose, you will be able to run the Django applications
    developed in this book (or elsewhere) without modification.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike client-server database systems, SQLite does not require a resident process
    in memory, and it stores the database in a single file, making it ideal for our
    development environment. That is why we have used this database throughout this
    project, until now. Of course, you are free to use your preferred database management
    system. We can tell Django which database system to use by editing a configuration
    file. It is also worth noting that if you want to use MySQL, you will need to
    install MySQL, which is the MySQL driver for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a database system in Django is really simple; all your need to do
    is install the database you want to configure first, then add a few configuration
    lines in the `settings.py` file, and you are done with the database setup.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will install and configure MySQL and its related plugins step by step in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL in Linux – Debian
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Execute the following command to install MySQL in Linux (Debian here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After executing this command, you will be asked to set up MySQL and configure
    the database with a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the MySQL plugin for Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install the MySQL-related plugins that you require, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `settings.py` file and add the following lines for Django to
    connect with MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, all you need to do now is to recreate all the tables in the new
    database that you just configured and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will get the `django.db.utils.ConnectionDoesNotExist` exception if you have
    not defined the database that you are trying to access.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of Django is that you can use it with multiple databases at once.
  prefs: []
  type: TYPE_NORMAL
- en: However, you may think, what is the need of multiple databases in the same project?
  prefs: []
  type: TYPE_NORMAL
- en: Until the NoSQL database came into existence, in most of the cases, the same
    database was often used to keep the records of all types of data, from critical
    data, such as user details, to dump data, such as logs; all were kept in the same
    database and the system faced challenges while scaling up the system.
  prefs: []
  type: TYPE_NORMAL
- en: For a multiple database system, an ideal solution could be to store the relational
    information, such as users, their role, and other account information, in an SQL
    database, such as MySQL. The application data, which is independent, can be stored
    in a NoSQL database, such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We need to define multiple databases through a configuration file. Django needs
    to be told when you want to use more than one database with the database servers
    you use. So, in the `settings.py` file, you need to change the `DATABASES` setting
    with the database aliases map.
  prefs: []
  type: TYPE_NORMAL
- en: 'An appropriate example of the multiple database configuration can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses two databases, which are PostgreSQL and MySQL with
    the required credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Migration and the need for migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migration allows you to update, change, and delete models by creating migration
    files that represent the model changes and which can be run on any development,
    staging, or production database.
  prefs: []
  type: TYPE_NORMAL
- en: Schema migration with Django has had a long and complex history; for the last
    few years, the third-party application **South** was the only go-to choice. If
    you think about the importance of migration, Django 1.7 was released with an inbuilt
    support of migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to know about South versus Django migrations as well. For those who
    are familiar with South, this should feel pretty familiar and probably a little
    bit cleaner. For easy reference, the following table compares the old South workflow
    to the new Django migrations workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Steps | South | Django migration |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Initial migration | Run `syncdb` and then `./manage.py schemamigration <appname>
    --initial` | `./manage.py makemigrations <appname>` |'
  prefs: []
  type: TYPE_TB
- en: '| Apply migration | `./manage.py migrate <appname>` | `./manage.py migrate
    <appname>` |'
  prefs: []
  type: TYPE_TB
- en: '| Non-first migration | `./manage.py schemamigration <appname> --auto` | `./manage.py
    makemigration <appname>` |'
  prefs: []
  type: TYPE_TB
- en: So, from the table, we can see that Django migrations basically follow the same
    process as South, at least for the standard migration process—this just simplifies
    things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The new features in Django migration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new migration code will be in the improved version of South, but will be
    based on the same concepts, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Migration per application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto detection of the changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data migration alongside schema migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following term list to understand the advantages
    of Django migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved migration format**: The much improved migration format is readable,
    and can thus be optimized or examined without actual execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebasing**: In this, there is no need to keep or execute the whole history
    of migration every time, as it will now be possible to create new first migrations
    as the project grows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved auto detection**: New and custom field changes will be detected
    more easily, as migration will be built in with the improved field API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better merge detection**: The new migration format will automatically resolve
    the merging between different VCS branches, which will no longer need any work
    if we are able to merge the changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you set up your project and start the application, that is, your application
    has generated the necessary tables in your database, you are not supposed to make
    complex changes to your Django models, that is, you should not delete your attributes
    from a class. However, practically, that is not possible, as you might need to
    change your model classes accordingly. In such cases, we have a solution to fix
    these kind of problems. The process is called **migration**, and, in Django, these
    migrations are done with a module called South.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until the 1.7 version of Django, which is the latest one, you have to separately
    install the south module. However, since Django''s 1.7 migration, the south module
    is a built-in module. You might have always been doing it, for example, when you
    changed (changes such as adding new attributes) your model classes using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the newer version, `manage.py syncdb` has been deprecated for migration,
    but if you still like the old way, this works for now.
  prefs: []
  type: TYPE_NORMAL
- en: Backend support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very important for any Django application that is used in production
    to get migration support. Thus, choosing a database that is primarily supported
    by the migration module will always be a better decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the most compatible databases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PostgreSQL**: In terms of migration or schema support, PostgresSQL is the
    most compatible database out there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can initialize your new column with `null=True`, as this will be added much
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: '**MySQL**: MySQL is a widely used database, as Django supports it seamlessly.
    The catch here is that there is no support for transaction when schema alteration
    operations are done, that is, if an operation fails, you will have to manually
    revert the changes. Also, for every schema update, all the tables are rewritten,
    and this could take a lot of time, and getting your application up again can take
    a lot of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite**: This is the default database that comes with Django and is mainly
    used for development purposes. Thus, it has little schema alteration support that
    is limited to the following cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of a new table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping an old table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do migrations?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Migration is done mainly with the first three commands, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`makemigrations`: This is based on the changes you made to the models that
    prepare the migration query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`migrate`: This applies the changes prepared by the `makemigrations` query
    and lists their status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlmigrate`: This displays the SQL query that the `makemigrations` query prepared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the flow for Django''s schema migration can be stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prepare the migration file, which will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after the file has been created, you can check the directory structure.
    You will see a file named `0003_auto.py` under the `migration` folder; you can
    apply the changes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the operations that you need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `OK` message says that the migration has been applied successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it more understandable, the migration can be explained with the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do migrations?](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three separate entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A developer makes changes in the source code, mainly in the `models.py` file,
    and alters the previously defined schema. For example, when they create a new
    field as per the business requirements, or update max_length from 50 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: We will complete a proper migration of our project to see how this migration
    actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to create an initial migration of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the initial migration has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change our tweet modal, which is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text = models.CharField(max_length=160, null=False, blank=False)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change the preceding tweet modal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text = models.CharField(max_length=140, null=False, blank=False)`'
  prefs: []
  type: TYPE_NORMAL
- en: As we have changed our schema, we now have to do the migration to run the application
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the migration flow, we understood that, now, we have to run the `makemigrations`
    command, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it has detected the change in our field.
  prefs: []
  type: TYPE_NORMAL
- en: Just for verification, we will open our SQL database and check the current schema
    of our tweet table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Login to MySQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the MySQL console, write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you the schema of the tweet table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have not applied our migration yet, the database clearly displays the
    text as 160 in the character field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do the exact same thing after we apply our migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the operations that we need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our migration has been successfully applied; let's verify the same from the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the same MySQL `desc` command on the `tweet_tweet` table, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed! Our migration was successfully applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How migrations know what to migrate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django will never run a migration more than once on the same database, which
    means that it persists this information. This information is managed by a table
    called `django_migrations`, which is created the very first time the Django application
    is started, and for every migration thereafter, a new row is inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is what the table might look like after running our migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding table shows that there are two migrations with tagged information,
    and that every time you migrate, it will skip these changes, as there is already
    an entry in this table corresponding to that migration file.
  prefs: []
  type: TYPE_NORMAL
- en: This means that even if you change the migration file manually, it will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: This makes sense, as you generally don't want to run migrations twice.
  prefs: []
  type: TYPE_NORMAL
- en: However, if for some reason you really want to apply the migration twice, you
    can simply delete the table entry *"THIS IS NOT A OFFICIALLY RECOMMENDED WAY"*
    and it will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if you want to undo all the migrations for a particular application,
    you can migrate to a special migration called zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you type, all the migrations for the tweet application will
    be reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In addition to using zero, you can also use any arbitrary migration, and if
    that migration is in the past, then the database will be rolled back to the state
    of that migration, or will be rolled forward if the migration hasn't yet been
    run.
  prefs: []
  type: TYPE_NORMAL
- en: The migration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what does the migration file contain and what exactly happens when we run
    the following command?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After you run this, you can see a directory called `migrations`, where all the
    migration files are stored. Let's have a look at them. As they are Python files,
    they might be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `tweet/migrations/0001_initial.py` file, as this is the file where
    the initial migration code is created. It should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For migration to actually work, there must be a class called `Migration()`
    that inherits from the `django.db.migrations.Migration` module. This is the main
    class that is used for a migration framework, and this migration class contains
    two main lists, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependencies**: This is the list of other migrations that must run before
    the migration starts. In cases where there is a dependency, such as in the case
    of a foreign key relationship, the foreign key model must exist before its key
    is added here. In the preceding case, we have such a dependency on the `user_profile`
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**: This list contains the list of migrations to be applied, and
    the whole migration operation can be of the following categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateModel`: From the name itself, it''s very clear that this will create
    a new model. From the preceding model file, you can see lines such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These migration lines create the new model with the defined attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '`DeleteModel`: This will contain the statement to delete the model from the
    database. These are the opposite to the `CreateModel` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RenameModel`: This renames the model with the given new name from the old
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlterModelTable`: This will change the name of the associated table with the
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlterUniqueTogether`: This is the unique constraints of the table that is
    changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlteIndexTogether`: This changes the custom index set of the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddField`: This simply adds a new field to the existing model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveField`: This drops the field from the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RenameField`: This renames the field name from the old name to the new name
    for a model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The migration of a schema is not the only thing that needs to be migrated while
    updating the application; there is another important thing called **data migration**.
    This is the data that is already stored in the database by previous operations
    and, thus, also needs to be migrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data migration can be used in many situations. Among them, the most logical
    situations are:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading an external data to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is a change in the model schema and the dataset needs to be updated
    as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s play with our project by loading a tweet from the `username.txt` file.
    Create an empty migration for our project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a migration file named `mytweets/migrations/003_auto<date_time_stamp>.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this file; it will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nothing but the basic structure of the Django migration tool, and to
    do data migration, we have to add the `RunPython()` function in the operations,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. Now, run the migrate command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the operations that you need to perform as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, the command migrated all the applications
    and finally applied our migration in which we created the new tweet from the loaded
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's awesome, right?
  prefs: []
  type: TYPE_NORMAL
- en: This kind of a solution is much needed when you have external data in the form
    of a JSON or XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal solution will be to use the command-line argument to get the file
    path and to load the data as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add your migration folders to Git, as they are as important
    as your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Django with NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django does not officially support the NoSQL database, but with such a great
    community of developers, Django does have a fork that has **MongoDB** as a backend
    database.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of illustration, we will use the Django-Norel project to configure
    Django with the MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the detailed information regarding this at [http://django-nonrel.org/](http://django-nonrel.org/).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB can be installed by following the steps mentioned at [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/)
    as per the configuration you have.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will set up MongoDB for the Debian version of Linux (specifically,
    Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the MongoDB public GPG Key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list file for MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the local package database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the MongoDB packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Start MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The single-page application project – URL shortener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways in which MongoDB can be used with Django, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MongoEngine**: This is a **Document-object Mapper** (think of ORM, but for
    document databases) that is used to work with MongoDB from Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Django non-rel**: This is a project to support Django on nonrelational (NoSQL)
    databases; currently it supports MongoDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation of MongoEngine is required before we move further and show you
    how to configure MongoEngine with Django. Install MongoEngine by typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to protect the previous project we created, and to better understand,
    we will create a separate new project for MongoDB configuration, and we will use
    our existing project to configure MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will create the basic structure of the project, as we very well know.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting MongoDB with Django
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have to modify the `settings.py` file, and if we are only using MognoDB
    for the project, which is true in this case, then we can ignore the standard database
    setting. All we have to do is to call the `connect()` method on the `settings.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will place a dummy backend for MongoDB. Just replace the following code
    in the `settings.py` file, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Authentication in Django
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of MongoEngine is that it includes a Django authentication backend.
  prefs: []
  type: TYPE_NORMAL
- en: A user model becomes a MongoDB document and implements most of the methods and
    attributes that a normal Django user model does, which makes MongoEngine compatible
    with Django. We can also use the authentication infrastructure and decorators,
    such as the `login_required()` and `authentication()` methods. The `auth` module
    also contains the `get_user()` method, which takes a user ID as an argument and
    returns the user object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this backend for MognoEngine, add the following in the `settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Storing sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Django, you can use different databases to store a session for an application.
    To enable the MongoEngine session that is stored in MongoDB, there must be an
    entry of the `django.contrib.sessions.middleware.SessionMiddleware` parameter
    in `MIDDLEWARE_CLASSES` in the `settings.py` file. There must also be an entry
    of `django.contrib.sessions` in `INSTALLED_APPS`, which are there as we started
    the project from Django's basic structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all you need to do is add the following line in the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We are now all set up to get started with a small demo project, where we will
    implement the URL short project in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a URL modal first, which is where we will store all the long URLs
    and their corresponding short URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following `url/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You are already familiar with the first two lines of the preceding code, which
    imports the modules.
  prefs: []
  type: TYPE_NORMAL
- en: The third line, that is, `connect('urlShortener')`, connects Django with the
    MongoDB database named `urlShortener`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB gives many connection mechanisms that you can choose from, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that we are using takes MongoDB from its default port, which is
    27017; if you are running MongoDB on an other port, use the `connect()` method
    to connect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you configured a password to MongoDB, you can pass the parameters as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Like Django''s default model fields, MongoDB also gives you different fields,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BinaryField`: This field is used to store raw binary data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BooleanField`: This is a Boolean field type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTimeField`: This is a datetime field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComplexDateTimeField`: This handles microseconds exactly the way they are
    instead of rounding them up like `DateTimeField` does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecimalField`: This is a fixed point decimal number field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DictField`: This is a dictionary field that wraps a standard Python dictionary.
    This is similar to an embedded document, but the structure is not defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DynamicField`: This is a truly dynamic field type capable of handling different
    and varying types of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailField`: This is a field that validates input as an e-mail address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileField`: This is a GridFS storage field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FloatField`: This is a floating point number field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GeoPointField`: This is a list that stores the longitude and latitude coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageField`: This is the image file storage field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntField`: This is a 32-bit integer field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListField`: This is a list field that wraps a standard field, allowing multiple
    instances of the field to be used as a list in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapField`: This is a field that maps a name to a specified field type. This
    is similar to `DictField`, except that the ''value'' of each item must match the
    specified field type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectIdField`: This is a field wrapper around MongoDB''s object IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringField`: This is a unicode string field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLField`: This is a field that validates input as a URL and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, fields are not required. To make a field mandatory, set the required
    keyword argument of a field to `True`. Fields also may have validation constraints
    available (such as, max_length in the preceding example). Fields may also take
    default values, which will be used if a value is not provided. Default values
    may optionally be a callable, which will be called to retrieve the value (as in
    the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: The full list of different fields can be seen at [http://docs.mongoengine.org/en/latest/apireference.html](http://docs.mongoengine.org/en/latest/apireference.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create our `Url()` class, which will be similar to other models
    that we created so far, such as tweets and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following term list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`full_url`: This is a URL field that will store the full URL, and the same
    URL where the request will be redirected when its short URL is trigged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short_url`: This is the short URL for the corresponding long URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: This will store the date when the `Url` object was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will move to view and create two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**: Here, a user can generate short URLs. This will also have a `post()`
    method that saves every long URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link**: This is the short URL redirection controller. When a short URL is
    queried, this controller redirects the request to a long URL, such as shown in
    the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following term list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get()` method is simple: it forwards the request to the `base.html` file
    (which we will create soon)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `post()` method takes the long URL from the request''s POST variable and
    sets the object count, just as the short URL saves the `Url` object to the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is used to pass the current path to the view so that the short URL can
    be made clickable with the anchor tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how this URL object is saved in DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will move on to the `Link()` class, which will take the short URL request
    and redirect to the long URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `short_url` parameter is the `short_url` code from the requested URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line queries the database to check whether the matching long
    URL exists for the given short URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This redirects the request to find the long URL from the database.
  prefs: []
  type: TYPE_NORMAL
- en: For the view, all we need to create is the `base.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: As the aim of this project is not to teach you user interface, we will not include
    any library and will make the page with as little HTML as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `base.html` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This shows a text area with the form, and after submitting the form, it shows
    the short link beneath the long URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the minimalistic URL shortner home page looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing sessions](img/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make this work, all we need to do now is to create the required URL mapping,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this chapter is to prepare you to create your project with different
    databases, and also to give you a basic idea about database migration and how
    these migrations work. This will not only help you to debug your migration, but
    also you can create your own data migration scripts to load the data from a JSON
    file, or any other file format, directly to the Django application to initialize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also gave you a basic idea of how to set up Django with MongoDB,
    and we also saw a small project demonstration followed by the real-world application
    of scaling the Django system with MongoDB here.
  prefs: []
  type: TYPE_NORMAL
