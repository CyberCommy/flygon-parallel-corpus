- en: Understanding Design Patterns and Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the years, software has become increasingly complicated. Now, software
    is not only used for mathematical calculations or simple **create, read, update,
    and delete **(**CRUD**) operations: we are employing it to carry out complex tasks,
    such as controlling rocket engines or managing huge amounts of data every day.
    Businesses from a vast range of sectors have started to adopt software systems,
    including banks, insurance companies, research institutes, education institutes,
    and government agencies. The higher the demand for software, the more people begin
    to build careers in software development. From assembly-language programming,
    came procedural programming, before the introduction of the era of **Object-oriented
    programming** (**OOP**), which is still the most popular model, despite the emergence
    of other types of programming, such as functional programming. OOP has helped
    developers write good, modular software that is easy to maintain and extend. In
    this chapter, we are going to discuss some of the most important design principles
    and patterns that are followed by thousands of developers, and we are going to
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Design principles in software development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different design patterns in software development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start discussing design principles, let's think about what we mean
    by **design principles **in software development. When we develop software, we
    first design its architecture, and then we start writing its code. We want to
    write our code in such a way that it generates no bugs, or so it is easy to find
    bugs if there are any. We also want the code to be easily understandable when
    we read it and we want it to be structured in such a way that it can be changed
    later if required. Although it is difficult to write the best-possible code, there
    are various principles in software development that have been developed by experienced
    computer scientists. Using these, developers can write very clean code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The software developer Robert C. Martin, also known as Uncle Bob, came up with
    five software design principles. These principles are so effective and helpful
    for developers that they have become a norm in the software industry. Collectively,
    they are known as the SOLID principle, which represents the following different
    definitions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**S **stands for the **single responsibility principle**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O **stands for the **open-closed principle**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L **stands for the **Liskov substitution principle**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I **stands for the **interface segregation principle**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D **stands for the **dependency inversion principle**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these principles one by one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A class should have one, only one reason to change."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we write a class, we should design it in such a way that
    it has only one responsibility. You should only need to change the class for one
    reason. If you have multiple reasons to change the class, it is violating the
    single responsibility principle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: If a class has more than one responsibility and you make changes to a piece
    of code, this might break another piece of code, as they are in the same class
    and share some dependencies. Your code might not be very decoupled.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The open-closed principle
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code needs to be written in such a way that adding new things in a software
    entity, such as classes, modules, or functions, is good, but modifying the entity
    itself should not be allowed. This reduces the possibility of bugs being generated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov substitution principle
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Derived types must be completely substitutable for their base types."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: – *Barbara Liskov*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This principle states that when you write a class, if it is derived from another
    class, it should be replaceable with the base class. Otherwise, your code will
    be very fragile and coupled. This principle was first discovered by Barbara Liskov,
    so it is named after her.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, developers create large interfaces that contain too much information.
    Many classes might use this interface, but they might not need everything in it.
    This is what you should avoid in order to follow this principle. This principle
    supports small interfaces instead of big interfaces and, if necessary, a class
    can inherit multiple small interfaces that are actually applicable for the class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules; both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    upon abstractions"'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: We know that, in software development, we work with layers. To make the layers
    decoupled, we have to design the dependencies of these layers in such a way that,
    instead of depending on each other, the layers should depend on abstraction. Therefore,
    if you change something in a high-level module or a low-level module, it won't
    harm the system. When we create these abstractions, we have to design them in
    such a way that they are not dependent on the implementation details. The abstractions
    should be independent and the classes that implement these interfaces or abstract
    classes should depend on those abstractions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, where all things are treated as objects, it's very important to keep
    track of how an object is created and managed. If a developer doesn't pay much
    attention to this topic, the objects of the software could make the software fragile
    and coupled. It's important to maintain the objects appropriately to keep the
    application easily extendable. Creational design patterns are patterns that help
    create objects in a manner where the most common problems regarding object creation
    can be avoided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts that exist in creational design patterns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating knowledge about the concrete classes the system uses
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide creating and combining instances of the concrete classes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns are classified into object-creational patterns and
    class-creational patterns, in which **object-creational patterns** deal with the
    creation of objects and **class-creational patterns** deal with the discovery
    of classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main creational design patterns in the industry:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method pattern
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of this pattern from *Design Patterns: Elements of Reusable
    Object-Oriented* *Software* by the Gang of Four is to provide a combination to
    build families of similar or reliant objects without specifying their concrete
    classes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing that this pattern offers is separation or abstraction
    of object creation. If you are not following any pattern, the simplest thing that
    comes to mind when you are creating an object is to use the `new` keyword and
    create an object wherever you need it. For example, if I need a `Person` object
    in my `Bank` class, the easiest way to do this would be to instantiate a `Person`
    object using a `new` keyword in the `Bank` class. However, using this approach
    sometimes creates complexity in the software. To avoid that, we can use the abstract
    factory pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern is mainly used in cases where you have objects
    from the same family, or that are related or dependent in some way. The idea is
    to create factory classes to carry out the work of object creation. If an object `A`,
    needs an instance of another object `B`, object `A` should ask the factory of
    object `B` to create an object of `B` and pass it to object `A`. In this way,
    object `A` is independent of the creation of object `B`. Now, in the abstract
    factory pattern, there is another layer of abstraction. The factory classes are
    also abstracted. This means that object `A` won't call the factory of object `B`
    directly, but instead use an abstraction. There should be a mechanism that determines
    which `Factory` class needs to be called. This means that object `A` is not dependent
    on any particular factory of another object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separating the plan of a complicated object from its imitation is the main idea
    of the builder pattern. In object-oriented software development, we sometimes
    need to create objects that are quite complex. For example, we might create an
    object that uses other objects, which in turn use other objects. Creating or instantiating
    this kind of object could be difficult when you just need that object to carry
    out another kind of work. It might also make the code more complex and reduce
    its readability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. Imagine that you are making some burgers, some
    of which are chicken burgers and some of which are beef burgers. When creating
    the chicken burger objects, you have to create a chicken burger patty object,
    a tomato ketchup object, a cheese object, and a bread object every time you create
    a chicken burger object, which leads to messy code. You also have to follow the
    same process when creating a beef burger object. This is a really complex way
    of handling and creating these objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern provides a nice way to solve this complexity. Using this
    pattern, we create a class called `Builder` whose main task is to create complex
    objects and return the newly-created object. With the builder pattern, we use
    another type of class, which is normally called the `director` class. The task
    of this class is to call the `Builder` class and get the object from it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to our burger example. We can have a `ChickenBurgerBuilder` class
    and a `BeefBurgerBuilder` class. These will set the items, the burger patty, the
    bread, the ketchup, and the cheese, in the class. When the `BurgerDirector` class
    wants to create a `chicken burger`, it will call `ChickenBurgerBuilder`. To create
    a `beef burger`, it will call `BeefBurgerBuilder`. The complexity of creating
    the `burger patty` and the other ingredients will be handled by the `Builder`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method pattern is very similar to the abstract factory pattern.
    The difference is that, in the factory method pattern, the factory layer is not
    abstracted. Using this pattern means that you will create a factory class that
    will handle the creation of classes that implement the same abstraction. This
    means that, if there is an interface that is defined by many subclasses, a `Factory`
    class can create any of those subclasses depending on the logic passed to `Factory`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. We will use the Factory method pattern to solve
    our burger-creating problem from the Builder pattern example we mentioned in the
    section, *The builder Pattern*. We will create a `Factory`, called `BurgerFactory`,
    that will take an input, such as `typeOfBurger` (Chicken or Beef). Then, `BurgerFactory`
    will decide which `Burger` type of object should be created. Let's suppose we
    have an Interface called `Burger` that both `ChickenBurger` and `BeefBurger` implement.
    This means that `BurgerFactory` will return an object of the `Burger` type. The
    client will not be aware which `Burger` Object will be created and returned. By
    using this pattern, we are isolating the client from a specific object, which
    increases the flexibility of the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern is used when you want to avoid creating new classes of the
    same type or sub-type using traditional object-creation mechanisms, such as new
    keywords. Put simply, this pattern states that we should clone an object and then
    work with the cloned object as another newly-created object. This way, the traditional
    method of object creation is avoided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern is a very simple design pattern. It involves creating
    only one object of a class in the whole application. A **singleton object** is
    an object that can't have multiple instances. Whenever a piece of code needs to
    use this singleton object, it won't create a new object; instead, it will use
    the old object that is already available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern is applicable when you want to handle some information from
    one source only. The best example of when we might use a singleton pattern is
    in a database connection string. In an application, if there are multiple database
    connections used, the database might get corrupted and cause exceptions in the
    application. Here, it's better to make the connection string a singleton object,
    meaning that only one instance is used for all communication. This reduces the
    chance of discrepancy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the design patterns that are available in software development are
    related to the code structure. These patterns help you to design your code in
    such a way that you will be able to avoid common structural problems. In the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four,
    there are seven structural design patterns. In this section, we are just going
    to discuss four of these, which are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to find out more about the other three, take a look at the book
    *Design Patterns: Elements of Reusable Object-Oriented Software* by the Gang of
    Four. At first, it might be a little confusing to start using these patterns,
    but, as you get more experienced, it will become easier to identify which pattern
    is appropriate for which situation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when we think of the word adapter, we think about a small device that
    helps us plug our electronic devices into a power socket with a different kind
    of interface on the plug. The adapter design pattern actually does the same thing
    in software code. This design pattern states that, if two modules of a software
    want to communicate with each other, but the interface that one module expects
    is different from the interface that the other module has, instead of changing
    one interface to match the other interface, an adapter should be used. The benefit
    of doing this is that, in the future, if you want your code to talk to another
    interface, you won't have to change your code, but just use another adapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you have an Interface, `A`, but the code that you want
    to talk to wants another Interface, `B`. Instead of changing Interface `A` to
    Interface `B`, you use an adapter that converts interface `A` to interface `B`.
    This way, the code that uses interface `A` will not break, and you will be able
    to communicate with the code that asks for interface `B`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern allows us to add new behaviors to objects dynamically.
    When this new behavior is added to an object, it shouldn't affect any other behavior
    that already exists on that object. This pattern provides a solution when you
    have to add new behaviors to an object at runtime. It also removes the need to
    create subclasses just to add a behavior to a task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, if you have complex object relationships, it is hard to map them
    all and use them in your code. The facade pattern states that you should use a
    middle object to deal with the object-relational issues and give the client an
    easy point of contact. Let''s think about an example: when you go to a restaurant
    and order some food, you actually don''t go to each chef or person in the kitchen
    and collect food portions and make your own food; you tell the waiter what food
    you want. You don''t know how the item will be prepared or who will prepare it.
    You have no control over the making of the food, you just know that you will get
    the item that you have asked for. Here, the person taking the order is working
    as a facade. They take your order and ask different people to prepare the item
    you asked for.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you ordered a beef burger. You call a `GetBeefBurger()` method
    and the facade will actually call the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding methods are not real methods. I just want to give you an idea
    that the work of a facade is actually to hide the complexity from the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is very similar to the other structural design patterns that we
    have discussed. If there is a situation in which a piece of code should not call
    another piece of code directly for whatever reason, the proxy pattern can be used.
    The proxy pattern is especially useful when a piece of code doesn't have access
    rights to call another piece of code or when calling a piece of code directly
    is expensive in terms of resources. An example of when we might want to use a
    proxy pattern would be if we wanted to use a third-party library in our application,
    but we don't want our code to call the library directly for security reasons.
    In this case, we can create a proxy and let it communicate with the third-party
    code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behavioral design patterns are design patterns that deal with communication
    between objects. These design patterns allow your objects to communicate in a
    way that avoids the common issues that developers face related to object behavior.
    There are many patterns in this category:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The chain-of-responsibility pattern
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command pattern
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter pattern
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator pattern
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator pattern
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memento pattern
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state pattern
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template-method pattern
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visitor pattern
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, however, we are only going to talk about the following behavioral
    design patterns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to find out more, refer to the *Design Patterns: Elements of Reusable
    Object-Oriented Software* book by the Gang of Four that we mentioned earlier.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern states that, when an object wants to notify another object or call
    a method of another object, it should use another object instead of doing so directly.
    The object that will establish the communication is known as the command object.
    The command will encapsulate the object that holds the method to be called, the
    method name to be called, and the parameters that are to be passed, if there are
    any. The command pattern helps to decouple the relationship between the invoker
    and the receiver.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **observer pattern** is a solution to a problem in which many objects need
    to know when a particular object changes because they might have to update the
    data on their end. One way to do this is that all the objects, or observers, should
    ask the object, or the observable, whether the data has changed. If the data has
    changed in the observable, the observer will do its work. However, if we do this,
    the observers have to ask the observable about data changes very frequently to
    avoid slowing down your application. This requires a lot of resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern says that the observable should know the list of the observers
    that want to know about the data changes in the subject and notify each observer
    when the data in the subject is changed. This could be done by calling a method
    of the observers. A good use of this pattern is event and delegate in C#.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at a definition of the strategy pattern from the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: For example, a method could have different types of implementations depending
    on which class is using it. The definition, therefore, means that we need to make
    these different algorithms implement a base class or interface so that they belong
    to the same family and can be used interchangeably by the clients. The last part
    of the definition means that this pattern will allow clients to use different
    algorithms without affecting other clients.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we have a class, called `Animal`, that has a few common properties,
    such as `eat`, `walk`, and `noise`. Now, let's say you want to add another property,
    such as `fly`. Most of the animals in your class can fly, but a few can't. You
    could break the `Animal` class into two different classes, such as `AnimalWhichCanFly`
    and `AnimalWhichCantFly`. However, splitting this `Animal` class into two could
    over-complicate things as these animals could have other different attributes
    as well. Instead of using inheritance, therefore, you could use composition, which
    means you can add a property called `fly` in the `Animal` class and use it to
    indicate this behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern states that instead of using a fixed type, `fly`, as the
    property type, we should use an interface, such as `IFly`, and then create `subclasses`
    that implement `IFly` and have different algorithms. Then, we can take advantage
    of polymorphism and assign the specific subclass at runtime when the subclasses
    of the `Animal` class are created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to apply this on the preceding example. In the `Animal` class, instead
    of using the `Fly` property, we will use `IFly` and then implement different classes
    that implement `IFly`. For example, we create the `CanFly : IFly` and `CannotFly
    : IFly` classes. `CanFly` and `CannotFly` will have different implementations
    of the `Fly` method. If we create a `Dog` class that implements the `Animal` class,
    we will set the `Fly` property as the `CannotFly` class. If we create a `Bird`
    class, we will create an instance of `CanFly` and assign it to the `Fly` property.
    By applying this pattern, we have achieved a less-complicated object structure
    and easily-changeable algorithms.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MVC pattern is one of the most popular design patterns in the industry.
    You might have heard about it already, even if you are very new to the industry.
    This pattern is heavily used in web development. Many popular web-development
    frameworks use this design pattern. Some popular frameworks that use the MVC pattern
    are given here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式是行业中最流行的设计模式之一。您可能已经听说过它，即使您是行业的新手。这种模式在Web开发中被广泛使用。许多流行的Web开发框架使用这种设计模式。以下是一些使用MVC模式的流行框架：
- en: '**C#:** ASP.NET MVC Web Framework'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C#: ASP.NET MVC Web Framework'
- en: '**Java:** Spring framework'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java:** Spring框架'
- en: '**PHP:** Laravel framework, Codeigniter framework'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP:** Laravel框架，Codeigniter框架'
- en: '**Ruby:** Rails framework'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ruby:** Rails框架'
- en: 'The MVC design pattern states that we should divide a web application into
    three parts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式规定我们应该将Web应用程序分为三个部分：
- en: Model
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: View
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Controller
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: The **model** is the part that will hold the data models or objects and will
    be used in database transactions. **View** refers to the frontend of the application,
    which the users or customers look at. Finally, the **controller** is the part
    that handles all the business logic of the application. All the logic and decision-making
    parts will be in the controller.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是将保存数据模型或对象并将用于数据库事务的部分。**视图**指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器**是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。'
- en: The benefit of the MVC pattern is that your application is decoupled. Your view
    is independent from your business logic and your business logic is independent
    of your data source. This way, you can easily change one part of your application
    without affecting other parts of the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式的好处在于您的应用程序是解耦的。您的视图独立于您的业务逻辑，您的业务逻辑独立于您的数据源。这样，您可以轻松地更改应用程序的一部分，而不会影响应用程序的其他部分。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Software development is interesting because it changes all the time. There are
    many ways in which you can develop, design, or code something. None of these can
    be classified as the best way, because your code might need to change depending
    on the situation. However, because software development is a type of engineering,
    there are various rules that will make your software stronger and more reliable.
    Software design principles and design patterns are examples of these kinds of
    rules. Knowing these concepts and applying them to your own situation will make
    your life as a developer much easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发之所以有趣，是因为它一直在变化。您可以以许多方式开发、设计或编写代码。这些方式都不能被归类为最佳方式，因为您的代码可能需要根据情况进行更改。然而，由于软件开发是一种工程类型，有各种规则可以使您的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将其应用于您自己的情况将使您作为开发人员的生活更加轻松。
- en: This chapter has hopefully given you an idea of the basics of design patterns
    and shown you where you can look for more information. In the next chapter, we
    will get to know a very powerful and interesting software called Git. Git is a
    version-control system that helps to keep track of software code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章希望给您一个设计模式基础的概念，并向您展示可以查找更多信息的地方。在下一章中，我们将了解一个非常强大和有趣的软件，叫做Git。Git是一个版本控制系统，有助于跟踪软件代码。
