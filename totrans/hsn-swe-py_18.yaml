- en: Testing and Deploying Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling Service
    Transactions*, ended with an untested receipt of over-the-wire CRUD operations
    being implemented for the data objects, originating with the Artisan and Central
    Office applications. Since proving (and demonstrating) these capabilities is going
    to be needed for both quality assurance and story approval purposes, and since
    there was no structured or useful repeatable testing of that code, in this chapter,
    we will take a detailed look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and dealing with the challenges of testing service applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is involved in packaging and deploying the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An approach for demonstrating the service's functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, since the functional development of `hms_sys` is very nearly complete,
    some thoughts and examinations of what's still remaining to be done in `hms_sys`
    for it to be useful to end users, and some possible future enhancements to it,
    will be undertaken.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of testing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing services, while not difficult, can be substantially more elaborate than
    the relatively basic unit testing that's been shown up to this point. Each point
    in the general `hms_sys` data flow from an Artisan to the Gateway, for example,
    has specific and individual testing concerns, but the flow as a whole should,
    ideally, be as well, so that an end-to-end process verification can be performed
    on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end-to-end flow could be pictured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/202a9763-12ff-4f2e-8304-7997d092d30a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From start to finish, a test plan for this data flow would need to address,
    at a minimum, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `message-data` in a fashion that it could be used to verify the
    process at its end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `DaemonMessage` (though probably not testing that it was created
    accurately—there should already be unit tests that take care of testing that)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the resulting **message**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that the results of the **Artisan Gateway service** receiving the
    message are as expected, by comparison with the original `message-data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on specifics of how the service operates, there are steps that happen
    between the transmission and receipt of the **message** that may not be practical
    (or may not be possible) to test:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the `send_message()` part of the overall process has to take steps to
    assure that the transmission of the **message** can be verified without some other
    process (the Gateway service, in this case) consuming the **message** before it
    can be verified. If the unit testing of `send_message` accounts for that, to the
    extent that the `send_message` method itself can be considered trustworthy, then
    the larger scope process test can safely skip testing that part of the whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, testing of the various `[process-method]` items should provide adequate
    trustworthiness with respect to their parts of the whole flow process. The alternative
    is altering those methods so that their operation can be observed during the process,
    in which case they really aren't the same methods, and any tests that are applied
    are potentially meaningless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given that each part of the overall process should have their own unit tests,
    it would be fair to ask these questions: *"What are we actually* *gaining* *by
    testing the whole process, then? Isn''t the collection of individual unit tests
    enough by itself?"* The short answer (though it may be taken as the author''s
    opinion) is **no**—from one vantage point, all of the process tests are, in a
    very real way, unit tests of the Artisan Gateway''s `main` method—the event loop
    that makes the decisions about which method to call based on the content of an
    incoming message. From that perspective alone, and given that `ArtisanGatewayDaemon.main`
    is the critical chunk of functionality in the class, it must be thoroughly tested.
    Also consider that the unit tests required by our testing policy essentially cover
    all of the boxes in the flow diagram: `message-data`, `DaemonMessage`, `send_message`,
    and so on. They do not provide any coverage of the arrows in the flow diagram.
    Though it may be unlikely that the code misses one of the steps that the arrows
    represent, it''s not impossible, so a higher-level, end-to-end process test that
    would reveal any of those gaps would, in turn, provide proof of the trustworthiness
    of the processes as a whole. Similarly, the end results of those processes each
    need to be verifiable—if, for example, an Artisan-Creating-Product process is
    fired off, some assurance needs to be made that once the process is complete,
    that new `Product` object can be retrieved from the data store, with the correct
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since the various processes all happen behind the scenes, they will
    likely be very hard to debug if a bug slips through into production installation:'
  prefs: []
  type: TYPE_NORMAL
- en: There will be little or no visibility into the individual Artisan application
    installations that are starting the execution of the processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messages that are being sent back and forth, barring extremely detailed
    logging of their content/data, won't persist long enough to be readable and usable
    for debugging in a production setting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without more detailed logging, the specific daemon process calls are happening
    invisibly, and their results, if there are any, cannot be checked against the
    original data that they originated from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall testing strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing the code that implements the full process testing, an effort
    needs to be made to complete and successfully execute all of the outstanding unit
    tests. Once this is complete, we can logically take it as a given that any failures
    that arise in the *process* tests are because of something in that process, though
    we may want to take steps to verify sub-process steps, and raise failures for
    certain conditions. This may well evolve as the process tests are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each business object that has a set of corresponding processes needs to check
    for any/all of the following processes that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation of the object, and both local and remote persistence of its data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By each role that is allowed to perform an update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure to test both valid and invalid update attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Updating the object''s data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By each role that is allowed to perform an update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure to test both valid and invalid update attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deletion of the object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By each role that is allowed perform a deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure to test both valid and invalid deletion attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying applicable local and remote data changes after the attempt is made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Determining what would constitute an invalid attempt requires consideration
    of the following questions, at a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: At any step in the process being tested, what could be corrupted that should
    prevent the process from completing successfully?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any step in the process being tested, what could be altered with malicious
    intent that should prevent the process from completing successfully?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What tests are already in place that account for these scenarios?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What tests need to be created for any scenarios that aren't accounted for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of the Gateway service, the points with potential for bad data
    variations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An invalid attempt is made to create or alter a business object instance:**
    These should be mostly covered by unit tests on the creation and update processes
    of the business objects themselves—these tests should assure that, for example,
    only well-formed data creation and updates are allowed, and having raised an exception
    there, the message transmission process shouldn''t even fire. These cases really
    can''t be tested in the context of the Gateway daemon, but must be tested in the
    applications that talk to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An unauthorized data event message is received:** The testing of message
    signatures in `DaemonMessage` should assure that messages with invalid signatures
    raise an error. As an extension of that, tests of the data event processes should
    assure that if an unauthorized message error is raised, it is handled cleanly,
    and does not execute any data changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An authorized data event message is received with invalid data:** Provided
    that the unit tests that are relevant for the data event on the origination side
    of the message are complete, this may be an indicator of malicious activity. Testing
    considerations aside for the moment, some review of the logging around this event
    should probably be undertaken to assure that events in this category are logged.
    Whether malicious or not, the corresponding unit tests on the receiving end of
    the message should assure that some kind of exception is raised, and the data
    event process tests should assure that any exceptions raised are handled cleanly
    and do not execute any data changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though these tests will not, strictly speaking, be unit tests (they would be
    formally classified as some mixture of system or integration tests), we can still
    leverage the functionality of the `unittest` module that has driven all of the
    automated testing for the system up until this point. This will allow the process
    tests to be integrated into, and thus run as part of a complete test suite, if
    there was a desire to do so, or to be run independently, or even individually
    if needed/desired.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing variations of note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bulk of the unit tests that need to be implemented fall fairly neatly into
    the standard processes that have been in play since the beginning of the `hms_sys`
    development effort, and there's nothing new to say about those. A relatively small
    number of others, however, have some noteworthy variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the advent of a substantial amount of new code that relies heavily on
    either standard Python modules (`atexit`, `logging`, and `signal`, for example,
    in the `daemons` codebases), or various third-party modules that were installed
    to meet specific needs (`pika`, for RabbitMQ support), another aspect of testing
    policy bubbles up: the question of how deeply (or even whether) to test functionality
    that are little more than wrappers around functionality from other sources. It''s
    not an unreasonable assumption that any packages that are part of the Python distribution
    itself are thoroughly tested before they''re included in the distribution. It''s
    probably not unreasonable to assume that any packages that are available to be
    installed through the `pip` utility are also thoroughly tested, though that may
    well vary significantly from package to package.'
  prefs: []
  type: TYPE_NORMAL
- en: These are variations on a theme that might be expressed as **trusting the framework**.
    Essentially, this boils down to operating under the assumption that packages installed
    through `pip` (or whatever facilities are provided by the OS) are sufficiently
    tested (for whatever the value of sufficient might be). If these are considered
    sufficiently tested, they do not need to be categorically tested themselves. Whether
    the functionality that was developed that uses trusted framework functionality
    needs to be tested becomes something of a judgment call, perhaps depending on
    the specifics of how the external functionality is used.
  prefs: []
  type: TYPE_NORMAL
- en: This consideration should be borne in mind as the noteworthy variations of unit
    tests are listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `hms_core` package, tests for the `BaseDaemon` and `BaseDaemonizable`
    ABCs have corresponding concrete classes defined (`BaseDaemonDerived` and `BaseDaemonizableDerived`,
    respectively), which are used to create test instances as needed. That''s not
    new in and of itself—we''ve used concrete derived classes to simplify testing
    of ABCs before. Creating testable instances of either, though, requires a configuration
    file to be passed during instance construction. The creation and clean up of that
    file is handled by the `setUpClass` and `tearDownClass` methods, which are defined
    on the `TestCase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When `setUpClass` executes, before any of the test methods fire, it creates
    a usable config file (`example.config`) in the current working directory, populates
    it with bare-bones configuration data, and keeps track of the filename in a class
    attribute (`cls._config_file)` that the test methods can access. The typical pattern
    for creating a test object within a test method ends up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A number of tests against members of `hms_core.daemons` were actively skipped.
    The various control methods (`start`, `stop`, and `restart`) of `BaseDaemon` were
    skipped grudgingly. The fundamental issue with trying to test those is that, as
    they stand right now, they are little more than a collection of calls to other
    methods, many of which will, themselves, be tested. The balance falls into the
    trust of the framework category. At most, there is one decision point (in start,
    where a check of the instance's `_running` flag is made) that could, perhaps, be
    usefully tested, but it would have to happen really quickly before a change to
    that flag value would terminate the instance's processes. Ultimately, as long
    as an instance of the daemon starts, stops, and restarts without error, these
    methods are performing as expected, and there is little to gain by explicitly
    testing the corresponding methods.
  prefs: []
  type: TYPE_NORMAL
- en: A similar decision was made for the `daemonize`, `preflight`, and `start` methods
    in `BaseDaemonizable`, for similar reasons, with the added wrinkle that many of
    the methods being called are provided by standard modules, and themselves would
    fall into the category of trusting the framework.
  prefs: []
  type: TYPE_NORMAL
- en: All of the logging wrapper methods of `BaseDaemon` (`critical`, `debug`, `error`,
    `info`, and `warn`) were actively skipped. The rationale behind that decision
    was that as long as the `Logger` instance that they call is created correctly,
    those instances fall into the "trust the framework" category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties of `BaseDaemonizable` whose values are filesystem paths (`stdin`,
    `stdout`, `stderr`, and `pidfile`) almost follow the standard testing structures
    that we established earlier. The primary difference is that they are filesystem
    path values, and so the test methods for those properties need to include both
    valid and invalid paths and paths that were well-formed, but that couldn''t be
    written to or read from because of filesystem permissions. These tests are also
    tightly bound to the operating system, in a sense: a perfectly valid file path
    in Windows, for example, is not going to be valid in a POSIX-style filesystem,
    such as those used by Linux or macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: A similar strategy was required for `BaseDaemon.config_file`, and the `configure`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cleanup` and `preflight` methods of `BaseDaemon` fell into a unique category:
    by default, all they do is log (at an `info` logging level) that they have been
    called, so that startup and shutdown activity logging can announce that they were
    executed. If a derived class doesn''t actually override these methods, the baseline
    functionality provided by `BaseDaemon` will be called, and perform the same logging.
    If the same standards are applied that were applied to the logging wrapper methods
    noted earlier, the implication is that `cleanup` and `preflight` both fall into
    the "trust the framework" classification. But what happens if a future need changes
    one of those methods, adding something that goes beyond the simple call to log
    that the method has executed? In that case, if the tests are skipped, there won''t
    be any testing being performed, even if there should be. The simple truth of the
    matter is that changes made that would impact the associated tests cannot be anticipated,
    and as a result, a certain amount of expected discipline has to be assumed—that
    anyone making a substantive change to those base methods will also have to update
    the corresponding tests accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: In the process of building and executing these unit tests, a handful of classes
    that were stubbed out earlier in the development cycle, but that were never actually
    used, surfaced as requiring tests. Since those were never needed (or even implemented,
    in many cases), the classes themselves have been removed, and the corresponding
    test requirements went away as a result.
  prefs: []
  type: TYPE_NORMAL
- en: The `RabbitMQSender` class, in `hms_core.messaging`, had one method—`send_message`—that
    partly fell into the "trust the framework" category. It also needed testing to
    assure that the type checking for a `DaemonMessage` instance was accounted for,
    though. Taken together, the complete testing for the method amounted to little
    more than the type checking test, and assured that the method executed without
    error. After some consideration, retrieving the sent message, or at least performing
    the acknowledgement of it so that it won't sit in some test queue forever, was
    implemented in `send_message` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining outstanding tests needed, all of which followed reasonably simple
    variations of the standard unit testing processes, were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `hms_core.business_objects` and `hms_artisan.artisan_objects`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the `Artisan.queue_id` and `Artisan.signing_key` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `hms_core.co_objects`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the `Artisan.to_message_data` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the new `Order` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `hms_core.daemons`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `BaseDaemon._create_logger`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `hms_core.messaging`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `DaemonMessage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `HasMessageData`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `InvalidMessageError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the standard items of `RabbitMQSender`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `hms_artisan.artisan_objects`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the `Artisan.to_message_data` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the tests in classes outside the `hms_Gateway` namespace accounted
    for, that leaves the properties and methods of the `ArtisanGatewayDaemon` class,
    which are ready to be tested. The properties and most of the methods therein,
    once more, can be tested by following the standard testing policy and process
    that's been in play. The most noteworthy exception is `ArtisanGatewayDaemon.main`,
    which will be skipped in the test module, and tested with the end-to-end-process
    tests that we can build now.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Artisan transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The end-to-end process test for an Artisan needs to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Artisan as it would happen if originating from a Central Office
    staff member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an Artisan as it would happen if originating from a Central Office
    staff member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an Artisan as it would happen if originating with the Artisan themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an Artisan as it would happen if originating from a Central Office
    staff member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we aren''t testing classes, which has been the pattern for all of our
    unit tests so far, we don''t need all of the functionality of our standard unit
    test extensions, but we will want to use enough of the same structure and at least
    some of the utilities that were created there in order to integrate the process
    flow tests with the regular unit test runs for the `hms_Gateway` namespace. With
    that in mind, the starting point code looks very similar to our previous test
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since all we really need from the unit testing extensions we''ve been using
    is the output and report-saving functionality, we will only import those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The module-level constants stay the same, and since we''re going to be testing
    against a running instance of the `ArtisanGatewayDaemon` class, we already know
    that we''ll need to import that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The four process flows that we''re going to test initially can each be represented
    by a single test method. Each of these methods will have to provide whatever code
    needs to be executed for each step of the flow test, but they can start with nothing
    more than an explicit failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re using our standard unit testing extensions, we still need to actively
    add each test case class to the local test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since we''ll want to be able to run the process tests module independently,
    we''ll include the same `if __name__ == ''__main__''` code block that''s been
    in all the previous modules, which will provide the output of the test results
    and save the results to a report file if there are no failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since all of these tests will need a running instance of the `ArtisanGatewayDaemon`
    class, we also need to make sure that one is available. Because a running instance
    of the class is a service, running independently of any other processes, starting
    up a service instance cannot happen as a normal part of any test method—the `main`
    loop would start, and nothing else would progress until it terminated, making
    it impossible to actually test the processes that `main` controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of options that could be pursued to alleviate this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test process could, in some fashion, use the operating system service control
    facilities to start a local service instance in much the same way that it would
    be controlled once it was deployed. On a long-term basis, this might be a better
    approach, but at this point in the development process, we aren''t able to actually
    deploy the service code, so that would have to wait for future development. There
    is a trade-off to this approach, though: the service would have to be deployed,
    or some equivalent mechanism would have to be created to mimic a deployed service,
    on each execution of the test suite in order for tests to be accurate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the service is, ultimately, just an instance of a class, the test process
    could create an instance and start it, let the tests execute, then terminate the
    service instance that was used for the tests. Although this is a more complex
    solution, it feels better in at least one respect: each test suite would be able
    to execute against a service instance that could be customized specifically for
    those tests, including having distinct message queues that could, if necessary,
    be examined while working through issues raised by the test methods, without having
    to sort through a potentially huge set of messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing the second option involves using the `setUpClass` and `tearDownClass`
    methods that were noted earlier to create the service instance and make it run
    before any tests execute, and shut the instance down after they''ve all completed.
    Since it makes sense to have one test case class for each business object process
    set, setting up `setUpClass` and `tearDownClass` so that they can be reused by
    the various test case classes also feels like a good plan. We can simplify this
    by creating a class that contains all the required logic for both methods, then
    derive the individual test case classes from that new class and the normal `unittest.TestCase`
    class that''s been the backbone of our test case classes so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This, incidentally, shows that it's possible to add helper classes to test suites—classes
    that provide some functionality or capabilities needed during test execution,
    but that aren't, themselves, test case classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a configuration file that the service instance will use,
    but before we do that, we''ll store some of the values we''re likely to need in
    the test methods as class attributes so that we can access them later when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration data can be set up as a string that follows the configuration
    structure that was established earlier. Customization of the service instance,
    if needed, can be managed by adding variable/attribute values to the class, and
    making sure that those values get carried into the string, as was done with the
    `cls.Gateway_queue_id` and `cls.Gateway_signing_key` attributes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration data is written to a temporary config file that''s used by
    the test case class, in much the same way that we did before when testing `BaseDaemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we may need to access the service instance itself, we''ll create and
    store the instance as another class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting the service instance requires executing its start method so that the
    process is independent of the running test code. To achieve this, we''re going
    to use the `Process` class, from Python''s `multiprocessing` module, telling it
    what method to call when the `Process` is started, and that the process should
    be treated as a `daemon`, keeping its execution independent from other running
    code. Once that''s been set up, we can start the `Process`, which executes the
    start method of the service instance stored in `cls.Gateway`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `multiprocessing` module will be explored in more detail in [Chapter 19](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml),* Multi-processing
    and HPC in Python,* as we explore various strategies and approaches for scaling
    computational load across multiple processes and machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The teardown is much simpler: having stored the process that controls the running
    service instance (`cls.Gateway_process`), that `Process` simply needs to be terminated
    (the `terminate` method call), and the temporary config file deleted so that we
    don''t leave it in the test code. Because the termination of the process may not
    be complete before the teardown execution is complete, a short delay has been
    added as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `NeedsArtisanGateway` class in the test case classes requires some
    trivial code changes: each test case class needs to derive from `NeedsArtisanGateway`
    and `unittest.TestCase`, to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since `NeedsArtisanGateway` requires a `queue_name` class attribute to
    create the `Gateway_queue_id` class attribute, that needs to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From that point on, however, all that remains is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Before implementing any of the tests, there is some configuration and setup
    that needs to happen within the test module. All of the process tests are expected
    to need data access capabilities, so we need to import the main data store class,
    as well as the data store configuration class, and configure data access to allow
    those capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, since the process tests are all concerned with message transmission,
    we''ll need to be able to create sender objects—instances of `RabbitMQSender`—as
    well as `DaemonMessage` objects. Those, too, need to be imported, and a base `RabbitMQSender.configuration`
    call needs to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`MESSAGE_ORIGINS` in the `import` line is a new module constant, a collection
    of names and values that can be used to control what values are members of the
    collection, what names are associated with them, and to determine whether a given
    value is a member of the collection. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Python does have some official enumeration classes, but the one that would otherwise
    be best suited to meet this need, `enum.Enum`, does not allow an arbitrary value
    to check for membership in the enumeration. The differences can be seen in the
    results shown in the `enumeration-example.py` file in this chapter's code (in
    `hms_Gateway/scratch-space`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, since the test processes will be using classes with the same names
    from different namespaces (for example, `hms_core.co_objects.Artisan` and `hms_artisan.artisan_objects.Artisan`,
    both named Artisan), we need to import these and rename them in the process, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From this point onward, any creation of a `COArtisan` object will be instances
    of the `hms_core.co_objects.Artisan` class, and `ARArtisan` objects will be `hms_artisan.artisan_objects.Artisan`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those out of the way, the implementation of the first process test method
    can (finally) begin. It starts with the creation of the `sender` object, which
    will be used to send the test messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the Artisan creation process, we have to create an Artisan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the `message` to be sent, and send it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point in the code, the message has been sent, but there''s no easy
    way to determine whether it''s been received yet, let alone processed. Without
    actually writing code (possibly a lot of code) to keep track of messages and their
    status, there''s not much in the way of options to pause processing until we''re
    reasonably certain that the message has been delivered and acted upon. The next
    best option, and one that takes a lot less code effort, though it will slow down
    the test process, is to simply delay the execution for a short time—long enough
    to allow the message to be delivered and acted upon, but not so long that running
    the tests becomes problematically long. Using `time.sleep`, we''re going to delay
    processing for 5 seconds, at least for now. It may need to be increased later,
    or it might be able to be decreased if a better feel for how long the process
    takes to complete is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the message has been received and acted upon, if all went well, then a
    `new_artisan` object will be created by the Gateway service, and saved to the
    database that it''s using. The next step in testing the process is to assure that
    a new object was, in fact, created and stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing that the new object was created, we can then check to make sure that
    the new object''s data is identical to the data that was originally sent to create
    it. Since the data dict representation of any data object is going to be the most
    comprehensive—it should include all data that gets persisted—that is a simple
    comparison of the original `Artisan` and the newly created and retrieved `Artisan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the test process gets past that check, then we''re done with the `new_artisan` object
    that we created to test, and we can delete it from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes the "happy path" testing of the process—where everything was
    created, formatted, and sent exactly as intended. Testing unauthorized and badly
    formed messages requires a bit more work, since we''ll be circumventing the checking
    that''s performed by the `Artisan` and `DaemonMessage` classes. Starting, then,
    with an unauthorized message, where the signature of the message doesn''t match
    the signature calculated on the receiving end, we need to first create an unauthorized
    message. We can use the existing message, since it still exists, extract the data
    we''ll be sending, and then alter something—either a data value or the signature
    will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have a `sender`, we can use its `channel`, along with the
    `Gateway_queue_id` of the instance, to circumvent the normal sending process that
    expects a `DaemonMessage` instance. Instead, we''ll send the JSON dump of the
    unauthorized message that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The test portion of this branch is concerned with whether a data change made
    it through the Gateway service. If one did, it would have generated a new `Artisan`
    record, and we could retrieve the corresponding object. If it did, and we can,
    then something went wrong, and we explicitly cause the test to fail. If the retrieval
    attempt failed (raising an `IndexError` because the result set that comes back
    is a zero-length list, and has no element at `[0]`), that''s the expected/desired
    behavior, and we can simply ignore the error, passing that portion of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing an invalid but authorized message works much the same way, but we''ll
    alter the message data, and then use a normal `DaemonMessage`/`sender` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Variations on the same theme for the Central-Office-updating-Artisan and Central-Office-deleting-Artisan
    processes will look very similar, with each doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local Artisan and saving it in order to have a data object that's
    going to be manipulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally verifying that the newly created Artisan exists in the database before
    proceeding, though if the `Artisan.save` method is considered trustworthy from
    other tests, this could be skipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an appropriate `message` to execute the process being tested, and sending
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing the results against a second instance of the same Artisan:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The update process tests have to make a point of changing all fields that can
    be legitimately changed by the role that the test is acting in—as a Central Office
    user/Artisan Manager. In that respect, it might look very much like previous unit
    tests against methods like `Artisan.to_data_dict`, which return dictionary representations
    of the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should also make a point of trying to make changes to the Artisan that shouldn't
    be allowed, and verifying that those attempts fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deletion process test will be considerably simpler, since all it will need
    to do is try and re-acquire the test object (using something similar to `verify_artisan
    = COArtisan.get(str(new_artisan.oid))[0]`, which we looked at previously) with
    the test passing if the retrieval effort fails after deletion is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tests against invalid access attempts, such as an Artisan creating an Artisan,
    should also be implemented, and would have a code structure similar to portions
    of the test code shown previously. Before those tests could pass, though, mechanisms
    to actually check the message in the various operation methods would have to be
    implemented. Using the `origin` of the incoming `DaemonMessage` for any given
    operation, this might look something like this, showing a general, any-role-is-allowed
    check and a specific-role-only check, and using the `create_artisan` method of
    the Gateway service as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tests against invalid role/action execution variants would look very much like
    the testing of `invalid_message` that we saw previously, verifying that the operation
    method doesn't execute when presented with a well-formed message that's attempting
    to execute an operation that's not allowed by any given role/`origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing transaction processes that originate from the application side of a
    relationship is a bit more complicated, if only because there''s been no significant
    development so far on those applications. To test these processes, a bare-bones
    mock-up of the application processes would have to be created, at least initially—later
    on down the line, when there are reasonably complete and tested applications,
    it might be better to actually run a local instance of them. Both Artisan and
    Central Office applications would need a mock-up, and would need to provide CRUD
    operations methods in much the same manner that the Gateway service daemon''s
    class does. A mock-up of the Artisan application might start with code such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the Gateway service could be reused, in part, to provide a
    method that routes messages to their respective operation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than having a `main` loop, though, the mock-up would be better served
    by having a single method that acts like a single pass through the Gateway service''s
    `main` loop. For testing purposes, this allows the handling of messages to be
    more tightly controlled so that any number of test messages can be sent as part
    of a test process. Then, a single call can be made to the `ArtisanapplicationMock`
    method to read and handle all messages, which results in the fact that those messages
    can be tested. This method, `handle_pending_messages`, still looks a lot such
    as `ArtisanGatewayDaemon.main`, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With that available, and a corresponding mock-up for the Central Office application,
    the processes for testing transactions that originate with an application passing
    through the Gateway service to the other application and making changes will be
    similar to the testing process for simpler transactions, such as creating an Artisan:'
  prefs: []
  type: TYPE_NORMAL
- en: A message is created for the operation, with the appropriate origin and data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That message is sent to the Gateway service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verification of any service-level data changes is performed, possibly after
    a delay to ensure that there's been time for the message to be delivered and acted
    upon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `handle_pending_messages` method of the appropriate application mock-up
    class is called to read and process the incoming message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing of the expected results is performed—new local data created for creation
    transactions, changes to existing data for update transactions, and the removal
    of existing data for deletion transactions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This entire process—the creation of code that simulates a more complex system
    or object for testing purposes—is called **Mocking**. Mocking allows tests to
    be written without having to rely on actual (and often far more complex) real
    code implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for products and orders, for the most part, can follow similar patterns.
    The primary differences will, of course, be in what object types are being created
    and manipulated, and in what various roles are allowed to do to those objects,
    according to the business rules for each role/operation combination. Additional
    tests may need to be defined to specifically target certain operations—artisans
    fulfilling part of an order, for example, which is fundamentally just an update
    operation. However, this should only alter item fulfilment data, and not all of
    that data at that. Even so, this will almost certainly follow similar test processes
    and  structures to those outlined here.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A mainstay of many iterative development processes is the requirement that
    the functionality of code can be demonstrated to stakeholders so that they have
    sufficient information to agree that requirements for a story have been met, or
    to point out any gaps in those requirements. Demonstration of a service poses
    some unique challenges to meeting that requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything that's happening is happening "behind the scenes" invisibly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much of what is happening happens so quickly that there simply isn't time to
    see the interim steps that lead to the final results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The odds are good that there won't be any sort of user interface associated,
    or that even if there is one, that it will provide enough visibility into the
    processes to demonstrate them in enough detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, as is the case of the Gateway service, there are also external systems—databases,
    message queue services, and so on, that need to be available to the code being
    run for a demonstration process to actually run successfully. Preparation for
    demonstration needs to take that into account, and have running instances of any
    needed external services available, obviously. In this case, since development
    and testing already relies on those same services being available, this is a non-issue,
    provided that a code demo can be run from a development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process tests that have been implemented can be executed to demonstrate
    that the code is behaving in a predictable fashion, and this a good item to be
    demonstrated, but it does nothing to address our initial concerns. A very basic
    approach to show the inner workings of the various processes would be to write
    a demonstration script that performs the same tasks that occur in the final code,
    in whatever logical or required order is needed, but in user controllable chunks,
    with displays of relevant data when and as needed. It''s a brute-force, bare-bones
    approach, but makes the steps in the processes visible (addressing the first concern),
    and executes each step when a user says to (addressing the second concern). In
    effect, it''s solving the first two concerns by creating a user interface to that
    specific purpose. Though the full demo script is too long to reproduce here, it
    will largely look like the process tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The configuration of various items, like the data store that the demo process
    will use or the message queue, would need to be provided at about this point in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the unit tests for the entire service live in a package structure (that
    mirrors the structure of the real code), the entire unit test suite can be imported,
    and a function can be written to execute them on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The demonstrations of each data transaction process can also be wrapped in
    individual functions in the demo module. With the exception of new code to display
    information as the demo is running, and to prompt whoever is running the demo
    to allow it to continue, they will look very much like the corresponding process
    test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for creating an `Artisan` test object to work with is nearly identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the demo will need to show the initial state of the `new_artisan` object
    before the transmission of its create message to show that the data persisted
    as expected, some simple, brute-force output of the object''s `data-dict` is in
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the message, and sending it, looks almost identical, apart from the
    `queue_id` that''s used to identify which queue it gets sent through. It also
    has the same `time.sleep` delay as the corresponding process test, for the same
    reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The display of the results is essentially the same code used to display the
    `initial_state` that we saw previously; it''s just using the `data-dict` of the
    retrieved, database-persisted instance instead of the original instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since showing the original and persisted data is one logical grouping, the
    script waits for input from the user before continuing with the next step of the
    demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting aside the remaining items in this demo function, and all of the other
    demo functions that would likely be needed, the entire demo script can be executed
    by simply calling each demo function if the module is executed directly (`if __name__
    == ''__main__'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output with just this first segment of the first demo method in place can
    already be used to show that data persistence is accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37671549-83a1-418f-9920-933c19a15f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps that follow for this first demo function will be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the execution with data displays of before and after whatever changes
    are made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying what data changes are being made when applicable, so that there is
    visibility into those changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating expected failure cases, such as invalid message data or signatures,
    and any role-based variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will almost certainly be enough similarity between what the process test
    methods are proving (and executing) and the demonstrations of those same processes
    that the test methods will supply most of the code needed for all of the demo
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and deploying the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the `hms_Gateway` and `hms_core` projects each have their own `setup.py` file,
    the packaging and deployment process doesn''t need to be any more complicated
    than doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing each `setup.py` to generate the installable package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving those package files to the server that is going to run the Gateway service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing them with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install HMS-Core-0.1.dev0.tar.gz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install HMS-Gateway-0.1.dev0.tar.gz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, for new installations, the configuration file at the necessary location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration needed to allow the Gateway daemon to start up automatically
    on system boot and shutdown with a system shutdown will vary based on the OS of
    the target machine (more on that in a bit).
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, there is a need for a single package, consolidating the
    `src` directories from all of the relevant projects will need to be undertaken
    as part of the packaging process. That can be accomplished, if it's not available
    through some combination of the normal `setuptools.setup` function's arguments,
    with a `Makefile` and a minor change to the `setup.py` that's in place in the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the inclusion of source code outside a project's main source directory
    has, in the author's experience, had sporadic issues with earlier versions of
    Python and/or the `setuptools` package. If those issues are resolved in the current
    version, then it may possible to use the `package_dir` argument of `setuptools.setup`,
    possibly in combination with the `setuptools.find_package` function to instruct
    the main `setup` function where you can find other package source trees outside
    the current project. The `Makefile` approach described here is not as elegant,
    and can have other (generally minor) issues, but works all the time with only
    basic `setup.py` functionality/requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant change to the `setup.py` file is simple, requiring only the addition
    of the `hms_core` package name to the list of packages to include in the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `setup.py` doesn''t care where it''s being run from, a simple brute-force
    solution to gather all of the relevant source code into a single location as a
    `Makefile` target might start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Step-by-step, all the target is actually doing is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a temporary build directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the entire package directory from each project into that directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping into the directory and executing a typical `setup.py` run (with the
    modified `setup.py` file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sure that a directory exists on the filesystem that the final package
    files can be moved to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the newly created package files to that directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the temporary build directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final output of the combined `Makefile`/`setup.py` process would be a single
    package file, `HMS-Gateway-0.1.dev0.tar.gz`, that includes both the `hms_Gateway`
    and `hms_core` package directories, ready for installation with `pip install HMS-Gateway-0.1.dev0.tar.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: Common considerations across all operating systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No matter what operating system the Gateway service daemon is running under,
    it will require a full configuration file, at a known location, that stores all
    of the settings that the service will need to know about when it starts up. The
    basic, Linux-flavored version of this configuration file (living in `/etc/hms/hms_Gateway.conf`
    on the target machine the service is running on) looks very much like the bare-bones
    example used in the *Message-Queue implementation with RabbitMQ* section of [Chapter
    16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The Artisan Gateway Service*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This config file is intentionally not part of the packaging process—otherwise,
    every time an update was installed, there would be some risk of overwriting an
    existing and operational configuration. Once the final configuration is in place,
    it should not need to be modified under any reasonably normal circumstances. The
    only difference between the Linux version of the configuration file and one that
    would be used on a Windows server is the log file path (`logging:file:logfile`),
    which would need to be pointed at a Windows filesystem path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service management options that we''ll examine, under both Windows and
    Linux operating systems, allow a simple command-line execution to start the service
    daemon. Older Linux service management might require a separate, freestanding
    script in Bash or Python to bridge between the operating system''s core functionality
    and the user''s and system''s interaction with it. With the advent of these more
    modern options, though, we can launch the service daemon on a production system
    in much the same way it was launched for testing during its development, by adding
    a few lines of code to the end of `hms_Gateway/daemons.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When a Python module is directly executed by the Python interpreter—`python
    -m hms_Gateway.daemons`, for example, or `python /path/to/hms_Gateway/daemons.py`—the
    `if __name__ == '__main__'` condition will evaluate to `True`, and the code within
    that `if` statement will be executed. In this case, it creates an instance of
    `ArtisanGatewayDaemon`, passing the hard-coded config file path, then calling
    the `start` method of the `daemon` object, starting the service.
  prefs: []
  type: TYPE_NORMAL
- en: Linux (systemd) execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a reasonably recent Linux system, service management is handled by another
    service: `systemd`. Configuration is needed for `systemd` to know when and how
    to launch the service daemon, how to shut it down, and how to restart it, along
    with some additional information that is used to determine when the service starts
    during the system''s boot process. A bare-bones starting point `systemd` configuration
    file for the Gateway service would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the roles for he mentioned keywords are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Description` is a simple description of the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`After` indicates an operational state target that should be completely established
    before launching the service daemon—in this case, since the Gateway service requires
    network access, we are indicating that it should start after the network online
    target is complete, expecting that all network functionality will be available
    at that point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecStart` is a command that can be executed by the OS to start the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecStop` is a command that will be used to stop the service—in this case,
    using the `pkill` OS utility to find (`-f`) and kill any processes that match
    the `hms_Gateway.daemons` string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Restart` allows `systemd` to automatically restart the service if it dies
    unexpectedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WantedBy` is an OS state indicator that, in this case, defines under what
    circumstances the service daemon should launch—when a (standard) multi-user-capable
    run-level is reached, typical of a command-line only server system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once both of these configuration files are in place, the Gateway service should
    start automatically after the system boots up, shut down cleanly if the system
    is shut down, and can be manually started, stopped, and restarted with the following
    standard commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl start hms_Gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl stop hms_Gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl restart hms_Gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows (NSSM) execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the Gateway service on a Windows machine requires some middleware to
    create a service-compatible wrapper around the Python code that's going to be
    executed. One of the more popular and stable middleware options is the **Non-Sucking
    Service Manager** (**NSSM**). NSSM provides a GUI for creating, installing, and
    managing services that are written in a variety of languages—in general, if a
    program can be run from a command line, NSSM can almost certainly get it running
    as a Windows service.
  prefs: []
  type: TYPE_NORMAL
- en: 'NSSM may need to be run with administrative privileges, but in any event, is
    launched from the command line—`C:\path\to\nssm.exe install` launches the GUI,
    and all of the settings needed are present under one of the tabs. The application
    tab defines the Path to the program to be executed (`python.exe`, in our case)
    with whatever Arguments are needed (the Python script to run), as well as a Service
    name, which is used to identify the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2511b31c-b2d7-4555-8ff5-195fc4a1526c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If an existing NSSM-managed service needs to be modified, it can be accessed
    by executing the NSSM program and specifying the Service name in the command:
    `C:\path\to\nssm.exe install hms_Gateway`, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Details tab allows a Display name and Description to be provided, which
    will appear in the Windows Service Administration interface. It also allows for
    the control of the Startup type: whether the service starts automatically, or
    under other circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8a9ad1c7-af32-4fd0-8f53-97d68e443fd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the Install Service button is clicked, it's done—the new service, wrapped
    and manageable by NSSM, is available in the Windows Services administrator!
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, what might be called the "functional foundations" of `hms_sys`
    are pretty complete: all of the data flows that are expected have been accounted
    for, and if there are restrictions mandated by the business rules that aren''t
    implemented in the business logic, there is at least enough support for making
    the decisions related to them quick and easy to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still haven''t actually closed most of the stories that the iteration started
    with, though, in retrospect, those were written with goals that were too broad
    for them to be closed without UI development. Had they been broken out into two
    stories (or more) each, one of each set, focusing on the end-user goals and needs
    would look pretty much the same:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan Manager, I need to be able to create `Artisan` objects in a GUI
    so that I can manage artisans quickly and easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects in a GUI
    so that I can manage artisans quickly and easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these would have a corresponding story that focuses more on assuring
    that there would be some code, some functionality that the GUI-related stories
    could start with, and build upon. Those would probably have looked something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: As
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a UI developer, I need a mechanism to send create Artisan messages to the Gateway
    service so that I can create a UI to execute that process
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: As a UI developer, I need a mechanism to send delete Artisan messages to the
    Gateway service so that I can create a UI to execute that process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternately, if each of the original stories' development processes had taken
    the approach of making sure that the entire process for each end user action,
    from GUI to service to database to (where applicable) amother user application,
    had tasks associated with it, that would have allowed the stories as they were
    originally written to be completed in their entirety.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of gap, in a real-world situation, would have been addressed as part
    of grooming the stories, before they were even put into an active iteration. Story
    grooming is a development team activity, where incoming stories are examined,
    fleshed out, and (when necessary) tweaked with the help of any stakeholders to
    assure that they can be accomplished. Part of this process involves reviewing
    stories and their attendant tasks to assure that everything needed for the story
    to be worked to completion is accounted for. A review of that nature would almost
    certainly have revealed that either the stories, as originally presented here,
    had tasks that represented everything the story needed, or that splitting the
    original stories into UI and mechanism stories was necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, a few stories from the original set feel like they can be closed, barring
    tweaks that might surface during the demonstration and review:'
  prefs: []
  type: TYPE_NORMAL
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As any user sending messages across to or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where hms_sys development could go from here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's still a substantial amount of work needed for `hms_sys` to be *truly*
    complete, but all of the design, development, and process principles that needed
    to be exposed have been at this point, so this feels like a good point to break
    away from it and move on to other things. Before moving on, though, there are
    some easily identified items that could be picked up and worked on.
  prefs: []
  type: TYPE_NORMAL
- en: Code review, refactoring, and cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are at least a couple of items in the code as it stands right now that
    could be reviewed and remedied.
  prefs: []
  type: TYPE_NORMAL
- en: So far, there's been no call for any request-response process that would need
    to simply return any of the data objects. There are, however, methods that were
    stubbed out to address those potential needs (the various `response_{object}` methods
    in `ArtisanGatewayDaemon`), even though the needs themselves never surfaced. While
    it doesn't hurt to leave them in place, that would, ultimately, entail having
    test case classes and/or test methods that are required by the testing policy
    that don't really serve any purpose. The methods being tested don't do anything,
    and aren't expected to in the foreseeable future. At a minimum, these methods
    and any tests associated with them should probably be commented out, but they
    could even be completely removed, keeping the code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Since distinct classes were created for orders in both the Artisan and Central
    Office contexts, taking some time to winnow out their common functionality and
    interface, and re-define the `BaseOrder` class in `hms_core` would clean the codebases
    up a bit too. That would also entail reworking the relevant unit tests, and might
    (probably trivially) touch other classes that use the current `Order` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of Central Office classes in `hms_core`, while an understandable
    decision at the time, could present a small data integrity risk on a longer term
    basis: as members of `hms_core`, they would, at present, be distributed as part
    of an Artisan application (which depends on `hms_core`), and would be available
    to a disgruntled Artisan, if that were ever to occur. Though the risk is probably
    trivial, it''s certainly not an impossible scenario, and there''s really no reason
    why an Artisan application should have any code that''s intended for use only
    by Central Office staff. Re-organizing those items into a separate project/module,
    or altering the build/packaging process to actively remove that module from the
    Artisan application''s codebase, feels like a good idea, eliminating any concerns
    that might arise about deploying code to users who wouldn''t/shouldn''t use it.'
  prefs: []
  type: TYPE_NORMAL
- en: A similar reorganization effort may be needed later on with respect to where
    the `daemons.py` module lives, and how it's used. At this point, we don't really
    have a design for the end user applications–just a collection of functional requirements
    that have been implemented at a fundamental level, and so there's no real feeling
    for how the applications themselves will function. It's possible that the design
    would involve a local service, even if it's only running while the main application
    is active, in which case keeping `daemons.py` in the `hms_core` namespace makes
    sense. If, on the other hand, the end-user applications don't use such a service,
    then there's no reason to deploy the relevant code in either of the end-user applications
    and moving it into its own deployable package, or into a separate but dependent
    project would not a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least a few unit tests (the ones testing the various `to_data_dict`
    methods are probably the most obvious ones) that, because of the way the test
    arguments are used in deeply nested loops, will, over time, take longer and longer
    to execute. As things stand right now, there are as many as a dozen value variations
    that are (or could be) tested, and only a few values being used per variation.
    With three values per variation, and 12 variations to test, each of which lives
    in its own loop, that's 3^(12)—over half a million—assertions that would be executed
    on every execution of that test method. This takes time to execute. Reworking
    the various nested loop test methods so that each value variant is tested individually,
    un-nesting the loops, would speed up test execution significantly—there would
    be 36 (3 × 12) assertions instead of the half-million needed now. The trade-off
    is that the test code will be substantially longer, and potentially (slightly)
    more difficult to maintain as a result, but the time saved in the long run will
    be worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are literally dozens of GUI options available for Python applications,
    even if the list is limited to those that are usable on more than one OS/platform—a
    list is maintained on the Python website at [https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming).
    The more widely used are sufficiently feature-rich, and whole books could be written
    about each of them. Noteworthy GUI frameworks and toolkits include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter:** Distributed as part of Python installations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyGObject: **A GUI used for many Linux/Gnome applications, related to GnomePython
    and PyGTK ([https://pygobject.readthedocs.io/en/latest/](https://pygobject.readthedocs.io/en/latest/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kivy: **This includes support for Android and iOS (iPhone) applications ([https://kivy.org/](https://kivy.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tkinter** is the *de facto* standard for Python application GUIs, and has
    shipped with Python distributions for a long time. While the GUI elements it provides
    are, in many respects, quite basic, it provides enough of them for a wide range
    of application needs to be met. As one of the more mature options, there is a
    lot of documentation available for it (see [https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)),
    and it is quite stable. There are also a fair number of extension packages available
    that likely address needs that a baseline Tkinter installation may not fulfil,
    including **Python Mega****widgets** (**PMW**—[http://pmw.sourceforge.net/doc/](http://pmw.sourceforge.net/doc/)).
    While Tkinter GUIs may not be the most attractive in the world—their appearance
    is tightly bound to the GUI engine of the underlying OS, with all the variations
    that entails—they are *eminently* functional.'
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter doesn't have complex dependencies, making it extremely portable; a given
    Tkinter GUI will function without alteration on any OS, and simple tweaks based
    on the detection of which OS is present are generally not difficult, though they
    may require significant planning ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever worked on a Linux system that has a Gnome frontend, the odds
    are good that you've been exposed to a **PyGObject**-based GUI, whether you knew
    it or not. Although it's part of the open source Gnome Project, and thus perhaps
    more focused on fulfilling needs for various Linux systems, PyGObject is a viable
    option on Windows and Macintosh systems as well. Like most of the GUI frameworks
    available for Python, PyGObject does involve at least some additional software
    installation, and there may be extensive dependencies involved, even if they aren't
    directly visible, but those should be managed by the installation process of PyGObject
    itself. PyGObject assumes at least some control over widget appearance, taking
    that control away from the underlying GUI engine of the OS in order to provide
    a more attractive appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kivy** is a popular option, and is often cited as the go-to GUI framework
    for Python applications needing mobile technology support (Android and iOS applications).
    Judging by several of the entries in their gallery page ([https://kivy.org/#gallery](https://kivy.org/#gallery)),
    it can provide very clean and attractive GUIs. Kivy uses its own design language
    to define how a GUI is laid out, and what the elements look like. Mobile application
    support through Kivy is accomplished by bundling a complete Python installation
    with each Android `apk` or iOS `app` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option, though it might sound odd at first, would be to implement the
    Artisan and Central Office applications as local web servers, and use HTML, CSS,
    and JavaScript to create the GUI. This isn''t as far-fetched as it might sound:
    Python includes a variety of web server classes in the `http.server` module ([https://docs.python.org/3.6/library/http.server.html](https://docs.python.org/3.6/library/http.server.html)),
    and even if none of them were ready to use as-is, they could be extended to provide
    whatever functionality was lacking. Though the servers provided might not be as
    powerful or feature-rich as a dedicated web server (Apache or IIS), they wouldn''t
    really need to be, since there would be only a handful of users accessing it at
    any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: Order fulfilment and shipping APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic data changes involved in the order fulfilment process that an Artisan
    would execute are reasonably detailed and understood, but there is certainly room
    for improvement. One feature that would be very nice to have would be integration
    with online APIs for the various shipping companies that would be used to deliver
    those fulfilled order items. That integration, depending on the shape of all the
    requirements around it, could be a major development effort all by itself, and
    could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing an Artisan user to provide a package  or shipping ID during transactions
    for both individual and multiple item fulfilment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a confirmation email (if the APIs don't handle that on their own) to
    the customer with shipment tracking information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending some sort of notification to the Central Office that order items have
    been fulfilled, which would be a trigger for whatever manual or automatic process
    which pays the Artisan for the items shipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over and above that, there would be definitions needed for the various shipper
    APIs (since it's unlikely that any two of them will use the exact same request
    structure) and testing strategies and implementations for them, quite possibly
    with extensive mocking, if the APIs themselves don't provide any test harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing of services, particularly in a repeatable fashion that can be used
    as ongoing regression testing, has its own particular challenges, but none of
    them is insurmountable. The methods presented here are a solid starting point,
    and could be elaborated on in as much detail as required to meet almost any testing
    requirements. That said, these are reasonably complete, and easily managed/maintained
    should new testing requirements surface, whether through the discovery and correction
    of bugs, or the advent of new functional requirements that have to be reflected
    in tests.
  prefs: []
  type: TYPE_NORMAL
