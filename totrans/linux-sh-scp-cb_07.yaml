- en: Chapter 7. The Old-boy Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic networking primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's ping!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all the machines alive on a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files through network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an Ethernet and wireless LAN with script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-less auto-login with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running commands on remote host with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting remote drive at local mount point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-casting window messages on a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network traffic and port analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is the act of interconnecting machines through a network and configuring
    the nodes in the network with different specifications. We use TCP/IP as our networking
    stack and all operations are based on it. Networks are an important part of every
    computer system. Each node connected in the network is assigned a unique IP address
    for identification. There are many parameters in networking, such as subnet mask,
    route, ports, DNS, and so on, which require a basic understanding to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Several applications that make use of a network operate by opening and connecting
    to firewall ports. Every application may offer services such as data transfer,
    remote shell login, and so on. Several interesting management tasks can be performed
    on a network consisting of many machines. Shell scripts can be used to configure
    the nodes in a network, test the availability of machines, automate execution
    of commands at remote hosts, and so on. This chapter focuses on different recipes
    that introduce interesting tools or commands related to networking and also how
    they can be used for solving different problems.
  prefs: []
  type: TYPE_NORMAL
- en: Basic networking primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before digging through recipes based on networking, it is essential for you
    to have a basic understanding of setting up a network, the terminology and commands
    for assigning an IP address, adding routes, and so on. This recipe will give an
    overview of different commands used in GNU/Linux for networking and their usages
    from the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every node in a network requires many parameters to be assigned to work successfully
    and interconnect with other machines. Some of the different parameters are the
    IP address, subnet mask, gateway, route, DNS, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will introduce commands `ifconfig`, `route`, `nslookup`, and `host`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network interfaces are used to connect to a network. Usually, in the context
    of UNIX-like Operating Systems, network interfaces follow the eth0, eth1 naming
    convention. Also, other interfaces, such as usb0, wlan0, and so on, are available
    for USB network interfaces, wireless LAN, and other such networks.
  prefs: []
  type: TYPE_NORMAL
- en: '`ifconfig` is the command that is used to display details about network interfaces,
    subnet mask, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ifconfig` is available at `/sbin/ifconfig`. Some GNU/Linux distributions will
    display an error "command not found" when `ifconfig` is typed. This is because
    `/sbin` in not included in the user''s PATH environment variable. When a command
    is typed, the Bash looks in the directories specified in PATH variable.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, in Debian, `ifconfig` is not available since `/sbin` is not in PATH.
  prefs: []
  type: TYPE_NORMAL
- en: '`/sbin/ifconfig` is the absolute path, so try `run ifconfig` with the absolute
    path (that is, `/sbin/ifconfig`). For every system, there will be a by default
    interface ''lo'' called loopback that points to the current machine. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The left-most column in the `ifconfig` output lists the name of network interfaces
    and the right-hand columns show the details related to the corresponding network
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several additional commands that frequently come under usage for querying
    and configuring the network. Let's go through the essential commands and usage.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the list of network interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a one-liner command sequence to print the list of network interface
    available on a system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first 10 characters of each line in the `ifconfig` output is reserved for
    writing the name of the network interface. Hence we use `cut` to extract the first
    10 characters of each line. `tr -d ' '` deletes every space character in each
    line. Now the `\n` newline character is squeezed using `tr -s '\n'` to produce
    a list of interface names.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning and displaying IP addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ifconfig` command displays details of every network interface available
    on the system. However, we can restrict it to a specific interface by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the outputs of the previously mentioned command, our interests lie in
    the IP address, broadcast address, hardware address, and subnet mask. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HWaddr 00:1c:bf:87:25:d2` is the hardware address (MAC address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inet addr:192.168.0.82` is the IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bcast:192.168.3.255` is the broadcast address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mask:255.255.252.0` is the subnet mask'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In several scripting contexts, we may need to extract any of these addresses
    from the script for further manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the IP address is a common task. In order to extract the IP address
    from the `ifconfig` output use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here the first command `egrep -o "inet addr:[^ ]*"` will print `inet addr:192.168.0.82`.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern starts with `inet addr:` and ends with some non-space character
    sequence (specified by `[^ ]*`). Now in the next pipe, it prints the character
    combination of digits and '.'.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set the IP address for a network interface, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will need to run the above command as root. `192.168.0.80` is the address
    to be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the subnet mask along with IP address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Spoofing Hardware Address (MAC Address)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In certain circumstances where authentication or filtering of computers on a
    network is provided by using the hardware address, we can use hardware address
    spoofing. The hardware address appears in `ifconfig` output as `HWaddr 00:1c:bf:87:25:d2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can spoof the hardware address at the software level as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the above command, `00:1c:bf:87:25:d5` is the new MAC address to be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful when we need to access the Internet through MAC authenticated
    service providers that provide access to the Internet for a single machine.
  prefs: []
  type: TYPE_NORMAL
- en: Name server and DNS (Domain Name Service)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The elementary addressing scheme for the Internet is IP addresses (dotted decimal
    form, for example, `202.11.32.75`). However, the resources on the Internet (for
    example, websites) are accessed through a combination of ASCII characters called
    URLs or domain names. For example, [google.com](http://google.com) is a domain
    name. It actually corresponds to an IP address. Typing the IP address in the browser
    can also access the URL `www.google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of abstracting IP addresses with symbolic names is called **Domain**
    **Name** **Service** (**DNS**). When we enter `google.com`, the DNS servers configured
    with our network resolve the domain name into the corresponding IP address. While
    on a local network, we setup the local DNS for naming local machines on the network
    symbolically using their hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name servers assigned to the current system can be viewed by reading `/etc/resolv.conf`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add name servers manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How can we obtain the IP address for a corresponding domain name?
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest method to obtain an IP address is by trying to ping the given domain
    name and looking at the echo reply. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A domain name can have multiple IP addresses assigned. In that case, the DNS
    server will return one address among the list of IP addresses. To obtain all the
    addresses assigned to the domain name, we should use a DNS lookup utility.
  prefs: []
  type: TYPE_NORMAL
- en: DNS lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are different DNS lookup utilities available from the command line. These
    will request a DNS server for an IP address resolution. `host` and `nslookup`
    are two DNS lookup utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `host` is executed it will list out all of the IP addressed attached to
    the domain name. `nslookup` is another command that is similar to `host`, which
    can be used to query details related to DNS and resolving of names. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It may also list out DNS resource records like MX (Mail Exchanger) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last line above corresponds to the default nameserver used for DNS resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Without using the DNS server, it is possible to add a symbolic name to IP address
    resolution just by adding entries into file `/etc/hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add an entry, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After adding this entry, whenever a resolution to `backupserver.com` occurs,
    it will resolve to `192.168.0.9`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default gateway, showing routing table information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a local network is connected to another network, it needs to assign some
    machine or network node through which an interconnection takes place. Hence the
    IP packets with a destination exterior to the local network should be forwarded
    to the node machine, which is interconnected to the external network. This special
    node machine, which is capable of forwarding packets to the external network,
    is called a gateway. We set the gateway for every node to make it possible to
    connect to an external network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operating system maintains a table called the routing table, which contains
    information on how packets are to be forwarded and through which machine node
    in the network. The routing table can be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using `-n` specifies to display the numerical addresses. When `-n` is used it
    will display every entry with a numerical IP addresses, else it will show symbolic
    host names instead of IP addresses under the DNS entries for IP addresses that
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'A default gateway is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Traceroute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an application requests a service through the Internet, the server may
    be at a distant location and connected through any number of gateways or device
    nodes. The packets travel through several gateways and reach the destination.
    There is an interesting command `traceroute` that displays the address of all
    intermediate gateways through which the packet travelled to reach the destination.
    `traceroute` information helps us to understand how many hops each packet should
    take in order reach the destination. The number of intermediate gateways or routers
    gives a metric to measure the distance between two nodes connected in a large
    network. An example of the output from `traceroute` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Playing with variables and environment variables* of[Chapter 1](ch01.html
    "Chapter 1. Shell Something Out"), explains the PATH variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Searching and mining "text" inside a file with grep* of[Chapter 4](ch04.html
    "Chapter 4. Texting and Driving"), explains the grep command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's ping!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ping` is the most basic network command, and one that every user should first
    know. It is a universal command that is available on major Operating Systems.
    It is also a diagnostic tool used for verifying the connectivity between two hosts
    on a network. It can be used to find out which machines are alive on a network.
    Let us see how to use ping.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to check the connectivity of two hosts on a network, the `ping` command
    uses **Internet** **Control** **Message** **Protocol** (**ICMP**) echo packets.
    When these echo packets are sent towards a host, the host responds back with a
    reply if it is reachable or alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether a host is reachable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ADDRESS` can be a hostname, domain name, or an IP address itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`ping` will continuously send packets and the reply information is printed
    on the terminal. Stop the pinging by pressing *Ctrl* + *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the host is reachable the output will be similar to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When a host is unreachable the output will be similar to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once the host is not reachable, the ping returns a `Destination Host Unreachable`
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to checking the connectivity between two points in a network, the
    `ping` command can be used with additional options to get useful information.
    Let's go through the additional options of `ping`.
  prefs: []
  type: TYPE_NORMAL
- en: Round trip time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ping` command can be used to find out the **Round** **Trip** **Time**
    (**RTT**) between two hosts on a network. RTT is the time required for the packet
    to reach the destination host and come back to the source host. The RTT in milliseconds
    can be obtained from ping. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here the minimum RTT is 118.012ms, the average RTT is 206.630ms, and the maximum
    RTT is 347.186ms. The `mdev` (77.713ms) parameter in the `ping` output stands
    for mean deviation.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting number of packets to be sent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ping` command sends echo packets and waits for the reply of `echo` indefinitely
    until it is stopped by pressing *Ctrl* + *C*. However, we can limit the count
    of echo packets to be sent by using the `-c` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `ping` command sends two echo packets and stops.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when we need to ping multiple machines from a list of IP addresses
    through a script and checks its statuses.
  prefs: []
  type: TYPE_NORMAL
- en: Return status of ping command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ping` command returns exit status 0 when it succeeds and returns non-zero
    when it fails. Successful means, destination host is reachable, where failure
    is when destination host is unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return status can be easily obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Listing all the machines alive on a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we deal with a large local area network, we may need to check the availability
    of other machines in the network, whether alive or not. A machine may not be alive
    in two conditions: either it is not powered on or due to a problem in the network.
    By using shell scripting, we can easily find out and report which machines are
    alive on the network. Let''s see how to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use two methods. The first method uses `ping` and the second
    method uses `fping`. `fping` doesn't come with a Linux distribution by default.
    You may have to manually install `fping` using a package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through the script to find out all the live machines on the network
    and alternate methods to find out the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 1:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can write our own script using the `ping` command to query list of IP addresses
    and check whether they are alive or not as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Method 2:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use an existing command-line utility to query the status of machines
    on a network as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Method 1, we used the `ping` command to find out the alive machines on the
    network. We used a `for` loop for iterating through the list of IP addresses.
    The list is generated as `192.168.0.{1..255}`. The `{start..end}` notation will
    expand and will generate a list of IP addresses, such as `192.168.0.1`, `192.168.0.2`,
    `192.168.0.3` till `192.168.0.255`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ping $ip -c 2 &> /dev/null` will run a `ping` to the corresponding IP address
    in each execution of loop. `-c 2` is used to restrict the number of echo packets
    to be sent to two packets. `&> /dev/null` is used to redirect both `stderr` and
    `stdout` to `/dev/null` so that it won''t be printed on the terminal. Using `$?`
    we evaluate the exit status. If it is successful, the exit status is 0 else non-zero.
    Hence the successful IP addresses are printed. We can also print the list of unsuccessful
    IP addresses to give the list of unreachable IP addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is an exercise for you. Instead of using a range of IP addresses hard-coded
    in the script, modify the script to read a list of IP addresses from a file or
    `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, each ping is executed one after the other. Even though all the
    IP addresses are independent each other, the `ping` command is executed due to
    a sequential program, it takes a delay of sending two echo packets and receiving
    them or the timeout for a reply for executing the next `ping` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to 255 addresses, the delay is large. Let''s run all the `ping`
    commands in parallel to make it much faster. The core part of the script is the
    loop body. To make the `ping` commands in parallel, enclose the loop body in `(
    )&`. `( )` encloses a block of commands to run as the sub-shell and `&` sends
    it to the background by leaving the current thread. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop body executes many background process and it comes out of the
    loop and it terminates the script. In order to present the script to terminate
    until all its child process end, we have a command called `wait`. Place a `wait`
    at the end of the script so that it waits for the time until all the child `(
    )` subshell processes complete.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `wait` command enables a script to be terminated only after all its child
    process or background processes terminate or complete.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at `fast_ping.sh` from the code provided with the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 2 uses a different command called `fping`. It can ping a list of IP
    addresses simultaneously and respond very quickly. The options available with
    `fping` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-a` option with `fping` specifies to print all alive machine's IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-u` option with `fping` specifies to print all unreachable machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-g` option specifies to generate a range of IP addresses from slash-subnet
    mask notation specified as IP/mask or start and end IP addresses as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`2>/dev/null` is used to dump error messages printed due to unreachable host
    to a null device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to manually specify a list of IP addresses as command-line
    arguments or as a list through `stdin`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fping` command can be used for querying DNS data from a network. Let's
    see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: DNS lookup with fping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fping` has an option `-d` that returns host names by using DNS lookup for
    each echo reply. It will print out host names rather than IP addresses on ping
    replies.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Playing with file descriptors and redirection* of[Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains the data redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparisons and tests* of[Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains numeric comparisons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major purpose of the networking of computers is for resource sharing. Among
    resource sharing, the most prominent use is in file sharing. There are different
    methods by which we can transfer files between different nodes on a network. This
    recipe discusses how to transfer files using commonly used protocols FTP, SFTP,
    RSYNC, and SCP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The commands for performing file transfer over the network are mostly available
    by default with Linux installations. Files via FTP can be transferred by using
    the `lftp` command. Files via a SSH connection can be transferred by using `sftp`,
    RSYNC using SSH with `rsync` command and transfer through SSH using `scp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**) is an old file transfer protocol for transferring
    files between machines on a network. We can use the command `lftp` for accessing
    FTP enabled servers for file transfer. It uses Port 21\. FTP can only be used
    if an FTP server is installed on the remote machine. FTP is used by many public
    websites to share files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to an FTP server and transfer files in between, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it will prompt for a password and then display a logged in prompt as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can type commands in this prompt. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: To change to a directory, use `cd directory`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change directory of local machine, use `lcd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a directory use `mkdir`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To download a file, use `get filename` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To upload a file from the current directory, use `put filename` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: An `lftp` session can be exited by using the `quit` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto completion is supported in the `lftp` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through some additional techniques and commands used for file transfer
    through a network.
  prefs: []
  type: TYPE_NORMAL
- en: Automated FTP transfer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ftp` is another command used for FTP-based file transfer. `lftp` is more flexible
    for usage. `lftp` and the `ftp` command open an interactive session with user
    (it prompts for user input by displaying messages). What if we want to automate
    a file transfer instead of using the interactive mode? We can automate FTP file
    transfers by writing a shell script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The above script has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is used to send data through `stdin` to the FTP command. The recipe, *Playing
    with file descriptors and redirection* in[Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains various methods for redirection into `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-i` option of `ftp` turns off the interactive session with user. `user
    ${USER} ${PASSWD}` sets the username and password. `binary` sets the file mode
    to binary.
  prefs: []
  type: TYPE_NORMAL
- en: SFTP (Secure FTP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SFTP is an FTP-like file transfer system that runs on top of an SSH connection.
    It makes use of an SSH connection to emulate an FTP interface. It doesn't require
    an FTP server at the remote end to perform file transfer but it requires an OpenSSH
    server to be installed and running. It is an interactive command, which offers
    an `sftp` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands are used to perform the file transfer. All other commands
    remain same for every automated FTP session with specific HOST, USER, and PASSWD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run `sftp`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `lftp`, an `sftp` session can be exited by typing the `quit` command.
  prefs: []
  type: TYPE_NORMAL
- en: The SSH server sometimes will not be running at the default Port 22\. If it
    is running at a different port, we can specify the port along with `sftp` as `-oPort=PORTNO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-oPort` should be the first argument of the `sftp` command.'
  prefs: []
  type: TYPE_NORMAL
- en: RSYNC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: rsync is an important command-line utility that is widely used for copying files
    over networks and for taking backup snapshots. This is better explained in separate
    recipe, *Backup snapshots with rsync*, that explains the usage of `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: SCP (Secure Copy)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SCP is a file copy technique which is more secure than the traditional remote
    copy tool called `rcp`. The files are transferred through an encrypted channel.
    SSH is used as an encryption channel. We can easily transfer files to a remote
    machine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will prompt for a password. It can be made password less by using autologin
    SSH technique. The recipe, *Password-less auto-login with SSH*, explains SSH autologin.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, file transfer using `scp` doesn't require specific scripting. Once
    SSH login is automated, the `scp` command can be executed without an interactive
    prompt for the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here `remotehost` can be IP address or domain name. The format of the `scp`
    command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`SOURCE` or `DESTINATION` can be in the format `username@localhost:/path` for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The above command copies a file from the remote host to the current directory
    with the given filename.
  prefs: []
  type: TYPE_NORMAL
- en: If SSH is running at a different port than 22, use `-oPort` with the same syntax
    as `sftp`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive copying with SCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using `scp` we can recursively copy a directory between two machines on
    a network as follows with the `-r` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`scp` can also copy files by preserving permissions and mode by using the `-p`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Playing with file descriptors and redirection* of[Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains the standard input using EOF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an Ethernet and wireless LAN with script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ethernet is simple to configure. Since it uses physical cables, there are
    no special requirements such as authentication. However, a wireless LAN requires
    authentication—for example, a WEP key as well as the ESSID of the wireless network
    to connect. Let's see how to connect to a wireless as well as a wired network
    by writing a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to a wired network, we need to assign an IP address and subnet mask
    by using the `ifconfig` utility. But for a wireless network connection, it will
    require additional utilities, such as `iwconfig` and `iwlist` , to configure more
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to connect to a network from a wired interface, execute the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The script for connecting to a wireless LAN with WEP is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The commands `ifconfig`, `iwconfig`, and `route` are to be run as root. Hence
    a check for the root user is performed at the beginning of the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethernet connection script is pretty straightforward and it uses the concepts
    explained in the recipe, *Basic networking primer*. Let's go through the commands
    used for connecting to the wireless LAN.
  prefs: []
  type: TYPE_NORMAL
- en: A wireless LAN requires some parameters such as the `essid`, `key`, and frequency
    to connect to the network. The `essid` is the name of the wireless network to
    which we need to connect. Some **Wired** **Equivalent** **Protocol** (**WEP**)
    networks use a WEP key for authentication, whereas some networks don't. The WEP
    key is usually a 10-letter hex passphrase. Next comes the frequency assigned to
    the network. `iwconfig` is the command used to attach the wireless card with the
    proper wireless network, WEP key, and frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can scan and list the available wireless network by using the utility `iwlist`.
    To scan, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `Frequency` parameter can be extracted from the scan result, from the line
    `Frequency:2.462 GHz (Channel 11)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Comparisons and tests* of[Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains string comparisons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-less auto-login with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH is widely used with automation scripting. By using SSH, it is possible to
    remotely execute commands at remote hosts and read their output. SSH is authenticated
    by using username and password. Passwords are prompted during the execution of
    SSH commands. But in automation scripts, SSH commands may be executed hundreds
    of times in a loop and hence providing passwords each time is impractical. Hence
    we need to automate logins. SSH has a built-in feature by which SSH can auto-login
    using SSH keys. This recipe describes how to create SSH keys and facilitate auto-login.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SSH uses public key-based and private key-based encryption techniques for
    automatic authentication. An authentication key has two elements: a public key
    and a private key pair. We can create an authentication key using the `ssh-keygen`
    command. For automating the authentication, the public key must be placed at the
    server (by appending the public key to the `~/.ssh/authorized_keys` file) and
    its private key file of the pair should be present at the `~/.ssh` directory of
    the user at client machine, which is the computer you are logging in from. Several
    configurations (for example, path and name of the `authorized_keys` file) regarding
    the SSH can be configured by altering the configuration file `/etc/ssh/sshd_config`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps towards the setup of automatic authentication with SSH.
    They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SSH key from the machine, which requires a login to a remote machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transferring the public key generated to the remote host and appending it to
    `~/.ssh/authorized_keys` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to create an SSH key, enter the `ssh-keygen` command with the encryption
    algorithm type specified as RSA as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You need to enter a passphrase for generating the public-private key pair. It
    is also possible to generate the key pair without entering a passphrase, but it
    is insecure. We can write monitoring scripts that use automated login from the
    script to several machines. In such cases, you should leave the passphrase empty
    while running the `ssh-keygen` command to prevent the script from asking for a
    passphrase while running.
  prefs: []
  type: TYPE_NORMAL
- en: Now `~/.ssh/id_rsa.pub` and `~/.ssh/id_rsa` has been generated. `id_dsa.pub`
    is the generated public key and `id_dsa` is the private key. The public key has
    to be appended to the `~/.ssh/authorized_keys` file on remote servers where we
    need to auto-login from the current host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to append a key file, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Provide the login password in the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The auto-login has been set up. From now on, SSH will not prompt for passwords
    during execution. You can test this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You will not be prompted for a password.
  prefs: []
  type: TYPE_NORMAL
- en: Running commands on remote host with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH is an interesting system administration tool that enables to control remote
    hosts by login with a shell. SSH stands for Secure Shell. Commands can be executed
    on the shell received by login to remote host as if we run commands on localhost.
    It runs the network data transfer over an encrypted tunnel. This recipe will introduce
    different ways in which commands can be executed on the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH doesn't come by default with all GNU/Linux distributions. Therefore, you
    may have to install the `openssh-server` and `openssh-client` packages using a
    package manager. SSH service runs by default on port number 22.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect to a remote host with the SSH server running, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username` is the user that exist at the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_host` can be domain name or IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It will interactively ask for a user password and upon successful authentication
    it will return the shell for the user.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the SSH server runs at Port 22\. But certain servers run the SSH
    service at different ports. In that case use `-p port_no` with the `ssh` command
    to specify the port.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect to an SSH server running at port 422, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can execute commands in the shell that corresponds to the remote host. Shell
    is an interactive tool in which a user types and runs commands. However, in shell
    scripting contexts, we do not need an interactive shell. We need to automate several
    tasks. We require to execute several commands at the remote shell and display
    or store its output at localhost. Issuing a password every time is not practical
    for an automated script, hence autologin for SSH should be configured.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe, *Password-less auto-login with SSH*, explains the SSH commands.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that auto-login is configured before running automated scripts that
    use SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a command on the remote host and display its output on the localhost
    shell, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple commands can be given by using semicolon delimiter in between the
    commands as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Commands can be sent through `stdin` and the output of the commands will be
    available to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `COMMANDS` string should be quoted in order to prevent a semicolon character
    to act as delimiter in the localhost shell. We can also pass any command sequence
    that involves piped statements to the SSH command through `stdin` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the commands executed on the remote host are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be generalized as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We can also pass a more complex subshell in the command sequence by using the
    `( )` subshell operator.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write an SSH based shell script that collects the uptime of a list of
    remote hosts. Uptime is the time for which the system is powered on. The `uptime`
    command is used to display how long the system has been powered on.
  prefs: []
  type: TYPE_NORMAL
- en: It is assumed that all systems in the `IP_LIST` have a common user `test`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ssh` command can be executed with several additional options. Let's go
    through them.
  prefs: []
  type: TYPE_NORMAL
- en: SSH with compression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SSH protocol also supports data transfer with compression, which comes
    in handy when bandwidth is an issue. Use the `-C` option with the `ssh` command
    to enable compression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting data into stdin of remote host shell commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we need to redirect some data into `stdin` of remote shell commands.
    Let''s see how to do it. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`cat >> list` appends the data received through `stdin` to the file list. Here
    this command is executed at the remote host. But the data is passed to `stdin`
    from localhost.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Password-less auto-login with SSH*, explains how to configure auto-login to
    execute commands without prompting for password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a remote drive at a local mount point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a local mount point to access remote host file-system would be really
    helpful while carrying out both read and write data transfer operations. SSH is
    the most common transfer protocol available in a network and hence we can make
    use of it with `sshfs`. `sshfs` enables you to mount a remote filesystem to a
    local mount point. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sshfs` doesn''t come by default with GNU/Linux distributions. Install `sshfs`
    by using a package manager. `sshfs` is an extension to the fuse file system package
    that allows supported OSes to mount a wide variety of data as if it were a local
    file system.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to mount a filesytem location at a remote host to a local mount point,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Issue the user password when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: Now data at `/home/path` on the remote host can be accessed via a local mount
    point `/mnt/mountpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to unmount after completing the work, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Running commands on remote host with SSH*, explains the ssh command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-casting window messages on a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The administrator of a network may often require to send messages to the nodes
    on the network. Displaying pop-up windows on the user's desktop would be helpful
    to alert the user with a piece of information. Using a GUI toolkit with shell
    scripting can achieve this task. This recipe discusses how to send a popup window
    with custom messages to remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For implementing a GUI pop window, zenity can be used. Zenity is a scriptable
    GUI toolkit for creating windows consisting of textbox, input box, and so on.
    SSH can be used for connecting to the remote shell on a remote host. Zenity doesn't
    come installed by default with GNU/Linux distributions. Use a package manager
    to install zenity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zenity is one of the scriptable dialog creation toolkit. There are other toolkits,
    such as gdialog, kdialog, xdialog, and so on. Zenity seems to be one flexible
    toolkit that is adherent to the GNOME Desktop Environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create an info box with zenity, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Zenity can be used to create windows with input box, combo input, radio button,
    pushbutton, and more. They are not in the scope of this recipe. Check the man
    page of zenity for more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use SSH to run these zenity statements on a remote machine. In
    order to run this statement on the remote host through SSH, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'But this will return an error like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is because zenity depends on Xserver. Xsever is a daemon which is responsible
    for plotting graphical elements on the screen which consists of the GUI. A bare
    GNU/Linux system consists of only a text terminal or shell prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Xserver uses a special environment variable, `DISPLAY`, to track the Xserver
    instance that is running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: We can manually set `DISPLAY=:0` to instruct Xserver about the Xserver instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous SSH command can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This statement will display a pop up at `remotehost` if the user with username
    has been logged in any of the window managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to multicast the popup window to multiple remote hosts, write a shell
    script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above script, we have a list of IP addresses to which the window should
    be popped up. A loop is used to iterate through IP addresses and execute the SSH
    command.
  prefs: []
  type: TYPE_NORMAL
- en: In the SSH statement, at the end we have post fixed `&`. `&` will send an SSH
    statement to the background. It is done to facilitate parallelization in the execution
    of several SSH statements. If `&` was not used, it will start the SSH session,
    execute the zenity dialog, and wait for the user to close that pop up window.
    Unless the user at the remote host closes the window, the next SSH statement in
    the loop will not be executed. In order to move away from this blocking of the
    loop from further execution by waiting for the SSH session to terminate, the `&`
    trick is used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Running commands on remote host with SSH*, explains the ssh command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network traffic and port analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network ports are essential parameters of network-based applications. Applications
    open ports on the host and communicate to a remote host through opened ports at
    the remote host. Having awareness of opened and closed ports is essential for
    security context. Malwares and root kits may be running on the system with custom
    ports and custom services that allow attackers to capture unauthorized access
    to data and resources. By getting the list of opened ports and services running
    on the ports, we can analyze and defend the system from being controlled by root
    kits and the list helps to remove them efficiently. The list of opened ports is
    not only helpful for malware detection, but also for collecting information about
    opened ports on the system enables to debug network based applications. It helps
    to analyse whether certain port connections and port listening functionalities
    are working fine. This recipe discusses various utilities for port analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various commands are available for listening to ports and services running on
    each port (for example, `lsof` and `netstat`). These commands are, by default,
    available on all GNU/Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to list all opened ports on the system along with the details on each
    service attached to it, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entry in the output of `lsof` corresponds to each service that opens a
    port for communication. The last column of the output consists of lines similar
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this output `slynux-laptop.local:34395` corresponds to localhost part and
    `192.168.0.2:3128` corresponds to remote host.
  prefs: []
  type: TYPE_NORMAL
- en: '`34395` is the port opened from current machine, and `3128` is the port to
    which the service connects at remote host.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list out the opened ports from current machine, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `:[0-9]\+->` regex for `grep` is used to extract the host port portion (`:34395->`)
    from the `lsof` output. The next `grep` is used to extract the port number (which
    is numeric). Multiple connections may occur through the same port and hence multiple
    entries of the same port may occur. In order to display each port once, they are
    sorted and the unique ones are printed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional utilities that can be used for viewing the opened
    port and network traffic related information.
  prefs: []
  type: TYPE_NORMAL
- en: Opened port and services using netstat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`netstat` is another command for network service analysis. Explaining all the
    features of `netstat` is not in the scope of this recipe. We will now look at
    how to list services and port numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `netstat -tnp` to list opened ports and services as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
