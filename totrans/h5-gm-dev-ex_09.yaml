- en: Chapter 9. Building a Physics Car Game with Box2D and Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2D Physics Engine is a hot topic in game development. With the help of a physics
    engine, we can easily create a playable game by just defining an environment and
    a simple rule. Taking existing games as examples, players in the Angry Birds game
    fly birds to destruct the enemy's castle. In Cut the Rope, candy drops into the
    monster's mouth to progress to the next level.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Box2D JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a static ground body in the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing the physics world on the Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic box in the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advancing the world time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding wheels to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the physics car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding force to the car with a keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking a collision in the Box2D world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restarting the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a level support to our car game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the Box2D outline drawing with graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a final touch to make the game fun to play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what we will get by the end of this chapter.
    It is a car game in which a player moves the car towards the destination point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Physics Car Game with Box2D and Canvas](img/1260_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Box2D JavaScript library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, suppose that we want to create a car game. We apply force to the car to
    make it move forward. The car moves on a ramp and then flies through the air.
    Afterwards, the car falls on the destination ramp and the game finishes. Every
    collision in every part of the physics world counts on this movement. If we have
    to make this game from scratch, then we have to calculate at least the velocity
    and angle of each part. Luckily, the physics library helps us to handle all these
    physical problems. All we have to do is to create the physics model and present
    it in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Installing the Box2D physics library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will get the Box2D JavaScript library. The original Box2D JavaScript library
    is based on the prototype JavaScript library. The prototype library provides similar
    functions from jQuery but with a little different API. Thanks to KJ ([http://kjam.org/post/105](http://kjam.org/post/105))
    who ported it into the jQuery capable version, we can use the jQuery library on
    which we have based our whole book. The Box2D library with the starting code can
    be found from the code bundle named `box2d_game`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we should have the following setup:![Time for action Installing the Box2D
    physics library](img/1260_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already imported the essential JavaScript files. It is worth remembering
    that if you want to later use this base to create another physics game, Box2D
    JS recommends copying the JavaScript import codes in exactly the same order because
    there are dependencies between files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create an empty world to test our Box2D library installation.
    Open the `html5games.box2dcargame.js` JavaScript file and put the following code
    in the file to create the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open the `index.html` file in a web browser. We should see a grey canvas with
    nothing there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have not presented the physics world in the canvas yet. That is why we only
    see a blank canvas on the page. However, we have printed the newly created world
    in the console log. The following screenshot shows the console tracing the world
    object with many properties beginning with `m_`. These are the physical states
    of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action Installing the Box2D physics library](img/1260_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just installed the Box2D JavaScript library and created an empty world
    to test the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Using b2World to create a new world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `b2World` is a core class in the Box2D environment. All our physics bodies,
    including the ground and car, are created in this world. The following code shows
    how to create a world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `b2World` class takes three arguments to initialize, which are listed in
    the following table with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments | Type | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `worldAABB` | b2AABB | Represents the bounding area of the world |'
  prefs: []
  type: TYPE_TB
- en: '| `gravity` | b2Vec2 | Represents the gravity of the world |'
  prefs: []
  type: TYPE_TB
- en: '| `doSleep` | Bool | Defines whether the world ignores slept objects or not
    |'
  prefs: []
  type: TYPE_TB
- en: Using b2AABB to define a bounding area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the physics world, we need a lot of bounding area. The first bounding we
    need is for the world. All things within the world bounding will be calculated
    and things outside the bounding area will be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can treat `b2AABB` as a rectangle with the lowest bounding point and highest
    bounding point. The following code snippet shows how to use the `b2AABB` class.
    The `minVertex` is the top left-most point of the bound while `maxVertex` is the
    bottom right-most point. The following world defines a world with 8000x8000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unit in the Box2D mathematics model is different from what we commonly use
    in the computer world. The length unit is in meters instead of pixels. Moreover,
    the rotation unit is in radians.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the gravity of the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to define the gravity of the world. The gravity is defined by `b2Vec2`.
    The `b2Vec2` is a vector with a 1x2 matrix. We can treat it as a vector of X and
    Y-axis. Therefore, the following code defines the gravity with 300 units downwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting the Box2D to ignore the slept object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slept body is a dynamic body that does not move or change states anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The physics library calculates the mathematical data and collision of all bodies
    in the world. The performance will slow down when there are more bodies in the
    world to get calculated in every frame. When creating the physics world, we need
    to set the library to either ignore slept bodies or calculate all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, there are only a few bodies, so the performance is not yet a problem.
    Moreover, if later our created bodies get into an idle or sleep state, we cannot
    interact with them anymore. Therefore, we set this flag to false in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, only Google Chrome runs the Box2D JavaScript
    library in canvas smoothly. Therefore, it is suggested to test the game in Google
    Chrome until other web browsers can run it smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a static ground body in the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world is empty now. If we are going to place objects there, those objects
    will fall and finally leave our sight. Now suppose that we want to create a static
    ground body in the world, so that objects can stand there. We can do this in Box2D.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Creating a ground in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.box2dcargame.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following function to the end of the JavaScript file. It creates a
    fixed body as the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `createGround` function after creating the world as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we are still defining the logic and have not yet presented the physics world
    visually, we will see nothing if we open the browser. However, it is a good habit
    to try it and inspect the console window for an error message if there is any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a ground body with the shape and body definitions. This is a
    common process we will use a lot to create different kinds of physical bodies
    in the world. So, let's get into details on how we made it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A shape defines the geometrical data. In the JavaScript port of Box2D, a shape
    also defines material properties such as density, friction, and restitution. The
    shape can be a circle, rectangle, or a polygon. The following code that we used
    in the preceding example defines a box shape definition. In the box shape, we
    have to define the size of the box by setting the `extents` property. The `extents`
    property takes two arguments: half width and half height. It is a half value,
    so the final area of the shape is four times the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the shape, we can then create a body definition with the given
    shape definition. Then, we set the initial position of the body and finally ask
    the world instance to create a body from our body definition. The following code
    shows how we create a body in the world with the given shape definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A body set without a mass is considered as a static body, or fixed body. These
    bodies are immovable and will not have collisions with other static bodies. Therefore,
    these bodies can be used as a ground or walls to become the level environment.
    On the other hand, a dynamic body will move following the gravity and collision
    with other bodies. We will create a dynamic box body later.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the physics world in the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a ground but it is only in the mathematics model. We do not
    see anything in the canvas because we have not drawn anything on it yet. In order
    to show what the physics looks like, we have to draw something according to the
    physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Drawing the physics world into the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `html5games.box2dcargame.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `drawWorld` function call to the page loaded event handler as the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `draw_world.js` JavaScript file from the Box2D JavaScript example
    code. There are two functions named `drawWorld` and `drawShapes`. Copy the entire
    file, which is shown in the following code, to the end of our JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now re-open the game in a browser and we should see the outline of the ground
    body in the canvas, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Drawing the physics world into the canvas](img/1260_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a function to draw every shape in the world as a box with
    a dark green outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we loop through each shape in the world to draw
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is the `drawJoint` function and related code from the Box2D JS library
    too. This joint drawing function is optional for our example. Adding the joint
    drawing function can let us see the invisible joint connected between two bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will take a look at the `drawShape` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On every shape, we want to draw the outline of the object in the canvas to
    present it. We set the line style to dark green before drawing anything. Then,
    we check whether the shape is a circle, rectangle box, or a polygon. If it is
    a circle, then we use the pole coordinate to draw the circle with the given radius
    of the shape. If it is a polygon, then we draw each side of the polygon as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a dynamic box in the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now we drop a box into the world. The box falls from the air and finally
    hits the ground. The box bounces up a little and finally stops on the ground.
    This is different from what we created in the last section. In the last section,
    we created a static ground which is immovable and will not be affected by gravity.
    Now we will create a dynamic box.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Putting a dynamic box in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our JavaScript logic file and add the following box creation code to the
    page loaded event handler. Place the code after the `createGround` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will test the physics world in a browser. We should see that a box is
    created at the given initial position. However, the box is not falling down; it
    is because we still have something to do to make it fall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Putting a dynamic box in the world](img/1260_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a dynamic body in the world. In contrast to the ground
    body that is immovable, this box is affected by the gravity and the velocity changes
    during a collision. When a body contains a shape with any mass or density, it
    is a dynamic body. Otherwise, it is static. Therefore, we define a density to
    our box. Box2D will make it dynamic and calculate the mass according to the density
    and the size of the body automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the bouncing effect with the restitution property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The restitution value is between 0 and 1\. In our case, the box is falling down
    on the ground. When the restitution value is 0 on both the ground and the box,
    the box does not bounce at all. When either the box or ground has restitution
    value 1, the collision is perfectly elastic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When two bodies collide, the restitution value of that collision is the maximum
    value between both restitution values of the bodies. Therefore, if a box with
    a restitution of 0.4 drops on the ground with restitution 0.6, this collision
    uses 0.6 to calculate the bouncing velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing the world time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The box is dynamic but it does not fall down. Are we doing anything wrong here?
    The answer is no. We have setup the box correctly, but we forget to advance the
    time in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: In the Box2D physics world, all calculations are done in a systematic iteration.
    The world calculates the physical transformation of all things according to the
    current step. When we move the `step` to the next level, the world calculates
    again as the new state.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Setting up the world step loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make the world time advance by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to advance the world step, we have to call the `step` function in
    the world instance periodically. We used `setTimeout` to keep calling the `step`
    function. Put the following function in our JavaScript logic file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will kick-start the world by calling the first `step` function in
    the document ready event handler. Add the following highlighted code to the loaded
    handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will again simulate the world in a browser. The box is created at the initialized
    position and falls on the ground correctly. The following screenshot shows the
    sequence of a box dropping on the ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Setting up the world step loop](img/1260_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have advanced the time of the world. Now the physics library simulates the
    world every 10 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `step` function is similar to our `gameloop` function in *Chapter 2, Getting
    Started with DOM-based Game Development*. It executes periodically to calculate
    the new state of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding wheels to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have a box in the game. Imagine now we create two circular shaped bodies
    as the wheels. Then, we will have the basic component of a car, the body, and
    the wheels.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Putting two circles in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add two circles to the world by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.box2dcargame.js` JavaScript file to add the wheel bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code after the box creation code. It calls the `createWheel`
    function which we will write to create a circular shaped body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s work on the `createWheel` function. We design this function to create
    a circle shaped body in the given world at the given x and y coordinates in the
    world. Put the following function in our JavaScript logic file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now reload the physics world in a web browser. This time, we should
    see the result similar to the one shown in the following screenshot with a box
    and two wheels falling down from the air. These bodies collide with others and
    bounce away when they hit the wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Putting two circles in the world](img/1260_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When simulating the physics world, both the box and wheels drop and collide
    with each other and the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a circular body is similar to creating a box body. The only difference
    is that we use a `CircleDef` class instead of the box shape definition. In the
    circle definition, we define the circle size by using the `radius` property instead
    of the `extents` property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a physical car
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have prepared the car box body and two wheel bodies. We are just one step
    away from making a car. Imagine now we have a glue to glue the wheels to the car
    body. Then, the car and wheels will not separate anymore and we will have a car.
    We can use **joint** to achieve that. In this section, we will use `joint` to
    stick the wheels and the car body together.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Connecting the box and two circles with revolute joint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We are still working only on the logic part. Open our JavaScript logic file
    in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following global variable at the top of the document to reference the
    car body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `createCarAt` which takes the coordinate as arguments.
    Then, we move the body and the wheel creation code in this function. Afterwards,
    add the following highlighted Joint creation code. At last, return the car body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all we need to do is to create a car with the initial position. Add the
    following code to the page loaded event handler after the world creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to save the file and run the physics world in a browser. At this
    time, the wheels and the car body are not separate pieces. They glue together
    as a car and drop on the ground correctly, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Connecting the box and two circles with revolute joint](img/1260_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Joint is useful to add constraint between two bodies (or between a body and
    the world). There are many kinds of joints and what we used in this example is
    called **revolute joint**.
  prefs: []
  type: TYPE_NORMAL
- en: Using a revolute joint to create an anchor point between two bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The revolute joint sticks two bodies together with a common anchor point. The
    two bodies are then glued together and are only allowed to rotate based on the
    common anchor point. The left hand side of the following screenshot shows that
    two bodies are connected with an anchor. In our code example, we set the anchor
    point to be exactly the center point of the wheel. The right hand side of the
    following screenshot shows how we set the joint. The wheel rotates as a wheel
    because the rotation origin is at the center. This setup makes the car and wheels
    look real:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a revolute joint to create an anchor point between two bodies](img/1260_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are other types of joints which are useful in different ways. Joints
    are useful in creating a game environment and as there are several types of joints,
    each joint type is worth a try and you should think how to use them. The following
    link is the Box2D manual which explains each type of joint and how we can use
    them on different environment setups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding force to the car with a keyboard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the car ready now. Let's move it with our keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Adding force to the car
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.box2dcargame.js` JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the page loaded event handler, we add the following `keydown` event handler
    to the beginning. It listens to the **X** key and **Z** key to apply force in
    different directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. Save the files and run our game in the browser. When you press
    the **X** or **Z** key, the car starts moving. If you keep pressing the key, the
    world will keep adding force to the car and make it fly away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Adding force to the car](img/1260_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created an interaction with our car body. We can move the car left and
    right by pressing the **Z** and **X** keys. It seems like the game is getting
    interesting now.
  prefs: []
  type: TYPE_NORMAL
- en: Applying force to a body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply force to any body by calling the `ApplyForce` function in that
    body. The following code shows the usage of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two arguments, which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments | Type | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `force` | `b2Vec2` | The force vector to apply to the body |'
  prefs: []
  type: TYPE_TB
- en: '| `point` | `b2Vec2` | The point where the force applies |'
  prefs: []
  type: TYPE_TB
- en: Understanding the difference between ApplyForce and ApplyImpulse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the `ApplyForce` function, we can also move any body by using the `ApplyImpulse`
    function. Both functions move the body, but they move them in a different approach.
    If we want to change the instance velocity of a body, then we use `ApplyImpulse`
    once on the body to change velocity to our target value. On the other hand, we
    need to constituently apply force to a body to increase the speed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to increase the velocity of the car like stepping on the
    pedal. In this case, we apply force to the car. If we are creating a ball game
    that needs to kick-start the ball, we may use the `ApplyImpulse` function to add
    an instance impulse to the ball body.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can you think about a different situation where we will need to apply force
    or impulse to the body?
  prefs: []
  type: TYPE_NORMAL
- en: Adding ramps to our game environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can move the car. However, the environment is not interesting enough
    to play. Imagine now there are some ramps for the car to jump, and there is a
    gap between two platforms that a player has to fly the car over. It will become
    more interesting to play with different ramp setups.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Creating the world with ramps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will open the game logic JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the current ground creation code into a new function named `createGround`.
    Then, change the code to use the four given arguments as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a function to create the ground body. We will now replace the ground
    creation code in the page loaded handler function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and preview the game in a browser. We should see a ramp now and
    a destination platform as shown in the following screenshot. Try to control the
    car, jump over the ramp, and reach the destination without falling down. Refresh
    the page to restart the game if you fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Creating the world with ramps](img/1260_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just wrapped the ground box creating code into a function, so that we can
    easily create a combination of ground bodies. These ground bodies composite the
    level environment of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, this is the first time we are rotating a body. We set the rotation
    of the body by using the `rotation` property which takes a value in radian. Most
    people may get used to the degree unit; we can get the radian value from degree
    by using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By setting the rotation of a box, we can have a ramp of varying slope setup
    in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero Creating different environments with different joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a ramp setup now and we can play with the car within the environment.
    How about using different kinds of joints to setup the playground? For example,
    how about a pulley joint to act as a lift? On the other hand, how about including
    a dynamic board with a joint at the center?
  prefs: []
  type: TYPE_NORMAL
- en: Checking collisions in the Box2D world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Box2D physics library calculates all collisions automatically. Imagine now
    we setup a ground body as the destination. Players win when they successfully
    move the car to hit the destination. As Box2D already calculates all collisions,
    all we have to do is get the detected collision list and determine whether our
    car has hit the destination ground.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Checking a collision between the car and the destination body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start from our game logic. Open the `html5games.box2dcargame.js` JavaScript
    file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We setup a destination ground in the ground creation code and assign it to
    our `gamewinWall` reference inside the `carGame` global object instance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move on to the `step` function. In each step, we get the complete
    contact list from the world and check whether any two colliding objects are car
    and the destination ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now save the code and open the game in a browser again. This time,
    we have to open the console window to track if we get the **Level Passed!** output
    when the car hits that wall. Try to finish the game and we should see the output
    in the console once the car hits the destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Checking a collision between the car and the destination
    body](img/1260_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created the game winning logic by checking the collision contacts. The
    player wins when the car successfully reaches the destination ground object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the collision contact list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each step, Box2D calculates all collisions and puts them into a **contact
    list** in the `world` instance. We can get the contact list by using the `carGame.world.GetContactList()`
    function. The returned contact list is a **link list**. We can travel through
    the entire link list by using the following for-loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we get the collided shapes, we check whether the body of that shape is
    a car or the destination body. As the car shape may be in shape 1 or shape 2,
    and the same applies to the `gamewinWall`, we use the following code to check
    both combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a game over dialog in *Chapter 7, Using Local Storage to Store Game
    Data*. How about using that technique here to create a dialog showing the player
    passed the level when hitting the winning wall? It will also be useful as level
    transition later when we add different level setups to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already tried refreshing the page several times in the last example
    to make the car successfully jump to the destination. Imagine now we can press
    a key to re-initialize the world. Then, we can follow the trial-and-error method
    until success.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Restarting the game while pressing the R key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assign the **R** key as the restart key for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we only need to change the JavaScript file. Open the `html5games.box2dcargame.js`
    JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We move the create world, ramp, and the car code into a function named `restartGame`.
    They were originally in the page loaded handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the page loaded event handler, we call the `restartGame` function
    to initialize the game as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the following highlighted code to the `keydown` handler to
    restart the game when the **R** key is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'How about restarting the game when the player passes the level? Add the following
    highlighted code to the game win logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is time to test the game in a browser. Try playing the game and press the
    **R** key to restart the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We refractor our code to create a `restartGame` function. The world is destroyed
    and initialized again each time we call this function. We can destroy the existing
    world and create a new empty one by creating a new world instance of our world
    variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero Creating the game over wall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now the only way to restart the game is by pressing the restart key. How about
    creating a ground at the bottom of the world that checks any falling car? When
    the car drops and hits the bottom ground, we know that the player has failed and
    then restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a level support to our car game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now we can level up to the next environment setup when finishing each
    game. We will need several environment setups for each level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Loading game with levels data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will refractor our code to support loading the static ground bodies from
    a levels data structure. Let''s work on it by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.box2dcargame.js` JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need each ground setup on each level. Put the following code at the
    top of the JavaScript file. It is an array of levels. Each level is another array
    of objects with the position, dimension, and rotation of the static ground body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the following variable in the `carGame` object instance to store
    the current level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `restartGame` function with the following code. It changes the
    function to accept a `level` argument. Then, create the ground or car by the level
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the page loaded handler function, we change the `restartGame` function calling
    by providing `currentLevel` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to provide the `currentLevel` value in the restart key handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we change the following highlighted code in the game win logic. We
    level up the game when the car hits the destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now run the game in the web browser. Finish the level and the game
    should restart at the next level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Loading game with levels data](img/1260_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a data structure to store the levels. Then, we created the game
    with the given level number and constructed the world with the level data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each level data is an array of objects. Each object contains properties of
    each ground body in the world. This includes basic properties such as position,
    size, and rotation. There is also a property named `type`. It defines whether
    the body is a normal box body, car data, or the destination winning ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the world, we use the following code to loop through all objects
    in the level array. We then create the car and ground bodies and reference the
    game winning ground according to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero Creating more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have several levels setup for our game. How about duplicating the level
    data to create more interesting levels to play? Create your own levels and play
    with them. It is just as if a kid builds blocks and plays with them.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Box2D outline drawing with graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the game that is at least playable with several levels. However,
    they are just some outline boxes. We cannot even distinguish between the destination
    body and other ground bodies in the game. Imagine now the destination is a racing
    flag and there is a car graphic to represent it. It will make the game purpose
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Adding a flag graphic and a car graphic to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first download the graphics we need for this example. Go to the following
    link to download the graphics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://gamedesign.cc/html5games/1260_09_example_graphics.zip](http://gamedesign.cc/html5games/1260_09_example_graphics.zip
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the ZIP file in the `images` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it is time to edit the `index.htm` file. Add the following HTML markup
    to the body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to hide the asset DIV that contains our `img` tags. Open the `cargame.css`
    file and add the following CSS rule to keep the asset DIV out of our sight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We will now move on to the logic part. Open the `html5games.box2dcargame.js`
    JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `createGround` function, we add a new argument named `type` to pass
    in the type. Then, we add the highlighted code to assign the reference of the
    `flag` image to the ground shape user data if it is a winning destination ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the ground, we need to pass the `type` property now. Replace
    the ground creation code with the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we assign the reference of the `bus` image tag to the user data in the
    car shape. Add the following highlighted code to the car box definition creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We used to get the reference of an element by the jQuery `$(selector)` method.
    The jQuery selector returns an array of the element objects with additional jQuery
    data wrapped. If we want to get the original document element reference, then
    we can either use the `document.getElementById` method or `$(selector).get(0)`.
    As `$(selector)` returns an array, `get(0)` gives the first original document
    element in the list
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to handle the wheels. We assign the `wheel` image tag to the
    wheel body''s `userData` property. Add the following highlighted code to the `createWheel`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to draw the images in the canvas. Replace the `drawWorld`
    function with the following code. The highlighted code is the changed part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, save all files and run the game in a web browser. We should see a
    yellow bus graphic, two wheels, and a flag as the destination. Play the game now
    and the game should move on to the next level when the bus hits the flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Adding a flag graphic and a car graphic to the game](img/1260_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now presenting our game with minimal graphics. At least, players can
    easily know what they are controlling and where they should go.
  prefs: []
  type: TYPE_NORMAL
- en: The Box2D library uses a canvas to render the physics world. Therefore, all
    techniques that we learned about a canvas can be applied here. In *Chapter 5,
    Building* a *Canvas Games Masterclass*, we learned the use of the `drawImage`
    function to display an image in the canvas. We used this technique to draw the
    flag graphic in the canvas of the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Using userData in shape and body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we know which physics body needs to be displayed as the flag image? There
    is a property named `userData` in every Box2D shape and body. This property is
    used to store any custom data related to that shape or body. For example, we may
    store the filename of the graphic file or we just directly store the reference
    to the image tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a list of image tags referencing the graphic assets that we need in
    the game. However, we do not want to display the image tags, they are just for
    the purpose of loading and referencing. We hide those asset image tags by setting
    their position out of the HTML bound with the following CSS style. We do not use
    `display:none` because we cannot get the width and height of the element that
    is not displayed at all. We need the width and height to position graphics correctly
    in the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Drawing graphics every frame according to the state of its physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The drawing from Box2D is just for development use before we replace it with
    our graphics.
  prefs: []
  type: TYPE_NORMAL
- en: The following code checks whether the shape has a user data assigned. In our
    example, the user data is used for referencing the `image` tag of that graphics
    asset. We get the image tag and pass it to the canvas context `drawImage` function
    to draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'All box and circle shapes in Box2D have the origin point at the center. However,
    the image drawing in the canvas needs the top-left point. Therefore, we have both
    x/y coordinates and offset of top-left x/y points which is a negative half width
    and height of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Rotating and translating an image in the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the `drawImage` function to draw an image directly with the coordinate.
    However, the situation is different here. We need to rotate the drawn image. This
    is done by rotating the context before drawing and then restoring the rotation
    afterwards. We can do this by saving the context state, translating it, rotating
    it, and then calling the `restore` function. The following code shows how we draw
    an image at a given position and rotation. The `topleftX` and `topleftY` are the
    offset distances from the image center origin to the top left point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We do not need to make the physics body area exactly the same as its graphics.
    For example, if we have a round circle chicken, we can represent it in the physics
    world by just a ball body. Using a simple physics body can improve the performance
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero Applying the previously learned technique to the car game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned using CSS3 transition to animate a scoreboard. How about applying
    it to this car game? Moreover, how about adding some engine sounds to the car?
    Just try applying what we have learned through this book to give players a complete
    game experience.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a final touch to make the game fun to play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now we want to publish the game. The game logic is basically here, but
    it looks quite ugly with the black and white environment. In this section, we
    will add some final touches to the game so it is much more attractive. We will
    also apply some constraints to limit the time of ApplyForce. This constraint makes
    the game more fun because it requires a player to think before he applies too
    much force to the car.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Decorating the game and adding a fuel limitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need some background images for the starting screen, game winning
    screen, and environment backgrounds for each level. These graphics can be found
    from the code bundle named `box2d_final_game`. The following screenshot shows
    the graphics we need in this section:![Time for action Decorating the game and
    adding a fuel limitation](img/1260_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.htm` file and replace the canvas element with the following
    markup. It creates two more game components named current level and fuel remaining,
    and groups the game components into a `game-container` DIV:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will copy the `cargame.css` file from the code bundle. It contains
    several class style definitions for the game. The game should look similar to
    the one shown in the following screenshot when we have applied the new stylesheet:![Time
    for action Decorating the game and adding a fuel limitation](img/1260_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will move on to the JavaScript part. Open the `html5games.box2dcargame.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `carGame` object declaration with the following additional variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the starting screen. Instead of starting the game once, the page
    is loaded. We show the starting screen and wait for the player to click on the
    game canvas. Add the following logic to the page `ready` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We need to remove the original `step()` function calling at the end of the page
    `ready` function because we are calling it on a mouse click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to handle the game winning screen when the player passes all
    levels. In the winning flag collision checking logic, we replace the original
    `restartGame` function calling with the following logic which checks whether we
    show the next level or the ending screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will handle the game playing background. We prepared each game background
    for each level setting. We will switch the background in the `restartGame` function
    which responds to reconstruct the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With the game graphics now, we do not need the physics object outline drawing
    any more. We can remove the `drawShape(s, context)`; code in the `drawWorld` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, let''s add some constraints. Remember that in our level data, we include
    a mystery fuel data to the car. It is an indicator indicating how much fuel the
    car contains. We will use this fuel to limit the player''s input. The fuel reduces
    each time a force is applied to the car. The player cannot apply any additional
    force once the fuel runs out. This limitation makes the game more fun to play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the **x** and **z** `keydown` function with the following logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, in the car creating logic in the restart game function, we initialize
    the fuel as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the game in a browser. We should get five graphic levels. The following
    screenshot shows how the last four levels look:![Time for action Decorating the
    game and adding a fuel limitation](img/1260_09_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After passing all levels, we get the following winning screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Decorating the game and adding a fuel limitation](img/1260_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just decorated our game with more graphics. We also draw each level environment
    a background image. The following screenshot illustrates how the visual ground
    represents the logical physics boxes. Unlike the car and the winning flag, the
    ground graphics are not associated with the physics ground. It is just a background
    image with the graphics in their respective positions. We can use this approach
    because those boxes will never move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then prepare several CSS styles for each level with the level number
    in the class name, such as `.gamebg_level_1` and `.gamebg_level_2`. With each
    class linked with each level background, we can change the background when switching
    a level in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Adding fuel to add a constraint when applying force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we limit the player''s input by providing limited fuel to use. The fuel
    decreases when players apply force to the car. We used the following `keydown`
    logic to decrease the fuel and prevent additional force when running out of fuel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Presenting the remaining fuel in a CSS3 progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our game, we present the remaining fuel as a progress bar. The progress
    bar is actually a `DIV` inside another `DIV`. The following markup shows the structure
    of the progress bar. The outer `DIV` defines the maximum value and the inner `DIV`
    shows the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the structure of the progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/1260_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this structure, we can show a specific progress by setting the width as
    a percentage value. We use the following code to update the progress bar according
    to the percentage of the fuel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic logic to setup a progress bar and control it with the width
    style. Furthermore, we give the progress bar''s background a nice gradient as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/1260_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is done in the stylesheet with the following CSS3 gradient background definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about using the Box2D physics engine to create
    a car adventure game in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JavaScript ported physics engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating static and dynamic bodies in the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the car by using joints to constrain bodies and wheels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a keyboard input with the prototype library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the car by adding force to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking collisions in the physics world as the level destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing an image to replace the outline of our physical game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed adding a fuel bar to limit the player's input to give some
    constraint and add more fun to the game play.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned about using the Box2D physics library to create a canvas-based
    physics game.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed different aspects of making HTML5 games with CSS3 and JavaScript
    through all nine chapters. We learned building a traditional Ping Pong game in
    DOM, we built a card matching game in CSS3, and an Untangle puzzle game with the
    canvas. Then, we explored adding sounds to the game and created a mini piano musical
    game around it. Next, we discussed saving and loading game statuses by using the
    local storage. Moreover, we tried building a draw-and-guess real-time multiplayer
    game with WebSockets. Finally, we created a car game with a physics engine in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, we built different types of games and learned some essential
    techniques that we need to make HTML5 games. The next step is to go on and deploy
    your own games. To help develop your own games, there are some resources that
    can help. The following list gives some useful links for HTML5 games development:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 game engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Impact ([http://impactjs.com/](http://impactjs.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rocket Engine ([http://rocketpack.fi/engine/](http://rocketpack.fi/engine/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LimeJS ([http://www.limejs.com/](http://www.limejs.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game sprites, and textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lost Garden([http://lunar.lostgarden.com/labels/free%20game%20graphics.html](http://lunar.lostgarden.com/labels/free%20game%20graphics.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some free sprites from The_Protagonist's Domain ([http://www.freewebs.com/teh_pro/sprites.htm](http://www.freewebs.com/teh_pro/sprites.htm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HasGraphics sprites, textures, and tilesets ([http://hasgraphics.com/category/sprites/](http://hasgraphics.com/category/sprites/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CG Textures ([http://cgtextures.com/](http://cgtextures.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PacDV ([http://www.pacdv.com/sounds/](http://www.pacdv.com/sounds/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FlashKit Sound Effects ([http://www.flashkit.com/soundfx/](http://www.flashkit.com/soundfx/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FlashKit Sound Loops ([http://www.flashkit.com/loops/](http://www.flashkit.com/loops/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
