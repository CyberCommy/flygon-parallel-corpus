- en: Chapter 4. Android Development Style and Standards in the Industry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no written rule or direction to write code in Android, other than the
    syntactical grammar. However, most developers across the globe follow a few fundamental
    styles and standards for writing Android code. Android is based on Java, so most
    of the stylization follows Java standards.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Android game development, there are a few design styles that
    should be followed. They do not cover game design, rather more technical design.
    These kinds of styles and standards indicate a proper project structure, class
    structure, and folder/file management.
  prefs: []
  type: TYPE_NORMAL
- en: Typical game design also involves following some rules while working on the
    Android platform. A few styles are being followed in the industry in terms of
    game design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a look at these styles and standards through
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android programming structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game programming specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical design standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other style and standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different styles for different development engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Industry best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android programming structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android style or recommendation is not a definite programming rule. However,
    a good programming practice always includes a set of rules. To code in Android,
    the code structure follows the Android base structure and hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Android typically follows the standards and style of Java. So, the Android programming
    structure is basically Java structure, which follows the OOP style.
  prefs: []
  type: TYPE_NORMAL
- en: Class formation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java class formats should be consistent and follow the Javadoc rule; a standard
    structure should follow this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: License information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package declaration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Library imports
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class description and purpose
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class definition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the copyright and license information format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the class and method description format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Call hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the coding style, there is no defined call hierarchy. However, in Android
    gaming, most developers follow a basic approach. In this approach, there are mainly
    three kinds of classes in the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Managers and controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game requires the managers and controllers to implicate game rules and regulations.
    It is also used to control the behavior of game elements and states. Most games
    consist of multiple sections or screens, for example, menu, level selection, game
    play, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'These sections can be termed as states, and the elements used inside these
    are called associates. Associates may be separate classes by themselves. Utility
    classes basically support development by providing predefined functionality, such
    as in-game sound implementation, record store management, common utilities, network
    connectivity, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Call hierarchy](img/B05069_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Call hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Inside the game loop, the main Android game thread loops hand over control to
    the main game manager. The main game manager is responsible for passing on the
    thread and rendering control to the required state manager. The main game manager
    is also responsible for the initialization and destruction of state managers,
    depending on the current thread. Moreover, the main game manager is active throughout
    the game cycle and manages the main game activity as well.
  prefs: []
  type: TYPE_NORMAL
- en: State managers are responsible for managing a state (main menu, level selection,
    in-gameplay, and so on) and all the required associate classes. State managers
    pass the call to the respective associates to carry out a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: Utility classes are accessible from any layer in the hierarchy, depending on
    the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This is a generic architecture that is not mandatory. Many developers design
    the call hierarchy differently. Everything is good, and the game flow is also
    running properly without sacrificing the class/data security.
  prefs: []
  type: TYPE_NORMAL
- en: Game programming specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game programmers are not very different from any other software programmer.
    However, game programming requires stronger logical skill than software programming.
    The sense of game design is also different.
  prefs: []
  type: TYPE_NORMAL
- en: A game is an interactive entertainment system. A software or an application
    is meant to reduce a human calculative real-time task. So, it is clear that a
    game serves a very different purpose than a software or an application.
  prefs: []
  type: TYPE_NORMAL
- en: This is why game programming has to follow a few specifications and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Game programming can be divided into these following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphics programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gameplay programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the most relevant programming for the gaming division. Gameplay programming
    requires a strong logical, mathematical, and analytical skill. A sense of game
    design is also required. Gameplay programming includes AI, user control, physics,
    display control, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay programmers are the ones who deal with the most responsible designers
    for prototyping the game.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the visual effects and impacts are made by graphic programmers. They are
    responsible for the visual quality of the game. There is a vast scope to manipulate
    graphic assets while the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics programming is all about getting the maximum from the GPU. Nowadays,
    most games are graphics heavy. The latest devices have separate, powerful GPUs
    to support heavy graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Modern-age games represent an excellent quality of graphical display. All new
    3D real-time lighting, particle system effect, visual motion effect, and so on
    entirely depend on the graphical programmer. The challenge is to increase the
    visual quality without affecting the game performance.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, game performance drops significantly due to heavy art asset
    processing, which is never a desired situation. Shaders or graphics programmers
    have to balance quality and performance.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly effective when games are ported across different platforms. As
    we have discussed earlier, a range of hardware platforms with a wide range of
    hardware specifications run on Android. Separate shaders and assets are required
    for this kind of porting. A shader program instructs the graphic processor to
    render each pixel in a particular way.
  prefs: []
  type: TYPE_NORMAL
- en: Technical programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This part of programming has not much to do with games; however, it ensures
    the game performance. Besides the performance, network management, plugin development,
    optimization, and so on are also part of technical programming. Here is a list
    of the possible areas for technical programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Sound programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game tool programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research and development programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowadays, sound is a mandatory part of games. Some games are even made around
    music. Sound programming has therefore become a part of game programming. A sound
    programmer mainly has knowledge of digital signal processing. Sound programmers
    have to work with sound designers.
  prefs: []
  type: TYPE_NORMAL
- en: Modern-age games use 3D sound systems. Sound programming plays a critical role
    in delivering quality sound without affecting the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Network programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old-age games were mostly made to run on a single instance. Most of the time,
    the game did not communicate with other instances, so there was not much need
    for network programming at that point in time. The modern age is the age of networking;
    just one instance is not enough. Multiplayer games are very common today; even
    standalone games communicate with other game instances just for socialization
    and monetization.
  prefs: []
  type: TYPE_NORMAL
- en: Network programming takes care of network latency, packet optimization, connection
    handling, and maintaining communication. The network programmer is also responsible
    for managing client-server communication and creating the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Some games run on the server. The client acts as a display device for the game
    instance running on the server. The transaction follows real-time syncing. Few
    games even follow asynchronous communication. Network programming assures the
    smooth and proper transition in this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Game tool programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Game development cannot be completed without the support of certain tools. Tool
    programmers can make other developers' lives a living hell or heaven. Proper game
    tool programming can ease the development process a lot. A lot of time and effort
    can be saved with the help of development tools.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed a few development tools. However, it is not necessary
    for all of the tools to be game independent. There may be few tools that can be
    game specific. For example, a tool can be made to generate a required database
    to be used in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Research and development programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This kind of programming is not primarily for making a game. Instead, this programming
    helps make gaming better and finds new techniques to be used for upcoming games.
  prefs: []
  type: TYPE_NORMAL
- en: This type of programming requires strong skills in technical understanding,
    hardware platforms, and native development. Programmers should have knowledge
    of native language and assembly or hardware-level language as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Android game development, research programmers are assigned to
    explore new Android devices along with a new feature and specification. These
    programmers then try to discover how to use the feature in the best possible way
    in games.
  prefs: []
  type: TYPE_NORMAL
- en: This programming is solely responsible for games having features like the use
    of various sensors such as gravity, light, accelerometer, and so on. The recent
    development of virtual reality with Android devices is a practical example of
    such experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Technical design standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mostly, game development revolves around game design; however, the development
    process is controlled by technical design. Technical design considers each and
    every possible aspect of the real-time feasibility of the actual game design and
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A technical design contains the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Game analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design pattern and flow diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools and other requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section of technical design analyzes the game design thoroughly and figures
    out the sections where technology plays a major role. Game play logic development
    is not a part of this section. However, when game logic requires hardware dependency,
    then this section is also considered in technical design.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers and organizations have a habit of making a technical design
    document after creating the game design and before starting the actual development
    process. This helps define the timeline and predict upcoming challenges, with
    possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern and flow diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section designs the class diagram and hierarchy for the game. The game
    flowchart and server-client architecture (if required) are also defined here.
  prefs: []
  type: TYPE_NORMAL
- en: This section of game technical design gives a clear picture of upcoming development
    for a developer. Each and every part of game modules, program structure, call
    hierarchy, third-party tool integration, database connectivity, and server-call
    management should be clearly declared in this part of the technical design document.
  prefs: []
  type: TYPE_NORMAL
- en: The visual display of such a diagram, showing the flowcharts, is always a headstart
    for any development process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technical specification specifies the development platform, target device
    set, and target operating system. It may also mention what hardware system and
    software is required to develop the project.
  prefs: []
  type: TYPE_NORMAL
- en: This identification is essential before starting the actual development. For
    any software to run, it requires a hardware platform that is well capable of supporting
    the software. Developers must know the target devices and must be provided with
    these devices to carry out unit testing. Any additional requirement is also identified
    in this section of technical design.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, there are two different sections in this specification. First
    is to specify the target system on which the game is designated to run. Second
    is to identify the system required to create the game according to the design.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and other requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section in technical design refers to the additional tools and system requirements.
    In many cases, this section is included in the technical specification. However,
    this part serves a different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This may create the requirement to develop a new tool for the actual game development.
    Therefore, tool programmers are referred to this section. Android game development
    is not out of scope for this section. Although most of the tools are readily available
    for Android development, a few scenarios may demand a game-specific tool as well.
    In this case, the tool design and separate technical design, and the use of the
    tool is mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Resource analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource analysis is a report on staff dependency, staff skill level, technical
    dependency, and other resource dependencies. This helps estimate project cost
    and decide the development timeline.
  prefs: []
  type: TYPE_NORMAL
- en: Testing requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another important part of technical design. Testing is an integral part
    of a game development process. Technical design should define the testing procedure
    along with the defined test cases.
  prefs: []
  type: TYPE_NORMAL
- en: The development head of the game identifies the stages of testing and its requirements.
    Testing tools may be declared in this section. We have already mentioned testing
    tools in the previous chapter. In some cases, a customized tool may be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing requirements have four main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing resource requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tool requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every game has a predefined limited scope. Especially in Android devices, where
    the variety is maximum, a scope definition is required. Running a game with the
    same design on all Android platforms is next to impossible.
  prefs: []
  type: TYPE_NORMAL
- en: This section of technical design indicates the probable scope of the game. This
    may identify the minimum required configuration, recommended configuration, and
    target configuration to run the game at its maximum performance.
  prefs: []
  type: TYPE_NORMAL
- en: The game scope defines the minimum and maximum range of the hardware platform.
    Most developers like to minimize the game design scope to target maximum hardware
    devices. A technical design document is a good reference for developers to get
    an idea of the performance of the game within the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Risk analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A technical design document is made before the production is started, so there
    are many fields that have to be assumed beforehand. This obviously increases the
    risk of the project. However, having a clear idea of the risk always helps developers
    get the solution when the actual problem occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason risk analysis is mandatory for any technical design standard.
    The risk may be analyzed in different fields.
  prefs: []
  type: TYPE_NORMAL
- en: While developing a game, the technical requirements or game design may change.
    So, risk should be calculated to accommodate these changes without affecting the
    main project pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Technology is evolving quickly. So, in the risk analysis section, change of
    technology should also be addressed. In a common scenario in game development,
    technology may change during development to increase the game quality.
  prefs: []
  type: TYPE_NORMAL
- en: Change log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A change log is the list containing all the changes in technical document from
    the first draft and according to the date and version number. This helps in keeping
    track of the evolution of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Game design standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game design is documented in almost every organization in the gaming industry.
    This is one of the standards used most often by almost all developers. Technical
    design is sometimes skipped to save some time, and some designers include the
    most required segments from a technical document in game design. However, this
    approach is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic approach to maintain a standard game design contains the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Game overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gameplay details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game progression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storyboard and game elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Art style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section defines the nature of the game along with its target audience.
    This section contains a brief about the game concept, gameplay, and the look and
    feel. The working title is mentioned beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Game overview is basically the brief on almost all aspects of the game to be
    made. This section may project a market study to support the game concept and
    genre chosen for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gameplay controls and the preferred user interface to control the gameplay is
    defined in this section. This is one of the most important parts of the game.
    Gameplay should be optimized for each hardware platform it is targeting. The game
    might be deployed for a mobile, tablet, and a console as well. So, different control
    schemes are defined for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Game progression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Game progression defines the game life cycle and its evolution through time.
    A game is a dynamic entertainment system. So, users cannot be bored at any point
    in time, and this section is responsible for user retention.
  prefs: []
  type: TYPE_NORMAL
- en: Storyboard and game elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This part of game design defines the background of the game concept. This does
    not mean having an actual story-based game background. However, every game must
    have some elements or objects around which the gameplay works.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a side scrolling runner game will have a character, a few obstacles,
    environmental objects, and so on. They are termed as game elements. The reason
    for running is the background story.
  prefs: []
  type: TYPE_NORMAL
- en: In another example, let's assume a game of Tic-Tac-Toe. A background story is
    not necessary; however, crosses, circles, and the grid are the elements of the
    game, which need to be designed and stylized.
  prefs: []
  type: TYPE_NORMAL
- en: Level design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Levels are the consequence of game progression. Each level has a synopsis, introduction,
    materials or elements, and an objective. More information can be given depending
    on the game.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artificial intelligence helps the gameplay to be experienced in a real-time
    scenario. It may be the opponent, enemy, obstacle, friendly support, situation
    detection, collision detection, pathfinding, or anything that determines a state
    of the game automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence is mandatory for each and every game. It should imply
    a mathematical or physical algorithm to carry out a certain task within a domain.
  prefs: []
  type: TYPE_NORMAL
- en: Art style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A game design document also includes the style and direction of the look and
    feel. The designer may include few references as well. This gives the artist a
    headstart in thinking about the art direction. Art is the most powerful part of
    the game to attract users initially.
  prefs: []
  type: TYPE_NORMAL
- en: This section does not include the technical specification for the art. Developers
    may include a few technical directions here to optimize the asset to be used inside
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Technical reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section of a design document, all the technical references are included.
    For Android game development, this section may include a range of devices with
    minimum specification, targeting platforms, base graphics engine, development
    engine, and so on. This is a miniature version of the actual technical design
    document. When a developer or an organization chooses not to make any separate
    technical document, they mention all the tech specs in this scope.
  prefs: []
  type: TYPE_NORMAL
- en: Change log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The change log holds a history of changes in the document with versions and
    dates. This serves the same purpose as any change log documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Other styles and standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard mentioned in the previous sections defines the general process
    of making a game. We will discuss a few of these processes that are used widely
    in the game development industry.
  prefs: []
  type: TYPE_NORMAL
- en: Most large-scale organizations follow a certain project management and tracking
    system. This may make the development process slower, but effective enough to
    minimize risk and improve game quality. A few small organizations or individual
    developers do not follow such processes in order to finalize the product as early
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: These styles are opposite to each other, and have different consequences. However,
    it is recommended that you follow a procedure that helps in the long run. A quick
    fix cannot be a permanent solution.
  prefs: []
  type: TYPE_NORMAL
- en: One more commonly used practice is patching code to resolve bugs. This is also
    extremely vulnerable to threats such as project crash, deadline failure, and creation
    of a major bug. In game development, the most common problem is a device crashing,
    which is least expected on any hardware platform. In most of the cases, it happens
    because of handling exceptions badly.
  prefs: []
  type: TYPE_NORMAL
- en: It is very necessary to play and understand games to make games. Most game development
    organizations encourage developers to play and study games. For Android developers
    also, it is very good practice to play a lot of games from different platforms.
    It is already established that Android is the best mobile or small-scale hardware
    operating system. It has its foot in large-scale platforms as well. Being an Android
    developer, it is always a good practice to keep an eye on other platforms' features
    and development and try to implement them in Android. It is the job of the Android
    game research and development team.
  prefs: []
  type: TYPE_NORMAL
- en: Different styles for different development engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed a few development tools and engines. The current gaming
    industry does not encourage the development of a game only for a specific hardware
    or operating platform. We can find a lot of games that are platform exclusive,
    but this implies a business decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite obvious that the same development is not applicable on every development
    engine. For example, the development style in native Android will differ from
    the development style in the Unity3D game engine. The basic reasons are:'
  prefs: []
  type: TYPE_NORMAL
- en: Different programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different work principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different target platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different programming languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each and every programming language has its own style and structure of programming.
    Developing games with Android NDK through C++ is not the same as making games
    in Android SDK using Java. Developing games using third-party cross-platform engines
    is also different.
  prefs: []
  type: TYPE_NORMAL
- en: We are not talking about the syntactical difference here. It is about the coding
    style. Using C++ for Android NDK is different from using C++ for Unreal Engine
    4 or Cocos2d-x. Although the C++ core library remains the same, each tool guides
    the developer to a different direction of styles to get the best result.
  prefs: []
  type: TYPE_NORMAL
- en: Not only C++ and Java, but also C#, Python, JavaScript, Lua, Boo, and so on
    are being used in the gaming industry. Many of the engines support multiple programming
    languages to attract maximum developers.
  prefs: []
  type: TYPE_NORMAL
- en: Different work principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different game engines or game making tools follow different working principles.
    A developer should be flexible enough to become accustomed to these different
    systems. There are always different code structures, folder structures, and program
    hierarchies for different engines.
  prefs: []
  type: TYPE_NORMAL
- en: For native development, it is the developer who sets the standard. Engines come
    with an integral set of standards, and it is expected that all the developers
    working on that particular engine will follow the same principle.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the work principle of Unity3D is far different to Unreal Engine
    or Cocos2d-x. Cocos2d-x does not support visual programming, whereas Unreal Engine
    Blueprint has full visual programming support. So, the development approach must
    be different despite having the same deployment target.
  prefs: []
  type: TYPE_NORMAL
- en: Different target platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern age cross-platform game development tools have already minimized the
    difference in style and standard. However, for a very few tools, the style and
    standard is still different.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we talk only about Android here, then consider the different hardware
    platforms on it. Development style does not always mean programming. It is about
    maintaining the complete project, starting from design to deployment. Android
    console development is different from Android mobiles.
  prefs: []
  type: TYPE_NORMAL
- en: From the gameplay point of view, the general style of design varies with play
    session time, control, and look. An average session on a console may last up to
    2 hours, whereas mobile session length is almost 5 percent of that. A touch interface
    is far different from a key interface, which also differs from a game controller
    interface. So, even if the developer plans to deploy the same game made with the
    same engine, the style of designing the interface changes for very obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Industry best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although there are plenty of styles and standards out there, most developers
    like to maintain some common standards to create stability in the game development
    procedure. Let''s discuss some of these area of standards commonly practiced by
    the industry:'
  prefs: []
  type: TYPE_NORMAL
- en: Design standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design and concepts vary for every game. The best design standard practice is
    to make it properly documented along with scope for improvement. The document
    must be clear enough for the users to understand. No matter what the concept is,
    developers cannot implement it without a proper understanding of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: The design scope must not be so widely open that it can change the entire game;
    this causes serious delay in production time. However, it should always have a
    limited scope to improve the production time over time with ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Design must specify the target genre and audience along with a valid reason.
    This should also include probable target hardware platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For Android development, mobile gaming is the largest industry in the present
    day. So, most Android developers mainly have their focus on mobile games. However,
    designers should always leave scope for the game to be deployed on other platforms,
    such as wearables, consoles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Programming standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programming is the execution of the design. It is the most significant part
    of the production of any game. A standard piece of code should be readable, modular,
    and properly documented. Previously, there were two programming approaches: procedural
    and object-oriented. In the case of the modern day gaming industry, developers
    follow an object-oriented approach. For this reason, programming standards have
    changed a lot. Previously, it was common practice to use `m_` and `l_` as prefixes
    to variables to indicate their status in the object-oriented structure. There
    were a few other notations such as `i`, `f`, and `b` and so on to indicate variable
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern day standards follow mainly the Camel and Pascal casing system for their
    naming convention. Common practice is to use Pascal casing for all classes, interfaces,
    enums, events, structures, namespaces, and method names, and other elements should
    use the Camel casing system.
  prefs: []
  type: TYPE_NORMAL
- en: Camel casing in programming language means that the first letter of a name should
    be in lowercase, which is specifically **Lower CamelCase**. The Pascal casing
    system states that the first letter should be capitalized, which is termed **Upper
    CamelCase**.
  prefs: []
  type: TYPE_NORMAL
- en: There is no limitation technically to the number of arguments in a method or
    the number of words per line while programming in any language. However, common
    industry practice says that the number of arguments should be within eight, and
    the number of letters per line of coding should not exceed 20.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this manual limitation is to have less complexity and better
    readability of the code. For the same reason, a method body should be limited
    to 200 lines, and a split class structure is always preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Testing standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is the validation process for the implementation of the design. Testing
    also checks the development standard, and it also ensures the quality of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, there are mainly two parts of testing procedure involved, automated
    testing and manual testing. The programmer must write the automated testing code
    for checking the core development. This part is called the test code, which must
    not be included in the main development project. It requires dedicated testers
    to carry out manual testing. Their job is to ensure the quality of the game from
    the user point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Most game development companies follow a checklist for the testing procedure.
    This checklist often contains defined test cases. Test cases are mainly defined
    by the developer and designer, and testers need to execute these cases. We will
    discuss testing in detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any software development must follow a certain protocol and standard. Game development
    is not an exception. Following a standard helps the product sustain for a longer
    period of time. The modern age Android game life cycle includes many updates after
    launch, and in many cases the game sustains for years. For an organization, the
    same developer might not be working on the same game for a long period time, which
    is a very common scenario in the game industry.
  prefs: []
  type: TYPE_NORMAL
- en: The development project must be readable enough to be adopted by new developers
    and be flexible enough to accommodate new changes for updates to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's summarize the mandatory tasks, which are common in the Android
    game development industry. Game developers should follow the game development
    principles. First, they must create a proper game design document to make it easy
    for programmers and artists to understand clearly. Then, they should create a
    proper technical design document to supply all the possible technical information
    to programmers and game engineers. A specific development process in an organization
    defines and maintains development standards. Programmers must write code in modules
    to avoid future changes and to increase the reusability of codes. A proper naming
    convention always helps in understanding the code better, and prepares it for
    easy editing and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Another practice that a game developer should follow to make games is to play
    and enjoy a lot of games.
  prefs: []
  type: TYPE_NORMAL
