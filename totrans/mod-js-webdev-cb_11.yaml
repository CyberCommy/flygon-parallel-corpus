- en: Creating Mobile Apps with React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'n this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting things up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding development tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using native components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting to devices and orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling and laying out your components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we showed you how to use `React` to build web applications,
    and in this chapter, we'll use a close relative, `React Native`, to develop native
    apps that you can run on Android and iOS (Apple) phones.
  prefs: []
  type: TYPE_NORMAL
- en: Setting things up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For development of mobile apps, there are several possible approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use native languages*, with possibilities such as Java or Kotlin for Android,
    or Objective C or Swift for iOS, using the native development tools for each platform.
    This can make sure that your app has the best fit for different phones, but will
    require multiple teams of developers, each with experience of a specific platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use a pure website* that the user can visit with the phone''s browser. This
    is the simplest solution, but the application will have limitations, such as not
    being able to access most of the phone''s features because they cannot be used
    in HTML. Also, running with a wireless connection, which may vary in strength,
    can sometimes prove hard. You can use any framework for this development, such
    as `React`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Develop a hybrid application*, which is a web page, bundled with a browser
    that includes a set of extensions so that you can use the phone''s internal features.
    For the user, this is a single standalone application, which runs even without
    a web connection, and that can use most of the phone''s features. These applications
    frequently use Apache Cordova, or a derived product, PhoneGap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a fourth style, provided by `React Native`, which was developed by Facebook,
    along the lines of the existing `React`. Instead of rendering components to a
    browser's DOM, `React Native` (which, from now on, we'll shorten to *RN*) invokes
    native APIs to create internal components that are handled through your JS code.
    There are some differences between the usual HTML elements and RN's components,
    but they are not too hard to overcome. With this tool, you are actually building
    a native app that looks and behaves exactly as any other native application, except
    that you use a single language, JS, for both Android and iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll set up a RN application so that we can start trying our
    hand at developing apps for mobile phones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three ways to set up a RN application: completely manually, which
    you won''t want to do; secondly, with packages, using the `react-native-cli` command-line
    interface; or lastly, by using a package very similar to what we already used
    for `React`, `create-react-native-app` (from now on, we''ll refer to this as *CRAN*).
    A key difference between the two packages is that with the latter, you cannot
    include custom native modules, and if you need to do so, you''ll have to *eject*
    the project, which will also require setting up several other tools.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the two latter methods at [https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html),
    and if you want to be prepared for ejecting, go to [https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by getting a command-line utility, which will include plenty of other
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we can create and run a simple project with just three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You're set! Let's see how it works—and yes, we still have some more configuration
    to do, but it's good to check whether things are going well so far.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run your app, it starts a server at your machine, at port `19000`
    or `19001`, to which you will connect using the `Expo` application, which you
    can find at [https://expo.io/learn](https://expo.io/learn), available for both
    Android or iOS. Install it by following the instructions onscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/515f38da-eefb-46bc-9cea-c7b4cf0818d0.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial screen you get when you fire up your app
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the `Expo` app for the first time, it will look like the following
    screenshot. Note that both the phone and your machine must be in the same local
    network, and your machine must also allow connections to ports `19000` and `19001`;
    you may have to modify your firewall for this to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8954ddfd-4485-4498-a9a4-5800a256674b.png)'
  prefs: []
  type: TYPE_IMG
- en: On loading the Expo app, you'll have to scan the QR code in order to connect
    to the server
  prefs: []
  type: TYPE_NORMAL
- en: 'After you use the Scan QR Code option, there will be some synchronization,
    and soon you''ll get to see your basic code running with no problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3283acff-a484-42cc-9944-4631a406b48b.png)'
  prefs: []
  type: TYPE_IMG
- en: Success—your code is up and running!
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if you modify the `App.js` source code, the changes will be immediately
    reflected in your device, which means all is well! To make sure this happens,
    shake the phone to enable the debugging menu, and make sure that Live Reload and
    Hot Reloading are enabled. You''ll also require Remote JS Debugging for later.
    Your phone should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61a0ed6-b6f7-43ed-b90e-13d4a50bd516.png)'
  prefs: []
  type: TYPE_IMG
- en: These settings enable reloading and debugging
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using the `Expo` client, CRAN lets you develop for iOS, even if you don't
    own an Apple computer. (You cannot develop for Apple systems if you have a Windows
    or Linux machine; you must have a MacBook or similar; this is a restriction of
    Apple's.) Also, working on an actual device is better in some ways, because you
    can actually see what the final user will see—no question about it.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be a couple of reasons why you would want to work differently,
    perhaps with an emulator on your computer that simulates real-life devices. Firstly,
    it may be difficult for you to get a dozen or so of the most popular devices in
    order to test your application on each of them. Secondly, it's more convenient
    to work on your own machine only, where you can easily debug, take screenshots,
    copy and paste, and so on. So, you could install Xcode or the Android SDK to enable
    yourself to work with emulated machines.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be going into details here, because there are a lot of combinations
    depending on your development OS and the target OS; rather, let's point you to
    the documentation at [https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html),
    where you should click on Building Projects with Native Code, and see what's needed
    in order to work with emulators. After having installed them, you will need the
    `Expo` client (as for your actual device) and then you'll be able to run your
    code on your own machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, take a look at the Android emulator simulating a Nexus 5 in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58237379-2a4d-4820-8922-7acf6d4ec249.png)'
  prefs: []
  type: TYPE_IMG
- en: An emulated Nexus 5 running Android, directly on your screen
  prefs: []
  type: TYPE_NORMAL
- en: 'With this emulator, you have exactly the same functionality as with an actual
    device. For example, you can also get the debugging menu, though opening it will
    be different; for example, on my Linux machine, I needed to press *Ctrl* + *M*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89419e1a-12c7-44da-92af-4c5e72d9d213.png)'
  prefs: []
  type: TYPE_IMG
- en: All the functionality that is available on your phone is also available with
    emulated devices
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Android Virtual Device** (**AVD**) manager, you can create lots
    of different emulators for phones and tablets; you get similar functionality with
    Xcode, though that will only work on macOS computers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's now get a better configuration going. As in previous chapters, we
    want to have ESLint for code checking, `Prettier` for formatting, and `Flow` for
    data types. CRAN takes care of including `Babel` and `Jest`, so we won't have
    to do anything for those two.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As opposed to what happened with `React`, where we had to add a special `rewiring`
    package in order to work with specific configurations, in RN, we can just add
    some packages and configuration files, and we'll be ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For ESLint, we''ll have quite a list of packages we want. We used most of them
    in `React`, but there''s a special addition, `eslint-plugin-react-native`, which
    adds a few RN-specific rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about the (actually few) extra rules added by `eslint-plugin-react-native`,
    check out its GitHub page at [https://github.com/Intellicode/eslint-plugin-react-native](https://github.com/Intellicode/eslint-plugin-react-native).
    Most of them have to do with styles, and one is applied for platform-specific
    code, but we'll get to this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll require a separate `.eslintrc` file, as we did with `React`. The appropriate
    contents includes the following, and I''ve highlighted the RN-specific additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having completed that, `ESLint` is set to recognize our code, but we have to
    configure `Flow` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have to add a couple of lines to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to initialize the working directories of `Flow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the same `.flowconfig` files that we used earlier for React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are now set to use `Flow`, so we can keep working in the style we were accustomed
    to—we just have to add `Prettier` to format our code, and we'll be on our way!
  prefs: []
  type: TYPE_NORMAL
- en: Adding Prettier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s not much to re-installing `Prettier`, and all we need is a `npm` command,
    plus the `.prettierrc` file we''ve been working with. For the former, just use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For configuration, we can use the contents of this `.prettierrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are set! We can check it's working; let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check that everything is OK. We''ll start by looking at the `App.js`
    file that was created by CRAN, and we can immediately verify that the tools work—because
    a problem is detected! Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66dd3473-9ef7-42f3-a8e2-f0a6a54816e6.png)'
  prefs: []
  type: TYPE_IMG
- en: We can verify that ESLint integration is working, because it highlights a problem
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule that fails is a new one, from `eslint-plugin-react-native`: `no-color-literals`,
    because we are using constants in styling, which could prove to be a maintenance
    headache in the future. We can solve that by adding a variable, and we''ll use
    a type declaration to make sure `Flow` is also running. The new code should be
    as follows—I''ve highlighted the required changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have restored all our tools, we can get started with actual
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Using native components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with RN is very much like working with `React`—there are components,
    state, props, life cycle events, and so on—but there is a key difference: your
    own components won''t be based on HTML, but on specific RN ones. For instance,
    you won''t be using `<div>` elements, but rather `<View>` ones, which will be
    then mapped by RN to a `UIView` for iOS, or to an `Android.View` for Android.
    Views can be nested inside views, just as `<div>` tags can be. Views support layout
    and styling, they respond to touch events and more, so they are basically equivalent
    to `<div>` tags, leaving aside the mobile environment behaviors and specifics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more differences: components also have different properties than
    the HTML ones, and you''ll have to go through the documentation (at [https://facebook.github.io/react-native/docs/components-and-apis](https://facebook.github.io/react-native/docs/components-and-apis))
    to learn about all the possibilities for each specific component.'
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to using the components that RN provides you with. You can
    extend your project by using native components developed by other people; for
    this, a top notch source is the Awesome React Native list, at [http://www.awesome-react-native.com/](http://www.awesome-react-native.com/).
    Note that it's likely that you'll have to eject your project in order to do this,
    so check [https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by going over the list of RN components and APIs you may want
    to use, and afterward, we''ll move to some actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RN Component** | **Replaces...** | **Objective** |'
  prefs: []
  type: TYPE_TB
- en: '| `ActivityIndicator` | animated GIF | A component to display a circular loading
    indicator |'
  prefs: []
  type: TYPE_TB
- en: '| `Button` | `button` | A component to handle touches (clicks) |'
  prefs: []
  type: TYPE_TB
- en: '| `DatePickerAndroid` `TimePickerAndroid` | `input type="date"` `input type="time"`
    | An API that shows a popup where you can enter a date and a time; for Android
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DatePickerIOS` | `input type="date"` `input type="datetime-local"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input type="time"` | A component where the user can enter a date and time;
    for iOS |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `FlatList` | - | A list component that only renders elements that are visible;
    used for performance gains |'
  prefs: []
  type: TYPE_TB
- en: '| `Image` | `img` | A component to display an image |'
  prefs: []
  type: TYPE_TB
- en: '| `Picker` | `select` | A component to pick a value from a list |'
  prefs: []
  type: TYPE_TB
- en: '| `Picker.Item` | `option` | A component to define values for the list |'
  prefs: []
  type: TYPE_TB
- en: '| `ProgressBarAndroid` | - | A component to show activity; for Android only
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ProgressViewIOS` | - | A component to show activity; for iOS only |'
  prefs: []
  type: TYPE_TB
- en: '| `ScrollView` | - | Scrolling container that may contain multiple components
    and views |'
  prefs: []
  type: TYPE_TB
- en: '| `SectionList` | - | Similar to `FlatList`, but allows for sectioned lists
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Slider` | `input type="number"` | A component to select a value from a range
    of values |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusBar` | - | A component to manage the app status bar |'
  prefs: []
  type: TYPE_TB
- en: '| `StyleSheet` | CSS | Apply styling to your app |'
  prefs: []
  type: TYPE_TB
- en: '| `Switch` | `input type="checkbox"` | A component to accept a Boolean value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | - | A component to display text |'
  prefs: []
  type: TYPE_TB
- en: '| `TextInput` | `input type="text"` | A component to enter text using the keyboard
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TouchableHighlight` `TouchableOpacity` | - | Wrapper to make views respond
    to touches |'
  prefs: []
  type: TYPE_TB
- en: '| `View` | `div` | A basic structural feature for your app |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualizedList` | - | An even more flexible version of `FlatList` |'
  prefs: []
  type: TYPE_TB
- en: '| `WebView` | `iframe` | A component to render web content |'
  prefs: []
  type: TYPE_TB
- en: 'There are also many APIs that you may be interested in; some of them are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Alert` | Displays an alert dialog with the given title and text |'
  prefs: []
  type: TYPE_TB
- en: '| `Animated` | Simplifies creating animations |'
  prefs: []
  type: TYPE_TB
- en: '| `AsyncStorage` | An alternative to `LocalStorage` |'
  prefs: []
  type: TYPE_TB
- en: '| `Clipboard` | Provides access for getting and setting clipboard content |'
  prefs: []
  type: TYPE_TB
- en: '| `Dimensions` | Provides access to the device dimensions and orientation changes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Geolocation` | Provides access to geolocation; available only for ejected
    projects |'
  prefs: []
  type: TYPE_TB
- en: '| `Keyboard` | Allows control of keyboard events |'
  prefs: []
  type: TYPE_TB
- en: '| `Modal` | Displays content above a view |'
  prefs: []
  type: TYPE_TB
- en: '| `PixelRatio` | Provides access to the device pixel density |'
  prefs: []
  type: TYPE_TB
- en: '| `Vibration` | Allows control of device vibration |'
  prefs: []
  type: TYPE_TB
- en: To have as few problems as possible, you might prefer to eschew platform-specific
    components and APIs, and make do with the generic, compatible components. However,
    if you are determined to use some Android or iOS-specific elements, have a look
    at [https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code)
    for details on how to do it; it's not complex. Remember, however, that this will
    become harder to maintain, and will probably change some interactions or screen
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s revisit an example we wrote for `React` in [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml),
    *Developing with React*, the countries and regions page, which will also let us
    use `Redux` and async calls, as in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*. Since we are using `PropTypes`, we''ll need that
    package. Install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll have to reinstall some packages, starting with `Redux` and relatives.
    Actually, CRAN already includes `redux` and `react-redux`, so we don''t need those,
    but `redux-thunk` isn''t included. If you had created the project in a different
    fashion, without using CRAN, you would have needed to install all three packages
    manually. In both cases, the following command would do, because `npm` won''t
    install an already installed package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also be using `axios` for async calls, as we did earlier in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By default, RN provides `fetch` instead of `axios`. However, RN includes the
    `XMLHttpRequest` API, which allows us to install `axios` with no problems. For
    more on network handling, check out [https://facebook.github.io/react-native/docs/network](https://facebook.github.io/react-native/docs/network).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final step will be to run the server code that we wrote back in [Chapter
    4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml), *Implementing RESTful Services
    with Node*, so that our app will be able to do async calls. Go to the directory
    for that chapter, and just enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we're set! Let's now see how we can modify our code to make it appropriate
    for RN.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since RN uses its own components, your HTML experience will be of little use.
    Here, we''ll see some changes, but in order to derive the full benefits of all
    of RN''s possibilities, you''ll have to study its components on your own. Let''s
    start with the `<RegionsTable>` component, which was rather simple. We saw its
    original code in the *Defining Components* section of [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml),
    *Developing with React*; here, let''s focus on the differences, which are all
    constrained to the `render()` method. Earlier, we use `<div>` tags and displayed
    texts in them; here, with RN, we''re required to use the `<View>` and `<Text>`
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there are no changes in the rest of the component, and all your
    `React` knowledge is still valid; you just have to adjust the output of your rendering
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll change the `<CountrySelect>` component to use `<Picker>`, which
    is sort of similar, but we''ll require some extra modifications. Let''s take a
    look at our component, highlighting the parts where changes are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lots of changes! Let''s go through them in the order they occur:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An unexpected change: if you want a `<Picker>` component to display its current
    value, you must set its `selectedValue` property; otherwise, even if the user
    selects a country, the change won''t be seen onscreen. We''ll have to provide
    an extra prop, `currentCountry`, which we''ll get from the store, so we can use
    it as the `selectedValue` for our list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fired event when the user selects a value is also different; the event handler
    will be called directly with the chosen value, instead of with an event from which
    to work with `event.target.value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to replace the `<select>` element with `<Picker>`, and provide a `prompt`
    text prop that will be used when the expanded list is shown onscreen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to use `<Item>` elements for the individual options, noting that the
    `label` to be displayed is now a prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s not forget the change when connecting the list of countries to the store;
    we''ll only have to add an extra property to the `getProps()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do is see how the main app is set up. Our `App.js` code
    will be quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward. The rest of the setup will be in the `main.js`
    file, which has some interesting details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the usage of `<View>` wherever we would previously have used `<div>`
    (a change to which you should already have gotten used to), there''s an added
    detail: we don''t want the status bar to show, so we use the `<StatusBar>` element,
    and make sure to hide it.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, that's it! When writing code for RN, at first you'll have to make some effort
    to remember what elements are the equivalent of your old and familiar HTML ones,
    and which props or events change, but aside from that, all your previous knowledge
    will still be valid. To finish, let's see our app running.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just for variety, instead of using my mobile phone, as I did earlier in this
    chapter, I decided to use an emulated device. After starting the application with
    `npm start`, I started my device, and soon got the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7392d569-17d1-45d7-8300-ec9aab4cc490.png)'
  prefs: []
  type: TYPE_IMG
- en: Our application, just loaded, waiting for the user to select a country
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user touches the `<Picker>` element, a popup will be displayed, listing
    the countries that were received from our Node server, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9ed4754-6e5a-417c-a381-c5a689ab6f14.png)'
  prefs: []
  type: TYPE_IMG
- en: Upon touching on the list of countries, a popup shows up so that the user can
    select the desired country
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user actually taps on a country, the `onValueChange` event is fired,
    and after calling the server, the list of regions is displayed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d672fec4-b9a2-4230-b132-7e844a4e3bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: After picking a country, the list of its regions is displayed, as in our earlier
    HTML React version
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything works, and is using native components; great! By the way, if you
    were not very sure about the `selectedValue` problem we described, just omit that
    prop, and when the user picks on a country, you''ll get a bad result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11023a1c-172f-4a30-b5ed-70782c1722d7.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some differences, such as requiring the selectedValue prop to be present,
    or otherwise the currently picked value
  prefs: []
  type: TYPE_NORMAL
- en: won't be updated—even though Brazil was selected, the picker doesn't show it
  prefs: []
  type: TYPE_NORMAL
- en: Here, we went through an example of writing RN code, and as we have seen, it
    doesn't differ much from simple `React` code, other from the fact that we don't
    get to use HTML, having us instead depending on different elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen two ways of running our code: with the `Expo` client on our mobile
    device, and with emulators on our computer. To experiment with RN, there are a
    couple of online playgrounds you may want to look at Snack, at [https://snack.expo.io/](https://snack.expo.io/),
    [and `Repl.it`, at ](https://snack.expo.io/)[https://repl.it/languages/react_native](https://repl.it/languages/react_native)[.
    In both of these environments, you can create files, edit code, and see the results
    of your experiments online.](https://snack.expo.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One final step, after getting your app to run, is to create a standalone package
    that you could ideally distribute via the Apple and Google app stores. If you
    created your application manually, then the process can get a bit complicated,
    and you''ll even require an actual macOS computer, because you won''t be able
    to build for iOS otherwise: you''ll have to read how to produce an app with `Xcode`
    or the Android developers'' kit, which can be a bit complicated. With CRAN apps,
    instead, the process can be simplified, because `Expo` provides an app building capability
    so that you won''t have to. Check out [https://docs.expo.io/versions/latest/guides/building-standalone-apps.html](https://docs.expo.io/versions/latest/guides/building-standalone-apps.html)
    for specific instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, no matter which way you decide to proceed for your build process,
    check out some of the suggestions to help ensure your app will be approved and
    well received at [https://docs.expo.io/versions/latest/guides/app-stores.html](https://docs.expo.io/versions/latest/guides/app-stores.html).
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to devices and orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed a responsive and adaptive web page back in the *Making your
    application adaptive for enhanced usability *section in [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml),
    *Enhancing Your Application*, we had to deal with the possibility that the window
    size could be changed at any moment, and our page's contents had to relocate itself
    properly. With mobile devices, the screen size won't change, but you still have
    the possibility of a rotation (changing from portrait mode to landscape, and vice
    versa), so you still have to deal with at least one change. And, of course, if
    you want to make your app look good on all devices, it's probable that you'll
    have to take into account the screen size in order to decide how to accommodate
    your contents.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at a simple technique to make your application aware
    of different device types. This technique can be easily upgraded to also cover
    specific screen dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look more at styling later; for the time being, we'll focus on getting
    the app to recognize the device type and orientation, and then in the next section,
    we'll follow up with specific style examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want our app to adapt, we have to be able to answer several questions
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell if the device is a tablet or a handset?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we learn if it's in the portrait or landscape modes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we code a component that will render differently depending on the device
    type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we make a component redraw itself automatically upon a screen orientation
    change?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go over all these questions now. Let''s first look at how we can learn
    about the device type and orientation. RN includes an API, `Dimensions`, that
    provides data that''s necessary to render the app, such as the screen dimensions.
    How can we, then, learn the device type and orientation? The second question is
    easier: since there are no square devices (at least so far!), it''s enough to
    see which of the two dimensions is bigger—if the height is bigger, then the device
    is in portrait mode, and otherwise it''s in landscape mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question, however, is harder. There''s no strict rule that defines,
    in terms of screen sizes, where handsets end and where tablets start, but if we
    look at information on devices and calculate form factors (the ratio of the longest
    side to the shortest side), a simple rule appears: if the calculated ratio is
    1.6 or below, it''s more likely a tablet, and higher ratios suggest handsets.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need more specific data, check [http://iosres.com/](http://iosres.com/)
    for information on iOS devices, or [https://material.io/tools/devices](https://material.io/tools/devices)
    and [http://screensiz.es](http://screensiz.es) for a larger variety of devices,
    in particular for Android, which is used on devices with a much greater variety
    of screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following code, we basically return all the information provided by `Dimensions`,
    plus a couple of attributes (`.isTablet` and `.isPortrait`) to simplify the coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding code, we have all we'd need to draw a view in a manner that
    is suitable for all kinds of devices, sizes, and both possible orientations—but
    how would we use this data? Let's look at this now, and make our app adjust properly
    in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: For more on the `Dimensions` API, read [https://facebook.github.io/react-native/docs/dimensions](https://facebook.github.io/react-native/docs/dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could directly use the information provided by `getDeviceData()` in our
    components, but that would pose some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The components would not be as functional as before, because they would have
    a hidden dependency in the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, testing components would then become a bit harder, because we'd
    have to mock the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, it wouldn't be so easy to set the components to re-render
    themselves when the orientation changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution for all of this is simple: let''s put the device data in the store,
    and then the relevant components (meaning those that need to change their way
    of rendering) can be connected to the data. We can create a simple component to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The component won''t be seen onscreen, so we can add it to our main view anywhere.
    Connecting the component is the other necessary step; when the `onLayout` event
    fires (meaning the device''s orientation has changed), we''ll have to dispatch
    an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to define both the actions and the reducer, as well as the
    store. Let''s look at how to do this—we''ll begin with the actions. The very minimum
    we''d need (apart from other actions needed by our hypothetical app) would be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are exporting a thunk that will include the `deviceData` in it. Note that
    by allowing it to be provided as a parameter (or a default value being used instead,
    created by `getDeviceData()`), we will simplify testing; if we wanted to simulate
    a landscape tablet, we'd just provide an appropriate `deviceData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the reducer would look like the following (obviously, for a real app,
    there would be many more actions!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have our device information in the store, we can study how to
    code adaptive, responsive components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how to code adaptive and responsive components by using a very basic
    component that simply displays whether it''s a handset or a tablet, and its current
    orientation. Having access to all of the `deviceData` objects means that we can
    take any kind of decisions: what to show, how many elements to display, what size
    to make them, and so on. We''ll be making this example short, but it should be
    clear how to expand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about the `textStyle` definition—soon we'll be getting into how
    it works, but for now I think it should be easy to accept that it defines bold,
    largish, text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given `this.props.deviceData`, we can use the `.isTablet` prop to decide which
    method to call (`.renderTablet()` or `.renderHandset()`). In those methods, we
    can then use `.isPortrait` to decide what layout to use: portrait or landscape.
    Finally—although we don''t show this in our example—we could use `.width` or `.height`
    to show more or fewer components, or to calculate the components'' sizes, and
    so on. We only need to connect the component to the store as follows, and we''ll
    be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have everything we need now; let's see it working!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have prepared a (hidden) component that responds to orientation changes
    by dispatching an action to update the store, and we know how to code a component
    that will use the device information. Our main page could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run the app on a (simulated) Nexus 5 device in portrait mode, we''d see
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/462a6b6b-3240-49e7-a2eb-49262cd0bed7.png)'
  prefs: []
  type: TYPE_IMG
- en: Our device is recognized as a handset, currently in portrait (vertical) orientation
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotating the device would produce a different view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cabcc8a-cf15-49ce-86e2-0874fd81e69c.png)'
  prefs: []
  type: TYPE_IMG
- en: When the orientation changes, the store is updated and the app re-renders itself
    appropriately
  prefs: []
  type: TYPE_NORMAL
- en: In our design, components never use the `Dimension` API by themselves—since
    they get the device information from the store, testing the components' behavior
    for different devices and orientations could be done functionally, without needing
    to mock anything.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To continue, write separate `something.handset.js` and `something.tablet.js`
    files that extend `SomethingBase` to define the `SomethingHandset` and `SomethingTablet`
    components. And, to finish, set up the `something.component.js` file that will
    be used to check whether the device is a handset or a tablet, and return either
    a `<SomethingHandset>` component or a `<SomethingTablet>` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this style, you'd use and connect `<Something>` components in your code,
    which, internally, would really be the appropriate version for the current device's
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science terms, this is called the *Factory* design pattern, where
    you are able to create an object without actually specifying its class.
  prefs: []
  type: TYPE_NORMAL
- en: Styling and laying out your components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying CSS styles to your app is not difficult, but you''ll have to un-learn
    and re-learn some of the following concepts that are just plain different in RN,
    when compared to HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: In web pages, CSS style is global, and applies to all tags; in RN, styling is
    done locally on a component-by-component basis; there is no global styling. Also,
    you don't need *selectors*, because styles are directly associated to components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no inheritance of styles: in HTML, children inherit some of their
    parent''s style by default, but in RN, if you want this to happen, you''ll have
    to provide the specific desired style to the children. However, if you wish, you
    can `export` styles and `import` them elsewhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RN styles are completely dynamic: you can use all JS functions to compute whichever
    values you wish to apply. You could even alter styles on the fly, so an app background
    color could be lighter during the day, gradually changing to darker colors at
    night, as time goes by. You won''t need anything like SASS or LESS; you can do
    math and use constants, because that''s pure JS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some other minor differences as well:'
  prefs: []
  type: TYPE_NORMAL
- en: RN uses *camelCase* style (such as `fontFamily`) instead of CSS's *kebab-case*
    style (for example, `font-family`); that's easy enough to get used to. Also, not
    all usual CSS properties may be present (it depends on specific components), and
    some may be restricted as to their possible values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RN has only two possible measurements: either percentages, or **density independent
    pixels** (**DP**). DP aren''t the classic screen pixels from the web; rather,
    they work well with every device, independently of their pixel density or **pixels
    per inch** (**ppi**), thus guaranteeing a common look for all screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layout is done with flex, so positioning elements is simpler. You may not
    have the full set of options that are available for web pages, but what you get
    is absolutely enough for any kind of layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's much to read about styling in RN (for starters, see [https://facebook.github.io/react-native/docs/style](https://facebook.github.io/react-native/docs/style)
    for an introduction, and [https://facebook.github.io/react-native/docs/height-and-width](https://facebook.github.io/react-native/docs/height-and-width)
    and [https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)
    for sizing and positioning elements), so here, in this recipe, we'll look at some
    specific examples by styling our countries-and-regions app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to enhance our app a bit. And, to complete what we earlier saw about
    adaptive and responsive displays, we are going to provide a different layout for
    portrait and landscape orientations. We won't need media queries or column based
    layouts; we'll make do with simple styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating styles for the `<Main>` component. We''ll be using
    the `<DeviceHandler>` we developed earlier; both components will be connected
    to the store. I didn''t want to do specific versions for tablets and handsets,
    but I wanted to display a different layout for portrait and landscape orientations.
    For the former, I basically used what I had developed earlier, but for the latter,
    I decided to split the screen in half, displaying the countries selector on the
    left and the regions list on the right. Oh, and you may notice that I opted to
    use inline styles, even if it''s not the preferred option; since components are
    usually short, you may place styles right in the JSX code without losing clarity.
    It''s up to you to decide whether you like it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**When the device is in portrait orientation, I created a `<View>`, occupying
    all the screen (`flex:1`) and setting its components vertically using `flexDirection:"column"`,
    although this is actually the default value, so I could have omitted this. I didn''t
    specify a size for the `<CountrySelect>` component, but I set the `<RegionsTable>`
    to occupy all possible (remaining) space. The detailed code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For the landscape orientation, some changes were required. I set the direction
    for the contents of the main view to horizontal (`flexDirection:"row"`) and I
    added two equal-sized views within. For the first, with the country list, I set
    its contents vertically and centered, because I thought it looked better that
    way, instead of appearing at the top. I didn''t do anything in particular for
    the regions list that occupies the right side of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you want a component to occupy a larger piece of space, increase its flex
    value; *flex* implies that components will flexibly expand or shrink according
    to the available space, which is shared among all components in direct proportion
    to their flex values. If I had wanted the countries list to occupy one third of
    the screen, leaving the other two thirds to the regions list, I would have set
    `flex:1` for it, and `flex:2` for the regions. Of course, you could also set heights
    and widths directly (in either DIP values or as percentages), as you could have
    done with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for distributing children in a view, apart from `"center"`, which centers
    all children in the parent view, you also have several other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"flex-start"` places them together, at the start of the parent view; here,
    it''s top, given the vertical alignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"flex-end"` would have behaved similarly, but placed the children at the end
    (here, the bottom) of the parent view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"space-between"` splits the extra space equally between the children components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"space-around"` also splits extra space equally, but includes space at the
    start and at the end of the parent view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"space-evenly"` splits all space equally between children and dividing spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting how the components will be laid out in the main flex direction,
    you can use `alignItems` to specify how the children will be aligned along the
    secondary flex direction (if `flexDirection` is `"row"`, then the secondary direction
    will be `"column"`, and vice versa). Possible values are `"flex-start"`, `"center"`,
    and `"flex-end"`, with similar meaning to what was just given, or you could use `"stretch"`,
    which will occupy all possible space.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment with these options, go to [https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)
    and modify the code examples. You'll immediately see the effects of your changes,
    which is the easiest way to understand the effects and implications of each option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s style the regions table. For this, I had to make some changes,
    starting with the need for a `<ScrollView>` instead of a plain `<View>`, given
    that the list may be too long to fit in the screen. Also, to show you some styles
    and constants, I decided to go with separate style files. I started by creating
    a `styleConstants.js` file, which defines a color constant and a simple, full-sized
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting thing here, rather than the (assumedly quite Spartan) `fullSize`
    style, is the fact that you can export styles, or define simple JS constants that
    will be used elsewhere. In the regions list, I imported both the style and the
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some interesting details here in the preceding block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: As I said before, I'm using a `<ScrollView>` component to enable the user can
    browse through lists that are longer than the available space. A `<FlatList>`
    component would also have been a possibility, though for relatively short and
    simple lists as here, it wouldn't have made much of a difference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I used the imported color to create a local style, `grayish`, which I used later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I directly applied the imported `fullSize` style to the regions' `<ScrollView>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I applied more than one style to the second `<ScrollView>`; if you provide an
    array of styles, they get applied in the order of appearance. In this case, I
    got a full-sized gray area. Note that the color is only applied if some regions
    are present; otherwise, the color is unchanged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the style can be created dynamically, and that allows for interesting
    effects. To use an example based upon one in RN''s documentation at [https://facebook.github.io/react-native/docs/stylesheet](https://facebook.github.io/react-native/docs/stylesheet),
    you could have a title changing style depending on a prop. In the following code,
    the style for the title would change depending on `this.props.isActive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You could produce even more interesting results; remember that you have the
    full power of JS available to you, and that a style sheet can be created on the
    fly, so you actually have limitless possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I fired up the emulator, and tried out the code. When in portrait orientation,
    the view is as shown in the following screenshot; note that I scrolled down, and
    the app correctly handles it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba75c98a-231f-48d8-b764-6aeb7e902262.png)'
  prefs: []
  type: TYPE_IMG
- en: Our styled application, showing colors, styles, and a scrollable view
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the device''s orientation, our device handler logic captures
    the event, and the app is rendered differently. Here, we can see the split screen,
    with centered elements on the left and the scrollable view on the right, with
    its grayish background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/959d3015-b0a8-474d-84f6-8ea1f452c282.png)'
  prefs: []
  type: TYPE_IMG
- en: The landscape view gets a different layout, courtesy of new styling rules
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen—and this was only an introduction to the many styling features
    provided by RN—you can get the same kind of results as with HTML and CSS, though
    here you are assuredly working with different elements and styles. The possibility
    of applying the full extent of JS to the definition of styles lets you forget
    about using tools such as SASS, because all the extra functionality that it would
    bring is already available through JS itself. Let's look at a further example
    of styling, this time for text, as we consider how to write code that's been specifically
    oriented to a given platform.
  prefs: []
  type: TYPE_NORMAL
- en: Adding platform-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the generic components is good enough for most development, but
    you may want to utilize some platform-specific feature, and RN provides a way
    to do so. Obviously, if you start along this trend, you may end with a bigger
    job, and it will be harder to maintain your code, but done judiciously, it can
    add some extra *pizzazz* to your app.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at how to adapt your app so that it will fit in better
    for whatever platform it runs on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to recognize your platform is by using the `Platform` module,
    which includes a property, `Platform.OS`, which tells you whether you are running
    Android or iOS. Let''s go for a simple example. Imagine you wanted to use some
    monospaced font in your app. It happens that the right name for the relevant font
    family varies between platforms: it would be `"monospace"` in Android, but `"AmericanTypewriter"`
    (among others) on Apple devices. By checking `Platform.OS`, we can set the `.fontFamily`
    attribute of a style sheet appropriately, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d66a972-1aa4-4898-b9af-64b582ac2352.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Platform.OS is the simplest way to detect the platform of the device
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to pick several attributes differently, you might want to use
    `Platform.select()` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `headings.title` and `headings.subtitle` will get the values appropriate
    to the current platform, either Android or iOS. Obviously, you could have managed
    this using `Platform.OS`, but this style may be shorter.
  prefs: []
  type: TYPE_NORMAL
- en: For more on the available font families in both Android and iOS devices, you
    may want to check the lists at [https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts).
    Take into account, however, that the list may change from version to version.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just for variety, I decided to try out platform detection in Snack (at [https://snack.expo.io/](https://snack.expo.io/);
    we mentioned this tool earlier in this chapter) because it would be much faster
    and simpler than running code on two actual devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'I opened the page, and in the sample application that is provided, I just added
    the `.fontFamily` change I showed earlier, and tested the results for both platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aeb80e4-59cd-4d07-8983-a1120078b60d.png)'
  prefs: []
  type: TYPE_IMG
- en: The Snack emulators show the different look of my app, with distinct fonts for
    Android (left) and iOS (right)
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, issues with platform differences can be easily solved, and the
    end users of your app will get something that more closely match their expectations
    regarding colors, fonts, components, APIs, and whatnot.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The changes we saw in this recipe are rather small in scope. If you wanted some
    radically bigger differences, such as, for example, getting a date by using a
    `DatePickerIOS` component for iOS, but the `DatePickerAndroid` API for Android,
    there's another feature you should consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say your own component was named `AppropriateDatePicker`. If you create
    two files, respectively named `appropriateDatePicker.component.ios.js` and `appropriateDatePicker.component.android.js`,
    then when you import your component with `import { AppropriateDatePicker } from
    "AppropriateDatePicker"`, the `.ios.js` version will be used for Apple, and the
    `.android.js` version for Android: simple!'
  prefs: []
  type: TYPE_NORMAL
- en: For a complete description of the `Platform` module and the platform-specific
    options, read [https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code).
  prefs: []
  type: TYPE_NORMAL
- en: Routing and navigating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `React` router, you just used a `<Link>` component to navigate from
    one page to another, or used methods to programmatically open a different page.
    In RN, there is a different way of working, and the `react-navigation` package
    is practically the de facto standard. Here, you define a navigator (there are
    several kinds to pick from) and provide it with the screens (views) that it should
    handle, and then forget about it! The navigator will handle everything on its
    own, showing and hiding screens, adding tabs or a sliding drawer, or whatever
    it needs, and you don't have to do anything extra!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll revisit an example from earlier pages of this book, and
    show how the router is written differently, to highlight differences in style.
  prefs: []
  type: TYPE_NORMAL
- en: There's more to navigation than what we'll see here. Check out the API documentation
    at [https://reactnavigation.org/docs/en/api-reference.html](https://reactnavigation.org/docs/en/api-reference.html)
    for more, and beware if you Google around, because the `react-navigation` package
    has evolved, and many sites have references to old methods that are currently
    deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `React` part of this book, we built a complete routing solution, including
    public and protected routes, using a login view to enter the user's name and password.
    In a mobile application, since the user is more restricted, we can just make do
    by enabling a login at the beginning, and enabling the normal navigation afterward.
    All the work with usernames, passwords, and tokens is basically the same as before,
    so for now, let's only worry about navigation, which is different in RN, and forget
    the common details.
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, let''s have some views—a empty screen with some centered text
    will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to simplify creating all the needed views, let''s have a `makeSimpleView()`
    function that will produce a component. We''ll include a *hamburger* icon at the
    top right, which will open and close the navigation drawer; we''ll see more on
    this later. We''ll use this function to create most of our views, and we''ll add
    a `SomeJumps` extra view, with three buttons that allow you to navigate directly
    to another view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, for simplicity, and given that we weren't using props or state, and that
    the view was simple enough, I used a functional definition for the `SomeJumps`
    component, instead of using a class, as in most other examples. If you want to
    revisit the concept, have a look at [https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html)[.](https://reactjs.org/docs/components-and-props.html)
  prefs: []
  type: TYPE_NORMAL
- en: Where does the `navigation` prop come from? We'll see more in the next section,
    but some explanation can be given here. Whenever you create a navigator, you provide
    it with a set of views to handle. All those views will get an extra prop, `navigation`,
    which has a set of methods you can use, such as toggling the visibility of the
    drawer, navigating to a given screen, and more. Read about this object at [https://reactnavigation.org/docs/en/navigation-prop.html](https://reactnavigation.org/docs/en/navigation-prop.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the drawer itself. This will handle the sidebar menu and
    show whatever view is needed. The `createDrawerNavigator()` function gets an object
    with the screens that will be handled, and a set of options; here, we just specified
    the color of the drawer itself and its width (there are plenty more possibilities,
    which are detailed at [https://reactnavigation.org/docs/en/drawer-navigator.html](https://reactnavigation.org/docs/en/drawer-navigator.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The result of `createDrawerNavigation()` is itself a component that will take
    care of showing whatever view is selected, showing and hiding the drawer menu,
    and so on. We only need to create the main application itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s creating our navigable application, since we now have a set of
    views and a drawer navigator to handle them. The main view for our application
    is then quite simple—check out its `.render()` method, and you''ll have to agree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting point: since navigators are components. If you so wish, you
    can have a navigator within another navigator! For example, you could create a
    `TabNavigator`, and include it in a drawer navigator: when the corresponding option
    is selected, you''ll get a tabbed view onscreen, now governed by the tab navigator.
    You can compose navigators in any way you wish, allowing for very complex navigation
    structures, if you want.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you open the application, the initial route is shown. There are several
    options you can provide, such as `initialRouteName` to specify which should be
    the first shown view, `order` to rearrange the drawer items, and even a custom
    `contentComponent` if you want to draw the contents of the drawer by yourself;
    all in all, there is lots of flexibility. Your first screen should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4eddab-0191-4acb-95df-cd124a814ce0.png)'
  prefs: []
  type: TYPE_IMG
- en: Our drawer navigator showing the initial screen
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual way to open a drawer is by sliding from the left (although you can
    also set the drawer to slide in from the right). We also provided the hamburger
    icon to toggle the drawer open and shut. Opening the drawer should look like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16b3cbf8-1530-4245-b496-879b07e55249.png)'
  prefs: []
  type: TYPE_IMG
- en: The opened drawer shows the menu, with the current screen highlighted, and the
    rest of the screen darkened
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on any menu item will hide the current view, and show the selected
    view instead. For instance, we could select the `Some jumps` screen, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb528b3-850d-4d6f-a81f-28ff8bf36299.png)'
  prefs: []
  type: TYPE_IMG
- en: After selecting an option, the drawer menu slides close on its own, and the
    selected screen is shown
  prefs: []
  type: TYPE_NORMAL
- en: In this particular screen, we show three buttons, all of which use the `props.navigation.navigate()`
    method to show a different screen. This shows that your navigation is not restricted
    to using the drawer, but that you can also directly browse in any way you want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll notice we didn''t make any reference to `Redux`, as we did in the `React`
    chapters. While use of this is possible, the `react-navigation` authors are tending
    toward *not* enabling this, and at [https://reactnavigation.org/docs/en/redux-integration.html](https://reactnavigation.org/docs/en/redux-integration.html),
    you can read the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Warning: in the next major version of React Navigation, to be released in
    Fall 2018, we will no longer provide any information about how to integrate with
    Redux and it may cease to work. Issues related to Redux that are posted on the
    React Navigation issue tracker will be immediately closed. Redux integration may
    continue to work, but it will not be tested against or considered when making
    any design decisions for the library."'
  prefs: []
  type: TYPE_NORMAL
- en: This warning suggests that it wouldn't be a good idea to devote space to an
    integration that might just go away and stop working without notice. If you want
    to integrate `Redux`, read the preceding page I mentioned, but be careful when
    you update the navigation package, just in case something stops working. You have
    been warned!**
  prefs: []
  type: TYPE_NORMAL
