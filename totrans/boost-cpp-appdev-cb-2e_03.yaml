- en: Converting and Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting numbers to strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting numbers to numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting user-defined types to/from strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting smart pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting polymorphic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing simple input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing complex input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, that we know some of the basic Boost types, it is time to get to know data-converting
    functions. In this chapter, we'll see how to convert strings, numbers, pointers,
    and user-defined types to each other, how to safely cast polymorphic types, and
    how to write small and big parsers right inside the C++ source files.
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting strings to numbers in C++ makes a lot of people depressed because
    of their inefficiency and user unfriendliness. See how string `100` can be converted
    to `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is better not to think, how many unnecessary operations, virtual function
    calls, atomic operations, and memory allocations occurred during the conversion
    from earlier. By the way, we do not need the `iss` variable any more, but it will
    be alive until the end of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'C methods are not much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Did it convert the whole value to `int` or stopped somewhere in the middle?
    To understand that we must check the content of the `end` variable. After that
    we'll have a useless `end` variable getting in the way until the end of scope.
    And we wanted an `int`, but `strtol` returns `long int`. Did the converted value
    fit in `int`?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and standard library is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a library in Boost, which will help you cope with depressing difficulty
    of string to number conversions. It is called `Boost.LexicalCast` and consists
    of a `boost::bad_lexical_cast` exception class and a few `boost::lexical_cast`
    and `boost::conversion::try_lexical_convert` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used even for non-zero-terminated strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boost::lexical_cast` function accepts string as input and converts it
    to the type specified in triangular brackets. The `boost::lexical_cast` function
    will even check bounds for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It also checks for the correct syntax of input and throws an exception if input
    is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Boost 1.56, there is a `boost::conversion::try_lexical_convert` function
    that reports errors by return code. It could be useful in performance critical
    places where bad input could often occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`lexical_cast`, just like all `std::stringstream` classes, uses `std::locale`
    and can convert localized numbers, but also has an impressive set of optimizations
    for **C locale** and for locales without number groupings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The C++ standard library has no `lexical_cast`, but since C++17 has `std::from_chars`
    functions that could be used to create amazingly fast generic converters. Note
    that those converters do not use locales at all, so they have slightly different
    functionality because of that. `std::from_chars` functions were designed to not
    allocate memory, do not throw exceptions, and have no atomic or some other heavy
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Converting numbers to strings* recipe for information about the
    `boost::lexical_cast` performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation of `Boost.LexicalCast` contains some examples, performance
    measures, and answers to frequently asked questions. It is available at [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting numbers to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will continue discussing the lexical conversions, but now
    we will be converting numbers to strings using `Boost.LexicalCast`. As usual,
    `boost::lexical_cast` will provide a very simple way to convert the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and a standard library is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s convert integer `100` to `std::string` using `boost::lexical_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare it against the traditional C++ conversion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And against the C conversion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::lexical_cast` function may also accept numbers as input and convert
    them to a string type specified as the template parameter (in triangular brackets).
    This is pretty close to what we have done in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A careful reader will notice that in case of `lexical_cast`, we have an additional
    call to string copy the constructor and that such a call degrades performance.
    It is true, but only for old or bad compilers. Modern compilers implement a **Named
    Return Value Optimization** (**NRVO**), which eliminates the unnecessary calls
    to copy constructors and destructor. Even if the C++11-compatible compilers don't
    detect NRVO, they use a move constructor of `std::string`, which is fast and efficient.
    The *Performance* section of the `Boost.LexicalCast` documentation shows the conversion
    speed on different compilers for different types. In most cases, `lexical_cast`
    is faster than the `std::stringstream` and `printf` functions.
  prefs: []
  type: TYPE_NORMAL
- en: If `boost::array` or `std::array` is passed to `boost::lexical_cast` as the
    output parameter type, less dynamic memory allocations will occur (or there will
    be no memory allocations at all, it depends on the `std::locale` implementation).
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has `std::to_string` and `std::to_wstring` functions that are declared
    in the `<string>` header. Those functions use locales and have behavior very close
    to `boost::lexical_cast<std::string>` and `boost::lexical_cast<std::wstring>`,
    respectively. C++17 has `std::to_chars` functions that convert numbers to char
    arrays amazingly fast. `std::to_chars` do not allocate memory, do not throw exception,
    and may report errors using error codes. If you need really fast conversion functions
    that do not use locales, then use `std::to_chars`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains tables that compare the `lexical_cast`
    performance against other conversion approaches. In most cases, `lexical_cast`
    is faster than other approaches [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting strings to numbers* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting user defined types to/from strings* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting numbers to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might remember situations where you were writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, programmers just ignore such warnings by implicitly casting to the
    `unsigned short` datatype, as demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But, what if `foo()` returns numbers that do not fit into `unsigned short`?
    This leads to hard detectable errors. Such errors may exist in code for years
    before they get caught and fixed. Take a look at the `foo()` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The library `Boost.NumericConversion` provides a solution for such cases. Just
    replace `static_cast` with `boost::numeric_cast`. The latter will throw an exception
    when the source value cannot be stored in target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run `test_function()`, it will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even detect specific overflow types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test_function1()` function will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`boost::numeric_cast` checks if the value of the input parameter fits into
    the new type without losing data and throws an exception if something is lost
    during conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.NumericConversion` library has a very fast implementation. It can
    do a lot of work at compile time, for example, when converting to types of a wider
    range, the source will be converted to target type by just via `static_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::numeric_cast` function is implemented via `boost::numeric::converter`,
    which can be tuned to use different overflow, range checking, and rounding policies.
    But usually, `numeric_cast` is just what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small example that demonstrates how to make our own overflow handler
    for `boost::numeric::cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how to use our custom converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Even C++17 does not have facilities for safe numeric casts. However, work in
    that direction is ongoing. We have all the chances to see such facilities after
    the year 2020.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boost''s official documentation contains detailed description of all the
    template parameters of numeric converter; it is available at the following link:
    [http://boost.org/libs/numeric/conversion](http://boost.org/libs/numeric/conversion)'
  prefs: []
  type: TYPE_NORMAL
- en: Converting user-defined types to/from strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a feature in `Boost.LexicalCast` that allows users to use their own
    types with `lexical_cast`. This feature requires from the user to write the correct
    `std::ostream` and `std::istream` operators for the type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All you need is to provide `operator<<` and `operator>>` stream operators.
    If your class is already streamable, nothing needs to be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may use `boost::lexical_cast` for conversions to and from the `negative_number`
    class. Here''s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::lexical_cast` function can detect and use stream operators to convert
    user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.LexicalCast` library has many optimizations for basic types and they
    will be triggered, when user-defined type is being cast to basic type or when
    basic type is being cast to user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `boost::lexical_cast` function may also convert to wide character strings,
    but the correct `basic_istream` and `basic_ostream` operator overloads are required
    for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Boost.LexicalCast` library is not a part of C++. A lot of Boost libraries
    use it, and I hope that it will make your life easier as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.LexicalCast` documentation contains some examples, performance measures,
    and answers to frequently asked questions; it is available at [http://boost.org/libs/lexical_cast](http://boost.org/libs/lexical_cast)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting strings to numbers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting numbers to strings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a class named `some_class`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You have a third-party API that returns constructed `derived` by shared pointer
    to `base` and accepts shared pointer to `const derived` in other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to make the following code work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How do you solve the problem in a nice manner?
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and smart pointers is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution would be to use special casts for smart pointers. In this particular
    case, we need to use `dynamic_cast` functionality, so we are using `boost::dynamic_pointer_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boost library has a lot of functions for smart pointer conversions. All
    of them accept a smart pointer and a template parameter `T`, where `T` is the
    desired template type of the smart pointer. Those conversion operator mimic the
    behavior of built-in casts while correctly managing the reference counting and
    other smart pointer internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::static_pointer_cast<T>(p)` - does `static_cast<T*>(p.get())`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::dynamic_pointer_cast<T>(p)` - does `dynamic_cast<T*>(p.get())`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::const_pointer_cast<T>(p)` - does `const_cast<T*>(p.get())`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boost::reinterpret_pointer_cast<T>(p)` - does `reinterpret_cast<T*>(p.get())`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the `boost::*_pointer_cast` functions can work with smart pointers from
    the standard library and C pointers if you include `<boost/pointer_cast.hpp>`.
  prefs: []
  type: TYPE_NORMAL
- en: In C++11, the standard library has `std::static_pointer_cast`, `std::dynamic_pointer_cast`,
    and `std::const_pointer_cast` defined in the `<memory>` header, however, it is
    only for `std::shared_ptr`. The C++17 standard library has `std::reinterpret_pointer_cast`,
    but it is only for `std::shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.SmartPointer` library documentation contains more examples on pointer
    casts for a standard library at [http://boost.org/libs/smart_ptr/pointer_cast.html](http://boost.org/libs/smart_ptr/pointer_cast.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casts reference for `boost::shared_ptr` is available at [http://boost.org/libs/smart_ptr/shared_ptr.htm](http://boost.org/libs/smart_ptr/shared_ptr.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Casting polymorphic objects* recipe in this chapter will show you a better
    way of doing dynamic casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting polymorphic objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that some programmer designed such an awful interface as follows (this
    is a good example of how interfaces should not be written):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our task is to make a function that eats bananas, and throws exceptions if something
    different came instead of banana ( `try_produce_banana()` may return `nullptr`)so
    if we dereference a value returned by it without checking we are in danger of
    dereferencing a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So we need to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Ugly, isn''t it? `Boost.Conversion` provides a slightly better solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::polymorphic_cast` function just wraps around code from the first
    example, and that is all. It checks input for null and then tries to do a dynamic
    cast. Any error during those operations will throw a `std::bad_cast` exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Conversion` library also has a `polymorphic_downcast` function, which
    should be used only for downcasts that certainly shall succeed. In debug mode
    (when `NDEBUG` is not defined), it will check for the correct downcast using `dynamic_cast`.
    When `NDEBUG` is defined, the `polymorphic_downcast` function will just do a `static_cast`
    operation. It is a good function to use in performance-critical sections, still
    leaving the ability to detect errors in debug compilations.
  prefs: []
  type: TYPE_NORMAL
- en: Since Boost 1.58 there is a `boost::polymorphic_pointer_downcast` and `boost::polymorphic_pointer_cast`
    function in `Boost.Conversion` libraries. Those functions allow you to safely
    cast smart pointers and have the same characteristics as `boost::polymorphic_cast`
    and `boost::polymorphic_downcast`.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard library lacks `polymorphic_cast` and `polymorphic_downcast`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, the `polymorphic_cast` idea was proposed in the book *The C++ Programming
    Language*, *Bjarne Stroustrup*. Refer to this book for more information and some
    good ideas on different topics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation may also be helpful; it is available at [http://boost.org/libs/conversion](http://boost.org/libs/conversion).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the previous recipe for more information on casting smart pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing simple input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a common task to parse a small text. Such situations are always a dilemma:
    shall we use some third-party professional and good tools for parsing such as
    Bison or ANTLR, or shall we try to write it by hand using only C++ and standard
    library? The third-party tools are good for handling the parsing of complex texts,
    and it is easy to write parsers using them, but they require additional tools
    for creating C++ or C code from their grammar, and add more dependencies to your
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Handwritten parsers are usually hard to maintain, but they require nothing except
    a C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start from a very simple task to parse a date in the ISO format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the examples of possible input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will need parser's grammar from the following link [http://www.ietf.org/rfc/rfc333:](http://www.ietf.org/rfc/rfc3339.txt:)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that you are familiar with the placeholder's concept or read the *Reordering
    parameters of function* and *Binding a value as a function parameter* recipes
    in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd), *Starting
    to Write Your Application*. Basic knowledge of parsing tools would be good.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me introduce to you a `Boost.Spirit` library. It allows writing parsers
    (as well as lexers and generators) directly in C++ code, which are immediately
    executable (do not require additional tools for C++ code generation). Grammar
    of `Boost.Spirit` is very close to **Extended Backus-Naur Form** (**EBNF**), which
    is used for expressing grammar by many standards and understood by other popular
    parsers. Grammar at the beginning of this chapter is in EBNF:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to make a `date` structure to hold the parsed data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the parser (step-by-step description of how it works can be
    found in the next section):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may use this parser wherever we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a very simple implementation; it does not check the count of digits
    for numbers. Parsing occurs in the `boost::spirit::qi::parse` function. Let''s
    simplify it a little bit, removing the actions on successful parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `first` argument points to the beginning of data to parse. It must be a
    nonconstant variable because the `parse` function will modify it to point to the
    end of the parsed sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `end` argument points to the position that goes after the last element to
    parse. `first` and `end` shall be iterators or pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument to the function is a parsing rule. It looks exactly like
    the EBNF rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We just replaced white spaces with the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `parse` function returns `true` on success. If we want to make sure that
    the whole string was successfully parsed, we need to check for the parser's return
    value and equality of the `end` and modified `first` iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to deal with actions on successful parse and this recipe will be
    over. Semantic actions in `Boost.Spirit` are written inside `[]` and they can
    be written using function pointers, function objects, `boost::bind`, `std::bind`
    (or the other `bind()` implementations), or C++11 lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you could also write a rule for `YYYY` using C++11 lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You cannot put the lambda definition directly inside the `[]` because the C++
    compiler will think that it's an attribute. As a workaround, you can make an `auto`
    variable with the lambda function in it and use that variable in parser rule description
    (just like it was done in the preceding code snippet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the month''s semantic action closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For those who read the book from the beginning, the preceding code reminds about
    `boost::bind`, `boost::ref`, and placeholders. `ref(res.month)` means pass `res.month`
    as a modifiable reference and `_1` means the first input parameter, which would
    be a number (result of `ushort_` parsing).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s modify our parser, so it could take care of the digits count. For
    that purpose, we will take the `unit_parser` class template and just set up the
    correct parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if those examples seem complicated. The first time I was also frightened
    by `Boost.Spirit`, but now it really simplifies my life. You are extremely brave,
    if this code does not scare you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not write parsers in header files because it increases compilation times
    of your project. Write parsers in source files and hide all the `Boost.Spirit`
    internals in that file. If we adjust the previous example to follow that rule
    then the header file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Also take care of iterator types passed to the `boost::spirit::parse` function.
    The less different types of iterators you use, the less size of binary you get.
  prefs: []
  type: TYPE_NORMAL
- en: If you are now thinking that parsing date was simpler to implement by hand using
    standard library, you are right! But only for now. Take a look at the next recipe,
    it will give you more examples on `Boost.Spirit` usage and extend this example
    for cases, when writing parser by hand is harder than using `Boost.Spirit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.Spirit` library is not a part of C++ and would not be proposed for
    inclusion in the nearest future. However, it works pretty well with modern C++
    features, so use them if your compiler supports C++11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reordering parameters of function* recipe in [Chapter 1](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Binding a value as a function parameter* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Spirit` is a huge header-only library. A separate book may be written
    about it. Feel free to use its documentation at [http://boost.org/libs/spirit.](http://boost.org/libs/spirit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing complex input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we were writing a simple parser for date. Imagine that
    some time has passed and the task has changed. Now, we need to write a date-time
    parser that supports multiple input formats and zone offsets. Our parser must
    understand the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using the `Boost.Spirit` library, which was described in the *Parsing
    simple input* recipe. Read it before getting hands on with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by writing a date-time structure that will hold a parsed result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a function for setting the zone offset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing a parser can be split into writing a few simple parsers. We start with
    writing a zone-offset parser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s finish our example by writing the remaining parsers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very interesting variable here is `boost::spirit::qi::rule<const char*, void()>`.
    It erases the exact type of a resulting parser and allows you to write parsers
    for recursive grammars. It also allows you to write parsers in source files and
    export them to headers without significantly affecting compilation times of your
    project. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that this class implies optimization barrier for compilers, so do not use
    it when it is not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we used `>> '':''` instead of `>> char_('':'')`. The first approach
    is more limited: you cannot bind actions to it and cannot do new rules by just
    combining chars (for example, you cannot write `char_(''+'')|char_(''-'')` without
    using `char_` at all). But for better performance use the first approach, because
    some compilers may optimize it slightly better.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can make our example slightly faster by removing the `rule<>` objects that
    do type erasure. Just replace them with the C++11 `auto` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Spirit` library generates very fast parsers; there are some performance
    measures at the official site. Official documentation contains advanced recommendations
    for writing faster parsers.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of `boost::phoenix::bind` is not mandatory, but without it the rule
    that parses specific zone offset in `timezone_parser` will be dealing with the
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::fusion::vector<char, unsigned short, unsigned short>` type. Using `bind(&set_zone_offset,
    ref(ret), _1, _2, _3)` seems to be a more reader-friendly solution.'
  prefs: []
  type: TYPE_NORMAL
- en: When parsing big files, consider reading the *Fastest way to read files* recipe
    in [Chapter 11](part0569.html#GUKG20-712b4ba1126a4c7c89e1d44de61b4bdd), *Working
    with the System*, because incorrect work with files may slow down your program
    much more than parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the code that uses the `Boost.Spirit` (or `Boost.Fusion`) library
    may take a lot of time, because of the huge amount of template instantiations.
    When experimenting with the `Boost.Spirit` library use modern compilers, they
    provide better compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Spirit` library is worth writing a separate book, it's impossible
    to describe all of its features in a few recipes, so referring to the documentation
    will help you to get more information about it. It is available at [http://boost.org/libs/spirit](http://boost.org/libs/spirit)
    . There, you'll find much more examples, ready parsers, and information on how
    to write lexers and generators directly in C++11 code using Boost.
  prefs: []
  type: TYPE_NORMAL
