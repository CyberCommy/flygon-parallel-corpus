- en: Error Handling and Fault Tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is hard to overestimate the importance of error handling in regards to embedded
    software. Embedded systems should work without supervision in varying physical
    conditions, such as controlling external peripheral devices that may fail over
    or not always provide reliable communication lines. And in many cases, a failure
    of the system is either expensive or plain unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about common strategies and best practices that
    will help you write reliable and fault-tolerant embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with error codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constant references when catching exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tackling static objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with watchdogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring heartbeats for highly available systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing software debouncing logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These recipes will help you understand the importance of error handling design,
    learn best practices, and avoid pitfalls in this domain.
  prefs: []
  type: TYPE_NORMAL
- en: Working with error codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a new function, developers often need a mechanism to indicate
    that the function can't accomplish its work because of some kind of error. It
    might be invalid, an unexpected result being received from a peripheral device,
    or a resource allocation issue.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most traditional and widespread ways to report an error condition
    is through error codes. This is an efficient and ubiquitous mechanism that does
    not depend on the programming language or the operating system. Due to its efficiency,
    versatility, and ability to cross various platform boundaries, it is highly used
    in embedded software development.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a function interface that returns either a value or an error code
    may be tricky, especially if the value and the error code have different types. In
    this recipe, we will explore several approaches to designing such types of function
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a simple program with three implementations of a function
    called `Receive`. All three implementations have identical behavior but a different
    interface. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `errcode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `errcode.cpp` in the `errcode` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the implementation of the first function to the `errcode.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the second implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The third implementation of the `Receive` function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define a helper function called `Display` to display a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a function called `Test` that invokes all three implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function ties everything together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we defined three different implementations of a function
    that receives data from some device. It should return the received data as a string,
    but in the case of an error, it should return an integer error code representing
    the reason for the error.
  prefs: []
  type: TYPE_NORMAL
- en: Since the result and the error code have different types, we can't reuse the
    same value for both. To return multiple values in C++, we either need to use output
    parameters or create a compound data type.
  prefs: []
  type: TYPE_NORMAL
- en: Our implementations explore both these strategies. We use C++ function overloading
    to define the `Receive` function with the same name, but different types of arguments
    and return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first implementation returns an error code and stores the result in an
    output parameter result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output parameter is a string passed by reference to let the function modify
    its content. The second implementation flips the parameters around. It returns
    a received string as a result and accepts an error code as an output parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want the error code to be set from within the function, we also pass
    it by reference. Finally, the third implementation combines and returns both the
    result and the error code in a C++ `pair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function always creates an `std::pair<int, std::string>` instance. Since
    we do not pass any values to its constructor, the object is default-initialized.
    The integer element is set to `0`, and the string element is set to an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not require an `output` parameter and is more readable, but
    has a slightly higher overhead to construct and then destroy a `pair` object.
  prefs: []
  type: TYPE_NORMAL
- en: When all three implementations are defined, we test all of them in the `Test` function.
    We pass the same parameter to each of the implementations and display the result.
    We expect each of them to generate the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two invocations of `Test`. First, we pass `-1` as a parameter, which
    should trigger an error path, and then we pass `1`, which activates a normal operation
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e6428d7-7667-4b9f-8b0c-bc17d09787d0.png)'
  prefs: []
  type: TYPE_IMG
- en: All three implementations correctly return either the result or error code based
    on the input parameters. You can use any of the approaches in your applications
    based on the overall design guidelines or your personal preferences.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of the C++17 standard, a template called `std::optional` was added to
    the standard library. It can represent an optional value that may be missing.
    It can be used as a return value from a function that may fail. However, it can't
    represent a reason for failure, only a Boolean value indicating whether the value
    is valid or not. For more information, please check the `std::optional` reference
    at [https://en.cppreference.com/w/cpp/utility/optional](https://en.cppreference.com/w/cpp/utility/optional).
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the error codes remain the most widespread technique of error handling
    in embedded programming, C++ offers another mechanism for this purpose, called
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions aim to simplify error handling and make it more reliable. When using
    error codes, developers have to check the result of each function for errors and
    propagate the result to the calling functions. This clutters the code with lots
    of if-else constructs, making the function logic more obscure.
  prefs: []
  type: TYPE_NORMAL
- en: When using exceptions, developers do not need to check for errors after every
    function invocation. Exceptions propagate through the call stack automatically,
    until they reach the code that can handle it properly by logging, retrying, or
    terminating the application.
  prefs: []
  type: TYPE_NORMAL
- en: While exceptions are the default error handling mechanism of the C++ standard
    library, communicating with peripheral devices or the underlying operating system
    layer still involves error codes. In this recipe, we will learn how to bridge
    the low-level error handling to the C++ exceptions using the `std::system_error` exception
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a simple application that communicates to a device over
    a serial link. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `except`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `except.cpp` in the `ex``cept` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the required includes in the `except.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `Device` class that abstracts the communication to the device.
    We start with the constructor and the destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a method that sends data to the device, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After our class has been defined, we add the `main` function, which uses it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application communicates with an external device connected over a serial
    link. In POSIX operating systems, communication to devices is similar to operations
    with regular files and uses the same API; that is, the `open`, `close`, `read`,
    and `write` functions.
  prefs: []
  type: TYPE_NORMAL
- en: All these functions return error codes to indicate various error conditions.
    Instead of using them directly, we wrap the communication in a class called `Device`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its constructor tries to open a file referred to by the `deviceName` constructor
    parameter. The constructor checks for the error code and, if it indicates an error,
    creates and throws an `std::system_error` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We construct the `std::system_error` instance using three parameters. The first
    one is an error code we want to wrap in an exception. We use the value of the `errno`
    variable that's set by the `open` function when it returns an error. The second
    parameter is an error category. Since we use an error code specific to the operating
    system, we use an instance of `std::system_category`. The first parameter is a
    message we want to associate with the exception. It can be anything that helps
    us identify the error if it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we define the `Send` function, which sends data to the device.
    It is a wrapper around the `write` system function, and if `write` returns an
    error, we create and throw an `std::system_error` instance. The only difference
    is the message string since we want to differentiate between these two cases in
    our logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Device` class has been defined, we can use it. Instead of opening
    a device and checking for errors, and then writing to the device and checking
    for errors again, we just create an instance of the `Device` class and send data
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'All error handling lies in the `catch` block after the main logic. If a system
    error is thrown, we log it to the standard output. Additionally, we print information
    about the error code, embedded in the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build and run the application, it shows the following output, if no
    device is connected as `/dev/ttyUSB0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6da888b-864b-412d-8c25-e35b1e4323e1.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the error condition was detected and we can see all the required
    details, including the underlying operating system error code and its description.
    Note that the code that communicates with the device using the wrapper class is
    uncluttered and readable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard library comes with a number of predefined exceptions and error
    categories. For more details, check the C++ error handling reference at [https://en.cppreference.com/w/cpp/error](https://en.cppreference.com/w/cpp/error).
  prefs: []
  type: TYPE_NORMAL
- en: Using constant references when catching exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ exceptions provide a powerful foundation for exception handling design.
    They are flexible and may be used in multiple different ways. You can throw exceptions
    of any type, including pointers and integers. You can catch exceptions by value
    or by reference. A wrong choice when it comes to selecting a data type may lead
    to performance hits or resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will analyze potential pitfalls and learn how to use constant
    references in catch blocks for efficient and safe error handling.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a sample application that throws and catches a custom
    exception and analyze how the data type choice affects efficiency. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `catch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `catch.cpp` in the `catch` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the definition of the `Error` class in the `catch.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add helper functions to test three different ways of throwing and
    handling errors. We start with the function that catches exceptions by value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a function that throws a pointer and catches the exception by
    pointer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a function that uses a `const` reference to catch exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the helper functions have been defined, we add the `main` function
    to tie everything together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We put the build rules for our application into a `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we defined a custom class called `Error` that we are going
    to use when throwing and catching exceptions. This class provides a constructor,
    a copy constructor, and a destructor that only logs information to the console.
    We need it to evaluate the efficiency of different exception catching approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Error` class only contains the `code` data field, which is used to differentiate
    between instances of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We evaluate three approaches for exception handling. The first one, `CatchByValue`,
    is the most straightforward. We create and throw an instance of the `Error` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we catch it by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second implementation, `CatchByPointer`, creates an instance of `Error`
    dynamically using the `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a pointer to catch the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `CatchByReference` throws an exception similar to `CatchByValue`,
    but it uses a `const` reference to `Error` when catching it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it make any difference? When we run our program, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f5b8cf3-a4d9-4337-972f-32d2fdc7772c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when catching an object by value, a copy of the exception object
    was created. Though not critical in a sample application, this inefficiency can
    cause performance issues in a high-load application.
  prefs: []
  type: TYPE_NORMAL
- en: There is no inefficiency when catching exceptions by pointer, but we can see
    that the object destructor was not invoked, causing a memory leak. This can be
    avoided by calling `delete` from the `catch` block, but this is error-prone since
    it is not always clear who is responsible for destroying an object referenced
    by a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The reference approach is the safest and most efficient one. There is no memory
    leak and unnecessary copying. Also, making the reference constant gives the compiler
    a hint that it is not going to be changed and thus can be better optimized under
    the hood.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is a complex area with a number of best practices, hints, and
    recommendations. Consider reading the C++ exceptions and error handling FAQ at
    [https://isocpp.org/wiki/faq/exceptions](https://isocpp.org/wiki/faq/exceptions)
    to master your exception handling skills.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling static objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, object constructors throw exceptions if an object can't be instantiated
    properly. Normally, this does not cause any issues. An exception originating from
    an object constructed on the stack, or an object created dynamically using the
    `new` keyword, can be handled by the try-catch block around the code where the
    object was created.
  prefs: []
  type: TYPE_NORMAL
- en: It gets more complicated for static objects, though. Such objects are instantiated
    before the execution enters the `main` function, so they cannot be wrapped in
    a try-catch block of the program. The C++ compiler handles this situation by calling
    the `std::terminate` function, which prints an error message and terminates the
    program. Even if the exception is non-fatal, there is no way to recover.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to not get into this pitfall. As a general rule, only
    simple, integral data types should be allocated statically. If you still need
    to have a complex static object, make sure its constructor does not throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement a constructor for static objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a custom class that allocates a specified amount of memory and
    statically allocates two instances of the class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `static.cpp` in the `static` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s define a class named `Complex`. Put its private field and the constructor
    in the `static.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a destructor and the `IsValid` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After the class has been defined, we define two global objects, `small` and
    `large`, and the `main` function, which uses them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we defined the `Complex` class, and we intend to allocate instances of
    this class statically. To be safe, we need to make sure that neither the constructor
    nor the destructor of this class can throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: However, both the constructor and the destructor invoke operations that may
    potentially throw exceptions. The constructor performs memory allocation, while
    the destructor writes logs to standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor allocates memory using the `new` operator, which throws an
    `std::bad_alloc` exception if memory can''t be allocated. We use an `std::nothrow`
    constant to select a non-throwing implementation of `new`. Instead of throwing
    an exception, `new` will return `nullptr` if it can''t allocate any memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrap the body of the constructor in the `try` block to catch all exceptions.
    The `catch` block is empty – if the constructor fails, we can''t do much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we do not allow any exceptions to propagate to the upper level, we mark
    our constructor as non-throwing using a C++ keyword, that is, `noexcept`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to know whether an object was created properly. For this purpose,
    we define a method called `IsValid`. It returns `true` if the memory was allocated,
    or `false` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor does the reverse. It deallocates the memory and logs the status
    of deallocation to the console. As for the constructor, we do not want any exceptions
    to be propagated to the upper level, so we wrap the destructor body in a try-catch
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we declare two global objects, `small` and `large`. Global objects are
    allocated statically. The size of the objects is artificially selected in a way
    that the `small` object will be allocated properly, but the allocation of the
    `large` object should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main` function, we check and print whether the objects are valid or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ae692c-8dd9-4803-b71e-6bdfd2d91a90.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the small object was allocated and deallocated properly. Initialization
    of the large object failed, but since it was designed to not throw any exceptions,
    it did not cause the abnormal termination of our application. You can use a similar
    technique for statically allocated objects to write robust and safe applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with watchdogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embedded applications are built to work without supervision. This includes the
    ability to recover from errors. If an application crashes, it can be restarted
    automatically. But what should we do if an application hangs by entering an endless
    loop or due to a deadlock?
  prefs: []
  type: TYPE_NORMAL
- en: Hardware or software watchdogs are used to prevent such situations. Applications
    should periodically notify or *feed* them to indicate that they keep operating
    normally. If a watchdog is not fed within a specific time interval, it terminates
    an application or restarts the system.
  prefs: []
  type: TYPE_NORMAL
- en: Many different implementations of watchdogs exist, but their interfaces are
    essentially the same. They provide a function that applications can use to reset
    the watchdog timer.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a simple software watchdog on top
    of POSIX signals subsystems. The same technique can be used to work with hardware
    watchdog timers or more sophisticated software watchdog services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that will define the `Watchdog` class and provide
    an example of its usage. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `watchdog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `watchdog.cpp` in the `watchdog` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the required includes in the `watchdog.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `Watchdog` class itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main` function, which serves as a usage example for our watchdog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a mechanism to terminate our application when it hangs. Though we could
    spawn a special monitoring thread or process, there is another, simpler way to
    do this—POSIX signals.
  prefs: []
  type: TYPE_NORMAL
- en: Any process running in a POSIX operating system can receive a number of signals.
    To deliver a signal to the process, the operating system stops the normal execution
    of the process and invokes a corresponding signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: One of the signals that can be delivered to the process is called `alarm` and,
    by default, its handler just terminates the application. This is exactly what
    we need to implement a watchdog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of our `Watchdog` class accepts one parameter, `seconds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a time interval for our watchdog and it is immediately passed into the
    `feed` method to activate the watchdog timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `feed` method invokes a POSIX function `alarm` that sets the timer. If
    the timer is already set, it updates it with a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we invoke the same `alarm` function in the destructor to disable the
    timer by passing a value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, each time we invoke the `feed` function, we shift the time when the process
    will receive the `alarm` signal. If, however, we do not invoke this function before
    the timer expires, it triggers the `alarm` handler, which terminates our process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check it out, we''ve created a simple example. It is a loop that has 10
    iterations. On each iteration, we display a message and sleep for a specific interval.
    The interval is initially 700 ms and on each iteration, it increases by 300 ms;
    for example, 700 ms, 1,000 ms, 1,300 ms, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Our watchdog is set to a 2-second interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the application and check how it works. It produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b755a216-3c0d-4381-9129-554f07f472ba.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the application was terminated after the sixth iteration, after
    the delay exceeded the watchdog interval. Moreover, since it was terminated abnormally,
    its return code is non-zero. If the application is spawned by another application
    or script, this is an indicator that the application needs to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: The watchdog technique is a simple and efficient way to build robust embedded
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring heartbeats for highly available systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we learned how to prevent software from hanging using
    watchdog timers. A similar technique can be used to implement a highly available
    system, which consists of one or more software or hardware components that can
    perform the same function. If one of the components fails, another one can take
    over.
  prefs: []
  type: TYPE_NORMAL
- en: The component that is currently active should periodically advertise its health
    status to other, passive components using messages that are called **heartbeats**.
    When it reports an unhealthy status or doesn't report it within a specific amount
    of time, a passive component detects it and activates itself. When the failed
    component recovers, it can either transition into passive mode, monitoring the
    now active component for failures, or initiate a failback procedure to claim the
    active status back.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement a simple heartbeat monitor in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that defines a `Watchdog` class and provide an
    example of its usage. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `heartbeat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `heartbeat.cpp` in the `heartbeat` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the required includes in the `heatbeat.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define an `enum` to report the health status of the active worker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a class that encapsulates the heartbeat reporting and monitoring.
    We start with the class definition, its private fields, and its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a method to report the health status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by a health monitoring method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the heartbeat logic has been defined, we create some functions so that
    we can use it in our test application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heartbeats mechanism needs some kind of communication channel to let one
    component report its status to other components. In a system that is built around
    multiple processing units, the best choice would be network-based communication
    over sockets. Our application is running on a single node, and we can use one
    of the local IPC mechanisms instead.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use POSIX pipes mechanisms for our heartbeat transport. When
    a pipe is created, it provides two file descriptors for communication—one is used
    to read data, while the other is used to write data.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the communication transport, we need to choose the time interval for
    taking over. If a monitoring process does not receive a heartbeat message within
    this interval, it should consider another component as unhealthy or failed, and
    perform some takeover action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the possible health statuses of our applications. We use
    the C++ `enum class` to make the stats strictly typed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application is simple and has only three statuses: `Ok`, `Unhealthy`, and
    `ShutDown`. The `ShutDown` status is an indicator that the active process is going
    to shut down normally and that no takeover action is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the `Heartbeat` class, which encapsulates all message exchange,
    health reporting, and monitoring functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has two data fields that represent the monitoring time interval and the
    POSIX pipe that''s being used for message exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor creates the pipe and throws an exception in the event of a
    failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The health reporting method is a simple wrapper around the `write` function.
    It writes the status, represented as an unsigned 8-bit integer value, to the `write`
    file descriptor of the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The monitoring method is more complex. It uses the POSIX `poll` function to
    wait for data in one or more file descriptors. In our case, we are interested
    in data from only one file descriptor—the read side of the pipe. We fill the `fds` structure
    used by `pol` with file descriptors and the types of events we are interested
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Two Boolean flags control the polling loop. The `takeover` flag indicates whether
    the takeover action should be performed when we exit the loop, while the `polling`
    flag indicates whether the loop should exist or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration of the loop, we poll for new data in the socket using the
    `poll` function. We use a monitoring interval passed into the constructor as a
    polling timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `poll` function indicates one of three possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is greater than zero, we have new data available to read from the communication
    pipe. We read the status from the communication channel and analyze it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the status is `Ok`, we log it and go to the next iteration of polling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the status is `ShutDown`, we need to exit the polling loop, but also prevent
    the `takeover` action. To do this, we set our Boolean flags accordingly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For any other health status, we break from the loop with the `takeover` flag
    set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`poll` returns zero in the case of a timeout. Similar to the `Unhealthy` status,
    we need to break from the loop and perform the `takeover` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the value returned by `poll` is less than zero, it indicates an
    error. There are several reasons why a system call can fail, with a very common
    one being when it is interrupted by a signal. This is not a real error; we only
    need to call `poll` again. For all other cases, we write a log message and keep
    polling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monitoring method blocks while the monitoring loop is running, and it returns
    a Boolean value to let the caller know whether the takeover action should be performed
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to use this class in a toy example. We''ll define a `Worker` function
    that accepts a reference to the `Heartbeat` instance and represents the job to
    be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration of the inner loop, the `Worker` reports its health status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, it reports its status as `Unhealthy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we create an instance of the `Heartbeat` class with
    a 200 ms polling interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we spawn two independent processes. A parent process starts monitoring
    and, if a takeover is needed, runs the `Worker` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The child simply runs the `Worker` method. Let''s run the application and check
    how it works. It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d55f961e-37da-4689-8aa0-f0d9f2e9a02a.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `Worker` method reports that it processes data, and the monitor
    detects its status as healthy. However, after the `Worker` method reports its
    status as `Unhealthy`, the monitor detects it immediately and reruns the worker
    again to keep processing. This strategy can be used to build a more elaborate
    health monitoring and failure recovery logic to implement high availability in
    a system you have designed and developed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, we used two identical components that run simultaneously and
    monitor each other. However, if one of the components contains a software bug
    that, under certain conditions, causes the component to malfunction, there's a
    high chance that another identical component could suffer from this issue too.
    In safety-critical systems, you may need to develop two completely different implementations.
    This approach increases the cost and development time but results in the higher
    reliability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing software debouncing logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common tasks of embedded applications is interacting with external
    physical controls such as buttons or switches. Though such objects have only two
    states – on and off – detecting the moment a button or switch changes state is
    not as simple as it may look.
  prefs: []
  type: TYPE_NORMAL
- en: When a physical button is pressed, it takes some time before the contact is
    established firmly. During this time, spurious interrupts can be triggered as
    if the button is bouncing between on and off states. Instead of reacting to every
    interrupt, an application should be able to filter out the spurious transitions.
    This is called **debouncing**.
  prefs: []
  type: TYPE_NORMAL
- en: Though it can be implemented at the hardware level, the most common approach
    is to do this through software. In this recipe, we will learn how to implement
    a simple and generic debouncing function that can be used with any type of input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that defines a generic debouncing function along
    with a test input. This function can be used for any practical purpose by replacing
    the test input with real input. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `debounce`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `debounce.cpp` in the `debounce` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add includes and a function called `debounce` to the `debounce.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `main` function, which shows how to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to detect when a button has stopped bouncing between on and off
    states. We assume that if all consecutive attempts to read the button state return
    the same value (either on or off) within a specific interval of time, we can tell
    whether the button is really on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this logic to implement the `debounce` function. Since we want to make
    the debouncing logic as generic as possible, the function should not know how
    to read the state of a button. That is why the function accepts two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, `timeout`, defines that specific interval of time we need
    to wait to report a state change. The second argument, `handler`, is a function
    or a function-like object that knows how to read the state of the button. It is
    defined as a pointer to a Boolean function without arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debounce` function runs a loop. On each iteration, it calls the handler
    to read the state of the button and compares it with the previous value. If the
    values are equal, we check the time since the most recent state change. If it
    exceeds the timeout, we exit the loop and return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If the values are not equal, we reset the time for the most recent state change
    and keep waiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To minimize the CPU load and let other processes do some work, we add a 1-millisecond
    delay between reads. If the function is intended to be used on a microcontroller
    that does not run a multitasking operating system, this delay is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `main` function contains a usage example for the `debounce` function. We
    use the C++ lambda to define a simple rule to read the button. It always returns
    `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass `10ms` as a `debounce` timeout. If we run our program, we will see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15406ee1-e262-4eca-b5d6-f744a0738e85.png)'
  prefs: []
  type: TYPE_IMG
- en: The `debounce` function works for 10 ms and returns `true` since there were
    no spurious state changes in the test input. In the case of real input, it may
    take more time until the button state stabilizes. This simple yet efficient debouncing
    function can be applied to a variety of real inputs.
  prefs: []
  type: TYPE_NORMAL
