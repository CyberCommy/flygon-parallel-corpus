- en: Writing Web Applications in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed many advanced topics related to goroutines
    and channels as well as shared memory and mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: The main subject of this chapter is the development of web applications in Go.
    However, this chapter will also talk about how to interact with two popular databases
    in your Go programs. The Go standard library provides packages that can help you
    develop web applications using higher level functions, which means that you can
    do complex things such as reading web pages by just calling a couple of Go functions
    with the right arguments. Although this kind of programming hides the complexity
    behind a request and offers less control over the details, it allows you to develop
    difficult applications using fewer lines of code, which also results in having
    fewer bugs in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as this book is about systems programming, this chapter will not go
    into too much depth: you might consider the presented information as a good starting
    point for anyone who wants to learn about web development in Go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this chapter will talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Go utility for MySQL database administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administering a MongoDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Go MongoDB driver to talk to a MongoDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web server in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web client in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `http.ServeMux` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with JSON data in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `net/http` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `html/template` Go standard package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a command-line utility that searches web pages for a given keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a web application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is a client-server software application where the client part
    runs on a web browser. Web applications include webmail, instant messaging services,
    and online stores.
  prefs: []
  type: TYPE_NORMAL
- en: About the net/http Go package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hero of this chapter will be the `net/http` package that can help you write
    web applications in Go. However, if you are interested in dealing with TCP/IP
    connections at a lower level, then you should go to [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml),
    *Network Programming*, which talks about developing TCP/IP applications using
    lower level function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package offers a built-in web server as well as a built-in web
    client that are both pretty powerful. The `http.Get()` method can be used for
    making HTTP and HTTPS requests, whereas the `http.ListenAndServe()` function can
    be used for creating naive web servers by specifying the IP address and the TCP
    port the server will listen to, as well as the functions that will handle incoming
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Another very convenient package is `html/template`, which is part of the Go
    standard library and allows you to generate an HTML output using Go HTML template
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Developing web clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to develop web clients in Go and how to
    time out a web connection that takes too long to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a single URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, you will learn how to read a single web page with the help
    of the `http.Get()` function, which is going to be demonstrated in the `getURL.go`
    program. The utility will be presented in four parts; the first part of the program
    is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Although there is nothing new here, you might find impressive the fact that
    you will use Go packages that are related to file input and output operations
    even though you are reading data from the internet. The explanation for this is
    pretty simple: Go has a uniform interface for reading and writing data regardless
    of the medium it is in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `getURL.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The URL you want to fetch is given as a command-line argument to the program.
    Additionally, you can see the call to `http.Get()`, which does all the dirty work!
    What `http.Get()` returns is a `Response` variable, which in reality is a Go structure
    with various properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If there is an error after calling `http.Get()`, this is the place to check
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the data of `URL` is written in standard output using `os.Stdout`,
    which is the preferred way for printing data on the screen. Additionally, the
    data is saved in the `Body` property of the return value of the `http.Get()` call.
    However, not all HTTP requests are simple. If the response streams a video or
    something similar, it would make sense to be able to read it one piece at a time
    instead of getting all of it in a single data piece. You can do that with `io.Reader`
    and the `Body` part of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `getURL.go` will generate the following raw results, which is what
    a web browser would have gotten and rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, although `getURL.go` does the desired job, the way it works
    is not so sophisticated because it gives you no flexibility or a way to be creative.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to set a timeout for a `http.Get()` request.
    For reasons of simplicity, it will be based on the Go code of `getURL.go`. The
    name of the program will be `timeoutHTTP.go` and will be presented in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, you declare the desired timeout period, which is 1 second, as a global
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `timeoutHTTP.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you define two types of timeouts, the first one is defined with `net.DialTimeout()`
    and is for the time it will take your client to connect to the server. The second
    one is the read/write timeout, which has to do with the time you want to wait
    to get a response from the web server after connecting to it: this is defined
    with the call to the `conn.SetDeadline()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the presented program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth portion of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, you define the desired parameters of the connection using an `http.Transport`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This part of the program is all about error handling!
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `timeoutHTTP.go` will generate the following output in case of a
    timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The simplest way to deliberately create a timeout during a web connection is
    to call the `time.Sleep()` function in the handler function of a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Developing better web clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although `getURL.go` does the required job pretty quickly and without writing
    too much Go code, it is in a way not adaptable or informative. It just prints
    a bunch of raw HTML code without any other information and without the capability
    of dividing the HTML code into its logical parts. Therefore, `getURL.go` needs
    to be improved!
  prefs: []
  type: TYPE_NORMAL
- en: The name of the new utility will be `webClient.go` and will be presented to
    you in five segments of Go code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the Go code from `webClient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing here is the use of the `url.Parse()` function that creates
    a `URL` structure from a URL that is given as a string to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `webClient.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this Go code, you first create an `http.Client` variable. Then, you construct
    a `GET` HTTP request using `http.NewRequest()`. Last, you send the HTTP request
    using the `Do()` function, which returns the actual response data saved in the
    `httpData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth code part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you find the status code of the HTTP request using the `Status` property.
    Then, you do a little digging into the `Header` part of the response in order
    to find the character set of the response. Last, you check the value of the `ContentLength`
    property, which equals `-1` for dynamic pages: this means that you do not know
    the page size in advance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you find the length of the response by reading from the `Body` reader
    and counting its data. If you want to print the contents of the response, this
    is the right place to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `webClient.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A small web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enough with the web clients: in this section, you will learn how to develop
    web servers in Go!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code for the implementation of a naive web server can be found in `webServer.go`,
    and this will be presented in four parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is where things start to get tricky and strange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a kind of function that handles HTTP requests: the function takes two
    arguments, a `http.ResponseWriter` variable and a pointer to an `http.Request`
    variable. The first argument will be used for constructing the HTTP response,
    whereas the `http.Request` variable holds the details of the HTTP request that
    was received by the server, including the requested URL and the IP address of
    the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `webServer.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you just deal with the port number of the web server: the default port
    number is `8001`, unless there is a command-line argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last chunk of Go code for `webServer.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `http.HandleFunc()` call defines the name of the handler function (`myHandler`)
    as well as the URLs that it will support: you can call `http.HandleFunc()` multiple
    times. The current handler supports `/URL`, which in Go matches all URLs!'
  prefs: []
  type: TYPE_NORMAL
- en: After you are done with the `http.HandleFunc()` calls, you are ready to call
    `http.ListenAndServe()` and start waiting for incoming connections! If you do
    not specify an IP address in the `http.ListenAndServe()` function call, then the
    web server will listen to all configured network interfaces of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `webServer.go` will generate no output, unless you try to fetch some
    data from it: in this case, it will print logging information on your Terminal,
    which will show the server name (`localhost`) and port number (`8001`) of the
    request, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows three outputs of `webServer.go` on a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92cc0e7a-c289-4559-ae6f-6fc6e9d42ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: Using webServer.go
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you use a command-line utility such as `wget(1)` or `getURL.go`
    instead of a web browser, you will get the following output when you try to connect
    to the Go web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The biggest advantage you get from custom made web servers is security because
    they are really difficult to hack when developed with security as well as easier
    customization in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection will show how to create web servers using `http.ServeMux`.
  prefs: []
  type: TYPE_NORMAL
- en: The http.ServeMux type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to use the `http.ServeMux` type in order
    to improve the way your Go web server will operate. Putting it simply, `http.ServeMux`
    is a HTTP request router.
  prefs: []
  type: TYPE_NORMAL
- en: Using http.ServeMux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web server implementation of this section will support multiple paths with
    the help of `http.ServeMux`, which will be illustrated in the `serveMux.go` program
    that will be displayed in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `serveMux.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have the implementation of three HTTP handler functions. The first
    two display a static page, whereas the third one displays the current time, which
    is a dynamic text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `home()` handler function will have to make sure that it is actually serving
    `/Path`, because `/Path` catches everything!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `serveMux.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, you define the paths that your web server will support. Note that paths
    are case sensitive and that the last path in the preceding code catches everything.
    This means that if you put `m.HandleFunc("/", home)` first, you will not be able
    to match anything else. Putting it simply, the order of the `m.HandleFunc()` statements
    matters. Also, note that if you want to support both `/about` and `/about/`, you
    should have both `m.HandleFunc("/about", about)` and `m.HandleFunc("/about/",
    about)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `serveMux.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the various kinds of outputs generated by `serveMux.go`
    on a web browser: note that the browser output is not related to the preceding
    output from the `go run serveMux.go` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67d1c2e9-8fd4-4134-8ae7-f992fdb8d0d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Using serveMux.go
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `wget(1)` instead of a web browser, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, `http.HandleFunc()` is the default call in the library that will be used
    for first time implementations, whereas the `HandleFunc()` function of `http.NewServeMux()`
    is for everything else. Putting it simply, it is better to use the `http.NewServeMux()`
    version instead of the default one except in the simplest of cases.
  prefs: []
  type: TYPE_NORMAL
- en: The html/template package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Templates** are mainly used for separating the formatting and data parts
    of the output. Note that a Go template can be either a file or string: the general
    idea is to use strings for smaller templates and files for bigger ones.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will talk about the `html/template` package by showing an
    example, which can be found in the `template.go` file and will be presented in
    six parts. The general idea behind `template.go` is that you are reading a text
    file with records that you want to present in HTML format. Given that the name
    of the package is `html/template`, a better name for the program would have been
    `genHTML.go` or `genTemplate.go`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `text/template` package, which is more useful for creating
    plain text output. However, you cannot import both `text/template` and `html/template`
    on the same Go program without taking some extra steps to disambiguate them because
    the two packages have the same package name (`template`). The key distinction
    between the two packages is that `html/template` does sanitization of the data
    input for HTML injection, which means that it is more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the source file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The definition of the structure is really important because this is how your
    data is going to be passed to the `template` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `template.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `template.ParseGlob()` function is used for reading the external template
    file, which can have any file extension you want. Using the `.gohtml` extension
    might make your life simpler when you are looking for Go template files in your
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Although I personally prefer the `.gohtml` extension for Go template files,
    `.tpl` is a pretty common extension that is widely used. You can choose whichever
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third chunk of code from `template.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The third parameter to the `ExecuteTemplate()` function is the data you want
    to process. In this case, you pass a slice of records to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function displays a static HTML page, which we are just going to pass through
    the template engine with the `nil` data, which is signified by the third argument
    of the `ExecuteTemplate()` function. If you have the same function handling different
    pieces of data, you may end up with cases where there is nothing to render, but
    keep it there for common code structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth part of `template.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last chunk of Go code from `template.go` is where you define the supported
    paths and start the web server using port number `8001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the `template.gohtml` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot (`.`) character represents the current data being processed: to put
    it simply, the dot (`.`) character is a variable. The `{{ range . }}` statement
    is equivalent to a `for` loop that visits all the elements of the input slice,
    which are structures in this case. You can access the fields of each structure
    as `.WebSite`, `.WebName`, and `.Quality`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `static.gohtml` file are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute `template.go`, you will get the following output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the two outputs of `template.go` as displayed
    on a web browser. The `sites.html` file has three columns, which are the URL,
    the name and the quality and can have multiple lines. The good thing here is that
    if you change the contents of the `/tmp/sites.html` file and reload the web page,
    you will see the updated contents!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31188a00-51f7-4535-9f6b-2ce30fca63c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Using template.go
  prefs: []
  type: TYPE_NORMAL
- en: About JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for JavaScript Object Notation. This is a text-based format
    designed as an easy and light way to pass information between JavaScript systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JSON document has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON document has three fields named `name`, `surname`, and `country`.
    Each field has a single value.
  prefs: []
  type: TYPE_NORMAL
- en: However, JSON documents can have more complex structures with multiple depth
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: Before seeing some code, I think that it would be very useful to talk about
    the `encoding/json` Go package first. The `encoding/json` package offers the `Encode()`
    and `Decode()` functions that allow the conversion of a Go object into a JSON
    document and vice versa. Additionally, the `encoding/json` package offers the
    `Marshal()` and `Unmarshal()` functions that work similarly to `Encode()` and
    `Decode()` and are based on the `Encode()` and `Decode()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `Marshal()-Unmarshal()` and `Encode()-Decode()`
    is that the former functions work on single objects, whereas the latter functions
    can work on multiple objects as well as streams of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, the `encoding/json` Go package includes two interfaces named `Marshaler`
    and `Unmarshaler`: each one of them requires the implementation of a single method,
    named `MarshalJSON()` and `UnmarshalJSON()`, respectively. These two interfaces
    allow you to perform custom JSON **Marshalling** and **Unmarshalling** in Go.
    Unfortunately, those two interfaces will not be covered in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will teach you how to convert regular data into JSON format
    in order to send it over a network connection. The Go code of this subsection
    will be saved as `writeJSON.go` and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first chunk of Go code is the expected preamble of the program as well
    as the definition of two new `struct` types named `Record` and `Telephone`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that only the members of a structure that begin with an uppercase letter
    will be in the JSON output because members that begin with a lowercase letter
    are considered private: in this case, all members of `Record` and `Telephone`
    structures are public and will get exported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the definition of a function named `saveToJSON()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `saveToJSON()` function does all the work for us as it creates a JSON encoder
    variable named `encodeJSON`, which is associated with a filename, which is where
    the data is going to be saved. Then, the call to `Encode()` saves the data of
    the record to the associated filename and we are done! As you will see in the
    next section, a similar process will help you read a JSON file and convert it
    into a Go variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here: you just get the first command-line argument
    of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do two things. The first is defining a new `Record` variable and filling
    it with data. The second is the call to `saveToJSON()` for saving the `myRecord`
    variable in the JSON format to the selected file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `writeJSON.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the contents of `/tmp/SavedFile` will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Sending JSON data over a network requires the use of the net Go standard package
    that will be discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will illustrate how to read a JSON record and convert it into
    one Go variable that you can use in your own programs. The name of the presented
    program will be `readJSON.go` and will be shown to you in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is identical to the first part of the `writeJSON.go`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the Go code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, you define a new function named `loadFromJSON()` that is used for decoding
    a JSON file according to a data structure that is given as the second argument
    to it. You first call the `json.NewDecoder()` function to create a new JSON decode
    variable that is associated with a file, and then you call the `Decode()` function
    for actually decoding the contents of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `readJSON.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `readJSON.go`, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Reading your JSON data from a network will be discussed in the next chapter,
    as JSON records do not differ from any other kind of data transferred over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Using Marshal() and Unmarshal()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, you will see how to use `Marshal()` and `Unmarshal()` in
    order to implement the functionality of `readJSON.go` and `writeJSON.go`. The
    Go code that illustrates the `Marshal()` and `Unmarshal()` functions can be found
    in `marUnmar.go`, and this will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `marUnmar.go` is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the same record that is used in the `writeJSON.go` program. Therefore,
    so far there is nothing special.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `marUnmar.go` is where the marshalling happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that `json.Marshal()` requires a pointer for passing data to it even if
    the value is a map, array, or slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program contains the following Go code that performs the
    unmarshalling operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, `json.Unmarshal()` requires the use of a pointer
    for saving the data even if the value is a map, array, or slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `marUnmar.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Marshal()` and `Unmarshal()` functions cannot help you
    store your data into a file: you will need to implement that on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A relational database is a structured collection of data that is strictly organized
    into tables. The dominant language for querying databases is SQL. NoSQL databases,
    such as **MongoDB**, do not use SQL, but various other query languages and do
    not have a strict structure in their tables, which are called **collections**
    in the NoSQL terminology.
  prefs: []
  type: TYPE_NORMAL
- en: You can categorize NoSQL databases according to their data model as Document,
    Key-Value, Graph, and Column-family. MongoDB is the most popular document-oriented
    NoSQL database that is appropriate for use in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Document databases were not made for dealing with Microsoft Word documents,
    but for storing semistructured data.
  prefs: []
  type: TYPE_NORMAL
- en: Basic MongoDB administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to use MongoDB on your Go applications, it would be very practical
    to know how to perform some basic administrative tasks on a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the tasks presented in this section will be performed from the Mongo
    shell, which starts by executing the `mongo` command. If no MongoDB instance is
    running on your Unix machine, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous output tells us two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The default TCP port number for the MongoDB server process is `27017`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mongo executable tries to connect to the `127.0.0.1` IP address, which is
    the IP address of the local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to execute the following commands, you should start a MongoDB server
    instance on your local machine. Once the MongoDB server process is up and running,
    executing `mongo` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands will show you how to create a new MongoDB database and
    a new MongoDB collection, and how to insert some documents in to that collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Once you try to insert a document into a collection using `db.someData.insert()`,
    the collection (`someData`) will be automatically created if it does not already
    exist. The last command counts the number of records stored into the `someData`
    collection of the current database.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB will not inform you about any typographical errors you might have. Putting
    it simply, if you mistype the name of a database or a collection, MongoDB will
    create a totally new database or a new collection while you are trying to find
    out what went wrong! Additionally, if you put more, less, or different fields
    on a document and try to save it, MongoDB will not complain!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the records of a collection using the `find()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the list of databases on a running MongoDB instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can find the names of the collections stored in the current
    MongoDB database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete all the records of a MongoDB collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, you can delete an entire collection, including its records, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding information will get you going for now, but if you want to learn
    more about MongoDB, you should visit the documentation site of MongoDB at [https://docs.mongodb.com/](https://docs.mongodb.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the MongoDB Go driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use MongoDB in your Go programs, you should first have the MongoDB
    Go driver installed on your Unix machine. The name of the MongoDB Go driver is
    `mgo` and you can learn more information about the MongoDB Go driver by visiting
    [https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo), [https://labix.org/mgo](https://labix.org/mgo),
    and [https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As the driver is not part of the standard Go library, you should first download
    the required packages using the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you will be free to use it in your own Go utilities. If you try
    to execute the program without having the two packages on your Unix system, you
    will get an error message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that you might need to install Bazaar on your Unix system in order to execute
    the two `go get` commands. You can get more information about the Bazaar version
    control system at [https://bazaar.canonical.com/](https://bazaar.canonical.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you should first try to run a simple Go program that connects to a MongoDB
    database, creates a new database and a new collection, and adds new documents
    to it in order to make sure that everything works as expected: the name of the
    program will be `testMongo.go` and will be presented in four parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see the use of the Go MongoDB driver in the import block. Additionally,
    you see the definition of a new Go structure named `Record` that will hold the
    data of each MongoDB document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `testMongo.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `collection` variable will be used for dealing with the `someData`
    collection of the `goDriver` database: a better name for the database would have
    been `myDB`. Note that there was not a `goDriver` database in the MongoDB instance
    before running the Go program; this also means that neither the `someData` collection
    was there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, you insert two documents to the MongoDB database using the `Insert()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last portion of `testMongo.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you do not know the number of documents that you will get from the `Find()`
    query, you should use a slice of records for storing them.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, note that you should put the `yvalue` field in lowercase in the
    `Find()` function because MongoDB will automatically convert the fields of the
    `Record` structure in lowercase when you are storing them!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute `testMongo.go`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you execute `testMongo.go` multiple times, you will find the same
    documents inserted multiple times into the `someData` collection. However, MongoDB
    will not have any problems differentiating between all these documents because
    the key of each document is the `_id` field, which is automatically inserted by
    MongoDB each time you insert a new document to a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, connect to your MongoDB instance using the `MongoDB` shell command
    to make sure that everything worked as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is important to understand that MongoDB documents are presented in
    JSON format, which you already know how to handle in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the Go MongoDB driver has many more capabilities than the ones
    presented here. Unfortunately, talking more about it is beyond the scope of this
    book, but you can learn more by visiting [https://github.com/go-mgo/mgo](https://github.com/go-mgo/mgo),
    [https://labix.org/mgo](https://labix.org/mgo), and [https://docs.mongodb.com/ecosystem/drivers/go/](https://docs.mongodb.com/ecosystem/drivers/go/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Go application that displays MongoDB data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the utility will be `showMongo.go` and it will be presented in three
    parts. The utility will connect to a MongoDB instance, read a collection, and
    display the documents of the collection as a web page. Note that `showMongo.go`
    is based on the Go code of `template.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the web application is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You should know in advance the structure of the MongoDB documents that you will
    retrieve because the field names are hard coded in the `struct` type and need
    to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As before, you connect to MongoDB using `mgo.DialWithInfo()` with the parameters
    that were defined in the `mgo.DialInfo` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the web application is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The contents of `MongoDB.gohtml` are similar to the contents of `template.gohtml`
    and will not be presented here. You can refer to *The html/template package* section
    for the contents of `template.gohtml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of `showMongo.go` will not display the actual data on the screen:
    you will need to use a web browser for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The good thing is that if the data of the collections is changed, you will
    not need to recompile your Go code in order to see the changes: you will just
    need to reload the web page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of `showMongo.go` as displayed on
    a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a11f9a8c-3fc3-414b-83a7-ecffd7aca8de.png)'
  prefs: []
  type: TYPE_IMG
- en: Using showMongo.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `Numbers` collection contains the following documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Have in mind that extra data in the MongoDB structure that does not have corresponding
    fields in the Go structure is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application that displays MySQL data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will present a Go utility that executes a query on a
    MySQL table. The name of the new command-line utility will be `showMySQL.go` and
    will be presented in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `showMySQL.go` will use the `database/sql` package that provides a
    generic SQL interface to relational databases for querying the MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented utility requires two parameters: a username with administrative
    privileges and its password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `showMySQL.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There is a small change here, as `showMySQL.go` uses `text/template` instead
    of `html/template`. Note that the drivers that conform to the `database/sql` interface
    are never really referenced directly in your code, but they still need to be initialized
    and imported. The `_` character in front of `"github.com/go-sql-driver/mysql"`
    does this by telling Go to ignore the fact that the `"github.com/go-sql-driver/mysql"`
    package is not actually used in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to download the MySQL Go driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the utility has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The third chunk of Go code from `showMySQL.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, you manually construct the connection string to MySQL. For reasons of
    security, a default MySQL installation works with a socket (`/tmp/mysql.sock`)
    instead of a network connection. The name of the database that will be used is
    the last part of the connection string (`information_schema`).
  prefs: []
  type: TYPE_NORMAL
- en: You will most likely have to adjust these parameters for your own database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `showMySQL.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `Next()` function iterates over all the records returned from the `select`
    query and returns them one by one with the help of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of presenting the data as a web page, you will receive it
    as plain text. Additionally, as the text template is small, it is defined in line
    with the help of the `t` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Is the use of the template necessary here? Of course not! But it is good to
    learn how to define Go templates without using an external template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the output of `showMySQL.go` will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows information about the available databases for the
    current MySQL instance, which is a great way to get information about a MySQL
    database without having to connect using the MySQL client.
  prefs: []
  type: TYPE_NORMAL
- en: A handy command-line utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a handy command-line utility that reads a number
    of web pages, which can be found in a text file or read from standard input, and
    returns the number of times a given keyword was found in these web pages. In order
    to be faster, the utility will use goroutines to get the desired data and a monitoring
    process to gather the data and present it on the screen. The name of the utility
    will be `findKeyword.go` and will be presented in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `Data struct` type will be used for passing information between channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `findKeyword.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `monitor()` function is where all the information is collected and printed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the implementation of the `processPage()` function that is
    executed in a goroutine. If the `Error` field of the `Data` structure is not `nil`,
    then there was an error somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using the `bodyHTML` variable to save the entire contents of
    a URL is for not having a keyword split between two consecutive calls to `reader.Read()`.
    After that, a regular expression (`r`) is used for searching the `bodyHTML` variable
    for the desired keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `findKeyword.go` expects its input from a text file or from
    standard input, which is the common Unix practice: this technique was first illustrated
    back in [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes
    and Signals*, in the *Reading from standard input* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last chunk of Go code for `findKeyword.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here: you just start the desired goroutines and the
    `monitor()` function to take care of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `findKeyword.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The funny thing here is that the `doesnotexist.com` domain does actually exist!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download and install MongoDB on your Unix machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the documentation page of the `net/http` Go standard package at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the documentation page of the `html/template` Go standard package at [https://golang.org/pkg/html/template/](https://golang.org/pkg/html/template/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Go code of `getURL.go` in order to make it able to fetch multiple
    web pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the documentation of the `encoding/json` package that can be found at [https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the MongoDB site at [https://www.mongodb.org/](https://www.mongodb.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn how to use `text/template` by developing your own example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Go code of `findKeyword.go` in order to be able to search multiple
    keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about web development in Go including parsing, marshalling
    and unmarshalling JSON data, interacting with a MongoDB database; reading data
    from a MySQL database; creating web servers in Go; creating web clients in Go;
    and using the `http.ServeMux` type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about network programming in Go, which includes
    creating TCP and UDP clients and servers using low level commands. We will also
    teach you how to develop an RCP client and an RCP server in Go. If you love developing
    TCP/IP applications, then the last chapter of this book is for you!
  prefs: []
  type: TYPE_NORMAL
