- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of making an executable from the source code is called compilation.
    Compiling a C++ program is a sequence of complex tasks that results in machine
    code generation. Typically, a C++ compiler parses and analyzes the source code,
    generates intermediate code, optimizes it, and finally, generates machine code
    in a file called an object file. An interpreter, on the other hand, doesn't produce
    machine code. Instead, it executes instructions in the source code line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, pre-processing, and then the compiler compiles the code by parsing it,
    performing syntax and semantic analysis, after which an intermediate code is generated.
    After optimizing the generated intermediate code, the compiler generates the final
    object file (containing machine code), which can then be linked with other object
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pre-processor is intended to process source files to make them ready for compilation. A
    pre-processor works with pre-processor directives, such as `#define` and `#include`. Directives
    don't represent program statements, but they are commands for the pre-processor,
    telling it what to do with the text of the source file. The compiler cannot recognize
    those directives, so whenever you use pre-processor directives in your code, the
    pre-processor resolves them accordingly before the actual compilation of the code
    begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler outputs an object file for each compilation unit. The task of the
    linker is to combine these object files into a single object file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Libraries can be linked with the executable file either as static or dynamic
    libraries. When you link them as a static library, they become a part of the final
    executable file. A dynamically linked library should also be loaded into memory
    by the operating system to provide your program with the ability to call its functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, the `main()` function has two parameters, `argc` and `argv`, where
    `argc` is the number of input arguments to the program and `argv` constitutes
    those input arguments. Very occasionally, you can see a widely supported, but
    not standardized, third argument, most commonly named `envp`. The type of `envp`
    is an array of char pointers and it holds the environment variables of the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `constexpr` specifier declares that the value of the function can be evaluated
    at compile time. The same definition applies to variables as well. The name consists
    of `const` and expressions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursion leads to the allocation of additional space for function invocations.
    It is expensive to allocate space for the function and call compared to an iterative
    solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stack holds objects with automatic storage duration; that is, programmers
    do not concern themselves with the construction and destruction of those objects
    in memory. Typically, a stack is used for function arguments and local variables.
    The heap, on the other hand, allows new memory to be allocated during the program
    execution. However, proper deallocation of memory space is now the responsibility
    of the programmer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The size of the pointer doesn't depend on the type of the pointer because a
    pointer is a value that represents an address in memory. The size of the address
    depends on the system. Usually, it's either 32 or 64 bits. Therefore, we say that
    the size of the pointer is 4 or 8 byte.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An array has a unique structure in terms of item locations. They are placed
    contiguously in memory; the second item is placed right after the first item,
    the third right after the second, and so on. Considering this feature, and also
    the fact that the array consists of elements of the same type, accessing an item
    at any position takes a constant amount of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we forget the `break` keyword in the `case` statement, the execution will
    pass to the next `case` statement without checking for its condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, `operations['+'] = [](int a, int b) { return a + b; }`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity, state, and behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When moving objects instead of copying, we omit the creation of temporary variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There aren't any differences between a struct and a class in C++ except the
    default access modifier. This is public for the struct, and private for the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of aggregation, the class that contains an instance or instances
    of other classes could be instantiated without the aggregate. The composition,
    on the other hand, expresses strong containment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Private inheritance hides the inherited members from the client code of the
    derived class. Protected inheritance does the same, but allows the derived classes
    in the chain to have access to those members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typically, an introduction of a virtual function leads to augmenting the class
    with addition data members pointing to the table of virtual functions. Usually,
    that adds up to 4 or 8 bytes of space (based on the size of the pointer) to the
    class object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Singleton design pattern allows the construction of a single instance of
    the class. This is helpful in a lot of projects where we need to ensure that the
    number of instances of the classes is limited to one. For example, a database
    connection class works best if implemented as a Singleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are powerful tools if used in the right way. However, the following aspects
    limit the usage of macros. (1) You cannot debug macros; (2) Macro expansion can
    lead to strange side effects; (3) Macros have no namespace, so if you have a macro
    that clashes with a name used elsewhere, you get macro replacements where you
    didn't want them, and this usually leads to strange error messages; and (4) Macros
    may affect things you are not aware of. For further details, please go to [https://stackoverflow.com/questions/14041453](https://stackoverflow.com/questions/14041453).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class/function template refers to a kind of template used to generate template
    classes/functions. It's just a template but not a class/function, and hence the
    compiler does not generate any object code for it. A template class/function is
    an instance of a class/function template. Since it is a class/function, the corresponding
    object code is generated by the compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we define a class/function template, there is a <> symbol after the `template` keyword,
    in which one or more type parameters must be given. The type parameter(s) inside
    <> is known as the template parameter list. When we instantiate a class/function
    template, all the template parameters must be replaced with their corresponding
    template arguments, which is known as a template argument list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implicit instantiation happens on demand. However, when providing library files
    (`.lib`), you have no idea what type of argument list will be used by users in
    the future, hence, you need to explicitly instantiate all potential types.
  prefs: []
  type: TYPE_NORMAL
- en: '*Polymorphism* means that something exists in different forms. Specifically,
    in programming languages, polymorphism means that some functions, operations,
    or objects have several different behaviors in different contexts. In C++, there
    are two kinds of polymorphism: dynamic polymorphism and static polymorphism. Dynamic
    polymorphism allows users to determine the actual function method to be executed
    at runtime, while static polymorphism means that the actual function to call (or,
    in general, the actual code to run) is known at compile time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function overloading means that functions are defined with the same name but
    a different set of parameters (different signatures).
  prefs: []
  type: TYPE_NORMAL
- en: Function overriding is the ability of the child class rewriting the virtual
    methods defined in the parent classes.
  prefs: []
  type: TYPE_NORMAL
- en: A type trait is a technique that is used to collect information regarding types. With
    its help, we can make more intelligent decisions to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: develop high-quality optimized algorithms in generic programming. Type traits
    can be implemented by partial or full template specialization.
  prefs: []
  type: TYPE_NORMAL
- en: We can write an error statement in `g()`, and build the code. If an unused function
    is instantiated, the compiler will report errors, otherwise it will be built successfully.
    You can find the example code in the following files, `ch4_5_class_template_implicit_inst_v2.h`
    and `ch4_5_class_template_implicit_inst_B_v2.cpp`, at [https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4.](https://github.com/PacktPublishing/Expert-CPP/tree/master/Chapter-4)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to `ch4_q7.cpp` at [https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4](https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a laboratory exercise; no answer is required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer memory can be described as a single concept – the **Dynamic RAM** (**DRAM**),
    or as a combination of all the memory units that the computer contains, starting
    with the registers and cache memory, and ending with the hard drive. From the
    programmers' perspective, DRAM is of the most interest because it holds the instructions
    and data of the program running in the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual memory is an approach to efficiently manage the physical memory of the
    computer. Typically, the operating system incorporates virtual memory to handle
    memory accesses from programs and to efficiently allocate chunks of memory to
    particular programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In C++, we use the `new` and `delete` operators to allocate and deallocate memory
    space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`delete` deallocates the space allocated for a single object, while `delete[]`
    is used for dynamic arrays and frees all the elements of the array on the heap.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A garbage collector is a tool or a set of tools and mechanisms that provide
    automatic resource deallocation on the heap. For a garbage collector, a support
    environment is required, such as a virtual machine. C++ directly compiles into
    machine code that can be run without a support environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When inserting a new element into the vector, it is placed at the already allocated
    free slot of the vector. If the size of the vector and its capacity are equal,
    this means that the vector has no free slot for the new element. In these (rare)
    cases, the vector automatically resizes itself, which involves allocating new
    memory space and copying the existing elements to that new bigger space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When inserting an element at the front of the linked list, we only create the
    new element and update the list pointers to effectively place the new element
    in the list. Inserting a new element at the front of the vector requires all of
    the vector elements to be shifted right to free up a slot for that element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the chapter source code in GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will look like a linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selection sort searches for the maximum (or minimum) element and replaces the
    current one with that maximum (or minimum). Insertion sort divides the collection
    into two sections and walks through the unsorted section and places each of its
    elements in the proper slot of the sorted section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the chapter source code in GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ranges library in C++ allows ranges of elements to be handled, manipulating
    them using view adapters, which are far more efficient because they don't store
    the entire collection as an adapter result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function is pure if it doesn't modify the state, and produces the same result
    for the same input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pure virtual function is a characteristic of a function without an implementation.
    Pure virtual functions are used to describe interface functions for derived classes.
    Pure functions in functional programming are those functions that do not modify
    the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Folding (or reduction) is the process of combining a collection of values together
    to generate a reduced number of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tail recursion allows compilers to optimize the recursive calls by omitting
    the allocation of new memory space for each recursive call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two operations run concurrently if their start and end times are interleaved
    at any point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parallelism means that tasks run simultaneously, while concurrency does not
    force the tasks to run at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A process is the image of the program. It's a combination of program instructions
    and data loaded into the computer memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread is a section of code in the scope of a process that can be scheduled
    by the operating system scheduler, while a process is the image of the running
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to any example in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using double-checked locking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the source code for the chapter in GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++20 introduced coroutines as an addition to the classic asynchronous functions.
    Coroutines move the background execution of the code to the next level. They allow
    a function to be paused and resumed when necessary. `co_await` is a construct
    telling the code to wait for asynchronously executing code. This means the function
    can be suspended at that point and resume its execution when a result is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double-checked locking is a way to make the Singleton pattern work flawlessly
    in a multithreaded environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's a way to make sure that the underlying data of the other stack won't
    get modified while we make a copy of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An atomic operation is an indivisible operation, and atomic types leverage lower-level
    mechanisms to ensure the independent and atomic execution of instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`load()` and `store()` leverage low-level mechanisms to ensure that the write
    and read operations are done atomically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides `load()` and `store()`, there are operations such as `exchange()`, `wait()`,
    and `notify_one()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD stands for test-driven development, and the aim is to write tests before
    the actual implementation of the project. This helps to define project requirements
    more clearly and avoid most of the bugs in the code beforehand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interaction diagrams picture the exact process of communication of the objects.
    This allows developers to have a high-level view of the actual program execution
    for any given moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of aggregation, the class that contains an instance or instances
    of other classes could be instantiated without the aggregate. The composition,
    on the other hand, expresses the strong containment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In simple terms, the Liskov substitution principle ensures that any function
    taking an object of some type T as an argument will also take an object of type
    K if K extends T.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The open-closed principle states that the class should be open for extension
    and closed for modification. In the stated example, `Animal` is open for extension,
    so it doesn't contradict the principle to inherit the `monkey` class from `Animal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the chapter source code in GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overriding a private virtual function allows modification of the behavior of
    the class by keeping its public interface untouched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a behavioral design pattern in which an object encapsulates an action and
    all the information required to perform the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By sharing data with other objects as much as possible. When we have a lot of
    objects with a similar structure, sharing repeated data across objects minimizes
    the use of memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The observer notifies subscriber objects regarding an event, while the mediator
    plays the role of a connection hub between intercommunicating objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Designing the game loop as an infinite loop is reasonable because, theoretically,
    the game might never end and only end when the player commands it to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physical, Data-Link, Network, Transport, Session, Presentation, and Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Port numbers provide a way to differentiate between several network applications
    running in the same environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sockets are abstractions providing programmers with a means to send and receive
    data over a network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to create and bind the socket with an IP address. Next, we should
    listen for incoming connections and, if there is one, we should accept the connection
    to further process the data communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCP is a reliable protocol. It handles a strong connection between endpoints
    and also handles packet loss by resending packets not received by the receiver.
    UDP, on the other hand, is not reliable. Almost every aspect of handling rests
    on programmers' shoulders. The advantage of UDP is its speed given that it omits
    handshakes, checks, and packet loss handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Macro definitions lead to logic bugs in the code that are hard to spot. It's
    always better to use `const` expressions rather than macros.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client applications must have unique identifiers as well as tokens (or passwords)
    used to authorize and/or authenticate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a laboratory exercise; no answer is required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following output is from Ubuntu 18.04 on NVIDIA Jetson Nano:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because static analysis tools predict the errors from their models, and dynamic
    analysis tools detect errors via the execution of a program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please refer to the sample code, `ch13_tdd_v3.h`, `ch13_tdd_v3.cpp`, and `ch13_tdd_Boost_UTF3.cpp`,
    at
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-13](https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-13).'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt's compilation model allows the omission of a virtual machine. It uses a **meta-object
    compiler** (**MOC**) to translate into C++, which is then compiled into the machine
    code of the specific platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QApplication::exec()` is the starting point of the application. It starts
    Qt''s event loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling `setWindowTitle()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`m->index (2, 3)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wgt->resize (400, 450)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When inheriting from `QLayout`, you should provide implementation for the `addItem()`,
    `sizeHint()`, `setGeometry()`, `itemAt()`, `takeAt()`, and `minimumSize()` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `connect()` function that takes the source and target objects and
    names of signals and slots as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ML** stands for **machine learning** and is a field of study of algorithms
    and statistical models that computer systems use to perform a specific task without
    using explicit instructions, relying on patterns and inference instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supervised learning algorithms (also known as training with an instructor) learn
    from labeled datasets; that is, each record contains additional information describing
    the data. Unsupervised learning algorithms are even more complex— they process
    the dataset containing a bunch of features and then try to find useful properties
    of the features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ML applications include machine translation, natural language processing, computer
    vision, and email spam detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the ways is to add a weight for each outcome, if the weight for the subtract
    operation overweighs others, it will become the dominant operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The purpose of neural networks is to recognize patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The crawler downloads web pages and stores their content for the search engine
    to index it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call it an inverted index because it maps words back to their locations in
    documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before indexing, tokenization normalizes words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recommendation engines verify and recommend the best outcomes fitting to the
    particular request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A knowledge graph is a graph where nodes are topics (the knowledge) and edges
    are connections between topics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
