- en: '*Chapter 2*: Working with Docker Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At one time, containers were used for stateless workloads that could scale up,
    scale quickly, and move from one location to another without impacting the workload.
    Stateless workloads limit the type of containers you can run, prohibiting you
    from running anything beyond items that are stored in the base image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need persistent data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker bind mounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker tmpfs mounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not have any technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create volumes using the examples in this chapter, you can use
    the Docker host that we created in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*. The volumes that we'll be using for examples
    in this chapter are not required for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the code to create a Docker host from [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Containers Essentials* by going to the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need persistent data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider an example use case where you may want to write data to a persistent
    location from a container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have a system that requires you to deploy a **MySQL** database
    fronted by a web-based application running on **NGINX**. You start both containers
    for the application using standard **docker run** commands. You do some initial
    testing with the users and they confirm that everything is working as expected.
    The users were successful when it came to adding records, querying for records,
    editing, and deletions – this all worked correctly. After a few days of the container
    running, you receive an email from security telling all users that all MySQL servers
    need to have a new patch deployed as soon as possible to address a security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'You quickly work on a new MySQL image that includes the newest patch and push
    it to your container registry. Working with the users, you decide a time to deploy
    the new container and start the process by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the running container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the new image using the same container name that the previous image
    used. To do this, you need to remove the current container using the **docker
    rm** command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the new MySQL container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the container starts up, you log in to verify that MySQL is running and
    to confirm that the patch has been applied. Next, you log into the application
    and search for a record in the database and receive a record not found error.
    You find this to be odd since the system has been running for a few days. To troubleshoot
    further, you log into the database directly to check the health of the database
    and discover that there are no databases on the server.
  prefs: []
  type: TYPE_NORMAL
- en: What happened to your database? Why does it appear that the database server
    has been wiped out and reinitialized? You know the system was working over the
    last few days and everything was running as expected, that is, right up to the
    point that you downloaded a new MySQL image and started it in place of the original
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from our ephemeral discussion in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*, that the writeable layer for the container
    is ephemeral and that all the data that's written to it will be lost when the
    container is removed, even if you start a container with the same name. When you
    removed the container to reuse the name, the container layer that contained the
    database was deleted. When the new container was started, it created a new container
    layer and when MySQL started up, it didn't see any of its base files and created
    a new, fully initialized, MySQL instance.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't want to lose your database every time you need to deploy
    a new version of the database server. Since the container layer is ephemeral,
    you need to store your database outside the base layer on something that will
    persist between image upgrades. So far, we have been telling you that containers
    are ephemeral, so how can you configure your container to save data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Docker includes the ability to add persistent data to a container
    using two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker bind mounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a third option that offers storage using the host's RAM, called
    **tmpfs**. This type of mount is not persistent through container restarts, Docker
    restarts, or host reboots. It is only used as a location to temporarily store
    data in high-speed RAM and is truly ephemeral. While it does not offer persistency,
    there are specific use cases where selecting tmpfs can be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Which option should you select when you need to run containers that require
    persistent data? Both volumes and bind mounts function similarly, storing files
    on the local host filesystem to provide persistency to your container. The final
    decision comes down to understanding how each option is managed, and what data
    it may expose if used improperly.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker volumes are the preferred option to add persistent data to a container.
    A volume is nothing more than a directory on the local host that is mapped to
    the container using a volume mount. When you create a volume, a new directory
    is created on the host filesystem, commonly under **/var/lib/docker/volumes/<volume
    ID>/**. If you have root access to the host, you can look at the file structure
    as you would any other directory. The following screenshot shows the directories
    under the **volumes** directory from a Docker host running containers using volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Docker folder directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.1_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Docker folder directories
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain information between restarts, Docker stores key metadata in various
    databases on the host using Boltdb, which is a fast database written in Go that''s
    used to store persistent key values. There are two Boltdb databases that you may
    come across when browsing the **/var/lib/docker** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/var/lib/docker/volumes/metadata.db**: Maintains metadata for Docker volumes,
    such as the name, driver, labels, and options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/lib/docker/network/files/local-kv.db**: Maintains metadata for Docker
    networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are focusing on data in this chapter, we will use the **metadata.db**
    database. As you will see later in this chapter, when you create a Docker volume,
    you can provide options such as a name or label. This information is stored in
    the database to maintain volume persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example from **metadata.db** in JSON format for a Docker volume
    called **webdata**:'
  prefs: []
  type: TYPE_NORMAL
- en: webdata{"Name":"webdata","Driver":"local","Labels":null,"Options":null}
  prefs: []
  type: TYPE_NORMAL
- en: Every Docker volume has a directory in the **/var/lib/docker/volumes** directory.
    In each volume folder, there is a directory called **_data** that contains the
    actual data for the container.
  prefs: []
  type: TYPE_NORMAL
- en: Before using a volume with a container, it must be created. Creating a Docker
    volume can be done manually using the Docker CLI or automatically by the Docker
    daemon when a container is started. Since both methods are created by Docker,
    they are owned and managed by Docker itself, making it is easy to manage and track
    them using the Docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a volume using the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Docker volume, we can use the volume management options:'
  prefs: []
  type: TYPE_NORMAL
- en: docker volume <option>
  prefs: []
  type: TYPE_NORMAL
- en: 'The available options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Volume management options'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15514_Table_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – Volume management options
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new volume, use the **create** option:'
  prefs: []
  type: TYPE_NORMAL
- en: docker volume create <optional volume name>
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing **create**, you will see the volume name that was created.
    If you did not provide the optional volume name, Docker will assign a volume ID
    as the name. Creating a volume without providing a volume name is known as an
    anonymous volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Anonymous volume output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.2_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Anonymous volume output
  prefs: []
  type: TYPE_NORMAL
- en: An anonymous volume can be difficult to keep track of as you add additional
    containers to your host that use volumes. Therefore, it is considered a best practice
    to name your volume at creation time, rather than allowing Docker to generate
    a long anonymous volume name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any volume that you provide a volume name for at creation is called a named
    volume. To create a named volume, you need to supply the volume name to the **docker
    volume create** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Named volume output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.3_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Named volume output
  prefs: []
  type: TYPE_NORMAL
- en: Once a volume is created using either method, you can verify that the directory
    was created for your volume by looking in **/var/lib/docker/volumes**. You will
    find a directory with the name of the volume that was returned by the **create**
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create a volume, the next step is to use it with a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a volume in a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process to mount a volume in a container is the same as the one that's followed
    for a named or anonymous volume. We already went over the process of creating
    a volume using the Docker CLI, but we didn't explain how to let Docker automatically
    create a volume.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explain how to have Docker automatically create a volume
    and mount it. We will also explain how to mount a previously created named volume
    to a container.
  prefs: []
  type: TYPE_NORMAL
- en: When mounting a volume in a container, you need to provide one of two options
    to the **docker start** command. The two options you can use to mount volumes
    are **--mount** or **-v**. If you are running a standard container, you can use
    either option, but **-v** is the most commonly used option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we created a volume called **pv-mysql-data**. We now
    want to start our MySQL container with the named volume so that we will have a
    persistent database. To mount a volume in your container, you need to pass the
    **-v** option when starting the container. The **-v** option requires two arguments:
    the volume name and the container mountpoint. In the following example command,
    you can see the command to start MySQL with a named volume mount. We also added
    some additional options that are being passed to the container, specifically the
    **-e** option, which is used to set an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
  prefs: []
  type: TYPE_NORMAL
- en: This will start a container running MySQL, with a name of **mysql-01**, that
    mounts a volume called **pv-mysql-data** in a mount point called **/var/lib/mysql**
    in the container. The last option, which is using **-e**, creates an environment
    variable that is called **MYSQL_ROOT_PASSWORD**, which is set to **my-password**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the container is up and running, you can look at the volume directory
    to verify that MySQL mounted the volume correctly by checking the data in the
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – MySQL persistent volume'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.4_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – MySQL persistent volume
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the new volume contains all the standard files that are created
    when a new MySQL server is started for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We also mentioned that you can let Docker create the volume automatically, instead
    of creating the volume yourself. To have Docker create the volume upon container
    startup, run the same command that you would if you were using a pre-created volume.
    For example, using the previous MySQL example, let's assume *we did not* pre-create
    the volume using the **docker volume create** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
  prefs: []
  type: TYPE_NORMAL
- en: When we do this, the Docker daemon will recognize that there is no existing
    volume named **pv-mysql-data** and one will be created before it's mounted in
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting an existing volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the container layers, which are also stored on the local host, volumes
    are not lost if a container is removed from Docker. In our MySQL upgrade example
    from earlier, we upgraded our database server to a newer version. Since we wanted
    to keep the container name the same as the previously deployed container, we removed
    the old container and started the new container with the same name. By removing
    the container, we removed the container layer that was stored on the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid losing our database after an upgrade, or after a container has been
    removed from our host, we can mount the existing volume in our new running container.
    Since volumes are not deleted by default, the data is still on the local filesystem
    and ready to be used by any other container.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we stop and remove our MySQL server, the volume remains intact. When we
    start the new MySQL container, we only need to supply the **-v** option using
    the same volume name that was used in the original container. This is why creating
    a named volume is preferred over an anonymous volume. In our example, we created
    a named volume called **pv-mysql-data**. To run the new container, using the same
    volume, we can use the **docker run** command with the **-v** option, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql:v2
  prefs: []
  type: TYPE_NORMAL
- en: This will launch our new **mysql:v2** container with the same volume as the
    previous container, with the existing database completely intact.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a volume in multiple containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if you had an application that requires multiple containers, and each of
    them requires the exact same data? While you could create a volume for each container
    and copy the data into each, a more efficient method would be to share a single
    volume between multiple containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'One unique characteristic of Docker volumes is that multiple containers can
    access the same volume. While this sounds like an easy solution to provide a single
    location to shared data, you need to keep in mind that not every application plays
    nicely when multiple processes access the same data. Using our database example,
    starting up a second container using the same volume would cause the second container''s
    MySQL server to fail at startup. Since the files are locked by the first container''s
    database, the second container cannot gain exclusive access to the database to
    mount it. If you look at the logs for the second instance, you will see the error
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Locking error output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.5_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Locking error output
  prefs: []
  type: TYPE_NORMAL
- en: There are use cases where a shared volume will offer benefits to your application.
    Imagine that you were running a few instances of a web server on your host that
    only presented data that was retrieved from a folder that changed nightly. One
    option would be to create a new container each night using a pipeline, but for
    this example, we will assume that you do not have a CI/CD system in place.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you may have a process on the host that pulls the data into the directory
    where the Docker volume has been created. Each web server will use a volume mount,
    using the same Docker volume. This allows each container to access the data from
    a single shared location, without any changes needing to be made to the base image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, you simply need to supply the same mount option to each
    container when the container starts. For example, we have created a volume called
    **webdata** on our host, and we want to launch four NGINX servers that will use
    the data in the Docker volume. When you start each instance, you just use the
    same **webdata** named volume:'
  prefs: []
  type: TYPE_NORMAL
- en: docker run --name webserver01 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver02 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver03 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver04 -v webdata:/opt/web/data -d bitnami/nginx:latest
  prefs: []
  type: TYPE_NORMAL
- en: Since the NGINX server is only going to read the data, we will not run into
    any of the locking errors that we encountered for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been talking about volumes and have created a few of them,
    you might recognize that when you have many volumes on a host, it can become difficult
    to remember what volumes exist. The next section will discuss some basic management
    options for our volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Docker volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that volumes are managed by Docker, so the daemon knows about every
    volume that was created. If you want to list every volume that you or the Docker
    daemon has created, use the **docker volume list** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – docker volume list output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.6_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – docker volume list output
  prefs: []
  type: TYPE_NORMAL
- en: This option will display all the volumes that are currently being managed by
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Docker never deletes the volumes that are created for containers.
    We already know that when we stop and start a container using a volume, the data
    persists, but what can we do about the data after we no longer need it?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the amount of data in the **/var/lib/docker/volumes** folder can
    grow at a tremendous rate. Because of this, it is a best practice to prune or
    remove the volumes to free up disk space – we often refer to this as part of a
    garbage collection process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to delete the data from an image that''s no longer required
    is to use the **-v** option when you remove the container from Docker. We have
    used **docker rm <image name>** a few times in this book to remove an image from
    the host. If you have a volume attached to the container and you want to delete
    the data when you remove the image, you can add the **-v** option to the **rm**
    command, which will delete all the volumes that were associated with the container.
    To delete our MySQL server and the persistent data, we would use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: docker rm -v mysql
  prefs: []
  type: TYPE_NORMAL
- en: There will be times where you will not want to delete the data by removing the
    container. Deleting a volume cannot be undone, so a better practice is to remove
    the container and keep the volume for a set number of days. After a defined period
    of time, you may be more comfortable deleting the volume or volumes.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to delete a single or multiple volumes, you can use the **docker
    volume rm** option. You can supply the volume name, or names, after the **rm**
    option. Each volume that is supplied will be delete by the system, freeing up
    disk space on the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be nervous that you might delete a volume that is being used by a container.
    Fear not – Docker has you covered. If you attempt to delete any volume that is
    currently in use by a running container, or assigned to a stopped container, you
    will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error response from daemon: remove test-auto: volume is in use - [51000e2f61c79ae705cdac78692fa5590fb2b26d3d0eb0a3916df230
    daf1b617]'
  prefs: []
  type: TYPE_NORMAL
- en: Docker will only allow you to delete a volume that has not been opened by a
    running container.
  prefs: []
  type: TYPE_NORMAL
- en: You may have many volumes that you want to delete. While you could supply each
    name using the **remove** command, Docker provides another option, known as pruning.
    Pruning will look at all the volumes and remove any volume that is not currently
    mounted on a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful using this option – only use it if you know that the volumes that
    are not in use do not contain data that you need for any reason. This process
    is final and once run, it will delete *all* the volumes that are not in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete unused volumes, we use the **docker volume prune** option. This command
    will look at all the volumes, and any volume that is not attached to a running
    container will be deleted. When you issue the command, it will warn you that it
    will delete any volume without at least one running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – docker prune confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.7_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – docker prune confirmation
  prefs: []
  type: TYPE_NORMAL
- en: '**Select** **y** **for yes carefully** – there is no undo command for this
    action. Once executed, you will receive a summary of the deleted volumes, including
    their names and the total reclaimed disk space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – docker prune results'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.8_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – docker prune results
  prefs: []
  type: TYPE_NORMAL
- en: That completes the Docker volume section of this chapter. Remember that volumes
    are just one way to provide data persistence to your containers. The other method
    is called a bind mount, and while it also uses the host filesystem like a volume,
    bind mounts have a very different use case.
  prefs: []
  type: TYPE_NORMAL
- en: Docker bind mounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second option you can use to provide persistent data to a container is
    called a bind mount. Overall, volumes and bind mounts may look similar; both use
    the local host''s filesystem, and both are mounted using the **docker -v** option.
    While they do share many of the same characteristics, a bind mount differs from
    a volume mount in one main area: it is *not* managed by Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a Docker volume, a bind mount cannot be created by Docker. You cannot
    create a bind mount using the **docker volume create** option; however, a bind
    mount can be created automatically by Docker when a container starts. Even though
    Docker can create the bind mount location on the host, it does not "manage" the
    mount.
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker does not manage the bind mounts, they cannot be deleted using a
    Docker command. Docker does not track the location of bind mounts in a list. If
    you create bind mounts in different areas of the filesystem on the host, you need
    to track the location of each one to remove once you no longer need the data manually.
  prefs: []
  type: TYPE_NORMAL
- en: A bind mount is a directory located anywhere on the host's filesystem that is
    bound to the container using the **docker -v** option. Unlike a volume, which
    is always located in a predefined location usually, such as **/var/lib/docker/volumes**,
    a bind mount can be anywhere on the host's filesystem. Since the directory is
    on the filesystem, you may run into permission issues when trying to access a
    directory. This discussion is outside the scope of this book and moves into the
    realms of Linux file system permissions.
  prefs: []
  type: TYPE_NORMAL
- en: You can bind any existing directory or create a new directory either by pre-creating
    the directory or letting Docker create the directory on container startup.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain how to use a bind mount, you might be asking yourself, *"Why
    would I use a bind mount?"* or *"Why would I use a volume? Why do I care which
    one I should use?".* We'll explain why you may or may not want to use a bind mount
    and then compare them to volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bind mount can be beneficial when you need to share something on the host
    system with a running container. For example, you develop an application on your
    local laptop and you want to test the application before finalizing the code.
    Rather than running it on your local console, you want to test it in a container.
    You could store your source code in **/source** and then, when you compile, you
    could store the executable and any libraries in **/apps/testapp**. Let''s take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You start a container with the **-v** option, which will bind mount the local
    host''s **/apps/testapp** folder in the container. This doesn''t change very much
    from using a volume in a container. In fact, the syntax to mount a bind location
    is the same as mounting a volume to a container when using the **docker run -v**
    option. However, rather than providing a volume name in the **-v** option, you
    need to provide the local host directory instead; for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**docker run -d -v /apps/testapp:/bin/testapp ubuntu:latest**'
  prefs: []
  type: TYPE_NORMAL
- en: This will start a container running Ubuntu with a mount inside the container
    that binds to the local host's **/apps/testapp** path, where the compiled application
    is located.
  prefs: []
  type: TYPE_NORMAL
- en: To test the application, you would attach to the running image and execute the
    application by running **/bin/testapp/testapp**. Since the container's mount is
    using the local hosts directory, you can test the app and if any errors are encountered,
    you can fix the code and simply recompile the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once recompiled, you can run the new executable in the container again to test
    the application. This saves you from creating multiple test images, iterating
    through images after an issue is discovered. Once you have successfully tested
    the application, you can stop the container and create the final container image
    that includes the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker volumes cannot provide the same solution since they are all located in
    a directory on the host and cannot be pointed to an existing directory.
  prefs: []
  type: TYPE_NORMAL
- en: There are other example use cases for using bind mounts. The main point to remember
    is that bind mounts can be used to share data anywhere on the host system with
    a container. When used in the correct scenario, bind mounts are very useful, but
    when used incorrectly, their use can lead to an unstable system or a security
    breach.
  prefs: []
  type: TYPE_NORMAL
- en: It should go without saying that you should be careful when using any existing
    directory on the host system with a container. Binding your host's **/etc** directory
    in a container may lead to unexpected results. Someone running a shell in a container
    could easily delete or edit a file, or multiple files, making the host's system
    unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Docker tmpfs mounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we mentioned that Docker allows you to use
    the host''s RAM as a temporary storage location for container data. This type
    of mount will not persist data but for the right workload, it can be a very useful
    storage location. tmpfs offers a few unique advantages that are not available
    in volumes or bind mounts:'
  prefs: []
  type: TYPE_NORMAL
- en: The size can be pre-defined to limit the amount of RAM that is consumed for
    storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers very fast data access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also some limitations to tmpfs mounts:'
  prefs: []
  type: TYPE_NORMAL
- en: They are only available on Linux; Windows is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single tmpfs can only be mounted to one container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a tmpfs mount in a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A container can be started with a tmpfs mount by adding either **--mount** or
    using the **--tmpfs** option. In general, you should use the **--mount** option
    by default since **--tmpfs** does not allow for any customizations on the mount.
    If you use **--tmpfs**, you will not be able to set a size limit, or any file
    mode security. Since this type of mount will use an expensive resource, namely
    the host's RAM, you will want to create a size for your mount. Due to these limitations,
    we highly suggest that you do not use **--tmpfs** to create your tmpfs mounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a tmpfs mount for a NGINX container, you need to use the **--mount**
    option when you start the image:'
  prefs: []
  type: TYPE_NORMAL
- en: docker run --mount type=tmpfs,target=/opt/html,tmpfs-mode=1770,tmpfs-size=1000000
    --name nginx-test -d bitnami/nginx:latest
  prefs: []
  type: TYPE_NORMAL
- en: 'The mount option allows you to add multiple options after specifying **--mount**
    in your **run** command. In our example, we are adding options for the type of
    mount, the target mount in the container, the file mode, and the size. The following
    table shows the details for each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.2 – Docker tmpfs optiond'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15514_Table_2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.2 – Docker tmpfs optiond
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created a tmpfs mount, we want to list the volumes on the
    host to verify we have a tmpfs mount. You may recall that we can list the volumes
    using the **docker volume ls** command. The output after creating the tmpfs mount
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Docker volume list'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.9_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Docker volume list
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the list is empty; there are no volumes in use according to the
    Docker daemon. tmpfs mounts will not appear in the volume list since they are
    not "true" volumes; only volumes appear when using the **docker volume ls** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to verify the tmpfs mount in the container, you can look at the
    **docker inspect** command''s output from the container and look for the **"Mounts"**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Docker inspect output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.10_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Docker inspect output
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also verify the mount inside the running container by executing a Linux
    **df** command when using the **docker exec** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – tmpfs mount in Linux'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_2.11_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – tmpfs mount in Linux
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the highlighted section of the **df** command's output, the
    mount exists in the container and the size is correct.
  prefs: []
  type: TYPE_NORMAL
- en: We want to show one last example of using a mount where we do not specify a
    size for the tmpfs space. If you do not specify a size, Docker will create a mount
    using half the RAM of the host. Our example server has **26 GB** of RAM and we
    have executed a **docker run** command with the same container without specifying
    a size.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we do specify a size in the **mount** command. To verify the container
    has the **/opt/html** target, we can execute a **df -u** command using **docker
    exec** and confirm that the **/opt/html** mount was created. As you may have noticed,
    the volume size is **13 GB**, which is **half** of the **26 GB** of RAM for the
    host. It is important to point out that while the volume is set to 26 GB, it has
    no data at this time, so it is not consuming any RAM yet. RAM is not consumed
    until data is stored in the container, so you need to be very careful with tmpfs
    volumes or you may run out of RAM on your host and may crash your system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned multiple ways you can handle data in a container.
    After reading this chapter you should know how to decide on the appropriate type
    of storage to use for your containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about Docker networking by learning about the
    Docker default bridge network. We'll also learn how to use and create user-defined
    bridges and expose container services on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following volumes provides persistent storage for containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. tmpfs
  prefs: []
  type: TYPE_NORMAL
- en: B. Bind mounts
  prefs: []
  type: TYPE_NORMAL
- en: C. Volumes
  prefs: []
  type: TYPE_NORMAL
- en: D. SAN
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes must be created before they can be mounted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: You create a tmpfs volume on a host that has 64 GB of RAM. During its creation,
    you failed to set a size. What size volume will Docker create?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. 1 GB
  prefs: []
  type: TYPE_NORMAL
- en: B. 64 GB
  prefs: []
  type: TYPE_NORMAL
- en: C. 20 GB
  prefs: []
  type: TYPE_NORMAL
- en: D. 32 GB
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes are automatically deleted when you remove a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: Which volume type is managed by the Docker daemon?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Bind volumes
  prefs: []
  type: TYPE_NORMAL
- en: B. Named volumes
  prefs: []
  type: TYPE_NORMAL
- en: C. All volumes
  prefs: []
  type: TYPE_NORMAL
- en: D. None
  prefs: []
  type: TYPE_NORMAL
- en: How do you delete an unused bind volume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. There is no need to; Docker will delete it automatically
  prefs: []
  type: TYPE_NORMAL
- en: B. **docker volume prune**
  prefs: []
  type: TYPE_NORMAL
- en: C. **docker volume bind prune**
  prefs: []
  type: TYPE_NORMAL
- en: D. You must manually delete the bind folder
  prefs: []
  type: TYPE_NORMAL
