- en: Chapter 2. Getting Hands-on with I/O, Redirection Pipes, and Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In day-to-day work, we come across different kinds of files such as text files,
    source code files from different programming languages (for example, `file.sh`,
    `file.c`, and `file.cpp`), and so on. While working, we often perform various
    operations on files or directories such as searching for a given string or pattern,
    replacing strings, printing few lines of a file, and so on. Performing these operations
    is not easy if we have to do it manually. Manual searching for a string or pattern
    in a directory having thousands of files can take months, and has high chances
    of making errors.
  prefs: []
  type: TYPE_NORMAL
- en: Shell provides many powerful commands to make our work easier, faster, and error-free.
    Shell commands have the ability to manipulate and filter text from different streams
    such as standard input, file, and so on. Some of these commands are `grep`, `sed`,
    `head`, `tr`, `sort`, and so on. Shell also comes with a feature of redirecting
    output from one command to another with the pipe ('`|`'). Using pipe helps to
    avoids creation of unnecessary temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best qualities of these commands is that they come along with the
    `man` pages. We can directly go to the `man` page and see what all features they
    provide by running the `man` command. Most of the commands have options such as
    `--help` to find the help usage and `--version` to know the version number of
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard I/O and error streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting the standard I/O and error streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe and pipelines—connecting commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering output using `grep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing output using `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating a stream using `tee`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting and finding unique text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character-based translation using `tr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering based on lines—`head` and `tail`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cut-based selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard I/O and error streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In shell programming, there are different ways to provide an input (for example,
    via a keyboard and terminal) and display an output (for example, terminal and
    file) and error (for example, terminal), if any, during the execution of a command
    or program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show the input, output, and error while running the
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input from a user by a keyboard and the input obtained by a program via
    a standard input stream, that is terminal, is taken as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output printed on the standard output stream, that is terminal, is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message printed on the standard error stream, that is terminal, is
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When a program executes, by default, three files get opened with it which are
    `stdin`, `stdout`, and `stderr`. The following table provides a short description
    of each of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File descriptor number | File name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `stdin` | This is standard input being read from the terminal |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `stdout` | This is standard output to the terminal |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `stderr` | This is standard error to the terminal |'
  prefs: []
  type: TYPE_TB
- en: File descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File descriptors are integer numbers representing opened files in an operating
    system. The unique file descriptor numbers are provided to each opened files.
    File descriptors' numbers go up from `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new process in Linux is created, then standard input, output, and
    error files are provided to it along with other needed opened files to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know what all open file descriptors are associated with a process, we will
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run an application and get its process ID first. Consider running `bash` as
    an example to get PID of bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that multiple bash processes are running. Take one of the bash PID example,
    `2508`, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We see that 0, 1, and 2 opened file descriptors are associated with process
    bash. Currently, all of them are pointing to `/dev/pts/5`. `pts`, which is pseudo
    terminal slave.
  prefs: []
  type: TYPE_NORMAL
- en: So, whatever we will do in this bash, input, output, and error related to this
    PID, output will be written to the `/dev/pts/5` file. However, the `pts` files
    are pseudo files and contents are in memory, so you won't see anything when you
    open the file.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the standard I/O and error streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have an option to redirect standard input, output, and errors, for example,
    to a file, another command, intended stream, and so on. Redirection is useful
    in different ways. For example, I have a bash script whose output and errors are
    displayed on a standard output—that is, terminal. We can avoid mixing an error
    and output by redirecting one of them or both to a file. Different operators are
    used for redirection. The following table shows some of operators used for redirection,
    along with its description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | This redirects a standard output to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | This appends a standard output to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | This redirects a standard input from a file |'
  prefs: []
  type: TYPE_TB
- en: '| `>&` | This redirects a standard output and error to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `>>&` | This appends a standard output and error to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This redirects an output to another command |'
  prefs: []
  type: TYPE_TB
- en: Redirecting standard output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An output of a program or command can be redirected to a file. Saving an output
    to a file can be useful when we have to look into the output in the future. A
    large number of output files for a program that runs with different inputs can
    be used in studying program output behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, showing redirecting echo output to `output.txt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that no output is displayed on the terminal. This is because output
    was redirected to `output.txt`. The operator ''`>`'' (greater than) tells the
    shell to redirect the output to whatever filename mentioned after the operator.
    In our case, it''s `output.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some more output to the `output.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We noticed that the previous content of the `output.txt` file got erased and
    it only has the latest redirected content. To retain the previous content and
    append the latest redirected output to a file, use the operator ''`>>`'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also redirect an output of a program/command to another command in bash
    using the operator ''`|`'' (pipe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we gave the output of `ls` to the `grep` command using the
    ''`|`'' (pipe) operator, and `grep` gave the matching search result of the `libc.so`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting standard input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of getting an input from a standard input to a command, it can be redirected
    from a file using the < (less than) operator. For example, we want to count the
    number of words in the `output.txt` file created from the *Redirecting standard
    output* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sort the content of `output.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also give a `patch` file as an input to the `patch` command in order
    to apply a `patch.diff` in a source code. The command `patch` is used to apply
    additional changes made in a file. Additional changes are provided as a `diff`
    file. A `diff` file contains the changes between the original and the modified
    file by running the `diff` command. For example, I have a patch file to apply
    on `output.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting standard errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a possibility of getting an error while executing a command/program
    in bash because of different reasons such as invalid input, insufficient arguments,
    file not found, bug in program, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, errors are printed on a terminal so that it''s easy for us to know
    the reason for an error. Printing both the errors and output on the terminal can
    be annoying because we have to manually look into each line and check whether
    the program encountered any error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We ran a series of commands in the preceding section. First `cd` to `/`, `ls`
    content of `/`, cat file `hello.txt`, `cd` to `/bin` and see files matching `*.py`
    and `*.sh` in `/bin/`. The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that `hello.txt` doesn''t exist in the `/` directory and because of
    this there is an error printed on the terminal as well, along with other output.
    We can redirect the error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the error has been redirected to the `error.txt` file. To verify,
    check the `error.txt` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Multiple redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can redirect `stdin`, `stdout`, and `stderr` together in a command or script
    or a combination of some of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command redirects both `stdout` and `stder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `stdout` is redirected to `log.txt` and error messages are redirected
    to `log.txt` as well. In `2>&1`, `2>` means redirect an error and `&1` means redirect
    to `stdout`. In our case, we have already redirected `stdout` to the `log.txt`
    file. So, now both the `stdout` and `stderr` outputs will be written into `log.txt`
    and nothing will be printed on the terminal. To verify, we will check the content
    of `log.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows the `stdin`, `stdout`, and `stderr` redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `.bashrc` file present in the `home` directory acts as an input to
    the `cat` command and its output is redirected to the `out.txt` file. Any error
    encountered in between is redirected to the `err.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `bash` script will explain `stdin`, `stdout`, `stderr`, and their
    redirection with even more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This script saves two snapshots of all running processes in the system and
    generates `diff`. The output after running the process will look somewhat as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pipe and pipelines – connecting commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The outputs of the programs are generally saved in files for further use. Sometimes,
    temporary files are created in order to use an output of a program as an input
    to another program. We can avoid creating temporary files and feed the output
    of a program as an input to another program using bash pipe and pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pipe denoted by the operator `|` connects the standard output of a process
    in the left to the standard input in the right process by inter process communication
    mechanism. In other words, the `|` (pipe) connects commands by providing the output
    of a command as the input to another command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `cat` command, instead of displaying the content of the `/proc/cpuinfo`
    file on `stdout`, passes its output as an input to the `less` command. The `less`
    command takes the input from `cat` and displays on the `stdout` per page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example using pipe is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pipeline is a sequence of programs/commands separated by the operator '' `|`
    '' where the output of execution of each command is given as an input to the next
    command. Each command in a pipeline is executed in a new subshell. The syntax
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`command1 | command2 | command3 …`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples showing pipeline are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are first getting a list of files from the `/usr/lib64` directory that
    has the `.so` extension. The output obtained is passed as an input to the next
    `grep` command to look for the `libc` string. The output is further given to the
    `wc` command to count the number of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expression (also known as regex or regexp) provides a way of specifying
    a pattern to be matched in a given big chunk of text data. It supports a set of
    characters to specify the pattern. It is widely used for a text search and string
    manipulation. A lot of shell commands provide an option to specify regex such
    as `grep`, `sed`, `find`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression concept is also used in other programming languages such
    as C++, Python, Java, Perl, and so on. Libraries are available in different languages
    to support regular expression's features.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression metacharacters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The metacharacters used in regular expressions are explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Metacharacters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| * (Asterisk) | This matches zero or more occurrences of the previous character
    |'
  prefs: []
  type: TYPE_TB
- en: '| + (Plus) | This matches one or more occurrences of the previous character
    |'
  prefs: []
  type: TYPE_TB
- en: '| ? | This matches zero or one occurrence of the previous element |'
  prefs: []
  type: TYPE_TB
- en: '| . (Dot) | This matches any one character |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | This matches the start of the line |'
  prefs: []
  type: TYPE_TB
- en: '| $ | This matches the end of line |'
  prefs: []
  type: TYPE_TB
- en: '| [... ] | This matches any one character within a square bracket |'
  prefs: []
  type: TYPE_TB
- en: '| [^... ] | This matches any one character that is not within a square bracket
    |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; (Bar) | This matches either the left side or the right side element
    of &#124; |'
  prefs: []
  type: TYPE_TB
- en: '| \{X\} | This matches exactly X occurrences of the previous element |'
  prefs: []
  type: TYPE_TB
- en: '| \{X,\} | This matches X or more occurrences of the previous element |'
  prefs: []
  type: TYPE_TB
- en: '| \{X,Y\} | This matches X to Y occurrences of the previous element |'
  prefs: []
  type: TYPE_TB
- en: '| \(...\) | This groups all the elements |'
  prefs: []
  type: TYPE_TB
- en: '| \< | This matches the empty string at the beginning of a word |'
  prefs: []
  type: TYPE_TB
- en: '| \> | This matches the empty string at the end of a word |'
  prefs: []
  type: TYPE_TB
- en: '| \ | This disables the special meaning of the next character |'
  prefs: []
  type: TYPE_TB
- en: Character ranges and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look into a human readable file or data, its major content contains
    alphabets (a to z) and numbers (0 to 9). While writing regex for matching a pattern
    consisting of alphabets or numbers, we can make use character ranges or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Character ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use character ranges in a regular expression as well. We can specify
    a range by a pair of characters separated by a hyphen. Any characters that fall
    in between that range, inclusive, are matched. Character ranges are enclosed inside
    square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of character ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Character range | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-z]` | This matches any single lowercase letter from a to z |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z]` | This matches any single uppercase letter from A to Z |'
  prefs: []
  type: TYPE_TB
- en: '| `[0-9]` | This matches any single digit from 0 to 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-zA-Z0-9]` | This matches any single alphabetic or numeric characters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[h-k]` | This matches any single letter from h to k |'
  prefs: []
  type: TYPE_TB
- en: '| `[2-46-8j-lB-M]` | This matches any single digit from 2 to 4 or 6 to 8 or
    any letter from j to l or B to M |'
  prefs: []
  type: TYPE_TB
- en: '**Character classes**: Another way of specifying a range of character matches
    is by using Character classes. It is specified within the square brackets [:class:].
    The possible class value is mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Character Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alnum:]` | This matches any single alphabetic or numeric character; for
    example, [a-zA-Z0-9] |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alpha:]` | This matches any single alphabetic character; for example,
    [a-zA-Z] |'
  prefs: []
  type: TYPE_TB
- en: '| `[:digit:]` | This matches any single digit; for example, [0-9] |'
  prefs: []
  type: TYPE_TB
- en: '| `[:lower:]` | This matches any single lowercase alphabet; for example, [a-z]
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[:upper:]` | This matches any single uppercase alphabet; for example, [A-Z]
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[:blank:]` | This matches a space or tab |'
  prefs: []
  type: TYPE_TB
- en: '| `[:graph:]` | This matches a character in the range of ASCII—for example
    33-126—excluding a space character |'
  prefs: []
  type: TYPE_TB
- en: '| `[:print:]` | This matches a character in the range of ASCII—for example.
    32-126—including a space character |'
  prefs: []
  type: TYPE_TB
- en: '| `[:punct:]` | This matches any punctuation marks such as ''?'', ''!'', ''.'',
    '','', and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `[:xdigit:]` | This matches any hexadecimal characters; for example, [a-fA-F0-9]
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[:cntrl:]` | This matches any control characters |'
  prefs: []
  type: TYPE_TB
- en: '**Creating your own regex**: In the previous sections of regular expression,
    we discussed about metacharacters, character ranges, character class, and their
    usage. Using these concepts, we can create powerful regex that can be used to
    filter out text data as per our need. Now, we will create a few regex using the
    concepts we have learned.'
  prefs: []
  type: TYPE_NORMAL
- en: Matching dates in mm-dd-yyyy format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will consider our valid date starting from UNIX Epoch—that is, 1st January
    1970\. In this example, we will consider all the dates between UNIX Epoch and
    30th December 2099 as valid dates. An explanation of forming its regex is given
    in the following subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: Matching a valid month
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 0[1-9] matches 01st to 09th month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1[0-2] matches 10th, 11th, and 12th month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''|'' matches either left or right expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together, the regex for matching a valid month of date will be
    **0[1-9]|1[0-2]**.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a valid day
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 0[1-9] matches 01st to 09th day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12][0-9] matches 10th to 29th day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3[0-1] matches 30th to 31st day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''|'' matches either left or right expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0[1-9]|[12][0-9]|3[0-1]** matches all the valid days in a date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching the valid year in a date
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 19[7-9][[0-9] matches years from 1970 to 1999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20[0-9]{2} matches years from 2000 to 2099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''|'' matches either left or right expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**19[7-9][0-9]|20[0-9]{2}** matches all the valid years between 1970 to 2099'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining valid months, days, and years regex to form valid dates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our date will be in mm-dd-yyyy format. By putting together regex formed in
    the preceding sections for months, days, and years, we will get regex for the
    valid date:'
  prefs: []
  type: TYPE_NORMAL
- en: (0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[0-1])-(19[7-9][0-9]|20[0-9]{2})
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a nice website, [http://regexr.com/](http://regexr.com/), where you
    can also validate regular expression. The following screenshot shows the matching
    of the valid date among the given input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining valid months, days, and years regex to form valid dates](img/4335_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regex for a valid shell variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. The Beginning of the Scripting Journey"),
    *Beginning of Scripting Journey*, we learned nomenclature of variables in shell.
    A valid variable name can contain a character from alphanumeric and underscore,
    and the first letter of the variable can't be a digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping these rules in mind, a valid shell variable regex can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[_a-zA-Z][_a-zA-Z0-9]*$
  prefs: []
  type: TYPE_NORMAL
- en: Here, ^ (caret) matches the start of a line.
  prefs: []
  type: TYPE_NORMAL
- en: The regex [_a-zA-Z] matches _ or any upper or lower case alphabet [_a-zA-Z0-9]*
    matches zero or multiple occurrences of _,any digit or upper and lower case alphabet
    $ (Dollar) matches the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: In character class format, we can write regex as **^[_[:alpha:]][_[:alnum:]]*$**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows valid shell variables using regex formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regex for a valid shell variable](img/4335_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enclose regular expression in single quotes (') to avoid pre-shell expansion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use back slash (\) before a character to escape the special meaning of metacharacters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metacharacters such as ?, +, {, |, (, and ) are known to be extended regex.
    They lose their special meaning when used in basic regex. To avoid this, use them
    with backslash '\?', '\+', '\{', '\|', '\(', and '\)'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering an output using grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the powerful and widely used command in shell is `grep`. It searches
    in an input file and matches lines in which the given pattern is found. By default,
    all the matched patterns are printed on `stdout` that is usually terminal. We
    can also redirect the matched output to other streams such as file. Instead of
    giving an input from a file, `grep` can also take the input from the redirected
    output of the command executed on the left-hand side of '`|`'.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of using the `grep` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep [OPTIONS] PATTERN [FILE...]`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `FILE` can be multiple files for a search. If no file is given as an input
    for a search, it will search the standard input.
  prefs: []
  type: TYPE_NORMAL
- en: '`PATTERN` can be any valid regular expression. Put `PATTERN` within single
    quotes ('') or double quotes (") as per need. For example, use single quotes ('')
    to avoid any bash expansion and double quotes (") for expansion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of `OPTIONS` are available in `grep`. Some of the important and widely
    used options are discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -i | This enforces case insensitive match in both pattern and input file(s)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | This displays the non-matching line |'
  prefs: []
  type: TYPE_TB
- en: '| `-o` | This displays only the matched part in the matching line |'
  prefs: []
  type: TYPE_TB
- en: '| `-f FILE` | This obtains a pattern from a file, one per line |'
  prefs: []
  type: TYPE_TB
- en: '| `-e PATTERN` | This specifies multiple search pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `-E` | This considers pattern as an extended regex (egrp) |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | This reads all the files in a directory recursively, excluding resolving
    of symbolic links unless explicitly specified as an input file |'
  prefs: []
  type: TYPE_TB
- en: '| `-R` | This reads all the files in a directory recursively and resolving
    symbolic if any |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | This processes binary file as a text file |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | This prefixes each matched line along with a line number |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Don''t print anything on stdout |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Don''t print error messages |'
  prefs: []
  type: TYPE_TB
- en: '| `-c` | This prints the count of matching lines of each input file |'
  prefs: []
  type: TYPE_TB
- en: '| `-A NUM` | This prints NUM lines after the actual string match. (No effect
    with the -o option) |'
  prefs: []
  type: TYPE_TB
- en: '| `-B NUM` | This prints NUM lines before the actual string match. (No effect
    with the -o option) |'
  prefs: []
  type: TYPE_TB
- en: '| `-C NUM` | This prints NUM lines after and before the actual string match.
    (No effect with the -o option) |'
  prefs: []
  type: TYPE_TB
- en: Looking for a pattern in a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot of times we have to search for a given string or a pattern in a file.
    The `grep` command provides us the capability to do it in a single line. Let''s
    see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input file for our example will be `input1.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to get the following information from the `input1.txt` file using
    the `grep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line starting with a capital letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line ending with a period (.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of sentences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching sub-string `sent lines` that don't have a `periodNumber` of times
    the string `file` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shell script demonstrates how to do the above mentioned tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the `pattern_search.sh` shell script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Looking for a pattern in multiple files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `grep` command also allows us to search for a pattern in multiple files
    as an input. To explain this in detail, we will head directly to the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: The input files, in our case, will be `input1.txt` and `input2.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse the content of the `input1.txt` file from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `input2.txt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will try to get the following information from the `input1.txt` and `input2.txt`
    files using the `grep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the string `command`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case-insensitive search of the string `command`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the line number where the string `grep` matches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for punctuation marks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print one line followed by the matching lines while searching for the string
    `important`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shell script demonstrates how to follow the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output after running the shell script `pattern_search.sh`.
    The matched pattern string has been highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for a pattern in multiple files](img/4335_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A few more grep usages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following subsections will cover a few more usages of the `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: Searching in a binary file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have seen all the `grep` examples running on text files. We can also
    search for a pattern in binary files using `grep`. For this, we have to tell the
    `grep` command to treat a binary file as a text file too. The option `-a` or `–text`
    tells `grep` to consider a binary file as a test file.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the `grep` command itself is a binary file that executes and gives
    a search result.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the option in `grep` is `--text`. The string `--text` should be somewhere
    available in the `grep` binary file. Let''s search for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We saw that the string `--text` is found in the search path `/usr/bin/grep`.
    The character backslash ('`\`') is used to escape its special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's search for the `-w` string in the `wc` binary. We know that the `wc`
    command has an option `-w` that counts the number of words in an input text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Searching in a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also tell `grep` to search into all files/directories in a directory
    recursively using the option `-R`. This avoids the hassle of specifying each file
    as an input text file to `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we are interested in knowing at how many places `#include <stdio.h>`
    is used in a standard `include` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `#include <stdio.h>` string is found at `77` places in the
    `/usr/include` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another example, we want to know how many Python files (the extension `.py`)
    in `/usr/lib64/python2.7/` does `"import os"`. We can check that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Excluding files/directories from a search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also specify the `grep` command to exclude a particular directory or
    file from search. This is useful when we don't want `grep` to look into a file
    or directory that has some confidential information. This is also useful in the
    case where we are sure that searching into a certain directory will be of no use.
    So, excluding them will reduce search time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, there is a source code directory called `s0`, which uses the `git`
    version control. Now, we are interested in searching for a text or pattern in
    source files. In this case, searching in the `.git` subdirectory will be of no
    use. We can exclude `.git` from search as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are searching for the `search_string` string in the `s0` directory
    and telling `grep` to not to search in the `.git` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of excluding a directory, to exclude a file, use the `--exclude-from=FILE`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Display a filename with a matching pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some use-case, we don't bother with where the search matched and at how many
    places the search matched in a file. Instead, we are interested in knowing only
    the filename where at least one search matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I want to save filenames that have a particular search pattern
    found in a file, or redirect to some other command for further processing. We
    can achieve this using the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This example gets name of the file in which `import os` is written and saves
    result in file `search_result.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Matching an exact word
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exact matching of the word is also possible using word boundary that is
    `\b` on both the sides of the search pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will reuse the `input1.txt` file and its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `--color` option allows colored printing of the matched search result.
  prefs: []
  type: TYPE_NORMAL
- en: The `"\ba\b"` option tells `grep` to only look for the character **a** that
    is alone. In search results, it won't match the character `a` present as a sub-string
    in a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matching an exact word](img/4335_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Editing output using sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sed` command is a non-interactive stream editor that allows you to modify
    the content of the standard input or file. It performs an operation on each line
    in a pipeline. The syntax will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sed [OPTIONS]... {script} [input-file …]`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the output is displayed on `stdout`, but can be redirected to a
    file if specified.
  prefs: []
  type: TYPE_NORMAL
- en: The `input-file` are the files on which `sed` needs to be run. If no files are
    specified, it reads from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `script` can be a command or a file with multiple commands to pass to `sed`,
    and `OPTIONS` to `sed` are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -n | This suppresses automatic printing of pattern space |'
  prefs: []
  type: TYPE_TB
- en: '| -e script | This allows multiple scripts to be executed |'
  prefs: []
  type: TYPE_TB
- en: '| -r | This uses the extended regex in the script |'
  prefs: []
  type: TYPE_TB
- en: '| -l N | This specifies line wrap length |'
  prefs: []
  type: TYPE_TB
- en: '| --posix | This disables all GNU extensions |'
  prefs: []
  type: TYPE_TB
- en: '| -u | This loads the minimal amounts of data from input and flushes output
    buffers frequently |'
  prefs: []
  type: TYPE_TB
- en: String substitution using s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sed` command is widely used for string substitution in a text file. Programmers
    frequently use this feature while renaming a variable in a huge source code. It
    saves a lot of programmers' time by avoiding manual renaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The substitution command `s` has the following field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s/regex/replacement/`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `s` means perform substitution, `/` acts as separator, and `regex` is
    a regular expression that needs to be replaced. A simple string can also be specified
    here. The last field `replacement` is with what matched results should be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `sed` will replace only the first occurrence of a matched pattern
    in a line. To replace all occurrences, use the `g` flag after the end of `/—`,
    that is, `s/regex/replacement/g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the flags that can be used are mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | This applies replacement to all the matches in a line |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | This prints a new pattern space, if substitution occurs |'
  prefs: []
  type: TYPE_TB
- en: '| `w filename` | This writes substituted pattern space to a filename |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | This replaces only the Nth matched result in a matched line |'
  prefs: []
  type: TYPE_TB
- en: 'We have the `sed.sh` file for our example. The content of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a shell script, where the variable `var1` has been used at four places.
    Now, we want to rename the variable `var1` to `variable`. We can do this very
    easily using the `sed` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-i` option is used to replace an input file.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple substitutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also specify multiple commands to be executed for substitution using
    `-e` followed by a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the `sed.txt` file. The content of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to replace ''`.`'' with ''`,`'' and delete the line containing
    a string `manual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In `sed.txt` file, the `s/\./,/g` command first replaces '`.`' with '`,`' and
    `/manual/d` deletes further the line containing the string `manual`.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating a stream using tee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, it''s necessary to print an output on `stdout` and save an output
    in a file. In general, command output can either be printed or can be saved in
    a file. To solve it, the `tee` command is used. This command reads from the standard
    input and writes to both standard output and files. The syntax of `tee` will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tee [OPTION] [FILE …]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tee` command copies the output to each `FILE` and also to `stdout`. The
    `OPTIONS` can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-a, --append` | This appends to the `FILE` instead of overwriting |'
  prefs: []
  type: TYPE_TB
- en: '| `-i, --ignore-interrupts` | This ignores interrupt signals, if any |'
  prefs: []
  type: TYPE_TB
- en: 'Writing an output to `stdout` and file: In general, to write an output to `stdout`
    and file, we will call the same command twice, with and without redirection. For
    example, the following command shows how to print an output on `stdout` and save
    it to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do both the tasks by running the `ls` command once using the `tee` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify multiple filenames to `tee` for an output to be written
    in each file. This copies the output to all files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the above commands, the output will be also written to the `out1.txt`
    and `out2.txt` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Writing an output to stdout and appending to a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tee` command also allows you to append the output to a file instead of
    overwriting a file. This can be done using the `-a` option with `tee`. Appending
    an output to a file is useful when we want to write an output of various commands
    or an error log of different command execution in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to keep the output of running the `ls` and `echo` commands
    in the `out3.txt` file and also display results on `stdout`, we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Sending an output to multiple commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use the `tee` command to provide an output of a command as an input
    to multiple commands. This is done by sending the `tee` output to pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, the output of the `df -h` command is saved to the `out4.txt` file, the
    `stdout` output is redirected to the `grep` command, and the output of the search
    result from `grep` is further redirected to the `wc` command. At the end, the
    result of `wc` is printed on `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and finding unique text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell provides different ways to sort the input text using the `sort` command.
    It's also possible to remove repeated lines from sorted/unsorted input text using
    the `uniq` command. The input text to sort and `uniq` commands can be given from
    a file, or redirected from another command.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an input text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lines in the input text are sorted in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers from 0 to 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uppercase letters from A to Z
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase letters from a to z
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort [OPTION] [FILE …]`'
  prefs: []
  type: TYPE_NORMAL
- en: Single or multiple input files can be provided to sort for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sort` command takes multiple options to provide flexibility in sorting.
    The popular and important `OPTION` to sort have been discussed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | This ignores leading blanks |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | This considers only blanks and alphanumeric characters |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | This ignores a case |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | This ignores a non-printable character |'
  prefs: []
  type: TYPE_TB
- en: '| `-M` | This compares months that are unknown (for example, < JAN < FEB… <
    DEC) |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | This sorts on the basis of numerical values |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | This sorts in reverse order |'
  prefs: []
  type: TYPE_TB
- en: '| `-h` | This sorts on human-readable numbers; for example, 9K, 5M, 1G, and
    so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | This gets unique lines |'
  prefs: []
  type: TYPE_TB
- en: '| `-o file` | This writes an output to a file instead of stdout |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | This merges the already sorted file without resorting it |'
  prefs: []
  type: TYPE_TB
- en: '| `-k n` | This sorts data according to the given column n |'
  prefs: []
  type: TYPE_TB
- en: Now, we will see with the help of examples, how different sorting can be done
    on the input text data.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a single file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, we will consider the `sort1.txt` file for sorting. The content
    of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the content alphabetically, we can use the `sort` command without any
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the content in reverse order, we can use the `–r` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Sorting multiple files**: We can also sort multiple files collectively, and
    the sorted output can be used for further queries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider `sort1.txt` and `sort2.txt` files. We will reuse the
    content of the `sort1.txt` file from the previous example. The content of `sort2.txt`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sort both the files together alphabetically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `-o` option to save the sorted output of files in a file
    instead of displaying it on `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting output to sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can sort an output redirected from another command. The following example
    shows the sorting of the `df -h` command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![Redirecting output to sort](img/4335_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following command sorts output of `df` by its 2nd column content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![Redirecting output to sort](img/4335_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can sort the `ls -l` output according to the last modification day and month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![Redirecting output to sort](img/4335_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To sort the `ls -l` output, first sort according to the month that is the 6th
    field using the `-M` option, and if the month for two or more row is the same,
    then sort according to the day that is the 7th field using `-n` for numerical
    sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '![Redirecting output to sort](img/4335_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Filtering unique elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many use-case, we need to remove duplicate items and keep only one occurrence
    of items. It is very useful when the output of a command or input file is too
    big, and it contains lot of duplicate lines. To get unique lines from a file or
    redirected output, the shell command `uniq` is used. One important point to note
    is that, in order to get the `uniq` output, input should be sorted, or first run
    the sort command to make it sorted. The syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort [OPTION] [INPUT [OUTPUT]]`'
  prefs: []
  type: TYPE_NORMAL
- en: An input to `uniq` can be given from a file or another command's output.
  prefs: []
  type: TYPE_NORMAL
- en: If an input file is provided, then an optional output file can also be specified
    on a command line. If no output file is specified, the output will be printed
    on `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that `uniq` supports are discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c` | This prefixes lines with the number of occurrences |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | This prints duplicate lines only once |'
  prefs: []
  type: TYPE_TB
- en: '| `-f N` | This skips the comparison of the first N fields |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | This is case-insensitive comparison of items |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | This prints only unique lines |'
  prefs: []
  type: TYPE_TB
- en: '| `-s N` | This avoids comparing the first N characters in line |'
  prefs: []
  type: TYPE_TB
- en: '| `-w N` | This compares only N characters in line |'
  prefs: []
  type: TYPE_TB
- en: Unique elements in a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the `unique.txt` file as an example on which we will run the `uniq`
    command with its options. The content of `unique.txt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove duplicate lines from the `unique.txt` file, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, sort the file and then redirect the sorted text to the `uniq` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-u` option with the `sort` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running either of the commands will be the same, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unique elements in a file](img/4335_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `-c` option to print the number of occurrences of each line
    in the input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![Unique elements in a file](img/4335_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the options `-c` and `-i` will print the `uniq` lines along with the
    occurrence count. A comparison for unique line will be done case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![Unique elements in a file](img/4335_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get only those lines in file that have appeared only once, the `-u` option
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to get the lines that have been appeared more than once in a file,
    `-d` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also tell the `uniq` command to find unique lines based on comparing
    only the first N character of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The uniq command does not detect the repeated lines unless they are adjacent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find unique lines, first sort the input using the sort command and then apply
    the uniq command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character-based translation using tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting shell command is `tr`. This translates, squeezes, or deletes
    characters from the standard input. The syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tr [OPTION]... SET1 [SET2]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The options for the `tr` commands are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c, -C` | Use complement of SET1 |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | This deletes a range of characters specified in SET1. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | This replaces consecutive multiple occurrences of characters in SET1
    with a single occurrence. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t` | This truncates SET1 to the length of SET2\. Any extra characters in
    SET1 will be not considered for translation. |'
  prefs: []
  type: TYPE_TB
- en: 'SETs are a string of characters that can be specified using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A character class: `[:alnum:]`, `[:digit:]`, `[:alpha:]` and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A character range: `''a-z''`, `''A-Z''`, and `''0-9''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An escape character: `\\`, `\b`, `\r`, `\n`, `\f`, `\v`, and `\t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To provide an input text from a file and an output to a file, we can use the
    file redirection operators: `<` (less than for input) and `>` (greater than for
    output).'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting input characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, removing a few unnecessary characters from an input text is important.
    For example, our input text is in the `tr.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to remove all the caps letters from this file. We can use the
    `-d` option with `SET1` as `''A-Z''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the output doesn''t have any caps letter. We can also removed a
    new line and space from a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have redirected the output to `tr_out1.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Squeezing to a single occurrence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `-s` option is useful when we don't want to delete a character throughout
    the input text, instead we want to squeeze down to a single occurrence if consecutive
    multiple occurrences of the given character is there.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the use-case where it will prove useful is when we have multiple spaces
    in between two words that we want to bring down to a single space between any
    two words/strings in the input text. Consider the `tr1.txt` file as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking into this file, it''s quite clear that texts are not properly aligned.
    There are multiple spaces between two words. We can squeeze multiple spaces to
    one space using the `tr` option with `-s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Inverting a character set to be translated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command `tr` also provides the `-c` or `-C` options to invert a character set
    to be translated. This is useful when we know what is not to be translated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to keep only alphanumeric, newline, and white-space in
    the text string. Everything should be deleted from the input text. Here, it's
    easy to specify what not to delete rather than what to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the `tr2.txt` file whose content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete characters other than alphanumeric, newline, and white-space, we
    can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Filtering based on lines—head and tail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To display the content of a file, we will use the `cat` command. The `cat` command
    displays the whole file content on `stdout`. However, sometimes, we are interested
    in viewing only a few lines of a file. In this case, using `cat` will be tedious
    because we will have to scroll down to particular lines that we are interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Shell provides us the `head` and `tail` commands to print only the lines in
    which we are interested in. The main difference between both the commands is,
    `head` prints the lines from the beginning of the files, and tail prints the lines
    from the end of the files.
  prefs: []
  type: TYPE_NORMAL
- en: Printing lines using head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`head [OPTION] [FILE …]`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `head` prints first 10 lines of each FILE to `stdout`. If no file
    is mentioned or '`-`' is specified, the input is taken from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available in head can be used to change how much of the content
    to be printed. The options available are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c [-] K` | This prints first K bytes of a file. If -K is used, then you
    can output all contents except the last K bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n [-]K` | This prints first K lines of each file. If -K is used, then you
    can output all lines except the last n lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | This prevents name of input files from being printed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | This always outputs the header having the filename of each file. |'
  prefs: []
  type: TYPE_TB
- en: Printing the first few lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how many files `/usr/lib64/` directory contains `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that `/usr/lib64` has 3954 files. Suppose, we don''t want all the libraries
    names, but just the first five library names. We can use a head command for this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Printing the first few bytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the `-c` option to print the first few bytes of a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This first prints 50 bytes of the `/usr/share/dict/linux.words` and `/usr/share/dict/words`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can eliminate the printing of the header having a filename using `–q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'For a single file, command `head` doesn''t print name of file in output. To
    see it, use `–v` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Printing lines using tail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for `tail` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tail [OPTION] [FILE …]`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `tail` prints the last 10 lines of each `FILE` to `stdout`. If no
    file is mentioned or '`-`' is specified, the input is taken from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available in `tail` can be used to change how much of the content
    to be printed. The available options are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c [+]K` | This prints the last `K` byte of each file. If `+K` is used,
    then print from `Kth` byte of each file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-n [+]K` | This prints the last `K` lines of each file. If +K is used, then
    output from Kth line of each file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f [{name&#124;descriptor}]` | The outputs the appended data as the file
    grows. |'
  prefs: []
  type: TYPE_TB
- en: '| `--retry` | This keeps trying to open a file if it is inaccessible. |'
  prefs: []
  type: TYPE_TB
- en: '| `--max-unchanged-stats=N` | With the `-f` name, reopen the file that has
    not opened. This shows the changed size after `N` iterations (default 5). |'
  prefs: []
  type: TYPE_TB
- en: '| `--pid=PID` | With `-f`, terminate if `PID` dies. |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Don''t output header having filename of each file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-F` | This is the same as the `-f` name `--retry` option. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s N` | This sleeps for `N` seconds between iterations. With `–pid`=`PID`,
    check the process at least once in `N` seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | This always outputs the header having a filename of each file. |'
  prefs: []
  type: TYPE_TB
- en: Checking log entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tail` command is frequently used to check the error or message log for
    the last few run of commands. With each new run, logs are appended at the end
    of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see in following example that kernel log entries are made when a new
    USB drive is added and when it is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw that when USB was unmounted, a new log entry was added:`[120110.466498]
    sdb:` detected capacity change from `1011875840` to `0` To check the last 10 yum
    logs in an RPM-based system, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To see real-time logs, we can use the `-f` option. For example, the `/var/log/messages`
    file shows the general system activities. With `tail -f`, appended log messages
    in `/var/log/messages` will be printed on `stdout` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The command prompt won't return back. Instead, the output will keep getting
    updated whenever there is new content in `/var/log/messages`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding any line in a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use head and tail to find any line of a file.
  prefs: []
  type: TYPE_NORMAL
- en: We will consider the `/usr/share/dict/words` file as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to find the 10th line of this file, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The Cut-based selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also select a text from each line of single/multiple files using the
    `cut` command. The `cut` command allows us to select a column based on delimiters.
    By default, `TAB` is used as delimiter. We can also select a portion of the text
    in a line by specifying the characters or range. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cut OPTION [FILE …]`'
  prefs: []
  type: TYPE_NORMAL
- en: The `cut` command works on the single and multiple files. By default, the output
    is printed on `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options for the `cut` command are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-b LIST` | This selects bytes that are specified in LIST. |'
  prefs: []
  type: TYPE_TB
- en: '| `-c LIST` | This selects characters that are specified in LIST. |'
  prefs: []
  type: TYPE_TB
- en: '| `-d DELIM` | This uses delimiter as DELIM instead of TAB. It also prints
    lines that don''t have a delimiter. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f LIST` | This only selects fields specified in LIST. |'
  prefs: []
  type: TYPE_TB
- en: '| `--complement` | This complements a set of selected bytes, characters, or
    fields. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Don''t print lines that don''t have a delimiter. |'
  prefs: []
  type: TYPE_TB
- en: '| `--output-delimiter=STRING` | This uses STRING as the output delimiter. By
    default, the input delimiter is used. |'
  prefs: []
  type: TYPE_TB
- en: 'LIST is made up of a range or many ranges separated by a comma. A range is
    specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Range | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | This is the Nth byte, character, or field, counted from 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `N-` | This is from the Nth byte, character, or field, to the end of the
    line |'
  prefs: []
  type: TYPE_TB
- en: '| `N-M` | This is from the Nth to Mth byte (including M and N), character,
    or field. |'
  prefs: []
  type: TYPE_TB
- en: '| `-M` | This is from the first to Mth (include) byte, character, or field.
    |'
  prefs: []
  type: TYPE_TB
- en: Cutting across columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of Linux command outputs are formatted in such a way that the results
    have multiple fields and each field is separated by space or tabs. The outputs
    of each field can be viewed by looking down into a particular field column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `ls -l ~` command and observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '![Cutting across columns](img/4335_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are interested only in knowing the modification time and filename.
    To achieve this, we will need the column `6` to `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '![Cutting across columns](img/4335_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, `TAB` is used as a delimiter. Here, there are multiple spaces between
    any two columns in the `ls -l` output. So, first using `tr -s`, we will squeeze
    multiple whitespace into single whitespace and then we will cut the column field
    range `6-9` with a delimiter as whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Text selection in files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the `cut1.txt` file as an example. The content of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text selection in files](img/4335_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are interested in knowing the names of the students. We can get this
    by fetching the first column. Here, each column is separated by *Tab*. So, we
    will not have to specify the delimiter in our command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting thing to do is to get unique department names. We can do
    this by using the following set of commands on the `cut1.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are four unique departments mentioned in the `cut1.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting thing we can do is find out who received the highest marks,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: To find out who scored the highest mark, we first select the first and third
    column from the `cut1.txt` file. Then, we exclude the first line using `tail -n
    +2`, which tells us what this file is about, because we do not need this. After
    that, we do numerical sorting of the second column in reverse order, which contains
    the marks of all the students. Now, we know that the first column contains the
    details of those who scored the highest marks.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the speed of your system processor is interesting in order to know the
    various details of your system. Among all, one of them knows the speed of your
    processor. The first thing to know is that all processor details are available
    in the `/proc/cpuinfo` file. You can open this file and see what all details are
    available. For example, we know that the processor's speed is mentioned in the
    `"model name"` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script will show the speed of the processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will output the processor speed of your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do without using temporary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should know how to provide an input to commands
    and print or save its result. You should also be familiar with redirecting an
    output and input from one command to another. Now, you can easily search, replace
    strings or pattern in a file, and filter out data based on needs.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter, we now have a good control on transforming/filtering text
    data. In next chapter, we will learn how to write more powerful and useful shell
    scripts by learning loops, conditions, switch, and the most important function
    in shell. We will also know how important it is to know the exit status of a command.
    In the next chapter, we will also see more advanced examples of commands that
    we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
