- en: Creating a File Explorer with NW.js â€“ Enhancement and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have a working version of File Explorer that can be used to navigate
    the filesystem and open files with the default associated program. Now we will
    extend it for additional file operations, such as deleting and copy pasting. These
    options will keep in a dynamically built context menu. We will also consider the
    capabilities of NW.js to transfer data between diverse applications using the
    system clipboard. We will make the application respond to command-line options.
    We will also provide support for multiple languages and locales. We will protect
    the sources by compiling them into native code. We will consider packaging and
    distribution. At the end, we will set up a simple release server and make the
    File Explorer auto-update.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internationalization**, often abbreviated as **i18n**, implies a particular
    software design capable of adapting to the requirements of target local markets.
    In other words, if we want to distribute our application to markets other than
    the USA, we need to take care of translations, formatting of datetime, numbers,
    addresses, and such.'
  prefs: []
  type: TYPE_NORMAL
- en: Date format by country
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internationalization is a cross-cutting concern. When you are changing the
    locale, it usually affects multiple modules. So, I suggest going with the observer
    pattern that we already examined while working on `DirService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/I18n.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we can change the `locale` property by setting a new value to the
    `locale` property. As soon as we call the `notify` method, all the subscribed
    modules immediately respond.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `locale` is a public property and therefore we have no control over
    its access and mutation. We can fix it using overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/I18n.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we access the `locale` property of the `I18n` instance, it gets delivered
    by the getter (`get locale`). When setting it a value, it goes through the setter
    (`set locale`). Thus, we can add extra functionalities, such as validation and
    logging on property access and mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we have a combo box for selecting the language in the HTML. Why
    not give it a view?
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/LangSelector.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we listen for change events on the combo box.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the event occurs, we change the `locale` property with the passed-in `I18n`
    instance and call `notify` to inform the subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Well, we can change the locale and trigger the event. What about consuming modules?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FileList` view, we have the `formatTime` static method that formats
    the passed in `timeString` for printing. We can make it formatted in accordance
    with the currently chosen `locale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/FileList.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we subscribe to the `I18n` update event and update the
    file list every time the locale changes. The `formatTime` static method converts
    passed the string into a `Date` object and uses the `Date.prototype.toLocaleString()`
    method to format the datetime according to a given locale. This method belongs
    to the so called **ECMAScript Internationalization API** ([http://norbertlindenberg.com/2012/12/ecmascript-internationalization-
    api/index.html](http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html)).
    This API describes methods of built-in objects--`String`, `Date`, and `Number`--designed
    to format and compare localized data. However, what it really does is to format
    a `Date` instance with `toLocaleString` for the English (United States) locale
    (`en-US`), and it returns the date, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we feed German locale (`de-DE`) to the method, we get quite a different
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To put it into action, we set an identifier to the combo box. The `./index.html`
    file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we have to create an instance of the `I18n` service and pass it
    in `LangSelectorView` and `FileListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we shall start the application. Yeah! As we change the language in the
    combo box, the file modification dates are adjusted accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97388f9b-0432-45bf-9777-dd650d980998.png)'
  prefs: []
  type: TYPE_IMG
- en: Multilingual support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Localization dates and numbers is a good thing, but it will be more exciting
    to provide translation to multiple languages. We have a number of terms across
    the application, namely, the column titles of the file list and tooltips (via
    the `title` attribute) on windowing action buttons. What we need is a dictionary.
    Normally, it implies sets of token translation pairs mapped to language codes
    or locales. Thus, when you request from the translation service a term, it can
    correlate to a matching translation according to the currently used language/locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have suggested making the dictionary a static module that can be loaded
    with the required function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Data/dictionary.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have two locales with translations per term. We will inject the dictionary
    as a dependency into our `I18n` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/I18n.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also added a new method, translate, that accepts two parameters: `token`
    and `default` translation. The first parameter can be one of the keys from the
    dictionary, such as `NAME`. The second one is guarding value for the case when
    the requested token does not yet exist in the dictionary. Thus, we still get a
    meaningful text, at least in English.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can use this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/FileList.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We change the hardcoded column titles in the `FileList` view with calls for
    the `translate` method of the `I18n` instance, which means that every time the
    view updates, it receives the actual translations. We shall not forget about the
    `TitleBarActions` view where we have windowing action buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/TitleBarActions.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we add the `translate` method, which updates button-title attributes with
    the actual translations. We subscribe for the `i18n` update event to call the
    method every time a user changes the `locale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08faa557-defe-45b5-be0d-1d505d9f6bd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Context menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, with our application, we can already navigate through the filesystem
    and open files, yet one might expect more of a File Explorer. We can add some
    file-related actions, such as delete and copy/paste. Usually, these tasks are
    available via the context menu, which gives us a good opportunity to examine how
    to make it with `NW.js`. With the environment integration API, we can create an
    instance of system menu ([http://docs.nwjs.io/en/latest/References/Menu/](http://docs.nwjs.io/en/latest/References/Menu/)).
    Then, we compose objects representing menu items and attach them to the menu instance
    ([http://docs.nwjs.io/en/latest/References/MenuItem/](http://docs.nwjs.io/en/latest/References/MenuItem/)).
    This `menu` can be shown in an arbitrary position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet, our task is more specific. We have to display the menu on the right-click
    in the position of the cursor, that is, we achieve it by subscribing a handler
    to `contextmenu` DOM event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we right-click within the application window, the menu shows
    up. It''s not exactly what we want, is it? We need it only when the cursor resides
    within a particular region, for instance, when it hovers a file name. This means
    that we have to test whether the target element matches our conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we ignore the event until the cursor hovers over any cell of the file
    table row, given that every row is a list item generated by the `FileList` view
    and therefore provided with a value for a data file attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This passage pretty much explains how to build a system menu and how to attach
    it to the file list. However, before starting on a module capable of creating
    a menu, we need a service to handle file operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/File.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s going on here? `FileService` receives an instance of `DirService` as
    a constructor argument. It uses the instance to obtain the full path to a file
    by name (`this.dir.getFile( file )`). It also exploits the `notify` method of
    the instance to request all the views subscribed to `DirService` to update. The
    `showInFolder` method calls the corresponding method of `nw.Shell` to show the
    file in the parent folder with the system file manager. As you can recon, the
    `remove` method deletes the file. As for copy/paste, we do the following trick.
    When the user clicks on copy, we store the target file path in the `copiedFile`
    property. So, when the user clicks on paste the next time, we can use it to copy
    that file to the supposedly changed current location. The `open` method evidently
    opens the file with the default associated program. That is what we do in the
    `FileList` view directly. Actually, this action belongs to `FileService`. So,
    we adjust the view to use the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/FileList.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a module to handle the context menu for a selected file. The module
    will subscribe for the `contextmenu` DOM event and build a menu when the user
    right-clicks on a file. This menu will contain Show Item in the Folder, Copy,
    Paste, and Delete. Copy and Paste are separated from other items with delimiters,
    and Paste will be disabled until we store a file with Copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/ContextMenu.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, in the `ConextMenuView` constructor, we receive instances of `FileService`
    and `I18nService`. During the construction, we also call the `attach` method,
    which subscribes for the `contextmenu` DOM event, creates the menu, and shows
    it in the position of the mouse cursor. The event gets ignored unless the cursor
    hovers over a file or resides in the empty area of the file list component. When
    the user right-clicks on the file list, the menu still appears, but with all items
    disabled except Paste (in case a file was copied before). Method render to create
    an instance of the menu and populates it with `nw.MenuItems` created by the `getItems`
    method. The method creates an array representing menu items. Elements of the array
    are object literals. The `label` property accepts translation for item captions.
    The `enabled` property defines the state of an item depending on our cases (whether
    we hold the copied file or not). Finally, the `click` property expects the handler
    for the click event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to enable our new components in the main module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the application, right-click on a file, and voila! We have
    the context menu and new file actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d5747ae-172d-4c7f-9b2c-7d0ad5c95d3d.png)'
  prefs: []
  type: TYPE_IMG
- en: System clipboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, the copy/paste functionality involves system clipboard. `NW.js` provides
    an API to control it ([http://docs.nwjs.io/en/latest/References/Clipboard/](http://docs.nwjs.io/en/latest/References/Clipboard/)).
    Unfortunately, it's quite limited; we cannot transfer an arbitrary file between
    applications, which you may expect of a file manager. Yet, some things are still
    available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to examine text transferring with the clipboard, we modify the method
    copy of `FileService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What does it do? As soon as we obtain the file full path, we create an instance
    of `nw.Clipboard` and save the file path there as text. So now, after copying
    a file within the File Explorer, we can switch to an external program (for example,
    a text editor) and paste the copied path from the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76eb224-6217-4723-af99-7e6005321ec7.png)'
  prefs: []
  type: TYPE_IMG
- en: Transferring graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It doesn''t look very handy, does it? It would be more interesting if we could
    copy/paste a file. Unfortunately, `NW.js` doesn''t give us many options when it
    comes to file exchange. However, we can transfer PNG and JPEG images between the
    `NW.js` application and external programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/File.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We extended our `FileService` with the `copyImage` private method. It reads
    a given file, converts its contents in Base64 and passes the resulting code in
    a clipboard instance. In addition, it creates HTML with an image tag with the
    Base64-encoded image in the data **Uniform Resource Identifier** (**URI**). Now,
    after copying an image (PNG or JPEG) in File Explorer, we can paste it in an external
    program, such as the graphical editor or text processor.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving text and graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve learned how to pass text and graphics from our `NW.js` application to
    external programs, but how can we receive data from outside? As you can guess,
    it is accessible through the `get` method of `nw.Clipboard`. Text can be retrieved
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the graphic is put on the clipboard, we can get it with NW.js only as
    Base64-encoded content or as HTML. To see it in practice, we add a few methods
    to `FileService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/File.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `hasImageInClipboard` method checks whether the clipboard keeps any graphics.
    The `pasteFromClipboard` method takes graphical content from the clipboard as
    a Base64-encoded PNG; it converts the content into binary code, writes it into
    a file, and requests `DirService` subscribers to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of these methods, we need to edit the `ContextMenu` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/ContextMenu.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We add a new item, `Paste image from clipboard`, to the menu, which is enabled
    only when there are some graphics in the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: Menu in the system tray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All three platforms available for our application have a so-called system notification
    area, which is also known as the system tray. That's a part of the user interface
    (in the bottom-right corner on Windows and top-right corner on other platforms)
    where you can find the application icon even when it's not present on the desktop.
    Using the `NW.js` API ([http://docs.nwjs.io/en/latest/References/Tray/](http://docs.nwjs.io/en/latest/References/Tray/)),
    we can provide our application with an icon and drop-down menu in the tray, but
    we do not have any icon yet. So, I have created the `icon.png` image with the
    text `Fe` and saved it in the application root in the size of 32x32px. It is supported
    on Linux, Windows, and macOS. However, in Linux, we can go with a better resolution,
    so I have placed the 48x48px version next to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application in the tray will be represented by `TrayService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/Tray.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What does it do? The class takes the tray's title as a constructor parameter
    and calls the `removeOnExit` and render methods during instantiation. The first
    one subscribes for the window's `close` event and ensures that the tray is removed
    when we close the application. Method render creates the `nw.Tray` instance. With
    the constructor argument, we pass the configuration object with the title, which
    is a relative path to the icon. We assign it with `icon- 48x48.png` icon for Linux
    and `icon-32x32.png` for other platforms. By default, macOS tries adapting the
    image to the menu theme, which requires an icon to consist of clear colors on
    a transparent background. If your icon doesn't fit these restrictions, you would
    rather add it into configuration object property `iconsAreTemplates`, which is
    set as `false`.
  prefs: []
  type: TYPE_NORMAL
- en: When launching our File Explorer in Ubuntu 16.x, it doesn't appear in the system
    tray due to the whitelisting policy. You can fix this by running `sudo apt-get
    install libappindicator1` in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '`nw.Tray` accepts the `nw.Menu` instance. So, we populate the menu the same
    way as we did for the context menu. Now we just initialize the `Tray` view in
    the main module and run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the application now we can see the app icon and the menu in the system
    tray:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f193457b-315c-42e0-8b29-adbed34fdbef.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, the only menu item exit looks somehow lonely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the `Tray` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/Tray.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `render` method receives a Boolean as an argument defining whether
    the application window is in the initial mode; that flag gets passed to the new
    `getItems` method that produces an array of menu items meta. If the flag is true,
    all the menu items are enabled, except restore. What makes sense is to restore
    the switches window to the initial mode after minimizing or maximizing. Seemingly,
    when the flag is `false`, the `Minimize` and `Maximize` items are disabled, but
    how can we know the current mode of the window? While constructing, we subscribe
    to window events minimize, maximize, and restore. When an event happens, we call
    `render` with the corresponding flag. Since we can now change window mode from
    both the `TitleBarActions` and `Tray` views, the `toggle` method of `TitleBarActions`
    is not a reliable source of window mode anymore. Instead, we rather refactor the
    module to rely on window events like we did in the `Tray` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/View/TitleBarActions.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time when we run the application we can find in the system tray application
    menu with windowing actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a14be2-3418-4b01-989c-90b4f25adabd.png)'
  prefs: []
  type: TYPE_IMG
- en: Command-line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other file managers usually accept command-line options. For example, you can
    specify a folder when launching Windows Explorer. It also responds to various
    switches. Let's say that you can give it switch `/e`, and Explorer will open the
    folder in expanded mode.
  prefs: []
  type: TYPE_NORMAL
- en: '`NW.js` reveals command-line options as an array of strings in `nw.App.argv`.
    So, we can change the code of the `DirService` initialization in the main module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can open a specified folder in the File Explorer straight from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In UNIX-based systems, the tilde means user home directory. The equivalent
    in Windows will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What else can we do? Just for a showcase, I suggest implementing the `--minimize`
    and `--maximize` options that switch the application window mode on startup, respectively:
    `./js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't make any sense to parse `nw.App.argv` array manually when we can
    use an external module minimist ([https://www.npmjs.com/package/minimist](https://www.npmjs.com/package/minimist)).
    It exports a function that collects all the arguments that are not options or
    associated with options into the `_` (underscore) property. We expect the only
    argument of that type, which is startup directory. It also sets the `maximize`
    and `minimize` properties to true when they are provided on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'One should note that NPM doesn''t delegate options to the running script, so
    we shall call the `NW.js` executable directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Native look and feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, one can find plenty of native desktop applications with semi-transparent
    background or with round corners. Can we achieve such fancy look with `NW.js`?
    Sure we can! First, we shall edit our application manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the frame field to `false`, we instruct `NW.js` to not show the
    window frame, but its contents. Fortunately, we have already implemented custom
    windowing controls as the default ones will not be available anymore. With a transparent
    field, we remove the opacity of the application window. To see it in action, we
    edit the CSS definitions module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Base/definitions.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With RGBA color function, we set the opacity of the title bar to 70% and other
    background colors to 90%. We also introduce a new variable, `--border-radius`,
    which we will use in the `titlebar` and `footer` components to make round corners
    on the top and in the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/css/Component/titlebar.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`./assets/css/Component/footer.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we can launch the application and enjoy our renewed fancy look.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, we need to use the `nw . --enable-transparent-visuals --disable-gpu`
    command-line option to trigger transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Source code protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike in native applications, our source code isn''t compiled and is therefore
    open to everybody. If you have any commercial use of this fact in mind, it is
    unlikely to suit you. The least you can do is to obfuscate the source code, for
    example, using Jscrambler ([https://jscrambler.com/en/](https://jscrambler.com/en/)).
    On the other hand, we can compile our sources into native code and load it with
    `NW.js` instead of JavaScript. For that, we need to separate JavaScript from the
    application bundle. Let''s create the `app` folder and move everything except
    `js` there. The `js` folder will be moved into a newly created directory, `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Our JavaScript modules are now out of the project scope, and we cannot reach
    them when required. However, these are still Node.js modules ([https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html))
    that confront CommonJS module definition standards. Therefore, we can merge them,
    with a bundler tool, into a single file that we later compile into native code.
    I suggest going with Webpack ([https://webpack.github.io/](https://webpack.github.io/)),
    the seemingly most popular bundler nowadays. So, we place it in the root directory
    webpack configuration file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we instruct Webpack to transpile all the required modules, starting
    with `src/js/app.js`, into a single `src/build/bundle.js` file. However, Webpack,
    unlike `NW.js`, expects the required dependencies relative to the hosting file
    (not project root); so, we have to remove `js/` from the file paths in the main
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./src/js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For both transpiling CommonJS modules and compiling the derived file in the
    native code, we need a few tasks in the script field of the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With the first task, we make webpack build our JavaScript sources into a single
    file. The second one compiles it using the `NW.js` compiler. The last one does
    both at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the HTML file, we replace the code calling the main module with the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run the application and observe that the implemented functionality
    still confronts our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have completed our application and that is the time to think about
    distribution. As you understand, asking our users to install `Node.js` and type
    `npm start` from the command line will not be friendly. Users will expect a package
    that can be started as simply as any other software. So, we have to bundle our
    application along with `NW.js` for every target platform. Here, `nwjs-builder`
    comes in handy ([https://github.com/evshiron/nwjs-builder](https://github.com/evshiron/nwjs-builder)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we install the `npm i -D nwjs-builder` tool and add a task to the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specified three target platforms (`-p linux64, win32,osx64`) at once
    and thus, after running this task (`npm run package`), we get platform-specific
    subfolders in the `dist` directory, containing other executable things named after
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Nwjs-builder` accepts diverse options. For example, we can request it to output
    the packages as ZIP archives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can make it run the package after the build process with
    the given options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Autoupdate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the era of continuous deployment, new releases are issued pretty often. As
    developers, we have to ensure that users receive the updates transparently, without
    going through the download/install routine. With the traditional web application,
    it's taken for granted. Users hit the page and the latest version gets loaded.
    With desktop applications, we need to deliver the update. Unfortunately, `NW.js`
    doesn't provide any built-in facilities to handle autoupdates, but we can trick
    it; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a simple release server. Let''s give it a folder (for
    example, `server`) and create the manifest file there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./server/package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This file contains a `packages` custom field, describing the available application
    releases. This simplified implementation accepts only the latest release per platform.
    The release version must be set in the manifest version field. Every entry of
    package objects contains a downloadable URL and the package size in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve HTTP requests for this manifest and packages in the `release` folder,
    we will use the HTTP server ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)).
    So, we install the package and start the HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will jump back to our client and modify the application manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./client/package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a custom field, `manifestUrl`, with a URL to the server manifest.
    After we start the server, the manifest will be available at `http://127.0.0.1:8080/package.json`.
    We instruct `nwjs-builder` to pack application bundles with ZIP and place them
    in `../server/release`. Eventually, we set the `postversion` hook; so, when bumping
    the package version (for example, `npm version patch`) NPM will automatically
    build and send a release package to the server, every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the client, we can read the server manifest and compare it with the application.
    If the server has a newer version, we download the release package matching our
    platform and unpack it in a temporary directory. What we need to do now is just
    replace the running application version with the downloaded one. However, the
    folder is locked until the app is running, so we close the running application
    and start the downloaded one (as a detached process). It backs up the old version
    and copies the downloaded package to the initial location. All that can be easily
    done using `nw- autoupdater` (`https://github.com/dsheiko/nw-autoupdater`), so
    we install the `npm i -D nw-autoupdater` package and create a new service to handle
    the autoupdate flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./client/js/Service/Autoupdate.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we applied the async/await syntax of ES2016\. By prefixing the function
    with `async`, we state that it is asynchronous. After that, we can use await in
    front of any Promise (`https://mzl.la/1jLTOHB`) to receive its resolved value.
    If Promise rejects it, the exception will be caught in the try/catch statement.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly does the code do? As we agreed, it compares local and remote manifest
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: If release server has the newer version, it informs the user using the JavaScript
    confirm function. If the user is positive on upgrading, it downloads the latest
    release and unpacks it. While downloading and unpacking, the updater object emits
    the corresponding messages; so, we can subscribe and represent the progress. When
    ready, the service restarts the application for swapping; so, now it replaces
    the outdated version with the downloaded one and restarts again. On the way, the
    service reports to the user by writing in the passed-in HTML element (el). By
    the design it expects the element representing the path container in the title
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can now enable the service in the main module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./client/js/app.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, how do we test it? We jump to client folder and build a distribution
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposedly, it lands in server/releases. We unpack to the arbitrary location,
    for example, `~/sandbox/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will find the executable (for Linux, it will be `file-explorer`) and
    run it. The File Explorer will work as usual because the release server doesn''t
    have a newer version, so we go back to the client folder and create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now we switch to the server folder and edit the version of the manifest to match
    the just-generated one (1.0.1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we restart the bundled app (for example, `~/sandbox/file-explorer`) and
    observe the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a1a69d8-fab1-4d91-a411-0956ebc63fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on OK, we see the progress on downloading and installing in
    the title bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c530a27a-0b49-47aa-9f6b-7b431e4749fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, the application restarts and reports swapping. When done, it restarts
    again, now updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning of this chapter, our File Explorer could only navigate the
    filesystem and open files. We extended it to show a file in the folder, and to
    copy/paste and delete files. We exploited the `NW.js` API to provide the files
    with the dynamically-built context menu. We learned to exchange text and images
    between applications using system clipboard. We made our File Explorer support
    diverse command-line options. We provided support for internalization and localization,
    and examined the protection of the sources through compilation in the native code.
    We went through the packaging process and prepared for distribution. Finally,
    we set up a release server and extended the File Explorer with a service for autoupdating.
  prefs: []
  type: TYPE_NORMAL
