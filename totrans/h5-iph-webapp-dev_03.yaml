- en: Chapter 3. HTML5 Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the importance of media distribution and
    how HTML5 has changed the web in providing both audio and video content natively
    in the browser. We specifically went over the HTML5 Video implementation, but
    we also discussed the `MediaElement` specification, which covers common APIs that
    are used by both video and audio.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we go further into the specification and abstract it, making
    it reusable for audio and video. But before we get to that, we will discuss the
    server configuration with a simple example, and then move on to more advanced
    implementation with a dynamic audio player and customized controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a simple HTML5 Audio example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaElement` abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the `MediaElement` API for audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic audio player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the audio controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with the HTML5 audio element, we need to configure our
    server for allowing specific audio formats to play appropriately. First, let's
    take a moment to understand the appropriate audio formats.
  prefs: []
  type: TYPE_NORMAL
- en: Audio formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Support for the HTML5 audio playback is similar to that of the video element,
    in that each browser supports different types of formats for one reason or another.
    Here are some tables showcasing what is supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the details related to desktop browsers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Desktop browser | Version | Codec support |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Internet Explorer | 9.0+ | MP3, AAC |'
  prefs: []
  type: TYPE_TB
- en: '| Google Chrome | 6.0+ | Ogg Vorbis, MP3, WAV |'
  prefs: []
  type: TYPE_TB
- en: '| Mozilla Firefox | 3.6+ | Ogg Vorbis, WAV |'
  prefs: []
  type: TYPE_TB
- en: '| Safari | 5.0+ | MP3, AAC, WAV |'
  prefs: []
  type: TYPE_TB
- en: '| Opera | 10.0+ | Ogg Vorbis, WAV |'
  prefs: []
  type: TYPE_TB
- en: 'Following are the details related to mobile browsers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Mobile browser | Version | Codec support |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opera Mobile | 11.0+ | Device-dependent |'
  prefs: []
  type: TYPE_TB
- en: '| Android | 2.3+ | Device-dependent |'
  prefs: []
  type: TYPE_TB
- en: '| Mobile Safari (iPhone, iPad, iPod Touch) | iOS 3.0+ | MPEG, MPG, MP3, SWA,
    AAC, WAV, BWF, MP4, AIFF, AIF, AIFC, CDDA, 32G, 3GP2, 3GP, 3GPP |'
  prefs: []
  type: TYPE_TB
- en: '| Blackberry | 6.0+ | MP3, AAC |'
  prefs: []
  type: TYPE_TB
- en: As we can see, there are multiple format types that are supported by various
    browsers, both mobile and desktop. Luckily for us, this book focuses on iPhone
    web applications, so for our purpose, we will only focus on delivering MP3 formats,
    which are supported by most browsers. Now, we need to make sure our server can
    play MP3s.
  prefs: []
  type: TYPE_NORMAL
- en: Audio format directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to serve the correct MIME types, we need to configure our Apache server.
    To do this, we want to add the following directives to an `.htaccess` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, for our purpose, we only need MPEG/MP3, but it's a good idea to allow
    these in order to take into account extensibility when supporting other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Simple HTML5 audio integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Including audio on a page is pretty simple. We can just include the following
    markup in the page and we have an audio player instantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Simple HTML5 audio integration](img/1024OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The audio element
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example specifies an audio element with an attribute of controls
    telling the browser to have an audio player with native controls for playback.
    Inside this element, there is a source element and a paragraph element. The source
    element specifies the source of the audio and its type. The attribute `src` on
    the source element is the relative location of the audio, and the `type` attribute
    specifies the MIME type and codec of the source. Lastly, we have a paragraph element,
    just in case the audio element is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: This example is perfect to demonstrate how easy it is to have media on our pages,
    except it's not always as simple. Most of the time, we want complete control over
    our components, and sometimes it's necessary to tap into the APIs specified. We've
    gone over these concepts in the previous chapter, and we have developed an extensive
    Video class that we can use here. In the next section, we'll take a step back
    and abstract the code we've written thus far.
  prefs: []
  type: TYPE_NORMAL
- en: MediaElement abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about how audio and video share the same API in the HTML5 specification.
    In this section, we'll discuss taking the video JavaScript we've written and abstracting
    it so that we can re-use it for audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: Creating App.MediaElement.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's create a new JavaScript file in our `js` directory and name it
    `App.MediaElement.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, copy over the contents of `App.Video.js` into the new `App.MediaElement.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we want to make sure that our file reflects the `MediaElement`
    namespace, so we'll rename the word `Video` as `MediaElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've renamed everything to `MediaElement`, we probably want to remove
    the default elements and their names, because they won't be necessary for an abstracted
    class like this one. Along with those defaults, we won't need the public `fullscreen`
    method nor the `onFullScreen` callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we make the preceding changes, our file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although we've written this code previously, let's briefly review the structure
    of the `MediaElement` class. This class contains exposed methods that can be accessed,
    such as `onCanPlay`, `onSeeking`, and `onEnded`. These methods are called when
    the element we pass in has dispatched the appropriate event. The events we are
    listening to are in `attachEvents`, and they contain the shared API events, such
    as `canplay`, `seeking`, `ended`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This class essentially contains only the APIs that are shared among audio and
    video media. If we wanted to extend it for a specific functionality, such as fullscreen,
    we would extend the instance of `MediaElement` or use JavaScript inheritance for
    the `App.Video` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we do not cover true JavaScript inheritance. Given that we want
    to review HTML5 for iPhone web application development as a whole, we don't go
    into more advanced details of JavaScript architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing App.MediaElement.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to initialize `App.MediaElement.js`, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a new instance of `MediaElement` and pass it
    an object, which gets merged with the defaults of the `MediaElement` constructor.
    Keep in mind that `element` will always refer either to the audio or video element.
    We can choose to override the default callbacks or not, as they are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that we are passing in all the callbacks. This is because, since
    the writing of this book, `Zepto.js` contains a bug that does not do deep copying
    of an object if passed in the Boolean true value as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are prepared to use this class with the audio class we've developed for
    this page.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the MediaElement API for audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an abstract `MediaElement` class, we want to build on top of
    it to allow for audio playback. Starting with the base template we've established,
    we'll create an `App.Audio` class that contains all the functionality for this
    page; from creating an instance of `MediaElement`, to creating a drop-down menu
    for switching tracks and managing the volume of each track.
  prefs: []
  type: TYPE_NORMAL
- en: The base template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can establish a base template by following the pattern we have previously
    established. Here is some code you can start out with as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Nothing is new here, we are using the same pattern that we've used previously;
    establishing an `App.Audio` class, an IIFE that contains the `Audio` constructor,
    the same `attachEvents` method to contain the events to handle, and some prototype
    methods that extend `Audio` (`getDefaults` and `toString`). We continue to use
    `Zepto` and pass in both `window` and `document` into the IIFE as a reference
    and then self contain our code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of MediaElement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our constructor, we need to do two things. One, we need to get the audio
    element on the page and cache it. And two, we need to create or initialize an
    instance of MediaElement based on the element on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and caching an audio element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find the audio element and cache it, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `this` keyword is in reference to the instance of `audio`
    that gets returned to `App.Audio`. We then create a property on `this` called
    `audioElement`, which gets set to the first audio element found on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `getElementsByTagName`, which exists on the document, accepts one
    parameter, a string. This method gets all the elements on the page that match
    that tag in an array. In this instance, we only have one audio element on the
    page, so we get an array with one element found. Thus, we use `[0]` to get the
    first instance in that array.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the audio element, we cache it as a `Zepto` object so that we use
    `Zepto` once, thus increasing the performance of our application. I usually do
    this in most of my projects because I find myself using many of Zepto's built-in
    methods, especially for creating event listeners. However, this can be skipped
    if you don't find it useful in your case.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing MediaElement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our audio element, we can follow the code we wrote in the
    last section on how to initialize `MediaElement`. So you don''t have to flip back,
    here''s the code we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the same code we wrote previously, and the ellipsis in the callbacks
    should contain `console.log` we had written. The one thing you should notice is
    that we pass in `this.audioElement`, our cached audio element, into this instance
    of `MediaElement`. Also, we have now created a reference to the instance of `MediaElement`
    with `this.mediaElement`. Now we can publicly control the audio from the instance
    of `App.Audio` we will create later on.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a fully functional audio player built off our abstracted
    class of `MediaElement`. However, there's not much going on; we only have a setup
    that works and is extensible, but it is not in any way unique. This is where our
    dynamic audio player will come in to play.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic audio player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So at this point, we have an audio class that extends our `MediaElement` object
    with events that are exposed and therefore available for us to create dynamic
    content. Now, let's have some fun and create a dynamic audio player that switches
    tracks.
  prefs: []
  type: TYPE_NORMAL
- en: The select element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, when we created this application in [Chapter 1](ch01.html "Chapter 1. Application
    Architecture"), *Application Architecture*, we created a navigation that is contained
    by anchor tags and list elements. Although this works perfectly on desktop and
    perhaps the iPad, it is not suitable for smaller screen devices like the iPhone.
    For this reason, the `select` element brings up a native component that allows
    you to easily navigate choices that you can select.
  prefs: []
  type: TYPE_NORMAL
- en: Apple's developer documentation suggests that we use the `select` element in
    our apps, because it has been optimized as a custom control within iOS ([http://goo.gl/T3xuY](http://goo.gl/T3xuY)).
    This is extremely useful, because it allows us to keep within the guidelines for
    web application design for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go ahead with the implementation. First we need to make sure to
    add the `select` element to our page. Right now, you should have the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to do is add the select element after the `audio` tag, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![The select element](img/1024OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A select element
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we have added a select element that contains multiple
    options. These options have a `value` attribute, and the first option also contains
    a `selected` attribute. The value attribute should contain the track you have
    in your assets, and the selected attribute tells the `select` to have that option
    automatically selected on page load.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we assume that all our audio is MP3\. In your case this may
    be different, and if so, we would need to build logic into the code we will write
    to handle this logic. Because of the complexity that would be introduced, we focus
    exclusively on handling audio tracks that have a MIME type of MP3.
  prefs: []
  type: TYPE_NORMAL
- en: Switching audio tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `select` element on the page listing out the several audio
    tracks in an iOS suggested manner, we now want to make our player dynamic based
    on user input. To do this, we need to create an event listener to handle the change
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The change event listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `select` element has a specific event we can listen to, namely the `change`
    event. This is fairly easy to accomplish with `Zepto` and our cached instance
    of the audio element. To add the listener, let''s go to our `attachEvents` method
    in `App.Audio` and add the following bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First we are creating a variable called `that`, which refers to the instance
    of audio. Then we get the cached element we created in the constructor and delegate
    the `change` event coming from any `select` element on the page. When the `change`
    event fires, we call the anonymous function, namely the third parameter in the
    `on` method. Inside this anonymous function we call a method, which we have not
    created, called `onSelectedChange`, and pass it in the event or the `e` reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using Zepto's `on` method. This method can accept various parameters
    similar to jQuery's `on` method, but in this case, we send in the event we want
    to listen to, the element it should be coming from, and then finally a function
    that should be called. On top of this, our anonymous function is doing a call
    on the method, which we have discussed previously, but essentially it changes
    the reference of this to be audio.
  prefs: []
  type: TYPE_NORMAL
- en: The change event handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have created the listener for the `change` event, we need to define
    the handler. We haven''t created this yet, but it entails some fairly complex
    functionality. Initially, this should be fairly easy now that we have an API via
    the `MediaElement` instance. However, we only have one audio element on the page,
    so we need to be able to use that one element for playback. Thus, we need to do
    the following in our handler:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a temporary reference to our cached audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the playback of the audio, even if it is not playing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the cached audio element to the temporary reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the audio element from the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete the cached media element, audio element, and Zepto audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the source of the cloned audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append the cloned audio element to the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recreate the cached media element, audio element, and Zepto audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, this sounds like a lot of work to do in order to keep a single audio element
    on the page, but the code to do this is very little and involves some copy and
    paste because we have already written it. So, let's write some magic!
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the event handler section, we want to include the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we go ahead and run the code in the browser, we should be able to switch
    between audio tracks with no problem. If you do have an issue, please refer to
    the provided source code.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, the preceding code does exactly what we wanted. If we analyze the
    code closely, we can see that we are essentially tapping into the `MediaElement`
    class when we stop the playback. This is an example of how easy it is to play
    around with media elements such as audio and video now that it has been abstracted.
    Also note that we are using quite a few of the Zepto methods, including `clone`,
    `remove`, `prepend`, and `attr`. These are all methods that are useful, which
    is precisely the reason we cache our audio element.
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself what the `delete` section does in our preceding code.
    Essentially, this helps with garbage collection; it tells the JavaScript engine
    that we no longer need this and so you can recollect it. Yes, we can set them
    to the new values after we prepend the new audio element, but this is a sure fire
    way of starting fresh and not leaving anything up to guessing from the JavaScript
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: There is a problem with the code we've written, and that is the redundancy of
    the recreation of the `audioElement`, `$audioElement`, and `mediaElement` objects.
    As we've defined this functionality previously in our constructor, we can refactor
    to make sure our functionality is all located in one place—this is what the next
    section looks at. If you already understand what is meant by the refactor of this
    code, you can skip this part.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we have the same code in two places, we are starting to introduce some
    redundancy. To make our application a bit more manageable, we should centralize
    the same functionality into one location. Doing this is not complex, and it is
    simpler than you would probably imagine.
  prefs: []
  type: TYPE_NORMAL
- en: For our refactor, we only need to write one method, a `setAudioElement` method.
    This method should be private and only available within the `Audio` class, and
    it should only contain the code necessary for creating the references to the `audioElement`,
    `$audioElement`, and `mediaElement` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create the following method in our private methods section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now copy the following code from the constructor, and paste it into `setAudioElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, let''s call `setAudioElement` within our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application now, it should run like normal, as if we had not
    changed anything. Now we need to replace the repeated code in the `select` handler
    to call the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've done all the refactoring we need, let's run the application on
    our iPhone simulator. When the page runs and you switch between audio tracks,
    you should not encounter any issues. There's nothing surprising here, but the
    cool thing is that you now a have common code centralized in one location. This
    is the essence of refactoring, and it helps achieve a maintainable codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our Audio class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, we've focused on the development of the `Audio` class. That's
    fine, but now we need to initialize all of this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open up the `index.html` file for the **Audio** page. This should
    be located at `/audio/index.html`. Once we''ve opened up that file, scroll to
    the bottom of the source code and add the following script after all the other
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit different from how we initialized `App.Video`, in that we now
    pass in the element while `App.Video` finds the video elements within it. The
    reason behind the difference was to show how we can initialize our classes differently.
    It's up to you on how you want to initialize a class. Each has its advantages
    and disadvantages, but it's good to be aware of the alternatives and choose the
    best one your code style and project needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a dynamic audio player running off an abstract `MediaElement` class.
    On top of that, we have created a UI that is effective for this purpose and executes
    what is expected. But what if we want clearer control of the audio besides what
    is provided in the default interface? In the next section, we discover how to
    control our audio using the `MediaElement` class we've created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing HTML5 audio controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll cover how to customize the controls of our audio player.
    As we've seen in our video player discussed in the previous chapter, it can be
    fairly useful to create a custom experience. For this book, we've kept it fairly
    simple, and we will continue following that pattern so that we can discuss the
    principles and get you started quickly. For audio, customizing the controls is
    even simpler, especially since we do not have control over the volume, which is
    discussed further in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom media controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s remove the `controls` attribute from our `audio` element. When
    we do this, you should have the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add custom controls to the markup. We can continue doing the
    same thing we did in the previous chapter, except this time we abstract it with
    a media-controls class and keep it simple by just having a play and pause button.
    This should also go after the `audio` element. When we are finished, the markup
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you check out the application on the iPhone simulator, it should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom media controls](img/1024OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom controls
  prefs: []
  type: TYPE_NORMAL
- en: What you will notice is that we now have no audio element being displayed on
    the page. This is because we have taken out the `controls` attribute. Don't worry
    about it too much; this is the expected behavior on iOS. Normally, you would create
    all the controls for your audio player, but for now we'll just do play and pause.
    As a bonus, you would probably want a track as well, but that is for a much larger
    discussion and does not fit the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity to our customized controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where all the magic happens. We will now connect the interactivity we've
    built into the `MediaElement` class in order to customize our experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go to our `App.Audio` JavaScript file and find the `attachEvents`
    method. To keep it short and simple, let''s include the following bit of code
    after our `change` event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the cached `$element` to find the media controls, and
    then attaches the clock event onto the play and pause buttons accordingly. Inside
    each event listener we use the instance of `mediaElement` that has been created
    within the `setAudioElement` method to call the `play` or `pause` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to note is that our event listeners are using `that` in order to reference
    the instance of `mediaElement`. If you recall, we created the `that` variable
    at the top of the `attachEvents` method so that we have a reference of `this`
    inside of the event listener. As we've explained previously, JavaScript has function
    scope, so when we create our event listener, that function has created a new scope
    that sets the relation of `this` to the scope of the event. Behind the scenes,
    Zepto sets `this` to the target element, which would be either the `play` or `pause`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need to make customized controls that play and pause our audio.
    If we now test the application, we should be able to switch between tracks, play
    our track, and pause the track.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we take a look at how we can build a preliminary playlist.
    Although this section is more bonus material, it's useful when creating some sort
    of a music player application where there are playlists of music we want to play
    sequentially. At first, it may be difficult to understand how we can do this,
    especially given the fact that we need user input to enable playback, but it's
    not really an issue. Because the load and play methods are initiated on the first
    song, we can just switch the source, load it, and then play the track. So let's
    go through it step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: The markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We don''t really want to play music sequentially by default, this should be
    user initiated based on good user experience design. So, let''s include another
    button for the user to enable or disable this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All we've done in the preceding code is added another button after the play
    and pause buttons. This button contains the appropriate three classes that we
    need and the text `Sequential Off`, because we only want users to enable this
    feature if they want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your markup is all set, you should have the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The markup](img/1024OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The sequential button
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s a bit of work to do here, but nothing overly complicated. Here''s
    what we want to do as a checklist:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a default setting for sequential playback, and set it to false
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `handleOnAudioEnded` method, with a parameter for the `Audio` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `handleOnAudioEnded` method within the `onEnded` callback of the MediaElement
    initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `handleOnAudioEnded` method, we should check if sequential playback
    is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If sequential playback is enabled, we want to update the select menu and reload
    the audio element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we want to listen for the click event on the new sequential button
    to enable or disable this feature, while also updating the button's status as
    well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, first things first, let''s create the sequential default setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too crazy, we''ve just added a default setting called `sequential`
    and set it to `false`. Next, we want to create the `handleOnAudioEnded` method
    that contains the functionality we''ve listed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry if you don''t understand the preceding code, just take the following
    points into account:'
  prefs: []
  type: TYPE_NORMAL
- en: The only parameter we are passing is an instance of `Audio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then check if `sequential` is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''ve verified we want sequential playback, we create two variables:
    `$select`, which caches the select element, and `$next`, which will cache the
    next song in the playlist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we set the `$next` element while removing the `selected` attribute from
    the current option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We update the `select` menu by setting the `selectedIndex` to the next option
    in `select`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we update the audio elements source directly, load that source, and
    set the status to playing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method handles the playback of the next source we want to play. We could
    probably improve this by adding the functionality to change the source, load,
    and play inside the `MediaElement` class, but I'll leave that up to you to decide
    and extend as needed. We could also possibly cache `select` at the class level
    (`Audio`), instead of doing it each time we want to play sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have not added any error checking. Currently, this code doesn't
    do a check for when we get to the end of the list. Perhaps we want it to loop,
    or maybe we want to inform the user the playlist is done? There are many use cases
    that we can execute here, but you get the point, which is that we can have a playlist
    in our application if we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we want to call the preceding method we created when we pass in `callbacks`
    to the initialization of the media element. As you may recall, we put this in
    our `setAudioElement`, and therefore we want to update the initialization to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All we did here was update the `onEnded` method by calling `handleOnAudioEnded`
    and passing in `that`, which is a reference to the instance of the `Audio` class.
    Now, all we need to do is add our event listener for when the user wants sequential
    playback, which can be added in our `attachEvents` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code basically shows that we have added a `click` event listener
    to our sequential button, and all it does is call the `handleSequentialClick`
    method that accepts an event and the instance of audio with the `that` variable
    we created previously. Notice how we haven''t created the `handleSequentialClick`
    method? Well, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Put simply, this method just updates the default `sequential` option to `true`
    or `false`, toggling the value depending on the previous status. The method also
    toggles the classes of the button and the inner text, updating the user based
    on their interaction.
  prefs: []
  type: TYPE_NORMAL
- en: iOS considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have customized much of the experience for both the video
    and audio elements. This will work perfectly for desktop devices, but there are
    a few points we need to take into account when working with touch devices, such
    as the iPhone and iPad. The good thing is that these are points that are consistent
    across all iOS devices, and as such should be something we take into account.
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set the volume for audio and video elements from `0` to `1`, and we can
    maintain the state of the volume in our `MediaElement` library. This is good practice
    for an overall architecture. However, on iOS, the volume is under the user's physical
    control—the volume button we interact with on almost any device.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW11](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: On iOS devices, the audio level is always under the user's physical control.
    The volume property is not settable in JavaScript. Reading the volume property
    always returns 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Basically, we can't set the volume property; it will always return `1`. This
    is so that we don't manipulate the user's volume, and as such is only set via
    the user's volume control button.
  prefs: []
  type: TYPE_NORMAL
- en: Autoplay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our application, we've also seen an example of autoplay, where we play the
    audio after we select a different track in our `select`. This works perfectly
    on a desktop, but not so much on iOS. There's a reason for this, and it's basically
    to protect the user's cellular data usage. This is a design decision on Apple's
    part, and is something we could see on other devices as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW8](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: Autoplay is disabled to prevent unsolicited cellular download.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It also states that ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW4](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: In Safari on iOS (for all devices, including iPad), where the user may be on
    a cellular network and be charged per data unit, preload and autoplay are disabled.
    No data is loaded until the user initiates it. This means the JavaScript play()
    and load() methods are also inactive until the user initiates playback, unless
    the play() or load() method is triggered by user action. In other words, a user-initiated
    Play button works, but an onLoad="play()" event does not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simultaneous playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be asking why we didn't go into more complicated experiences, including
    multiple video playback or audio tracks playing at the same time. Well, there's
    a good reason for that too, and it's basically because iOS limits the playback
    of audio or video streams to one at a time. This also comes back to the fact that
    we don't want to use more cellular data than necessary on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per Apple''s documentation ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW10](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, all devices running iOS are limited to playback of a single audio
    or video stream at any time. Playing more than one video—side by side, partly
    overlapping, or completely overlaid—is not currently supported on iOS devices.
    Playing multiple simultaneous audio streams is also not supported.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are more considerations that should be taken into account when developing
    an iOS web application that supports audio and video media playback. We can continue
    covering this here, but I encourage you to visit Apple's documentation, *iOS-Specific
    Considerations* ([http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html](http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html)),
    to review all the necessary considerations. The previously mentioned documentation
    snippets should cover some of the concerns you had while developing the video
    and audio sections of this book, but it's always good to be aware of all the issues
    that come up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've reviewed the media element API from the perspective of
    audio playback on iOS. From abstracting the previous code into a `MediaElement`
    class making it reusable for both audio and video, to customizing the controls
    of the audio element, we have created a dynamic audio player that works and is
    constructed in a modular pattern. Along with creating an audio player, we have
    reviewed the considerations that must be made on an iOS device, such as the control
    of volume and the limitation of simultaneous playback. I hope that this chapter
    has helped you get started experimenting with audio, and has helped you understand
    that we can consolidate code and focus on delivering features that are critical
    within our applications by abstracting our code. In the next chapter, we shift
    to how we can use touch and gestures to create unique user experiences that go
    beyond just clickable buttons.
  prefs: []
  type: TYPE_NORMAL
