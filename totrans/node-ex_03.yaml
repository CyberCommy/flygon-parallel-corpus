- en: Chapter 3. Managing Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first two chapters were a good introduction to the building blocks and
    structures of Node.js application development. We learned about the fundamentals
    of the technology and revealed important patterns such as Model-View-Controller.
    We talked about test-driven development and REST APIs. In this chapter, we will
    create the base of our social network. The proper delivery and management of an
    application''s assets is an essential part of the system. In most of the cases,
    it determines our workflow. We will go through the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving files with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS preprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packing client-side JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivering HTML templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving files with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js differs from the usual Linux-Apache-MySQL-PHP setup. We have to write
    the server that handles the incoming request. When the user requires an image
    from our backend, Node.js doesn''t serve it automatically. The very first file
    of our social network will be `server.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We require three native modules that we will use to drive the server and deliver
    assets. The last two lines of the preceding code run the server and print a message
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the entry point of our application is the `assets` function. The main
    purpose of this method is to read files from the hard disk and serve it to the
    users. We will use `req.url` to fetch the current request path. When a web browser
    accesses our server and requests `http://localhost:9000/static/css/styles.css`
    in the browser, `req.url` will be equal to `/static/css/styles.css`. From this
    point onwards, we have a few tasks to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the file exists and if not, sending a proper message (HTTP
    error code) to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the file and finding out its extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the file's content to the browser with the correct content type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is an important one. Serving files with a wrong or missing content
    type may cause problems. The browser may not be able to recognize and process
    the resource properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the process smooth, we will create a separate function for each of
    the tasks mentioned. The shortest one is the one that sends an error message to
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, the value of the `code` variable is `404`, which means **Not Found**.
    However, there are different types of errors, such as client errors (4XX) and
    server errors (5XX). It is good to leave an option to change the error's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have the content of the file and its extension. We need
    a function that recognizes the correct content type and delivers the resource
    to the client. For the sake of simplicity, we will perform a simple string-to-string
    check of the file''s extension. The following code does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `serve` method accepts a `file` object with two properties—`ext` and `content`.
    In the next few chapters, we will probably add more file types to the list. However,
    for now, serving JavaScript, CSS, HTML, JPG, and PNG images is enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task that we have to cover is the actual reading of the file. Node.js
    has a built-in module to read files called `fs`. We will use the asynchronous
    versions of its methods. With synchronous functions, the JavaScript engine may
    be blocked till the particular operation is fully executed. In this case, that
    is a reading of a file. In asynchronous programming, we allow our program to execute
    the rest of the code. In this scenario, we normally pass a callback—a function
    that will be executed when the operation ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function accepts the path and opens the file. If the file is missing or
    there is a problem reading it, it sends an error to the user. In the beginning,
    we defined a `files` variable, which is an empty object. Every time we read a
    file, we are storing its content there so that the next time we read it, we don't
    have to access the disk again. Every I/O operation, such as reading a file, takes
    time. By using this simple caching logic, we improve the performance of our application.
    If everything is okay, we call the `serve` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you combine all the preceding snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Every HTTP request sent to our server is processed by the `assets` handler.
    We compose the file's path, starting from the current directory. The `path.normalize`
    parameter guarantees that our string looks alright on different operating systems.
    For example, it does not contain multiple slashes.
  prefs: []
  type: TYPE_NORMAL
- en: CSS preprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS preprocessors are tools that accept source and produce CSS. Very often,
    the input is similar to the CSS language with regard to the syntax. However, the
    main idea of preprocessing is to add features that are missing and, at the same
    time, wanted by the community. Over the past few years, CSS preprocessing has
    become a hot topic. It comes with lots of benefits and the concept has been warmly
    accepted by the community. There are two main CSS preprocesors—**Less** ([http://lesscss.org/](http://lesscss.org/))
    and **Sass** ([http://sass-lang.com/](http://sass-lang.com/)). Sass is based on
    the Ruby language and it requires more effort to run it in a Node.js project.
    So in this book, we are going to use Less.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we talked about building systems and task runners.
    CSS preprocessing and a few other tasks that we will talk about in a bit should
    happen automatically. Gulp seems like a good option. Let''s move forward and add
    a `package.json` file where we will describe all the Gulp-related modules that
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The setting of `"start": "node server.js"` will allow us to type `npm start`
    and run our server. The dependencies that we will start with are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gulp itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulp-less`: This is a plugin that wraps the Less preprocessor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulp-rename`: This changes the name of the produced file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulp-minify-css`: This compresses our CSS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, along with `server.js`, we now have `package.json`. We run `npm install`
    and the package manager adds a `node_modules` directory containing the modules.
    Let''s define our Gulp tasks in another file named `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start with two tasks—`css` and `watchers`. The first one expects us to have
    a `less` directory and a `styles.less` file inside. This will be our entry point
    to all the CSS styles. As seen from the Gulp task, we pipe the content of the
    file to the preprocessor and export the result to the `static/css` directory.
    Since everything with Gulp is a stream, we can continue and minify the CSS, rename
    the file to `styles.min.css`, and export it to the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: We do not want to run the building processes by ourselves every time we make
    changes to a file. So, we register `watchers` for the files in the `less` folder.
    A watcher is a process that monitors specific files and notifies the rest of the
    system once these files are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this step, our project looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS preprocessing](img/image00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Packing client-side JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with CSS, our goal should be to serve only one JavaScript file to the client's
    browser. We do not want to force the user to make more than one request, because
    this is less efficient and it means that the web browser takes longer to process
    and display the content of the page. Nowadays, the client-side part of applications
    is fairly complex. As with complex systems, we split our logic into different
    modules. Often, different modules mean different files. Thankfully, Node.js is
    full of tools that can be used to pack JavaScript. Let's see two of the most popular
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating with Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gulp, as a build system, has several modules to concatenate files. The one
    that we are interested in is called `gulp-concat`. Let''s add it to the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to write a task that uses it. Again, we will use the `src`
    and `dest` Gulp methods, and in between is the concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It's important to mention that the files will be added to the final file in
    alphabetical order. So, we should be careful whenever there are some code dependencies.
    If this is the case, we should name the files in such a way that their names start
    with a unique number—01, 02, 03, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next logical task that we will do is to minify our JavaScript. Like the
    Less compilation, we want to serve a file that is as small as possible. The module
    that will help us achieve this is `gulp-uglify`. Again, we should add it to the
    `package.json` file (`"gulp-uglify": "1.0.1"`). After this, a little tweak to
    our newly created task will minify the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used the `gulp-rename` plugin again. This is necessary because
    we want to produce a different file.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity in the browser with RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While building software, one of the most important concepts to think about is
    the splitting of our system into modules. Node.js has a nice built-in system to
    write modules. We mentioned this in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Node.js
    Fundamentals"), *Node.js Fundamentals*. We encapsulate our code in a single file
    and use `module.exports` or `exports` to create the public API. Later, via the
    `require` function, we access the created functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for the client-side JavaScript, we do not have such a built-in system.
    We need to use an additional library that allows us to define modules. There are
    several possible solutions. The first one that we will take a look at is RequireJS
    ([http://requirejs.org/](http://requirejs.org/)). We will download the library
    (version 2.1.16) from the official site and include it in our page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The key attribute here is `data-main`. It tells RequireJS about our application''s
    entry point. In fact, we should have the `scripts/main.js` file in our project''s
    folder to get the preceding line working. In `main.js`, we can use the `require`
    global function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's say that our code in `main.js` depends on two other modules—the Ajax wrapper
    and router. We describe these dependencies in an array and provide a callback,
    which is later executed with two parameters. These parameters are actually references
    to the necessary modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The defining of modules is possible with the help of another global function—`define`.
    Here is how the Ajax wrapper looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, behind the scenes, RequireJS resolves the dependencies asynchronously.
    In other words, it performs an HTTP request for every required module. In some
    cases, this may lead to performance issues because every request takes time. Thankfully,
    RequireJS has a tool (optimizer) that solves the problem. It can bundle all the
    modules into a single file. The tool is available for Node.js too and it is distributed
    with the `requirejs` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful installation, we will have the `r.js` command in our terminal.
    The basic call looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Grunt and Gulp, we have a file that instructs RequireJS on how to work.
    The following is a snippet that covers our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` property is the entry point and `out` is the resulting file. It''s
    nice that we have the `paths` property available. It is a place where we can describe
    the modules directly; for example, `jquery: "some/other/jquery"`. Later in our
    code, we do not have to write the full path to the files. Just a simple `require([''jquery''],
    ...)` is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the output of the `r.js` command is minified. If we add an `optimize=none`
    argument to the command in the terminal, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `main-built.js` file contains the main module and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Moving from Node.js to the browser with Browserify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RequireJS indeed solves the problem with modularity. However, it makes us write
    more code. Also, we should always describe our dependencies by following a strict
    format. Let''s look at the code that we used in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is indeed better if we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code is much simpler now. This is how we should fetch a module in the Node.js
    environment. It would be nice if we could use the same approach in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browserify ([http://browserify.org/](http://browserify.org/)) is a module that
    brings the `require` module of Node.js to the browser. Let''s install it first
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to illustrate how the tool works, we will create the `main.js`,
    `ajax.js` and `router.js` files. This time, we are not going to use a global function
    such as `define`. Instead, we will use the usual Node.js `module.exports`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Browserify comes as a command-line tool. We need to provide an
    entry point and an output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result in the compiled file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that along with the modules, the compiled file also contains the `require`
    function's definition and implementation. It's really just a few bytes of code
    that makes Browserify one of the most popular ways to deliver modular JavaScript
    in the browser. This is what we are going to use in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have started a Gulp setup. Let''s add Browserify there. We have already
    made a concatenation of the JavaScript. Let''s replace it with Browserify. We
    will add the module to the `package.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `npm install`, we will get the plugin installed and ready to
    use. We need to make two changes, replacing `concat` with `browserify` and pointing
    out the application''s main file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `src` method accepts only one file. It's our entry point. This is the
    place where Browserify starts resolving dependencies. The rest is the same. We
    still use `uglify` for minification and `rename` to change the file's name.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering HTML templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you saw how you can package CSS and JavaScript for
    the browser. At the end of this chapter, we will explore the various ways to deliver
    HTML. In the context of client-side applications, the templates still contain
    HTML. However, we need a dynamic way to render and fill them with data.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the templates in script tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ember.js framework adopts the concept of adding HTML templates directly
    into the page by using the popular **handlebars** ([http://handlebarsjs.com/](http://handlebarsjs.com/))
    template engine. However, since we do not want to mess up the markup that is already
    there, we place them in the `<script>` tags. The good thing about this is that
    if we set a custom value of the `type` attribute, the browser does not process
    the code inside. Here''s a demonstration of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the tag has an `id` attribute, we can get its content easily in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this technique is that the template is on the page and we have
    instant access to it. Also, templates only display the desired content after being
    processed by JavaScript. So, if JavaScript is not enabled in the browser, we do
    not want to display the unprocessed raw template. A major problem with this concept
    is the fact that we will flood our HTML page with a lot of code. If we have a
    big application, then the user will have to download all the templates even if
    he/she uses only a part of it.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the template externally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s also a common practice to define the templates as external files and
    load them on the page with an Ajax request. The following pseudocode uses jQuery''s
    `get` method to do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have clear markup, but the user has to make an additional HTTP request in
    order to fetch the template. This approach makes the code more complex because
    the process is asynchronous. It also makes the processing and rendering of the
    content slower than the preceding method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing HTML inside the JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the rise of mobile applications, many big companies have started developing
    their own frameworks. Since these companies have enough resources, they usually
    produce something interesting. For example, Facebook created a framework called
    **React** ([http://facebook.github.io/react/](http://facebook.github.io/react/)).
    It defines its templates directly in the JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The developers from Facebook adopted the first technique mentioned in this section.
    They put some code inside a `<script>` tag. In order to get things working, they
    have their own parser. It processes the script and converts it into valid JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are solutions that do not have templates in the form of HTML. There are
    tools that use templates written in JSON or YAML. For example, **AbsurdJS** ([http://absurdjs.com/](http://absurdjs.com/))
    can keep its template inside the JavaScript class definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Precompiling templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another popular way to deliver templates to the client side is by using precompilation.
    This is what we are going to use in our project. Precompilation is a process that
    converts the HTML template to a JavaScript object, which is ready for use in our
    code. This approach has several benefits, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to think about accessing the HTML template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The markup is still separated from the JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not lose time in fetching and processing the HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different client-side frameworks have different tools to precompile templates.
    We will cover this in detail later, but the instrument that we are going to use
    for our social network application is called Ractive.js ([http://www.ractivejs.org/](http://www.ractivejs.org/)).
    It's a client-side framework that was originally developed by the people at TheGuardian
    to produce a news application. It's cross-browser and it performs well on mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to transform our HTML into Ractive-precompiled templates, we need
    two new modules in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gulp-tap` plugin allows us to process every file sent to the Gulp''s pipeline.
    Here is the new task that we have to add to the `gulpfile.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Ractive.parse` returns the precompiled template. Since it is a JavaScript
    object, we use `JSON.stringify` to convert it to a string. We use Browserify to
    control our client-side modularity so `module.exports` is attached in front of
    the template''s code. In the end, we use `gulp-rename` and produce a JavaScript
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a `/tpl/template.html` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the `gulp` command, we will receive `/tpl/template.js` , which
    contains the JavaScript that is equivalent to the preceding markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It probably looks strange now, but in the next few chapters, you will see how
    you can use such templates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assets are a major part of web applications. Often, companies do not pay enough
    attention to this part, which leads to slower loading time and increased web hosting
    costs, especially when your site grows in popularity. In this chapter, we saw
    that it is important to find the right setup and deliver the images, CSS, JavaScript,
    and HTML in the most efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start working heavily on our social network. We
    will explore the world of the Model-View-Controller pattern.
  prefs: []
  type: TYPE_NORMAL
