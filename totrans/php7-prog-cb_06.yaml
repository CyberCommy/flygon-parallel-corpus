- en: Chapter 6. Building Scalable Websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a generic form element generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML radio element generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML select element generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a form factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining `$_POST` filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining `$_POST` validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tying validation to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to build classes that generate HTML form
    elements. The generic element generator can be used for text, text areas, passwords,
    and similar HTML input types. After that, we will show variations that allow you
    to pre-configure the element with an array of values. The form factory recipe
    will bring all these generators together, allowing you to render an entire form
    using a single configuration array. Finally, we introduce recipes that allow filtering
    and the validation of incoming `$_POST` data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a generic form element generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s pretty easy to create a function that simply outputs a form input tag
    such as `<input type="text" name="whatever" >`. In order to make a form generator
    generically useful, however, we need to think about the bigger picture. Here are
    some other considerations over and above the basic input tag:'
  prefs: []
  type: TYPE_NORMAL
- en: The form `input` tag and its associated HTML attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A label that tells the user what information they are entering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to display entry errors following validation (more on that later!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some sort of wrapper, such as a `<div>` tag, or an HTML table `<td>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Form\Generic` class. This will also later serve
    as a base class for specialized form elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define some class constants, which will be generally useful in form
    element generation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first three will become keys associated with the major components of a
    single form element. We then define supported input types and defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can define properties and a constructor that sets them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we require two properties, `$name` and `$type`, as we cannot
    effectively use the element without these attributes. The other constructor arguments
    are optional. Furthermore, in order to base one form element on another, we include
    a provision whereby the second argument, `$type`, can alternatively be an instance
    of `Application\Form\Generic`, in which case we simply run the *getters* (discussed
    later) to populate properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that `$wrappers` has three primary subkeys: `INPUT`, `LABEL`, and `ERRORS`.
    This allows us to define separate wrappers for labels, the input tag, and errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Before defining the core methods that will produce HTML for the label, input
    tag, and errors, we should define a `getWrapperPattern()` method, which will produce
    the appropriate *wrapping* tags for the label, input, and error display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If, for example, the wrapper is defined as `<div>`, and its attributes include
    `[''class'' => ''label'']`, this method will return a `sprintf()` format pattern
    that looks like this: `<div class="label">%s</div>`. The final HTML produced for
    the label, for example, would then replace `%s`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is how the `getWrapperPattern()` method might look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to define the `getLabel()` method. All this method needs to
    do is to plug the label into the wrapper using `sprintf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to produce the core `input` tag, we need a way to assemble the attributes.
    Fortunately, this is easily accomplished as long as they are supplied to the constructor
    in the form of an associative array. All we need to do, in this case, is to define
    a `getAttribs()` method that produces a string of key-value pairs separated by
    a space. We return the final value using `trim()` to remove excess spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the element includes either the `value` or `href` attribute, for security
    reasons we should escape the values on the assumption that they are, or could
    be, user-supplied (and therefore suspect). Accordingly, we need to add an `if`
    statement that checks and then uses `htmlspecialchars()` or `urlencode()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the core input tag, we split the logic into two separate methods. The primary
    method, `getInputOnly()`, produces *only* the HTML input tag. The second method,
    `getInputWithWrapper()`, produces the input embedded in a wrapper. The reason
    for the split is that when creating spin-off classes, such as a class to generate
    radio buttons, we will not need the wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define a method that displays element validation errors. We will assume
    that the errors will be supplied in the form of an array. If there are no errors,
    we return an empty string. Otherwise, errors are rendered as `<ul><li>error 1</li><li>error
    2</li></ul>` and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For certain attributes, we might need more finite control over various aspects
    of the property. As an example, we might need to add a single error to the already
    existing array of errors. Also, it might be useful to set a single attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define getters and setters that allow us to retrieve or set the
    values of properties. For example, you might have noticed that the default value
    for `$pattern` is `<input type="%s" name="%s" %s>`. For certain tags (for example,
    `select` and `form` tags), we will need to set this property to a different value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add methods that will give the label value (not the HTML),
    as well as the errors array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Be sure to copy all the preceding code into a single `Application\Form\Generic`
    class. You can then define a `chap_06_form_element_generator.php` calling script
    that sets up autoloading and anchors the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the wrappers. For illustration, we''ll use HTML table data and
    header tags. Note that the label uses `TH`, whereas input and errors use `TD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now define an email element by passing parameters to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, define the password element using setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, be sure to define a submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual display logic might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an HTML radio element generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A radio button element generator will share similarities with the generic HTML
    form element generator. As with any generic element, a set of radio buttons needs
    the ability to display an overall label and errors. There are two major differences,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you will want two or more radio buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each button needs to have its own label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, create a new `Application\Form\Element\Radio` class that extends
    `Application\Form\Generic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define class constants and properties that pertain to the special needs
    of a set of radio buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this illustration, we will need a `spacer`, which will be placed between
    the radio button and its label. We also need to decide whether to place the radio
    button label before or after the actual button, thus, we use the `$after` flag.
    If we need a default, or if we are re-displaying existing form data, we need a
    way of designating the selected key. Finally, we need an array of options from
    which we will populate the list of buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Given that we are extending `Application\Form\Generic`, we have the option of
    expanding the `__construct()` method, or, alternatively, simply defining a method
    that can be used to set specific options. For this illustration, we have chosen
    the latter course.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure the property `$this->options` is populated, the first parameter (`$options`)
    is defined as mandatory (without a default). All other parameters are optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are ready to override the core `getInputOnly()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We save the `id` attribute into an independent variable, `$baseId`, and later
    combine it with `$count` so that each `id` attribute is unique. If the option
    associated with the selected key is defined, it is assigned as the value; otherwise,
    we use the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `foreach()` loop we check to see if the key is the one selected.
    If so, the `checked` attribute is added for that radio button. We then call the
    parent class `getInputOnly()` method to return the HTML for each button. Note
    that the `value` attribute of the input element is the options array key. The
    button label is the options array element value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the preceding code into a new `Radio.php` file in the `Application/Form/Element`
    folder. You can then define a `chap_06_form_element_radio.php` calling script
    that sets up autoloading and anchors the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, define the wrappers using the `$wrappers` array defined in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can define a `$status` array and create an element instance by passing
    parameters to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can see if there is any status input from `$_GET` and set the options.
    Any input will become the selected key. Otherwise, the selected key is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, don''t forget to define a submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The display logic might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A checkbox element generator would be almost identical to the HTML radio button
    generator. The main difference is that a set of checkboxes can have more than
    one value checked. Accordingly, you would use PHP array notation for the element
    names. The element type should be `Generic::TYPE_CHECKBOX`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTML select element generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating an HTML single select element is similar to the process of generating
    radio buttons. The tags are structured differently, however, in that both a `SELECT`
    tag and a series of `OPTION` tags need to be generated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a new `Application\Form\Element\Select` class that extends
    `Application\Form\Generic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The reason why we extend `Generic` rather than `Radio` is because the structuring
    of the element is entirely different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The class constants and properties will only need to add slightly to `Application\Form\Generic`.
    Unlike radio buttons or checkboxes, there is no need to account for *spacers*
    or the placement of the selected text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we turn our attention to setting options. As an HTML select element can
    select single or multiple values, the `$selectedKey` property could be either
    a string or an array. Accordingly, we do not add a **type hint** for this property.
    It is important, however, that we identify whether or not the `multiple` attribute
    has been set. This can be obtained from a `$this->attributes` property via inheritance
    from the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `multiple` attribute has been set, it''s important to formulate the
    `name` attribute as an array. Accordingly, we would append `[]` to the name if
    this were the case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP, if the HTML select `multiple` attribute has been set, and the `name`
    attribute is not specified as an array, only a single value will be returned!
  prefs: []
  type: TYPE_NORMAL
- en: Before we can define the core `getInputOnly()` method, we need to define a method
    to generate the `select` tag. We then return the final HTML using `sprintf()`,
    using `$pattern`, `$name`, and the return value of `getAttribs()` as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We replace the default value for `$pattern` with `<select name="%s" %s>`. We
    then loop through the attributes, adding them as key-value pairs with spaces in
    between:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a method to obtain the `option` tags that will be associated
    with the `select` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you will recall, the *key* from the `$this->options` array represents the
    return value, whereas the *value* part of the array represents the text that will
    appear on screen. If `$this->selectedKey` is in array form, we check to see if
    the value is in the array. Otherwise, we assume `$this-> selectedKey` is a string
    and we simply determine if it is equal to the key. If the selected key matches,
    we add the `selected` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally we are ready to override the core `getInputOnly()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will note that the logic for this method only needs to capture the return
    values from the `getSelect()` and `getOptions()` methods described in the preceding
    code. We also need to add the closing `</select>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the code described above into a new `Select.php` file in the `Application/Form/Element`
    folder. Then define a `chap_06_form_element_select.php` calling script that sets
    up autoloading and anchors the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the wrappers using the array `$wrappers` defined in the first
    recipe. You can also use the `$statusList` array defined in the *Creating an HTML
    radio element generator* recipe. You can then create instances of `SELECT` elements.
    The first instance is single select, and the second is multiple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'See if there is any status input from `$_GET` and set the options. Any input
    will become the selected key. Otherwise, the selected key is the default. As you
    will recall, the second instance is multiple select, so the value obtained from
    `$_GET` and the default setting should both be in the form of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, be sure to define a submit button (as shown in the *Creating a generic
    form element generator* recipe of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual display logic is identical to the radio button recipe, except that
    we need to render two separate HTML select instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can see how the elements appear in the *view source* page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a form factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of a form factory is to generate a usable form object from a single
    configuration array. The form object should have the ability to retrieve the individual
    elements it contains so that output can be generated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a class called `Application\Form\Factory` to contain the
    factory code. It will have only one property, `$elements`, with a getter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Before we define the primary form generation method, it's important to consider
    what configuration format we plan to receive, and what exactly the form generation
    will produce. For this illustration, we will assume that the generation will produce
    a `Factory` instance, with an `$elements` property. This property would be an
    array of `Application\Form\Generic` or `Application\Form\Element` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to tackle the `generate()` method. This will cycle through
    the configuration array, creating the appropriate `Application\Form\Generic` or
    `Application\Form\Element\*` objects, which in turn will be stored in the `$elements`
    array. The new method will accept the configuration array as an argument. It is
    convenient to define this method as static so that we can generate as many instances
    as are needed using different blocks of configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create an instance of `Application\Form\Factory`, and then we start looping
    through the configuration array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check for parameters that are optional in the constructor for the
    `Application\Form\Generic` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the constructor parameters are in place, we can create the form
    element instance, which is then stored in `$elements`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we turn our attention to options. If the `options` parameter is set,
    we extract the array values into variables using `list()`. We then test the element
    type using `switch()` and run `setOptions()` with the appropriate number of parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the form object and close out the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Theoretically, at this point, we could easily render the form in our view logic
    by simply iterating through the array of elements and running the `render()` method.
    The view logic might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we return the form object and close out the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to define a discrete `Form` class under `Application\Form\Element`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to the `Application\Form\Factory` class, we now need to define a
    simple method that returns a `sprintf()` wrapper pattern that will serve as an
    envelope for input. As an example, if the wrapper is `div` with an attribute `class="test"`
    we would produce this pattern: `<div class="test">%s</div>`. Our content would
    then be substituted in place of `%s` by the `sprintf()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to define a method that does overall form rendering.
    We obtain wrapper `sprintf()` patterns for each form row. We then loop through
    the elements, render each one, and wrap the output in the row pattern. Next, we
    generate an `Application\Form\Element\Form` instance. We then retrieve the form
    wrapper `sprintf()` pattern and check the `form_tag_inside_wrapper` flag, which
    tells us whether we need to place the form tag inside or outside the form wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referring to the preceding code, create the `Application\Form\Factory` and `Application\Form\Element\Form`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can define a `chap_06_form_factor.php` calling script that sets up
    autoloading and anchors the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next, define the wrappers using the `$wrappers` array defined in the first recipe.
    You can also use the `$statusList` array defined in the second recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See if there is any status input from `$_POST`. Any input will become the selected
    key. Otherwise, the selected key is the default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can define the overall form configuration. The `name` and `attributes`
    parameters are used to configure the `form` tag itself. The other two parameters
    represent form-level and row-level wrappers. Lastly, we provide a `form_tag_inside_wrapper`
    flag to indicate that the form tag should *not* appear inside the wrapper (that
    is, `<table>`). If the wrapper was `<div>`, we would set this flag to `TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define an array that holds parameters for each form element to be created
    by the factory. The array key becomes the name of the form element, and must be
    unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, be sure to generate the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual display logic is extremely simple, as we simply call the form level
    `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the actual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chaining $_POST filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proper filtering and validation is a common problem when processing data submitted
    by users from an online form. It is arguably also the number one security vulnerability
    for a website. Furthermore, it can be quite awkward to have the filters and validators
    scattered all over the application. A chaining mechanism would resolve these issues
    neatly, and would also allow you to exert control over the order in which the
    filters and validators are processed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a little-known PHP function, `filter_input_array()`, that, at first
    glance, seems well suited for this task. Looking more deeply into its functionality,
    however, it soon becomes apparent that this function was designed in the early
    days, and is not up to modern requirements for protection against attack and flexibility.
    Accordingly, we will instead present a much more flexible mechanism based on an
    array of callbacks performing filtering and validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between *filtering* and *validation* is that filtering can potentially
    remove or transform values. Validation, on the other hand, tests data using criteria
    appropriate to the nature of the data, and returns a boolean result.
  prefs: []
  type: TYPE_NORMAL
- en: In order to increase flexibility, we will make our base filter and validation
    classes relatively light. By this, we mean *not* defining any specific filters
    or validation methods. Instead, we will operate entirely on the basis of a configuration
    array of callbacks. In order to ensure compatibility in filtering and validation
    results, we will also define a specific result object, `Application\Filter\Result`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The primary function of the `Result` class will be to hold a `$item` value,
    which would be the filtered value or a boolean result of validation. Another property,
    `$messages`, will hold an array of messages populated during the filtering or
    validation operation. In the constructor, the value supplied for `$messages` is
    formulated as an array. You might observe that both properties are defined `public`.
    This is to facilitate ease of access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define a method that allows us to merge this `Result` instance with
    another. This is important as at some point we will be processing the same value
    through a chain of filters. In such a case, we want the newly filtered value to
    overwrite the existing one, but we want the messages to be merged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to finish the methods for this class, we add a method that merges
    validation results. The important consideration here is that *any* value of `FALSE`,
    up or down the validation chain, must cause the *entire* result to be `FALSE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to make sure that the callbacks produce compatible results, we will define
    an `Application\Filter\CallbackInterface` interface. You will note that we are
    taking advantage of the PHP 7 ability to data type the return value to ensure
    that we are getting a `Result` instance in return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Each callback should reference the same set of messages. Accordingly, we define
    a `Application\Filter\Messages` class with a series of static properties. We provide
    methods to set all messages, or just one message. The `$messages` property has
    been made `public` for easier access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position to define a `Application\Web\AbstractFilter` class
    that implements core functionality. As mentioned previously, this class will be
    relatively *lightweight* and we do not need to worry about specific filters or
    validators as they will be supplied through configuration. We use the `UnexpectedValueException`
    class, provided as part of the PHP 7 **Standard PHP Library** (**SPL**), in order
    to throw a descriptive exception in case one of the callbacks does not implement
    `CallbackInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define useful class constants that hold various *housekeeping* values.
    The last four shown here control the format of messages to be displayed, and how
    to describe *missing* data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define core properties. `$separator` is used in conjunction with filtering
    and validation messages. `$callbacks` represents the array of callbacks that perform
    filtering and validation. `$assignments` map data fields to filters and/or validators.
    `$missingMessage` is represented as a property so that it can be overwritten (that
    is, for multi-language websites). Finally, `$results` is an array of `Application\Filter\Result`
    objects and is populated by the filtering or validation operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can build the `__construct()` method. Its main function is
    to set the array of callbacks and assignments. It also either sets values or accepts
    defaults for the separator (used in message display), and the *missing* message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a series of methods that allow us to set or remove callbacks.
    Notice that we allow the getting and setting of a single callback. This is useful
    if you have a generic set of callbacks, and need to modify just one. You will
    also note that `setOneCall()` checks to see if the callback implements `CallbackInterface`.
    If it does not, an `UnexpectedValueException` is thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods for results processing are quite simple. For convenience, we added
    `getItemsAsArray()`, otherwise `getResults()` will return an array of `Result`
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving messages is just a matter of looping through the array of `$this
    ->results` and extracting the `$messages` property. For convenience, we also added
    `getMessageString()` with some formatting options. To easily produce an array
    of messages, we use the PHP 7 `yield from` syntax. This has the effect of turning
    `getMessages()` into a **delegating generator**. The array of messages becomes
    a **sub-generator**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we define a mixed group of useful getters and setters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Filtering and validation, although often performed together, are just as often
    performed separately. Accordingly, we define discrete classes for each. We''ll
    start with `Application\Filter\Filter`. We make this class extend `AbstractFilter`
    in order to provide the core functionality described previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this class we define a core `process()` method that scans an array of
    data and applies filters as per the array of assignments. If there are no assigned
    filters for this data set, we simply return `NULL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we initialize `$this->results` to an array of `Result` objects where
    the `$item` property is the original value from `$data`, and the `$messages` property
    is an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make a copy of `$this->assignments` and check to see if there are any
    *global* filters (identified by the ''`*`'' key. If so, we run `processGlobal()`
    and then unset the ''`*`'' key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we loop through any remaining assignments, calling `processAssignment()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will recall, each *assignment* is keyed to the data field, and represents
    an array of callbacks for that field. Thus, in `processGlobalAssignment()` we
    need to loop through the array of callbacks. In this case, however, because these
    assignments are *global*, we also need to loop through the *entire* data set,
    and apply each global filter in turn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tricky bit is this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Remember, each callback is actually an anonymous class that defines the PHP
    magic `__invoke()` method. The arguments supplied are the actual data item to
    be filtered, and an array of parameters. By running `$this->callbacks[$callback['key']]()`
    we are in fact magically calling `__invoke()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define `processAssignment()`, in a manner akin to `processGlobalAssignment()`,
    we need to execute each remaining callback assigned to each data key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important that any filtering operation that alters the original user-supplied
    data should display a message indicating that a change was made. This can become
    part of an audit trail to safeguard you against potential legal liability when
    a change is made without user knowledge or consent.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an `Application\Filter` folder. In this folder, create the following
    class files, using code from the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Application\Filter\* class file | Code described in these steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Result.php` | 3 - 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `CallbackInterface.php` | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| `Messages.php` | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| `AbstractFilter.php` | 8 - 15 |'
  prefs: []
  type: TYPE_TB
- en: '| `Filter.php` | 16 - 22 |'
  prefs: []
  type: TYPE_TB
- en: 'Next, take the code discussed in step 5, and use it to configure an array of
    messages in a `chap_06_post_data_config_messages.php` file. Each callback references
    the `Messages::$messages` property. Here is a sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `chap_06_post_data_config_callbacks.php` callback configuration
    file that contains configuration for filtering callbacks, as described in step
    4\. Each callback should follow this generic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The callbacks themselves must implement the interface and return a `Result`
    instance. We can take advantage of the PHP 7 **anonymous class** capability by
    having our callbacks return an anonymous class that implements `CallbackInterface`.
    Here is how an array of filtering callbacks might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For test purposes, we will use the prospects table as a target. Instead of
    providing data from `$_POST`, we will construct an array of *good* and *bad* data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now create a `chap_06_post_data_filtering.php` script that sets up
    autoloading, includes the messages and callbacks configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to define *assignments* that represent a mapping between the
    data fields and filter callbacks. Use the `*` key to define a *global* filter
    that applies to all data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define *good* and *bad* test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can create an `Application\Filter\Filter` instance, and test the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Processing *good* data produces no messages other than one indicating that
    the value for the *float* field was converted from string to `float`. The *bad*
    data, on the other hand, produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will also notice that tags were removed from `first_name`, and that both
    `last_name` and `city` were truncated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter_input_array()` function takes two arguments: the input source (in
    the form of a pre-defined constant used to indicate one of the `$_*` PHP super-globals,
    that is, `$_POST`), and an array of matching field definitions as keys and filters
    or validators as values. This function performs not only filtering operations,
    but validation as well. The flags labeled *sanitize* are actually filters.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation and examples of `filter_input_array()` can be found at [http://php.net/manual/en/function.filter-input-array.php](http://php.net/manual/en/function.filter-input-array.php).
    You might also have a look at the different types of *filters* that are available
    on [http://php.net/manual/en/filter.filters.php](http://php.net/manual/en/filter.filters.php).
  prefs: []
  type: TYPE_NORMAL
- en: Chaining $_POST validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *heavy lifting* for this recipe has already been accomplished in the preceding
    recipe. Core functionality is defined by `Application\Filter\AbstractFilter`.
    The actual validation is performed by an array of validating callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look over the preceding recipe, *Chaining $_POST filters*. We will be using
    all of the classes and configuration files in this recipe, except where noted
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To begin, we define a configuration array of validation callbacks. As with
    the preceding recipe, each callback should implement `Application\Filter\CallbackInterface`,
    and should return an instance of `Application\Filter\Result`. Validators would
    take this generic form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `Application\Filter\Validator` class, which loops through
    the array of assignments, testing each data item against its assigned validator
    callbacks. We make this class extend `AbstractFilter` in order to provide the
    core functionality described previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this class, we define a core `process()` method that scans an array
    of data and applies validators as per the array of assignments. If there are no
    assigned validators for this data set, we simply return the current status of
    `$valid` (which is `TRUE`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we initialize `$this->results` to an array of `Result` objects where
    the `$item` property is set to `TRUE`, and the `$messages` property is an empty
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make a copy of `$this->assignments` and check to see if there are any
    *global* filters (identified by the ''`*`'' key). If so, we run `processGlobal()`
    and then unset the ''`*`'' key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we loop through any remaining assignments, calling `processAssignment()`.
    This is an ideal place to check to see if any fields present in the assignments
    array is missing from the data. Note that we set `$valid` to `FALSE` if any validation
    callback returns `FALSE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As you will recall, each *assignment* is keyed to the data field, and represents
    an array of callbacks for that field. Thus, in `processGlobalAssignment()`, we
    need to loop through the array of callbacks. In this case, however, because these
    assignments are *global*, we also need to loop through the *entire* data set,
    and apply each global filter in turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In contrast to the equivalent `Application\Filter\Fiter::processGlobalAssignment()`
    method, we need to call `mergeValidationResults()`. The reason for this is that
    if the value of `$result->item` is already `FALSE`, we need to ensure that it
    does not subsequently get overwritten by a value of `TRUE`. Any validator in the
    chain that returns `FALSE` must overwrite any other validation result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define `processAssignment()`, in a manner akin to `processGlobalAssignment()`,
    we need to execute each remaining callback assigned to each data key, again calling
    `mergeValidationResults()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the preceding recipe, be sure to define the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application\Filter\Result`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Filter\CallbackInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Filter\Messages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Filter\AbstractFilter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `chap_06_post_data_config_messages.php` file, also described
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a `Validator.php` file in the `Application\Filter` folder. Place
    the code described in step 3 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `chap_06_post_data_config_callbacks.php` callback configuration
    file that contains configurations for validation callbacks, as described in step
    2\. Each callback should follow this generic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create a `chap_06_post_data_validation.php` calling script that
    initializes autoloading and includes the configuration scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define an array of assignments, mapping data fields to validator callback
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'For test data, use the same *good* and *bad* data defined in the `chap_06_post_data_filtering.php`
    file described in the previous recipe. After that, you are in a position to create
    an `Application\Filter\Validator` instance, and test the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the *good* data does not produce any validation errors. The *bad*
    data, on the other hand, generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the *missing* fields, `address` and `state_province` validate `FALSE`,
    and return the missing item message.
  prefs: []
  type: TYPE_NORMAL
- en: Tying validation to a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a form is first rendered, there is little value in having a form class
    (such as `Application\Form\Factory`, described in the previous recipe) tied to
    a class that can perform filtering or validation (such as the `Application\Filter\*`
    described in the previous recipe). Once the form data has been submitted, however,
    interest grows. If the form data fails validation, the values can be filtered,
    and then re-displayed. Validation error messages can be tied to form elements,
    and rendered next to form fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, be sure to implement the classes defined in the *Implementing
    a Form Factory*, *Chaining $_POST Filters*, and *Chaining $_POST Validators* recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now turn our attention to the `Application\Form\Factory` class, and
    add properties and setters that allow us to attach instances of `Application\Filter\Filter`
    and `Application\Filter\Validator`. We also need define `$data`, which will be
    used to retain the filtered and/or validated data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `validate()` method that calls the `process()` method of
    the embedded `Application\Filter\Validator` instance. We check to see if `$data`
    and `$validator` exist. If not, the appropriate exceptions are thrown with instructions
    on which method needs to be run first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling the `process()` method, we associate validation result messages
    with form element messages. Note that the `process()` method returns a boolean
    value that represents the overall validation status of the data set. When the
    form is re-displayed following failed validation, error messages will appear next
    to each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar manner, we define a `filter()` method that calls the `process()`
    method of the embedded `Application\Filter\Filter` instance. As with the `validate()`
    method described in step 3, we need to check for the existence of `$data` and
    `$filter`. If either is missing, we throw a `RuntimeException` with the appropriate
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run the `process()` method, which produces an array of `Result` objects
    where the `$item` property represents the end result of the filter chain. We then
    loop through the results, and, if the corresponding `$element` key matches, set
    the `value` attribute to the filtered value. We also add any messages resulting
    from the filtering process. When the form is then re-displayed, all value attributes
    will display filtered results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can start by making the changes to `Application\Form\Factory` as described
    above. For a test target you can use the prospects database table shown in the
    *How it works...* section of the *Chaining $_POST filters* recipe. The various
    column settings should give you an idea of which form elements, filters, and validators
    to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you can define a `chap_06_tying_filters_to_form_definitions.php`
    file, which will contain definitions for form wrappers, elements, and filter assignments.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the already existing `chap_06_post_data_config_callbacks.php` and
    `chap_06_post_data_config_messages.php` files described in the previous recipes.
    Finally, define a `chap_06_tying_filters_to_form.php` file that sets up autoloading
    and includes these three configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can create instances of the form factory, filter, and validator classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then check to see if there is any `$_POST` data. If so, perform validation
    and filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The view logic is extremely simple: just render the form. Any validation messages
    and values for the various elements will be assigned as part of validation and
    filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example using bad form data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the filtering and validation messages. Also notice the bad tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
