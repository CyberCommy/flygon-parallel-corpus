- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, [Chapter 14](c8355d57-1eb8-4e45-93f5-a32513185de3.xhtml), *CircleCI
    UI Logging and Debugging*, we covered more advanced debugging and logging techniques
    using CircleCI and went over more options using the CircleCI API. In the last
    chapter of the book, we will go over best practices for different types of testing,
    such as unit testing, integration testing, system testing, and acceptance testing.
    We will go over best practices with password management and use the Vault library
    as an example. Lastly, we will go over best practices in deployments in CI/CD
    and write a custom Go script to create a GitHub release.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for different types of testing in CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in password and secrets storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will require some basic programming skills, as we will discuss
    some programming language-specific material in the deployment script and in the
    unit test example as well. It would be very helpful to have some familiarity with
    Unix programming and what a Bash shell is.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for different types of testing in CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml), *Basics of Continuous
    Delivery*, we went over acceptance testing and spoke briefly about how an acceptance
    test suite can serve as a regression test suite. In this section, we will talk
    about different types of software testing that you can do and formulate some best
    practices with each type of test. We will go over the following types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Smoke testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smoke tests are a special kind of test that help verify basic functionality
    in your application. Smoke tests will assume some basic implementation and environmental
    setup. Smoke tests are typically run at the beginning of a test cycle that behave
    as a sanity check before starting a complete test suite.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind a smoke test is to catch glaring problems when working
    on new features in a software system. Smoke tests are not meant to be exhaustive
    but instead are meant to run very quickly. Let's say that a software company follows
    agile software development practices and there are 2 week sprints where new features
    are added to the product. When a new feature is merged into the release, meaning
    the main trunk of the software, a smoke test fails, and this should immediately
    raise a red flag that the new feature may have broken existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You can create smoke tests that are context-specific when testing a new functionality
    in a system that will employ some basic assumptions and that can assert that the
    requirements are being met. You can create smoke tests that are run before any
    integration testing is done and before any deployments are done for staging environments,
    and these smoke tests will check different conditions on each staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Smoke test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use an existing application that I have built that shows a list of
    users in a table. The application is called `containerized-golang-and-vuejs` ([https://github.com/jbelmont/containerized-golang-and-vuejs](https://github.com/jbelmont/containerized-golang-and-vuejs))
    and it shows how to use the containers, Golang and Vue.js for reference purposes.
    The first thing we will do is to make sure that the application is running using
    a `makefile` task called `make dev`. This command does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, this command spins up four Docker containers and, when it is up
    and running, we should be able to hit `http://localhost:8080`. Now, in reality,
    a smoke test would hit a live running application but this is just for demonstration
    purposes for a smoke test. We will use an end-to-end testing library called **Cypress**
    ([https://www.cypress.io/](https://www.cypress.io/)) but we could just as easily
    use another library for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write the following simple smoke test using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about Cypress in the Getting Started ([https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#))
    documents but this test is essentially verifying that the page is loading with
    data and Cypress takes screenshots so we can visually verify the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot that the Cypress library took:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b6cbc20c-13d3-47f2-b58f-97231623e841.png)'
  prefs: []
  type: TYPE_IMG
- en: For this simple application, we can be sure that the application is roughly
    working, but a more complete smoke test may go through a login screen and then
    do a basic action that the application is expected to do.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice feature of Cypress is that it can take videos of the tests showing
    all the steps that the test is taking, which can further verify that the application
    is meeting the basic requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests can be considered the foundation of software testing in that unit
    tests test individual blocks of code, such as a function or a class/object. With
    a unit test, you are testing the functionality of functions and/or classes on
    their own. Because of this fact, unit tests typically stub out or mock out any
    external dependencies so that that the test can focus entirely on the function
    and/or class in question.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are fundamental to testing a system in terms of correctness of behavior
    of individual components. The fact that unit tests are limited in this respect
    means that it is easier to isolate where defects have occurred at. Unit tests
    are often used to test code branches and how a function may handle different types
    of input. Unit tests are typically the first tests that developers will run in
    a build while QA engineers may run smoke tests first and then follow that with
    any unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Individual developers will run unit tests on their workstations prior to submitting
    changes to version control projects, such as GitHub. With that being said, continuous
    integration servers, such as Jenkins, Travis CI, and CircleCI, will run unit tests
    before running any integration tests, as we have seen in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will look at a previous project called `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    that has several unit tests that have been written to test individual functions.
    In the repository, we have a file called `sort.js` that has the following function
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an array of objects and sorts the objects by the `firstName`
    attribute. For our unit test, we simply want to test that the `sortListOfNames`
    function will sort the first name in alphabetical order. Here is the unit test
    that we have written in the `tape.js` ([https://github.com/substack/tape](https://github.com/substack/tape))
    testing library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that the unit test is able to isolate and test only the behavior
    of the `sortListOfNames` function, which is very useful because, if the `sortListOfNames`
    function were to have any issues, we can quickly isolate where the regression
    is occurring. Now, granted this function is very basic and simple, but you can
    see that unit tests serve an important purpose in a continuous integration build's
    job in catching regressions in software.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests will test groups of software components as they work with
    each other. While unit tests can help validate the functionality of a block on
    code in isolation, integration tests help test blocks of code as they interact
    with one another. Integration tests are useful because they can help catch different
    types of issues that arise when software components interact.
  prefs: []
  type: TYPE_NORMAL
- en: While unit tests may be run in a developer's workstation, integration tests
    are usually run when code is checked into source control. A CI server will check
    out the code, perform build steps, and then follow with any smoke tests and then
    run unit tests and then integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Since integration tests are a higher level of abstraction and test software
    components interacting with each other, they help protect the health of a code
    base. When developers introduce new features to a system, the integration tests
    can help ensure that the new code is working with other blocks of code as expected.
    Integration tests can help ensure that new features in a system can safely be
    deployed to an environment. Integration tests are usually the first types of tests
    that are done outside of a developer's workstation and help show whether they
    may be environmental dependency breakages and whether newer code is behaving properly
    with external libraries and external services and/or data.
  prefs: []
  type: TYPE_NORMAL
- en: Integration test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will look at a public API, such as CircleCI, and write an integration test
    that hits the API endpoint and verifies that the status code and the body of the
    request are what we would expect. This would typically be a local API that you
    are working on and want verification of correct behavior but, as an example, we
    will hit the CircleCI for illustration purposes only. We will create a new repository
    in GitHub using our `packtci` user and call it `integration-test-example` ([https://github.com/packtci/integration-test-example](https://github.com/packtci/integration-test-example))[.
    We will use several libraries including `supertest` (](https://github.com/packtci/integration-test-example)[https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest)), 
    a Node.js library, `baloo` ([https://github.com/h2non/baloo](https://github.com/h2non/baloo)),
    a Golang library to hit API endpoints, and , finally, just `curl` and `bash`.
    It does not matter which library that you use; I am using these libraries for
    demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: API testing example using the supertest Node.js library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this integration test example, we hit the `GET /projects` ([https://circleci.com/docs/api/v1-reference/#projects](https://circleci.com/docs/api/v1-reference/#projects))
    endpoint in CircleCI. Here is the code testing this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we test that the endpoint returns a `200` HTTP response and that it has
    a body and that there is an attribute in the array of objects of `oss`.
  prefs: []
  type: TYPE_NORMAL
- en: API testing example with the baloo Golang library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this integration test, we hit the `GET /user` ([https://developer.travis-ci.com/resource/user#User](https://developer.travis-ci.com/resource/user#User))
    endpoint in the Travis API. Here is the code testing this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we test that the response is a `200` and that the body has values.
  prefs: []
  type: TYPE_NORMAL
- en: API testing example with curl, bash, and jq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this integration test example, we will hit `GET: /project/:vcs-type/:username/:project`
    ([https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project)),
    a recent build endpoint in the CircleCI API. Here is the code testing this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we test that we received an `author_name` attribute from the endpoint
    that should be returned in the JSON payload.
  prefs: []
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System tests are typically broader integration tests that extend integration
    tests. System tests will aggregate groups of functionality in an application and
    so are even wider in scope than integration tests. System tests will usually be
    run after integration tests as they are testing larger behaviors in an application
    and will take longer to run.
  prefs: []
  type: TYPE_NORMAL
- en: System test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System tests can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Usability testing**: A type of test that tests the ease of use in the system
    and the overall ability of the system to meet its proposed functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load testing**: A type of test that will measure the behavior of a system
    under real-world load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: A type of test that checks that the system is behaving
    normally whenever newer features are added to a system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other types of system testing but we have only included some common
    types of system tests.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone over acceptance tests throughout the book but, to reiterate, an
    acceptance test is a formal verification of the behavior of an application. Acceptance
    tests will typically be the last types of tests that you will write in a CI/CD
    pipeline as they are longer running and more involved in terms of the verification
    aspect of acceptance tests as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests can also serve as a regression test suite since they provide
    assurances that the application is behaving as it should. There are some libraries
    that use a formal domain-specific language called **Gherkin** ([https://docs.cucumber.io/gherkin/reference/](https://docs.cucumber.io/gherkin/reference/)).
    This has specific files that write down what is called **acceptance criteria. **These
    stipulate what the new feature needs to do and it is not uncommon for a software
    company to write an acceptance test that is failing at the beginning of the sprint
    and that will pass once the acceptance criteria have been met when the feature
    is implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can look at a very simple example of an acceptance test in my repository
    called `cucumber-examples` ([https://github.com/jbelmont/cucumber-examples](https://github.com/jbelmont/cucumber-examples)),
    which has a Gherkin file that checks that our acceptance criteria is met for a
    simple calculator program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice here that the Gherkin syntax is human-readable and is meant to be read
    as a list of declarations for the new functionality. Here, we state that we want
    to be able to do a simple math addition operation and then provide a scenario
    to fulfill this. Here is the code that implements this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is a JavaScript class that does simple addition and here is another
    class that has a list of scenarios that add a list of numbers up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple acceptance test but it is meant to illustrate the fact
    that an acceptance test is a formal verification that the new feature is behaving
    as it is should be.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for running different tests in a CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We described the the following stages in [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml),
    *Basics of Continuous Delivery*:'
  prefs: []
  type: TYPE_NORMAL
- en: The first stage of a CI/CD pipeline will typically encompass a build and commit
    stage. This is where you build any artifacts needed for the rest of the pipeline
    and run your unit test suite in the build. The first stage is meant to be very
    fast running as developers need to have a short feedback loop or else you risk
    developers bypassing this stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second stage of a CI/CD pipeline will typically run integration tests as
    they are longer running types of tests and can be run after the first stage of
    the pipeline runs and passes. The second stage is a layer of assurance that any
    new functionality has broken integrated components of a system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third stage of a CI/CD pipeline might consist of a suite of load tests and
    or regression tests and or security tests and will be much longer running than
    the first two stages of the CI/CD pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth stage can be where the acceptance tests are run, although I have
    personally seen companies that run an acceptance test suite in tandem with integration
    tests and so they only had three stages in their CI/CD pipeline. The stages we
    have laid out in this chapter are not hard and fast rules but merely some suggestions,
    as each application is unique in its behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Best practices in password and secrets storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen throughout the chapters covering Jenkins, Travis CI, and CircleCI,
    each continuous integration server has a way to store secure information such
    as passwords, API keys, and secrets. It is dangerous to run certain actions in
    the CI server, such as execution tracing with Bash by using the `set -x` option
    in Bash. It is better to either use the CI server's functionality to securely
    store passwords and secrets, such as the context settings for each project in
    CircleCI ,which cannot be seen by anyone other than a project owner. You can also
    use a tool such as **Vault** ([https://www.vaultproject.io/intro/index.html](https://www.vaultproject.io/intro/index.html))
    to securely store your passwords and that can be retrieved using a RESTful API
    or use something like the **Amazon Key Management Service** ([https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/)). 
    We will briefly look at using Vault for password needs in a local development
    environment and make calls to Vault's RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Vault installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/))
    can be done at the Install Vault ([https://www.vaultproject.io/intro/getting-started/install.html](https://www.vaultproject.io/intro/getting-started/install.html))
    link. Once you download Vault, you will need to move the single binary into a
    `PATH` that your OS will be able to find. Here is a sample run that I did on my
    local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command will move the binary called `vault` into the `/usr/local/bin` directory
    that is in my path and I should now be able run the `vault` command and see the
    help menu like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba4e906c-281a-493d-a0ad-c8a27fee3ac7.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that the `vault` command has `Common commands` and `Other commands`
    that can be run.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the dev server for Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to run the vault server `-dev` command to start the dev server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3a2506b-8d4c-4052-929a-edb6e6b98f9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that we get a list of instructions to set up our local dev environment.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this is just for demonstration purposes and that the dev mode
    is not meant for a production instance.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the status of the Vault server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, we check the status of the dev Vault server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b65767c5-89fe-4798-b037-13f337dcda02.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing we did was export the `VAULT_ADDR` environment variable in a
    new shell, as we will be using this command, and then we checked the status of
    our dev Vault server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting  an API secret in Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, we set an API secret and then retrieve it with
    Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ae0f090-6fe2-4d41-a498-e5129098b6b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also list out all the secrets in the Vault like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1739eb77-a4b6-48f0-a019-c469a29de376.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Vault RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember that we are running a dev Vault server instance and so we can run
    `curl` as a REST client to the Vault API on our local machine. Let''s us run the
    following `curl` command to check whether our Vault instance has been initialized,
    which it should be at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a file called `config.hcl` in order to bypass TLS defaults
    for Vault with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to unseal the Vault and log in, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8f7a876-40b2-4c9d-8562-c19506f908c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice here that we get a token, which is what we will need to make requests
    to the RESTful API using the following HTTP header: `X-Vault-Token: 3507d8cc-5ca2-28b5-62f9-a54378f3366d`.'
  prefs: []
  type: TYPE_NORMAL
- en: Vault RESTful API endpoint GET /v1/sys/raw/logical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a sample `curl GET` request for the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fc5603a4-a40c-4fa9-bd99-53169818e0b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that we used the token that was printed from the standard output
    after we ran the Vault login `ROOT_KEY` command. This endpoint returns the list
    of keys for the given path, which in this case is `/sys/raw/logical`.
  prefs: []
  type: TYPE_NORMAL
- en: Overall best practices for secrets management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have stated before throughout the book, it is not good practice to commit
    raw passwords and secrets into source control and you will need to have a way
    to safely retrieve passwords when running CI/CD pipelines. You can use the CI
    server itself to store passwords and secrets and then retrieve them using environment
    variables or you can use services such as Vault to securely store your passwords.
    Remember that it can be unsafe to use execution tracing in shell scripts in CI
    environments so be mindful when debugging builds and using the `set -x` flag in
    Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml), *Basics of Continuous
    Delivery*, we went over what a deployment is, explained the deployment pipeline,
    and spoke about test gates in a deployment pipeline. We also spoke about deployment
    scripting and about the deployment ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s highlight some other good strategies when doing deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a deployment checklist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a deployment checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every company will have unique constraints and so it is not possible to create
    a deployment checklist that satisfies the constraints of every company but, in
    general, here are some guidelines that may be helpful throughout all deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration among developers and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There should be communication between the development team and operations to
    properly coordinate a deployment. This is critical because miscommunications are
    bound to happen and so close communication should be happening during a deployment
    to avoid outages and lost of data.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual processes are error-prone and so a deployment should be automated as
    much as possible to avoid human error. Manual processes are not repeatable and
    are not sustainable, as deployments become more complicated. It is better to have
    automation scripts that take human error out of the equation.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment script example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different options in terms of where software can be deployed.
    In this way, a deployment script can vary greatly depending on whether a project
    is open source, private, or enterprise. Many open source projects simply create
    a GitHub release ([https://help.github.com/articles/creating-releases/](https://help.github.com/articles/creating-releases/))
    for each new release and automate the process by using a Bash script. Some companies
    may use **Heroku** ([https://devcenter.heroku.com/start](https://devcenter.heroku.com/start))
    as their provider or some may use **AWS CodeDeploy** ([https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/))
    but, in the end, you want to automate your deployment process so that there is
    a standard and automated way to deploy your software. It is also good to have
    a deployment script that will collate version control commits and be able to display
    new features and bug fixes in each software release.
  prefs: []
  type: TYPE_NORMAL
- en: Automated GitHub release example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the following endpoint in the GitHub API to automate the release
    strategy: `POST /repos/:owner/:repo/releases`. The documentation for  this endpoint
    can be found at [https://developer.github.com/v3/repos/releases/#create-a-release](https://developer.github.com/v3/repos/releases/#create-a-release).
    We will create a Golang script in the `multiple-languages` ([https://github.com/packtci/multiple-languages](https://github.com/packtci/multiple-languages) )
    GitHub repository that will create a new GitHub release.
  prefs: []
  type: TYPE_NORMAL
- en: Golang script example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Golang to make an HTTP request and give the Go script some command-line
    arguments. These will be used to formulate the following `request` body that will
    have the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first part of the deployment script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f6eb61c-5117-4ab1-973e-272dfdf0fed4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this part of the script, we declare our package of `main` and then get some
    command-line arguments that we will need to make our HTTP request. We need to
    parse them and check if they are are set, which is what the `checkArgs` function
    does when it gets called in the `main` function, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85330f7b-a713-4b57-adcb-2b12d9a4527d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in this second part of the script, we are in our `main` function and here
    we parse the command-line arguments and then invoke our `checkArgs` function.
    Next, we create an anonymous struct that we will use to create our `request` body
    and then we set up the HTTP request and set our HTTP headers. In the last part
    of the script, we make our request and print out the release URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e3fac44d-4378-4ea5-bb7d-45ccd0c785d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us show a run in a Terminal session for this deployment script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/638b14c2-3c95-471c-b8d0-21262191a5fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice here that we provided the four command-line arguments after `go run deploy.go`
    and the script printed out a release URL at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go to the Releases tab in the `multiple-languages` ([https://github.com/packtci/multiple-languages/releases](https://github.com/packtci/multiple-languages/releases))
    repository and click on our new release, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50c11e35-f9cc-4b21-8fee-ed1e4925eb47.png)'
  prefs: []
  type: TYPE_IMG
- en: Best practices for a deployment script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to automate the deployment process when releasing new software for
    your consumers. It is not necessary to create a custom deployment script as we
    have done here as their are great libraries that you can use that are more structured
    and feature rich than this small script that we wrote. For example, you can use
    the **GoReleaser** ([https://goreleaser.com/](https://goreleaser.com/)) automation
    release script that works fantastically  for Go projects. There are many libraries
    available that are language-specific as well as options in CI providers, such
    TravisCI ,that will deploy your software to providers, such as the Google App
    Engine ([https://docs.travis-ci.com/user/deployment/google-app-engine/](https://docs.travis-ci.com/user/deployment/google-app-engine/))
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, we covered best practices for different types of tests
    in a CI/CD pipeline, including unit tests, integration tests, system tests, and
    acceptance tests. We provided code examples and showed ways of how to test an
    API endpoint using Node.js, Golang, and a shell script. We covered best practices
    in password management and showed how to use the Vault library to securely manage
    secrets and showed how to use the Vault API. We finished the chapter by showing
    some best practices regarding deployment. We talked about a deployment checklist,
    release automation, and we wrote a custom release script in Golang to create a
    GitHub release.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of the book and I hope that you have learned a lot about CI/CD,
    testing and automation, and using Jenkins CI, CircleCI, and Travis CI.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it important to separate integration tests from unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a commit stage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a type of system test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the name of the password management tool that we used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful with execution tracing in a shell script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one item that we mentioned in the deployment checklist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the name of the deployment tool that we mentioned for Golang?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should check out the book called *Continuous Integration, Delivery, and
    Deployment* ([https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment))
    by Packt Publishing to learn more about best practices with CI/CD.
  prefs: []
  type: TYPE_NORMAL
