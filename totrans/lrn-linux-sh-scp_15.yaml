- en: Parsing Bash Script Arguments with getopts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss the different ways of passing arguments to a
    script, with a special focus on flags. We will start by recapping positional arguments,
    before continuing with arguments passed as flags. After this, we will talk about
    how to use flags in your own scripts using the `getopts` shell builtin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `getopts` and `shift`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Positional parameters versus flags
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getopts` shell builtin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15).
    Follow along with the examples on your Ubuntu Linux virtual machine—no other resources
    are needed. For the single-flag.sh script only the final version is found online.
    Be sure to verify the script version in the header before executing it on your
    system.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Positional parameters versus flags
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start this chapter off with a short recap on positional arguments. As
    you might remember from [Chapter 8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml),
    *Variables and User Input*, we are able to use positional parameters to pass arguments
    to our scripts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this simply, the following syntax is used:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the preceding (fictive) `script.sh`, we can then grab the values supplied
    by the user by looking at the positions the arguments are supplied in: `$1` is
    the first argument, `$2` is the second, and so on. Remember that `$0` is a special
    argument, which relates to the name of the script: in this case, `script.sh`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This approach is relatively simple, but also susceptible to errors. When you
    write this script, you need to check extensively for the input supplied by the
    user; did they give enough arguments, but not too many? Or, perhaps some arguments
    are optional, so a few combinations are possible? All these things need to be
    considered and, if possible, dealt with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the script writer (you!), there is also the burden on the script caller.
    Before they can successfully call your script, they need to be aware of how to
    pass the needed information. For our scripts, we''ve applied two practices which
    are meant to minimize the burden on the user:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Our script header contains a `Usage:` field
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our scripts are called incorrectly, we print an error message with a *usage
    hint* similar/equal to the header
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Still, this approach is error-prone and not always very user-friendly. There
    is another option though: *options*, more commonly known as *flags*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Using flags on the command line
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps you haven''t realized it yet, but most commands you use on the command
    line use a combination of positional arguments and flags. The most basic command
    in Linux, `cd`, uses a single positional argument: the directory you want to move
    to.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'It does actually have two flags that you can use as well: `-L` and `-P`. The
    purpose of these flags is niche and not worth explaining here. Almost all commands
    use both flags and positional arguments complementarily.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'So then, when do we use which? As a rule of thumb, flags are often used for
    *modifiers*, while positional arguments are used for *targets*. A target is simple
    this is: the thing you want to manipulate with the command. In the case of `ls`,
    this means that the positional arguments are the files or directories that should
    be listed (manipulated) by the command.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ls -l /tmp/` command, `/tmp/` is the target, and `-l` is the flag
    used to modify the behavior of `ls`. By default, `ls` lists all files without
    extra information such as ownership, permissions, size, and so on. If we want
    to modify the behavior of `ls`, we add one or more flags: `-l` tells `ls` to use
    the long listing format, which prints each file on its own line, and prints the
    extra information about the file too.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Do note that between `ls /tmp/` and `ls -l /tmp/`, the target does not change,
    but the output does, since we *modified* it with the flag!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Some flags are even more special: they require their own positional argument!
    So not only can we use the flag to modify the command, but the flag itself has
    multiple options for how to modify the command''s behavior.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of this is the `find` command: by default, it finds all files
    within a directory, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, we can use `find` with a positional argument to search not in
    the current working directory, but somewhere else, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, `find` also allows us to use the `-type` flag to only print files of a
    certain type. But by only using the `-type` flag, we have not yet specified what
    file type we want to print. By specifying the file type directly after the flag
    (ordering is *critical* here), we tell the flag what to look for. It looks something
    like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we looked for a type of `d` (directory) within the `/boot/` directory.
    Other arguments to the `-type` flag include `f` (file), `l` (symbolic link), and
    `b` (block device).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, ordering is important, and something like this will happen if you
    do not get it right:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately for us, not all commands are created equal. Some are more forgiving
    on the user, and try their hardest to make sense of what has been given as input.
    Others are much more strict: they will run whatever is passed, even if it does
    not make any functional sense. Always make sure you verify whether you are using
    the command and its modifiers correctly!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples use flags differently to how we'll learn to use them
    with `getopts`. These examples should only serve to illustrate the concepts of
    script arguments, flags, and flags-with-arguments. These implementations are written
    without the use of `getopts` and thus do not map precisely to what we'll be doing
    later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The getopts shell builtin
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the real fun begins! In this second part of this chapter, we'll explain
    the `getopts` shell builtin. The `getopts` command is used in the beginning of
    your script to ***get** the **opt**ion**s*** you supplied in the form of flags.
    It has a very specific syntax that will seem confusing at first, but, once we've
    looked at it fully, it should not be too complicated for you to understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive in, though, we''ll need to discuss two things:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `getopts` and `getopt`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short versus long options
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated, `getopts` is a *shell builtin*. It is available in both the regular
    Bourne shell (`sh`) and in Bash. It originated around 1986, as a replacement for
    `getopt`, which was created sometime before 1980.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to `getopts`, `getopt` is not built into the shell: it is a standalone
    program that has been ported to many different Unix and Unix-like distributions.
    The main differences between `getopts` and `getopt` are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`getopt` does not handle empty flag arguments well; `getopts` does'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getopts` is included in the Bourne shell and Bash; `getopt` needs to be installed
    separately'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getopt` allows for the parsing of long options (`--help` instead of `-h`);
    `getopts` does not'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getopts` has a simpler syntax; `getopt` is more complicated (mainly because
    it is an external program and not a builtin)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the consensus seems to be that for most cases, using `getopts` is
    preferable (unless you really want long options). Since `getopts` is a Bash builtin,
    we'll use it as well, especially since we do not have the need for long options.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Most commands you use on the Terminal have both the short option (which is used
    almost always when interactively working at the Terminal to save time) and the
    long option (which is more descriptive and is more suitable for creating better
    readable scripts). In our experience, short options are more prevalent and, when
    used correctly, more recognizable as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the most common short flags, which do the same to
    most commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`-h`: Prints the help/usage for a command'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Makes the command verbose'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q`: Makes the command quiet'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f <file>`: Passes a file to the <indexentry content="getopts shell builtin,
    flags:-f ">command'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: Performs the operation recursively'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: Runs the command in debug mode'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not assume all commands parse the short flags, as specified previously. While
    this is true for most commands, don't all follow these trends. What is printed
    here has been found from personal experience and should always be verified by
    you before running a command that is new to you. That being said, running a command
    without arguments/flags or with a `-h` will, at least 90% of the time, print the
    correct usage for you to admire.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Even though it would have been nice to have long options available to us for
    our `getopts` scripting, even long options are never a substitute for writing
    readable scripts and creating good hints for the user that is using your script.
    We feel that that's much more important than having long options! Besides, the
    `getopts` syntax is much cleaner than a comparable `getopt`, and adhering to the
    KISS principle is still one of our goals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The getopts syntax
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of spending any more time in this chapter not seeing actual code, we're
    going to jump right in and show a very simple example of a `getopts` script. Of
    course, we'll walk you through step by step so that you have the chance to understand
    it all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The script we''re creating does just a few simple things: if it finds the `-v` flag,
    it prints a *verbose* message, telling us it found the flag. If it does not find
    any flags, it prints nothing. If it finds any other flag, it prints an error for
    the user. Simple, right?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run this script, we''ll see the following happening:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, our script at least works as expected! But why does it work like that?
    Let''s take a look. We''ll skip the header, as that should be very clear by now.
    We''ll start with the `while` line, which contains the `getopts` command and `optstring`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`optstring`, which is likely short for ***opt**ions **string***, tells `getopts`
    which options should be expected. In this case, we expect only `v`. However, we
    start the `optstring` with a colon (`:`), which is a special character for `optstring`
    that sets `getopts` in *silent error reporting* mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Since we prefer to handle error situations ourselves, we will always start our
    `optstring` with a colon. However, feel free to see what happens when you remove
    the colon.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the syntax for `getopts` is pretty simple, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see the command, followed by the `optstring` (which we abstracted to
    a separate variable to improve readability), ending with the name of the variable
    in which we'll store the parsed results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The final, optional, aspect of `getopts` allows us to pass our own set of arguments,
    instead of defaulting to everything passed to the script ($0 through $9). We will
    not be needing/using this in our exercises, but this is definitely good to know.
    As always, because this is a shell builtin, you can find information on it by
    executing `help getopts`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We place this command within a `while` loop so that it iterates over all arguments
    we passed to the script. If there are no more arguments to be parsed by `getopts`,
    it returns an exit status other than `0`, which causes the `while` loop to exit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re inside the loop, though, we''ll hit the `case` statement. As you
    know, the `case` statement is basically better syntax for a longer `if-elif-elif-elif-else`
    statement. In our example script, this looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how the `case` statement ends with the word `esac` (case in reverse).
    For all our defined flags (currently only `-v`), we have a block of code that
    will execute only for that flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The other thing we find when we look at the `${options}` variable (which we
    have because we specified it for *name* in the `getopts` command) is the `?` wildcard.
    We place that at the end of the case statement as a means of catching errors.
    If it hits the `?)` code block, we've presented `getopts` with a flag it does
    not understand. In this case, we print an error and exit the script.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The `done` on the last line ends the `while` loop, and signals that all of our
    flags should have been handled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: It might seem a bit unnecessary to have both an `optstring` and a case for all
    possible options. For now, this is indeed the case, but a bit further on in this
    chapter we'll show you how the `optstring` is used to specify things beyond just
    the letter; at that point, it should be clear why the `optstring` is here. For
    now, don't worry about it too much and just enter the flags in both locations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Multiple flags
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately for us, we do not have to be content with just a single flag: we
    can define many (right up until we run out of alphabet!).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new script that will print a message to the reader. If no flags
    are specified, we'll print a default message. If we encounter either flag `-b`
    or flag `-g`, we'll print a different message, depending on the flag. We'll also
    include instructions for the `-h` flag, which will print a help message when encountered.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'A script with these requirements could look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This script should be readable to you at this point, especially with the included
    comments. From the top, we start with the header and follow up with the `print_help()` function,
    which prints our help message when the `-h` flag is encountered (as we see a few
    lines further on).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `optstring`, which still starts with a colon so that verbose
    errors from `getopts` is turned off (as we will handle this ourselves). In the
    `optstring`, all three flags that we will handle, that is `-b`, `-g`, and `-h`,
    are defined as a single string: `bgh`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of these flags, we have an entry in the `case` statement: for `b)`
    and `g)`, the `gender` variable is set to `boy` or `girl`, respectively. For `h)`,
    the function we defined is called, before calling `exit 0`. (Think about why we
    would do this! If you''re not sure, run the script without the exit.)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: We always end a `getopts` block by handling unknown flags with the `?)` syntax.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, after our `case` statements ends with `esac`, we get to the actual
    functionality. We check whether the `gender` variable is defined: if it is, we
    print a message that contains the value set according to the flag. If it is not
    set (that is the case if neither `-b` and `-g` are specified), we print a generic
    greeting that omits gender.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also why we `exit 0` after we find `-h`: otherwise both the help message
    and the greeting would be given to the user (which is weird, since the user asks
    *just* for the help page with `-h`).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our script in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So far, so good! If we call it with `-h`, we see the multi-line help message
    printed. By default, each `echo` ends with a newline character, so our five echoes
    are printed on five lines. We could have worked with a single `echo` and the `\n`
    characters, but this is more readable
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If we run our script without flags, we'll see the generic greeting. Running
    it with either `-b` or `-g` will give the gender-specific greeting. Wasn't that
    easy?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: It actually was! However, it is about to get a little bit more complicated.
    As we've explained before, users tend to be rather unpredictable, and would perhaps
    use too many flags, or the same flags multiple times.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how our script reacts to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, regardless of how many flags are specified, as long as the script encounters
    the `-h` flag, it will print the help message and exit (due to `exit 0`). For
    your understanding, run the preceding commands in debug with `bash -x` to see
    that they do actually differ, even though the user does not see this (hint: check
    for assignments of `gender=boy` and `gender=girl`).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to an important point: *flags are parsed in the order they are
    supplied by the user!* To further illustrate this point, let''s look at another
    example of a user messing with flags:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user supplies both the `-b` and `-g` flag, both variable assignments
    for gender are performed by the system. However, it seems as though the final
    flag is the one that wins, even though we just stated that the flags are parsed
    in order! Why would that be?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, a nice `bash -x` gives us a good idea of this situation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Initially, the `gender` variable is assigned the value of `boy`. However, when
    the next flag is parsed, the value of the variable is *overwritten with a new
    value*, `girl`. Since the `-g` flag is the final one, the `gender` variable ends
    as `girl`, and thus that is what is printed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in the next part of this chapter, it is possible to supply
    an argument to a flag. For flags without arguments, though, there is a really
    cool feature that many commands use: flag chaining. It might sound complicated,
    but it is actually pretty simple: if you have multiple flags, you can place them
    all behind a single dash.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'For our script, it looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We specified all flags as one bunch: instead of `-b -g -h`, we used `-bgh`.
    As we concluded before, the flags are processed in order, which is still the case
    in our concatenated example (as the debug instruction clearly shows). This is
    not much different to an `ls -al`, for example. Again, this only works if a flag
    does not have an argument.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Flags with arguments
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an `optstring`, the colon has an extra meaning beyond turning off verbose
    error logging: when placed after a letter, it signals to `getopts` that an *option
    argument* is expected.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at our first example, the `optstring` was simply `:v`. If we
    wanted the `-v` flag to accept an argument, we would place a colon behind the
    `v`, which would result in the following `optstring`: `:v:`. We can then use a
    special variable we''ve seen before, `OPTARG`, to grab that ***opt**ion **arg**ument*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll make a revision to our `single-flag.sh` script to show you how this
    works:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The changed lines have been highlighted for your convenience. By adding a colon
    to the `optstring` and using the `OPTARG` variable in the `v)` block, we now see
    the following behavior when running the script:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, as long as we supply the flag and flag argument, our script
    works just fine. We do not even need a space between the flag and flag argument;
    since `getopts` knows an argument is expected, it can handle either a space or
    no space. We'd always recommend including the space in any case, to ensure readability,
    but it is not technically needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, this proves why we need a separate `optstring`: the `case` statement
    is the same, but `getopts` now expects an argument, something we could not have
    done if the creators had omitted the `optstring`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all things that seem too good to be true, this is one of those situations.
    While it works fine if the user is nice to your script, if he/she is not, the
    following might happen:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we've told `getopts` to expect an argument to the `-v` flag, it will
    actually not correctly identify the flag if there is no argument. An empty argument,
    as denoted by the `''` in the second script call, is fine, however. (Technically
    fine, that is, since no user would ever do that.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a solution for this—the `:)` block, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It might be a little confusing that both a wrong flag and a missing option argument
    are resolved as the `OPTARG`. Without making this situation more complicated than
    it has to be, it all depends on whether the `case` statement block contains `?)`
    or `:)` at that moment. For `?)` blocks, everything that is not recognized (the
    whole flag) is seen as the option argument, and `:)` blocks only trigger when
    the `optstring` contains the proper instruction for an option with an argument.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything should work just as intended now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, because of the sequential processing of flags, the final call never gets
    to the `-v` flag due to the `exit 1` in the `?)` block. However, all other situations
    are now properly resolved. Nice!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The actual processing that `getopts` does involves multiple passes and the use
    of `shift`. This is a little too technical for this chapter, but for those curious
    among you, the *Further reading* section includes a *very* in-depth explanation
    of this mechanism that you can read at your leisure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Combining flags with positional arguments
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to combine positional arguments (in the way we''ve been using
    them before this chapter) with options and option arguments. There are some things
    to consider in this scenario:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: By default, Bash recognizes flags such as `-f` as positional parameters
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as there is an order to flags and flag arguments, there is an order for
    flags and positional parameters
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with a mix of `getopts` and positional arguments, the *flags and
    flag options should always be provided before the positional arguments! *This
    is because we want to parse and handle all flags and flag arguments before we
    get to the positional parameters. This is a fairly typical scenario for both scripts
    and command-line tools, but it is still something we have to consider.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding points are best illustrated with an example, as always.
    We''re going to create a simple script that serves as a wrapper for common file
    operations. With this script, `file-tool.sh`, we will be able to do the following
    things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: List a file (default behavior)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a file (with the `-d` option)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty a file (with the `-e` option)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename a file (with the `-m` option, which includes another filename)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the help function (with `-h`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the script:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's a big one, isn't it? We've shortened it just a little bit by compacting
    multiple lines into single lines (within the `case` statement), but it's still
    not a short script. While it might seem intimidating at first, we're sure that
    with your exposure up until now, and the comments in the script, this should be
    understandable to you. If it is not fully understandable just yet, don't worry—we're
    going to explain all the new and interesting lines now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re skipping the header, the `print_help()` function, and the default command
    of `ls -l`. The first interesting bit will be the `optstring`, which now contains
    options with and without option arguments:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we get to the `m)` block, we save the option argument in the `new_filename` variable
    for later use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re done with the `case` statement for `getopts`, we run into a command
    that we''ve briefly seen before: `shift`. This command allows us to move our positional
    arguments around: if we do `shift 2`, the argument `$4` becomes `$2`, the argument `$3`
    becomes `$1`, and the old `$1` and `$2` are removed.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with a positional parameter behind flags, all flags and flag arguments
    are seen as positional arguments as well. In this case, if we call the script
    as `file-tool.sh -m newfile /tmp/oldfile`, the following will be interpreted by
    Bash:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`$1`: Interpreted as `-m`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2`: Interpreted as a new file'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$3`: Interpreted as `/tmp/oldfile`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, `getopts` saves the options (and option arguments) it has processed
    in a variable: `$OPTIND` (from ***opt**ions **ind**ex*). To be even more precise,
    after it has parsed an option, it sets `$OPTIND` to the next possible option or
    option argument: it starts at 1 and ends when it finds the first non-option argument
    passed to the script.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, once `getopts` reaches our positional parameter of `/tmp/oldfile`,
    the `$OPTIND` variable will be `3`. Since we just need to `shift` everything before
    that point away, we subtract 1 from the `$OPTIND`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember, `$(( ... ))` is shorthand for arithmetic; the resulting number is
    used in the `shift` command. The rest of the script is pretty straightforward:
    we''ll do some checks to ensure we only have one positional parameter left (the
    filename of the file that we want to manipulate), and whether we have write permissions
    on that file.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Next, depending on which operations we have selected, we'll either do a complex
    one for the `mv`, or a simple one for all the others. For the rename command,
    we'll use a bit of command substitution to determine the directory name of the
    original filename, which we will then reuse in the rename.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If we did our tests like we should, the script should be fully functional with
    all the requirements we set out. We encourage you to give it a try.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, see if you can come up with a situation that we have not thought
    of that breaks the script''s functionality. If you do find something (spoiler
    alert: we know of a few shortcomings!), try to fix them yourself.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As you may start to realize, we're entering territory in which it is very hard
    to harden scripts for every user input. For example, in the last example, if we
    supply the `-m` option but omit the content, the filename we supply will be seen
    as the option argument. In this case, instead of throwing an error for a missing
    option argument, our script will `shift` the filename away and complain that it
    doesn't have it. While this script should serve for educational purposes, it is
    not something that we would trust for our workplace scripting. It is often better
    not to mix `getopts` with positional arguments, as you would avoid many of the
    complexities we've faced here. Just have the user supply the filename as another
    option argument (`-f`, anyone?) and you'll be much happier!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with a recap of how positional parameters are used in Bash.
    We continued by showing you how most command-line tools we've introduced up until
    this point (and those we haven't) use flags, often as *modifiers* for script functionality,
    whereas positional parameters are used to indicate *targets* for the commands.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We then introduced a way for the reader to incorporate options and option arguments
    within their own scripts: by using the `getopts` shell builtin. We kicked this
    off by discussing the differences between the legacy program `getopt` and the
    newer builtin `getopts`, which we focused on for the rest of this chapter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Since `getopts` only allows us to use short options (whereas `getopt` and some
    other command-line tools also use long options, denoted by double dashes), we
    showed you how this is not an issue due to the recognition of common short options
    such as `-h`, `-v`, and so on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We properly introduced the `getopts` syntax with a few examples. We showed how
    you can use flags with and without flag arguments, and how we need an `optstring`
    to signal to `getopts` which options have arguments (and which options to even
    expect).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter by showing you how options and option arguments could
    be combined with positional parameters by cleverly using the `shift` command to
    deal with this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `getopts` and `shift`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are flags often used as modifiers whereas positional parameters are used
    as targets?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we run `getopts` in a `while` loop?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在`while`循环中运行`getopts`？
- en: Why do we need `?)` in the `case` statement?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在`case`语句中需要`?)`？
- en: Why do we (sometimes) need `:)` in the `case` statement?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们（有时）在`case`语句中需要`:)`？
- en: Why do we need a separate `optstring` if we're resolving all options anyway?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们无论如何都要解析所有选项，为什么还需要一个单独的`optstring`？
- en: Why do we need to subtract 1 from the `OPTIND` variable when we use it in `shift`?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在使用`shift`时需要从`OPTIND`变量中减去1？
- en: Is it a good idea to mix options with positional arguments?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项与位置参数混合使用是个好主意吗？
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Pleas refer to the following links for more information on the topics in this
    chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解本章主题的更多信息：
- en: 'Bash-hackers on `getopts`: [http://wiki.bash-hackers.org/howto/getopts_tutorial](http://wiki.bash-hackers.org/howto/getopts_tutorial)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash-hackers对`getopts`的解释：[http://wiki.bash-hackers.org/howto/getopts_tutorial](http://wiki.bash-hackers.org/howto/getopts_tutorial)
- en: '`getopts` in depth: [https://www.computerhope.com/unix/bash/getopts.htm](https://www.computerhope.com/unix/bash/getopts.htm)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解`getopts`：[https://www.computerhope.com/unix/bash/getopts.htm](https://www.computerhope.com/unix/bash/getopts.htm)
