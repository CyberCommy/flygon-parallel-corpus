- en: Chapter 2. Understanding the Concurrency Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a sense of what Go is capable of and how to test drive some
    concurrency models, we need to look deeper into Go's most powerful features to
    understand how to best utilize various concurrent tools and models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We played with some general and basic goroutines to see how we can run concurrent
    processes, but we need to see how Go manages scheduling in concurrency before
    we get to communication between channels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the working of goroutines
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, you should be well-versed in what goroutines do, but it's worth
    understanding *how* they work internally in Go. Go handles concurrency with cooperative
    scheduling, which, as we mentioned in the previous chapter, is heavily dependent
    on some form of blocking code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The most common alternative to cooperative scheduling is preemptive scheduling,
    wherein each subprocess is granted a space of time to complete and then its execution
    is paused for the next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Without some form of yielding back to the main thread, execution runs into issues.
    This is because Go works with a single process, working as a conductor for an
    orchestra of goroutines. Each subprocess is responsible to announce its own completion.
    As compared to other concurrency models, some of which allow for direct, named
    communication, this might pose a sticking point, particularly if you haven't worked
    with channels before.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: You can probably see a potential for deadlocks given these facts. In this chapter,
    we'll discuss both the ways Go's design allows us to manage this and the methods
    to mitigate issues in applications wherein it fails.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous versus asynchronous goroutines
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the concurrency model is sometimes an early pain point for programmers—not
    just for Go, but across languages that use different models as well. Part of this
    is due to operating in a *black box* (depending on your terminal preferences);
    a developer has to rely on logging or errors with data consistency to discern
    asynchronous and/or multiple core timing issues.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: As the concepts of synchronous and asynchronous or concurrent and nonconcurrent
    tasks can sometimes be a bit abstract, we will have a bit of fun here in an effort
    to demonstrate all the concepts we've covered so far in a visual way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, a myriad of ways to address feedback and logging. You
    can write to files in `console/terminal/stdout…`, most of which are inherently
    linear in nature. There is no concise way to represent concurrency in a logfile.
    Given this and the fact that we deal with an emerging language with a focus on
    servers, let's take a different angle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply outputting to a file, we'll create a visual feedback that
    shows when a process starts and stops on a timeline.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Designing the web server plan
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show how approaches differ, we'll create a simple web server that loops through
    three trivial tasks and outputs their execution marks on an X-second timeline.
    We'll do this using a third-party library called `svgo` and the built-in `http`
    package for Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s grab the `svgo` library via `go get`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you try to install a package via the `go get` command and get an error about
    `$GOPATH` not being set, you need to set that environment variable. `GOPATH` is
    where Go will look to find installed import packages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this in Linux (or Mac), type the following in bash (or Terminal):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This path is up to you, so pick a place where you're most comfortable storing
    your Go packages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To ensure it's globally accessible, install it where your Go binary is installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, you can right-click on **My Computer** and navigate to **Properties**
    | **Advanced system settings** | **Environment Variables…**, as shown in the following
    screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the web server plan](img/00005.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Here, you''ll need to create a new variable called `GOPATH`. As with the Linux
    and Mac instructions, this can either be your Go language root directory or someplace
    else entirely. In this example, we''ve used `C:\Go`, as shown in the following
    screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您需要创建一个名为`GOPATH`的新变量。与Linux和Mac的说明一样，这可以是您的Go语言根目录，也可以是完全不同的地方。在本例中，我们使用了`C:\Go`，如下截图所示：
- en: '![Designing the web server plan](img/00006.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设计Web服务器计划](img/00006.jpeg)'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that after taking these steps, you may need to reopen the Terminal, Command
    Prompt, or bash sessions before the value is read as valid. On *nix systems, you
    can log in and log out to initiate this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在执行这些步骤后，您可能需要重新打开终端、命令提示符或bash会话，以便值被视为有效。在*nix系统上，您可以登录和注销以启动此操作。
- en: Now that we have installed gosvg, we can visually demonstrate how the asynchronous
    and synchronous processes will look side-by-side as well as with multiple processors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了gosvg，我们可以直观地演示异步和同步进程并排以及多个处理器的外观。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More libraries**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多库**'
- en: 'Why SVG? We didn''t need to use SVG and a web server, of course, and if you''d
    rather see an image generated and open that separately, there are other alternatives
    to do so. There are some additional graphical libraries available for Go, which
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用SVG？当然，我们不需要使用SVG和Web服务器，如果您更愿意看到生成的图像并单独打开它，还有其他替代方法可以做到这一点。Go还有一些其他可用的图形库，如下所示：
- en: '**draw2d**: As the name suggests, this is a two-dimensional drawing library
    for doing vector-style and raster graphics, which can be found at [https://code.google.com/p/draw2d/](https://code.google.com/p/draw2d/).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**draw2d**：顾名思义，这是一个用于进行矢量风格和光栅图形的二维绘图库，可以在[https://code.google.com/p/draw2d/](https://code.google.com/p/draw2d/)找到。'
- en: '**graphics-go**: This project involves some members of the Go team itself.
    It''s fairly limited in scope. You can find more about it at [https://code.google.com/p/graphics-go/](https://code.google.com/p/graphics-go/).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**graphics-go**：这个项目涉及Go团队的一些成员。它的范围相当有限。您可以在[https://code.google.com/p/graphics-go/](https://code.google.com/p/graphics-go/)找到更多信息。'
- en: '**go:ngine**: This is one of the few OpenGL implementations for Go. It can
    be overkill for this project, but if you find yourself in need of a three-dimensional
    graphics library, start at [http://go-ngine.com/](http://go-ngine.com/).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**go:ngine**：这是为Go设计的少数OpenGL实现之一。对于这个项目来说可能有些过度，但如果您发现自己需要一个三维图形库，可以从[http://go-ngine.com/](http://go-ngine.com/)开始。'
- en: '**Go-SDL**: Another possible overkill method, this is an implementation of
    the wonderful multimedia library SDL. You can find more about it at [https://github.com/banthar/Go-SDL](https://github.com/banthar/Go-SDL).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go-SDL**：另一种可能过度的方法，这是一个实现了出色的多媒体库SDL的项目。您可以在[https://github.com/banthar/Go-SDL](https://github.com/banthar/Go-SDL)找到更多信息。'
- en: Robust GUI toolkits are also available, but as they were designed as systems
    languages, it isn't really Go's forte.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些强大的GUI工具包可用，但由于它们是作为系统语言设计的，这并不是Go的长处。
- en: Visualizing concurrency
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化并发
- en: Our first attempt at visualizing concurrency will have two simple goroutines
    running the `drawPoint` function in a loop with 100 iterations. After running
    this, you can visit `localhost:1900/visualize` and see what concurrent goroutines
    look like.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对可视化并发的第一次尝试将有两个简单的goroutines在循环中运行`drawPoint`函数，循环100次。运行后，您可以访问`localhost:1900/visualize`，看看并发goroutines的样子。
- en: If you run into problems with port 1900 (either with your firewall or through
    a port conflict), feel free to change the value on line 99 in the `main()` function.
    You may also need to access it through `127.0.0.1` if your system doesn't resolve
    localhost.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在端口1900上遇到问题（无论是防火墙还是端口冲突），请随意在`main()`函数的第99行更改该值。如果您的系统无法解析localhost，则可能还需要通过`127.0.0.1`访问它。
- en: 'Note that we''re not using `WaitGroup` or anything to manage the end of the
    goroutines because all we want to see is a visual representation of our code running.
    You can also handle this with a specific blocking code or `runtime.Gosched()`,
    as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有使用`WaitGroup`或任何其他东西来管理goroutines的结束，因为我们只想看到我们的代码运行的可视化表示。您也可以使用特定的阻塞代码或`runtime.Gosched()`来处理这个问题，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you go to `localhost:1900/visualize`, you should see something like the
    following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`localhost:1900/visualize`时，您应该看到类似以下截图的内容：
- en: '![Visualizing concurrency](img/00007.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00007.jpeg)'
- en: 'As you can see, everything is definitely running concurrently—our briefly sleeping
    goroutines hit on the timeline at the same moment. By simply forcing the goroutines
    to run in a serial fashion, you''ll see a predictable change in this behavior.
    Remove the goroutine call on line 73, as shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一切肯定是同时运行的——我们短暂休眠的goroutines在同一时刻命中时间轴。通过简单地强制goroutines以串行方式运行，您将看到这种行为的可预测变化。如下所示，删除第73行的goroutine调用：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To keep our demonstration clean, change line 77 to indicate that there are
    no goroutines as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的演示清晰，将第77行更改为指示没有goroutines，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we stop our server and restart with `go run`, we should see something like
    the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们停止服务器并使用`go run`重新启动，我们应该看到类似以下截图的内容：
- en: '![Visualizing concurrency](img/00008.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00008.jpeg)'
- en: Now, each process waits for the previous process to complete before beginning.
    You can actually add this sort of feedback to any application if you run into
    problems with syncing data, channels, and processes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个进程在开始之前都会等待前一个进程完成。如果您在同步数据、通道和进程的同步方面遇到问题，您实际上可以向任何应用程序添加这种反馈。
- en: If we so desired, we could add some channels and show communication across them
    as represented. Later, we will design a self-diagnosing server that gives real-time
    analytics about the state and status of the server, requests, and channels.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以添加一些通道，并显示它们之间的通信。稍后，我们将设计一个自我诊断服务器，实时提供有关服务器、请求和通道状态的分析。
- en: 'If we turn the goroutine back on and increase our maximum available processors,
    we''ll see something similar to the following screenshot, which is not exactly
    the same as our first screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新启动goroutine并增加最大可用处理器，我们将看到类似于以下截图的内容，这与我们的第一个截图并不完全相同：
- en: '![Visualizing concurrency](img/00009.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00009.jpeg)'
- en: Your mileage will obviously vary depending on server speeds, the number of processors,
    and so on. But in this case, our change here resulted in a faster total execution
    time for our two processes with intermittent sleeps. This should come as no surprise,
    given we have essentially twice the bandwidth available to complete the two tasks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您的里程数会根据服务器速度、处理器数量等而有所不同。但在这种情况下，我们的更改导致了两个具有间歇性休眠的进程的更快总执行时间。这应该不足为奇，因为我们基本上有两倍的带宽可用来完成这两个任务。
- en: RSS in action
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSS的实际应用
- en: Let's take the concept of **Rich Site Summary** / **Really Simple Syndication**
    (**RSS**) and inject some real potential delays to identify where we can best
    utilize goroutines in an effort to speed up execution and prevent blocking code.
    One common way to bring real-life, potentially blocking application elements into
    your code is to use something involving network transmission.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以**Rich Site Summary** / **Really Simple Syndication** (**RSS**)的概念为基础，并注入一些真正的潜在延迟，以确定我们在哪里可以最好地利用goroutines来加快执行速度并防止阻塞代码。将真实生活中可能阻塞应用程序元素引入您的代码的一种常见方式是使用涉及网络传输的内容。
- en: This is also a great place to look at timeouts and close channels to ensure
    that our program doesn't fall apart if something takes too long.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的地方，可以查看超时和关闭通道，以确保我们的程序不会在某些操作花费太长时间时崩溃。
- en: To accomplish both these requirements, we'll build a very basic RSS reader that
    will simply parse through and grab the contents of five RSS feeds. We'll read
    each of these as well as the provided links on each, and then we'll generate an
    SVG report of the process available via HTTP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这两个要求，我们将构建一个非常基本的RSS阅读器，它将简单地解析并获取五个RSS源的内容。我们将读取每一个源以及每个源上提供的链接，然后我们将通过HTTP生成一个SVG报告。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is obviously an application best suited for a background task—you'll notice
    that each request can take a long time. However, for graphically representing
    a real-life process working with and without concurrency, it will work, especially
    with a single end user. We'll also log our steps to standard output, so be sure
    to take a look at your console as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个最适合作为后台任务的应用程序——您会注意到每个请求可能需要很长时间。但是，为了以图形方式表示与并发和无并发的真实生活过程，它将起作用，特别是对于单个最终用户。我们还将将我们的步骤记录到标准输出中，所以一定要查看您的控制台。
- en: 'For this example, we''ll again use a third-party library, although it''s entirely
    possible to parse RSS using Go''s built-in XML package. Given the open-ended nature
    of XML and the specificity of RSS, we''ll bypass them and use `go-pkg-rss` by
    Jim Teeuwen, available via the following `go get` command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将再次使用第三方库，尽管完全可以使用Go的内置XML包来解析RSS。鉴于XML的开放性和RSS的特定性，我们将绕过它们，使用Jim Teeuwen的`go-pkg-rss`，可以通过以下`go
    get`命令获取：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this package is specifically intended as a replacement for the Google
    Reader product, which means that it does interval-based polling for new content
    within a set collection of sources, it also has a fairly neat and tidy RSS reading
    implementation. There are a few other RSS parsing libraries out there, though,
    so feel free to experiment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个包专门用作Google Reader产品的替代品，这意味着它会在一组来源中对新内容进行基于间隔的轮询，但它也有一个相当整洁的RSS阅读实现。虽然还有一些其他的RSS解析库，但是请随意尝试。
- en: An RSS reader with self diagnostics
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带自我诊断功能的RSS阅读器
- en: 'Let''s take a look at what we''ve learned so far, and use it to fetch and parse
    a set of RSS feeds concurrently while returning some visual feedback about the
    process in an internal web browser, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们迄今为止学到的东西，并利用它来同时获取和解析一组RSS源，同时在内部Web浏览器中返回有关该过程的一些可视化反馈，如下所示的代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the basis of our feed''s overall structure: we have a `url` variable
    that represents the feed''s location, a `status` variable to indicate whether
    it''s started, and a `complete` Boolean variable to indicate it''s finished. The
    next piece is an individual `FeedItem`; here''s how it can be laid out:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们源的整体结构的基础：我们有一个代表源位置的`url`变量，一个表示它是否已启动的`status`变量，以及一个表示它是否已完成的`complete`布尔变量。下一个部分是一个单独的`FeedItem`；以下是它的布局方式：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meanwhile, we will not do much with individual items; at this point, we simply
    maintain a URL, whether it's complete or a `FeedItem` struct's index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们不会对单个项做太多处理；在这一点上，我们只是维护一个URL，无论它是完整的还是`FeedItem`结构体的索引。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `grabFeed()` method directly controls the flow of grabbing any individual
    feed. It also bypasses potential concurrent duplication through the `WaitGroup`
    struct. Next, let''s check out the `itemsHandler` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`grabFeed()`方法直接控制抓取任何单个源的流程。它还通过`WaitGroup`结构绕过了潜在的并发重复。接下来，让我们看看`itemsHandler`函数：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `itemsHandler` function doesn''t do much at this point, other than instantiating
    a new `FeedItem` struct—in the real world, we''d take this as the next step and
    retrieve the values of the items themselves. Our next step is to look at the process
    that grabs individual feeds and marks the time taken for each one, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemsHandler`函数目前并没有做太多事情，除了实例化一个新的`FeedItem`结构体——在现实世界中，我们会将这作为下一步，并检索这些项本身的值。我们的下一步是查看抓取单个feed并标记每个feed所花费的时间的过程，如下所示：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we retrieve the RSS feed and mark points on our SVG with the status of
    our retrieval and read events. Our `main()` function will primarily handle the
    setup of feeds, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取RSS源并在我们的SVG上标记我们的检索和读取事件的状态。我们的`main()`函数主要处理源的设置，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is our slice of `FeedItem` structs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`FeedItem`结构体的切片：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the print version, these colors may not be particularly useful, but testing
    it on your system will allow you to delineate between events inside the application.
    We''ll need an HTTP route to act as an endpoint; here''s how we''ll set that up:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印版本中，这些颜色可能并不特别有用，但在您的系统上测试它将允许您区分应用程序内部的事件。我们需要一个HTTP路由作为终点；以下是我们将如何设置它：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When run, you should see the start and duration of the RSS feed retrieval and
    parsing, followed by a thin line indicating that the feed has been parsed and
    all items read.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，您应该看到RSS feed检索和解析的开始和持续时间，然后是一条细线，表示该feed已被解析并且所有项已被读取。
- en: 'Each of the three blocks expresses the full time to process each feed, demonstrating
    the nonconcurrent execution of this version, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 三个块中的每一个都表达了处理每个feed的全部时间，展示了这个版本的非并发执行，如下面的屏幕截图所示：
- en: '![An RSS reader with self diagnostics](img/00010.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![带有自我诊断功能的RSS阅读器](img/00010.jpeg)'
- en: 'Note that we don''t do anything interesting with the feed items, we simply
    read the URL. The next step will be to grab the items via HTTP, as shown in the
    following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对feed项并没有做任何有趣的事情，我们只是读取URL。下一步将是通过HTTP获取这些项，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this example, we stop at every step to provide some sort of feedback to
    the SVG that some event has occurred. Our channel here is buffered and we explicitly
    state that it must receive three Boolean messages before it can finish blocking,
    as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们在每一步都停下来向SVG提供某种反馈，告诉它发生了某种事件。我们的通道在这里是有缓冲的，我们明确声明它必须在完成阻塞之前接收三条布尔消息，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By giving `3` as the second parameter in our channel invocation, we tell Go
    that this channel must receive three responses before continuing the application.
    You should use caution with this, though, particularly in setting things explicitly
    as we have done here. What if one of the goroutines never sent a Boolean across
    the channel? The application would crash.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的通道调用中给出`3`作为第二个参数，我们告诉Go这个通道必须在继续应用程序之前接收三个响应。不过，您应该谨慎使用这个功能，特别是在明确设置事物时。如果其中一个goroutine从未通过通道发送布尔值会怎么样？应用程序会崩溃。
- en: Note that we also increased our timeline here, from 800ms to 60 seconds, to
    allow for retrieval of all feeds. Keep in mind that if our script exceeds 60 seconds,
    all actions beyond that time will occur outside of this visual timeline representation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里还增加了我们的时间轴，从800毫秒增加到60秒，以便检索所有的feeds。请记住，如果我们的脚本超过60秒，那么超过这个时间的所有操作都将发生在这个可视时间轴表示之外。
- en: 'By implementing the `WaitGroup` struct while reading feeds, we impose some
    serialization and synchronization to the application. The second feed will not
    start until the first feed has completed retrieving all URLs. You can probably
    see where this might introduce some errors going forward:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在读取feeds时实现`WaitGroup`结构，我们对应用程序施加了一些串行化和同步。第二个feed将在第一个feed完成检索所有URL之前不会开始。您可能会看到这可能会引入一些错误：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tells our application to yield until we set the `Done()` command from the
    `itemsHandler()` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的应用程序要等到我们从`itemsHandler()`函数中设置`Done()`命令为止。
- en: So what happens if we remove `WaitGroups` entirely? Given that the calls to
    grab the feed items are asynchronous, we may not see the status of all of our
    RSS calls; instead, we might see just one or two feeds or no feed at all.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们完全删除`WaitGroups`会发生什么？考虑到抓取feed项的调用是异步的，我们可能看不到所有的RSS调用的状态；相反，我们可能只看到一个或两个feeds，或者根本没有feed。
- en: Imposing a timeout
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强加超时
- en: So what happens if nothing runs within our timeline? As you might expect, we'll
    get three bars with no activity in them. It's important to consider how to kill
    processes that aren't doing what we expect them to. In this case, the best method
    is a timeout. The `Get` method in the `http` package does not natively support
    a timeout, so you'll have to roll your own `rssFeed.Fetch` (and underlying `http.Get()`)
    implementation if you want to prevent these requests from going into perpetuity
    and killing your application. We'll dig into this a bit later; in the mean time,
    take a look at the `Transport` struct, available in the core `http` package at
    [http://golang.org/pkg/net/http/#Transport](http://golang.org/pkg/net/http/#Transport).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果在我们的时间轴内没有运行任何东西会发生什么？正如您所期望的那样，我们将得到三个没有任何活动的条形图。重要的是要考虑如何终止那些没有按我们期望的方式运行的进程。在这种情况下，最好的方法是超时。`http`包中的`Get`方法并不原生支持超时，因此如果您想要防止这些请求永无止境地进行并杀死您的应用程序，您将不得不自己编写`rssFeed.Fetch`（和底层的`http.Get()`）实现。我们稍后会深入探讨这一点；与此同时，看一下核心`http`包中可用的`Transport`结构，网址为[http://golang.org/pkg/net/http/#Transport](http://golang.org/pkg/net/http/#Transport)。
- en: A little bit about CSP
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于CSP的一点说明
- en: We touched on CSP briefly in the previous chapter, but it's worth exploring
    a bit more in the context of how Go's concurrency model operates.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中简要介绍了CSP，但在Go的并发模型操作方式的背景下，值得更深入地探讨一下。
- en: CSP evolved in the late 1970s and early 1980s through the work of Sir Tony Hoare
    and is still in the midst of evolution today. Go's implementation is heavily based
    on CSP, but it neither entirely follows all the rules and conventions set forth
    in its initial description nor does it follow its evolution since.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CSP在20世纪70年代末和80年代初通过Tony Hoare爵士的工作发展起来，至今仍在不断发展中。Go的实现在很大程度上基于CSP，但它既不完全遵循初始描述中设定的所有规则和惯例，也不遵循其自那时以来的发展。
- en: One of the ways in which Go differs from true CSP is that as it is defined,
    a process in Go will only continue so long as there exists a channel ready to
    receive from that process. We've already encountered a couple of deadlocks that
    were the result of a listening channel with nothing to receive. The inverse is
    also true; a deadlock can result from a channel continuing without sending anything,
    leaving its receiving channel hanging indefinitely.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is endemic to Go's scheduler, and it should really only pose problems
    when you're working with channels initially.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hoare's original work is now available (mostly) free from a number of institutions.
    You can read, cite, copy, and redistribute it free of charge (but not for commercial
    gain). If you want to read the whole thing, you can grab it at [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The complete book itself is also available at [http://www.usingcsp.com/cspbook.pdf](http://www.usingcsp.com/cspbook.pdf).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: As of this publishing, Hoare is working as a researcher at Microsoft.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: As per the designers of the application itself, the goal of Go's implementation
    of CSP concepts was to focus on simplicity—you don't have to worry about threads
    or mutexes unless you really want to or need to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The dining philosophers problem
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have heard of the dining philosophers problem, which describes the
    kind of problems concurrent programming was designed to solve. The dining philosophers
    problem was formulated by the great Edsger Dijkstra. The crux of the problem is
    a matter of resources—five philosophers sit at a table with five plates of food
    and five forks, and each can only eat when he has two forks (one to his left and
    another to his right). A visual representation is shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![The dining philosophers problem](img/00011.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: With a single fork on either side, any given philosopher can only eat when he
    has a fork in both hands and must put both back on the table when complete. The
    idea is to coordinate the meal such that all of the philosophers can eat in perpetuity
    without any starving—two philosophers must be able to eat at any moment and there
    can be no deadlocks. They're philosophers because when they're not eating, they're
    thinking. In a programming analog, you can consider this as either a waiting channel
    or a sleeping process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Go handles this problem pretty succinctly with goroutines. Given five philosophers
    (in an individual struct, for example), you can have all five alternate between
    thinking, receiving a notification when the forks are down, grabbing forks, dining
    with forks, and placing the forks down.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Receiving the notification that the forks are down acts as the listening channel,
    dining and thinking are separate processes, and placing the forks down operates
    as an announcement along the channel.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize this concept in the following pseudo Go code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example has been left very abstract and nonoperational so that you have
    a chance to attempt to solve it. We will build a functional solution for this
    in the next chapter, so make sure to compare your solution later on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: There are hundreds of ways to handle this problem, and we'll look at a couple
    of alternatives and how they can or cannot play nicely within Go itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Go and the actor model
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actor model is something that you'll likely be very familiar with if you're
    an Erlang or Scala user. The difference between CSP and the actor model is negligible
    but important. With CSP, messages from one channel can only be completely sent
    if another channel is listening and ready for them. The actor model does not necessarily
    require a ready channel for another to send. In fact, it stresses direct communication
    rather than relying on the conduit of a channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Both systems can be nondeterministic, which we''ve already seen demonstrated
    in Go/CSP in our earlier examples. CSP and goroutines are anonymous and transmission
    is specified by the channel rather than the source and destination. An easy way
    to visualize this in pseudocode in the actor model is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种系统都可能是不确定的，这在我们之前的Go/CSP示例中已经看到了。CSP和goroutines都是匿名的，传输由通道而不是源和目的地指定。在演员模型的伪代码中可视化这一点的简单方法如下：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In CSP, it is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP中，它是这样的：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both serve the same fundamental functionality but through slightly different
    ways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都通过稍微不同的方式提供了相同的基本功能。
- en: Object orientation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象
- en: As you work with Go, you will notice that there is a core characteristic that's
    often espoused, which users may feel is wrong. You'll hear that Go is not an object-oriented
    language, and yet you have structs that can have methods, those methods in turn
    can have methods, and you can have communication to and from any instantiation
    of it. Channels themselves may feel like primitive object interfaces, capable
    of setting and receiving values from a given data element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Go时，你会注意到一个核心特征经常被提倡，用户可能觉得是错误的。你会听到Go不是一种面向对象的语言，然而你有可以有方法的结构体，这些方法反过来又可以有方法，你可以与任何实例进行通信。通道本身可能感觉像原始的对象接口，能够从给定的数据元素中设置和接收值。
- en: The message passing implementation of Go is, indeed, a core concept of object-oriented
    programming. Structs with interfaces operate essentially as classes, and Go supports
    polymorphism (although not parametric polymorphism). Yet, many who work with the
    language (and who have designed it) stress that it is not object oriented. So
    what gives?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Go的消息传递实现确实是面向对象编程的核心概念。具有接口的结构本质上就像类，Go支持多态性（尽管不支持参数多态性）。然而，许多使用该语言的人（以及设计它的人）强调它并不是面向对象的。那么是什么原因呢？
- en: Much of this definition ultimately depends on who you ask. Some believe that
    Go lacks some of the requisite characteristics of object-oriented programming,
    and others believe it satisfies them. The most important thing to keep in mind
    is that you're not limited by Go's design. Anything that you can do in a *true*
    object-oriented language can be handled without much struggle within Go.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义的很大程度上取决于你问的是谁。有些人认为Go缺乏面向对象编程的必要特征，而其他人认为它满足了这些特征。最重要的是要记住，你并不受Go设计的限制。在*真正*的面向对象语言中可以做的任何事情在Go中都可以轻松处理。
- en: Demonstrating simple polymorphism in Go
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示Go中简单的多态性
- en: 'As mentioned before, if you expect polymorphism to resemble object-oriented
    programming, this may not represent a syntactical analogue. However, the use of
    interfaces as an abstraction of class-bound polymorphic methods is just as clean,
    and in many ways, more explicit and readable. Let''s look at a very simple implementation
    of polymorphism in Go:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你期望多态性类似于面向对象编程，这可能不代表一种语法类比。然而，使用接口作为类绑定多态方法的抽象同样干净，并且在许多方面更加明确和可读。让我们看一个Go中多态性的非常简单的实现：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we use an interface (or its Go analog) to disambiguate methods.
    You cannot have generics the same way you might in Java, for example. This, however,
    boils down to a mere matter of style in the end. You should neither find this
    daunting nor will it impose any cruft or ambiguity into your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用接口（或其Go模拟）来消除方法的歧义。例如，你不能像在Java中那样使用泛型。然而，这归结为最终只是一种风格问题。你既不应该觉得这令人畏惧，也不会给你的代码带来任何混乱或歧义。
- en: Using concurrency
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发
- en: It hasn't yet been mentioned, but we should be aware that concurrency is not
    always necessary and beneficial for an application. There exists no real rule
    of thumb, and it's rare that concurrency will introduce problems to an application;
    but if you really think about applications as a whole, not all will require concurrent
    processes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未提到的是，我们应该意识到，并发并不总是对应用程序有益的。并没有真正的经验之谈，而且并发很少会给应用程序带来问题；但是如果你真的考虑整个应用程序，不是所有的应用程序都需要并发进程。
- en: So what works best? As we've seen in the previous example, anything that introduces
    potential latency or I/O blocking, such as network calls, disk reads, third-party
    applications (primarily databases), and distributed systems, can benefit from
    concurrency. If you have the ability to do work while other work is being done
    on an undetermined timeline, concurrency strategies can improve the speed and
    reliability of an application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么效果最好呢？正如我们在之前的例子中看到的，任何引入潜在延迟或I/O阻塞的东西，比如网络调用、磁盘读取、第三方应用程序（主要是数据库）和分布式系统，都可以从并发中受益。如果你有能力在未确定的时间表上进行工作，那么并发策略可以提高应用程序的速度和可靠性。
- en: The lesson here is you should never feel compelled to shoehorn concurrency into
    an application that doesn't really require it. Programs with inter-process dependencies
    (or lack of blocking and external dependencies) may see little or no benefit from
    implementing concurrency structures.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是你不应该感到被迫将并发加入到一个真正不需要它的应用程序中。具有进程间依赖关系（或缺乏阻塞和外部依赖关系）的程序可能很少或根本不会从实现并发结构中获益。
- en: Managing threads
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理线程
- en: So far, you've probably noticed that thread management is not a matter that
    requires the programmer's utmost concern in Go. This is by design. Goroutines
    aren't tied to a specific thread or threads that are handled by Go's internal
    scheduler. However, this doesn't mean that you neither have access to the threads
    nor the ability to control what individual threads do. As you know, you can already
    tell Go how many threads you have (or wish to use) by using `GOMAXPROCS`. We also
    know that using this can introduce asynchronous issues as it pertains to data
    consistency and execution order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the main issue with threads is not how they're accessed or utilized,
    but how to properly control execution flow to guarantee that your data is predictable
    and synchronized.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using sync and mutexes to lock data
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue that you may have run into with the preceding examples is the notion
    of atomic data. After all, if you deal with variables and structures across multiple
    goroutines, and possibly processors, how do you ensure that your data is safe
    across them? If these processes run in parallel, coordinating data access can
    sometimes be problematic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a bevy of tools in its `sync` package to handle these types of problems.
    How elegantly you approach them depends heavily on your approach, but you should
    never have to reinvent the wheel in this realm.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We've already looked at the `WaitGroup` struct, which provides a simple method
    to tell the main thread to pause until the next notification that says a waiting
    process has done what it's supposed to do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Go also provides a direct abstraction to a mutex. It may seem contradictory
    to call something a direct abstraction, but the truth is you don't have access
    to Go's scheduler, only an approximation of a true mutex.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a mutex to lock and unlock data and guarantee atomicity in our data.
    In many cases, this may not be necessary; there are a great many times where the
    order of execution does not impact the consistency of the underlying data. However,
    when we do have concerns about this value, it''s helpful to be able to invoke
    a lock explicitly. Let''s take the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unsurprisingly, this provides a list of 0 to 99 in your terminal. What happens
    if we change `WaitGroup` to know there will be 100 instances of `Done()` called,
    and put our blocking code at the end of the loop?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a simple proposition of why and how to best utilize `waitGroups`
    as a mechanism for concurrency control, let''s do a simple number iterator and
    look at the results. We will also check out how a directly called mutex can augment
    this functionality, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, our order of execution is suddenly off. You may see something like the
    following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have the ability to lock and unlock the current command at will; however,
    this won't change the underlying execution order, it will only prevent reading
    and/or writing to and from a variable until an unlock is called.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to lock down the variable we''re outputting using `mutex`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can probably see how a mutex control mechanism can be important to enforce
    data integrity in your concurrent application. We'll look more at mutexes and
    locking and unlocking processes in [Chapter 4](part0040_split_000.html#page "Chapter 4. Data
    Integrity in an Application"), *Data Integrity in an Application*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've tried to remove some of the ambiguity of Go's concurrency
    patterns and models by giving visual, real-time feedback to a few applications,
    including a rudimentary RSS aggregator and reader. We examined the dining philosophers
    problem and looked at ways you can use the Go concurrency topics to solve the
    problem neatly and succinctly. We compared the way CSP and actor models are similar
    and ways in which they differ.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take these concepts and apply them to the process
    of developing a strategy to maintain concurrency in an application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
