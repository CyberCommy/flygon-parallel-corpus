- en: Using Modern JavaScript Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes we will be covering in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming functionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing async calls compactly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with objects and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing code in modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining a feature's availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we set up our working environment with many tools that
    we will be using throughout this book. In this chapter, we will get ourselves
    prepared for the rest of this book, and we will be considering some interesting
    and powerful modern features of JavaScript that can you help be more effective
    and write better code.
  prefs: []
  type: TYPE_NORMAL
- en: We will be considering several new language features that will come handy—but
    definitely not everything! JS has really grown into a big language, and there
    are some features that you're not likely to ever need. From the very start, we
    will also work more seriously with `Flow`, aiming to forego the usage of *untyped
    JS*, for a safer way of developing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be important to highlight that JS has evolved through the years, and
    that there isn''t a single standard version. The most recent one is (formally)
    called ECMAScript 2018, which is usually shortened to ES2018\. The current list
    of versions of the language is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 1, June 1997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 2, June 1998, essentially equal to the previous version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 3, December 1999, adding several new functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5, December 2009 (there never was an ECMAScript 4; that version was
    abandoned) also known as JS5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5.1, June 2011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 6 (ES2015 or ES6), June 2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 7 (ES2016), June 2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 8 (ES2017), June 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 9 (ES2018), June 2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECMA** was originally an acronym meaning **European Computer Manufacturers Association**,
    but nowadays the name is simply considered a name by itself. You can go to its
    site at [https://www.ecma-international.org/](https://www.ecma-international.org/) and
    view the standard language specification at [https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we refer to JS in this text without further specification, the latest
    version (that is, ES2018) is what we mean. No browsers fully implement this version,
    and further on in this book, we'll solve this problem by using `Babel`, a tool
    that will convert the modern features into equivalent, but older and compatible
    code, so even if you program in the latest fashion, users with older browsers
    will still be able to run your code. The tools we'll be using will install `Babel`
    on their own, so we won't have to do that, but if you're curious, you can read
    more at [https://babeljs.io/](https://babeljs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: A very good source for all JS-related things is the **Mozilla Developer Network**
    (**MDN**), which has been going strong with all sorts of web documentation for
    over ten years. Take a look to their site at [https://developer.mozilla.org/bm/docs/Web/JavaScript](https://developer.mozilla.org/bm/docs/Web/JavaScript);
    we'll be frequently making reference to it. You can also read [http://es6-features.org/](http://es6-features.org/)
    for a wealth of examples of ES6 features.
  prefs: []
  type: TYPE_NORMAL
- en: Adding types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we installed `Flow` so that we could add data types
    check to JS, but we didn't really get into its syntax or rules. Let's get into
    that now, before getting into JS-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with Flow''s controls, you just have to specify what data type you
    expect any variable to be, and `Flow` will check that it''s always used correctly.
    Fortunately, `Flow` is also capable of determining data types by value; for example,
    if you assign a string to a variable, it will assume that this variable is meant
    to contain strings. Adapting an example from [https://flow.org/en/docs/usage/](https://flow.org/en/docs/usage/), you
    could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:?number` and `:string` annotations specify that `x` is an optional numeric
    parameter, and that `foo` should return a string. Can you see two problems with
    the rest of the code? If you use `npm run flow`, you''ll get a report showing
    what the problem is. First, you cannot `return x`, because of the data types mismatch
    between the variable and the expected return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you are trying to call a function but passing a parameter of the wrong
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All of the preceding code is (except for the type declarations) valid JS, so
    it would have been accepted; `Flow` tells you about the problems so that you can
    fix them. Now, let's get into greater detail, and see all of the possibilities
    that this tool gives us.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to ignore Flow's warnings for any line, precede it with a comment
    like `// @FlowFixMe` and follow with the reason why you want to skip that situation.
    See [https://flow.org/en/docs/config/options/#toc-suppress-comment-regex](https://flow.org/en/docs/config/options/#toc-suppress-comment-regex) for
    more on this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to define types so that you can deal with simple and complex
    cases with no problems. Let's start with the simpler, basic types, and then move
    on to more specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types in Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The possible data types definitions can be found at [https://flow.org/en/docs/types/](https://flow.org/en/docs/types/)—we
    won''t copy them all here, but rather show you the main ones through a few examples.
    Please look at the full documentation because there''s a great variety of possibilities
    that you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `:boolean` | Boolean values. |'
  prefs: []
  type: TYPE_TB
- en: '| `:number` | Numeric values. |'
  prefs: []
  type: TYPE_TB
- en: '| `:string` | Strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `:null` | Null values. You wouldn''t just be declaring that a certain variable should
    always be null; rather,you''ll be using these with advanced types such as *unions*,
    which we''ll get to see in the next section. |'
  prefs: []
  type: TYPE_TB
- en: '| `:void` | Void (undefined) value. |'
  prefs: []
  type: TYPE_TB
- en: '| `:mixed` | Any type, but will still get checked for consistency. For instance, if
    at one point `Flow` knows that the variable is a Boolean, then using it as a string would
    be flagged as wrong. |'
  prefs: []
  type: TYPE_TB
- en: '| `:any` | Any type, and `Flow` won''t do any checks for it.This amounts to disabling
    type checks onwhatever is of *any* type. |'
  prefs: []
  type: TYPE_TB
- en: '| `function foo(x: ?boolean)` | A function with an optional `boolean` parameter.
    This is the same as declaring that the argumentcan either be a `boolean`, `null`,
    or also `undefined`. |'
  prefs: []
  type: TYPE_TB
- en: '| `function bar() :string` | A function that returns a string result. |'
  prefs: []
  type: TYPE_TB
- en: '| `{ property ?: number }` | An optional object property; if present, it could
    be numeric or undefined, but not `null`. |'
  prefs: []
  type: TYPE_TB
- en: '| `: Array&lt;number>` `: number[]` | An array of numbers, in two different
    styles. If you want to deal with fixed length arrays, *tuples* may apply; go to [https://flow.org/en/docs/types/tuples/](https://flow.org/en/docs/types/tuples/) to
    find out more. |'
  prefs: []
  type: TYPE_TB
- en: We will find out how to assign or define types for these definitions in the *Defining
    types for arrow functions* recipe, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see some examples of the definitions in the following code. I disabled
    ESLint''s rule about unused variables to avoid obvious problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addTwo()` definition has a hidden problem: are you sure that `x` and `y` will
    always be of the same type? Actually, `x` could be a number and `y` could be a
    string, and `Flow` wouldn''t complain. We have no easy way of testing this, and
    a runtime check for `typeof x === typeof y` would be needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define an object, you should provide data types for all of its properties
    and methods. Object definitions are considered to be *sealed*, meaning that you
    cannot change the object types. If you cannot or won''t do this, start with an
    empty object, and then `Flow` will let you add properties at will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If a function expects an object with some properties, and it receives an object
    with those properties plus some extra ones, `Flow` won't complain. If you don't
    want this, use *exact objects*; see [https://flow.org/en/docs/types/objects/#toc-exact-object-types](https://flow.org/en/docs/types/objects/#toc-exact-object-types).
    However, this also causes problems, such as disabling the spread operator; see [https://github.com/facebook/flow/issues/2405](https://github.com/facebook/flow/issues/2405)
    for a (two year long!) discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn to more complex definitions, which you will probably end up
    using, since they better match usual business requirements and program specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic definitions of the previous section may be enough for plenty of code,
    but as you start working with more complex problems, you'll need some more advanced
    `Flow` features, and you may want to define types separately so that you can reuse
    them elsewhere. Due to this, in this and the following sections, we'll look at
    more advanced types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JS, it''s common that a variable may have, at different times, different
    data types. For that situation, you can use *union* *types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For some occasions in which you have objects that have different properties
    depending on some internal value, you can also use *disjoint* unions; see [https://flow.org/en/docs/types/unions/](https://flow.org/en/docs/types/unions/).
  prefs: []
  type: TYPE_NORMAL
- en: Class types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flow` supports classes and mostly in an automatic way. Every time you define
    a class, it becomes a type by itself, so you don''t have to do anything else;
    you can just use it elsewhere. (We''ll be seeing more about classes in a short
    while, in the *Working with Objects and Classes* section.) You can assign types
    to properties and methods in the same way as for objects and functions. Using
    our `Person` class again as an example, the following code shows how to define
    it with `Flow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a problem you may encounter. If you have distinct classes,
    even with exactly the same shape, they won''t be considered equivalent by `Flow`.
    For instance, even if `Animal` and `Pet` are equivalent, the assignment of `Pet`
    to `Animal` (or vice versa) won''t be allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular case, if you were to say that `Pet` extends `Animal`, then
    you could assign `Pet` to `Animal`, but not the other way round. A more general
    solution would involve creating an `interface` and using it in several places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `interface` definition, which includes three fields, doesn't exempt
    you from declaring those fields when you define `Animal2` or `Pet2`; in fact,
    if you were to forget some of these fields, `Flow` would point out the error,
    because neither of the three is marked as optional.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your types become more complex or when you want to reuse the same definition
    in several places, you can create a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining types in this fashion, you can just use them anywhere, even
    in the definition of new types, as we did in `complexObject`, where we defined
    a field to be of the previously defined `simpleFlag` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases can even be generic, as we'll see in the next section. You can
    also export types from a module, and import them for usage anywhere; we'll get
    to that in the *Working with libraries* section.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, it''s quite usual to work with the `identity` function,
    which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In combinatory logic, which we won't be going into, this corresponds with the
    I *combinator*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would you write a type definition for this function? If the argument is
    a number, it will return a number; if it''s a string, it''ll return a string and
    so on. Writing all possible situations would be a chore and not very **Don''t
    Repeat Yourself** *(***DRY**). `Flow` provides a solution, with *generic types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `T` stands for the generic type. Both the argument of the function
    and the result of the function itself are defined to be of `T` type, so `Flow`
    will know that whatever type the argument is, the result type will be the same.
    A similar syntax would be used for the more usual way of defining functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Flow` also checks that you don''t accidentally restrict a generic type. In
    the following case, you would always be returning a number, while `T` might actually
    be any other different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You need not restrict yourself to a single generic type; the following nonsense
    example shows a case with two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to define a parametric type with a generic type that can
    later be specified. In the following example, the type definition for `pair` allows
    you to further create new types, each of which will always produce pairs of values
    of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are more ways you can use generic types; check [https://flow.org/en/docs/types/generics/](https://flow.org/en/docs/types/generics/) for
    a complete description of available possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Opaque types for safer coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `Flow` (and TypeScript as well), types that are structurally the same are
    considered to be compatible and one can be used instead of the other. Let''s consider
    an example. In Uruguay, there is a national identification card with a DNI code:
    this is a string that''s formed by seven digits, a dash, and a check digit. You
    could have an application that lets you update people''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What could happen? If you don't define better types, there's nothing preventing
    you from doing a call such as `updateClient(229, "Kari Nordmann", "1234567-8")`;
    can you spot the switched values? Since both `dniType` and `nameType` are just
    bottom strings, even though they imply totally different concepts, `Flow` won't
    complain. `Flow` ensures that types are used correctly, but since it doesn't handle
    semantics, your code can still be obviously wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '*Opaque* types are different, since they obscure their internal implementation
    details from the outside, and have much stricter compatibility rules. You could
    have a file called `opaque_types.js` with the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in a different source file, we could attempt the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we fix this? Not even changing the definition of `newDni` would help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Even after this change, `Flow` would still complain that a string isn''t a
    DNI. When we work with opaque types, if we want to do type conversions, we must
    provide them on our own. In our case, we should add such a function to our file
    with type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can work! Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still not optimal. We know that all DNI values are strings, so we should
    be able to use them as such, right? This isn''t the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `anotherDni` variable is of `dniType`, but as opaque types carry no information
    as to the real types, trying to use it as a `string` fails. You could, of course,
    write a `dniToString()` function, but that seems to be overkill—and would quickly
    get out of control in a system with potentially dozens of data types! We have
    a fallback: we can add a subtyping constraint, which will allow the opaque type
    to be used as a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means that `dniType` may be used as `string`, but not vice versa. Using
    opaque types will add safety to your code, since more errors will be caught, but
    you can also get a certain measure of flexibility through these constraints, which
    will make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Working with libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, it's highly likely that any project you create will depend on third-party
    libraries, and it's very likely that those weren't written with `Flow`. By default,
    `Flow` will ignore these libraries and won't do any type checking. This means
    that any data type errors you might commit when using the library will be unrecognized,
    and you'll have to deal with them in the old-fashioned way, through testing and
    debugging—a throwback to worse times!
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, `Flow` lets you work with **library definitions** (**libdefs**)
    (see [https://flow.org/en/docs/libdefs/](https://flow.org/en/docs/libdefs/)) that
    describe the data types, interfaces, or classes for a library, separately from
    the library itself, like header files in C++ and other languages. Libdefs are `.js` files,
    but they are placed in a `flow-typed` directory at the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: You can change this directory by editing the `.flowconfig` configuration file,
    but we won't meddle with it. If you are interested in effecting such a change,
    see the `[libs]` documentation at [https://flow.org/en/docs/config/](https://flow.org/en/docs/config/).
  prefs: []
  type: TYPE_NORMAL
- en: There exists a repository of library definitions, `flow-typed`, in which you
    can find already made files for many popular libraries; see [https://github.com/flowtype/flow-typed](https://github.com/flowtype/flow-typed) for
    more information. However, you don't need to directly deal with that, because
    there is a tool that does the work for you, though at some times it will pass
    the buck back to you!
  prefs: []
  type: TYPE_NORMAL
- en: The main objection against `Flow` these days, and a point for TypeScript, is
    that the list of supported libraries in terms of data type descriptions is far
    greater for the latter. There are some projects that attempt to make `Flow` work
    with TypeScript's descriptions, but so far this is still pending, though some
    good results have been shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the new tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a script in `package.json` to simplify the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `npm run addTypes` will scan your project and attempt to add all possible
    libdefs. If it cannot find an appropriate definition for a library (this isn''t
    unusual, I''m sorry to say), it will create a basic definition using `any` everywhere.
    For instance, I added the `moment` library to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After this, the `flow-typed` directory was added to the project root. In it,
    there a lot of files appeared, including `moment_v2.3.x.js` with the type definitions
    for the `moment` library. For libraries without a libdef, files were also created,
    but you may ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a libdef, and it doesn't exist, you may be able to create it by
    yourself. (And, please, contribute your work to the `flow-typed` project!) I added `npm
    install fetch --save`, but when I tried to get the libdef, it wasn't found. So,
    I can either keep working without the definitions (the standard situation!) or
    I can try to create the appropriate file; none is really an optimal situation.
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest adding the `flow-typed` directory to `.gitignore` so that those
    files won't get uploaded to Git. Since it's standard practice to do `npm install` every
    time you pull from the repository, now you also have to use `npm run addTypes`—or,
    better yet, create a script that will do both commands!
  prefs: []
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings have been a feature of JS since the very first version, but nowadays
    there are some more features available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we'll see many functions that we'll be using through
    the rest of this book, such as interpolation (to build up strings out of several
    parts) or tagged strings (which we'll use to style components in the *Creating
    StyledComponents for inline styling* section of [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml),
    *Enhancing Your Application*), to show just two examples.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating in template strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everybody has, at one time or another, used common operators to build up a
    string, as in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'JS has now added *template literals*, providing an easy way to include variable
    text and produce multiple line strings. String interpolation is quite simple,
    and the preceding code could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Template literals were earlier known as *template strings*, but current JS specifications
    don't use that expression any more. For more information, go to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  prefs: []
  type: TYPE_NORMAL
- en: 'Template literals are delimited by back-tick characters (``...``). You use `${...}` wherever
    you want some value or expression to be substituted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it''s easy to go overboard and start pushing too much logic when
    interpolating. I would recommend avoiding code such as the following for just
    that reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If `list` had been empty, `"Visiting no cities"` would have been produced instead.
    It''s far clearer if you push logic out of templates; even if the resulting code
    is somewhat larger, it will gain in clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We'll fight the temptation to include logic in templates later, when we work
    in `React` (from [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing
    with React*, to [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml), *Testing
    your Application*) and see how we can render components.
  prefs: []
  type: TYPE_NORMAL
- en: Tagged templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tagged template is a more advanced form of the templates we''ve been looking
    at. Basically, it''s another way to call a function, but with a syntax similar
    to a template string. Let''s look at an example and then explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showAge()` function is called with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An array of strings, corresponding to each constant part of the template, so
    `strings[0]` is `The` and `strings[2]` is `.` in the first case, for example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A parameter for each expression included; in our case, there's two of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function may do any calculations and return any type of value—possibly not
    a string! In our example, the function produces an *enhanced* version of the original
    string, adding how many years ago something happened—when a comic strip character
    was created or an automobile was bought, for example.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using tagged templates in the *Creating StyledComponents for inline
    styling* section of [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml), *Enhancing
    Your Application*; the styled-component library we'll use depends totally on this
    feature to allow for more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing multiline strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another feature of the new template literals is that they can span several
    lines. With earlier versions of JS, if you wanted to produce multiple lines of
    text, you had to insert newline characters (`"\n"`) in the output string, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With template strings, you can just write the line as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, I would recommend against this practice. Even if the code may seem
    more legible, when it gets indented, the result looks ugly, since continuation
    lines *must* start at the first column—do you see why? Check out the following
    code—the continuation lines are pushed to the left, breaking the visual continuity
    of the indented code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a backslash to escape characters that are not meant to be part
    of templating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You might want to look into `String.raw` (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw))
    for an alternative to this way of avoiding templating. You can just avoid templating
    altogether, since an informal poll has shown that practically no developers know
    of it and it isn't such a great advantage after all.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish with several new string-related functions. Most are pretty simple
    to understand, so the explanations will mostly be brief. For a complete list of
    all available string functions, both old and new, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can iterate any string using the `.repeat(...)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Padding strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can pad a string to a given length by adding repeated strings either at
    the left or at the right of the original text by using `.padStart(...)` and `.padEnd(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Among possible uses, you may pad a number with zeroes to the left. We have
    to transform the number into a string because the padding methods are only available
    for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The reason for using `padStart` and `padEnd` instead of `padLeft` and `padRight` has
    to do with left-to-right and right-to-left languages. It was felt that start and
    end were not ambiguous, while left and right would be. For example, in Hebrew,
    the start of a string is printed at the right and its end is to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Searching in strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are new functions to determine whether a strings starts with, ends with,
    or includes a given string. This can give you much relief from using `indexOf(...)` and
    length-related calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Each of these methods has a position as an optional second parameter, which
    specifies where to do the search; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith),
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may trim a string at both ends, or only at one, by using `.trim(...)`, `.trimStart(...)`,
    and `.trimEnd(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Originally, `.trimStart()` was `.trimLeft()`, and `.trimEnd()` was `.trimRight()`,
    but the names were changed for the same reason as `.padStart()` and `.padEnd()` were.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are now iterable objects (such as arrays are), meaning that you can
    use `for...of` to iterate over them, character by character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The spread operator (read about it in depth, in the *Spreading and joining
    values* section of this chapter) will also work, hence transforming a string into
    an array of single characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Enhancing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's go over several useful new functions of JS, which have to do with
    basic needs and features. This won't be exhaustive, since JS is quite big, after
    all! However, we will touch on the most interesting features that you will be
    likely to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The features in this section aren't linked by a common thread, apart from the
    fact that they will help you to write shorter, more concise code and help you
    to avoid possible common errors.
  prefs: []
  type: TYPE_NORMAL
- en: Working in strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a change that you probably won''t need! JS was somewhat cavalier
    as to some errors and, instead of warning or crashing, it would just silently
    ignore them. In 2015, a new *strict* mode was included, which changed the JS engine''s
    behavior to start reporting these errors. To enable the new mode, you had to include
    a single line before anything else, with a simple string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Including this string would enforce strict mode for your code. What errors
    were caught? A brief list includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot create a global variable by accident. If you misspelled a variable's
    name in a function, JS would have created a new global variable and just moved
    on; in strict mode, an error is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use `eval()` to create variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot have function parameters with duplicate names, as in `function doIt(a,
    b, a, c)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot delete non-writable object properties; for example, you cannot delete
    `someObject.prototype`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot write to some variables; for instance, you cannot do `undefined=22` or
    `NaN=9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `with` statement is forbidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some words (such as `interface` or `private`, for example) were reserved for
    keywords in future versions of JS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list isn't complete and there're a few more changes and restrictions.
    For full details, read [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: Should you use this? For your main script, `"use strict"` is optional, but for
    modules and classes, it's implied. So, most code will always run in strict mode,
    so you'd really get used to including that string. That said, if you are using
    `Babel`, the required string is already provided for you by the transpiler. On
    the other hand, Node's modules will require it, as we'll see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of *scope* is associated with the idea of *visibility*: scope is
    the context in which defined elements (such as variables or functions) can be
    referenced or used. Clasically, JS provided only two types of scope: *global*
    scope (accessible everywhere) and *function* scope (accessible only within the
    function itself). Since scopes have been around since the beginning of JS, let''s
    just remember a couple of rules, with not much elaboration:'
  prefs: []
  type: TYPE_NORMAL
- en: Scopes are hierarchically arranged, and *child* scopes can access everything
    in the *parent* scope, but not the other way round.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the *parent* scope will be disabled if you redefine something at an
    inner scope. References will always be to the child definition, and you cannot
    access the equally named element in the outer, encompassing scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JS5 introduced a new type of scope, called *block* scope, that lets you work
    in a more careful way. This allows you to create variables for a single block,
    without existence outside of it, even in the rest of the function or method where
    they were defined. With this concept, two new ways of defining variables, other
    than using `var`, were added: `let` and `const`.'
  prefs: []
  type: TYPE_NORMAL
- en: The new declarations are not subject to *hoisting*, so if you are not used to
    declaring all variables at the top of your code before they are used, you may
    have problems. Since the usual practice is starting functions with all declarations,
    this isn't likely to affect you. See [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option, `let`, allows you to declare a variable that will be limited
    to the block or statement where it is used. The second option, `const`, adds the
    proviso that the variable isn''t supposed to change value, but rather be constant;
    if you try to assign a new value to a constant, an error will be produced. The
    following simple examples show the new behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `const` for a constant value needs little explanation, but what about `let`?
    The reason harkens back to the origin of the `BASIC` programming language. In
    that language, you assigned values to variables with code like `37 LET X1 = (B1*A4
    - B2*A2) / D`; this particular line was taken from Darmouth College's `BASIC`
    manual facsimile, dated October 1964\. See [http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf](http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `let` also solves a classic problem. What would the following code do? Here
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were expecting a countdown to zero (`10... 9... 8...` down to `2...
    1... 0!`) with suitable one second delays, you''ll be surprised, because this
    code emits `-1`! eleven times! The problem has to do with closures; by the time
    the loop ends, the `i` variable is `-1`, so when the waiting (timeout) functions
    run, `i` has *that* value. This can be solved in several ways, but using `let`
    instead of `var` is the simplest solution; each closure will capture a different
    copy of the loop variable, and the countdown will be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For more on blocks and `let`/`const`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
    at MDN.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading and joining values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new operator, `...`, lets you expand an array, string, or object, into independent
    values. This is harder to explain than to show, so let''s see some basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use it to copy arrays or concatenate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you apply the spread operator to a string, the effect is to separate it into
    individual characters, much as if you had used `.split()`; for instance, `console.log(..."JS")`
    shows `["J", "S"]`, so this case isn't particularly interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use it to clone or modify objects; in fact, this is a usage we''re
    going to meet again later, in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*, mostly when we use `Redux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also useful for writing functions with an undefined number of arguments,
    avoiding the old style usage of the `arguments` pseudo-array. Here, instead of
    splitting an element into many, it joins several distinct elements into a single
    array. Note, however, that this usage only applies to the last arguments of a
    function; something such as `function many(a, ...several, b, c)` wouldn''t be
    allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering why I called `arguments` a pseudo-array, the reason is
    because it *looks* somewhat like an array, but only provides the `.length` property;
    see more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).
    In any case, you won't be dealing with it, thanks to the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring arrays and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another powerful construct provided by JS nowadays is the destructuring assignment.
    This is also harder to explain than to show, so once again let''s directly get
    to some examples! The simplest case lets you split an array into variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'More interesting still is that you can swap or twiddle variables around! Following
    on from the preceding example, we''d have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign default values to missing variables, ignore values you
    don''t care for, and even apply the `rest` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be applied to objects, letting you pick attributes and even renaming
    them, as with the flag and name in the following code. Assigning values by default
    is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'One interesting usage of this is allowing a function to return many values
    at once. If you want to return, say, two values, you can either return an array
    or an object and use destructuring to separate the returned values in a single
    sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use an object and an arrow function just for variety;
    note the extra parentheses we used, since we are returning an object. We are also
    renaming attributes, by the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find many examples of spreading and destructuring in MDN if you visit
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)'
  prefs: []
  type: TYPE_NORMAL
- en: Doing powers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s introduce a newly added operator, `**`, which stands for power
    calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a shortcut for the existing `Math.pow()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'An exponential assignment operator also exists, which is similar to `+=`, `-=`,
    and the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an operator that you won''t probably using very often, unless you deal
    with interest calculations and financial formulas. A final reminder: just as in
    math, the exponentiation operator groups from right to left, so `2 ** 3 ** 4`
    is calculated as `2 ** (3 ** 4)`; be careful!'
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JS isn't a functional programming language by definition, but it includes practically
    everything that a full-fledged functional language would provide. In our case,
    we won't be delving too deeply into this programming paradigm, but let's see some
    important features that will simplify your work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JS has always included functions, which can be defined in many ways, but now
    there is yet one more function definition style that will provide several advantages;
    read on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading the preceding paragraph, did you try to count how many ways there
    are to define a function in JS? There are actually far more than you probably
    think, including at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A named function declaration*: `function one(...) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An anonymous function expression*: `var two = function(...) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A named function expression*: `var three = function someName(...) {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An immediately-invoked expression*: `var four = (function() { ...; return
    function(...) {...}; })()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A function constructor*: `var five = new Function(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The new style, an arrow function*: `var six = (...) => {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You are probably quite used to the first trio, while the two that follow may
    be not so common. However, what we now care about is the last style, called an
    *arrow function*. Arrow functions work pretty much in the same fashion as functions
    defined in the other ways, but there are three key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions do not have an `arguments` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions may implicitly return a value, even if no `return` statement
    is provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions do not bind the value of `this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, there are some more differences, including the fact that you cannot
    use arrow functions as constructors, they don't have a prototype property, and
    they cannot be used as generators. For more on this, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is handled simply by using the spread operator, as we saw
    earlier in this chapter. So, let's focus on the last two items, which are more
    interesting, instead.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An arrow function may have a block of code with some return statements in it
    or it may just be an expression. The former case is most similar to the standard
    way of defining a function; for example, we could write a function to add three
    numbers as follows, using both styles. We should add data types to the definitions,
    but we''ll get to that soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can do this just by returning an expression, you can then write an equivalent
    version; just write whatever you want to return immediately after the arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a special case: if you are returning an object, then you must place
    it within parentheses because otherwise JS will confuse it with a block of code.
    For `Redux` (which we''ll be seeing in the *Managing State with Redux* section
    of [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml), *Expanding Your Application*),
    you might want to write an *action creator* that returns an *action, *namely an
    object with a `type` attribute and possibly some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here? JS is interpreting the braces as a block, and then
    `type` and `data` are considered to be *labels* (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
    if you don''t remember these!), so the whole *object* is really a block that just
    doesn''t return anything, and JS returns an `undefined` result. Just placing the
    object in parentheses will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Handling this in arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A well-known JS problem is how to handle `this`, because its value isn''t always
    what you expect! Modern JS solves this with arrow functions that, unlike common
    functions, inherit the proper `this` value. A well-known example is as follows:
    you would expect the following code to display `JAVASCRIPT` after a few seconds,
    but rather `undefined` will be shown (don''t mind the fact that you could have
    coded `show()` in a simpler way; I wanted to highlight a general problem and not
    a particular solution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three ways of solving this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `.bind()` to properly bind the timeout function to the correct value of
    `this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a closure and defining a local variable (usually called `that`) to store
    and save the original value of `this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using arrow functions, which will work without any extra work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see these three solutions in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We will get to see the `.bind()` idea in React in the *Defining Components* section
    of [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing with React,*
    where we will deal with `this` related problems.
  prefs: []
  type: TYPE_NORMAL
- en: Defining types for arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s see how types would be defined for arrow functions. We can
    have a couple more implementations of the `toString()` function we saw earlier
    in the *Basic types in Flow* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Defining default argument values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting new feature for functions is the possibility of defining default
    values for missing arguments. We could write a function to calculate *n^(th)* roots
    that, by default, would calculate square roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the third example, passing `undefined` is equivalent to omitting
    the value. This means that you can provide default values for any parameter: a
    call such as `someFunction(undefined, 22, undefined)` would use default values
    for the first and third arguments, and 22 as the second one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Default values can also be used for methods and constructors. In the following
    `Counter` class, the `inc()` method, if not provided with a number, will increment
    the counter by `1`. Also, when constructing the counter, if you don''t provide
    an initial value, zero will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last detail, you can use values from previous arguments to calculate the
    default values of later ones. A simple nonsense example shows this; I''ll skip
    type declarations since they are not relevant here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Using default values is a very practical way to simplify the usage of functions,
    particularly in the case of complex APIs with many parameters, but allowing sensible
    values for whatever the user omits.
  prefs: []
  type: TYPE_NORMAL
- en: Programming functionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is often more declarative than imperative, with higher
    level functions that can do complete processing in a simpler, straightforward
    way. Here, let's look at several functional programming techniques that you should
    really adopt for your own code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has always been present in JS, but recent versions of
    the language have added well-known features of other languages that you can use
    to shorten your code, also making it simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing arrays to values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple question: how many times have you looped through an array to, say,
    add its numbers? The odds are, many times! This kind of operation —going through
    an array element by element performing some calculation to arrive at a final result—is
    the first one we will be implementing in a functional way, with `.reduce()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name `.reduce()` pretty much tells us what it does: it *reduces* a complete
    array to a single value. In other languages, this operation is called *fold*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most usual example, which most texts and articles show, is summing all
    of the elements of an array, and, since I''m traditionally minded, let''s do just
    that! You must provide an initial value for your calculation (in this case, since
    we want a sum, it would be a zero) and a function that will update the calculated
    value when accessing each array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'How does it work? Internally, `.reduce()` starts by taking your initial value
    (zero, in this case) and then it calls the reducing function, giving it the accumulated
    total (`acc`) and the first element of the array (`val`). The function must update
    the accumulated total: in this case, it would calculate *0* + *22*, so the next
    total would be `*22*`. After, `.reduce()` would call the function again, passing
    it 22 (the updated total) and `9` (the second array element), and `31` would become
    the new accumulated total. This will proceed systematically through the complete
    array, until the final value (`163`) is computed. Note that all aspects of loop
    control are automatic, so there is no way you can err somewhere, and the code
    is quite declarative: you could almost read it as "reduce `someArray` to a value
    by summing all elements, starting with zero".'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some more possibilities for `.reduce()`: check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) for
    more information. You can also use `.reduceRight()`, which essentially works in
    the same fashion, but starting at the end of the array and proceeding backwards;
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight) for
    more information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you are not limited to processing arrays of numbers; you can deal
    with any data type, and the final result can also be any type. For example, you
    could use `.reduce()` to turn an array of names into an HTML bulleted list, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: With a little practice, it's safe to say that you'll probably be able to transform
    any kind of calculation over an array into a `.reduce()` call with shorter, clearer
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A second type of very common operation is to go through an array and produce
    a new array by doing some kind of process to each element. Fortunately, we also
    have a way to do that functionally by using `.map()`. The way this function works
    is simple: given an array and a function, it applies the function to each element
    of the array and produces a new array with the results of each call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we called a web service and got back an array with people data. We
    just wanted their ages so that we are able to do some other process; say, calculate
    the average age of the people who used the service. We can manage this simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Using `.map()` is, like `.reduce()`, a much shorter and safer way to process
    an array. In fact, most times, the two operations are used one after the other,
    with some possible `.filter()` operations mixed in to select what should or should
    not be processed; let's get into that now.
  prefs: []
  type: TYPE_NORMAL
- en: The `.map()` operation also has some extra features; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
    for a complete description. Also, if you really want to affect the original array,
    rather than producing a new one, take a look at the `.forEach()` method at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).
  prefs: []
  type: TYPE_NORMAL
- en: Filtering arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third operation we are considering is `.filter()`, which will scan a complete
    array and generate a new one, but only with the elements that satisfy some condition,
    as given by you via a function. Following our example, we could pick only the
    males in the service result by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these three operations makes it simple to do sequences of calls and
    generate results with little code. For example, could we find out the age of the
    eldest of the males in the family? Yes, quickly—with just a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of chained operations is quite common: in this case, we first select
    the males, then we pick their ages, and then we reduce the array to a single value,
    the maximum: neat!'
  prefs: []
  type: TYPE_NORMAL
- en: Producing functions from functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish this section on functional aspects by looking at a quintessential
    functional programming tool: **Higher Order Functions** (**HOFs**): functions
    that produce functions as results! In later chapters, we''ll actually meet more
    usages of HOFs; here, let''s work out a simple example.'
  prefs: []
  type: TYPE_NORMAL
- en: The following example is taken from my previous book for Packt, *Mastering JavaScript
    Functional Programming*. Chapter 2, *Thinking Functionally - A First Example*,
    and Chapter 6, *Producing Functions - Higher-Order Functions* will be of particular
    interest with regard to HOFs. See more at [www.packtpub.com/web-development/mastering-javascript-functional-programming](https://www.packtpub.com/web-development/mastering-javascript-functional-programming).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have developed an e-commerce site. The user selects products, adds
    them to his/her shopping cart, and at the end clicks on a BILL ME button so that
    his/her credit card will be charged. However, if the user were to click twice
    or more, he/she would be billed several times rather than once. Your application
    might have something along these lines in its HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere among your scripts, there would be some code like the following.
    I''m not including data type declarations because they are not relevant to our
    code; we don''t really know or care what the arguments to `billUser()` would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what could you do in order to avoid repeated clicks on the button? There
    are several not-quite-so-good solutions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Do nothing, just warn the user, and hope they pay attention!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a global flag to signal the fact that the user clicked once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `onclick` handler from the button after the user clicks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `onclick` handler to something else that won't bill the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, all of these solutions are somewhat lacking, depend on global objects,
    need you to mess with the billing function, are tightly linked with the user view,
    and so on. Since requiring that some functions are executed only once isn''t such
    an outlandish requirement, let''s specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The original function should be unchanged and do its thing—nothing more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a new function that will call the original one, but only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a general solution so that we can apply it in different situations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will write a function, `once()`, that will take a function as its argument
    and produce a new function, but that will *do its thing* only once. The logic
    is not long, but study it carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Some analysis of our new function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition shows that `once()` takes a generic function (`fn()`) as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement shows that `once()` returns another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the spread operator to deal with functions with any number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using a closure for the `done` variable, which remembers whether `fn()`
    was invoked or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I left out type definitions for clarity, but in the source code provided with
    this book, full definitions are provided. Can you work them out on your own? A
    tip: the output of the `once()` function should be the same type as the input
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new function, you could have coded the button as follows. When the
    user clicks on the button, the function that will get called with `(sales, data)`
    as arguments isn''t `billUser()`, but rather the result of having applied `once()`
    to `billUser()`—and that would have resulted in a new function that would have
    called `billUser()` only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the concept of a higher order function: a function that receives functions
    as arguments and produces a new function as a result. Usually, there are three
    kinds of possible transformations that we could desire:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Wrapping functions*: We do this so that they keep their original functionality,
    but add some new feature; for example, we could add logging or timing so that
    the original function still does its thing, but log its parameters or produce
    timing information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Altering functions*: We do this so that they will differ in some key point
    with the original version; this is what we did with `once()`, which produces a
    new version of a function that runs only a single time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Other changes*: These changes include turning a function into a promise (we''ll
    see this when we get to `Node`, in the *Using Promises instead of error first
    callbacks* section of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml),
    *Developing with Node*) and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing async calls compactly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Ajax started appearing, it was commonly used with callbacks, which themselves
    could have callbacks of their own, with more callbacks within, which eventually
    led to coining the term *callback hell*. As a way out of that impractical programming
    style, two other styles of working with services and asynchronous calls appeared:
    promises and `async`/`await`—though in truth, the latter also use promises!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see both styles by using a simple example. This book was written in
    three different cities: Pune, India; London, England; and Montevideo, Uruguay,
    so let''s do some work related to those cities. We will write code that will get
    weather information for those cities:'
  prefs: []
  type: TYPE_NORMAL
- en: For Montevideo alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For London and then for Pune, in series, so that the second call won't start
    until the first is done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the three cities in parallel, so that all three requests will be processed
    at the same time, gaining time by the overlap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will not get into details such as using this or that API, getting a private
    key, and so on, and we''ll just fake it by accessing the free *The Weather Channel* page.
    We will use the following definitions for all our coding, which we''ll do in `Node`,
    using the `axios` module; don''t worry about the details now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BASE_URL` constant provides the basic web address, to which you must attach
    the coordinates (latitude, longitude) of the desired city. On its own, we would
    get a page like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f27bb572-7800-4640-8d02-86e62e9c0190.png)'
  prefs: []
  type: TYPE_IMG
- en: we will be using Ajax to get weather information for cities
  prefs: []
  type: TYPE_NORMAL
- en: In real life, we would not be getting a web page but rather an API, and then
    process the returned results. In our case, since we don't actually care for the
    data, but for the methods we'll use to do the calls, we'll be content with just
    showing some banal information, such as how many bytes were sent back. Totally
    useless, I agree, but this is enough for our example!
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using `axios` in several places in this book, so you may want to read
    its documentation, which can be found at [https://github.com/axios/axios](https://github.com/axios/axios).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using functions as callbacks is the most classic way of dealing with async calls,
    but this has several disadvantages, such as code that is harder to read and series
    difficulties in dealing with some not-too-uncommon cases. Here, we'll look at
    two alternative ways of working.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Ajax calls with promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first way we can do web service calls is by using promises, and they were
    (up to the appearance of the more modern `async`/`await` statements, which we'll
    be seeing in the next section) the favorite method. Promises were available some
    time back (first around 2011 through jQuery's deferred objects, and afterwards
    by means of libraries such as `BlueBird` or `Q`), but in recent JS versions, they
    became native. Since promises cannot really be considered something new, let's
    just see some examples so that we can move on to more modern ways of working—no, we
    won't be even considering going further back than promises, and directly work
    with callbacks!
  prefs: []
  type: TYPE_NORMAL
- en: Do native promises imply that libraries won't be needed again? That's a tricky
    question! JS promises are quite basic, and most libraries add several methods
    that can simplify your coding. (See [http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html) or [https://github.com/kriskowal/q/wiki/API-Reference](https://github.com/kriskowal/q/wiki/API-Reference)
    for such features from `Bluebird` or `Q`.) Hence, while you may do perfectly well
    with native promises, in some circumstances, you may want to keep using a library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the weather data for Montevideo is simple if we use the `getWeather()`
    function that we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `getWeather()` function actually returns a promise; its `.then()` method
    corresponds to the success case and `.catch()` corresponds to any error situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting data for two cities in a row is also simple. We don''t want to start
    the second request until the first one has been successful, and that leads to
    the following scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is not the only way to program such a series of calls, but since we won't
    actually be directly working with promises, let's just skip the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to do calls in parallel and optimize time, the `Promise.all()`
    method will be used to build up a new promise out of the three individual ones
    for each city. If all calls succeed, the bigger promise will also do; should any
    of the three calls fail, then failure will also be the global result:'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `Promise.all()`, check out [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all).
    If you'd rather build a promise that succeeds when *any* (instead of *all*) of
    the involved promises succeeds, you should use `Promise.race()`; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use a destructuring assignment to get the data for each city. The
    result of calling these functions may be as follows; I added some spacing for
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Organizing web calls with promises is a straightforward method, but the usage
    of possibly nested `.then()` methods can become hard to understand, so we really
    should give a look to an alternative. We'll do just that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Ajax calls with async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second way, `async`/`await`, is more modern but, deep inside, actually
    also works with promises, but simplifyies the job. There are some important definitions
    that we should take into account:'
  prefs: []
  type: TYPE_NORMAL
- en: An `async` function will contain some `await` expressions, depending on promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`await` expressions pause the execution of the `async` function until the promise''s
    resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the promise's resolution, processing is resumed, with the returned value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error is produced, it can be caught with `try ... catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`await` can only be used in async functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How does this affect our coding? Let''s review our three examples. Getting
    information for a single city is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We are still using a promise (the one returned by `axios` via the `getWeather()`
    call), but now the code looks more familiar: you wait for results to come, and
    then you process them—it almost looks as if the call were a synchronous one!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting data for London and then Pune in sequence is also quite direct: you
    wait for the first city''s data, then you wait for the second''s, and then you
    do your final process; what could be simpler? Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, getting all data in parallel also depends on the `Promise.all()` method
    we saw in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The parallel call code is really quite similar to the pure promises'' version:
    the only difference here is that you `await` results, instead of using `.then()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen two ways of dealing with asynchronous service calls. Both are very
    much in use, but in this text, we'll tend to favor `async`/`await`, given that
    the resulting code seems clearer, with less extra baggage.
  prefs: []
  type: TYPE_NORMAL
- en: Working with objects and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to start a lively discussion, ask a group of web developers: is
    *JavaScript an object oriented language, or merely an object based one?*, and
    retreat quickly! This discussion, while possibly arcane, has gone on year after
    year, and will probably continue for a while. A usual argument for the *object-based*
    opinion has to do with the fact that JS didn''t include classes and inheritance
    and was prototype oriented. This argument has been voided now because the latest
    versions of JS provide two new keywords, `class` and `extends`, which behave in
    pretty much the same way as their counterparts in other *official* OO languages.
    However, keep in mind that the new classes are just *syntactical sugar* over the
    existing prototype-based inheritance; no new paradigm or model was truly introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: JS could do inheritance, but it was harder. To see how this was achieved in
    the old fashioned way, look at [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance),
    and you'll have to agree that using `class` and `extends` is much better than
    assigning prototypes and constructors by hand!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked with other common programming languages, such as Java, C++,
    and Python, the concepts of classes and objects should already be clear to you;
    we'll assume that's the case and look at how these concepts apply in modern JS.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the basics and look at how classes are defined in modern
    JS. Afterwards, we''ll move to other features that are interesting, but that you
    might not use that often. To define a class, we simply write something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The new syntax is much clearer than using functions for constructors, as in
    older versions of JS. We wrote a `.constructor()` method, which will initialize
    new objects, and we defined two methods, `.initials()` and `.fullName()`, which
    will be available for all instances of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: We are following the usual convention of using an initial uppercase letter for
    class names and initial lowercase letters for variables, functions, methods, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also extend a previously existing class. To refer to the original constructor,
    use `super()`, and to refer to the parent''s method, use `super.method()`; see
    the redefinition of `.fullName()` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not limited to extending your own classes; you can also extend the
    JS ones, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If you don't need a special constructor, you can omit it; the parent's constructor
    will be called by default.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JS doesn't allow multiple inheritance, and it doesn't provide for implementing
    interfaces either. However, you can build your own ersatz interfaces by using
    *mixins*, using a higher order function (as we saw earlier, in the *Producing
    functions from functions* section), but with a class as a parameter, and adding
    methods (but not properties) to it. Even if you don't get to actually use it,
    let's look at a short example, because it gives another example of working in
    a functional way.
  prefs: []
  type: TYPE_NORMAL
- en: Read [https://developer.mozilla.org/en-US/docs/Glossary/Mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin) for
    a definition. As an alternative, you can use TypeScript; see [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html) for
    the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our `Person` class from earlier, once again. Let''s imagine a couple
    of interfaces: one could provide an object with a method that produced the JSON
    version of itself, and another could tell you how many properties an object has.
    (OK, none of these examples are too useful, but bear with me; the method we''ll
    use is what matters.) We will define two functions that receive a class as an
    argument and return an extended version of it as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new `PersonWithMixins` class (not a very good name, is
    it?) by using these two mixins, and we can even provide a different implementation,
    as with the `.toJson()` method. A very important detail is that the class to extend
    is actually the result of a function call; check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Being able to add methods to an object in this way can be a workaround for the
    problem of being able to implement interfaces. This is important to show how JS
    can let you work in an advanced style, seemingly beyond what the language itself
    provides, so that you won't be feeling that the language hinders you when trying
    to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Flow`, we will get to use the usual Java-style implements and interface
    declarations, but they will only be used for type checking; see the *Implementing
    interfaces* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, you have some utility functions that are related to a class, but not
    to specific object instances. In this case, you can define such functions as static
    methods, and they will be available in an easy way. For instance, we could create
    a `.getMonthName()` method, which will return the name of a given month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Static methods must be accessed by giving the class name; since they do not
    correspond to objects, they cannot be used with this or an object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JS now lets you define *dynamic* properties that, instead of being a stored
    value in the object, are calculated on the spot. For example, with the previous
    `Person` class, we could have a *getter* for `lastFirst`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, you could access a `.lastFirst` property as if it actually
    were an attribute of the object; no parentheses are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: You can complement a getter with a *setter*, and it will perform any operations
    you want it to. For example, we may want let the user assign a value to `.lastFirst` and
    then change `.first` and `.last` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working somewhat cavalierly (no checks on arguments!), we could add the following
    definition to our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Of course, having a property and having a getter or a setter for the same property
    is not allowed. Also, getter functions cannot have parameters, and setter functions
    must have exactly one.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on getters and setters at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The previous sections do not exhaust all of the possibilities of JS as to classes
    and objects (not by a long shot!), but I opted to go over the most likely ones
    for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As today's JS applications become more and more complex, working with namespaces
    and dependencies becomes ever more difficult to handle. A key solution to this
    problem was the concept of *modules*, which allows you to partition your solution
    in independent parts, taking advantage of encapsulation to avoid conflict between
    different modules. In this section, we'll look at how to work in this fashion.
    However, we'll start with a previous JS pattern, which may become useful in its
    own way.
  prefs: []
  type: TYPE_NORMAL
- en: '`Node`, which we''ll be working with starting with the next chapter, also does
    modules but in a different fashion, so we''ll postpone the discussion of its modules
    for now.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing code is such a basic need when dealing with hundreds or thousands
    of or even larger code bases, and so many ways of dealing with the problem were
    designed before JS finally defined a standard. First, we'll look at the more classic
    *iffy* way (we'll see what this means soon) and then move on to more modern solutions,
    but be aware that you may encounter all of these styles when reading other people's
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Doing modules the IIFE way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before modules became widely available, there was a fairly common pattern in
    use, which basically provided the same features that today''s modules do. First,
    let''s introduce a sample fragment of code, and then examine its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Defining a function and immediately calling it is called an IIFE, pronounced
    *iffy*, and stands for *Immediately Invoked Function Expression*.
  prefs: []
  type: TYPE_NORMAL
- en: IIFEs are also known as *Self-Executing Anonymous Functions*, which doesn't
    sound as good as *iffy*!
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a function (the one starting with `name => ...`), but we immediately
    called it (with `("Clicks")` afterwards). Therefore, what gets assigned to `myCounter`
    is not a function, but its returned value, that is, an object. Let''s analyze
    this object''s contents. Because of the scoping rules for functions, whatever
    you define inside isn''t visible from the outside. In our particular case, this
    means that `count`, `get()`, `inc()`, and `toString()` won''t be accessible. However,
    since our IIFE returns an object including the two latter functions, those two
    (and only those two) are usable from the outside: this is called the *revealing
    module pattern*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A question: where is the `"Clicks"` value stored, and why isn''t the value
    of `count` lost from call to call? The answer to both questions has to do with
    a well-known JS feature, *closures*, which has been in the language since its
    beginning. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
    for more information on this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed on so far, the following should be clear to you:'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever variables or functions are defined in the module aren't visible or
    accessible from the outside, unless you voluntarily reveal them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever names you decide to use in your module won't conflict with outside
    names because of normal lexical scoping rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The captured variables (in our case, `name`) persist so that the module can
    store information and use it later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All in all, we must agree that IIFEs are a *poor man''s module* and their usage
    is quite common. Browse the web for a bit; you are certain to find examples of
    it. However, ES6 introduced a more general (and clearer and easier to understand)
    way of defining modules, which is what we''ll be using: let''s talk about this
    next.'
  prefs: []
  type: TYPE_NORMAL
- en: Redoing our IIFE module in the modern way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key concept in modules is that you''ll have separate files, each of which
    will represent a module. There are two complementary concepts: importing and exporting.
    Modules will import the features they require from other modules, which must have
    exported them so that they are available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the equivalent of our counter module from the previous
    section, and then comment on the extra features we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: How would we use this module? Let's hold on the explanations about some internal
    aspects and answer that first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module in some other file from our application, we would write
    something as follows, with a new source file that imports the functions that our
    module exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: OK, so using this module to provide a counter isn't so different after all.
    The main difference with the IIFE version is that here, we cannot do an initialization. A
    common pattern to provide this is to export a `init()` function that will do whatever
    is needed. Whoever uses the module must, first of all, call `init()` to set things
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to immediately call the `init()` function, as would happen with
    the IIFE version, and you could delay it until necessary. Also, the `init()` function
    could be called more times in order to reset the module. These possibilities provide
    extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding initialization checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish, you can make the `.init()` function more powerful by having the
    module crash if used without initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In this fashion, we can ensure proper usage of our module. Note that the idea
    of assigning a new function to replace an old one is very typical of the Functional
    Programming style; functions are first class objects that can be passed around,
    returned, or stored.
  prefs: []
  type: TYPE_NORMAL
- en: Using more import/export possibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we exported a single item from our module by using
    what is called a default export: one per module. There is also another kind of
    export, *named* exports, of which you can have several per module. You can even
    mix them in the same module, but it''s usually clearer to not mix them up. For
    example, say you needed a module to do some distance and weight conversions. Your
    module could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: You can have as many definitions as you want, and you can export any of them;
    in our case, we are exporting six functions and one constant. You do not need
    to pack everything into a single `export`; you can have several, as we have already
    shown you. Exports are usually grouped together at the end of a module to help
    a reader quickly find everything that the module exports, but sometimes you may
    find them all throughout the code; we won't be doing that. You can also export
    something in the same line where you define it, as in `export const LENGTH_OF_YEAR_IN_DAYS
    = 365.2422`, but we won't use that style either, for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'When importing a module with named exports, you just have to say which of the
    exports you want. You can import from different modules; you''ll just require
    several `import` statements. It''s a standard practice to group all of them at
    the start of your source file. You can also rename an `import`, as in the case
    of `poundsToKg` in the following code, which we''ll use as `p_to_kg`. In reality,
    you would do this if you had identically named imports from two different modules;
    in our particular example, it doesn''t really make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen how to export JS elements—functions and constants in our
    example—but you could also export classes, objects, arrays, and so on. In the
    next section, we'll get back to Flow, and see how types can also be exported and
    imported.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flow types with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exporting data types (including generics, interfaces, and so on) is quite similar
    to normal exports, except that you must include the word `type`. If you wanted
    to use the conversion type elsewhere, in the original module, you would add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, wherever you wanted to import that type, you would add something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, however, an important detail: you cannot export or import data types
    in the same sentence in which you deal with standard JS elements: `export` and
    `export type` are distinct, separate statements, and so are `import` and `import
    type`.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining a feature's availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To round off this chapter, let me introduce two web tools that can help you
    be aware about what features you can safely use and which will make a transpiler
    (such as `Babel`, which we mentioned at the start of this chapter) necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your first resource will be [https://kangax.github.io/compat-table/](https://kangax.github.io/compat-table/),
    which provides very thorough and complete tables showing, feature by feature,
    what is supported on JS engines everywhere. Depending on your specific needs,
    you might be able to totally dispense with transpiling, but it's certain you should
    be careful before taking such a measure!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Kangax at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52bf1c0f-fdcd-4da4-a707-e985222f7f50.png)'
  prefs: []
  type: TYPE_IMG
- en: The Kangax website lets you determine what features are (or are not) provided
    by browsers, versions of Node, and so on
  prefs: []
  type: TYPE_NORMAL
- en: 'A second web tool that you should be aware of is *Can I use...* at [https://caniuse.com/](https://caniuse.com/).
    In this site, you can search for any feature (be it JS, HTML, or CSS), and you''ll
    get to see what browser versions support it or not. A comment is relevant: this
    site only provides information for desktop and mobile browsers; you cannot see
    if a feature is supported in `Node`, for example. The following screenshot shows *Can
    I use...* at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a5da347-88de-44da-aa06-07052b82694f.png)'
  prefs: []
  type: TYPE_IMG
- en: The *Can I Use...* site lets you find out what browsers support (or don't) a
    given feature
  prefs: []
  type: TYPE_NORMAL
