- en: Using Sets and Maps for Faster Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sets** and **maps** are two notoriously simple-looking data structures, that
    have been standardized in the latest version of ES6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need sets and maps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and how to use sets and maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 API of sets and maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A performance comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the origin of sets and maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we try and understand how to use sets and maps in real-world applications,
    it is more meaningful to understand the origin of sets and maps and why we need
    them in JavaScript in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditional arrays, until ES5, did not support a few major features, that developers
    usually want to leverage:'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledging that it contains a particular element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new elements without having duplicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This led to developers implementing their own versions of sets and maps,which
    were available in other programming languages. A common implementation of a set
    and map using JavaScript''s `Object` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Although a lot of prototype headaches can be avoided by using`Object.create`to
    create the set or map*, *it still does not resolve the fact that the main `Key`that
    is being held can only be a `string` because `Object`only allows keys as strings,
    so we could unintentionally end up with values overwriting each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing set and map types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before actually using sets and maps,we will need to understand when and where
    we need to use them. Each data structure whether native or custom has its own
    strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is it important to utilize these strengths, it's much more important
    to avoid their weaknesses. To understand some of these, we will explore set and
    map types and why they are needed and where to employ them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are primarily four different set and map types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map**: A key-value pair in which the key can either be an `Object` or a primitive
    and can hold any arbitrary value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WeakMap**: A key-value pair in which the key can only be an `Object` and
    can hold any arbitrary value. The Keys are weakly referenced; this means that
    they are not prevented from being garbage-collected if not in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**: Data type that allows a user to store unique values of any type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WeakSet**: Similar to set, but maintains a weak reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How weak is WeakMap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we all know what a map is and how to add keys and values, at least in
    theory. However, how do you determine when to use a map and when to use a `WeakMap`?
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official definition of a `WeakMap` as per MDN ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap))
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The WeakMap object is a collection of key/value pairs in which the keys are
    weakly referenced. The keys must be objects and the values can be arbitrary values.
  prefs: []
  type: TYPE_NORMAL
- en: The key emphasis is on *weakly referenced. *
  prefs: []
  type: TYPE_NORMAL
- en: Before comparing `Map` and `WeakMap`*,* it is crucial to understand when to
    use a particular data structure. If you need to know the keys of the collection
    at any time or if you need to iterate over your collection, then you will need
    to use a `Map` over a `WeakMap` because keys are not enumerable, that is, you
    cannot get a list of the keys available in the latter, as it only maintains a
    weak reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, naturally, the preceding statement should raise two questions in your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if I always use a map?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing really, life goes on. You may or may not end up with memory leaks, depending
    on how well you have used your map. For the most part, you will be fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a weak reference?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A weak reference is something that allows everything an object refers to be
    garbage-collected in the event all the referrers are removed. Confused? Good.
    Let''s take a look at the following example to understand it better:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We all know that the IIFE is primarily used so that we can immediately execute
    a function and remove its scope so that we can avoid memory leaks. In this case,
    although we have wrapped the `key` and map setter in an IIFE, the `key`does not
    get garbage-collected because internally the `Map`still holds a reference to the
    `key` and its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the same code is written with a `WeakMap`*, *once the IIFE is executed,
    the key and the value of that key are removed from memory because the key is taken
    out of scope; this helps to keep memory usage to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: API differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API for `Map` and `WeakMap` is very similar when it comes to standard operations,
    such as `set()` and `get()`. This makes the API very straightforward and contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map.prototype.size`: Returns the size of the map; not available on typical
    objects unless you loop and count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.set`: Sets a value for a given key and returns the entire new
    map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.get`: Gets a value for a given key and returnsundefined if not
    found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.delete`: Deletes a value for a given key and returns `true`
    if deletion was successful, otherwise `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.has`: Checks the map for the presence of an element with the
    key provided; returns boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.clear`: Clears the map; returns nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.forEach`: Loops over the map and gives access to each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.entries`: Returns an iterator on which you can apply the `next()`
    method to get the value of the next element in `Map`, for example, `mapIterator.next().value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.keys`: Similar to `entries`*;* returns an iterator that can
    be used to get access to the next value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.prototype.values`: Similar to `key`; returns access to values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference comes in when accessing anything related to keys and the
    values for a `WeakMap`*. *As described earlier, because of the enumeration challenge
    in case of the `WeakMap`, methods such as `size()`, `forEach()`, `entries()`,
    `keys()`, and `values()` are not available in  `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Sets versus WeakSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we understand the fundamental meaning of weakin the term `WeakMap` or `WeakSet`*. *It
    is not very complex to predict how sets work and how `WeakSet` differs from them.
    Let's take a quick look at the functional difference and then move on to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WeakSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WeakSet` is very similar to `WeakMap`; the values that a `WeakSet` can hold
    are only objects and cannot be primitives just like in the case of a `WeakMap`.
    The `WeakSets` are also not enumerable, so you do not have direct access to the
    values available inside the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small example and understand the difference between a `Set`
    and a `WeakSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note is that `WeakSet` does not accept primitives and
    can only accept objects similar to the `WeakMap` keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows, which is what was expected
    from the `WeakSet`. `WeakSet` does not retain elements beyond the lifespan of
    the variables that were holding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ccaeefe6-894e-48df-bc1b-b094d0e96b30.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `WeakSet` is empty once the IIFE is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The API difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API difference as documented in `WeakMap` case of maps is pretty close
    to what you can find for Sets as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set.prototype.size`: Returns the size of the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.add`: Adds a value for a given element and returns the entire
    new set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.delete`: Deletes an element and returns `true` if delete was
    successful, otherwise `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.has`: Checks the set for the presence of an element and returns
    a Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.clear`: Clears the set and returns nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.forEach`: Loops over the set and gives access to each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.values`: Returns an iterator, which can be used to get access
    to the next value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.prototype.keys`: Similar to values—returns access to values in the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakSet`, on the other hand, does not contain the `forEach()`*,* `keys()`,
    and `values()` methods for reasons discussed previously.'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start off with use cases, let's create a base application, that will
    be reused for each of the examples just like we did in [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section is a quick recap of creating a base Angular application:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on to the individual use cases, we will first create the Angular
    application which will work as the base for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the given commands to get up and running with the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Angular CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new project in the folder of your choice by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After these two steps, you should be able to see the new project created and
    all the corresponding node modules installed and ready to go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run your application, run the following command from a Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom keyboard shortcuts for your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, creating a web application means having a beautiful UI with unobstructed
    data. You want your user to have a fluid experience without having to go through
    the hassle of clicking through multiple pages, which can become quite a hassle
    sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: Take any IDE, for example. As useful as they are and as easy as they make our
    lives on a day-to-day basis, imagine not having simple shortcuts in them, such
    as code indentation. Sorry for the scare, but it is true that having minor details
    like these can make the user experience very fluid, making users come back for
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a simple set of keyboard shortcuts that you can provide to
    your application to make things a lot easier for your end user. To create this,
    you will need the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A web application (we created one earlier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of features, which you want to be able to control with the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation simple enough to make adding new features to it very simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you remember the *custom back button *from [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*, we are going to create an
    application that is something similar. Let's quickly put together the example
    application again. For detailed instructions, you can follow the same example (Creating
    an Angular Application) from [Chapter 1](4928ea27-d6a2-4af4-ae80-95fd912a800d.xhtml),
    *Building Stacks for Application State Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create multiple states (About, Dashboard, Home, and Profile) with basic templates
    under `src/pages` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the routing for that state under `<component_name>.routing.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new `routes` and `Components` to the application''s main routing file
    `app.routing.ts` next to `app.module.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the routes with your application using `RouterModule` and declare
    your `navigatableComponents`in the `app.module.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the HTML template to load the four routes in `app.component.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have performed all the steps listed previously, run the following
    command in your Terminal; the web app should be up-and-running with four states
    for you to toggle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating states with keymap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, what we have declared in the states (or routes) is the path and the
    component that we want to go with them. What Angular does allow us to do is add
    a new property called **data**to the route configuration. This allows us to add
    any data that we would like regarding any route. In our case, it works out very
    well because we want to be able to toggle routes based on the keys a user presses.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take an example route that we have defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now modify this and add the new `data` property to the route configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have added a property called `keymap` and its value `ctrl+h`;
    we will do the same for all the other routes defined as well. One important thing
    to nail down in the very beginning is the anchor key (`ctrl`, in this case) that
    is going to be used alongside a secondary identifying key (`h` for the home route).
    This really helps filter down key presses that the user may making within your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the keymaps associated with each of the routes, we can register
    all of these keymaps when the app loads and then start tracking user activity
    to determine whether they have selected any of our predefined keymaps.
  prefs: []
  type: TYPE_NORMAL
- en: To register the keymaps, in the `app.component.ts`file, we will first define
    the `Map` in which we are going to hold all the data and then extract the data
    from the routes before adding it to `Map`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data is added to the `keyMap`, we will need to listen to user interactions
    and determine where the user wants to navigate. To do that, we can use the `@HostListener` decorator
    provided by Angular, listen for any keypress events, and then filter item down
    based on the application''s requirements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There we have it! We can now define and navigate to routes easily whenever a
    user makes a keypress. However, before we move on, we will need to take another
    perspective here to understand the next step. Consider you are the end user and
    not the developer. How do you know what the bindings are? What do you do when
    you want to bind not just the routes on a page but also the buttons? How do you
    know whether you are pressing the wrong keys?
  prefs: []
  type: TYPE_NORMAL
- en: All of this can be fixed with a very simple UX review of what we have so far
    and what we need instead. One thing that is clear is that we need to show the
    user what they are selecting so that they do not keep pounding our application
    with incorrect key combinations.
  prefs: []
  type: TYPE_NORMAL
- en: First, to inform our users of what they can select, let's modify the navigation
    in such a way that the first character of each of the route names is highlighted.
    Let's also create a variable to hold the value that the user is selecting, display
    that on the UI, and clear it out after a few milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify our `app.component.scss`to that effect, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our template gets an addition at the very end to show the key the user has
    pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `app.component.ts` in its final form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This way, the user is always informed of their options and what they are selecting,
    making the overall usability of your application a lot higher.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd9059e2-55a9-491f-af36-38ca734c80db.png)'
  prefs: []
  type: TYPE_IMG
- en: Irrespective of what the user selects, they will always see their selection
    at the bottom-right side of the screen as long as the *Ctrl* key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Activity tracking and analytics for web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever someone mentions analytics, especially for web applications, the first
    thing that usually comes to mind is something such as Google analytics or new
    relic. Although they do an amazing job at collecting analytics, such as page views
    and custom events, these tools keep the data with them and do not let you download/export
    the raw data. It becomes necessary to build your own custom modules to track user
    actions and activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity tracking and analytics are complex and can quickly get out of hand
    with growing application size. In this use case, we will build a simple web application
    in which we will be tracking custom actions that a user is taking and lay down
    some groundwork for syncing application data with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into coding, let's discuss briefly what our approach is going
    to be and how we are going to take advantage of the Angular components that are
    available to us. In our application, we will build a basic form for the user,
    which they get to fill out and submit. As and when the user interacts with the
    different components available on the form, we will start tracking the user activity
    and then extract some custom data based on the events generated. This custom data
    is obviously going to change based on the application that is being built. For
    brevity, we will simply track the time of the event, the *x* and *y* coordinates,
    and custom values (if any).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create an Angular application like we did in the preceding use
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create the app and it should be ready to go. Just go into your
    project folder and run the following command to see your app running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the application is up, we will include Angular material just so we can
    quickly have a nice form up and running. To install material in your Angular application,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `material` is installed, include the module of your choice in your main
    `app.module.js`*, *which, in this case, is going to be `MatInputModule `and `ReactiveFormsModule`
    because we will need them to create the forms. After this, your `app.module.js`
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the application set up, we can set up our template, which
    is going to be fairly straightforward, so let us add the following template to
    our `app.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple form with standard fields for user details; we will style
    it a little bit so that it''s centered on the page so we can update our `app.component.scss`
    file to contain our styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the end result on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aac34955-40d0-4a7a-b6b1-81464b9d5560.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the form ready, we want an activity tracker, which is going
    to be extremely lightweight as we will be calling this quite frequently.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice is to have the tracker logic moved into a web worker; that way,
    your tracker will not take up the only available thread, thus freeing up your
    application from any extra load.
  prefs: []
  type: TYPE_NORMAL
- en: Before we actually start creating a web worker, we will need something to invoke
    our worker; for this, we will create a tracker service. Also, to make the worker
    includable in an Angular project, we will add it to the `scripts` option of the
    `.angular-cli.json` file, which will allow us to use this as an external script
    called `scripts.bundle.js `which is generated from the file `utils/tracker.js`
    by `webpack.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a folder called `tracker` under a folder called `services`, then
    create a `tracker.service.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Nothing out of the ordinary here; we initialized the worker when we triggered
    the service and added an `addEvent()` method, which takes in a few parameters
    such as the name of the event (key), the event data (or parts of it), and custom
    values (if any). The rest of the logic we defer to the worker so that our application
    is seamless.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to trigger the constructor of the service, we will need to add the
    service to the providers of the main module. So, our `app.module.ts` now updates
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, we now have the application bootstrapped and the worker set up. However,
    what is actually calling the `addEvent()` method to track these custom events?
    You can do one or both of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject the `TrackerService` into your component/service and call the `addEvent()`
    method with the right parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a directive to capture clicks and sync data using the `addEvent()` method
    on the `TrackerService`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will take the second approach for this example as we have a form and do
    not want to add a click handler to each and every element. Let''s create a `directives` folder and
    another folder called `tracker`, which will contain our `tracker.directive.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the directive is pretty lean; it injects the `TrackerService`
    and then triggers the `addEvent()` method on a click.
  prefs: []
  type: TYPE_NORMAL
- en: 'To consume this, all we need is to add the directive to the input elements
    on the form that we created earlier, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the user interacts with any field on the form, our worker is notified
    of the change, and it's now up to our worker to basically batch the events and
    save them on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly recap what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We set up the worker and invoked it via the constructor of our `TrackerService`,
    which gets instantiated on app start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We created a simple directive capable of detecting clicks, extracting event
    information, and passing it on to the `TrackerService` to be forwarded to our
    worker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0029140d-ddc4-4378-a13e-3bfb18339ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the directory structure of the application so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step will be to update our worker so that we can easily handle the
    data that is coming in and send it to the server based on whatever logic your
    application sees fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break this worker under `utils/tracker.js` down into simple steps it''s
    made up of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker receives the message from the `TrackerService`, and this message is
    then forwarded to be added to the master list of events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will do something different here by maintaining two lists, one for just the
    keys that are being saved and another that maps the keys to the collection of
    data that we are receiving.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addEvent()` method then decomposes the incoming data and stores it in
    a master list of items being collected to be synced up with the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will try to check whether the user has already interacted with the provided
    key's element. If that's true, we will just append it to the existing collection
    of events; otherwise, we will create a new one. This check is where we leverage
    setsand their extremely fast `has()` method, which we will explore in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, the only logic that we will need now is to sync this data with
    the server based on predetermined logic. As you can see, right now we are just
    doing this based on a random number but, of course, that is not recommended for
    a production application. What you can do instead is learn based on how much your
    user is interacting with the application, and sync accordingly. For some application
    tracking services, this is way too much, so they go with the simpler approach
    of either syncing at a regular interval (in the order of a few seconds) or syncing
    based on the payload size. You can take up any of these approaches as your application
    demands.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, once you have that nailed down, everything is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: One peculiar thing to note here is the way we are transforming data to an array
    before we send it to the server. Could we have just passed the entire `sessionData` here?
    Perhaps, but it's a Map, which means the data is not accessible as-is and you
    would have to use `.entires()` or `.values()` to get an Iterator Object on which
    you can iterate to get the data from the map. Having worked with arrays a lot,
    it may seem a little backward to have to transform data before sending it to the
    server, but it's well worth the effort given the other benefits that Maps provide
    to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how it all comes together in our `tracker.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can note in the preceding code, sets and mapssilently, yet effectively,
    change how we designed our application. Instead of having a simple array and an
    object, we will actually get to use some concrete data structures with fixed set
    of APIs, which allows us to simplify our application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Performance comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will compare the performance of sets and maps against their
    counterparts: arrays and objects. As mentioned in earlier chapters, the main goal
    of doing a comparison is not to know that the data structures are superior to
    their native counterparts but to understand their limitations and ensure that
    we make an informed decision when trying to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to take benchmarks with a grain of salt. Benchmarking tools
    often use engines such as V8, which are built and optimized to run in a way that
    is very different from some other web-based engines. This may cause the results
    to be a little skewed based on the environment in which your application runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to do some initial set up to run our performance benchmark. To
    create a Node.js project, go to a Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set up an empty directory; now, go into the directory and run the
    `npm` initialization command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This step will ask you a series of questions, and all of them can be filled
    out or left blank, as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is set up, next we will need the benchmarking tool, which
    we can install using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to start running some benchmark suites.
  prefs: []
  type: TYPE_NORMAL
- en: Sets and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating and running suites is very easy thanks to the `benchmark` tool. All
    we will need is to set up our `sets-arr.js` file, and we are good-to-go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the setup is pretty self-explanatory. Once we create the new
    `suite`, we set up some data for the initial load and then we can add our tests
    to the `suite`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this `suite`, you can run the following command from a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the `suite` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7e351e82-f7b2-45cc-87a9-871f22b5b482.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the sets are a little faster than the arrays in this setup. Of course,
    the data that we are using in the tests can also cause variations in the results;
    you can try this out by switching between the data types that are being stored
    in the array and the set.
  prefs: []
  type: TYPE_NORMAL
- en: Maps and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have a similar setup for Maps and Objects in a file called `maps-obj.js`,
    which will give us something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run this `suite`, run the following command on a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/937b1b92-e459-4b9f-b9af-75dd595ea39c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the `Object` hugely outperforms the map and is clearly the
    better of the two here, but it does not provide the syntactical sugar and some
    features that the map is capable of.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into sets and maps, their weaker counterparts, and
    their APIs. Then, we used sets and maps in few real-world examples such as applications
    with keyboard shortcuts for navigation powered by sets and an application analytics
    tracker powered by sets and maps. Then, we concluded the chapter with a performance
    comparison between objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be exploring trees and how we can leverage them
    to make our web applications faster with reduced code complexity.
  prefs: []
  type: TYPE_NORMAL
