- en: '*Chapter 14*: Using Dual Quaternions for Skinning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current skinning implementation blends between skin weights linearly, and
    this is called **Linear Blended Skinning (LBS)** or, sometimes, **Linear Skin
    Blending**. Linearly blending the skin does not preserve the volume of a model,
    which introduces skinning artifacts. An easy way to visualize this artifact is
    to twist one end of a rectangle by 180 degrees, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: Comparing linear blended and dual quaternion skinning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: Comparing linear blended and dual quaternion skinning'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate to Linear Skin Blending is **Dual Quaternion Skin Blending**.
    When dual quaternions are used, the volume of the model is maintained. In this
    chapter, you will implement dual quaternion mesh skinning. By the end of this
    chapter, you should be able to use dual quaternions to skin an animated character.
    The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing dual quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing dual quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skinning with dual quaternions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use dual quaternion skinning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing dual quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dual quaternion combines linear and rotational transformations together into
    one variable. This single variable can be interpolated, transformed, and concatenated.
    A dual quaternion can be represented with two quaternions or eight floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Dual numbers are like complex numbers. A complex number has a real part and
    an imaginary part, and a dual number has a real part and a dual part. Assuming
    ![](img/Formula_14_001.png)is the dual operator, a dual number can be represented
    as ![](img/Formula_14_002.png), where ![](img/Formula_14_003.png) and ![](img/Formula_14_004.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations on dual numbers are done as imaginary numbers, where the dual components
    and real components must be acted on separately. For example, dual quaternion
    addition can be expressed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_14_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the real and dual parts are added independently.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in the more formal mathematics behind dual quaternions,
    check out *A Beginner's Guide to Dual-Quaternions* by Ben Kenwright, [at https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion](https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion.pdf).pdf.
  prefs: []
  type: TYPE_NORMAL
- en: Dual quaternions are just an extension of dual numbers. The real and dual parts
    are represented by quaternions instead of scalar values, and most of the mathematical
    operations just work. In the next section, you will begin to implement dual quaternions
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dual quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will implement dual quaternions in code. By the end of
    this section, you will have implemented a dual quaternion struct, along with all
    the mathematical functions needed for using dual quaternions to skin a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Dual quaternions need to be implemented as structures, similar to transforms
    or matrices. Create two new files, `DualQuaternion.h` and `DualQuaternion.cpp`.
    You will implement the math relevant to dual quaternions in these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by declaring a `DualQuaternion` structure. This structure will allow
    you to access the data in the dual quaternion struct as two quaternions or a floating-point
    array of eight numbers. The constructor should set the dual quaternion to identity.
    The identity dual quaternion has an identity quaternion in its real part and a
    zero quaternion in its dual part, as illustrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The real part of a dual quaternion holds rotation data, and the dual part holds
    position data. Dual quaternions do not handle scaling. In the following section,
    you will declare and implement common dual quaternion operations such as addition
    and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Implementing dual quaternion operations* subsection, you will implement
    trivial dual quaternion operators such as addition, scaling, multiplication, and
    comparison operators. In the *Measuring, normalizing, and inverting dual quaternions*
    section, you will learn how to implement the dot product for a dual quaternion,
    how to measure the dual quaternion, and how to invert it. In the *Converting transforms
    and dual quaternions* section, you will learn how to convert between the `DualQuaternion`
    and `Transform` structs. Finally, in the *Transforming vectors and points* section,
    you will learn how to transform vectors and points with dual quaternions, as transforms
    or matrices would.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dual quaternion operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to define some mathematical operators to work with dual quaternions.
    These functions are addition, scalar multiplication, dual quaternion multiplication,
    and equality comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two dual quaternions are combined through multiplication. Unlike matrices and
    quaternions, dual quaternions multiply left to right. Follow these steps to implement
    the dual quaternion operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the addition, scalar multiplication, dual quaternion multiplication,
    and equality comparison operators in `DualQuaternion.h`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the addition, scalar multiplication, and comparison functions. They
    are all component-wise operations. Perform component-wise operations separately
    on the real and dual components of the dual quaternion, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Start implementing dual quaternion multiplication by first making sure both
    dual quaternions are normalized, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the real parts of both the normalized quaternions together. The dual
    parts are more involved because![](img/Formula_14_006.png) must equal `0`. Satisfy
    this requirement by multiplying the dual and real sides of both quaternions and
    adding the results, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the most part, the common dual quaternion operators are intuitive, but the
    multiplication order of dual quaternions being against convention makes them a
    little hard to deal with. In the next section, you will learn about the dot product
    and normal implementations for dual quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring, normalizing, and inverting dual quaternions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot product measures how similar two dual quaternions are. The rules for
    the dual quaternion dot product are the same as the vector and quaternion dot
    products. The result of the dot product is a scalar value that has the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is positive if the dual quaternions point in the same direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is negative if the dual quaternions point in opposite directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is zero if the dual quaternions are perpendicular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-unit dual quaternions can introduce an unwanted skew into the transformation
    represented by a dual quaternion. To normalize a dual quaternion, both the real
    part and dual part will need to be divided by the length of the real part.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing a dual quaternion is like normalizing a regular quaternion, operating
    mainly on the real part. First, find the length of the real part of the dual quaternion,
    then divide both the real and dual parts by the length. This normalizes both the
    real and dual parts to the length of the real part.
  prefs: []
  type: TYPE_NORMAL
- en: Since the dot product only considers direction, the imaginary part of the dual
    quaternion is not used. Find the dot product of the real parts of both dual quaternions.
    The dual quaternion `conjugate` operation is an extension of quaternion conjugates,
    to find the conjugate of both real and dual parts respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the `dot product`, `invert`, and `normalize`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the dual quaternion dot product, conjugate and normalization functions
    in  `DualQuaternion.h`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the dot product by finding the quaternion dot product of the real
    parts of both dual quaternions and returning their result, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `conjugate` function by taking the quaternion conjugate of the
    real and dual parts separately, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `normalized` function by finding the length of the real part
    and scaling both the dual and real parts by the inverse of the length, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a `normalize` function. Unlike `normalized`, the `normalize` function
    takes a dual quaternion reference and normalizes it in place, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If a dual quaternion changes over time, it might become non-normalized due to
    a floating-point error. If the length of the real part of the dual quaternion
    is not `1`, the dual quaternion needs to be normalized. Instead of checking the
    length against one, which would involve a square root operation, you should check
    if the square length is `1`, and this way, the operation is much faster. In the
    following section, you will learn how to convert between transforms and dual quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Converting transforms and dual quaternions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dual quaternions hold similar data to transforms, without the scale component.
    It's possible to convert between the two, but the scale will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: When converting a transform to a dual quaternion, the real part of a dual quaternion
    maps to the rotation of a transform. To calculate the dual part, create a pure
    quaternion from the translation vector of the transform. Then, multiply this pure
    quaternion by the rotation of the transform. The result needs to be halved—divide
    it by two or multiply it by 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: When converting a dual quaternion to a transform, the transform rotation still
    maps the real part of the dual quaternion. To find the position, multiply the
    dual part by two and combine the result with the inverse of the transform's rotation.
    This yields a pure quaternion. The vector part of this pure quaternion is the
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the code to convert between `Transform` and
    `DualQuaternion` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare functions to convert a dual quaternion to a transform and a transform
    to a dual quaternion in `DualQuaternion.h`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `transformToDualQuat` function. The resulting dual quaternion
    does not need to be normalized. The code for this can be seen in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `dualQuatToTransform` function. The input dual quaternion is
    assumed to already be normalized. The code for this can be seen in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Dual quaternions can be converted to and from matrices as well; however, that
    operation is generally not used. Dual quaternions are used to replace matrices
    in the skinning pipeline, so the matrix conversion isn't necessary. In the following
    section, you will explore how a dual quaternion can transform a vector or a point.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming vectors and points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dual quaternions contain rigid transformation data. This means that dual quaternions
    can be used to transform vectors and points. To transform a point by a dual quaternion,
    break the dual quaternion down into rotation and position components, then transform
    the vector the same way a transform would, but without scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to declare and implement `transform` functions for both
    vectors and points using dual quaternions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `transformVector` and `transformPoint` functions in `DualQuaternion.h`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotating a vector by a dual quaternion is trivial. Since the real part of the
    dual quaternion contains the rotation, multiply the vector by the real part of
    the dual quaternion, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To transform a point by a dual quaternion, convert the dual quaternion to rotation
    and translation components. Then, apply the following translation and rotation
    components to the vector: `rotation * vector + translation`. This formula works
    the same way as a transform moving the point, but without a scale component. The
    code for this can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The dual quaternion class can now be used in place of the `Transform` class.
    Dual quaternions can be arranged in a hierarchy and combined using multiplication,
    and with these new functions, a dual quaternion can transform a point or a vector
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you implemented dual quaternions in code. All the functions
    that you will need to work with dual quaternions are implemented as well. In the
    next section, you will learn how to do mesh skinning using dual quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Skinning with dual quaternions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to modify the skinning algorithm so that
    it works with dual quaternions instead of matrices. Specifically, you will replace
    the skin matrix with a skin dual quaternion that will transform both the vertex
    position and normal position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem dual quaternions solve is the linear blending of matrices, which
    is currently implemented in a vertex shader. Specifically, this is the bit of
    code that introduces the skinning artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three stages in the animation pipeline where it makes sense to replace
    matrices with dual quaternions. Each of these will have the same result. The three
    places where this should be implemented are listed here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the matrices to dual quaternions in the vertex shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the matrices of the current pose to dual quaternions, then pass dual
    quaternions to the vertex shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert each transform of the current pose to a dual quaternion, then accumulate
    the world transform as a dual quaternion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, you will implement the third option and add a `GetDualQuaternionPalette`
    function to the `Pose` class. You will also add an overload for the `GetInvBindPose`
    function of the `Skeleton` class. In the following section, you will begin to
    modify the `Skeleton` class to support dual quaternion skinned animation.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the pose class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Pose` class needs two new functions—one to retrieve the world dual quaternion
    of a specified joint (that is, `GetGlobalDualQuaternion`), and one to convert
    the pose to a dual quaternion palette. Follow these steps to declare and implement
    these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add declarations for the `GetDualQuaternionPalette` and `GetGlobalDualQuaternion`
    functions to the `Pose` class in `Pose.h`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetGlobalDualQuaternion` function to return the world space
    dual quaternion of a joint, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetDualQuaternionPalette` function, which should loop through
    all the joints stored in the current pose and store their world space dual quaternions
    in the output vector, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The dual quaternion conversion happens in joint local space, and because of
    this, you didn't need to add any additional data to the `Pose` class and were
    able to add two new functions instead. In the next section, you will modify the
    `Skeleton` class to provide the inverse bind pose as dual quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the skeleton class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to skin a mesh using dual quaternions, the inverse bind pose of the
    mesh will need to be expressed using dual quaternions as well. In this section,
    you will add an overload to the `GetInvBindPose` function that will fill out a
    reference to a vector of dual quaternion objects. Follow these steps to implement
    the new `GetInvBindPose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an additional `GetInvBindPose` function in the `Skeleton` class that
    will take a reference to a vector of dual quaternions as an argument. When the
    function is finished, it will have filled out the vector with inverse bind pose
    dual quaternions. The code for this can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetInvBindPose` function override in `Skeleton.cpp`. Resize
    the input vector to be as large as the bind pose. For each joint, get the global
    dual quaternion representation of the joint. Finally, store the conjugate of each
    world space dual quaternion in the output vector. The code for this can be seen
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can now convert both an animated pose and the inverse bind pose of a skeleton
    into arrays of dual quaternions. But in order to use these dual quaternions in
    a shader, they need to be passed to that shader somehow. In the following section,
    you will implement a new dual quaternion uniform type to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new uniform types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use dual quaternions as a replacement for matrices, there needs
    to be a way to use them as shader uniforms. A dual quaternion can be treated as
    a 2x4 matrix, which can be set with the `glUniformMatrix2x4fv` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a template specialization for the `Uniform` class using a `DualQuaternion`.
    The `Set` function needs to be implemented. It should use the `glUniformMatrix2x4fv`
    function to upload the dual quaternion array as a 2x4 matrix. Implement the new
    `Set` function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Set` function is templated, it does not need to be declared in the
    header file; it's just a specialized instance of the function. In the following
    section, you will explore how to implement a vertex shader that uses dual quaternions
    for skinning.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dual quaternion shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing left to do in order to support dual quaternion skinning is to
    implement a vertex shader. The new vertex shader will be similar to its linear-blended
    skinning counterpart. Instead of having two `mat4` uniform arrays for the matrix
    palettes, this shader will have two `mat2x4` uniform arrays for dual quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: The shader will have to blend dual quaternions together. Whenever two quaternions
    (the real part of the dual quaternions) are blended, there is a chance that the
    blend happens in the wrong neighborhood and the quaternion interpolates the long
    way around. Neighborhooding will need to be kept in mind when blending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the new vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start declaring the shader with the `model`, `view`, and `projection` uniforms,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the vertex structure. The input values for a vertex are as follows:
    `position`, `normal`, texture coordinates, and weight and joint influences. Each
    vertex should have up to four weights and influences. The code for this can be
    seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the output values passed to the fragment shader. These are the vertex
    normal, the fragment position in the world space, and the `uv` coordinate, as
    illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the skinning uniforms. These are no longer arrays of `mat4`; they are
    now arrays of `mat2x4`. A `mat2x4` has two columns with four rows. Subscripting
    a `mat2x4`, index `0` is the real part of our dual quaternion, and index `1` is
    the dual part. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a quaternion multiply function. The code for this is the same as
    that created in [*Chapter 4*](B16191_04_Final_JC_ePub.xhtml#_idTextAnchor069),
    *Implementing Quaternions*, and can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `normalize` dual quaternion function. A dual quaternion is normalized
    by dividing both its real and dual parts by the magnitude of the real part. The
    code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the dual quaternion multiplication function to combine dual quaternions,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a function to transform vectors by dual quaternions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a function to transform points by dual quaternions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main method of the vertex shader. Start the implementation by
    neighborhooding joints 1, 2, and 3 (`joints.y`, `joints.z`, `joints.w`) to joint
    0 (`joints.x`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the world space dual quaternion of each joint with the inverse bind
    pose dual quaternion of the same joint. Remember: dual quaternion multiplication
    is left to right. Store the result of each multiplication in a new variable. The
    code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Blend the four skinning dual quaternions together. Implement the blend using
    dual quaternion scalar multiplication and dual quaternion addition. Don''t forget
    to normalize the skin dual quaternion. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Skin the vertex using the `transformPoint` function with the skin dual quaternion.
    Put the resulting `vec4` through the normal model-view-projection pipeline, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the normal similarly. Don''t forget to pass the `uv` coordinates
    to the fragment shader as well. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Any animation that animates scale will not work with this method. This dual
    quaternion implementation does not have scaling support. It is possible to hack
    scaling support on top of dual quaternions, but the work involved outweighs its
    benefits in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to implement skinning with dual quaternions.
    This includes modifying pose data and the `Skeleton` class, creating new uniforms,
    and building a new shader. In the following section, you will explore how to use
    the dual quaternion code written up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to use dual quaternion skinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will explore how you can take the dual quaternion skinning code
    that you have written so far and implement it in an existing application. This
    code is meant to be for reference only; you do not have to follow along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dual quaternion-skinned shader is trivial; it would be easy to switch
    between skinning methods at runtime. The following steps demonstrate how the dual
    quaternion shader or a linear-skinned shader could be used to animate the same
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep track of both the dual quaternion pose palette and inverse bind pose palette,
    as well as the linear blend pose palette and inverse bind pose palette. Have a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application initializes, cache the inverse bind pose both as a vector
    of matrices and a vector of dual quaternions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When an animation is sampled, convert the resulting pose palette to both dual
    quaternion and linear blend versions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the animation is being rendered, make sure that the correct uniforms are
    used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, switching between the linear blended skinning and the dual quaternion
    skinning shaders is as simple as changing the value of the `mSkinningMethod` variable.
    This works because the only difference between the two shaders is the pose palette
    uniforms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the math behind dual quaternions and implemented
    a dual quaternion class. You discovered some of the skinning artifacts that can
    result from linear blend skinning and how dual quaternions can be used to avoid
    these artifacts. The dual quaternion skinning shader you implemented in this chapter
    can be used to replace the linear blend skinning shader.
  prefs: []
  type: TYPE_NORMAL
- en: If you look under `Chapter14` in the downloadable materials for this book, there
    are two samples. `Sample00` contains all the code up to this point. `Sample01`
    renders the same twisting cube model twice. The first cube is rendered with a
    linear blend skinning shader. The second one is rendered with a dual quaternion
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore how indexed drawing can be used to animate
    large crowds. This is interesting because it involves moving pose generation to
    the **graphics processing unit** (**GPU**) and performing the entire skinned animation
    pipeline in a vertex shader.
  prefs: []
  type: TYPE_NORMAL
