- en: Debunking Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: '"If I had asked people what they wanted, they would have said faster horses."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我问人们他们想要什么，他们会说更快的马。”
- en: – Henry Ford
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亨利·福特'
- en: Whether you are a tech lead, developer, or a tech savant eager to adapt to new
    modern web standards, the preceding line represents your current life situation
    in a nutshell. Today's mantra for the successful business, fail quickly, fix and
    rise soon, quicker delivery, frequent changes, adaption to changing technologies,
    and fault-tolerant systems are some of the general daily requirements. For the
    very same reason, during recent times, the technology world has seen a quick change
    in architectural designs that have led industry leaders (such as Netflix, Twitter,
    Amazon, and so on) to move away from monolithic applications and adopt microservices.
    In this chapter, we will debunk microservices and study their anatomy, and learn
    their concepts, characteristics, and advantages. We will learn about microservice
    design aspects and see some microservice design patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是技术负责人、开发人员还是渴望适应新的现代网络标准的技术专家，上述内容都概括了您当前的生活状况。今天成功业务的口号是，快速失败，快速修复和迅速崛起，更快的交付，频繁的变化，适应不断变化的技术和容错系统是一些日常要求。出于同样的原因，最近技术世界已经看到了架构设计的快速变化，这导致行业领袖（如Netflix、Twitter、亚马逊等）放弃了单片应用程序，转向了微服务。在本章中，我们将揭秘微服务，研究它们的解剖学，并了解它们的概念、特点和优势。我们将了解微服务设计方面，并了解一些微服务设计模式。
- en: 'In this chapter, we will talk about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Debunking microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: Key considerations for microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的关键考虑因素
- en: Microservice FAQs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务常见问题解答
- en: How microservices satisfy the twelve-factors of the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务如何满足应用程序的十二因素
- en: Microservices in the current world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前世界的微服务
- en: Microservice design aspects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计方面
- en: Microservice design patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: Debunking microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: The core idea behind microservice development is if the application is broken
    down into smaller independent units, with each group performing its functionality
    well, then it becomes straightforward to build and maintain an application. The
    overall application then just becomes the sum of individual units. Let's begin
    by debunking microservices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发的核心思想是，如果应用程序被分解为更小的独立单元，每个组都能很好地执行其功能，那么构建和维护应用程序就变得简单。整体应用程序只是各个单元的总和。让我们开始揭秘微服务。
- en: Rise of microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的崛起
- en: Today's world is evolving exponentially, and it demands an architecture that
    can satisfy the following problems that made us rethink traditional architecture
    patterns and gave rise to microservices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的世界正在呈指数级增长，并且需要一种能够满足以下问题的架构，这些问题使我们重新思考传统的架构模式，并催生了微服务。
- en: Wide selection of languages as per demand
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需求选择多种语言
- en: There is a great need for technological independence. At any point in time,
    there is a shift in languages and adoption rates change accordingly. Companies
    such as Walmart have left the Java stack and moved towards the MEAN stack. Today's
    modern applications are not just limited to the web interface and extends its
    need for mobile and smartwatch application too. So, coding everything in one language
    is not at all a feasible option. We need an architecture or ecosystem where multiple
    languages can coexist and communicate with each other. For example, we may have
    REST APIs exposed in Go, Node.js, and Spring Boot—a gateway as the single point
    of contact for the frontend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术独立性的需求非常迫切。在任何时候，语言和采用率都会发生变化。像沃尔玛这样的公司已经放弃了Java堆栈，转向了MEAN堆栈。今天的现代应用程序不仅仅局限于网络界面，还需要移动和智能手表应用程序。因此，用一种语言编写所有内容根本不是可行的选择。我们需要一种架构或生态系统，可以让多种语言共存并相互通信。例如，我们可以在Go、Node.js和Spring
    Boot中暴露REST API，一个网关作为前端的单一联系点。
- en: Easy handling of ownership
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易于处理所有权
- en: Today's applications not only include a single web interface, but go beyond
    into mobiles, smart watches, and **virtual reality** (**VR**). A separation of
    logic into individual modules helps to control everything as each team owns a
    single unit. Also, multiple things should be able to run in parallel, hence achieving
    faster delivery. Dependencies between teams should be reduced to zero. Hunting
    down the right person to get the issue fixed and get the system up and running
    demands a microservice architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的应用程序不仅包括单一的网络界面，还涉及到移动设备、智能手表和虚拟现实（VR）。将逻辑分离成单独的模块有助于控制每个团队拥有一个单独的单元。此外，多个事物应该能够并行运行，从而实现更快的交付。团队之间的依赖关系应该降低到零。追踪正确的人来解决问题并使系统重新运行需要微服务架构。
- en: Frequent deployments
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁的部署
- en: Applications need to constantly evolve to keep up with an evolving world. When
    Gmail started, it was just a simple mailing utility and now it has evolved into
    much more than that. These frequent changes demand frequent deployments in such
    a way that the end user doesn't even know that a new version is being released.
    By dividing into smaller units, a team can thus handle frequent deployments with
    testing and get the feature into customers hands quickly. There should be graceful
    degradation, that is, fail fast and get it over with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要不断发展，以适应不断发展的世界。当Gmail开始时，它只是一个简单的邮件工具，现在它已经发展成了更多。这些频繁的变化要求频繁的部署，以便最终用户甚至不知道新版本正在发布。通过分成更小的单元，团队可以处理频繁的部署和测试，并迅速将功能交付给客户。应该有优雅的退化，即快速失败并解决问题。
- en: Self-sustaining development units
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我维护的开发单元
- en: A tight dependency between different modules soon cascades to the entire application
    and it goes down. This requires smaller independent units in such a way that if
    one unit is not operational, then the entire application is not affected by it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不同模块之间的紧密依赖很快就会影响整个应用程序。这就需要更小的独立单元，以便如果一个单元不可操作，整个应用程序也不会受到影响。
- en: Now let's understand in depth about microservices, their characteristics, their
    advantages, and all the challenges while implementing a microservice architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解微服务，它们的特点，优势以及在实施微服务架构时所面临的所有挑战。
- en: What are microservices?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: There is no universal definition of microservices. Simply stating—*a microservice
    can be any operational block or unit, which handles its single responsibility
    very efficiently*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务没有通用的定义。简单地说——*微服务可以是任何操作块或单元，它可以非常有效地处理其单一责任*。
- en: '**Microservices** are modern styles to build autonomous, self-sustaining, loosely
    coupled business capabilities that sum up as an entire system. We will look into
    the principles and characteristics of microservices, the benefit that microservices
    provide, and the potential pitfalls to keep an eye out for.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是构建自主、自我维持、松耦合的业务能力的现代风格，这些能力汇总成一个整个系统。我们将深入了解微服务的原则和特征，微服务提供的好处，以及需要注意的潜在风险。'
- en: Principles and characteristics
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则和特征
- en: There are a few principles and characteristics that define microservices. Any
    microservice pattern would be distinguished and explained further by these points.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原则和特征定义了微服务。任何微服务模式都可以通过这些要点进一步区分和解释。
- en: No monolithic modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有单片模块
- en: A microservice is just another new project satisfying a single operational business requirement. A
    microservice is linked with business unit changes and thus it has to be loosely
    coupled. It should be that a microservice can continuously serve the changing
    business requirements irrespective of the other business units. For other services,
    it is just a matter of consumption, the mode of consumption should not change.
    Implementations can change in the background.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务只是满足单个操作业务需求的另一个新项目。微服务与业务单元的变化相关联，因此必须松耦合。微服务应该能够持续满足不断变化的业务需求，而不受其他业务单元的影响。对于其他服务来说，只是一种消费方式，消费方式不应改变。实现可以在后台更改。
- en: Dumb communication pipes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 愚蠢的通信管道
- en: Microservices promote basic, time-tested, asynchronous communication mechanisms
    among microservices. As per this principle, the business logic should stay inside
    the endpoint and not be amalgamated with the communication channel. The communication
    channel should be dumb and just communicate in the communication protocol decided.
    HTTP is a favorable communication protocol, but a more reactive approach—queues
    is prevalent these days. **Apache Kafka**, and **RabbitMQ** are some of the prevalent
    dumb communication pipes providers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务促进基本、经过时间考验的微服务之间的异步通信机制。根据这一原则，业务逻辑应保留在端点内，而不应与通信渠道混合在一起。通信渠道应该是愚蠢的，并且只在决定的通信协议中进行通信。HTTP是一种受欢迎的通信协议，但更具反应性的方法——队列如今更为普遍。**Apache
    Kafka**和**RabbitMQ**是一些普遍的愚蠢通信管道提供者。
- en: Decentralization or self-governance
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化或自我治理
- en: While working with microservices, there is often a change of failure. A contingency
    plan that eventually stops the failure from propagating to the entire system.
    Furthermore, each microservice may have its own data storage need. Decentralization
    manages just the need for that. For example, in our shopping module we can store
    our customer and his transactions-related information in SQL databases, but since
    the product data is highly unstructured, we store it in NoSQL-related databases.
    Every service should be able to take a decision on what to do in fail case scenarios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务时，经常会出现故障。一个应急计划最终可以阻止故障传播到整个系统。此外，每个微服务可能都有自己的数据存储需求。去中心化管理了这一需求。例如，在我们的购物模块中，我们可以将客户及其交易相关信息存储在SQL数据库中，但由于产品数据高度非结构化，我们将其存储在NoSQL相关数据库中。每个服务都应该能够在故障情况下做出决策。
- en: Service contracts and statelessness
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务合同和无状态性
- en: Microservices should be well defined through service contracts. A **service
    contract** basically gives information about how to consume the service and what
    all the parameters are that need to be passed to that service. **Swagger **and **AutoRest**
    are some of the widely adopted frameworks for creating service contracts. Another
    salient characteristic is that nothing is stored and no state is maintained by
    the microservice. If there is a need to persist something, then it will be persisted
    in a cache database or some datastore.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应通过服务合同进行明确定义。**服务合同**基本上提供了有关如何使用服务以及需要传递给该服务的所有参数的信息。**Swagger**和**AutoRest**是一些广泛采用的用于创建服务合同的框架。另一个显著的特征是微服务不存储任何东西，也不维护任何状态。如果需要持久化某些东西，那么它将被持久化在缓存数据库或某些数据存储中。
- en: Lightweight
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级
- en: Microservices, being lightweight, help to replicate a setup easily in any hosting
    environment. Containers are more preferred than hypervisors. Lightweight application
    containers help us to maintain a lower footprint, thus by binding a microservice
    to some context. Well-designed microservices should perform only one function
    and do that operation well enough. Containerized microservices are easily portable,
    thus enabling easy auto-scaling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务作为轻量级，有助于在任何托管环境中轻松复制设置。容器比虚拟化更受青睐。轻量级应用容器帮助我们保持较低的占用空间，从而将微服务绑定到某个上下文。设计良好的微服务应该只执行一个功能，并且执行得足够好。容器化的微服务易于移植，从而实现轻松的自动扩展。
- en: Polyglot
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语种
- en: Everything is abstract and unknown behind the service API in microservice architecture.
    In the preceding example of shopping cart microservices, we can have our payment
    gateway entirely as a service deployed in the cloud (serverless architecture),
    while the rest of the services can be in Node.js. The internal implementations
    are completely hidden behind the microservices and the only concern to be taken
    care of is that the communication protocol should be the same throughout.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务API后面的一切都是抽象和未知的。在前面的购物车微服务示例中，我们可以将我们的支付网关完全作为云中部署的服务（无服务器架构），而其余服务可以使用Node.js。内部实现完全隐藏在微服务后面，唯一需要关注的是通信协议在整个过程中应该是相同的。
- en: Now, let's see what advantages microservice architecture has to offer us.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看微服务架构为我们提供了哪些优势。
- en: Good parts of microservices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的优点
- en: Adopting microservices has several advantages and benefits. We will look at
    the benefits and higher business values we get while using microservices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务有许多优势和好处。我们将看看在使用微服务时获得的好处和更高的商业价值。
- en: Self-dependent teams
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主团队
- en: Microservices architecture enables us to scale any operation independently,
    have availability on demand, and introduce new services very quickly without zero
    to very few configurations. Technological dependence is also greatly reduced.
    For example, in our shopping microservice architecture, the inventory and shopping
    module can be independently deployed and worked upon. The inventory service will
    just assume that the product will exist and work accordingly. The inventory service
    can be coded in any language as long as the communication protocol between inventory
    and product service is met.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构使我们能够独立扩展任何操作，按需提供可用性，并在零到非常少的配置下非常快速地引入新服务。技术依赖也大大减少。例如，在我们的购物微服务架构中，库存和购物模块可以独立部署和处理。库存服务只会假设产品存在并相应地工作。只要库存和产品服务之间的通信协议得到满足，库存服务可以用任何语言编码。
- en: Graceful degradation of services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的优雅降级
- en: Failure in any system is natural, graceful degradation is a key advantage of
    microservices. Failures are not cascaded to the entire system. Microservices are
    designed in such a way that microservices adhere to agreed service level agreements;
    if the **service level agreements** (**SLAs**) are not met, then the service is
    dropped. For example, coming back to our shopping microservice example, if our
    payment gateway is down, then further requests to that service are stopped until
    the service is up and running.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 任何系统的故障都是自然的，优雅降级是微服务的一个关键优势。故障不会级联到整个系统。微服务设计成遵守约定的服务水平协议；如果服务水平协议未能达到，则服务将被丢弃。例如，回到我们的购物微服务示例，如果我们的支付网关宕机，那么对该服务的进一步请求将停止，直到服务恢复运行。
- en: Supports polyglot architecture and DevOps
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多语言体系结构和DevOps
- en: Microservices make use of resources as per need or effectively create polyglot
    architecture. For example, in shopping microservices, you can store products and
    customer data in a relational database, but any audit or log-related data you
    can store in **Elasticsearch** or **MongoDB**. As each microservice operates in
    its bounded context, this can enable experimentation and innovation. The cost
    of change impact will be very less. Microservices enables **DevOps** to full level.
    Many DevOps tools and techniques are needed for a successful microservice architecture.
    Small microservices are easy to automate, easy to test, contaminate the failure
    if needed, and are easy to scale. **Docker** is one of the major tools for containerizing
    microservices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务根据需要利用资源或有效地创建多语言体系结构。例如，在购物微服务中，您可以将产品和客户数据存储在关系数据库中，但任何审计或日志相关数据都可以存储在Elasticsearch或MongoDB中。由于每个微服务都在其有界上下文中运行，这可以促进实验和创新。变更影响的成本将会非常低。微服务使得DevOps达到了全面水平。成功的微服务架构需要许多DevOps工具和技术。小型微服务易于自动化，易于测试，如果需要，易于污染故障，并且易于扩展。Docker是容器化微服务的主要工具之一。
- en: Event-driven architecture
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: A well-architected microservice will support asynchronous event-driven architecture.
    Event-driven architecture helps as any event can be traced into—each action would
    be the outcome of any event, we can tap into any event to debug an issue. Microservices
    are designed with the publisher-subscriber pattern, meaning adding any other service
    that just subscribes to that event will be a mere task. For example, you are using
    a shopping site and there's a service for add to cart. Now, we want to add new
    functionality so that whenever a product is added to a cart, the inventory should
    be updated. Then, an inventory service can be prepared that just has to subscribe
    to the add to cart service.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好设计的微服务将支持异步事件驱动架构。事件驱动架构有助于追踪任何事件，每个动作都是任何事件的结果，我们可以利用任何事件来调试问题。微服务设计采用发布-订阅模式，这意味着添加任何其他服务只需订阅该事件即可。例如，您正在使用一个购物网站，有一个用于添加到购物车的服务。现在，我们想要添加新功能，以便每当产品添加到购物车时，库存应该更新。然后，可以准备一个只需订阅添加到购物车服务的库存服务。
- en: Now, we will look into the complexities that microservice architecture introduces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将研究微服务架构引入的复杂性。
- en: Bad and challenging parts of microservices
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的不好和具有挑战性的部分
- en: With great power comes greater challenges. Let's look at the challenging parts
    of designing microservices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的力量带来了更大的挑战。让我们看看设计微服务的具有挑战性的部分。
- en: Organization and orchestration
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织和编排
- en: It is one of the topmost challenges while adapting microservice architecture.
    This is more of a non-functional challenge wherein new organizational teams need
    to be formed and they need to be guided in adopting the microservice, agile, and
    scrum methodologies. They need to be simulated in such an environment that they
    can work independently. Their developed outcome should be integrated into the
    system in such a way that it is loosely coupled and is easily scaled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Platform
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the perfect environment needs a proper team, and a scalable fail-safe
    infrastructure across all data centers. Going to the right cloud provider (**AWS**
    or **GCP** or **Azure**), adding automation, scalability, high availability, managing
    containers, and instances of microservices are some of the key considerations.
    Further microservices demand other component needs such as an enterprise service
    bus, document databases, cache databases, and so on. Maintaining these components
    becomes an added task while dealing with microservices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being completely independent testing out services with dependencies is extremely
    challenging. As a microservice gets introduced into the ecosystem, proper governance
    and testing are needed, otherwise it will be a single point of failure for the
    system. Several levels of testing are needed for any microservice. It should start
    from whether the service is able to access cross-cutting concerns (cache, security,
    database, logs) or not. The functionality of the service should be tested, followed
    by testing of the protocol through which it is going to communicate. Next is collaborative
    testing of the microservice with other services. After that is the scalability
    testing followed by fail-safe testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locating services in a distributed environment can be a tedious task. Constant
    change and delivery is the dire requirement for today's constantly evolving world.
    In such situations, service discovery can be challenging as we want independent
    teams and minimal dependencies across teams. Service discovery should be such
    that a dynamic location can be provided for microservices. The location of a service
    may constantly change depending on deployments and auto-scaling or failures. Service
    discovery should also keep a lookout for services that are down or are performing
    poorly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Microservice example
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a diagram of shopping microservices, which we are going to
    implement throughout this book. As we can see, each service is independently maintained
    and there are independent modules or smaller systems—**Billing Module**, **Customer
    Module**, **Product Module**, and **Vendor Module**. To coordinate with every
    module, we have **API Gateway** and **Service Registry**. Adding any additional
    service becomes very easy as the service registry will maintain all the dynamic
    entries and will be updated accordingly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44697ea7-5a19-429a-bc5d-55e975a7dd73.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Key considerations while adopting microservices
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice architecture introduces well-defined boundaries, which makes
    it possible to isolate failures within the boundaries. But being like other distributed
    systems, there is likely a chance of failure at the application level. To minimize
    the impact, we need to design fault-tolerant microservices, which react in a predefined
    way to certain types of failure. While adapting to microservice architecture,
    we add one more network layer to communicate with rather than in-memory method
    calls, which introduces extra latency and one more layer to manage. Given next
    are a few considerations that if handled with care while designing microservices
    for failure, will benefit the system in the long run.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Service degradation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture allows you to isolate failures, thus enabling you
    to isolate the failures and get graceful degradation as failures are contained
    within the boundaries of the service and are not cascaded. For example, in social
    networking sites, the messaging service may go down, but that won't stop the end
    users from using social networks. They can still browse posts, share statuses,
    check-in locations, and so on. Services should be made such that they adhere to
    certain SLAs. If a microservice stops meeting its SLA, then that service should
    be restored to back up. **Netflix's Hystrix** is based on the same principle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构允许您隔离故障，从而使您能够隔离故障并获得优雅的降级，因为故障被包含在服务的边界内，不会被级联。例如，在社交网络网站上，消息服务可能会中断，但这不会阻止最终用户使用社交网络。他们仍然可以浏览帖子，分享状态，签到位置等。服务应该被制定以符合某些SLA。如果微服务停止满足其SLA，那么该服务应该被恢复备份。**Netflix的Hystrix**就是基于同样的原则。
- en: Proper change governance
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当的变更治理
- en: Introducing change without any governance can be a huge problem. In a distributed
    system, services depend on each other. So when you introduce a new change, the
    utmost consideration should be given as if any side or unwanted effects are introduced,
    then its effect should be minimal. Various change management strategies and automatic
    rollout options should be available. Also, proper governance should be there in
    code management. Development should be done via TDD or BDD, and if the agreed
    percentage is met upon, only then should it be rolled out. Releases should be
    done gradually. One useful strategy is the *blue-green* or *red-black* deployment
    strategy, wherein you run two production environments. You rollout the change
    in only one environment and point out the load balancer to a newer version only
    after your change is verified. This is more likely when maintaining a staging
    environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何治理的情况下引入变化可能会是一个巨大的问题。在分布式系统中，服务相互依赖。因此，当您引入新变化时，应该给予最大的考虑，以确保不会引入任何副作用或不良影响，其影响应该是最小的。应该提供各种变更管理策略和自动部署选项。此外，代码管理中应该有适当的治理。开发应该通过TDD或BDD进行，只有在达成约定的百分比后才应该进行部署。发布应该逐渐进行。一个有用的策略是*蓝绿*或*红黑*部署策略，其中您运行两个生产环境。您只在一个环境中部署变化，并在验证变化后将负载均衡器指向更新的版本。这在维护一个分级环境时更有可能。
- en: Health checks, load balancing, and efficient gateway routing
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查、负载均衡和高效的网关路由
- en: Depending on business requirements, the microservice instance can start, restart,
    stop on some failure, run low on memory, and auto-scale, which may make it temporarily
    or permanently unavailable. Therefore, the architecture and framework should be
    designed accordingly. For example, a Node.js server, being single-threaded, stops
    immediately in the case of failure, but using graceful tools such as **PM2** forever
    keeps them running. A gateway should be introduced that will be the only point
    of contact for the microservice consumer. The gateway can be a load balancer that
    should skip unhealthy microservices instances. The load balancer should be able
    to collect health information metrics and route traffic accordingly, it should
    smartly analyze the traffic on any particular microservice, and it should trigger
    auto-scaling if needed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务需求，微服务实例可能会在某些故障、内存不足、自动扩展等情况下启动、重新启动、停止，这可能会使其暂时或永久不可用。因此，架构和框架应相应设计。例如，Node.js服务器是单线程的，在故障情况下会立即停止，但使用**PM2**等优雅的工具可以使其一直运行。应该引入一个网关，这将是微服务消费者的唯一联系点。网关可以是一个负载均衡器，应该跳过不健康的微服务实例。负载均衡器应该能够收集健康信息指标并相应地路由流量，它应该能够智能分析任何特定微服务上的流量，并在需要时触发自动扩展。
- en: Self-curing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自愈
- en: '**Self-curing design** can help the system to recover from disasters. Microservices
    implementation should be able to recover lost services and functionality automatically.
    Tools such as Docker restart services whenever they fail. Netflix provides wide
    tools as an orchestration layer to achieve self-healing. Eureka service registry
    and Hystrix circuit breaker are commonly used. Circuit breakers make your service
    calls more resilient. They track each microservice endpoint''s status. Whenever
    timeout is encountered, Hystrix breaks the connection, triggers the need for curing
    that microservice, and reverts to some fail-safe strategy. **Kubernates** is another
    option. If a pod or any container inside the pod goes down, Kubernates brings
    up the system and maintains the replica set intact.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**自愈设计**可以帮助系统从灾难中恢复。微服务实现应该能够自动恢复丢失的服务和功能。诸如Docker之类的工具在服务失败时会重新启动服务。Netflix提供了广泛的工具作为编排层来实现自愈。Eureka服务注册表和Hystrix断路器是常用的。断路器使您的服务调用更具弹性。它们跟踪每个微服务端点的状态。每当遇到超时时，Hystrix会断开连接，触发对该微服务的治疗需求，并恢复到一些安全策略。**Kubernates**是另一个选择。如果一个pod或者pod内的任何容器宕机，Kubernates会启动系统并保持副本集完整。'
- en: Cache for failover
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障转移缓存
- en: Failover caching helps to provide necessary data whenever there are temporary
    failures or some glitches. The cache layer should be designed so that it can smartly
    decide how long the cache can be used in a normal situation or during failover
    situations. Setting cache standard response headers in HTTP can be used. The max-age
    header specifies the amount of time a resource will be considered fresh. The stale-if-error
    header determines how long the resource should be served from the cache. You can
    also use libraries such as **Memcache**, **Redis**, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 故障转移缓存有助于在临时故障或一些故障时提供必要的数据。缓存层应设计得能够智能决定在正常情况下或故障转移情况下缓存可以使用多长时间。可以使用在HTTP中设置缓存标准响应头。max-age头部指定资源被视为新鲜的时间。stale-if-error头部确定资源应该从缓存中提供的时间。您还可以使用诸如**Memcache**、**Redis**等库。
- en: Retry until
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试直到
- en: Due to its self-healing capabilities, a microservice usually gets up and running
    in no time. Microservice architecture should have *retry logic until condition*
    capabilities, as we can expect that the service will recover or the load balancer
    will redirect the service request to another healthy instance. Frequent retries
    can also have a huge impact on the system. A general idea is increasing the waiting
    time between retries after each failure. Microservices should be able to handle
    idempotency issues; let's say you are retrying to purchase an order, then there
    shouldn't be double purchases on the customer. Now, let's take time to revisit
    the microservice concept and understand the most common questions asked about
    microservice architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其自我修复能力，微服务通常可以在很短的时间内启动并运行。微服务架构应该具有*重试逻辑直到条件*的能力，因为我们可以预期服务将恢复，或者负载均衡器将将服务请求重定向到另一个健康的实例。频繁的重试也可能对系统产生巨大影响。一个常见的想法是在每次失败后增加重试之间的等待时间。微服务应该能够处理幂等性问题；比如说你正在重试购买订单，那么客户不应该出现重复购买。现在，让我们花点时间重新审视微服务的概念，并了解关于微服务架构的最常见问题。
- en: Microservice FAQs
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务常见问题
- en: 'While understanding any new terms, we often come across several questions.
    The following are some of the most frequently asked questions that we come across
    while understanding microservices:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解任何新术语时，我们经常会遇到一些问题。以下是我们在理解微服务时经常遇到的一些最常见的问题：
- en: '**Aren''t microservices just like service-oriented architecture (SOA)? Don''t
    I already have them? When should I start?**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务不就像面向服务的架构（SOA）吗？我不是已经有了吗？我应该何时开始？**'
- en: If you have been in the software industry for a long time, then seeing microservices
    would probably get you remembering SOA. Microservices does take the concept of
    modularity and message-based communication from SOA, but there are many differences
    between them. While SOA focuses more on code reuse, microservices follow the *play
    in your own bundled context* rule. Microservices are more of a subset of SOA.
    Microservices can be scaled on demand. Not all microservice implementations are
    the same. Using Netflix's implementation in your medical domain is probably a
    bad idea as any mistake in the medical report will be worth a human life. The
    simple answer for a working microservice can be to have a clear goal of the operation
    that the service is meant to perform and if it doesn't perform then what it should
    do in failures. There have been various answers to when and how to begin with microservices.
    *Martin Fowler*, one of the pioneers in microservices, states to start with the
    monolith and then gradually move to microservices. But the question here is—*is
    there enough investment to go into the same phase again in this technological
    innovation era?* The short answer is going early in microservices has huge benefits
    as it will address all concerns from the very beginning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在软件行业工作了很长时间，那么看到微服务可能会让你想起SOA。微服务确实从SOA中借鉴了模块化和基于消息的通信的概念，但它们之间有很多不同之处。虽然SOA更注重代码重用，微服务遵循“在自己的捆绑上下文中发挥作用”的规则。微服务更像是SOA的一个子集。微服务可以根据需求进行扩展。并非所有的微服务实现都相同。在医疗领域使用Netflix的实现可能是一个坏主意，因为医疗报告中的任何错误都可能值得一个人的生命。一个有效的微服务的简单答案可能是明确服务的操作目标，如果不能执行操作，则在失败时应该做什么。关于何时以及如何开始使用微服务，有各种不同的答案。*Martin
    Fowler*，微服务的先驱之一，建议从单体架构开始，然后逐渐转向微服务。但问题是——*在这个技术创新时代，是否有足够的投资再次进行相同的阶段？*简短的答案是早期使用微服务有巨大的好处，因为它将从一开始就解决所有问题。
- en: '**How will we deal with all the parts? Who''s in charge? **'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们将如何处理所有的部分？谁负责？**'
- en: Microservices introduce localization and self-rule. Localization means that
    the huge work that was done earlier will no longer be done by the central team.
    Embracing self-rule means trusting all teams to let them make their own decisions.
    This way, software changes or even migrations becomes very easy and fast to manage.
    Having said that, it doesn't mean that there's no central body at all. With more
    microservices, the architecture becomes more complex. The central team then should
    handle all centralized controls such as security, design patterns, frameworks,
    enterprise security bus, and so on. Certain self-governance processes should be
    introduced, such as SLAs. Each microservice should adhere to these SLAs and system
    design should be smart in such a way that if SLAs are not met, then the microservice
    should be dropped.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务引入了本地化和自主规则。本地化意味着之前由中央团队完成的大量工作将不再由中央团队完成。拥抱自主规则意味着信任所有团队让他们自己做决定。这样，软件的更改甚至迁移变得非常容易和快速。话虽如此，并不意味着根本没有中央机构。随着更多的微服务，架构变得更加复杂。然后中央团队应该处理所有集中控制，如安全性、设计模式、框架、企业安全总线等。应该引入某些自我治理流程，如SLA。每个微服务都应该遵守这些SLA，系统设计应该聪明地设计，以便如果SLA未达到，那么微服务应该被丢弃。
- en: '**How do I introduce change or how do I begin with microservice development?**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我如何引入变化或者如何开始微服务开发？**'
- en: Almost all successful microservice stories have begun with a monolith that got
    too big to be managed and was broken up. Changing some part of the architecture
    all of a sudden will have a huge impact, it should be introduced as  gradually
    kind of *divide and rule*. Consider asking yourself the following questions for
    deciding which part to break in the monolith—*How is my application built and
    packaged? How is my application code written? Can I have different data sources
    and how will my application function when I introduce multiple data sources?—*Based
    on the answers of these parts, refactor that part and measure and observe the
    performance of that application. Make sure that the application stays in its bounded
    context. Another part that you can begin is the part whose performance is worst
    in the current monolithic. Finding these bottlenecks that hinder change would
    be good for organizations. Introducing centralized operations will eventually
    allow multiple things to be run in parallel and benefit the greater good of the
    company.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有成功的微服务故事都始于一个变得太大而无法管理并被分解的单体架构。突然改变架构的某个部分将产生巨大影响，应该逐渐引入一种“分而治之”的方式。考虑以下问题来决定要在单体架构中分解哪个部分——我的应用是如何构建和打包的？我的应用代码是如何编写的？我可以有不同的数据源，当我引入多个数据源时，我的应用将如何运行？——根据这些部分的答案，重构该部分并测量和观察该应用的性能。确保应用保持在其边界上下文中。另一个可以开始的部分是当前单体架构中性能最差的部分。发现阻碍变化的瓶颈对组织来说是有益的。引入集中化操作最终将允许多个事情并行运行，并使公司受益匪浅。
- en: '**What kind of tools and technologies are required? **'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要什么样的工具和技术？
- en: While designing microservice architecture, proper thought should be given to
    the technology or framework selection for any particular stage. For example, an
    ideal environment for microservice features, cloud infrastructure, and containers.
    Containers give heterogeneous and easy to port or migrate systems. Using Docker
    brings resiliency and scalability on demand in microservices. Any part of microservices,
    such as the API Gateway or the service registry should be such that it should
    be API friendly, adaptable to dynamic changes, and not be a single point of failure.
    Containers require shifting on and off to a server, track all application upgrades
    for which proper framework either—**Swarm** or **Kubernates** for orchestrating
    framework deployments. Lastly, some monitoring tools to keep health checks on
    all microservices and take actions needed. Prometheus is one such famous tool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务架构时，应该对任何特定阶段的技术或框架选择进行适当的思考。例如，微服务特性、云基础设施和容器的理想环境。容器提供了异构和易于移植或迁移的系统。使用Docker可以在微服务中按需提供弹性和可伸缩性。微服务的任何部分，如API网关或服务注册表，都应该是API友好的，适应动态变化，而不是单点故障。容器需要在服务器上进行开关，跟踪所有应用程序升级，为此需要适当的框架，如Swarm或Kubernetes来进行框架部署。最后，一些监控工具可以对所有微服务进行健康检查并采取必要的行动。Prometheus就是这样一个著名的工具。
- en: '**How do I govern a microservices system? **'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理微服务系统？
- en: With lots of parallel service development going on, there is a primitive need
    to have a centralized governing policy. Not only do we need to take care of certifications
    and server audits, but also centralized concerns such as security, logging, scalability,
    and distributed concerns such as team ownership, sharing concerns between various
    services, code linters, service-specific concerns, and so on. In such a case,
    some standard guidelines can be made such as each team should provide a Docker
    configuration file that bundles the software right from getting dependencies to
    building it and producing a container that has the specifics of the service. The
    Docker image can then be run in any standard way, or using orchestration tools
    such as Amazon EC2, GCP, or Kubernates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多并行服务开发正在进行，有一个集中的管理政策是一个原始的需求。我们不仅需要关注认证和服务器审计，还需要关注集中的问题，如安全性、日志记录、可伸缩性，以及团队所有权、在各种服务之间共享问题、代码检查器、特定于服务的问题等分布式问题。在这种情况下，可以制定一些标准指南，例如每个团队应提供一个Docker配置文件，该文件从获取依赖项到构建软件并生成具有服务特定信息的容器。然后可以以任何标准方式运行Docker镜像，或者使用诸如Amazon
    EC2、GCP或Kubernetes之类的编排工具。
- en: '**Should all the microservices be coded in the same language?**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有微服务都应该用相同的语言编码吗？
- en: The generic answer to this question is it is not a prerequisite. Microservices
    interact with each other via predefined protocols such as HTTP, Sockets, Thrift,
    RPC, and so on, which we will see in much detail later on. This means different
    services can be written in completely different technological stacks. The internal
    language implementation of the microservice is not important as the external outcome,
    that is, the endpoint and API. As long as the communication protocols are maintained,
    language implementation is not important, while it is an added advantage for not
    just having one language, but adding too many languages will also result in an
    added complexity of system developers to maintain language environment needs.
    The entire ecosystem should not be a wild jungle where you grow anything.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的一般回答是这不是一个先决条件。微服务通过预定义的协议进行相互交互，例如HTTP、Sockets、Thrift、RPC等，我们稍后将更详细地看到。这意味着不同的服务可以使用完全不同的技术堆栈编写。微服务的内部语言实现并不重要，重要的是外部结果，即端点和API。只要保持通信协议，语言实现就不重要，虽然不仅拥有一种语言是一个优势，但添加太多语言也会导致系统开发人员维护语言环境需求的复杂性增加。整个生态系统不应该是一个你可以种植任何东西的野生丛林。
- en: Cloud-based systems now have a standard set of guidelines. We will look at the
    famous twelve-factor applications and how microservices adhere to those guidelines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于云的系统现在有一套标准的指导方针。我们将看一下著名的十二要素应用程序以及微服务如何遵循这些指导方针。
- en: Twelve-factor application of microservices
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的十二要素应用
- en: '"Good code fails when you don''t have a good process and a platform to help
    you. Good team fails when you don''t have a good culture that embraces DevOps
    and microservices."'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “当你没有一个好的流程和平台来帮助你时，好的代码会失败。当你没有一个拥抱DevOps和微服务的良好文化时，好的团队也会失败。”
- en: '- Tim Spann'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '- Tim Spann'
- en: 'The **twelve-factor application** is a methodology for **Software as a Service (SaaS****)** or
    web applications or software deployed in the cloud. It tells us about the characteristics
    of the output expected from such applications. It essentially is just outlining
    necessities for making well-structured and scalable cloud applications:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**十二要素应用程序**是一种**软件即服务（SaaS）**或部署在云中的Web应用程序或软件的方法论。它告诉我们关于这些应用程序期望的输出特征。它基本上只是概述了制作结构良好且可扩展的云应用程序的必要条件：'
- en: '**Codebase**: We maintain a single code base here for each microservice, with
    a configuration specific to their own environments, such as development, QA, and
    prod. Each microservice would have its own repository in a version control system
    such as Git, mercurial, and so on.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库**：我们为每个微服务维护一个单一的代码库，具有特定于它们自己的环境的配置，如开发、QA和生产。每个微服务都将在版本控制系统（如Git、mercurial等）中拥有自己的存储库。'
- en: '**Dependencies**: All microservices will have their dependencies as part of
    the application bundle. In Node.js, there is `package.json`, which mentions all
    the development dependencies and overall dependencies. We can even have a private
    repository from where dependencies will be pulled.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖关系**：所有微服务都将它们的依赖项作为应用程序包的一部分。在Node.js中，有一个`package.json`，其中列出了所有的开发依赖和总体依赖。我们甚至可以有一个私有仓库，从中获取依赖项。'
- en: '**Configs**: All configurations should be externalized, based on the server
    environment. There should be a separation of config from code. You can set environment
    variables in Node.js or use Docker compose to define other variables.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：所有配置应该是外部化的，基于服务器环境。应该将配置与代码分离。您可以在Node.js中设置环境变量，或者使用Docker compose来定义其他变量。'
- en: '**Backing services**: Any service consumed over the network such as database,
    I/O operations, messaging queries, SMTP, the cache will be exposed as microservices
    and using Docker compose and be independent of the application.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后备服务**：任何通过网络消耗的服务，如数据库、I/O操作、消息查询、SMTP、缓存，都将作为微服务暴露出来，并使用Docker compose，并独立于应用程序。'
- en: '**Build, release, and run**: We will use automated tools like Docker and Git
    in distributed systems. Using Docker we can isolate all the three phases using
    its push, pull, and run commands.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建、发布和运行**：我们将在分布式系统中使用Docker和Git等自动化工具。使用Docker，我们可以使用其推送、拉取和运行命令来隔离所有三个阶段。'
- en: '**Processes**: Microservices designed would be stateless and would share nothing,
    hence enabling zero fault tolerance and easy scaling. Volumes will be used to
    persist data thus avoiding data loss.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：设计的微服务将是无状态的，并且不共享任何东西，因此实现零容错和轻松扩展。卷将用于持久化数据，从而避免数据丢失。'
- en: '**Port binding**: Microservices should be autonomous and self-contained. Microservices
    should embed service listeners as part of service itself. For example— in Node.js
    application using HTTP module, service network exposing services for handling
    ports for all processes.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口绑定**：微服务应该是自治的和自包含的。微服务应该将服务监听器嵌入到服务本身中。例如，在Node.js应用程序中使用HTTP模块，服务网络公开服务以处理所有进程的端口。'
- en: '**Concurrency**: Microservices will be scaled out via replication. Microservices
    are scaled out rather than scaled up. Microservices can be scaled or shrunk based
    on the flow of workload diversity. Concurrency will be dynamically maintained.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**：微服务将通过复制进行扩展。微服务是通过扩展而不是扩大规模的。微服务可以根据工作负载的流动进行扩展或缩小。并发性将得到动态维护。'
- en: '**Disposability**: To maximize the robustness of application with fast startup
    and graceful shutdown. Various options include restart policies, orchestration
    using Docker swarm, reverse proxy, and load balancing with service containers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可处置性**：最大限度地提高应用程序的健壮性，实现快速启动和优雅关闭。各种选项包括重启策略，使用Docker swarm进行编排，反向代理以及使用服务容器进行负载平衡。'
- en: '**Dev/prod parity**: Keep development/production/staging environments exactly
    alike. Using containerized microservices helps via *build once, run anywhere strategy*.
    The same image is deployed across various DevOps stage.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/生产一致性**：保持开发/生产/暂存环境完全相同。使用容器化的微服务通过*构建一次，随处运行*策略有所帮助。相同的镜像部署在各种DevOps阶段。'
- en: '**Logs**: Creating separate microservice for logs for making it centralized,
    to treat as event streams and send it to frameworks such as **elastic stack**
    (**ELK**).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：为日志创建单独的微服务，使其集中化，将其视为事件流，并将其发送到诸如**弹性堆栈**（**ELK**）之类的框架。'
- en: '**Admin processes**: Admin or any management tasks should be packed as one
    of the processes, so they can be easily executed, monitored, and managed. This
    will include tasks like database migrations, one-time scripts, fixing bad data,
    and so on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理进程**：管理或任何管理任务应该作为其中一个进程打包，这样它们可以轻松执行、监视和管理。这将包括诸如数据库迁移、一次性脚本、修复错误数据等任务。'
- en: Microservices in the current world
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前世界中的微服务
- en: Now, let's look at the pioneer implementers of microservices in the current
    world, the advantages they have got, and the roadmap ahead. The common objective
    of why these companies adopted microservices was getting rid of monolithic hell.
    Microservices even saw its adoption at the frontend. Companies such as **Zalando**
    use microservices principles to have composition at the UI level too.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看当前世界中微服务的先驱实施者，他们获得的优势以及未来的路线图。这些公司采用微服务的共同目标是摆脱单片地狱。微服务甚至在前端看到了它的采用。像**Zalando**这样的公司也使用微服务原则在UI层面进行组合。
- en: Netflix
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix
- en: '**Netflix** is one of the front-runners in microservice adoption. Netflix processes
    billions of viewing events per day. It needed a robust and scalable architecture
    to manage and process this data. Netflix used polyglot persistence to get the
    strength of each of the technological solutions they adopted. They used **Cassandra**
    for high volume and lower latency writes operations and a hand-made model with
    tuned configurations for medium volume write operations. They have **Redis** for
    high volume and lower latency reads at the cache level. Several frameworks that
    Netflix tailor-made are now open source and available for use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '| **Netflix Zuul** | An edge server or the gatekeeper to the outside world.
    It doesn''t allow unauthorized requests to pass through. It is the only point
    of contact for the outside world. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| **Netflix Ribbon** | A load balancer that is used by service consumers to
    find services at runtime. If more than one instances of microservices are found,
    ribbon uses load balancing to evenly distribute the load. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| **Netflix Hystrix** | A circuit breaker that is used to keep the system up
    and running. Hystrix breaks the connection for services that are going to fail
    eventually and only joins the connection when services are up again. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| **Netflix Eureka** | Used for service discovery and registration. It allows
    services to register themselves at runtime. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| **Netflix Turbine** | Monitoring tool to check the health of running microservices.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: Just checking the stars on these repositories will give an idea of the rate
    of adoption of microservices using Netflix's tools.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Walmart
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walmart is one of the most popular companies on Black Friday. During Black Friday,
    it has more than 6 million page views per minute. **Walmart** adopted to microservices
    architecture to adopt to the world of 2020 to have 100% availability with reasonable
    costs. Migrating to microservices gave a huge uplift to the company. Conversion
    rates went up by 20%. They have zero downtime on Black Friday. They saved 40%
    of their computational power and got 20-50% cost savings overall.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Spotify
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spotify** has 75 million active users per month with an average session length
    of 23 minutes. They adopted a microservice architecture and polyglot environment.
    Spotify is a company of 90 teams, 600 developers, and five offices across two
    continents, all working on the same product. This was a major factor in reducing
    dependencies as much as possible.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Zalando
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Zalando** implemented microservices at the frontend. They introduced fragments
    that served as separate services for the frontend. Fragments can be composed together
    at runtime as per the template definitions provided. Similar to Netflix, they
    have outsourced usage libraries:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tailor** | It''s a layout service, which composes a page out of various
    fragments, as it does asynchronous and streams based fetching it has outstanding
    **time to the first byte** (**TTFB**). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **Skipper** | HTTP router for communication, more of an HTTP interceptor,
    it has the ability to modify request and responses with filters. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| **Shaker** | UI components library used for providing consistent user experience
    while developing fragments across multiple teams. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| **Quilt** | Template storage and manager with REST API. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| **Innkeeper** | Datastores for routes. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| **Tesselate** | Server-side renderer and component tree builder. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: It now serves more than 1500 fashion brands, generates more than $3.43 billion
    revenue, and developments are done in a team of more than 700 people.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will debunk microservices from the design point of view.
    We will see what components are involved in the microservices design and see widely
    prevalent microservices design patterns.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Microservice design aspects
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While designing microservices, various important decisions need to be taken
    such as how will the microservices communicate with each other, how we will handle
    security, how we will do data management, and so on. Let's now look at those various
    aspects involved in the microservices design and understand various options available
    to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时，需要做出各种重要决策，例如微服务之间如何通信，如何处理安全性，如何进行数据管理等。现在让我们看看微服务设计中涉及的各种方面，并了解其可用的各种选项。
- en: Communication between microservices
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的通信
- en: Let's understand this aspect with a real-world example to understand the problem.
    In the shopping cart application, we have our product microservices, inventory
    microservice, check out microservice, and user microservice. Now a user opts to
    buy a product; for the user, the product should be added to their cart, the amount
    paid, on successful payment, the checkout done, and inventory updated. Now if
    payment is successfully done, then only the checkout and inventory should be updated,
    hence the services need to communicate with each other. Let's now look at some
    of the mechanisms that microservices can use to communicate with each other or
    any of the external clients.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个真实世界的例子来理解这个问题。在购物车应用程序中，我们有产品微服务、库存微服务、结账微服务和用户微服务。现在用户选择购买一个产品；对于用户来说，产品应该被添加到他们的购物车中，支付金额，在成功支付后，结账完成，并更新库存。现在如果支付成功，那么只有结账和库存应该被更新，因此服务需要相互通信。现在让我们看一些微服务可以用来相互通信或与任何外部客户端通信的机制。
- en: Remote Procedure Invocation (RPI)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用（RPI）
- en: Briefly speaking, remote procedure call is a protocol that anyone can use to
    access services from any other providers located remotely in the network, without
    the need of understanding the network details. The client uses the protocol of
    request and replies to make requests for services and it is one of the most feasible
    solutions to REST for big data search systems. It has one of the major advantages
    of serialization time. Some of the technologies providing RPI are **Apache Thrift**
    and **Google's gRPC**. gRPC is a widely adopted library and it has more than 23,000
    downloads from Node.js per day. It has some awesome utilities such as pluggable
    authentication, tracing, load balancing, and health checking. It is used by Netflix,
    CoreOS, Cisco, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，远程过程调用是一种协议，任何人都可以使用它从网络中远程访问其他提供者的服务，而无需了解网络细节。客户端使用请求和回复协议来请求服务，这是大数据搜索系统中最可行的解决方案之一。它具有序列化时间的主要优势之一。提供RPI的一些技术包括**Apache
    Thrift**和**Google的gRPC**。gRPC是一个广泛采用的库，每天从Node.js下载量超过23,000次。它具有一些很棒的实用程序，如可插拔身份验证、跟踪、负载平衡和健康检查。它被Netflix、CoreOS、Cisco等公司使用。
- en: 'This pattern of communication has the following advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信模式具有以下优势：
- en: Request and reply are easy
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和回复很容易
- en: Simple to maintain as there is no middle broker
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护简单，因为没有中间代理
- en: Bidirectional streams with HTTP/2-based transportation methods
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于HTTP/2的双向流传输方法
- en: Efficiently connecting polyglot services in microservices styled architectural
    ecosystems
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务风格的架构生态系统中高效地连接多语言服务
- en: 'This pattern has the following challenges and issues for consideration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的通信对以下挑战和问题需要考虑：
- en: The caller needs to know the locations of service instances, that is, maintain
    a client-side registry and server-side registry
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方需要知道服务实例的位置，即维护客户端注册表和服务器端注册表
- en: It only supports the request and reply model and has no support for other patterns
    such as notifications, async responses, the publish/subscribe pattern, publish async
    responses, streams, and so on
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只支持请求和回复模式，不支持其他模式，如通知、异步响应、发布/订阅模式、发布异步响应、流等
- en: RPI uses binary rather than text to keep the payload very compact and efficient.
    These requests are multiplexed over a single TCP connection, which can allow multiple
    concurrent messages to be in flight without having to compromise for network consumption
    usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: RPI使用二进制而不是文本来保持有效负载非常紧凑和高效。这些请求在单个TCP连接上进行多路复用，这可以允许多个并发消息在不牺牲网络消耗的情况下进行传输。
- en: Messaging and message bus
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递和消息总线
- en: This mode of communication is used when services have to handle the requests
    from various client interfaces. Services need to collaborate with each other to
    handle some specific operations, for which they need to use an inter-process communication
    protocol. Asynchronous messaging and message bus is one of them. Microservices
    communicate with each other by exchanging messages over various messaging channels.
    **Apache Kafka**, **RabbitMQ**, and **ActiveMQ**, **Kestrel** are some of the
    widely available message brokers that can be used for communication between microservices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务必须处理来自各种客户端接口的请求时，就会使用这种通信模式。服务需要相互协作来处理一些特定的操作，为此它们需要使用进程间通信协议。异步消息传递和消息总线就是其中之一。微服务通过在各种消息通道上交换消息来相互通信。**Apache
    Kafka**、**RabbitMQ**、**ActiveMQ**、**Kestrel**是一些广泛可用的消息代理，可用于微服务之间的通信。
- en: 'The message broker ultimately does the following set of functionalities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理最终执行以下功能集：
- en: Route messages coming from various clients to different microservices destinations.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将来自各种客户端的消息路由到不同的微服务目的地。
- en: Changes messages to desired transformations as per need.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要将消息更改为所需的转换。
- en: Ability to do message aggregations, segregate a message into multiple messages,
    and send them to the destination as per need and recompose them.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够进行消息聚合，将消息分隔成多个消息，并根据需要发送到目的地并重新组合它们。
- en: Respond to errors or events.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应错误或事件。
- en: Provide content and routing using the publish-subscribe pattern.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用发布-订阅模式提供内容和路由。
- en: 'Using message bus as a means of communication between microservices has the
    following advantages:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息总线作为微服务之间的通信手段具有以下优势：
- en: The client is decoupled from the services; they don't need to discover any services.
    Loosely coupled architecture throughout.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务解耦；它们不需要发现任何服务。整体上松散耦合的架构。
- en: Highly available as the message broker persists messages until the consumer
    is able to process them for operations.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理具有高可用性，因为它会持久保存消息，直到消费者能够对其进行操作。
- en: It has support for a variety of communication patterns, including the widely
    used request/reply, notifications, async responses, publish-subscribe, and so
    on.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持各种通信模式，包括广泛使用的请求/回复、通知、异步响应、发布-订阅等。
- en: While this mode provides several advantages, it increases the complexity of
    adding a message broker that should be made highly available, as it can become
    a single point of failure. It also implies the need for the client to discover
    the location of the message broker, the single point of contact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种模式提供了几个优点，但增加了添加消息代理的复杂性，该代理应该具有高可用性，因为它可能成为单点故障。这也意味着客户端需要发现消息代理的位置，即联系点。
- en: Protobufs
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: protobufs
- en: '**Protocol buffers** or **protobufs** are a binary format created by Google.
    Google defines protobufs as a language and platform neutral extensive way of serializing
    structured data that can be used as one of the communication protocols. Protobufs
    also defines a set of some language rules that define the structure of messages.
    Some demonstrations effectively show that protobufs is six times faster than JSON.
    It is very easy to implement and it involves three major stages, which are creating
    message descriptors, message implementations, and parsing and serialization. Using
    protobufs in your microservices gives you the following advantages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议缓冲区**或**protobufs**是由谷歌创建的二进制格式。谷歌将protobufs定义为一种语言和平台中立的序列化结构化数据的广泛方式，可用作通信协议之一。
    Protobufs还定义了一组定义消息结构的一些语言规则。一些演示有效地表明protobufs比JSON快六倍。它非常容易实现，包括三个主要阶段，即创建消息描述符、消息实现和解析和序列化。在微服务中使用protobufs具有以下优势：'
- en: Formats for protobufs are self-explaining—formal formats.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: protobufs的格式是自解释的-正式的格式。
- en: It has RPC support; you can declare server RPC interfaces as part of protocol
    files.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有RPC支持；您可以将服务器RPC接口声明为协议文件的一部分。
- en: It has an option for structure validation. As it has larger datatype messages
    that are serialized on protobufs, it can be validated automatically by the code
    that is responsible for exchanging them.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有结构验证的选项。由于它具有在protobufs上序列化的较大数据类型消息，因此可以由负责交换它们的代码自动验证。
- en: 'While the protobuf pattern offers various advantages, it has some drawbacks,
    which are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然protobuf模式提供了各种优势，但也有一些缺点，如下所示：
- en: It is an upcoming pattern; hence you won't find many resources or detailed documentation
    for implementation of protobuf. If you just look for the protobuf tag on Stack
    Overflow, you will merely see a mere 10,000 questions.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种新兴的模式；因此您不会找到许多资源或详细的protobuf实现文档。如果您只在Stack Overflow上搜索protobuf标签，您只会看到大约1万个问题。
- en: As it's binary format, it's non-readable when compared to JSON, which is simple
    to read and analyze on the other hand. The next generation of protobuf and flatbuffer
    is already available now.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是二进制格式，与JSON相比，它是不可读的，而JSON在另一方面是简单易读和分析的。下一代protobuf和flatbuffer现在已经可用。
- en: Service discovery
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The next obvious aspect to take care of is the method through which any client
    interface or any microservice will discover the network location of any service
    instance. Modern applications based on microservices run in virtualized or containerized environments
    where things change dynamically, including the number of instances of services
    and their location. Also, the set of service instances changes dynamically based
    on auto-scaling, upgrades, and so on. We need an elaborate a service discovery
    mechanism. Discussed ahead are widely used patterns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的明显方面是任何客户端接口或任何微服务将发现任何服务实例的网络位置的方法。基于微服务的现代应用程序在虚拟化或容器化环境中运行，其中包括服务实例的数量和位置动态变化。此外，基于自动扩展、升级等，服务实例集会动态变化。我们需要一个详细的服务发现机制。下面讨论的是广泛使用的模式。
- en: Service registry for service-service communication
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表用于服务-服务通信
- en: Different microservices and various client interfaces need to know the location
    of service instances so as to send requests. Usually, virtual machines or containers
    have a different or dynamic IP address, for example, an EC2 group when applied
    auto-scaling, it auto adjusts the number of instances based on load. Various options
    are available to maintain a registry anywhere such as client-side or server-side
    registrations. Clients or microservices look up to that registry to find other
    microservices for communication.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的微服务和各种客户端接口需要知道服务实例的位置，以便发送请求。通常，虚拟机或容器具有不同或动态的IP地址，例如，应用自动扩展的EC2组，它根据负载自动调整实例的数量。有多种选项可用于在任何地方维护注册表，例如客户端端或服务器端注册。客户端或微服务查找该注册表以查找其他微服务进行通信。
- en: 'Let''s take the real-life example of Netflix. Netflix Eureka is a service registry
    provider. It has various options for registering and querying available service
    instances. Using the `POST API` exposed an instance of service tells about its
    network location. It must be constantly updated every 30 seconds with the `PUT
    API` exposed. Any interface can use the `GET API` to get that instance and use
    it as per demand. Some of the widely available options are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Netflix的真实例子为例。Netflix Eureka是一个服务注册提供者。它有各种选项用于注册和查询可用的服务实例。使用公开的`POST
    API`告知服务实例的网络位置。必须每30秒使用公开的`PUT API`进行不断更新。任何接口都可以使用`GET API`获取该实例并根据需求使用。一些广泛可用的选项如下：
- en: '`etcd`: A key-value store used for shared configuration and service discovery.
    Projects such as Kubernates and cloud foundry are based on `etcd` as it can be
    highly available, key-value based, and consistent.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：用于共享配置和服务发现的键值存储。诸如Kubernates和Cloud Foundry之类的项目都基于`etcd`，因为它可以是高可用的、基于键值的和一致的。'
- en: '`consul`: Yet another tool for service discovery. It has wide options such
    as exposed API endpoints that allow the client to register and discover services
    and perform health checks to determine service availability.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul`：另一个用于服务发现的工具。它具有广泛的选项，如公开的API端点，允许客户端注册和发现服务，并执行健康检查以确定服务的可用性。'
- en: '`ZooKeeper`: Very widely used, highly available, and a high performant coordinated
    service used in distributed applications. Originally a subproject of Hadoop, Zookeeper
    is a widely used top-level project and it comes preconfigured with various frameworks.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZooKeeper`：非常广泛使用，高可用性和高性能的协调服务，用于分布式应用程序。Zookeeper最初是Hadoop的一个子项目，是一个广泛使用的顶级项目，并且预配置了各种框架。'
- en: Some systems have implicit in-built service registry, built in as a part of
    their framework. For example, Kubernates, Marathon, and AWS ELB.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统具有隐式内置的服务注册表，作为其框架的一部分内置。例如，Kubernates、Marathon和AWS ELB。
- en: Server-side discovery
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端发现
- en: All requests made to any of the services are routed via a router or load balancers
    that run in a location known to client interfaces. The router then queries a maintained
    registry and forwards the request based on the query response. An **AWS Elastic
    load balancer** is a classic example that has the ability to handle load balancing,
    handle internal or external traffic, and act as a service registry. EC2 instances
    are registered to ELB either via exposed API calls or either through auto-scaling.
    Other options include NGINX and NGINX Plus. There are available consul templates
    that ultimately generate the `nginx.conf` file from the consul service registry
    and can configure proxying as required.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何服务的所有请求都通过已知客户端接口的位置运行的路由器或负载均衡器路由。然后，路由器查询维护的注册表，并根据查询响应转发请求。**AWS弹性负载均衡器**是一个经典示例，它具有处理负载平衡、处理内部或外部流量和作为服务注册表的能力。EC2实例可以通过公开的API调用或自动扩展注册到ELB。其他选项包括NGINX和NGINX
    Plus。还有可用的consul模板，最终从consul服务注册表生成`nginx.conf`文件，并根据需要配置代理。
- en: 'Some of the major advantages of using server-side discovery are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端发现的一些主要优势如下：
- en: The client does not need to know the location of different microservices. They
    just need to know the location of the router and the service discovery logic is
    completely abstracted from the client so there is zero logic at the client end.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不需要知道不同微服务的位置。他们只需要知道路由器的位置，服务发现逻辑完全抽象化，客户端端没有任何逻辑。
- en: Some environments provide this component functionality for free.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些环境免费提供此组件功能。
- en: 'While these options have great advantages, there are some drawbacks too that
    need to be handled:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些选项有很大的优势，但也有一些需要处理的缺点：
- en: It has more network hops, that is, one from the client service registry and
    another from the service registry microservice.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有更多的网络跳数，即来自客户端服务注册表和另一个来自服务注册表微服务。
- en: If the load balancer is not provided by the environment, then it has to be set
    up and managed. If not properly handled, then it can be a single point of failure.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果负载均衡器不是由环境提供的，那么就必须设置和管理它。如果处理不当，它可能成为单点故障。
- en: The selected router or load balancer must support different communication protocols
    for modes of communication.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的路由器或负载均衡器必须支持不同的通信协议以进行通信模式。
- en: Client-side discovery
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端发现
- en: 'Under this mode of discovery, the client is responsible for handling the network
    location of available microservices and load balancing incoming requests across
    them. The client needs to query a service registry (a database of available services
    maintained on the client side). The client then selects service instances on the
    basis of an algorithm and then makes a request. Netflix uses this pattern extensively
    and has open sourced their tools Netflix OSS, Netflix Eureka, Netflix Ribbon,
    and Netflix Prana. Using this pattern has the following advantages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种发现模式下，客户端负责处理可用微服务的网络位置，并在它们之间负载平衡传入请求。客户端需要查询服务注册表（在客户端维护的可用服务的数据库）。然后，客户端根据算法选择服务实例，然后发出请求。Netflix广泛使用此模式，并已开源其工具Netflix
    OSS、Netflix Eureka、Netflix Ribbon和Netflix Prana。使用此模式具有以下优势：
- en: High performance and availability as there are fewer transition hops, that is,
    the client just has to invoke the registry and the registry will redirect to the
    microservice as per their needs.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能和可用性，因为转换跳数较少，也就是说，客户端只需调用注册表，注册表将根据其需求重定向到微服务。
- en: This pattern is fairly simple and highly resilient as besides the service registry
    there are no moving parts. As the client knows about available microservices,
    they can make intelligent decisions easily such as to use a hash, when to trigger
    auto-scaling, and so on.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式相当简单且高度具有弹性，因为除了服务注册表外没有其他移动部分。由于客户端了解可用的微服务，他们可以轻松地做出智能决策，例如何时使用哈希，何时触发自动扩展等。
- en: One significant drawback of using this mode of service discovery is implementation
    of client-side service discovery logic has to be done in every programming language
    of the framework that is used by the service clients. For example, Java, JavaScript,
    Scala, Node.js, Ruby, and so on.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此服务发现模式的一个重大缺点是，必须在服务客户端使用的每种编程语言的框架中实现客户端端服务发现逻辑。例如，Java、JavaScript、Scala、Node.js、Ruby等。
- en: Registration patterns – self-registration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册模式-自注册
- en: While using this pattern, any microservice instance is responsible for registering
    and deregistering itself from the maintained service registry. To maintain health
    checks, a service instance sends heartbeat requests to prevent its registry from
    expiring. Netflix uses a similar approach and has outsourced their Eureka library,
    which handles all aspects of service registration and deregistration. It has its
    client in Java as well as Node.js. The Node.js client (`eureka-js-client`) has
    more than 12,000 downloads a month. The self-registration pattern has major benefits,
    such as any microservice instance would know its own state, hence it can implement
    or shift to other modes easily such as **Starting**, **Available**, and others.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it also has the following drawbacks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: It couples the service tightly to the self-service registry, which forces us
    to enable the service registration code in each language we are using in the framework
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any microservice that is in running mode, but is not able to handle requests,
    will often be unaware of which state to pursue, and will often end up forgetting
    to unregister from the registry
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data management
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important question in microservice design aspect is the database architecture
    in a microservices application. We will see various options such as whether to
    maintain a private datastore, managing transactions, and making querying datastores
    easy in distributed systems. An initial thought can be going with a single database,
    but if we give it deep thought, we will soon see it as an unwise and unfitting
    solution because of tight coupling, different requirements, and runtime blocking
    by any of the services.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Database per service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a distributed microservices architecture, different services have needs and
    usages of different storage requirements. The relational database is a perfect
    choice when it comes to maintaining relations and having complex queries. NoSQL
    databases such as MongoDB is the best choice when there is unstructured complex
    data. Some may require graph data and thus use *Neo4j* or *GraphQL*. The solution
    is to keep each of the microservices data private to that service and get it accessible
    only via APIs. Each microservice maintains its datastore and is a private part
    of that service implementation and hence it is not directly accessible by other
    services.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the options you have while implementing this mode of data management
    are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Private tables/collections per service**: Each microservice has a set of
    defined tables or collections that can only be accessed by that service'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema per service**: Each service has a schema that can only be accessed
    via the microservice it is bound to'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database per service**: Each microservice maintains its own database as per
    its needs and requirements'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When thought of, maintaining a schema per service seems to be the most logical
    solution as it will have lower overhead and ownership can clearly be made visible.
    If some services have high usage and throughput and different usage, then maintaining
    a separate database is the logical option. A necessary step is to add barriers
    that will restrict any microservice from accessing data directly. Various options
    to add this barrier include assigning user IDs with restricted privileges or accessing
    control mechanisms such as grants. This pattern has the following advantages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled services that can stand on their own; changes to one service's
    datastore won't affect any other services.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service has the liberty to select the datastore as required. Each microservice
    has the option of whether to go for relational or non-relational databases as
    per need. For example, any service that needs intensive search results on text
    may go for **Solr** or **Elasticsearch**, whereas any service where there is structured
    data may go for any SQL database.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This pattern has the following drawbacks and upcomings that need to be handled
    with care:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Handling complex scenarios that involve transactions spanning across multiple
    services. The CAP theorem states that it is impossible to have more than two out
    of the following three guarantees—consistency, availability, and partitions in
    the distributed datastore, so transactions are generally avoided.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理涉及跨多个服务的事务的复杂场景。CAP定理指出，在分布式数据存储中不可能同时满足一致性、可用性和分区中的三个保证中的超过两个，因此通常避免事务。
- en: Queries ranging across multiple databases are challenging and resource consuming.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个数据库的查询具有挑战性且消耗资源。
- en: The complexity of managing multiple SQL and non-SQL datastores.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个SQL和非SQL数据存储的复杂性。
- en: 'To overcome the drawbacks, the following patterns are used while maintaining
    a database per service:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服缺点，在维护每个服务的数据库时使用以下模式：
- en: '**Sagas**: A saga is defined as a batch sequence of local transactions. Each
    entry in the batch updates the specified database and moves on by publishing a
    message or triggering an event for the next entry in the batch to happen. If any
    entry in the batch fails locally or any business rule is violated, then the saga
    executes a series of compensating transactions that compensate or undo the changes
    that were made by the saga batch updates.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saga**：一个saga被定义为一批本地事务的序列。批中的每个条目都会更新指定的数据库，并通过发布消息或触发下一个批次中的事件来继续。如果批中的任何条目在本地失败，或者违反了任何业务规则，那么saga将执行一系列补偿事务，以补偿或撤消批次更新所做的更改。'
- en: '**API Composition**: This pattern insists that the application should perform
    the join rather than the database. As an example, a service is dedicated to query
    composition. So, if we want to fetch monthly product distributions, then we first
    retrieve the products from the product service and then query the distribution
    service to return the distribution information of the retrieved products.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API组合**：这种模式坚持认为应用程序应该执行连接而不是数据库。举个例子，一个服务专门用于查询组合。因此，如果我们想要获取每月产品分布，那么我们首先从产品服务中检索产品，然后查询分布服务以返回检索到的产品的分布信息。'
- en: '**Command Query Responsibility Segregation (CQRS)**: The principle of this
    pattern is to have one or more evolving views, which usually have data coming
    from various services. Fundamentally, it splits the application into two parts—the
    command or the operating side and the query or the executor side. It is more of
    a publisher-subscriber pattern where the command side operates create/update/delete
    requests and emits events whenever the data changes. The executor side listens
    for those events and handles those queries by maintaining views that are kept
    up to date, based on the subscription of events that are emitted by the command
    or operating side.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令查询责任分离（CQRS）**：这种模式的原则是有一个或多个不断发展的视图，通常这些视图的数据来自各种服务。基本上，它将应用程序分为两部分——命令或操作方和查询或执行方。这更像是一个发布-订阅模式，其中命令方操作创建/更新/删除请求，并在数据发生变化时发出事件。执行方监听这些事件，并通过维护视图来处理这些查询，这些视图根据命令或操作方发出的事件的订阅而保持最新。'
- en: Sharing concerns
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享关注点
- en: The next big thing in distributed microservice architecture to handle is sharing
    concerns. How will general things such as API routing, security, logging, and
    configurations work? Let's look at those points one by one.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式微服务架构中的下一个重要问题是如何处理共享关注点。诸如API路由、安全性、日志记录和配置等一般事务将如何工作？让我们逐一看看这些要点。
- en: Externalized configuration
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化配置
- en: An application usually uses one or many infrastructures third-party services
    such as a service registry, message broker, server, cloud deployment platform,
    and so on. Any service must be able to run in multiple environments without any
    modifications. It should have the ability to pick up external configurations.
    This pattern is more of a guideline that advises us to externalize all the configurations,
    including database information, environment info, network location, and so on,
    that create a startup service that reads this information and prepares the application
    accordingly. There are various options available. Node.js provides setting environment
    variables; if you use Docker, then it has the `docker-compose.yml` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序通常会使用一个或多个基础设施的第三方服务，比如服务注册表、消息代理、服务器、云部署平台等等。任何服务都必须能够在多个环境中运行，而不需要进行任何修改。它应该具有获取外部配置的能力。这种模式更多地是一个指导方针，建议我们将所有配置外部化，包括数据库信息、环境信息、网络位置等，创建一个启动服务来读取这些信息并相应地准备应用程序。有各种可用的选项。Node.js提供设置环境变量；如果您使用Docker，那么它有`docker-compose.yml`文件。
- en: Observability
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观测性
- en: Revisiting the twelve-factor's required for an application, we observe that
    any application needs some centralized features, even if it's distributed. These
    centralized features help us to have proper monitoring and debugging in case of
    issues. Let's look at some of the common observability parameters to look out
    for.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视应用程序所需的十二要素，我们可以观察到，即使是分布式的，任何应用程序都需要一些集中的功能。这些集中的功能帮助我们在出现问题时进行适当的监控和调试。让我们看一些常见的可观测性参数。
- en: Log aggregation
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志聚合
- en: Each service instance will generate information about what it is doing in a
    standardized format, which contains logs at various levels such as errors, warning,
    info, debug, trace, fatal, and so on. The solution is to use a centralized logging
    service that collects logs from each service instance and stores them in some
    common place where the user can search and analyze the logs. This enables us to
    configure alerts for certain kinds of logs. Also, a centralized service will help
    to do audit logging, exception tracking, and API metrics. Available and widely
    used frameworks are **Elastic Stack** (Elasticsearch, Logstash, Kibana), **AWS
    CloudTrail**, and **AWS CloudWatch**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next big problem is to understand the behavior and application so as to
    troubleshoot problems when required. This pattern is more of a designing guideline
    that states to maintain a unique external request ID, which is maintained by a
    microservice. This external request ID needs to be passed to all services that
    are involved in handling that request and in all the log messages. Another guideline
    is to include the start time and end time of requests and operations performed
    when a microservice does the operation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding design aspects, we will see common microservice design
    patterns and understand each pattern in depth. We'll see when to use a particular
    pattern, what the problems are that it solves, and what pitfalls to avoid while
    using that design pattern.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Microservice design patterns
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As microservices evolve, so evolves its designing principles. Here are some
    of the common design patterns that help to design an efficient and scalable system.
    Some of the patterns are followed by Facebook, Netflix, Twitter, LinkedIn, and
    so on, which provide some of the most scalable architectures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous messaging microservice design pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important things to consider in a distributed system is **state**.
    Although highly powerful REST APIs, it has a very primitive flaw of being synchronous
    and thus blocking. This pattern is about achieving a non-blocking state and asynchronicity
    to maintain the same state across the whole application reliably, avoid data corruption,
    and allow a faster rate of change across the application:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Speaking contextually, if we go with the principle of single responsibility,
    a model or an entity in the application can mean something different to different
    microservices. So, whenever any change occurs, we need to ensure that different
    models are in sync with those changes. This pattern helps to solve this issue
    with the help of asynchronous messaging. In order to ensure data integrity throughout,
    there is a need to replicate the state of key business data and business events
    between microservices or datastores.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Since it''s asynchronous communication, the client or the caller
    assumes that the message won''t be received immediately, carries on and attaches
    a callback to the service. The callback is for when the response is received what
    further operation to be carried on. A lightweight message broker (not to be confused
    with orchestrators used in SOA) is preferably used. The message broker is dumb,
    that is, they are ignorant of the application state. They communicate to services
    handling events, but they never handle events. Some of the widely adopted examples
    include RabbitMQ, the Azure bus, and so on. Instagram''s feed is powered by this
    simple RabbitMQ. Based on the complexity of the project, you can introduce either
    a single receiver or multiple receivers. While a single receiver is good, soon
    it can be the single point of failure. A better approach is going reactive and
    introducing the publish-subscribe pattern of communication. That way the communication
    from the sender will be available to subscriber microservices in one go. Practically,
    when we consider a routine scenario, an update in any of the models will trigger
    an event to all its subscribers, which may further trigger the change in their
    own models. To avoid this, event bus is generally introduced in such type of a
    pattern that can fulfill the role of inter micro service communication and act
    as the message broker. Some of the commonly available libraries are **AMQP**,
    **RabbitMQ**, **NserviceBus**, **MassTransit**, and so on for scalable architecture.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example using AMQP:  [https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e](https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Take care of:** To successfully implement this design, the following aspects
    should be considered:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need high scalability, or your current domain is already a message-based
    domain, then preference should be given to message-based commands over HTTP.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing events across microservices, as well as changing the state in the
    original microservices.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that events are communicated across; mimicking the event would be
    a very bad design pattern.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the position of the subscriber's consumer to scale up performance.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to make a rest call and when to use a messaging call. As HTTP is a synchronous
    call, it should be used only when needed.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use:** This is one of the most commonly used patterns. Based on the
    following use cases, you can use this pattern or its variants as per your requirements:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to use real-time streaming, use the *Event Firehouse* pattern,
    which has *KAFKA* as one of its key components.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your complex system is orchestrated in various services, one of the variants
    of this system, RabbitMQ, is extremely helpful.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, instead of subscribing to services, directly subscribing to the datastore
    is advantageous. In such a case use, *GemFire* or *Apache GeoCode* following this
    pattern is helpful.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use:** In the following scenarios, this pattern is less recommended:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have heavy database operations during event transmission, as database
    calls are synchronous
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your services are coupled
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you don't have standard ways defined to handle data conflict situations
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend for frontends
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current world demands a mobile-first approach everywhere. The service may
    respond differently to mobile where it has to show little content, as it has very
    less content. On the web, it has to show huge content as lots of space is available.
    Scenarios may differ drastically based on the device. As for example in the mobile
    app, we may allow barcode scanner, but in desktop, it is not a wise option. This
    pattern addresses these issues and helps to effectively design microservices across
    multiple interfaces:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: With the advent of development of services supporting multiple
    interfaces, it becomes extremely painful to manage everything in one service.
    This constantly evolves change in any of the single interfaces; the need to keep
    services working in all interfaces can soon become a bottleneck and a pain to
    maintain.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Rather than maintaining a general purpose API, design one backend
    per user experience or interface, better termed as a backend for frontend (**BFFs**).
    The BFF is tightly bound to a single interface or specific user experience and
    is maintained by their specific teams so as to easily adapt to new change. While
    implementing this pattern, one of  the common concerns that occurs is maintaining
    the number of BFFs. A more generic solution would be separating concerns and having
    each BFF handle its own responsibility.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Take care of**: While implementing this design pattern, the following points
    should be taken care of as they are the most common pitfalls:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fair consideration of the amount of BFFs to be maintained. A new BFF should
    only be created when concerns across a generally available service can be separated
    out for a specific interface.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BFF should only contain client/interface-specific code to avoid code duplication.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide responsibilities across teams for maintaining BFFs.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should not be confused with a **Shim**, a converter to the convert to interface-specific
    format required for that type of interface.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use**: This pattern is extremely useful in the following scenarios:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are varying differences in a general-purpose backend service across multiple
    interfaces and there are multiple updates at any point in time in a single interface.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to optimize a single interface and not disturb the utility across other
    interfaces.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various teams, and implement an alternative language for a specific
    interface and you want to maintain it separately.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use**: While this pattern does solve lots of issues, this pattern
    is not recommended in the following scenarios:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use this pattern to handle generic parameter concerns such as authentication,
    security, or authorization. This would just increase latency.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the cost of deploying an extra service is too high.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When interfaces make the same requests and there is not much difference between
    them.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is only one interface and support for multiple interfaces is not
    there, a BFF won't make much sense.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway aggregation and offloading
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dump or move specialized, common services and functionalities to a gateway.
    This pattern can introduce simplicity by moving shared functionality into a single
    part. Shared functionality can include things such as the use of SSL certificates,
    authentication, and authorization. A gateway can further be used to join multiple
    requests into a single request. This pattern simplifies needs where a client has
    to make multiple calls to different microservices for some operation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Often, to perform a simple task, a client may need to make multiple
    HTTP calls to various different microservices. Too many calls to a server requires
    an increase in resources, memory, and threads, which adversely affects performance
    and scalability. Many features are commonly used across multiple services; an
    authentication service and a product checkout service are both going to use the
    log in the same way. This service requires configuration and maintenance. Also,
    these type of services need an extra set of eyes as they are essential. For example,
    token validation, HTTPS certificate, encryption, authorization, and authentication.
    With each deployment, it is difficult to manage that as it has to span across
    the whole system.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution:** The two major components in this design pattern are the gateway
    and gateway aggregator. The gateway aggregator should always be placed behind
    the gateway. Hence, single responsibility is achieved, with each component doing
    the operation they are meant to do.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway: **It offloads some of the common operations such as certificate
    management, authentication, SSL termination, cache, protocol translation, and
    so on to one single place. It simplifies the development and abstracts all this
    logic in one place and speeds up development in a huge organization where not
    everyone has access to the gateway, only specialized teams work on it. It maintains
    consistency throughout the application. The gateway can ensure a minimum amount
    of logging and thus help out to find the faulty microservice. It''s much like
    the facade pattern in object-oriented programming. It acts as the following:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single entry point that exposes various microservices
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution to a common operation such as authorization, authentication, central
    configuration, and so on, abstracting this logic into a single place
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router for traffic management and monitoring
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netflix uses a similar approach and they are able to handle more than 50,000
    requests per hour and they open sourced **ZuuL**:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Gateway aggregator**: It receives the client request, then it decides to
    which different systems it has to dispatch the client request, gets the results,
    and then aggregates and sends them back to the client. For the client, it is just
    one request. Overall round trips between client and server are reduced.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example for aggregator: [https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js](https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Take care of**: The following pitfalls should be properly handled in order
    to successfully implement this design pattern in microservices:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not introduce service coupling, that is, the gateway can exist independently,
    without other service consumers or service implementers.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, every microservice will be dependent on the gateway. Hence, the network
    latency should be as low as possible.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to have multiple instances of the gateway, as only a single instance
    of the gateway may introduce it as a single point of failure.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the requests goes through the gateway. Hence, it should be ensured that
    gateway has efficient memory and adequate performance, and can be easily scaled
    to handle the load. Have one round of load testing to make sure that it is able
    to handle bulk load.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce other design patterns such as bulkheads, retry, throttle, and timeout
    for efficient design.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gateway should handle logic such as the number of retries, waiting for service
    until.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cache layer should be handled, which can improve performance.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gateway aggregator should be behind the gateway, as the request aggregator
    will have another. Combining them in a gateway will likely impact the gateway
    and its functionalities.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using the asynchronous approach, you will find yourself smacked by too
    many promises of callback hell. Go with the reactive approach, a more declarative
    style. Reactive programming is prevalent from Java to Node.js to Android. You
    can check out this link for reactive extensions across different links: [https://github.com/reactivex](https://github.com/reactivex).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic should not be there in the gateway.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use**: This pattern should be used in the following scenarios:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple microservices across and a client needs to communicate with
    multiple microservices.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to reduce the frequent network calls when the client is in lesser range
    network or cellular network. Breaking it in one request is efficient as then the
    frontend or the gateway will only have to cache one request.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to encapsulate the internal structure or introduce an abstract
    layer to a large team present in your organization.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use**: The following scenarios are when this pattern won''t be
    a good fit:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you just want to reduce the network calls. You cannot introduce a whole
    level of complexity for just that need.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latency by the gateway is too much.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have asynchronous options in the gateway. Your system makes too many
    synchronous calls for operations in the gateway. That would result in a blocking
    system.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application can't get rid of coupled services.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy routing and throttling
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have multiple microservices that you want to expose across a single
    endpoint and that single endpoint routes to service as per need. This application
    is helpful when you need to handle imminent transient failures and have a retry
    loop on a failed operation, thus improve the stability of the application. This
    pattern is also helpful when you want to handle the consumption of resources used
    by a microservice.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used to meet the agreed SLAs and handle loads on resources
    and resource allocation consumption even when an increase in demand places loads
    on resources:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: When a client has to consume a multitude of microservices, challenges
    soon turn up such as client managing each endpoint and setting up separate endpoints.
    If you refactor any part of the code in any service then the client must also
    be updated as the client is directly in contact with the endpoint. Further, as
    these services are in the cloud, they have to be fault tolerant. Faults include
    temporary loss of connectivity or unavailability of services. These faults should
    be self-correcting. For example, a database service that is taking a large number
    of concurrent requests should throttle further requests until the memory load
    and resource utilization has decreased. On retrying the request, the operation
    is completed. The load on any application varies drastically on time period. For
    example, a social media chatting platform will have very less load during peak
    office hours and a shopping portal will have extreme load during festive season
    sales. For a system to perform efficiently it has to meet to agreed LSA, once
    it exceeds, subsequent requests needs to be stopped until load consumption has
    decreased.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Place gateway layer in front of microservices. This layer includes
    the throttle component, as well as retry, once failed component. With the addition
    of this layer, the client needs only to interact with this gateway rather than
    interacting with each different microservice. It lets you abstract backend calls
    from the client and thus keeping the client end simple as the client only has
    to interact with the gateway. Any number of services can be added, without changing
    the client at any point in time. This pattern can also be used to handle versioning
    effectively. A new version of the microservice can be deployed parallelly and
    the gateway can route too, based on input parameters passed. New changes can be
    easily maintained by just a configuration change at the gateway level. This pattern
    can be used as an alternative strategy to auto-scaling. This layer should allow
    network requests only up to a certain limit and then throttle the request and
    retry once the resources have been released. This will help the system to maintain
    SLAs. The following points should be considered while implementing the throttle
    component:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the parameters to consider for throttling is user requests or tenant
    requests. Assuming that a specific tenant or user triggers throttle, then it can
    be safely assumed that there's some issue with the caller.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling doesn't essentially mean to stop the requests. Lower quality resources
    if available can be given, for example, a mobile-friendly site, a lower quality
    video, and so on. Google does the same.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining priority over microservices. Based on the priority they can be placed
    in the retry queue. As an ideal solution, three queues can be maintained—cancel,
    retry, and retry-after sometime.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Take care of**: Given here are some of the most common pitfalls that we can
    come across while successfully implementing this pattern:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gateway can be a single point of failure. Proper steps have to be taken
    to ensure that it has fault tolerant capabilities during development. Also, it
    should be run in multiple instances.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway should have proper memory and resource allocation otherwise it will
    introduce a bottleneck. Proper load testing should be done to ensure that failures
    are not cascaded.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing can be done based on IP, header, port, URL, request parameter, and so
    on.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The retry policy should be crafted very carefully based on the business requirements.
    It's okay in some places to have a please try again rather than having waiting
    periods and retrials. The retry policy may also affect the responsiveness of the
    application.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For effective application, this pattern should be combined with **Circuit Breaker
    Application**.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If service is idempotent, then and only then should it be retried. Trying retrial
    on other services may have unhealthy consequences. For example, if there is a
    payment service that waits for responses from other payment gateways, the retry
    component may think it fails and may send another request and the customer gets
    charged twice.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different exceptions should handle the retry logic accordingly, based on the
    exceptions.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retry logic should not disturb transaction management. The retry policy should
    be used accordingly.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All failures that trigger a retry should be logged and handled properly for
    future scenarios.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important point to be considered is this is no replacement for exception
    handling. The first priority should be given to exceptions always, as they would
    not introduce an extra layer and add latency.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling should be added early in the system as it's difficult to add once
    the system is implemented; it should be carefully designed.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling should be performed quickly. It should be smart enough to detect
    an increase in activity and react accordingly by taking appropriate measures.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consideration between throttling and auto-scaling should be decided based on
    business requirements.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requests that are throttled should be effectively placed in a queue based
    on priority.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use:** This pattern is very handy in the following scenarios:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure that agreed LSAs are maintained.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid a single microservice consuming the majority of the pool of resources
    and avoid resource depletion by a single microservice.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle sudden bursts in consumption of microservices.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle transient and short-lived faults.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use:** In the following scenarios, this pattern should not be
    used:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling shouldn't be used as a means to handle exceptions.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When faults are long-lasting. If this pattern is applied in that case, it will
    severely affect the performance and responsiveness of the application.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambassador and sidecar pattern
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is used when we want to segregate common connectivity features
    such as monitoring, logging, routing, security, authentication, authorization,
    and more. It creates helper services that act as ambassadors and sidecars that
    do the objective of sending requests on behalf of a service. It is just another
    proxy that is located outside of the process. Specialized teams can work on it
    and let other people not worry about it so as to provide encapsulation and isolation.
    It also allows the application to be composed of multiple frameworks and technologies.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The sidecar component in this pattern acts just like a sidecar attached to
    a motorcycle. It has the same life cycle as the parent microservice, retires the
    same time a parent microservice does, and it does essential peripheral tasks:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Find a set of operations that are common throughout different
    microservices and place them inside their own container or process, thus providing
    the same interface for these common operations to all frameworks and platforms
    services in the whole system. Add an ambassador layer that acts as a proxy between
    applications and microservices. This ambassador can monitor performance metrics
    such as the amount of latency, the resource usage, and so on. Anything inside
    the ambassador can be maintained independently of the application. An ambassador
    can be deployed as a container, common process, daemon, or windows service. An
    ambassador and sidecar are not part of the microservice, but rather are connected
    to the microservice. Some of the common advantages of this pattern are as follows:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language-independent development of the sidecar and ambassador, that is, you
    don't have to build a sidecar and ambassador for every language you have in your
    architecture.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just part of the host, so it can access the same resources as any other microservice
    can.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to connection with microservices, there hardly is any latency
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netflix uses a similar approach and they have open sourced their tool **Prana**
    ([https://github.com/Netflix/Prana](https://github.com/Netflix/Prana)). Take a
    look at the following diagram:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef58f302-8dad-4ec6-8c1d-7bdd0d3b7a9b.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: '**Take care of**: The following points should be taken care of as they are
    the most common pitfalls:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ambassador can introduce some latency. Deep thought should be given on whether
    to use a proxy or expose common functionalities as the library.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding generalized functionalities in ambassador and sidecar is beneficial,
    but is it required for all scenarios? For example, consider the number of retries
    to a service, it might not be common for all use cases.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language or framework in which ambassador and sidecar will be built, managed,
    and deployed strategy for it. The decision to create single or multiple instances
    of it based on need.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility to pass some parameters from service to ambassador and proxy and
    vice versa.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The deployment pattern: this is well suited when the ambassador and sidecar
    are deployed in containers.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inter-micro service communication pattern should be such that it is framework
    agnostic or language agnostic. This would be beneficial in the long run.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use**: This pattern is extremely helpful in the following scenarios:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are multiple frameworks and languages involved and you need a common
    set of general features such as client connectivity, logging, and so on throughout
    the application. An ambassador and sidecar can be consumed by any service across
    the application.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are owned by different teams or different organizations.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need independent services for handling this cross-cutting functionality
    and they can be maintained independently.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your team is huge and you want specialized teams to handle, manage, and
    maintain core cross-cutting functionalities.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to support the latest connectivity options in a legacy application
    or an application that is difficult to change.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to monitor resource consumption across the application and cut off
    a microservice if its resource consumption is huge.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use**: While this pattern does solve many issues, this pattern
    is not recommended in the following scenarios:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When network latency is utmost. Introducing a proxy layer would introduce some
    overhead that will create a slight delay, which may not be good for real-time
    scenarios.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When connectivity features cannot be generalized and require another level of
    integration and dependency with another service.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating a client library and distributing it to the microservices development
    team as a package.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For small applications where introducing an extra layer is actually an overhead.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When some services need to scale independently; if so, then the better alternative
    would be to deploy it separately and independently.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-corruption microservice design pattern
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we need interoperability or coexistence between legacy and modern applications.
    This design provides an easy solution for this by introducing a facade between
    modern and legacy applications. This design pattern ensures that the design of
    an application is not hampered or blocked by legacy system dependencies:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: New systems or systems in the process of migration often need
    to communicate with the legacy system. The new system''s model and technology
    would probably be different, considering that old systems are usually weak, but
    still, legacy resources may be needed for some operations. Often, these legacy
    systems suffer from poor design and poor schema designs. For interoperability,
    we may still need to support the old system. This pattern is about solving such
    corruption and still have a cleaner, neater, and easier to maintain microservice
    ecosystem.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution:** To avoid using legacy code or a legacy system, design a layer
    that does the following task: acts as the only layer for communicating with legacy
    code, which prevents accessing legacy code directly wherein different people may
    deal with them differently. The core concept is to separate out a legacy or the
    corrupt application by placing an ACL with the objective of not changing the legacy
    layer, and thus avoid compromising its approach or major technological change.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **anti-corruption layer** (**ACL**) should contain all the logic for translating
    as per new needs from the old model. This layer can be introduced as a separate
    service or translator component any place where needed. A general approach to
    organizing the design of the ACL is a combination of a facade, adapters, translators,
    and communicators to talk to systems. An ACL is used to prevent unexpected behavior
    of an external system from leaking in your existing context:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2df4007f-9073-418d-b73b-27df3bd2a54b.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: '**Take care of:** While effectively implementing this pattern, the following
    points should be considered as they are some of the major pitfalls:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ACL should be properly scaled and given a better resources pool, as it will
    add latency to calls made between two systems.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the corruption layer you introduce is actually an improvement
    and you don't introduce yet another layer of corruption.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ACL adds an extra service; hence it must be effectively managed and maintained
    and scaled.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively decide the number of ACLs. There can be many reasons to introduce
    an ACL—a means to translate undesirable formats of the object in required formats
    means to communicate between different languages, and so on.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective measures to make sure that transactions and data consistency are maintained
    between both systems and can be monitored.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration of the ACL, will it be permanent, how will the communication be
    handled.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While an ACL should successfully handle exceptions from the corruption layer,
    it should not completely, otherwise it would be very difficult to preserve any
    information about the original error.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use:** The anti-corruption pattern is highly recommended and extremely
    useful in the following scenarios:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a huge system up for refactoring from monolithic to microservices and
    there is a phase-by-phase migration planned instead of the big bang migration
    wherein the legacy system and new system need to coexist and communicate with
    each other.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the system that you are undertaking is dealing with any data source whose
    model is undesirable or not in sync with the needed model, this pattern can be
    introduced and it will do the task of translating from undesirable formats to
    needed formats.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever there is a need to link two bounded contexts, that is, a system is
    developed by someone else entirely and there is very little understanding of it,
    this pattern can be introduced as a link between systems.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use:** This pattern is highly not recommended in the following
    scenarios:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no major differences between new and legacy systems. The new system
    can coexist without the legacy system.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have lots of transactional operations and maintaining data consistency between
    the ACL and the corrupt layer adds too much latency. In such case, this pattern
    can be merged with other patterns.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your organization doesn't have extra teams to maintain and scale the ACL as
    and when needed.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulkhead design pattern
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Separate out different services in the microservices application into various
    pools such that if one of the services fails, the others will continue to function
    irrespective of failure. Create a different pool for each microservice to minimize
    the impact:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: This pattern takes inspiration from sectioned out parts of a ship''s
    hull. If the hull of a ship is damaged, then only the damaged section would fill
    with water, which would prevent the ship from sinking. Let''s say you are connecting
    to various microservices that are using a common thread pool. If one of the services
    starts showing delay, then all pool members will be too exhausted to wait for
    responses. Incrementally, a large number of requests coming from one service would
    deplete available resources. That''s where this pattern suggests a dedicated pool
    for every single service.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Separate service instances into different groups based on load
    and network usage. This allows you to isolate system failures and prevent depletion
    of resources in the connection pool. The essential advantages of this system are
    the prevention of propagating failures and ability to configure capacity of the
    resource pool. For higher priority services, you may assign higher pools.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, given is a sample file from which we can see pool allocation for
    service shopping-management: [https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db](https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Take care of**: Make sure to take care of the following points to make sure
    that a proper bulkhead design is implemented:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define proper independent partitions in the application based on business and
    technical requirements.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulkheads can be introduced in forms of thread pools and processes. Decide which
    one is suitable for your application.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation in the deployment of your microservices.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use:** The bulkhead pattern adds an advantage in the following scenarios:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application is huge and you want to protect it from cascading or spreading
    failures
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can isolate critical services from standard services and you can allocate
    separate pools for them
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use:** This pattern is not advisable for the following scenarios:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you don't have that much budget for maintaining separate overheads in terms
    of cost and management
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The added level of complexity of maintaining separate pools is not necessary
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your resources usage is unexpected and you can't isolate your tenants and keep
    a limit on it as it is not acceptable when you would place several tenants in
    one partition
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services sometimes need to collaborate with each other when they need to handle
    requests. In such cases, there is a very high scenario that the other service
    is not available, is showing high latency, or is unusable. This pattern essentially
    solves this issue by introducing a breakage in the circuit that stops propagation
    in the whole architecture:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: In the microservices architecture when there is inter-services
    communication, a remote call needs to be invoked instead of an in-memory call.
    It may so happen that the remote call may fail or reach a timeout limit and hang
    without any response. Now in such cases when there are many callers, then all
    such locked threads that you can run out of resources and the whole system will
    become unresponsive.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: A very primitive idea for solving this issue is introducing a
    wrapper for a protected function call, it monitors for failures. Now this wrapper
    can be triggered via anything such as certain threshold in failures, database
    connection fails, and so on. All further calls will return with an error and stop
    catastrophic propagation. This will trip the circuit open, and while the circuit
    is open, it will avoid making the protected call. The implementation is done in
    the following three stages just as in an electric circuit. It is in three stages:
    **Closed State**, **Open State**, and **Half-Open State**, as explained in the
    following diagram:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/001feed5-8c17-48d5-b3e8-8b3db679a254.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example for implementation in Node.js: Hystrix is open sourced by
    Netflix [https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b](https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '**Take care of**: The following needs to be taken care of when you want to
    apply the circuit breaker pattern:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you are invoking a remote call, and there may be many remote call invocation
    asynchronous and reactive principles for using future, promises, async, and await
    is must.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain a queue of requests; when your queue is overcrowded, you can easily
    trip the circuit. Always monitor the circuit, as you will often need to activate
    it again for an efficient system. So, have a mechanism ready for reset and failure
    handlers.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a persistent storage and network cache such as **Memcache** or **Redis**
    to record availability.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging, exception handling, and relaying failed requests.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use**: In the following use cases, you can use the circuit breaker
    pattern:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you don't want your resources to be depleted, that is, an action that is
    doomed to fail shouldn't be tried until it is fixed. You can use it to check the
    availability of external services.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you can compromise a bit on performance, but want to gain high availability
    of the system and not deplete resources.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use**: In the following scenarios, it is not advisable to introduce
    the circuit breaker pattern:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have an efficient cache layer that monitors and maintains states of
    services for a given time for requests across the clustered nodes.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For handling in-memory structures or as the substitute for handling exceptions
    in business logic. This would add overhead to performance.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strangler pattern
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today''s world is one where technology is constantly evolving. What is written
    today, is just tomorrow''s legacy code. This pattern is very helpful when it comes
    to the migration process. This pattern is about eventually migrating a legacy
    system by incrementally replacing particular parts of functionality with new microservices
    application and services. It eventually introduces a proxy that redirects either
    to the legacy or the new microservices, until the migration is complete and at
    the end, you can shut off the strangler or the proxy:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: With aging systems, new evolving development tools, and hosting
    options, the evolution of cloud and serverless platforms maintaining the current
    system gets extremely painful with the addition of new features and functionalities.
    Completely replacing a system can be a huge task, for which gradual migration
    needs to be done such that the old system is still handled for the part that hasn''t
    been migrated yet. This pattern solves this very problem.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: The strangler solution resembles a vine that strangles a tree
    that it''s wrapped over. Over time, the migrated application strangles the original
    application until you can shut off the monolithic application. Thus, the overall
    process is as follows:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reconstruct**: Construct a new application or site (in serverless or AWS
    cloud-based on modern principles). Incrementally reconstruct the functionalities
    in an agile manner.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coexist**: Leave the legacy application as it is. Introduce a facade that
    eventually acts as a proxy and decides where to route the request based on the
    current migration status. This facade can be introduced at web server level or
    programming level based on various parameters such as IP address, user agent,
    or cookies.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminate**: Redirect everything to the modern migrated application and loosen
    off all the ties with the legacy application.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample gist of `.htaccess` that acts as a facade can be found at this link: [https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d](https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The solution instructs us to create a facade or a proxy that has the ability
    to intercept the requests that are going to the backend legacy system. The facade
    or proxy then decides whether to route it to the legacy application or the new
    microservices. This is an incremental process, wherein both the systems can coexist.
    The end users won't even know when the migration process is complete. It gives
    the added advantage that if the adopted microservice approach doesn't work, there
    is a very simple way to change it.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**Take care of**: The following points need to be taken care of for effectively
    applying the strangulation pattern:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade or the proxy needs to be updated with the migration.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade or the proxy shouldn't be a single point of failure or bottleneck.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the migration is complete, facade will evolve as the adapter for legacy
    applications.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new code written should be such that it can easily be intercepted, so in
    future, we can replace it in future migrations.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to use**: The strangler application is extremely useful when it comes
    to replacing a legacy and monolithic application with microservices. The pattern
    is used in the following cases:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to follow the test-driven on behavior-driven development, and
    run fast and comprehensive tests with the accessibility of code coverages and
    adapt CI/CD.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application can be contained bounded contexts within which a model applies
    in the region. As an example, in a shopping cart application, the product module
    would be one context.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When not to use**: This pattern may not be applicable in the following scenarios:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are not able to intercept the user agent request, or you are not able
    to introduce a facade in your architecture.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you think of doing a page by page migration at a time or you are thinking
    of doing it all at once.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your application is more frontend-driven; that's where you have to entirely
    change and rework the interacting framework based on the way the frontend is interacting
    with services, as you don't want to expose the various ways the user agent is
    interacting with services.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we debunked microservices to understand the evolution of microservices,
    the characteristics of microservices, and the advantages of microservices. We
    went through various design principles of microservices, the process of refactoring
    from monolithic applications to microservices, and the various microservice design
    patterns.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start our microservice journey. We will go through
    all the setup required for our microservice journey. We will go through concepts
    related to Node.js and TypeScript, which are essential throughout the book. We
    will also create our first microservice, `Hello World`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
