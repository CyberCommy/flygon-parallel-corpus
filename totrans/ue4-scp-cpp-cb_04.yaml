- en: Chapter 4. Actors and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom `Actor` in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating an `Actor` using `SpawnActor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an `Actor` using `Destroy` and a Timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an `Actor` after a delay using `SetLifeSpan`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Actor` functionality by composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading assets into components using `FObjectFinder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Actor` functionality by inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching components to create a hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `Actor` Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `Scene` Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `Primitive` Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an `InventoryComponent` for an RPG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an `OrbitingMovement` Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a building that spawns units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actors are classes which have some presence in the game world. Actors gain their
    specialized functionality by incorporating Components. This chapter deals with
    creating custom Actors and Components, the purpose that they serve, and how they
    work together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Actor in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are a number of different types of Actors that ship with Unreal
    as part of the default installation, you will find yourself needing to create
    custom Actors at some point during your project's development. This might happen
    when you need to add functionality to an existing class, combine Components in
    a combination not present in the default subclasses, or add additional member
    variables to a class. The next two recipes demonstrate how to use either composition
    or inheritance to customize Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have installed Visual Studio and Unreal 4 as per the recipe in
    [Chapter 1](part0015_split_000.html#E9OE1-c0ca69a0411046888a488e5085138121 "Chapter 1. UE4
    Development Tools"), *UE4 Development Tools.* You'll also need to have either
    an existing project, or create a new one using the Unreal-provided wizard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up your project within the Unreal Editor, then click on the **Add New**
    button in **Content Browser**:![How to do it...](img/00072.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New C++ Class...**![How to do it...](img/00073.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog that opens, select **Actor** from the list:![How to do it...](img/00074.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your Actor a name, such as `MyFirstActor`, then click on **OK** to launch
    Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, class names for `Actor` subclasses begin with an `A`. When using
    this class creation wizard, make sure you don't prefix your class with `A`, as
    the engine automatically adds the prefix for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When Visual Studio loads, you should see something very similar to the following
    listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In time, you'll become familiar enough with the standard code, so you will be
    able to just create new classes from Visual Studio without using the Unreal wizard.
  prefs: []
  type: TYPE_NORMAL
- en: '`#pragma once`: This preprocessor statement, or `pragma`, is Unreal''s expected
    method of implementing include guards—pieces of code that prevent an `include`
    file from causing errors by being referenced multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "GameFramework/Actor.h"`: We''re going to create an `Actor` subclass,
    so naturally, we need to include the `header` file for the class we are inheriting
    from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "MyFirstActor.generated.h"`: All actor classes need to include their
    `generated.h` file. This file is automatically created by **Unreal Header Tool**
    (**UHT**) based on the macros that it detects in your files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UCLASS()`: `UCLASS` is one such macro, which allows us to indicate that a
    class will be exposed to Unreal''s reflection system. Reflection allows us to
    inspect and iterate object properties during runtime as well as manage references
    to our objects for garbage collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class UE4COOKBOOK_API AMyFirstActor : public AActor`: This is the actual declaration
    of our class. The `UE4COOKBOOK_API` macro is created by UHT, and is necessary
    to help our project compile properly on Windows by ensuring that our project module''s
    classes are exported correctly in the DLL. You will also notice that both `MyFirstActor`
    and `Actor` have the prefix `A`—this is the naming convention that Unreal requires
    for native classes that are inherited from `Actor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GENERATED_BODY()`: `GENERATED_BODY` is another UHT macro that has been expanded
    to include the automatically generated functions that the underlying UE type system
    requires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrimaryActorTick.bCanEverTick = true;`: Inside the constructor implementation,
    this line enables ticking for this `Actor`. All Actors have a function called
    `Tick`, and this Boolean variable means that the `Actor` will have that function
    called once per frame enabling the actor to perform actions in every frame as
    necessary. As a performance optimization, this is disabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating an Actor using SpawnActor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need to have an `Actor` subclass ready to instantiate.
    You can use a built-in class such as `StaticMeshActor`, but it would help to practice
    with the custom `Actor` you made in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new C++ class, like in the previous recipe. This time, select `GameMode`
    as your base class, giving it a name such as `UE4CookbookGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a function override in your new `GameMode` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `BeginPlay` in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, either through Visual Studio or by clicking on the **Compile**
    button in Unreal Editor.![How to do it...](img/00076.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **World Settings** panel for the current level by clicking on the **Settings**
    toolbar icon, then pick **World Settings** from the drop-down menu. In the **GameMode
    Override** section, change the game mode to the `GameMode` subclass you just created
    as shown in the following two screenshots:![How to do it...](img/00077.jpeg)![How
    to do it...](img/00078.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the level, and verify that `GameMode` spawns a copy of your `Actor` in
    the world by looking at the **World Outliner** panel. You can verify that the
    `BeginPlay` function is being run by viewing the **Actor Spawning** text being
    displayed on screen. If it doesn't spawn, make sure there are no obstructions
    at the world origin to prevent the `Actor` from being spawned. You can search
    the list of objects in the world by typing in the search bar at the top of the
    **World Outliner** panel to filter the entities shown.![How to do it...](img/00079.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GameMode` is a special type of actor which is part of the Unreal Game Framework.
    Your map''s `GameMode` is instantiated by the engine automatically when the game
    starts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By placing some code into the `BeginPlay` method of our custom `GameMode`, we
    can run it automatically when the game begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we create an `FTransform` to be used by the `SpawnActor`
    function. By default, `FTransform` is constructed to have zero rotation and a
    location at the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then get a reference to the current level's `UWorld` instance using `GetWorld`,
    then call its `SpawnActor` function. We pass in `FTransform,` which we created
    earlier, to specify that the object should be created at its location, that is,
    the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destroying an Actor using Destroy and a Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will reuse the `GameMode` from the previous recipe, so you should
    complete it first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make the following changes to the `GameMode` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add `#include "MyFirstActor.h"` to the implementation file's includes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the results of `SpawnActor` to the new `SpawnedActor` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the end of the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `DestroyActorFunction`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Load the level you created in the previous recipe, which had the game mode set
    to your custom class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and use the Outliner to verify that your `SpawnedActor` gets
    deleted after 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We declare a `UPROPERTY` to store our spawned `Actor` instance, and a custom
    function to call so that we can call `Destroy()` on a timer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `BeginPlay`, we assign the spawned `Actor` to our new `UPROPERTY`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare a `TimerHandle` object, and pass it to `GetWorldTimerManager::SetTimer`.
    `SetTimer` calls `DestroyActorFunction` on the object pointed to by this pointer
    after 10 seconds. `SetTimer` returns an object—a handle—to allow us to cancel
    the timer if necessary. The `SetTimer` function takes the `TimerHandle` object
    in as a reference parameter, hence, we declare it in advance so that we can pass
    it into the function properly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DestroyActorFunction` checks if we have a valid reference to a spawned
    `Actor`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do, it calls `Destroy` on the instance, so it will be destroyed, and
    eventually, garbage collected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Destroying an Actor after a delay using SetLifeSpan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how we can destroy an `Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new C++ class using the wizard. Select `Actor` as your base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the implementation of `Actor`, add the following code to the `BeginPlay`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Drag a copy of your custom `Actor` into the viewport within the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and look at the Outliner to verify that your `Actor` instance
    disappears after 10 seconds, having destroyed itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We insert our code into the `BeginPlay` function so that it executes when the
    game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetLifeSpan(10);`: The `SetLifeSpan` function allows us to specify a duration
    in seconds, after which the `Actor` calls its own `Destroy()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Actors without components don't have a location, and can't be attached
    to other Actors. Without a root Component, an Actor doesn't have a base transform,
    and so it has no location. Most Actors, therefore, require at least one Component
    to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: We can create custom Actors through composition—adding a number of components
    to our `Actor`, where each component provides some of the functionality required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will use the `Actor` class created in the *Creating a custom Actor
    in C++* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new member to your custom class in C++ by making the following changes
    in the `public` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to the constructor inside the cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your code looks like the following snippet, and compile it by using
    the **Compile** button in the editor, or building the project in Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once you've compiled this code, drag an instance of your class from the **Content
    Browser** out into the game environment, and you will be able to verify that it
    now has a transform and other properties, such as a Static Mesh, which comes from
    the `StaticMeshComponent` that we added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UPROPERTY macro` we added to the class declaration is a pointer to hold
    the component we are using as a subobject of our `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the `UPROPERTY()` macro ensures that the object declared in the pointer
    is considered to be referenced, and won't be garbage-collected (that is, deleted)
    out from under us, leaving the pointer dangling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using a Static Mesh component, but any of the `Actor` Component subclasses
    would work. Note the asterisk is connected to the variable type in accordance
    with Epic's style guide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we initialize the pointer to a known valid value by using
    a `template` function, `template<class TReturnType> TReturnType* CreateDefaultSubobject(FName
    SubobjectName, bool bTransient = false)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function is responsible for calling the engine code to appropriately initialize
    the component, and return a pointer to the newly constructed object so that we
    can give our component pointer a default value. This is important, obviously,
    to ensure that the pointer has a valid value at all times, minimizing the risk
    of dereferencing uninitialized memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function is templated based on the type of object to create, but also takes
    two parameters—the first one is the name of the subobject, which ideally should
    be human-readable, and the second is whether the object should be transient (that
    is—not saved along with the parent object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following recipe shows you how to reference a mesh asset in your Static
    Mesh Component so that it can be displayed without requiring a user to specify
    a mesh in the Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading assets into components using FObjectFinder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we created a Static Mesh Component, but we didn't try to
    load a mesh for the Component to display. While it's possible to do this in the
    Editor, sometimes it is helpful to specify a default in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the previous recipe so you have a custom `Actor` subclass with a Static
    Mesh Component ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your **Content Browser**, click on the **View Options** button, and select
    **Show Engine Content**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Browse to **Engine Content**, then **BasicShapes** to see the **Cube** we will
    be using in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to the constructor of your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Compile, and verify in the Editor that an instance of your class now has a mesh
    as its visual representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create an instance of the `FObjectFinder` class, passing in the type of asset
    that we are trying to load as a template parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FObjectFinder` is a class template that helps us to load assets. When we construct
    it, we pass in a string that contains a path to the asset that we are trying to
    load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string is of the format `"{ObjectType}'/Path/To/Asset.Asset'"`. Note the
    use of single quotes in the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to get the string for an asset that already exists in the editor, you
    can right-click on the asset in the **Content Browser** and select **Copy Reference**.
    This gives you the string so you can paste it into your code.![How it works...](img/00082.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the `auto` keyword, from C++11, to avoid typing out our whole object
    type in its declaration; the compiler deduces it for us. Without `auto`, we would
    have to use the following code instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `FObjectFinder` class has a property called `Object` that will either have
    a pointer to the desired asset, or will be `NU``LL` if the asset could not be
    found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we can check it against `nullptr`, and if it isn't null, assign
    it to `Mesh` using `SetStaticMesh`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the second way to implement a custom `Actor`. This is commonly
    done to make a new subclass, which adds member variables, functions, or a Component
    to an existing `Actor` class. In this recipe, we are going to add a variable to
    a custom `GameState` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Unreal Editor, click on **Add New** in the **Content Browser,** and then
    on **New C++ Class...** then select **GameState** as the base class, then give
    your new class a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the new class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that your code looks like the following listing, and compile using
    the **Compile** button in the Unreal Editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we add the declaration of a default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to set our new member variable to a safe default value of `0`
    on object initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `int32` type when declaring our new variable to ensure portability
    between the various compilers that Unreal Engine supports. This variable is going
    to be responsible for storing the current game score while it is running. As always,
    we will be marking our variable with `UPROPERTY` so that it is garbage collected
    appropriately. This variable is marked `private` so that the only way to change
    the value is through our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `GetScore` function will retrieve the current score, and return it to the
    caller. It is implemented as a simple accessor, which simply returns the underlying
    member variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second function, `SetScore`, sets the value of the member variable allowing
    external objects to request a change to the score. Placing this request as a function
    ensures that the `GameState` can vet such requests, and only allow them when valid
    to prevent cheating. The specifics of such a check are beyond the scope of this
    recipe, but the `SetScore` function is the appropriate place to make it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our score functions are declared using the `UFUNCTION` macro for a number of
    reasons. Firstly, `UFUNCTION`, with some additional code, can be called or overridden
    by Blueprint. Secondly, `UFUNCTION` can be marked as `exec—`this means that they
    can be run as console commands by a player or developer during a play session,
    which enables debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* has a recipe, *Creating new console commands*, that you can refer
    to for more information regarding `exec` and the console command functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching components to create a hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating custom Actors from components, it is important to consider the
    concept of **Attaching**. Attaching components together creates a relationship
    where transformations applied to the parent component will also affect the components
    that are attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class based on `Actor` using the editor, and call it `HierarchyActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to your new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your code looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Compile and launch the editor. Drag a copy of HierarchyActor into the scene.![How
    to do it...](img/00083.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that `Actor` has components in a hierarchy, and that the second box has
    a smaller size.![How to do it...](img/00084.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we create some `UPROPERTY`-tagged Components for our actor. We create
    two Scene Components, and two Static Mesh components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we create default subobjects for each component, as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then load the static mesh, and if loading is successful, assign it to the
    two static mesh components so that they have a visual representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then construct a hierarchy within our `Actor` by attaching components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the first Scene Component as the `Actor` root. This component will determine
    the transformations applied to all other components in the hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then attach the first box to our new root component, and parent the second
    scene component to the first one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We attach the second box to our child scene component so as to demonstrate how
    changing the transform on that scene component affects its children, but no other
    components in the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we set the relative transform of that scene component so that it moves
    a certain distance away from the origin, and is one-tenth of the scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that in the Editor, you can see that the `BoxTwo` component has inherited
    the translation and scaling of its parent component, `ChildSceneComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom Actor Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actor components are an easy way to implement common functionality that should
    be shared between Actors. Actor components aren't rendered, but can still perform
    actions such as subscribing to events, or communicating with other components
    of the Actor that they are present within.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an `ActorComponent` named `RandomMovementComponent` using the Editor
    wizard. Add the following class specifiers to the `UCLASS` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `UPROPERTY` to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the constructor''s implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add this to the implementation of `TickComponent( )`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your code looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project. In the editor, create an empty `Actor`, and add your **Random
    Movement** Component to it. To do this, drag an **Empty Actor** from the **Placement**
    tab out into the level, then click on **Add Component** in the **Details** panel,
    and select **Random Movement**. Do the same thing to add a **Cube** Component
    so that you have something to visualize your actor's position with.![How to do
    it...](img/00085.jpeg)![How to do it...](img/00086.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and observe the actor randomly moving around as its location
    changes every time the `TickComponent` function is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we add a few specifiers to the `UCLASS` macro used in our component''s
    declaration. Adding `BlueprintSpawnableComponent` to the class'' meta values means
    that instances of the component can be added to blueprint classes in the editor.
    The `ClassGroup` specifier allows us to indicate what category of class our Component
    belongs to in the list of classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `MovementRadius` as a property to the new component allows us to specify
    how far the component will be allowed to wander in a single frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we initialize this property to a safe default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`TickComponent` is a function that is called every frame by the engine, just
    like `Tick` is for Actors. In its implementation, we retrieve the current location
    of the component''s owner, that is, the `Actor` that contains our component, and
    we generate an offset in the world space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We add the random offset to the current location to determine a new location,
    and move the owning actor to it. This causes the actor's location to randomly
    change from frame to frame and dance about.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom Scene Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Scene` Components are a subclass of `Actor` Components that have a transform,
    that is, a relative location, rotation, and scale. Just like `Actor` Components,
    `Scene` Components aren''t rendered themselves, but can use their transform for
    various things, such as spawning other objects at a fixed offset from an `Actor`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a custom `SceneComponent` called `ActorSpawnerComponent`. Make the following
    changes to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementation to the cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your code against this snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Compile and open your project. Drag an empty `Actor` into the scene and add
    your `ActorSpawnerComponent` to it. Select your new Component in the `Details`
    panel, and assign a value to `ActorToSpawn`. Now whenever `Spawn()` is called
    on an instance of your component, it will instantiate a copy of the `Actor` class
    specified in `ActorToSpawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create the `Spawn UFUNCTION` and a variable called `ActorToSpawn`. The `ActorToSpawn`
    `UPROPERTY` is of type `TSubclassOf< >`, a template type that allows us to restrict
    a pointer to either a base class or subclasses thereof. This also means that within
    the editor, we will get a pre-filtered list of classes to pick from, preventing
    us from accidentally assigning an invalid value.![How it works...](img/00087.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Spawn` function's implementation, we get access to our world, and
    check it for validity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpawnActor` wants an `FTransform*` to specify the location to spawn the new
    actor, so we create a new stack variable to contain a copy of the current component''s
    transform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `TheWorld` is valid, we request it to spawn an instance of the `ActorToSpawn`-specified
    subclass, passing in the address of the `FTransform` we just created, and which
    now contains the desired location for the new actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* contains a much more detailed investigation into how you can make
    things Blueprint-accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Primitive Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Primitive` components are the most complex type of `Actor` Component because
    they not only have a transform, but are also rendered on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a custom C++ class based on `MeshComponent`. When Visual Studio loads,
    add the following to your class header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create an implementation for our overridden `CreateSceneProxy` function
    in our cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns an instance of `FMySceneProxy`, which we need to implement.
    Do so by adding the following code above the `CreateSceneProxy` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our scene proxy requires a vertex buffer and an index buffer. The following
    subclasses should be placed above the Scene Proxy''s implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your code looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Create an empty `Actor` in the editor and add the new mesh component to it to
    see that your triangle is rendered. Experiment by changing the values added with
    Vertices. Add and see how the geometry changes after a recompile.![How to do it...](img/00088.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for an `Actor` to be rendered, the data describing it needs to be made
    accessible to the rendering thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to do this is with a Scene Proxy—a proxy object that is created
    on the render thread, and is designed to provide thread safety to the data transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PrimitiveComponent` class defines a `CreateSceneProxy` function that returns
    `FPrimitiveSceneProxy*`. This function allows custom components like ours to return
    an object based on `FPrimitiveSceneProxy`, leveraging polymorphism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the constructor of the `SceneProxy` object to take in an instance
    of our component so that each `SceneProxy` created knows about the component instance
    it is associated with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That data is then cached in the Scene Proxy, and passed to the renderer using
    `GetDynamicMeshElements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an `IndexBuffer` and a `VertexBuffer`. Each of the buffer classes
    we create are helpers that assist the Scene Proxy with allocating platform-specific
    memory for the two buffers. They do so in the `InitRHI` (also known as Initialize
    Render Hardware Interface) function, wherein they use functions from the RHI API
    to create a vertex buffer, lock it, copy the required data, and then unlock it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the component's constructor, we look for a material asset that is built
    into the engine with the `ObjectFinder` template so that our mesh will have a
    material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add some vertices and indexes to our buffers so that the mesh can be
    drawn when the renderer requests a Scene Proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an InventoryComponent for an RPG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `InventoryComponent` enables its containing `Actor` to store `InventoryActors`
    in its inventory, and place them back into the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you've followed the *Axis Mappings – keyboard, mouse and gamepad directional
    input for an FPS character* recipe in [Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* before continuing with
    this recipe, as it shows you how to create a simple character.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the recipe *Instantiating an Actor using SpawnActor* in this chapter shows
    you how to create a custom `GameMode`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an `ActorComponent` subclass using the engine called `InventoryComponent`,
    then add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementation to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new `StaticMeshActor` subclass called `InventoryActor`. Add
    the following to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the new functions in the implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, change the constructor to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add an `InventoryComponent` to our character so that we have an
    inventory that we can store items in. Create a new `SimpleCharacter` subclass
    using the editor, and add the following to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this line to the character''s constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code to the overriden `SetupPlayerInputComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following function implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and test it in the Editor. Create a new level and drag a few
    instances of `InventoryActor` out into your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the *Instantiating an Actor using SpawnActor* recipe if you need a
    reminder of how to override the current game mode. Add the following line to the
    constructor of your Game Mode from that recipe, then set your level''s `GameMode`
    to the one you created in that recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Verify your code against the listing here before compiling and launching your
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we need to add our `InputAction` to the bindings in the editor. To do
    this, bring up the **Project Settings...** window by selecting **Edit** | **Project
    Settings...**:![How to do it...](img/00089.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select **Input** on the left-hand side. Select the plus symbol beside
    **Action Mappings**, and type `DropItem` into the text box that appears. Underneath
    it is a list of all the potential keys you can bind to this action. Select the
    one labelled `E`. Your settings should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then we can hit play, walk over to our inventory actor, and it will be picked
    up. Press *E* to place the actor in a new location! Test this with multiple inventory
    actors to see that they all get collected and placed correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our new component contains an array of actors, storing them by pointer as well
    as declaring functions that add or remove items to the array. These functions
    are simple wrappers around the `TArray` add/remove functionality, but allow us
    to optionally do things such as checking if the array is within a specified size
    limit before going ahead with storing the item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InventoryActor` is a base class that can be used for all items that can be
    taken by a player.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PickUp` function, we need to disable the actor when it is picked up.
    To do that, we have to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable actor ticking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide the actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do this with the functions `SetActorTickEnabled`, `SetActorHiddenInGame`,
    and `SetActorEnableCollision`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PutDown` function is the reverse. We enable actor ticking, unhide the actor,
    and then turn its collision back on, and we transport the actor to the desired
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add an `InventoryComponent` to our new character as well as a function to
    take items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor for our character, we create a default subobject for our
    `InventoryComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also add a `NotifyHit` override so that we are notified when the character
    hits other Actors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this function, we cast the other actor to an `InventoryActor`. If the
    cast is successful, then we know our `Actor` was an `InventoryActor`, and so we
    can call the `TakeItem` function to take it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `TakeItem` function, we notify the Inventory item actor that we want
    to pick it up, then we add it to our inventory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last piece of functionality in the `InventoryCharacter` is the `DropItem`
    function. This function checks if we have any items in our inventory. If it has
    any items, we remove it from our inventory, then we calculate a safe distance
    in front of our player character to drop the item using the Item Bounds to get
    its maximum bounding box dimension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then inform the item that we are placing it in the world at the desired location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    has a detailed explanation of how events and input handling work together within
    the Engine, as well as a recipe for the `SimpleCharacter` class mentioned in this
    recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](part0079_split_000.html#2BASE1-c0ca69a0411046888a488e5085138121
    "Chapter 6. Input and Collision"), *Input and Collision,* also has recipes concerning
    the binding of input actions and axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an OrbitingMovement Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is similar to `RotatingMovementComponent` in that it is designed
    to make the components parented to it move in a particular way. In this instance,
    it will move any attached components in an orbit around a fixed point at a fixed
    distance.
  prefs: []
  type: TYPE_NORMAL
- en: This could be used, for example, for a shield that orbits around a character
    in an **Action RPG**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `SceneComponent` subclass and add the following properties to
    the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `TickComponent` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your work against the following listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You can test this component by creating a simple `Actor` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `OrbitingMovement` Component to your `Actor`, then add a few meshes using
    the `Cube` component. Parent them to the `OrbitingMovement` component by dragging
    them on to it in the **Components** panel. The resulting hierarchy should look
    like the following:![How to do it...](img/00091.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the *Creating a custom Actor Component* recipe if you're unsure of
    the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit play to see the meshes moving around in a circular pattern around the center
    of the `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The properties that are added to the component are the basic parameters that
    we use to customize the circular motion of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RotateToFaceOutwards` specifies whether the component will orient to face
    away from the center of rotation on every update. `RotationSpeed` is the number
    of degrees the component rotates every second.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OrbitDistance` indicates the distance that the components that rotate must
    be moved from the origin. `CurrentValue` is the current rotation position in degrees.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our constructor, we establish some sane defaults for our new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `TickComponent` function, we calculate the location and rotation of our
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The formula in the next step requires our angles to be expressed in radians
    rather than degrees. Radians describe an angle in terms of *π*. We first use the
    `DegreesToRadians` function to convert our current value in degrees to radians.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SetRelativeLocation` function uses the general equation for circular motion,
    that is—*Pos(θ) = cos(θ in radians), sin(θ in radians)*. We preserve the Z axis
    position of each object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to rotate the object back towards the origin (or else, directly
    away from it). This is only calculated if `RotateToFaceOutwards` is `true`, and
    involves getting the relative offset of the component to its parent, and creating
    a rotator based on a vector pointing from the parent to the current relative offset.
    We then set the relative rotation to the resulting rotator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we increment the current value in degrees so that it moves `RotationSpeed`
    units per second, clamping the resulting value between 0 and 360 to allow the
    rotation to loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a building that spawns units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will create a building that spawns units at a fixed time
    interval at a particular location.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Actor` subclass in the editor, as always, and then add the following
    implementation to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the implementation for the `SpawnUnit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the overridden `EndPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new character subclass, and add one property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the component in the constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the visual representation to the root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following to the `Tick` function to get the spawned actor moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify against the following snippet, then compile your project. Place a copy
    of the barracks actor into the level. You can then observe it spawning the character
    at fixed intervals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, we create the barracks actor. We add a particle system component to
    indicate where the new units will be spawning, and a static mesh for the visual
    representation of the building.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we initialize the components, and then set their values
    using `FObjectFinder`. We also set the class to spawn using the `StaticClass`
    function to retrieve a `UClass*` instance from a class type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BeginPlay` function of the barracks, we create a timer that calls our
    `SpawnUnit` function at fixed intervals. We store the timer handle in a member
    variable in the class so that when our instance is being destroyed, we can halt
    the timer; otherwise, when the timer triggers again, we'll encounter a crash where
    the object pointer is dereferenced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SpawnUnit` function gets the world space location of the `SpawnPoint` object,
    then asks the world to spawn an instance of our unit class at that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BarracksUnit` has code in its `Tick()` function to move forward by 10 units
    every frame so that each spawned unit will move to make room for the next one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EndPlay` function override calls the parent class implementation of the
    function, which is important if there are timers to cancel or deinitialization
    performed in the parent class. It then uses the timer handle stored in `BeginPlay`
    in order to cancel the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
