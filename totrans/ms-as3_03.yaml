- en: UI Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Android Studio provides many invaluable
    tools for designing layouts quickly and simply. However, we only concerned ourselves
    with the design of static UIs. This, of course, is an essential first step, but
    our interfaces can, and should, be dynamic. And, according to material design
    guidelines, user interactions should be illustrated graphically using movement
    and color to intuitively demonstrate the action being performed, such as the ripple
    animations that result from tapping on a button.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: To see how this is done, we need to look at a practical example and start building
    a simple, but functional, application. But first, we will examine one or two more
    ways of applying the look and feel we want, and Android users expect, to our designs.
    This process is largely assisted by the use of support libraries, in particular,
    the AppCompat and Design libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will begin the chapter by looking at how Android Studio facilitates the implementation
    of Material design with the material-based visual theme editor as well as the
    design support library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Generate material styles and themes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use XML fonts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create XML font families
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use basic code completion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a coordinator layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate design components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a collapsing app bar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy raw resources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the percent support library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw in the previous chapter that, when sizing and moving the screen elements
    of a constraint layout using the design editor,  our views tend to stick to a
    particular set of dimensions. These are selected according to Material design
    guidelines. In case you are unaware, Material is a design language, stipulated
    by Google and based on traditional design and animation techniques, intended to
    clean up user interfaces by communicating the process through movement and position.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Material design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Material design is by no means essential, and can be ignored entirely
    if you are developing full-screen apps such as games, which often come with their
    own design rules, it is nevertheless an elegant design paradigm and is widely
    recognized and understood by the user base.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: One very good reason for implementing Material is that many of its features,
    such as card views and sliding drawers, can be applied with great ease, thanks
    to the associated support libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: One of the first design decisions we need to take is what color scheme, or theme,
    we want to apply to our app. There are one or two material guidelines regarding
    the shade and contrast of our themes. Fortunately, Android Studio's Theme Editor
    makes generating material-compliant themes very simple indeed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Android styles
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphical properties, such as background color, text size, and elevation, can
    all be set individually on any UI component. It often makes sense to group properties
    together into a style. Android stores such styles in the values directory as XML
    in the `styles.xml` file. An example of this is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Styles, such as this, can be applied to views and widgets simply and without
    having to specify each property, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is quite possible to create any style from scratch by defining all its properties,
    but it is far more practical to take an existing style and modify only the properties
    we wish to change. This is done by setting the `parent` property, which can be
    seen in the preceding example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also inherit from our own styles and without having to set a parent
    property, for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Previously, we created a new resource file, but we could just as easily add
    a new `<style>` node to the existing `styles.xml` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to Android Studio, you will have noticed the code completion
    drop-downs that appear as you are typing, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5fccfd-3aa0-40ec-90c3-dad520a25a92.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Code completion
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an invaluable tool and we will look at it in more detail later on.
    For now, it is useful to know that code completion exists in three levels, as
    outlined briefly here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**: *Ctrl* + Space; Displays possibilities for the next word.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart**: *Ctrl*  + *Shift* + Space; Context-sensitive suggestions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement**: *Ctrl*  + *Shift* + *Enter*; Completes whole statements.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling basic and smart code completion twice in a row will broaden the scope
    of suggestions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Creating and applying styles like this is a great way of fine-tuning an app's
    appearance without having to do a great deal of extra coding, but there are also
    times when we want to apply a look and feel to an entire application, and for
    this, we use themes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Material themes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating an overall theme for an app, we have two opposing goals. On the
    one hand, we want our app to stand out from the others and be easily recognized;
    on the other, we want it to comply with the user's expectations of the platform and
    we want them to find the controls familiar and simple to use. The Theme Editor
    strikes a good compromise between individuality and conformity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'At their simplest, material themes take two or three colors and apply these
    throughout an application to give it a consistent feel and this is probably the
    major benefit of using themes. The color selected as an accent will be used to
    color checkboxes and highlight text and is generally chosen to stand out and draw
    attention. Primary colors, on the other hand, will be applied to toolbars and,
    unlike the earlier versions of Android, to the status bar and navigation bar.
    For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This enables us to control the color scheme of the entire screen when our app
    is running, avoiding ugly clashes with any native controls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The general rule of thumb for selecting these colors is to pick two shades of
    the same color for the primary values and a contrasting, but complementary, color
    for the accent. Google is a little more precise about which shades and which colors
    to use and there are no hard and fast rules to decide which colors contrast nicely
    with others. There are, however, some useful guidelines to help us, but first
    we will take a look at Google's material palette.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The Theme Editor
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google prescribes a series of 20 different hues to be used in Android apps
    and Material design web pages. Each hue comes in ten shades, as seen in the following
    examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d9278b-aebe-4f18-955e-a21a060a34e0.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Material palettes
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The full palette along with downloadable swatches can be found at: [material.io/guidelines/style/color.html#color-color-palette](http://material.io/guidelines/style/color.html#color-color-palette).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Material guidelines recommend that we use shades of 500 and 700 for our primary
    and dark primary colors and 100 for the accent. Fortunately, we do not have to
    concern ourselves overly with these numbers, as there are tools to help us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The most useful of these tools is the Theme Editor. This is another graphical
    editor and can be accessed from the main menu with Tools | Android | Theme Editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Once you open the Theme Editor, you will see that it is divided into two sections.
    To the right, we have a list of color properties, and to the left, a panel displaying
    the effect these selections have on various interface components, giving us a
    handy preview and the opportunity to try out all the manner of combinations quickly
    and intuitively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are more than just two primary colors and an accent. There
    are in fact 12, covering text and background colors, as well as alternatives for
    both dark and light themes. These are set, by default, to those of the parent
    theme declared in the `styles.xml` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly set up a customized material theme, follow the steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Studio project or open one that you wish to apply a theme to.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Theme Editor from the Tools | Android menu.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the solid color block to the left of the colorPrimary field.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3fb9816f-7996-405a-8e58-b72b5db26543.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb9816f-7996-405a-8e58-b72b5db26543.png)'
- en: Select one of the solid color blocks in the lower right corner of the Resources
    dialog and click OK.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源对话框的右下角选择一个纯色块，然后单击“确定”。
- en: Open the dialog for colorPrimaryDark and select the only suggested block on
    the right-hand side below the color selection options. It will be the same hue
    with a shade of 700.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开colorPrimaryDark对话框，然后在右侧的颜色选择选项下选择唯一的建议块。它将是相同的色调，但是700的阴影。
- en: Select the Accent property and then choose from one of the suggested colors.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择重点属性，然后从建议的颜色中选择一个。
- en: These choices can be immediately seen in the preview pane on the left-hand side
    of the editor and also from the Layout Editor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择可以立即在编辑器左侧的预览窗格中看到，也可以从布局编辑器中看到。
- en: As you can see, these colors are not declared directly but rather are references
    to the values specified in the `values/colors.xml` file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些颜色并不是直接声明的，而是引用了“values/colors.xml”文件中指定的值。
- en: Not only does the editor help create material themes by suggesting acceptable
    colors, it also helps if we want to select a color of our own choice. Clicking
    anywhere on the color table in the Select Resource window will produce a prompt
    to select closest material color.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器不仅帮助通过建议可接受的颜色来创建材料主题，还可以帮助我们选择自己选择的颜色。在“选择资源”窗口的颜色表中的任何位置单击都会提示选择最接近的材料颜色。
- en: 'When it comes to selecting appropriate colors for the accent, there are several
    schools of thought. According to color theory, there are several ways to create
    a harmonic complement to any color using a color wheel, such as the following
    one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择重点颜色时，有几种思路。根据色彩理论，可以使用色轮创建与任何颜色和谐互补色的几种方法，例如以下色轮：
- en: '![](img/cdbe5c7e-21de-4645-b7c7-c7d5bcdc50d2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdbe5c7e-21de-4645-b7c7-c7d5bcdc50d2.png)'
- en: A RYB color wheel displaying harmonic complements
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RYB色轮显示和谐互补色
- en: The simplest way to calculate an harmonic color is to take the one opposite
    to ours on the wheel (known as the direct complement). However, those of artistic
    vision consider this somewhat obvious and lacking in subtlety, and prefer what
    is known as a split complement. This equates to selecting from those colors that
    closely neighbor the direct complement, as shown previously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和谐颜色的最简单方法是取色轮上与我们相对的颜色（称为直接互补色）。然而，具有艺术视野的人认为这有些显而易见，缺乏微妙之处，并更喜欢所谓的分裂互补色。这意味着从那些与直接互补色紧密相邻的颜色中进行选择，如前所示。
- en: The Theme Editor suggests several split complements beneath the color selector
    when the accent color is being selected. However, it also suggests analogous harmonies.
    These are colors that lie close to the original, and although they look nice together,
    these are not good choices for an accent, as there is little contrast and the
    user may well miss important hints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择重点颜色时，主题编辑器在颜色选择器下方建议几种分裂互补色。然而，它也建议类似的和谐色。这些颜色与原色接近，虽然看起来很好，但不适合作为重点颜色的选择，因为对比度小，用户可能会错过重要的提示。
- en: 'There is a very pleasing JetBrains plugin available that will apply a material
    theme to the IDE itself. It can be found at: [plugins.jetbrains.com/androidstudio/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常令人愉悦的JetBrains插件可用，可以将材料主题应用于IDE本身。它可以在以下网址找到：[plugins.jetbrains.com/androidstudio/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui)。
- en: As we have just seen, the Theme Editor is very helpful when it comes to generating
    material themes. There is also a growing number of online tools that generate
    complete XML material themes with a few clicks. MaterialUps can be found at: [www.materialpalette.com](http://www.materialpalette.com).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，主题编辑器在生成材料主题时非常有帮助。还有越来越多的在线工具可以通过几次点击生成完整的XML材料主题。MaterialUps可以在以下网址找到：[www.materialpalette.com](http://www.materialpalette.com)。
- en: 'This will produce the following `colors.xml` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下“colors.xml”文件：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At first sight, this looks like a quick way to select many of a theme''s properties,
    but if you look at the text colors, you will see that they are shades of gray.
    According to Material design guidelines, this is incorrect, and the alpha channel
    should be used to create shades using transparency. This makes no difference when
    the text is on a plain background, but when placed over imagery grayscale text
    can be harder to read particularly the lighter shades, as demonstrated here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来像是选择主题属性的快速方法，但是如果查看文本颜色，你会发现它们是灰色的阴影。根据材料设计指南，这是不正确的，应该使用alpha通道使用透明度创建阴影。当文本放在纯色背景上时，这没有什么区别，但当放在图像上时，灰度文本可能更难阅读，特别是浅色阴影，如此所示：
- en: '![](img/c741db61-a0df-40d4-9a33-0cb0cc0293d1.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c741db61-a0df-40d4-9a33-0cb0cc0293d1.png)'
- en: Grayscale vs transparency
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度与透明度
- en: Android themes allow us to define the appearance of our applications in terms
    of colors, but often we will want to do more than just customize the color of
    our text, and being able to include fonts in a similar way to other resources
    is a recent and extremely useful addition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Android主题允许我们以颜色的形式定义应用程序的外观，但通常我们希望做的不仅仅是自定义文本的颜色，能够以与其他资源类似的方式包含字体是最近非常有用的补充。
- en: XML fonts
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML字体
- en: As of API level 26, it has been possible to include fonts in a project as XML
    resources in the `res` directory. This feature has simplified the task of using
    nondefault fonts in an application as well as bringing the process into line with
    other resource management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别26开始，可以将字体作为XML资源包含在“res”目录中。这一特性简化了在应用程序中使用非默认字体的任务，并使该过程与其他资源管理保持一致。
- en: 'Adding XML fonts is remarkably simple, as the following exercise demonstrates:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加XML字体非常简单，如下练习所示：
- en: Right-click on the `res` directory and select New | Android resource directory.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“res”目录，然后选择“新建|Android资源目录”。
- en: Select font from the Resource type drop-down and click on OK.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源类型下拉菜单中选择字体，然后单击“确定”。
- en: Right-click on the newly created font folder and select Show in Explorer.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename your font files so that they only contain permissible characters. For
    example, `times_new_roman.ttf` not `TimesNewRoman.ttf`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your selected fonts in the font directory.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These can now be previewed directly from the editor.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6bb1077d-554b-40f9-b5f3-b89139305ce1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: XML fonts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these fonts in a layout is even simpler than adding them as resources.
    Simply use the `fontFamily` attribute, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When working with fonts, it is common to want to emphasize words in various
    ways, such as using a bolder typeface or italicizing text. Rather than relying
    on a separate font for each of these versions, it is more convenient to be able
    to refer to font groups, or families. Simply right-click on your `font` folder
    and select New | Font resource file. This will create an empty font family file,
    which can then be filled out along the following lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is, of course, a lot more to a design language than selecting the right
    colors and fonts. There are conventions regarding spacing and proportion and,
    usually, a number of specially designed screen components. In the case of material,
    these components take the form of widgets and layouts, such as FABs and sliding
    drawers. These do not come as part of the native SDK but are included in the design
    support library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The design library
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, the design support library provides widgets and views commonly
    found in material apps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will know, the design library, like other support libraries, needs to
    be included as a gradle dependency in the module level `build.gradle` file, as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although it is always useful to understand how things are done, there is, in
    fact, a great shortcut for adding a support library as a project dependency. Open
    the Project Structure dialog from the File menu, and select your module and the
    Dependencies tab.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b24fa4-b5ac-4490-937b-f8f2fced5073.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: The project structure dialog
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: You can select the library you are after by clicking on the Add icon in the
    top right corner and selecting Library dependency from the drop-down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The project structure dialog can be summoned with the *Ctrl* + *Alt* + *Shift*
    + *S* keys.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: There are two other advantages to using this method. Firstly, the IDE will automatically
    rebuild the project, and secondly, it will always import the most recent revision.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Many developers preempt future revisions by using a plus sign, as follows: `compile
    'com.android.support:design:25.1.+'`. This has the effect of applying future minor
    revisions. However, it is not always guaranteed to work and can cause crashes,
    and it is wiser to keep versions up-to-date manually, even if this means publishing
    more updates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: As well as importing the design library, if you are planning on developing a
    material app, you will most likely want the `CardView` and `RecyclerView` libraries
    as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The best way to find your way around the IDE is to work through a practical
    example. Here, we will put together a simple weather app. It won't be at all complex,
    but it will take us through each stage of application development and it will
    adhere to the Material design guidelines.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The coordinator layout
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design library provides three layout classes. There is one for designing
    tabular activities and one for toolbars, but the most important layout is `CoordinatorLayout`,
    which acts as a material-aware container, automatically performing many material
    tricks, such as expanding headers when a user scrolls to the top of a list or
    ensuring a FABs slides out of the way when a snack bar pops up over it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinator layout should be placed as the root layout of an activity and
    would typically look like the following lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The property `fitsSystemWindows` is particularly useful, as it sets the status
    bar to partially transparent. This allows our design to dominate native controls
    without hiding them completely as well as avoiding any clashes with system colors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb5d710f-3e6e-4f7f-b6cb-129f809aedd1.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Drawing behind the status bar
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to combine `fitsSystemWindows` with our own choice of color
    using `colorPrimaryDark` to assign the status bar color.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar's color can also be changed with the `navigationBarColor`
    attribute but this is not advisable, as devices with soft navigation controls
    are becoming rarer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`CoordinatorLayout` is very similar to `FrameLayout` with one important exception.
    The coordinator layout can take direct control of its children using the `CoordinatorLayout.Behavior`
    class. The best way to see how this works is with an example.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Snackbars and Floating Action Buttons
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snackbars and **Floating Action Buttons**(**FABs**) are two of the most recognizable
    material widgets. Although not entirely replacing the toast widget, snackbars
    offer a more sophisticated form of activity notification, allowing controls and
    media rather than just text, which was the case for toasts. FABs perform the same
    function as conventional buttons but use their position to indicate their function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a coordinator layout to control behavior, `Snackbar` rising from the
    bottom of the screen would obscure any views or widgets behind it. It would be
    far preferable if the widget were to slide gracefully out of the way, something
    you will have seen often in well designed material apps. The following exercise
    explains how this is done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project in Android Studio.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the root layout of the main activity with `CoordinatorLayout` here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following button:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is followed by `Snackbar`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the main activity Java file and extend the class declaration to implement
    a click listener, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate an error and a red light bulb (known as a quick fix) will
    appear.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d50dbb5-d39a-4ab4-a132-302acbc0fa43.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Quick fix
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Select Implement methods to add `OnClickListener`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following fields to the class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create references for these components in the `onCreate()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Associate the button with the listener, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then complete the listener method, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code can now be tested on an emulator or a real device. Clicking the button
    will display `Snackbar` temporarily, sliding the FAB out of the way as it does
    so.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`Snackbar`, in the previous demonstration, behaves exactly like a toast, but
    `Snackbar` is `ViewGroup` and not a view like the toast; as a layout, it can act
    as a container. To see how this is done, replace the previous listener method
    with the one here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The way the FAB moves out of the way of `Snackbar` is handled automatically
    by the parent coordinator layout, and this is the case for all design library
    widgets and ViewGroups. We will see shortly how we have to define our own behaviors
    when including native views, such as text views and images. We can also customize
    design component behavior, but first, we will take a look at the other design
    library components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Collapsing app bars
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another well recognized Material design feature is the collapsing toolbar. This
    generally contains a relevant image and a title. This type of toolbar will fill
    a large proportion of the screen when the user scrolls to the top of the content,
    it handily tucks itself out of the way when the user wishes to view more content
    and scrolls down. This component serves a useful purpose, as it provides a great
    branding opportunity and a chance for our app to stand out visually, but it does
    so without using up valuable screen real estate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8444936-2ecf-4ca5-a266-7ad55a6728c6.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: A collapsing app bar
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see how this is constructed is to examine the XML code behind
    it. Follow the steps to recreate it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new Android Studio project. We will be creating the following layout:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/749cc7ea-4917-435a-8ed7-2aa1454447a0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Project component tree
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: First open the `styles.xml` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the parent theme speculates no action bar, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following line if you want a translucent status bar:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As before, create a layout file with `CoordinatorLayout` at its root.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, nest the following `AppBarLayout`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside this, add `CollapsingToolbarLayout`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the toolbar, add these two widgets:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Beneath `AppBarLayout`, place `NestedScrollView` and `TextView`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally add an FAB:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you now test this on a device or emulator, you will see that the toolbar
    collapses and expands automatically, without any programming, and this is the
    beauty of the design library. To code this type of behavior without it would be
    a lengthy and often difficult process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Most of the preceding XML is self-explanatory, but there are one or two points
    that are worth glancing at.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Raw text resources
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the scrolling behavior, the string used in the preceding text
    view was a lengthy one. This was placed in the `strings.xml` file, and although
    this works perfectly well, it is not an elegant way to manage lengthy texts. This
    kind of text is better dealt with as a text file resource that can be read at
    runtime.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how this is done:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a plain text file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named `raw` inside the `res` directory of your project by
    right-clicking on the `res` folder in the project explorer and selecting `New
    | Directory`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the text file to this directory.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project directories can be opened quickly from the explorer context menu.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the java activity with the text view you wish to populate and add this
    function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, add this code to the `onCreate()` method:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The other point in the preceding demonstration is the use of a hardcoded value
    for the height of the expanded toolbar, that is, `android:layout_height="300dp"`.
    This works just fine on the model it was tested on but to achieve the same effect
    on all screen types could involve creating a large number of alternative layouts.
    One simpler solution is to only recreate the `dimens` folder, which can be simply
    copied and pasted, for example, `dimens-hdpi`, and edit only the appropriate value.
    One could even create a separate file containing just this value. Another way
    to combat this is with a support library designed for just this kind of situation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The percent library
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The percent support library offers just two layout classes `PercentRelativeLayout`
    and `PercentFrameLayout`. It needs to be added to the gradle build file as a dependency,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To recreate the layout in the previous section, we need to place `AppBarLayout`
    inside `PercentRelativeLayout`. We can then use a percentage value to set the
    maximum height of our app bar, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method saves us having to create a large number of alternative layouts
    to reproduce the same effect across numerous devices, although it will always
    be necessary to generate more than one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Another effective way of achieving this uniformity is to create our image drawables
    so that they are the exact height we require in dp and set the layout height in
    XML as `wrap_content`. All we need to do then is create an image for each desired
    designated resource directory, something we were very likely to do anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Together, the preceding tools make designing material interfaces simple and
    intuitive, and also provide ways to cut down on the amount of time it takes to
    prepare layouts for the bewildering array of devices available to the user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built on the work of the previous chapter and explored how
    more sophisticated layouts can be easily constructed using the coordinator layout
    and its associated library, which does a great deal of the work for us such as
    automating collapsing toolbars and preventing overlapping widgets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by exploring another invaluable design library, the
    percent library, which can solve a multitude of design problem when developing
    for very different screen sizes and shapes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will expand on this one by exploring more dynamic elements
    for interface development, such as screen rotation, developing for wearables,
    and reading sensors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
