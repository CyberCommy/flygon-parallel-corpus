- en: UI Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Android Studio provides many invaluable
    tools for designing layouts quickly and simply. However, we only concerned ourselves
    with the design of static UIs. This, of course, is an essential first step, but
    our interfaces can, and should, be dynamic. And, according to material design
    guidelines, user interactions should be illustrated graphically using movement
    and color to intuitively demonstrate the action being performed, such as the ripple
    animations that result from tapping on a button.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this is done, we need to look at a practical example and start building
    a simple, but functional, application. But first, we will examine one or two more
    ways of applying the look and feel we want, and Android users expect, to our designs.
    This process is largely assisted by the use of support libraries, in particular,
    the AppCompat and Design libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin the chapter by looking at how Android Studio facilitates the implementation
    of Material design with the material-based visual theme editor as well as the
    design support library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate material styles and themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use XML fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create XML font families
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use basic code completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a coordinator layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate design components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a collapsing app bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy raw resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the percent support library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw in the previous chapter that, when sizing and moving the screen elements
    of a constraint layout using the design editor,  our views tend to stick to a
    particular set of dimensions. These are selected according to Material design
    guidelines. In case you are unaware, Material is a design language, stipulated
    by Google and based on traditional design and animation techniques, intended to
    clean up user interfaces by communicating the process through movement and position.
  prefs: []
  type: TYPE_NORMAL
- en: Material design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Material design is by no means essential, and can be ignored entirely
    if you are developing full-screen apps such as games, which often come with their
    own design rules, it is nevertheless an elegant design paradigm and is widely
    recognized and understood by the user base.
  prefs: []
  type: TYPE_NORMAL
- en: One very good reason for implementing Material is that many of its features,
    such as card views and sliding drawers, can be applied with great ease, thanks
    to the associated support libraries.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first design decisions we need to take is what color scheme, or theme,
    we want to apply to our app. There are one or two material guidelines regarding
    the shade and contrast of our themes. Fortunately, Android Studio's Theme Editor
    makes generating material-compliant themes very simple indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Android styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphical properties, such as background color, text size, and elevation, can
    all be set individually on any UI component. It often makes sense to group properties
    together into a style. Android stores such styles in the values directory as XML
    in the `styles.xml` file. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Styles, such as this, can be applied to views and widgets simply and without
    having to specify each property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is quite possible to create any style from scratch by defining all its properties,
    but it is far more practical to take an existing style and modify only the properties
    we wish to change. This is done by setting the `parent` property, which can be
    seen in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also inherit from our own styles and without having to set a parent
    property, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we created a new resource file, but we could just as easily add
    a new `<style>` node to the existing `styles.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to Android Studio, you will have noticed the code completion
    drop-downs that appear as you are typing, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5fccfd-3aa0-40ec-90c3-dad520a25a92.png)'
  prefs: []
  type: TYPE_IMG
- en: Code completion
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an invaluable tool and we will look at it in more detail later on.
    For now, it is useful to know that code completion exists in three levels, as
    outlined briefly here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**: *Ctrl* + Space; Displays possibilities for the next word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart**: *Ctrl*  + *Shift* + Space; Context-sensitive suggestions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement**: *Ctrl*  + *Shift* + *Enter*; Completes whole statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling basic and smart code completion twice in a row will broaden the scope
    of suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and applying styles like this is a great way of fine-tuning an app's
    appearance without having to do a great deal of extra coding, but there are also
    times when we want to apply a look and feel to an entire application, and for
    this, we use themes.
  prefs: []
  type: TYPE_NORMAL
- en: Material themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating an overall theme for an app, we have two opposing goals. On the
    one hand, we want our app to stand out from the others and be easily recognized;
    on the other, we want it to comply with the user's expectations of the platform and
    we want them to find the controls familiar and simple to use. The Theme Editor
    strikes a good compromise between individuality and conformity.
  prefs: []
  type: TYPE_NORMAL
- en: 'At their simplest, material themes take two or three colors and apply these
    throughout an application to give it a consistent feel and this is probably the
    major benefit of using themes. The color selected as an accent will be used to
    color checkboxes and highlight text and is generally chosen to stand out and draw
    attention. Primary colors, on the other hand, will be applied to toolbars and,
    unlike the earlier versions of Android, to the status bar and navigation bar.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to control the color scheme of the entire screen when our app
    is running, avoiding ugly clashes with any native controls.
  prefs: []
  type: TYPE_NORMAL
- en: The general rule of thumb for selecting these colors is to pick two shades of
    the same color for the primary values and a contrasting, but complementary, color
    for the accent. Google is a little more precise about which shades and which colors
    to use and there are no hard and fast rules to decide which colors contrast nicely
    with others. There are, however, some useful guidelines to help us, but first
    we will take a look at Google's material palette.
  prefs: []
  type: TYPE_NORMAL
- en: The Theme Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google prescribes a series of 20 different hues to be used in Android apps
    and Material design web pages. Each hue comes in ten shades, as seen in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d9278b-aebe-4f18-955e-a21a060a34e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Material palettes
  prefs: []
  type: TYPE_NORMAL
- en: The full palette along with downloadable swatches can be found at: [material.io/guidelines/style/color.html#color-color-palette](http://material.io/guidelines/style/color.html#color-color-palette).
  prefs: []
  type: TYPE_NORMAL
- en: Material guidelines recommend that we use shades of 500 and 700 for our primary
    and dark primary colors and 100 for the accent. Fortunately, we do not have to
    concern ourselves overly with these numbers, as there are tools to help us.
  prefs: []
  type: TYPE_NORMAL
- en: The most useful of these tools is the Theme Editor. This is another graphical
    editor and can be accessed from the main menu with Tools | Android | Theme Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Once you open the Theme Editor, you will see that it is divided into two sections.
    To the right, we have a list of color properties, and to the left, a panel displaying
    the effect these selections have on various interface components, giving us a
    handy preview and the opportunity to try out all the manner of combinations quickly
    and intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are more than just two primary colors and an accent. There
    are in fact 12, covering text and background colors, as well as alternatives for
    both dark and light themes. These are set, by default, to those of the parent
    theme declared in the `styles.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly set up a customized material theme, follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Studio project or open one that you wish to apply a theme to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Theme Editor from the Tools | Android menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the solid color block to the left of the colorPrimary field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3fb9816f-7996-405a-8e58-b72b5db26543.png)'
  prefs: []
  type: TYPE_IMG
- en: Select one of the solid color blocks in the lower right corner of the Resources
    dialog and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the dialog for colorPrimaryDark and select the only suggested block on
    the right-hand side below the color selection options. It will be the same hue
    with a shade of 700.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Accent property and then choose from one of the suggested colors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These choices can be immediately seen in the preview pane on the left-hand side
    of the editor and also from the Layout Editor.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, these colors are not declared directly but rather are references
    to the values specified in the `values/colors.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the editor help create material themes by suggesting acceptable
    colors, it also helps if we want to select a color of our own choice. Clicking
    anywhere on the color table in the Select Resource window will produce a prompt
    to select closest material color.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to selecting appropriate colors for the accent, there are several
    schools of thought. According to color theory, there are several ways to create
    a harmonic complement to any color using a color wheel, such as the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdbe5c7e-21de-4645-b7c7-c7d5bcdc50d2.png)'
  prefs: []
  type: TYPE_IMG
- en: A RYB color wheel displaying harmonic complements
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to calculate an harmonic color is to take the one opposite
    to ours on the wheel (known as the direct complement). However, those of artistic
    vision consider this somewhat obvious and lacking in subtlety, and prefer what
    is known as a split complement. This equates to selecting from those colors that
    closely neighbor the direct complement, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: The Theme Editor suggests several split complements beneath the color selector
    when the accent color is being selected. However, it also suggests analogous harmonies.
    These are colors that lie close to the original, and although they look nice together,
    these are not good choices for an accent, as there is little contrast and the
    user may well miss important hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a very pleasing JetBrains plugin available that will apply a material
    theme to the IDE itself. It can be found at: [plugins.jetbrains.com/androidstudio/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui).'
  prefs: []
  type: TYPE_NORMAL
- en: As we have just seen, the Theme Editor is very helpful when it comes to generating
    material themes. There is also a growing number of online tools that generate
    complete XML material themes with a few clicks. MaterialUps can be found at: [www.materialpalette.com](http://www.materialpalette.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'This will produce the following `colors.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At first sight, this looks like a quick way to select many of a theme''s properties,
    but if you look at the text colors, you will see that they are shades of gray.
    According to Material design guidelines, this is incorrect, and the alpha channel
    should be used to create shades using transparency. This makes no difference when
    the text is on a plain background, but when placed over imagery grayscale text
    can be harder to read particularly the lighter shades, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c741db61-a0df-40d4-9a33-0cb0cc0293d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Grayscale vs transparency
  prefs: []
  type: TYPE_NORMAL
- en: Android themes allow us to define the appearance of our applications in terms
    of colors, but often we will want to do more than just customize the color of
    our text, and being able to include fonts in a similar way to other resources
    is a recent and extremely useful addition.
  prefs: []
  type: TYPE_NORMAL
- en: XML fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of API level 26, it has been possible to include fonts in a project as XML
    resources in the `res` directory. This feature has simplified the task of using
    nondefault fonts in an application as well as bringing the process into line with
    other resource management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding XML fonts is remarkably simple, as the following exercise demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `res` directory and select New | Android resource directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select font from the Resource type drop-down and click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the newly created font folder and select Show in Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename your font files so that they only contain permissible characters. For
    example, `times_new_roman.ttf` not `TimesNewRoman.ttf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your selected fonts in the font directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These can now be previewed directly from the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6bb1077d-554b-40f9-b5f3-b89139305ce1.png)'
  prefs: []
  type: TYPE_IMG
- en: XML fonts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these fonts in a layout is even simpler than adding them as resources.
    Simply use the `fontFamily` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with fonts, it is common to want to emphasize words in various
    ways, such as using a bolder typeface or italicizing text. Rather than relying
    on a separate font for each of these versions, it is more convenient to be able
    to refer to font groups, or families. Simply right-click on your `font` folder
    and select New | Font resource file. This will create an empty font family file,
    which can then be filled out along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is, of course, a lot more to a design language than selecting the right
    colors and fonts. There are conventions regarding spacing and proportion and,
    usually, a number of specially designed screen components. In the case of material,
    these components take the form of widgets and layouts, such as FABs and sliding
    drawers. These do not come as part of the native SDK but are included in the design
    support library.
  prefs: []
  type: TYPE_NORMAL
- en: The design library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, the design support library provides widgets and views commonly
    found in material apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will know, the design library, like other support libraries, needs to
    be included as a gradle dependency in the module level `build.gradle` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although it is always useful to understand how things are done, there is, in
    fact, a great shortcut for adding a support library as a project dependency. Open
    the Project Structure dialog from the File menu, and select your module and the
    Dependencies tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b24fa4-b5ac-4490-937b-f8f2fced5073.png)'
  prefs: []
  type: TYPE_IMG
- en: The project structure dialog
  prefs: []
  type: TYPE_NORMAL
- en: You can select the library you are after by clicking on the Add icon in the
    top right corner and selecting Library dependency from the drop-down.
  prefs: []
  type: TYPE_NORMAL
- en: The project structure dialog can be summoned with the *Ctrl* + *Alt* + *Shift*
    + *S* keys.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other advantages to using this method. Firstly, the IDE will automatically
    rebuild the project, and secondly, it will always import the most recent revision.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers preempt future revisions by using a plus sign, as follows: `compile
    'com.android.support:design:25.1.+'`. This has the effect of applying future minor
    revisions. However, it is not always guaranteed to work and can cause crashes,
    and it is wiser to keep versions up-to-date manually, even if this means publishing
    more updates.
  prefs: []
  type: TYPE_NORMAL
- en: As well as importing the design library, if you are planning on developing a
    material app, you will most likely want the `CardView` and `RecyclerView` libraries
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to find your way around the IDE is to work through a practical
    example. Here, we will put together a simple weather app. It won't be at all complex,
    but it will take us through each stage of application development and it will
    adhere to the Material design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinator layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design library provides three layout classes. There is one for designing
    tabular activities and one for toolbars, but the most important layout is `CoordinatorLayout`,
    which acts as a material-aware container, automatically performing many material
    tricks, such as expanding headers when a user scrolls to the top of a list or
    ensuring a FABs slides out of the way when a snack bar pops up over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinator layout should be placed as the root layout of an activity and
    would typically look like the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The property `fitsSystemWindows` is particularly useful, as it sets the status
    bar to partially transparent. This allows our design to dominate native controls
    without hiding them completely as well as avoiding any clashes with system colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb5d710f-3e6e-4f7f-b6cb-129f809aedd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Drawing behind the status bar
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to combine `fitsSystemWindows` with our own choice of color
    using `colorPrimaryDark` to assign the status bar color.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar's color can also be changed with the `navigationBarColor`
    attribute but this is not advisable, as devices with soft navigation controls
    are becoming rarer.
  prefs: []
  type: TYPE_NORMAL
- en: '`CoordinatorLayout` is very similar to `FrameLayout` with one important exception.
    The coordinator layout can take direct control of its children using the `CoordinatorLayout.Behavior`
    class. The best way to see how this works is with an example.'
  prefs: []
  type: TYPE_NORMAL
- en: Snackbars and Floating Action Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snackbars and **Floating Action Buttons**(**FABs**) are two of the most recognizable
    material widgets. Although not entirely replacing the toast widget, snackbars
    offer a more sophisticated form of activity notification, allowing controls and
    media rather than just text, which was the case for toasts. FABs perform the same
    function as conventional buttons but use their position to indicate their function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a coordinator layout to control behavior, `Snackbar` rising from the
    bottom of the screen would obscure any views or widgets behind it. It would be
    far preferable if the widget were to slide gracefully out of the way, something
    you will have seen often in well designed material apps. The following exercise
    explains how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the root layout of the main activity with `CoordinatorLayout` here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by `Snackbar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the main activity Java file and extend the class declaration to implement
    a click listener, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will generate an error and a red light bulb (known as a quick fix) will
    appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d50dbb5-d39a-4ab4-a132-302acbc0fa43.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick fix
  prefs: []
  type: TYPE_NORMAL
- en: Select Implement methods to add `OnClickListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following fields to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create references for these components in the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the button with the listener, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then complete the listener method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code can now be tested on an emulator or a real device. Clicking the button
    will display `Snackbar` temporarily, sliding the FAB out of the way as it does
    so.
  prefs: []
  type: TYPE_NORMAL
- en: '`Snackbar`, in the previous demonstration, behaves exactly like a toast, but
    `Snackbar` is `ViewGroup` and not a view like the toast; as a layout, it can act
    as a container. To see how this is done, replace the previous listener method
    with the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The way the FAB moves out of the way of `Snackbar` is handled automatically
    by the parent coordinator layout, and this is the case for all design library
    widgets and ViewGroups. We will see shortly how we have to define our own behaviors
    when including native views, such as text views and images. We can also customize
    design component behavior, but first, we will take a look at the other design
    library components.
  prefs: []
  type: TYPE_NORMAL
- en: Collapsing app bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another well recognized Material design feature is the collapsing toolbar. This
    generally contains a relevant image and a title. This type of toolbar will fill
    a large proportion of the screen when the user scrolls to the top of the content,
    it handily tucks itself out of the way when the user wishes to view more content
    and scrolls down. This component serves a useful purpose, as it provides a great
    branding opportunity and a chance for our app to stand out visually, but it does
    so without using up valuable screen real estate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8444936-2ecf-4ca5-a266-7ad55a6728c6.png)'
  prefs: []
  type: TYPE_IMG
- en: A collapsing app bar
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see how this is constructed is to examine the XML code behind
    it. Follow the steps to recreate it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new Android Studio project. We will be creating the following layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/749cc7ea-4917-435a-8ed7-2aa1454447a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Project component tree
  prefs: []
  type: TYPE_NORMAL
- en: First open the `styles.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the parent theme speculates no action bar, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line if you want a translucent status bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As before, create a layout file with `CoordinatorLayout` at its root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, nest the following `AppBarLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this, add `CollapsingToolbarLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the toolbar, add these two widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Beneath `AppBarLayout`, place `NestedScrollView` and `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally add an FAB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you now test this on a device or emulator, you will see that the toolbar
    collapses and expands automatically, without any programming, and this is the
    beauty of the design library. To code this type of behavior without it would be
    a lengthy and often difficult process.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the preceding XML is self-explanatory, but there are one or two points
    that are worth glancing at.
  prefs: []
  type: TYPE_NORMAL
- en: Raw text resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the scrolling behavior, the string used in the preceding text
    view was a lengthy one. This was placed in the `strings.xml` file, and although
    this works perfectly well, it is not an elegant way to manage lengthy texts. This
    kind of text is better dealt with as a text file resource that can be read at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a plain text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named `raw` inside the `res` directory of your project by
    right-clicking on the `res` folder in the project explorer and selecting `New
    | Directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the text file to this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project directories can be opened quickly from the explorer context menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the java activity with the text view you wish to populate and add this
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this code to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The other point in the preceding demonstration is the use of a hardcoded value
    for the height of the expanded toolbar, that is, `android:layout_height="300dp"`.
    This works just fine on the model it was tested on but to achieve the same effect
    on all screen types could involve creating a large number of alternative layouts.
    One simpler solution is to only recreate the `dimens` folder, which can be simply
    copied and pasted, for example, `dimens-hdpi`, and edit only the appropriate value.
    One could even create a separate file containing just this value. Another way
    to combat this is with a support library designed for just this kind of situation.
  prefs: []
  type: TYPE_NORMAL
- en: The percent library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The percent support library offers just two layout classes `PercentRelativeLayout`
    and `PercentFrameLayout`. It needs to be added to the gradle build file as a dependency,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To recreate the layout in the previous section, we need to place `AppBarLayout`
    inside `PercentRelativeLayout`. We can then use a percentage value to set the
    maximum height of our app bar, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method saves us having to create a large number of alternative layouts
    to reproduce the same effect across numerous devices, although it will always
    be necessary to generate more than one.
  prefs: []
  type: TYPE_NORMAL
- en: Another effective way of achieving this uniformity is to create our image drawables
    so that they are the exact height we require in dp and set the layout height in
    XML as `wrap_content`. All we need to do then is create an image for each desired
    designated resource directory, something we were very likely to do anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Together, the preceding tools make designing material interfaces simple and
    intuitive, and also provide ways to cut down on the amount of time it takes to
    prepare layouts for the bewildering array of devices available to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built on the work of the previous chapter and explored how
    more sophisticated layouts can be easily constructed using the coordinator layout
    and its associated library, which does a great deal of the work for us such as
    automating collapsing toolbars and preventing overlapping widgets.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by exploring another invaluable design library, the
    percent library, which can solve a multitude of design problem when developing
    for very different screen sizes and shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will expand on this one by exploring more dynamic elements
    for interface development, such as screen rotation, developing for wearables,
    and reading sensors.
  prefs: []
  type: TYPE_NORMAL
