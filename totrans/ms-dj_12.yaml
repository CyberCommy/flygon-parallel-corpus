- en: Chapter 12. Testing in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like all mature programming languages, Django provides inbuilt *unit testing*
    capabilities. Unit testing is a software testing process where individual units
    of a software application are tested to ensure they do what they are expected
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing can be performed at multiple levels-from testing an individual
    method to see if it returns the right value and how it handles invalid data, up
    to testing a whole suite of methods to ensure a sequence of user inputs leads
    to the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is based on four fundamental concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **test fixture** is the setup needed to perform tests. This could include
    databases, sample datasets and server setup. A test fixture may also include any
    clean-up actions required after tests have been performed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **test case** is the basic unit of testing. A test case checks whether a given
    set of inputs leads to an expected set of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **test suite** is a number of test cases, or other test suites, that are executed
    as a group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **test runner** is the software program that controls the execution of tests
    and feeds the results of tests back to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software testing is a deep and detailed subject and this chapter should be considered
    to be only a bare introduction to unit testing. There are a large number of resources
    on the Internet on software testing theory and methods and I encourage you to
    do your own research on this important topic. For a more detailed discussion on
    Django's approach to unit testing, see the Django Project website.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are automated tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been testing code right throughout this book; maybe without even realizing
    it. Each time you use the Django shell to see if a function works, or to see what
    output you get for a given input, you are testing your code. For example, back
    in [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views and URLconfs*,
    we passed a string to a view that expected an integer to generate a `TypeError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a normal part of application development, however what's different
    in automated tests is that the testing work is done for you by the system. You
    create a set of tests once, and then as you make changes to your app, you can
    check that your code still works as you originally intended, without having to
    perform time consuming manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: So why create tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If creating simple applications like those in this book is the last bit of Django
    programming you do, then true, you don't need to know how to create automated
    tests. But, if you wish to become a professional programmer and/or work on more
    complex projects, you need to know how to create automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating automated tests will:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Save you time**: Manually testing the myriad complex interactions between
    components of a big application is time-consuming and error prone. Automated tests
    save time and let you focus on programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prevent problems**: Tests highlight the internal workings of your code, so
    you can see where things have gone wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Look professional**: The pros write tests. Jacob Kaplan-Moss, one of Django''s
    original developers, says "Code without tests is broken by design."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improve teamwork**: Tests guarantee that colleagues don''t inadvertently
    break your code (and that you don''t break theirs without knowing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic testing strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways to approach writing tests. Some programmers follow a discipline
    called **test-driven development**; they actually write their tests before they
    write their code. This might seem counter-intuitive, but in-fact, it''s similar
    to what most people will often do anyway: they describe a problem, then create
    some code to solve it.'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development simply formalizes the problem in a Python test case.
    More often, a newcomer to testing will create some code and later decide that
    it should have some tests. Perhaps it would have been better to write some tests
    earlier, but it's never too late to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create your first test, let's introduce a bug into your Book model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have decided to create a custom method on your Book model to indicate
    whether the book has been published recently. Your Book model may look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First we have imported two new modules: Python''s `datetime` and `timezone`
    from `django.utils`. We need these modules to be able to do calculations with
    dates. Then we have added a custom method to the `Book` model called `recent_publication`
    that works out what date it was eight weeks ago and returns true if the publication
    date of the book is more recent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s jump to the interactive shell and test our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, we have imported our book model and retrieved a book. Today
    is the 11th June, 2016 and I have entered the publication date of my book in the
    database as the 1st of May, which is less than eight weeks ago, so the function
    correctly returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, you will have to modify the publication date in your data so this
    exercise still works for you based on when you complete this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what happens if we set the publication date to a time in the
    future to, say, 1st September:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Oops! Something is clearly wrong here. You should be able to quickly see the
    error in the logic-any date after eight weeks ago is going to return true, including
    dates in the future.
  prefs: []
  type: TYPE_NORMAL
- en: So, ignoring the fact that this is a rather contrived example, lets now create
    a test that exposes our faulty logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you created your books app with Django''s `startapp` command, it created
    a file called `tests.py` in your app directory. This is where any tests for the
    books app should go. So let''s get right to it and write a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This should all be pretty straight forward as it's nearly exactly what we did
    in the Django shell, the only real difference is that we now have encapsulated
    our test code in a class and created an assertion that tests our `recent_publication()`
    method against a future date.
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering test classes and the `assertEqual` method in greater detail
    later in the chapter-for now, we just want to look at how tests work at a very
    basic level before getting onto more complicated topics.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have created our test, we need to run it. Fortunately, this is very
    easy to do, jump into your terminal and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After a moment, Django should print out something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Python `manage.py test books` looked for tests in the books application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It found a subclass of the `django.test.TestCase` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It created a special database for the purpose of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looked for methods with names beginning with "test"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `test_recent_pub` it created a Book instance whose `publication_date` field
    is 5 days in the future; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `assertEqual()` method, it discovered that its `recent_publication()`
    returns `True`, when it was supposed to return `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test informs us which test failed and even the line on which the failure
    occurred. Note also that if you are on a *nix system or a Mac, the file path will
    be different.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for a very basic introduction to testing in Django. As I said at the
    beginning of the chapter, testing is a deep and detailed subject that is highly
    important to your career as a programmer. I can't possibly cover all the facets
    of testing in a single chapter, so I encourage you to dig deeper into some of
    the resources mentioned in this chapter as well as the Django documentation.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of the chapter, I will be going over the various testing tools
    Django puts at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides a set of tools that come in handy when writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: The test client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test client is a Python class that acts as a dummy web browser, allowing
    you to test your views and interact with your Django-powered application programmatically.
    Some of the things you can do with the test client are:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulate `GET` and `POST` requests on a URL and observe the response-everything
    from low-level HTTP (result headers and status codes) to page content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the chain of redirects (if any) and check the URL and status code at each
    step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test that a given request is rendered by a given Django template, with a template
    context that contains certain values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the test client is not intended to be a replacement for Selenium
    (for more information visit [http://seleniumhq.org/](http://seleniumhq.org/))
    or other in-browser frameworks. Django''s test client has a different focus. In
    short:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Django's test client to establish that the correct template is being rendered
    and that the template is passed the correct context data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use in-browser frameworks like Selenium to test rendered HTML and the behavior
    of web pages, namely JavaScript functionality. Django also provides special support
    for those frameworks; see the section on `LiveServerTestCase` for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comprehensive test suite should use a combination of both test types.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed look at the Django test client with examples, see the Django
    Project website.
  prefs: []
  type: TYPE_NORMAL
- en: Provided TestCase classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normal Python unit test classes extend a base class of `unittest.TestCase`.
    Django provides a few extensions of this base class:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple TestCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extends `unittest.TestCase`with some basic functionality like:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and restoring the Python warning machinery state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding a number of useful assertions including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking that a callable raises a certain exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form field rendering and error treatment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing HTML responses for the presence/lack of a given fragment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that a template has/hasn't been used to generate a given response
    content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a HTTP redirect is performed by the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robustly testing two HTML fragments for equality/inequality or containment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robustly testing two XML fragments for equality/inequality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robustly testing two JSON fragments for equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to run tests with modified settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the test `Client`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom test-time URL maps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction TestCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django's `TestCase` class (described in following paragraph) makes use of database
    transaction facilities to speed up the process of resetting the database to a
    known state at the beginning of each test. A consequence of this, however, is
    that some database behaviors cannot be tested within a Django `TestCase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, you should use `TransactionTestCase`. `TransactionTestCase`
    and `TestCase` are identical except for the manner in which the database is reset
    to a known state and the ability for test code to test the effects of commit and
    rollback:'
  prefs: []
  type: TYPE_NORMAL
- en: A `TransactionTestCase` resets the database after the test runs by truncating
    all tables. A `TransactionTestCase` may call commit and rollback and observe the
    effects of these calls on the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TestCase`, on the other hand, does not truncate tables after a test. Instead,
    it encloses the test code in a database transaction that is rolled back at the
    end of the test. This guarantees that the rollback at the end of the test restores
    the database to its initial state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionTestCase` inherits from `SimpleTestCase`.'
  prefs: []
  type: TYPE_NORMAL
- en: TestCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class provides some additional capabilities that can be useful for testing
    web sites. Converting a normal `unittest.TestCase` to a Django `TestCase` is easy:
    Just change the base class of your test from `unittest.TestCase` to `django.test.TestCase`.
    All of the standard Python unit test functionality will continue to be available,
    but it will be augmented with some useful additions, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic loading of fixtures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wraps the tests within two nested `atomic` blocks: one for the whole class
    and one for each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a `TestClient` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django-specific assertions for testing for things like redirection and form
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestCase` inherits from `TransactionTestCase`.'
  prefs: []
  type: TYPE_NORMAL
- en: LiveServerTestCase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LiveServerTestCase` does basically the same as `TransactionTestCase` with
    one extra feature: it launches a live Django server in the background on setup,
    and shuts it down on teardown. This allows the use of automated test clients other
    than the Django dummy client such as, for example, the Selenium client, to execute
    a series of functional tests inside a browser and simulate a real user''s actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Test cases features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Default test client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every test case in a `*TestCase` instance has access to an instance of a Django
    test client. This client can be accessed as `self.client`. This client is recreated
    for each test, so you don''t have to worry about state (such as cookies) carrying
    over from one test to another. This means, instead of instantiating a `Client`
    in each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '... you can just refer to `self.client`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Fixture loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A test case for a database-backed website isn't much use if there isn't any
    data in the database. To make it easy to put test data into the database, Django's
    custom `TransactionTestCase` class provides a way of loading fixtures. A fixture
    is a collection of data that Django knows how to import into a database. For example,
    if your site has user accounts, you might set up a fixture of fake user accounts
    in order to populate your database during tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way of creating a fixture is to use the `manage.pydumpdata`
    command. This assumes you already have some data in your database. See the `dumpdata`
    documentation for more details. Once you''ve created a fixture and placed it in
    a `fixtures` directory in one of your `INSTALLED_APPS`, you can use it in your
    unit tests by specifying a `fixtures` class attribute on your `django.test.TestCase`
    subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s specifically what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of each test case, before `setUp()` is run, Django will flush the
    database, returning the database to the state it was in directly after `migrate`
    was called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, all the named fixtures are installed. In this example, Django will install
    any JSON fixture named `mammals`, followed by any fixture named `birds`. See the
    `loaddata` documentation for more details on defining and installing fixtures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This flush/load procedure is repeated for each test in the test case, so you
    can be certain that the outcome of a test will not be affected by another test,
    or by the order of test execution. By default, fixtures are only loaded into the
    `default` database. If you are using multiple databases and set `multi_db=True`,
    fixtures will be loaded into all databases.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the functions  to temporarily alter the value of settings in tests. Don't
    manipulate `django.conf.settings` directly as Django won't restore the original
    values after such manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: settings()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For testing purposes it''s often useful to change a setting temporarily and
    revert to the original value after running the testing code. For this use case
    Django provides a standard Python context manager (see PEP 343at [https://www.python.org/dev/peps/pep-0343](https://www.python.org/dev/peps/pep-0343))
    called `settings()`, which can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example will override the `LOGIN_URL` setting for the code in the `with`
    block and reset its value to the previous state afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: modify_settings()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It can prove unwieldy to redefine settings that contain a list of values. In
    practice, adding or removing values is often sufficient. The `modify_settings()`
    context manager makes it easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For each action, you can supply either a list of values or a string. When the
    value already exists in the list, `append` and `prepend` have no effect; neither
    does `remove` when the value doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: override_settings()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In case you want to override a setting for a test method, Django provides the
    `override_settings()` decorator (see PEP 318 at [https://www.python.org/dev/peps/pep-0318](https://www.python.org/dev/peps/pep-0318)).
    It''s used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator can also be applied to `TestCase` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: modify_settings()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Likewise, Django provides the `modify_settings()` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator can also be applied to test case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When overriding settings, make sure to handle the cases in which your app's
    code uses a cache or similar feature that retains state even if the setting is
    changed. Django provides the `django.test.signals.setting_changed` signal that
    lets you register call-backs to clean up and otherwise reset state when settings
    are changed.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As Python''s normal `unittest.TestCase` class implements assertion methods
    such as `assertTrue()` and `assertEqual()`, Django''s custom `TestCase` class
    provides a number of custom assertion methods that are useful for testing web
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertRaisesMessage`: Asserts that execution of the callable object raised
    an exception with an `expected_message` representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFieldOutput`: Asserts that a form field behaves correctly with various
    inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFormError`: Asserts that a field on a form raises the provided list
    of errors when rendered on the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFormsetError`: Asserts that the `formset` raises the provided list of
    errors when rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertContains`: Asserts that a `Response` instance produced the given `status_code`
    and that `text` appears in the content of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotContains`: Asserts that a `Response` instance produced the given
    `status_code` and that `text` does not appear in the content of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertTemplateUsed`: Asserts that the template with the given name was used
    in rendering the response. The name is a string such as `''admin/index.html''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertTemplateNotUsed`: Asserts that the template with the given name was
    not used in rendering the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRedirects`: Asserts that the response returned a `status_code` redirect
    status, redirected to `expected_url` (including any `GET` data), and that the
    final page was received with `target_status_code`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertHTMLEqual`: Asserts that the strings `html1` and `html2` are equal.
    The comparison is based on HTML semantics. The comparison takes following things
    into account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace before and after HTML tags is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All types of whitespace are considered equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All open tags are closed implicitly, for example, when a surrounding tag is
    closed or the HTML document ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty tags are equivalent to their self-closing version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordering of attributes of an HTML element is not significant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes without an argument are equal to attributes that equal in name and
    value (see the examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertHTMLNotEqual`: Asserts that the strings `html1` and `html2` are *not*
    equal. The comparison is based on HTML semantics. See `assertHTMLEqual()` for
    details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertXMLEqual`: Asserts that the strings `xml1` and `xml2` are equal. The
    comparison is based on XML semantics. Similarly to `assertHTMLEqual()`, the comparison
    is made on parsed content, hence only semantic differences are considered, not
    syntax differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertXMLNotEqual`: Asserts that the strings `xml1` and `xml2` are *not* equal.
    The comparison is based on XML semantics. See `assertXMLEqual()` for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInHTML`: Asserts that the HTML fragment `needle` is contained in the
    `haystack` one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJSONEqual`: Asserts that the JSON fragments `raw` and `expected_data`
    are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertJSONNotEqual`: Asserts that the JSON fragments `raw` and `expected_data`
    are not equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertQuerysetEqual`: Asserts that a queryset`qs` returns a particular list
    of values `values`. The comparison of the contents of `qs` and `values` is performed
    using the function `transform`; by default, this means that the `repr()` of each
    value is compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNumQueries`: Asserts that when `func` is called with `*args` and `**kwargs`
    that `num` database queries are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If any of your Django views send email using Django's email functionality, you
    probably don't want to send email each time you run a test using that view. For
    this reason, Django's test runner automatically redirects all Django-sent email
    to a dummy outbox. This lets you test every aspect of sending email-from the number
    of messages sent to the contents of each message-without actually sending the
    messages. The test runner accomplishes this by transparently replacing the normal
    email backend with a testing backend. (Don't worry-this has no effect on any other
    email senders outside of Django, such as your machine's mail server, if you're
    running one.)
  prefs: []
  type: TYPE_NORMAL
- en: 'During test running, each outgoing email is saved in `django.core.mail.outbox`.
    This is a simple list of all `EmailMessage` instances that have been sent. The
    `outbox` attribute is a special attribute that is created only when the `locmem`
    email backend is used. It doesn''t normally exist as part of the `django.core.mail`
    module and you can''t import it directly. The following code shows how to access
    this attribute correctly. Here''s an example test that examines `django.core.mail.outbox`
    for length and contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted previously, the test outbox is emptied at the start of every test
    in a Django `*TestCase`. To empty the outbox manually, assign the empty list to
    `mail.outbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Management commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Management commands can be tested with the `call_command()` function. The output
    can be redirected into a `StringIO` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Skipping tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unittest` library provides the `@skipIf` and `@skipUnless` decorators to
    allow you to skip tests if you know ahead of time that those tests are going to
    fail under certain conditions. For example, if your test requires a particular
    optional library in order to succeed, you could decorate the test case with `@skipIf`.
    Then, the test runner will report that the test wasn't executed and why, instead
    of failing the test or omitting the test altogether.
  prefs: []
  type: TYPE_NORMAL
- en: The test database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests that require a database (namely, model tests) will not use your production
    database; separate, blank databases are created for the tests. Regardless of whether
    the tests pass or fail, the test databases are destroyed when all the tests have
    been executed. You can prevent the test databases from being destroyed by adding
    the `-keepdb` flag to the test command. This will preserve the test database between
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: If the database does not exist, it will first be created. Any migrations will
    also be applied in order to keep it up to date. By default, the test databases
    get their names by prepending `test_` to the value of the `NAME` settings for
    the databases defined in `DATABASES`. When using the SQLite database engine, the
    tests will by default use an in-memory database (that is, the database will be
    created in memory, bypassing the filesystem entirely!).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use a different database name, specify `NAME` in the `TEST`
    dictionary for any given database in `DATABASES`. On PostgreSQL, `USER` will also
    need read access to the built-in `postgres` database. Aside from using a separate
    database, the test runner will otherwise use all of the same database settings
    you have in your settings file: `ENGINE`, `USER`, `HOST`, and so on. The test
    database is created by the user specified by `USER`, so you''ll need to make sure
    that the given user account has sufficient privileges to create a new database
    on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Using different testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clearly, `unittest` is not the only Python testing framework. While Django doesn't
    provide explicit support for alternative frameworks, it does provide a way to
    invoke tests constructed for an alternative framework as if they were normal Django
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `./manage.py test`, Django looks at the `TEST_RUNNER` setting
    to determine what to do. By default, `TEST_RUNNER` points to `django.test.runner.DiscoverRunner`.
    This class defines the default Django testing behavior. This behavior involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing global pre-test setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking for tests in any of the following file the in current directory whose
    name matches the pattern `test*.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the test databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running migrate to install models and initial data into the test databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the tests that were found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destroying the test databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performing global post-test teardown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define your own test runner class and point `TEST_RUNNER` at that class,
    Django will execute your test runner whenever you run `./manage.py test`.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, it's possible to use any test framework that can be executed from
    Python code, or to modify the Django test execution process to satisfy whatever
    testing requirements you may have.
  prefs: []
  type: TYPE_NORMAL
- en: See the Django Project website for more information on using different testing
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to write tests for your Django projects, we will be moving
    on to a very important topic once you are ready to turn your project into a real
    live website-deploying Django to a web server.
  prefs: []
  type: TYPE_NORMAL
