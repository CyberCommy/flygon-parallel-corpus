- en: Basics of Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably the most important part of software is actually getting it delivered
    and ready to use for the end users. **Continuous Delivery** (**CD**) is the point
    at which you deliver a software product to your end users and is the basis of
    this chapter. A product is only useful if your intended users can actually use
    it. Throughout this chapter, we will discuss the deployment pipeline and tie in
    the concept of automation and CD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Problems delivering software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you understand the concept of automation and continuous
    integration. If you feel unsure about either of these topics, read [Chapter 1](69088250-887a-4306-ac24-fcda17be315b.xhtml), *CI/CD
    with Automated Testing*, and [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),
    *Basics of Continuous Integration,* before reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml](https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml).
  prefs: []
  type: TYPE_NORMAL
- en: Problems delivering software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of things that can go wrong when trying to deliver a software
    product to your end users, and we will look at several scenarios that affect delivering
    software. One possible scenario is that developers are working on a new feature
    but the new feature may not actually pass CI build stages or may not behave in
    the intended way initially proposed by product owners. Another possible scenario
    is that the intended audience was not properly understood, which would affect
    the usage of the end product by users. Another possible scenario is that the software
    product was not properly decoupled and was put together with bubblegum and tape,
    with many regressions occurring with new feature requests.
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean by delivering software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be much argument about what delivering software actually means. For
    the purposes of this chapter, what is meant is that the actual software product
    has been delivered to the intended user—not just that the software product was
    approved by the **quality assurance** (**QA**) department as working.
  prefs: []
  type: TYPE_NORMAL
- en: Common release anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There exists some common release anti-patterns that you should avoid, such as
    deploying software manually, manual configuration management, and different environment
    configurations for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying software manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of anti-pattern is common and can lead to bottlenecks in the delivery
    of software. The day of software delivery is stressful and error prone. Tom from
    operations starts his day by copying software artifacts from the version control
    system into a production environment. Tom copies files through the **File Transmission
    Protocol** (**FTP**) but forgets to add a new configuration file and the login
    page does not work anymore. Tom has to talk to the developer team and ask whether
    there are new configuration files that have been added, and waits for several
    hours to get a response.
  prefs: []
  type: TYPE_NORMAL
- en: Once Tom gets the new configuration file, he uploads it to the production environment.
    The Login page works now, but some pages are loading with weird image placement
    and irregularities. Tom pings the UI/UX team and finds out that a CSS file is
    missing in the production environment. Tom uploads the CSS file and now the page
    loads correctly. Tom asks the customer success team whether they can further test
    the new changes in the production environment and finally calls it a day around
    7 PM.
  prefs: []
  type: TYPE_NORMAL
- en: If there exists a long document detailing the delivery of a software product,
    this can indicate a manual process. This further complicates delivering a product
    because mistakes anywhere in the process can lead to more issues. If a delivery
    tends to be unpredictable, this can point to this anti-pattern as well.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment automation to the rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](69088250-887a-4306-ac24-fcda17be315b.xhtml),
    *CI/CD with Automated Testing*, automation is the process in which an action is
    done in a repeatable and automated fashion. Software delivery should be an automated
    process as this will help ensure the consistent practice and behavior of software
    delivery. We will look at tools later on in this chapter that will help you automate
    the software delivery processes.
  prefs: []
  type: TYPE_NORMAL
- en: Manual configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of anti-pattern can be frustrating to operations personnel, as they
    will be the last to know about new behaviors in a product. If the day of software
    delivery is the first time the operations team has seen the new feature, then
    they may be in for a surprise in software behavior. Cindy, an operations team
    member, has been tasked with delivering software and notices that the install
    script is completely broken because it cannot communicate with the **Identification**
    (**ID**) server. Cindy sends log messages to the development team and finds out
    that one of the client secrets for the ID server has changed and that the install
    script needs to use this new value in order to properly connect.
  prefs: []
  type: TYPE_NORMAL
- en: This type of problem could have been mitigated had Cindy been aware of this
    new change in the ID server, but the developers were working with another environment
    and the QA department was given this information to test the new feature, but
    no one thought to pass this information to operations until they encountered the
    issue on the day of delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss tools that can help with configuration management issues, such
    as those encountered previously. Using the proper tooling, operations/DevOps personnel
    can quickly get the right environment configuration for each environment, including
    the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: How a production environment differs from other environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of anti-pattern can be especially challenging because of all the changes
    that have been tested in development, and a staging environment may behave erratically
    in production. For example, Travis works as a tester in the QA department and
    has been testing the staging environment since the inception of the new feature.
    Billy, an operations person, has not been able to see the new feature as the staging
    environment is completely different to the production environment. Billy also
    notices that the production environment data is missing critical information shown
    in the staging environment. Billy contacts the development team and finds out
    that a database migration script must be run for the new feature to work in production.
  prefs: []
  type: TYPE_NORMAL
- en: The production environment should be the same as the staging environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the environments, including testing, staging, and production, should all
    have the necessary migration scripts and any other software assets to prevent
    production breakages, and the development team should make sure to point operations
    to any changes in script files or clearly mark such changes in a shared document.
  prefs: []
  type: TYPE_NORMAL
- en: How to conduct a software release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some important steps to consider when doing a software release, such
    as doing frequent releases to avoid introducing too many changes at once and making
    sure that releases are automated.
  prefs: []
  type: TYPE_NORMAL
- en: Frequent releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software release must be frequent. Big software releases tend to be riddled
    with issues, so it is best to make the deltas (changes) between releases small.
    By increasing the frequency of software releases, you also get the benefit of
    faster feedback. Large software releases tend to take longer, and critical feedback
    may not get delivered as fast.
  prefs: []
  type: TYPE_NORMAL
- en: Automated releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual releases are problematic because they are not repeatable. Each time a
    manual release is done, it will be different because of configuration changes,
    changes in the software, and changes in the environment. Manual release steps
    are riddled with mistakes as each step is manual and can lead to cascading mistakes.
    A good example of the hazards of manual changes is when **Amazon Web Services**
    (**AWS**), the most popular cloud provider, suffered a major outage in the eastern
    US region because an operations person entered the wrong command in a series of
    steps in a manual process. Automation is the key to software releases because
    they ensure repeatability and control over the software delivery process. We will
    look at deployment scripting tools further in this chapter to help with automating
    software deliveries.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of automation in delivering software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we illustrated previously, automation is important in software delivery as
    it ensures the repeatability, reliability, and predictability of a software release.
    Catastrophic events can be avoided or mitigated by having an automated software
    delivery process instead of a long manual process.
  prefs: []
  type: TYPE_NORMAL
- en: Team empowerment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QA department can safely select older versions of software releases to test
    regressions if automation is in place. Operations personnel can run the scripts
    used in staging and not encounter issues because of environment-level differences.
    With an automated software process, operations personnel can safely roll back
    a release in case of disaster in the delivery process. Also, as we talked about
    in the [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),  *Basics of Continuous
    Integration*, automation can help bring push button releases.
  prefs: []
  type: TYPE_NORMAL
- en: Error reduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation can help reduce errors that manual processes can create. As we saw
    earlier, configuration management issues can lead to poor software delivery. Manual
    software releases cannot effectively ensure repeatability and therefore are error
    prone.
  prefs: []
  type: TYPE_NORMAL
- en: Stress reduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another benefit is reduced stress by all personnel during software delivery
    days. Manual processes tend to create undue stress as whoever is doing the manual
    process must be diligent and not make any mistakes in the delivery process. An
    automated delivery process is great in that it ensures that each run will be executed
    in the same manner. A mistake in an manual process might require support from
    senior personnel in fixing issues.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration files that hold important information, such as client secrets
    and passwords, must be managed properly and must be kept with sync in other environments.
    Each environment may have different environment variables that must be used and
    passed into the application.
  prefs: []
  type: TYPE_NORMAL
- en: What does configuration management mean anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration management can be briefly described as the process by which all
    software artifacts that are pertinent to each given project—as well as any relationships
    between the software artifacts—are retrieved, stored, identified, and modified.
  prefs: []
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control is the means of keeping revisions between all software artifacts.
    Version control is very important to configuration management as any changes to
    files that contain environment files should be under version control.
  prefs: []
  type: TYPE_NORMAL
- en: Tony, a member of the development team, has been using a properties file that
    has not been put under source control and has been making changes to the **single
    sign-on** (**SSO**) flow in the product. Tony accidentally deletes the file and
    loses all the client IDs and secrets that are necessary during the SSO flow. Tony
    must now go to different API portals and regenerate the client secret for some
    of the properties, as they are only shown once during creation, and now he must
    notify other members of the team to update their properties files.
  prefs: []
  type: TYPE_NORMAL
- en: Example properties file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have added a sample properties file that has client secret information and
    authentication secret information. This is necessary for the given environment
    to run properly but should not be checked into source control, it is here for
    demonstration purposes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `TOKEN_SECRET` environment variable is only seen once, so if it is lost,
    then you must regenerate it in the API portal.
  prefs: []
  type: TYPE_NORMAL
- en: Version control management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of version control management tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Git** ([https://git-scm.com/](https://git-scm.com/)): Git is a distributed
    version control system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mercurial** ([https://www.mercurial-scm.org/](https://www.mercurial-scm.org/)):
    Mercurial is also a distributed version control system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subversion** ([https://subversion.apache.org/](https://subversion.apache.org/)):
    Subversion is considered a centralized version control system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fossil** ([https://www.fossil-scm.org/](https://www.fossil-scm.org/)): Fossil
    is a distributed version control system like Git although lesser known'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important practice is to keep everything that you possibly can under version
    control to avoid losing important work in a software product. Network files, configuration
    files, deployments scripts, database scripts, build scripts, and any other artifact
    that is important for your application to properly run should be under version
    control, or else you risk losing critical data.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting software check-ins often
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to do check-ins into your main branch often, or else you risk
    introducing breaking changes into your codebase. Additionally, frequent check-ins
    help developers stay mindful of bringing in small changes at any given time. Large
    sweeping changes to a codebase should be avoided as they are harder to test and
    can bring regressions. Frequent check-ins are also beneficial because breaking
    changes will be noticed much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Writing descriptive and meaningful commit messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use descriptive commit messages that include issue tracking information, such
    as a Jira issue, for example, that clearly describe the intent of the commit.
    Avoid writing commit messages that are vague, such as `Fixed bug` or `Wrapped
    up`, as these types of commit messages are not useful and are not helpful to developers
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a sample descriptive commit message [DEV-1003] added a new navigation
    link to the Parts Supply list. A test case for the new navigation was also added. This
    is clearly more descriptive. Additionally, in Jira, when you provide an issue
    such as DEV-1003, it will create a link in the Jira issue that references the
    work on this issue. Also, if you create a pull request and put `git commit` with
    the Jira issue, it will link your pull requests with the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for applications to have third-party dependencies that are critical
    to the software product. Dependency management is an important part of any application
    and different programming languages handle dependency management differently.
  prefs: []
  type: TYPE_NORMAL
- en: Example Node.js dependency file and Gopkg.toml dependency file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a `Gopkg.toml` file that has version and package information for each
    dependency in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Dependency management like this is important because third-party dependencies
    can easily bring breaking changes to an application, and API changes in a third-party
    dependency can break critical behavior in any running application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing software components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, software projects will start with a monolithic build that has all the
    working components in one layer. As an application grows in size and maturity,
    the layers of an application will break into services or different layers and
    this is where having separate build pipelines becomes necessary. Perhaps an ID
    service is used for authentication in an application and perhaps an admin service
    is run in a separate build pipeline for an administrative portal. Microservices
    architecture is a continuation of this service level componentization of an application,
    where each microservice has a clear and focused purpose in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Software configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration is an important part of any application and should be treated
    with the same level of care as your business-level logic that you use in your
    code. Configuration therefore needs to be properly managed and tested just like
    your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Configurability and flexibility concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first thought, it may seem appropriate to make configuration as flexible
    as you can. *Why not make a system as flexible as possible, and allow it to adapt
    to any type of environment?* This is commonly known as an anti-pattern of *ultimate
    configurability*, meaning that a configuration can behave like a programming language
    and can be made to behave in any manner. Configuration management done in this
    way can bring a software project to its knees as its users will come to expect
    such flexibility as necessary. It is more useful to set some constraints in place
    for your configuration management. Constraints can help rein in the effects of
    too much flexibility in a configured environment.
  prefs: []
  type: TYPE_NORMAL
- en: Specific types of configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of possible types of configuration that an application can utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration can be pulled and incorporated into application binaries at **build
    time**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages such as C/C++ and Rust can do such build-time configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration can be injected at **package time** when creating assemblies
    or gems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages such as C#, Java, and Ruby can use such configuration options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration can be done at **deployment time **meaning a deployment script
    or installer can fetch any necessary information as needed, or the deployment
    script can ask a user to pass such information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at this later in the book with the Jenkins, Travis, and CircleCI
    tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration can be done at **startup time or** **runtime**,meaning when an
    application is launching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages like Node.js often inject environment variables when a Node.js server
    is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management across applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration management becomes more complicated when you take configuration
    across different applications. There are tools that can help with configuration
    across application boundaries, and here is a list of such tools:'
  prefs: []
  type: TYPE_NORMAL
- en: CFEngine ([https://cfengine.com/](https://cfengine.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet ([https://puppet.com/](https://puppet.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chef ([https://www.chef.io/chef/](https://www.chef.io/chef/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible ([https://www.ansible.com/](https://www.ansible.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker with Kubernetes ([https://www.docker.com/](https://www.docker.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardware, software, infrastructure, and any external systems that an application
    depends on can be thought of as the environment of the application. The creation
    of any environment should be done in a fully automated manner because the ability
    to reproduce an environment is important, as we will illustrate.
  prefs: []
  type: TYPE_NORMAL
- en: Manual environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The manual setup of infrastructure can be problematic for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: A manually set up server instance may be configured to suit a single operations
    person. This operations person may be gone from an organization, leaving core
    infrastructure broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing a manually set up environment may take a long time, and fixing issues
    in such an environment is not reproducible and repeatable, for that matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually setup environments may not be capable of being copied for testing purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important configuration information for environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of important configuration information that all environments
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party dependency and software packages that need to be installed on each
    environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking topology information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External services necessary for an application to run, such as a database service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data or seed data to get a fresh environment set up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools such as Docker and Kubernetes have risen in popularity because of their
    ability to isolate environment-level information and to create reproducible/repeatable
    environments. Using Docker, you can declare all of your external services, such
    as Redis and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `docker-compose` YML script for the API workshop repo
    ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a database as well as a caching service (Redis) and an API
    that all run as an isolated container, all of which can have environment-level
    information such as environment variables, that can be configured separately.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spoke about the importance of CI in [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),
    *Basics of Continuous Integration*, and while CI is an important productivity
    enhancer, it is mainly useful for development teams. It is common to see bottlenecks
    in software life cycles with QA and operations teams when waiting for fixes or
    updated documentation. QA can be left waiting for a good build by the development
    team. Development teams may also receive bug reports many weeks after they have
    completed a new feature. All of these situations lead to non-deployable software,
    which ultimately leads to software that you cannot deliver to your end users.
    Creating push button deployment builds that can be deployed to testing, staging,
    and production environments can help alleviate such issues, as we noted previously.
  prefs: []
  type: TYPE_NORMAL
- en: What is a deployment pipeline?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A deployment pipeline can be thought of as end-to-end automation of build, deploy,
    test, and release processes. A deployment pipeline can also be thought of as the
    process for getting software that is written by developers into the hands of your
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment pipeline practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some deployment pipeline practices to follow,
    such as building binaries once, handling deployments the same way in each environment,
    and making a commit stage in a deployment pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Building binaries once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binaries that are compiled multiple times can be problematic for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Binaries can have different contexts at each run, which will introduce unpredictability
    to your system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically compiled languages, such as C/C++, can have different compiler versions
    on each run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party software may have different version specified on different compilation
    execution contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling binaries multiple times also leads to an inefficient deployment pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recompiling binaries can also be time consuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is better to compile binaries once during compile time if you can do so.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment should be done the same way in every environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers commonly deploy their software all the time when you consider a CI
    build that runs on each source code check-in. QA/testers will not deploy as often,
    and operations even less so. Deploying to a production environment will be done
    much less frequently than for a development environment, and for good reason.
  prefs: []
  type: TYPE_NORMAL
- en: A deployment script should be created that can be run for development, staging,
    and production environments. Any changes that are necessary in each environment
    can be managed with a properties files that is managed in version control. You
    can use, for example, an environment variable in the deployment script to differentiate
    the different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Commit stage – first step of the deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first stage of a deployment pipeline is the commit stage or whenever developers
    check in code to version control. As soon as code is checked in to a CI build
    pipeline, the build pipeline should compile any code if necessary, run a suite
    of unit tests (hopefully some exist) and integration tests, create any binaries
    if needed for the deployment pipeline later on, run static analysis tooling to
    check the health of the codebase, and prepare any build artifacts needed later
    for the deployment pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other metrics that are important for the commit stage build to
    look at, such as code coverage, duplication in the code base, cyclomatic complexity
    (measures the complexity in codebase), monitoring a large number of warning messages,
    and code style (usually reported by a linting tool).
  prefs: []
  type: TYPE_NORMAL
- en: If the commit build stage passes, then we can think of it as the first gate
    to pass through, albeit an important one.
  prefs: []
  type: TYPE_NORMAL
- en: Test gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In extreme programming, developers create acceptance tests that serve as functional-level
    tests that test a certain aspect of a software system. An example would be a user
    logging in to a system and a user logging out of a system. Another example would
    be a user going to their profile and updating information. Such tests are much
    broader than unit and integration tests and so they uncover system-level issues
    if they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests build stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a suite of acceptance tests should be the second gate of a deployment
    pipeline. The acceptance tests also serve as a regression test suite to verify
    that new features have not been introduced into the system. During this stage,
    any test failures that occur in the acceptance test suite need to be evaluated
    on a case-by-case basis. The failure may be due to intentional behavior changes
    in the system, and so the acceptance test suite needs to be updated or the failure
    may represent a regression that needs to be addressed. Either way, the acceptance
    test suite must be fixed as soon as possible. The acceptance tests act as another
    gate in order for the deployment pipeline to progress down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acceptance tests do provide a level of assurance that a system behaves as it
    should, but only a human can detect anomalies in a system. QA/testers can perform
    user-level testing of a system to ensure the proper usability of a system. The
    testers can also perform exploratory testing of a system. The automated acceptance
    test suite helps free up time for the testers to perform this higher-value testing.
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nonfunctional testing is aptly named because these types of tests are not functional
    requirements of a system. Instead, nonfunctional tests test things such as capacity
    and security in a system. Failures in this step of the deployment pipeline may
    not need to mark a build as a failure but can simply serve as decision-making
    metrics on a build.
  prefs: []
  type: TYPE_NORMAL
- en: Release preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is always an associated risk when conducting a release, and so it is best
    to have processes in place when conducting a software release. Problems that occur
    during a release will be prevented but they can be mitigated by having processes
    set up during a release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some possible steps to follow during a release:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a release plan that both involves and is created by everyone involved
    in delivering a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate as much of the release process as possible to prevent mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releases should be rehearsed often in production like environments to help debug
    possible issues that may occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up processes to migrate any production data that is being used and to migrate
    configuration information in case of a rollback (reverting a release back a version)
    or upgrading a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating release processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to automate as much of a release process as you can, as the more automation
    in place, the more control you have over the release process. Manual steps tend
    to be error prone and can lead to unexpected outcomes. Any changes that occur
    in a production environment need to be locked down properly, meaning changes are
    done via automated processes.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting rollbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Release days tend to be stressful because mistakes that occur during the release
    process can create hard-to-detect issues, or the new system that is being released
    may have defects. Rehearsing releases can help mitigate such issues and can help
    people quickly solve issues that they may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: The best strategy is to have a previous version of a software system ready before
    the release and after the release in case you have to roll back the system to
    a previous version; this excludes any necessary data migration or configuration.
    As another viable alternative, you can redeploy a known good version of an application.
    The rollback should be able to be done at a click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment scripting is necessary because the software written by development
    teams is not just run on their IDE or local environment but instead needs to be
    run during the deployment pipeline. Deployment scripting refers to the particular
    build tooling you use to write scripts for the deployment pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are already many build tools, and each come with their own pros and cons. Here
    is a small list of build tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)):
    Make is a language-agnostic build tool that has been used for a long time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven** ([https://maven.apache.org/](https://maven.apache.org/)): Maven is
    a build tool primarily used for Java projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSBuild** ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)): MSBuild
    is a build tool primarily used for the .NET family of programming languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rake** ([https://ruby.github.io/rake/](https://ruby.github.io/rake/)): Rake
    is a Make-like build tool that was originally intended for Ruby'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gulp.js** ([https://gulpjs.com/](https://gulpjs.com/)): A build tool that
    is used for frontend web development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack** ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)): A
    build tool that is used for Haskell environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment scripting concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of whatever build tool you use, you need to follow certain practices
    when conducting deployment scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a script for each stage in the deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the commit stage of a deployment pipeline, you will have actions that
    the deployment script will need to do. For example, you might need to compile
    any source files, run a suite of unit and integration tests, and run a linting
    tool that checks code style and perhaps a static analysis tool. All of these steps
    might require using different tools, so writing a script that does all of this
    is best. Depending on the particular actions of the script, you might want to
    further break down a script into subscripts that perform focused actions. During
    the acceptance test stage, your script might run the entire acceptance test suite
    and additionally generate some reports and metrics about the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Every environment should use the same scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should use the same exact script in all the environments, as this will ensure
    that the build and deployment process is being done the same way in each environment.
    If you have a different script for each environment, then you cannot ensure that
    the particular script being run is behaving the same way in a different environment.
    The deployment scripts that developers run in their local environments should
    be the same as those run in other environments, or else you risk environment leakage.
    What we mean here is that the developers environment might have specific environment
    variables set than the deployment script or each environment, such as development,
    staging, and production, might have different environment variables set, which
    will make debugging harder when issues arise.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment process should not change on each run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deployment process should remain the same on each run that is done. In mathematics,
    there is a term called **idempotent**, which basically states a certain operation
    can be done multiple times with the same outcome. If your deployment process changes
    on any given run then you cannot guarantee the behavior of each run, which in
    turn will make troubleshooting much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment scripting best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses deployment scripting best practices, such as making sure
    to test only known good foundations, testing environment configuration, using
    relative paths, and removing manual processes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing only known good foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should not be testing source code that cannot even compile and you should
    not bother to run any acceptance tests when the unit and integration tests are
    failing. Basically, there must exist a known good baseline for any of the additional
    stages of the deployment process to be run and to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the environment configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the deployment pipeline is going through each stage and subsequently passes
    through each stage, it is good to check that the respective stage is functioning
    correctly. The tests you do for the associated stage can be thought of as **smoke**
    tests. For example, checking that a website is up and running by accessing the
    URL, and checking that a record in a database can still be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: Using relative paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to use relative paths over absolute paths. A developer might have
    a certain filesystem or folder structure that does not exist in the environment
    where the deployment pipeline is running, so it is best to use relative paths
    so as not to create unintended breakages. It may be difficult at times to do this,
    but it is best to follow it as much as you can. Docker containers can map folder
    structures for each container; for example, if a Docker container is spawned on
    a particular part of the deployment pipeline, it can be mapped to a certain relative
    folder structure as well.
  prefs: []
  type: TYPE_NORMAL
- en: Removing manual processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid making build scripts that contain a list of steps you must do to finish
    a particular part of a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of possible steps in a manual process:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy all of the images from the root of the project into the `static/build`
    folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a manual migration of data on a new production release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If someone has to SSH into a box and run a script, this could be problematic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any steps that must be done manually can quickly become out of date in a document,
    so the easiest instruction to follow is, if you have to do an action a second
    time, to make an automated process.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly go over some tools that can help you in your
    deployment pipeline and that serve different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly mentioned Chef earlier in the chapter; Chef is a great tool to use
    to automate standing up infrastructure in a reliable manner. It is difficult without
    the proper tools to make sure that each new environment that you set up is done
    in the same manner. Potentially, you could create new environments that have different
    configurations, which can be very problematic when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud providers and tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three main cloud providers all have their own associated tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS** ([https://aws.amazon.com/](https://aws.amazon.com/)): AWS has a suite
    of tools for CI/CD:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeCommit** is a fully managed source control service. For more information,
    refer to [https://aws.amazon.com/codecommit/](https://aws.amazon.com/codecommit/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeDeploy** is a service that automates software deployments to a variety
    of compute services, including Amazon EC2, AWS Lambda, and instances running on-premises.
    For more information, refer to [https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure** ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)):
    Visual Studio Team Services is an end-to-end CI/CD service. For more information,
    refer to [https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google App Engine** ([https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/)):
    Google App Engine is more agnostic than the other cloud providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Jenkins, Travis, and CircleCI/CD tooling with all of the major cloud
    providers, although Microsoft Azure and AWS have created their own CI/CD tooling
    that you can use as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD, as we have seen, centers around the concept of automation. Throughout this
    chapter, we have learned about what delivering software means. We first examined
    the common issues that arise when delivering software. We also discussed configuration
    management in detail and the roles that version control and dependency management
    play in any configuration. We also looked at the deployment pipeline and took
    an in-depth look at the different build stages. In the deployment scripting section,
    we looked at some build tools that exist and set some best practices to follow.
    Lastly, we briefly looked at the deployment ecosystem and some of the cloud providers.
    In the next chapter, we will discuss the problems of communication among different
    teams, how to communicate pain points to other team members, sharing responsibility
    among different teams, demonstrating to stakeholders why CI/CD is important, and
    how to get approval for CI/CD with business stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we mean by delivering software?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some common release anti-patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some benefits of automation when delivering software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does configuration management even mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you write descriptive and meaningful commit messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deployment pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should deployment be done the same way in each environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider reading the book *DevOps: Continuous Delivery, Integration, and Deployment
    with DevOps*, by *Packt Publishing*, to get a more in-depth understanding of CD.'
  prefs: []
  type: TYPE_NORMAL
