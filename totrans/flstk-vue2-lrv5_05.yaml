- en: Integrating Laravel and Vue.js with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll migrate the Vuebnb frontend prototype into our main Laravel
    project, achieving the first full-stack iteration of Vuebnb. This fully-integrated
    environment will include a Webpack build step, allowing us to incorporate more
    sophisticated tools and techniques as we continue to build the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Laravel's out-of-the-box frontend app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-level overview of Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure Laravel Mix to compile frontend assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating the Vuebnb prototype into the full-stack Laravel environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ES2015 with Vue.js, including syntax and polyfills for older browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching hard-coded data in the frontend app to backend data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laravel frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We think of Laravel as being a backend framework, but a fresh Laravel project
    includes boilerplate code and configuration for a frontend app as well.
  prefs: []
  type: TYPE_NORMAL
- en: The out-of-the-box frontend includes JavaScript and Sass asset files, as a well
    as a `package.json` file that specifies dependencies such as Vue.js, jQuery, and
    Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at this boilerplate code and configuration so we get an idea
    of how the Vuebnb frontend app will fit into our Laravel project when we begin
    the migration.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript assets are kept in the `resources/assets/js` folder. There are several `.js` files
    in this directory, as well as a sub-directory component, with a `.vue` file. This
    latter file will be explained in another chapter so we'll ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: The main JavaScript file is `app.js`. You'll see the familiar Vue constructor
    in this file, but also some syntax that may not be as familiar. On the first line
    is a `require` function that is intended to import an adjacent file, `bootstrap.js`,
    which in turn loads other libraries including jQuery and Lodash.
  prefs: []
  type: TYPE_NORMAL
- en: '`require` is not a standard JavaScript function and must be resolved somehow
    before this code can be used in a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't heard of *Sass* before, it's a CSS extension that makes it easier
    to develop CSS. A default Laravel installation includes the `resources/assets/sass` directory, which
    includes two boilerplate Sass files.
  prefs: []
  type: TYPE_NORMAL
- en: The main Sass file is `app.scss`. Its job is to import other Sass files including
    the Bootstrap CSS framework.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/sass/app.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Node modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another key aspect of the Laravel frontend is the `package.json` file in the
    root of the project directory. Similar to `composer.json`, this file is used for
    configuration and dependency management, only for Node modules rather than PHP.
  prefs: []
  type: TYPE_NORMAL
- en: One of the properties of `package.json` is `devDependencies`, which specifies
    the modules required in the development environment, including jQuery, Vue, and
    Lodash.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To serve the frontend app with Laravel, it needs to be included in a view. The
    only out-of-the-box view provided is the welcome view, located at `resources/views/welcome.blade.php`, which
    is used as a boilerplate home page.
  prefs: []
  type: TYPE_NORMAL
- en: The welcome view does not actually include the frontend app and it's left to
    the user to install it themselves. We'll look at how to do this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Asset compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The files in `resources/assets` include functions and syntax that can''t be
    used directly in a browser. For example, the `require` method used in `app.js`,
    which is designed to import a JavaScript module, is not a native JavaScript method
    and is not part of the standard Web API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9687148e-76da-46c2-8876-0ac1a022d93b.png)Figure 5.1. require is
    not defined in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'A build tool is needed to take these asset files, resolve any non-standard
    functions and syntax, and output code that the browser can use. There are a number
    of popular build tools for frontend assets including Grunt, Gulp, and Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf0b1519-498e-4862-89e3-418509ed2104.png)Figure 5.2\. Asset compilation
    process'
  prefs: []
  type: TYPE_NORMAL
- en: The reason we go to the effort of using this asset compilation process is so
    we can author our frontend app without the constraints of what a browser allows.
    We can introduce a variety of handy development tools and features that'll allow
    us to write our code and fix problems more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is the default build tool supplied with Laravel 5.5 and we'll be making
    use of it in the development of Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: What makes Webpack different to other popular build tools, such as Gulp and
    Grunt, is that it's first and foremost a *module bundler*. Let's begin our overview
    of Webpack by getting an understanding of how the module bundling process works.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a frontend application, we are likely to have dependencies for third-party
    JavaScript libraries or even other files in our own code base. For example, the
    Vuebnb prototype is dependent on Vue.js and the mock-listing data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a6df745-de9c-465b-b804-0dec5598bfc7.png)Figure 5.3\. Vuebnb prototype
    dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: There's no real way of managing these dependencies in a browser, other than
    to ensure any shared functions and variables have global scope and that scripts
    are loaded in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, since `node_modules/vue/dist/vue.js` defines a global `Vue` object
    and is loaded first, we''re able to use the `Vue` object in our `app.js` script.
    If either of those conditions was not met, `Vue` would not be defined when `app.js`ran,
    resulting in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This system has a number of downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Global variables introduce possibilities of naming collisions and accidental
    mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script loading order is fragile and can be easily broken as the app grows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't utilize performance optimizations, such as loading scripts asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A solution to the dependency management problem is to use a module system, such
    as CommonJS or native ES modules. These systems allow JavaScript code to be modularized
    and imported into other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a CommonJS example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a Native ES modules example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that CommonJS cannot be used in a browser (it was designed for
    server-side JavaScript) and native ES modules are only now getting browser support.
    If we want to use a module system in a project, we'll need a build tool: Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of resolving modules into browser-friendly code is called **bundling**.
    Webpack begins the bundling process with the **entry file**as a starting point.
    In the Laravel frontend app, `resources/assets/js/app.js` is the entry file.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack analyzes the entry file to find any dependencies. In the case of `app.js`,
    it will find three: `bootstrap`, `vue`, and `Example.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Webpack will resolve these dependencies and then analyze them to find any dependencies
    that they might have. This process continues until all dependencies of the project
    are found. The result is a graph of dependencies that, in a large project, might
    include hundreds of different modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack uses this graph of dependencies as a blueprint for bundling all the
    code into a single browser-friendly file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of what makes Webpack so powerful is that during the bundling process it
    can *transform* a module with one or more Webpack loaders.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *Babel* is a compiler that transforms next-generation JavaScript
    syntax such as ES2015 into standard ES5\. The Webpack Babel loader is one of the
    most popular as it allows developers to write their code using modern features,
    but still provide support in older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the entry file, we see the ES2015 `const` declaration that isn't
    supported by IE10.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the Babel loader is used, `const` will be transformed to `var` before it's
    added to the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '`public/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Laravel Mix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the downsides of Webpack is that configuring it is arduous. To make thing
    easier, Laravel includes a module called *Mix* that takes the most commonly-used
    Webpack options and puts them behind a simple API.
  prefs: []
  type: TYPE_NORMAL
- en: The Mix configuration file can be found in the root of the project directory.
    Mix configuration involves chaining methods to the `mix` object that declare the
    basic build steps of your app. For example, the `js` method takes two arguments,
    the entry file and the output directory, and the Babel loader is applied by default.
    The `sass` method works in an equivalent way.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a high-level understanding of Webpack, let's run it and see
    how it bundles the default frontend asset files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure you have all the development dependencies installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Webpack is typically runs from the command line, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Rather than figuring out the correct CLI option ourselves, we can use one of
    the Weback scripts predefined in `package.json`. For example, the `development` script
    will run Webpack with options suitable for creating a development build.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now run the `dev` script (a shortcut for the `development` script):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After this runs, you should see an output in the Terminal similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6ad468e2-6365-48eb-a310-d318e82f8f4d.png)Figure 5.4\. Webpack Terminal
    output'
  prefs: []
  type: TYPE_NORMAL
- en: This output tells us a number of things, but most importantly that the build
    was successful and what files were created in the output including fonts, JavaScript,
    and CSS. Note that the output file path is relative not to the project root but
    to the `public` directory, so the `js/apps.js` file will be found at `public/js/app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inspecting the output JavaScript file, `public/js/app.js`, we see a whole lot
    of code in there - around 42,000 lines! That's because jQuery, Lodash, Vue, and
    the other JavaScript dependencies have all been bundled into this one file. It's
    also because we've used a development build that does not include minification
    or uglification.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you search through the file, you''ll see that the code from our entry file, `app.js`,
    has been transpiled to ES5 as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/63bd67a1-8729-460c-b088-42e7291fc09b.png)Figure 5.5\. Bundle file public/js/app.js'
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also have a CSS bundle file, `public/css/app.css`. If you inspect this file
    you will find the imported Bootstrap CSS framework has been included and the Sass
    syntax has been compiled to plain CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might think it's strange that there are fonts in the output, since Mix did
    not include any explicit font configuration. These fonts are dependencies of the
    Bootstrap CSS framework and Mix, by default, will output them individually rather
    than in a font bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Vuebnb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're familiar with the default Laravel frontend app code and configuration,
    we're ready to migrate the Vuebnb prototype into the main project. This migration
    will allow us to have all our source code in one place, plus we can utilize this
    more sophisticated development environment for building the remainder of Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration will involve:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing any unnecessary modules and files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the prototype files into the Laravel project structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifications to the prototype files to adapt them to the new environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2938293a-97c3-4d88-bdbd-1bcc5ee042b9.png)Figure 5.6\. Vuebnb prototype
    migration'
  prefs: []
  type: TYPE_NORMAL
- en: Removing unnecessary dependencies and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by removing the Node dependencies we no longer need. We''ll keep `axis` as
    it''ll be used in a later chapter, and `cross-env` because it ensures our NPM
    scripts can be run in a variety of environments. We''ll get rid of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command will leave your dev dependencies looking like this.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll remove the files we don''t need. This includes several of the
    JavaScript assets, all of the Sass plus the welcome view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we're removing all the Sass files, we'll also need to remove the `sass` method
    in the Mix configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now our frontend app is free from clutter and we can move the prototype files
    into their new home.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now copy the contents of `index.html`from the prototype project we completed
    in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping Vuebnb,
    Your First Vue.js Project*, into a new file, `app.blade.php`. This will allow
    the template to be used as a Laravel view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We'll also update the home web route to point to this new view instead of welcome.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Syntax clash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the prototype template file as a view will cause a small issue as Vue
    and Blade share a common syntax. For example, look at the heading section where
    Vue.js interpolates the title and address of a listing.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When Blade processes this, it will think the double curly brackets are its own
    syntax and will generate a PHP error as neither `title` nor `address` are defined
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple solution: escape these double curly brackets to let Blade
    know to ignore them. This can be done by placing an `@` symbol as a prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve done that for each set of double curly brackets in the file, load
    the home route in the browser to test the new view. Without the JavaScript or
    CSS it doesn''t look great, but at least we can confirm it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d297a0df-877b-4072-a869-98891fd553f0.png)Figure 5.7\. Home route'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now move the prototype''s main script file, `app.js`, into the Laravel
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Given the current Mix settings, this will now be the entry file of the JavaScript
    bundle. This means JavaScript dependencies at the bottom of the view can be replaced
    with the bundle, that is.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Can be replaced with,
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Mock data dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s copy the mock data dependency into the project as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Currently, this file declares a global variable `sample` thatis then picked
    up in the entry file. Let's make this file a module by replacing the variable
    declaration with an ES2015 `export default`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/data.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can now import this module at the top of our entry file. Note that Webpack
    can guess the file extension in an import statement so you can omit the `.js` from `data.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While Laravel has opted to use CommonJS syntax for including modules, that is `require`,
    we will use native ES module syntax, that is `import`. This is because ES modules
    are making their way into the JavaScript standard, and it's more consistent with
    the syntax used by Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying modules with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run a Webpack build to make sure the JavaScript migration is working
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, you''ll see the JavaScript bundle file being output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc3060e9-abb3-4da4-b9fc-918d2bdecdaa.png)Figure 5.8\. Webpack Terminal
    output'
  prefs: []
  type: TYPE_NORMAL
- en: It'd be nice to know that the mock data dependency was added without having
    to manually inspect the bundle to find the code. We can do this by telling Webpack
    to print the modules it has processed in the Terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `development` script in our `package.json`, a `--hide-modules` flag has
    been set, as some developers prefer a succinct output message. Let''s remove it
    for now and instead add the `--display-modules` flag, so the script looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the build again, and we get this more verbose terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6df01ea4-90bf-477f-a649-b37a04ae4c36.png)Figure 5.9\. Webpack Terminal
    output with the display-modules flag'
  prefs: []
  type: TYPE_NORMAL
- en: This assures us that both our `app.js` and `data.js` files are included in the
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now import Vue.js as a dependency of our entry file.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the build again, we''ll now see Vue.js in the list of modules in the
    Terminal output, plus some dependencies that it has introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c460263-f2d3-40b6-8dd6-0ace4c0d1278.png)Figure 5.10\. Webpack Terminal
    output showing Vue.js'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering how `import Vue from 'vue'` resolves, as it doesn't seem
    to be a proper file reference. Webpack will, by default, check the `node_modules` folder
    in the project for any dependencies, saving you from having to put `import Vue
    from 'node_modules/vue';`.
  prefs: []
  type: TYPE_NORMAL
- en: But how, then, does it know the entry file of this package? Looking at the Webpack
    Terminal output in the preceding screenshot, you can see that it has included `node_modules/vue/dist/vue.common.js`.
    It knows to use this file because, when Webpack is adding node modules as dependencies,
    it checks their `package.json` file and looks for the `main` property, which in
    the case of Vue is.
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/vue/package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, Laravel Mix overrides this to force a different Vue build.
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/laravel-mix/setup/webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In short, `import Vue from 'vue'` is effectively the same as `import Vue from
    'node_modules/vue/dist/vue.common.js'`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explain the different Vue builds in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that done, our JavaScript has been successfully migrated. Loading the
    home route again, we can better make out the listing page of Vuebnb with the JavaScript
    now included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b177096b-bc47-4952-b83d-8c01b30b73b9.png)Figure 5.11\. Home route
    with JavaScript migrated'
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To migrate CSS, we''ll copy `style.css`from the prototype into the Laravel
    project. The default Laravel frontend app used Sass rather than CSS, so we''ll
    need to make a directory for CSS assets first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's then make a new declaration in our Mix config to get a CSS bundle using
    the `styles` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We'll now link to the CSS bundle in our view by updating thelink's `href`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Font styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also have the Open Sans and Font Awesome style sheets to include. First,
    install the font packages with NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We'll modify our Mix configuration to bundle our app CSS, Open Sans, and Font
    Awesome CSS together. We can do this by passing an array to the first argument
    of the `styles` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Mix will append statistics about the CSS bundle into the Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4a097b9-3772-4381-8d74-5433c0bc8d85.png)Figure 5.12\. Webpack Terminal
    output with CSS'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to remove the links to the font style sheets from the view as these
    will now be in the CSS bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Sans and Font Awesome need both a CSS style sheet, and the relevant font
    files. Like CSS, Webpack can bundle fonts as modules, but we currently don't need
    to take advantage of this. Instead, we'll use the `copy` method, which tells Mix
    to copy the fonts from their home directory into the `public` folder where they
    can be accessed by the frontend app.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: After building again, you'll now see a `public/fonts` folder in the project
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll now migrate the images, including the logo for the toolbar, and the
    mock data header image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's chain on another `copy` method to include these in the `public/images` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We also need to ensure the view is pointing to the correct file location for
    the images. In the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: And in the modal.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that the `headerImageStyle` data property in the entry file also
    needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'While not exactly an image, we''ll also migrate the `favicon`. This can be
    put straight into the `public` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After building again, we''ll now have the Vuebnb client app prototype fully
    migrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/402bf3b1-0a52-4dd7-843e-7780f2577cbe.png)Figure 5.13\. Vuebnb client
    app prototype served from Laravel'
  prefs: []
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can utilize some handy development tools to improve our frontend workflow,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Watch mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BrowserSync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been running builds of our app manually using `npm run dev` every
    time we make a change. Webpack also has a watch mode where it automatically runs
    a build when a dependency changes. Thanks to the design of Webpack, it is able
    to efficiently complete these automatic builds by only rebuilding modules that
    have changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use watch mode, run the `watch` script included in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that it works, add this at the bottom of `resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If watch mode is running correctly, saving this file will trigger a build, and
    you'll see updated build statistics in the Terminal. If you then refresh the page
    you'll see the Testing watch message in the console.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off watch mode, press *Ctrl* + *C* in the Terminal. It can then be restarted
    at any time. Don't forget to remove the `console.log` once you're satisfied watch
    mode is working.
  prefs: []
  type: TYPE_NORMAL
- en: I'll assume you're using *watch* for the rest of the book, so I won't remind
    you to build your project after changes anymore!
  prefs: []
  type: TYPE_NORMAL
- en: BrowserSync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful development tool is BrowserSync. Similar to watch mode, BrowserSync
    monitors your files for changes, and when one occurs inserts the change into the
    browser. This saves you from having to do a manual browser refresh after every
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use BrowserSync, you''ll need to have the Yarn package manager installed.
    If you''re running terminal commands from within the Vagrant Box, you''re all
    set, as Yarn is pre-installed with Homestead. Otherwise, follow the installation
    instructions for Yarn here: [https://yarnpkg.com/en/docs/install](https://yarnpkg.com/en/docs/install).'
  prefs: []
  type: TYPE_NORMAL
- en: 'BrowserSync has been integrated with Mix and can be used by chaining a call
    to the `browserSync` method in your Mix configuration. Pass an options object
    with the app''s URL as a `proxy` property, for example, `browserSync({ proxy:
    http://vuebnb.test })`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the app''s URL stored as an environment variable in the `.env` file,
    so let''s get it from there rather than hard-coding into our Mix file. First,
    install the NPM `dotenv` module, which reads a `.env` file into a Node project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Require the `dotenv` module at the top of the Mix configuration file and use
    the `config` method to load `.env`. Any environment variables will then be available
    as properties of the `process.env` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now pass an options object to the `browserSync` method with `process.env.APP_URL` assigned
    to `proxy`. I also like to use the `open: false` option as well, which prevents
    BrowserSync from automatically opening a tab.'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.mix.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: BrowserSync runs on its own port, `3000` by default. When you run `npm run watch` again,
    open a new tab at `localhost:3000`. After you make changes to your code you'll
    find they are automatically reflected in this BrowserSync tab!
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you run BrowserSync inside your Homestead box you can access it
    at `vuebnb.test:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the BrowserSync server runs on a different port to the web server,
    I will continue to refer to URLs in the app without specifying the port to avoid
    any confusion, for example, `vuebnb.test` rather than `localhost:3000` or `vuebnb.test:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `js` Mix method applies the Babel plugin to Webpack, ensuring that any ES2015
    code is transpiled down to browser-friendly ES5 before it's added to the bundle
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote the Vuebnb frontend app prototype using only ES5 syntax, as we ran
    it directly in the browser without any build step. But now we can take advantage
    of ES2015 syntax, which includes a lot of handy features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use a shorthand for assigning a function to an object property.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Can be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There are several instances of this in `app.js` that we can change. There aren't
    any other opportunities for using ES2015 syntax in our code yet, though in the
    coming chapters we'll see more.
  prefs: []
  type: TYPE_NORMAL
- en: Polyfills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ES2015 proposal includes new syntax, but also new APIs, such as `Promise`, and
    additions to existing APIs, such as `Array` and `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The Webpack Babel plugin can transpile ES2015 syntax, but new API methods require
    polyfilling. A **polyfill** is a script that is run in the browser to cover an
    API or API method that may be missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `Object.assign` is a new API method that is not supported in Internet
    Explorer 11\. If we want to use it in our frontend app, we have to check at the
    top of our script whether the API method exists, and if not, we define it manually
    with a polyfill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Speaking of which, `Object.assign` is a handy way of merging objects and would
    be useful in our frontend app. Let's use it in our code, then add a polyfill to
    ensure the code will run in older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `data` object in our entry file, `resources/assets/js/app.js`. We
    are manually assigning each property of the `sample` object to the `data` object,
    giving it the same property name. To save having to repeat ourselves, we can instead
    use `Object.assign` and simply merge the two objects. In practice, this doesn't
    do anything different, it's just more succinct code.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To polyfill `Object.assign` we must install a new `core-js` dependency, which
    is a library of polyfills for most new JavaScript APIs. We''ll use some other
    `core-js` polyfills later in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of `app.js`, add this line to include the `Object.assign` polyfill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After this builds, refresh your page to see whether it works. Most likely you
    will not notice any difference unless you can test this on an older browser, such
    as Internet Explorer, but now you have the assurance that this code will run almost
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Mock data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now completely migrated the Vuebnb prototype into our Laravel project,
    plus we've added a build step. Everything in the frontend app is working as it
    was in [Chapter 2](b381aa06-e15c-4cb9-9b8b-4b9421ed73db.xhtml), *Prototyping Vuebnb,
    Your First Vue.js Project*.
  prefs: []
  type: TYPE_NORMAL
- en: However, we still have mock data hard-coded into the frontend app. In this last
    part of the chapter, we're going to remove that hard-coded data and replace it
    with data from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, the home route, that is,` */*`, loads our frontend app. But what
    we've built for our frontend app so far is not meant to be a home page! We'll
    be building that in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: What we've built is the *listing* page, which should be at a route like `/listing/5`,
    where `5` is the ID of the mock data listing being used.
  prefs: []
  type: TYPE_NORMAL
- en: '| Page | Route |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Home page | / |'
  prefs: []
  type: TYPE_TB
- en: '| Listing page | /listing/{listing} |'
  prefs: []
  type: TYPE_TB
- en: Let's modify the route to reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Just like in our `api/listing/{listing}` route, the dynamic segment is meant
    to match the ID for one of our mock data listings. If you recall from the previous
    chapter, we created 30 mock data listings with an ID range of 1 to 30.
  prefs: []
  type: TYPE_NORMAL
- en: If we now type hint the `Listing` model in the `closure` function's profile,
    Laravel's service container will pass in a model with an ID that matches that
    dynamic route segment.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: One cool in-built feature is, if the dynamic segment does not match a model,
    for example `/listing/50` or `/listing/somestring`, Laravel will abort the route
    and return a 404.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that we can retrieve the correct listing model in the route handler,
    and that, thanks to the Blade templating system, we can dynamically insert content
    into our *app* view, an obvious architecture emerges: we can inject the model
    into the head of the page. That way, when the Vue app loads, it will have immediate
    access to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ced66f3d-6116-4340-99d0-a9785f410ac5.png)Figure 5.14\. Inline listing
    model into the head of the page'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting the mock-listing data into the client app will take several steps. We'll
    begin by converting the model to an array. The `view` helper can then be used
    to make the model available within the template at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the Blade template, we'll create a script in the head of the document.
    By using double curly brackets, we can interpolate the model directly into the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now go to the `/listing/5` route, we will see the following in our page
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will see the following in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b075b90-99d1-483b-ab29-0062fbf83768.png)Figure 5.15\. Console output
    after injecting model ID'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now encode the entire model as JSON within the view. The JSON format is
    good because it can be stored as a string and can be parsed by both PHP and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In our inline script, let's format the model as a JSON string and assign to
    a `model` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Notice we also had to wrap `json_encode` in another global function, `addslashes`.
    This function will add backslashes before any character that needs to be escaped.
    It's necessary to do this because the JavaScript JSON parser doesn't know which
    quotes in the string are part of the JavaScript syntax, and which are part of
    the JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: We also had to use a different kind of Blade syntax for interpolation. A feature
    of Blade is that statements within double curly brackets `{{ }}` are automatically
    sent through PHP's `htmlspecialchars` function to prevent XSS attacks. This will,
    unfortunately, invalidate our JSON object. The solution is to use the alternative `{!!
    !!}` syntax, which does not validate the contents. This is safe to do in this
    scenario because we're sure we're not using any user-supplied content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we refresh the page, we''ll see the JSON object as a string in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b553cf66-4c47-41bd-aec4-bc08db5e1316.png)Figure 5.16\. Model as
    a JSON string in the console'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the log command to `console.log(JSON.parse(model));`, we see our
    model not as a string, but as a JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3eee0596-4d8d-4a4f-b1f4-38bcd82c946b.png)Figure 5.17\. Model as
    an object in the console'
  prefs: []
  type: TYPE_NORMAL
- en: We've now successfully gotten our model from the backend into the frontend app!
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have another issue to overcome now. The inline script in the head of the
    document, which is where our model object is, is a different script to the one
    where we have our client application, which is where it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve discussed in the previous section, multiple scripts and global variables
    are generally not preferred as they make the app fragile. But in this scenario,
    they''re a necessity. The safest way to share an object or function between two
    scripts is to make it a property of the global `window` object. That way, it''s
    very obvious from your code that you''re intentionally using a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you add additional scripts to your project, particularly third-party ones,
    they might also add to the `window` object, and there's a possibility of a naming
    collision. To avoid this the best we can, we'll make sure we use a very specific
    property name.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, over in the entry file of the frontend app, we can work with this `window` property
    in our script.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Replacing the hard-coded model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have access to our listing model in the entry file, so let's switch it
    with our hard-coded model in the `data` property assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we can now remove the `import sample from ''./data'';`statement
    from the top of `app.js`. We can also delete the sample data files as they won''t
    be used any further in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Amenities and prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you refresh the page now, it will load, but the script will have some errors.
    The problem is that the amenities and prices data are structured differently in
    the frontend app to how they are in the backend. This is because the model initially
    came from our database, which stores scalar values. In JavaScript, we can use
    richer objects which allow us to nest data, making it much easier to work with
    and manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the model object currently looks. Notice that the amenities and
    prices are scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/064fd314-22ec-49e0-b643-11027566d74b.png)Figure 5.18\. How the listing
    model currently looks'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we need it to look, with the amenities and prices as arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc6c4b95-eaec-4ade-a5d3-b139eb7c53a8.png)Figure 5.19\. How the listing
    model should look'
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, we'll need to transform the model before we pass it to
    Vue. To save you having to think too much about this, I've put the transformation
    function into a file, `resources/assets/js/helpers.js`. This file is a JavaScript
    module that we can import into our entry file and use by simply passing the model
    object into the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve added this and refreshed the page, we should see the new model
    data in the text parts of the page (although still with the hard-coded images):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32f99369-737e-4291-9e7e-f446a63555f3.png)Figure 5.20\. New model
    data in page with hard-coded images'
  prefs: []
  type: TYPE_NORMAL
- en: Image URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing to do is replace the hard-coded images' URLs in the frontend
    app. These URLs are not currently a part of the model, so need to be manually
    added to the model before we inject it into the template.
  prefs: []
  type: TYPE_NORMAL
- en: We've already done a very similar job back in [Chapter 4](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml), *Building
    a Web Service With Laravel*, for the API listing route.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In fact, our web route will end up with identical code to this API route, only
    instead of returning JSON, it will return a view.
  prefs: []
  type: TYPE_NORMAL
- en: Let's share the common logic. Begin by moving the route closure function into
    a new `get_listing_web` method in the listing controller.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Then adjust the route to call this new controller method.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Let's now update the controller so *both* the web and API routes get the images'
    URLs added to their model. We'll first create a new `add_image_urls` method, which
    abstracts the logic that was used in `get_listing_api`. Now both of the route-handling
    methods will call this new method.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, if we refresh the app and open Vue Devtools, we should see
    that we have the image URLs as an `images` data property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a17020d-30e8-4f25-ad17-192ecc32b947.png)Figure 5.21\. Images are
    now a data property as shown in Vue Devtools'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the hard-coded image URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final step is to use these image URLs from the backend instead of the hard-coded
    URL. Remembering that `images` is an array of URLs, we'll use the first image
    as a default, that is, `images[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll update the entry file,
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Then the view for the modal image.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, after a rebuild and page refresh, you''ll see the content of
    mock data listing `#5` in the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3cc885a-d893-44b4-94a6-e7af8955cf40.png)Figure 5.22\. Listing page
    with mock data'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify, and to admire our work, let''s try another route, for example, `/listing/10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24a89bd1-3055-499b-8510-b415b00df4cd.png)Figure 5.23\. Listing page
    with mock data'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got familiar with the files and configuration of Laravel's
    default frontend app. We then migrated the Vuebnb client app prototype into our
    Laravel project, achieving the first full-stack iteration of Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about Webpack, seeing how it addresses the JavaScript dependency
    management problem by bundling modules into a browser-friendly build file. We
    set up Webpack in our project via Laravel Mix, which offers a simple API for common
    build scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We then investigated tools for making our frontend development process easier,
    including Webpack watch mode and BrowserSync.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to get data from the backend into the frontend app by injecting
    it into the document head.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing Widgets
    with Vue.js Components*, we will be introduced to one of the most important and
    powerful tools for building user interfaces with Vue.js: components. We will build
    an image carousel for Vuebnb, and use knowledge of components to refactor the
    Vuebnb client app into a flexible component-based architecture.'
  prefs: []
  type: TYPE_NORMAL
