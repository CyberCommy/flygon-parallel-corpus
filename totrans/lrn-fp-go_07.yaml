- en: Functional Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing this chapter, my mind wandered back a few years to when I used
    to program in FoxPro. As I recall, I wrote a lot of functions in FoxPro. The functions
    I wrote were typically singular in purpose and rarely required more than four
    parameters. After Microsoft purchased Fox Software, newer versions of FoxPro began
    to be less functional. The UI builder was becoming more like Visual Basic. Functions
    began to be replaced by classes. Logic that was once readily accessible became
    hidden behind buttons and GUI objects. The lines of code increased, testing took
    more time and development cycles took longer. I felt a lack of productivity and
    could not adequately explain my feelings.
  prefs: []
  type: TYPE_NORMAL
- en: '"He who does not understand the supreme certainty of mathematics is wallowing
    in confusion."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Leonardo Da Vinci'
  prefs: []
  type: TYPE_NORMAL
- en: When I discovered Go, it was like paradise regained; A return to simplicity
    with added benefits of concurrency, networking, great development tools, first
    class functions as well as the best parts of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn a better way to refactor long parameter lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the difference between a dead data object and a functional parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the difference between currying and partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to apply a partial application to create another function with a smaller
    arity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a context to gracefully shut down our server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a context to cancel and rollback a long-running database transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement functional options to improve our APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you think it's okay to simplify a long parameter list by either passing pointers
    to mutable data objects or by calling other functions hidden within your function,
    please read this chapter with an open mind.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring long parameter lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long parameter lists are typically considered code smell.
  prefs: []
  type: TYPE_NORMAL
- en: How long is too long?
  prefs: []
  type: TYPE_NORMAL
- en: When we look at a parameter list and are unable to keep track of it all, then
    it's likely too long.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mind''s limit found - 4 things at once**'
  prefs: []
  type: TYPE_NORMAL
- en: Working memory relates to the information we can pay attention to and grasp.
    Keeping our parameter lists short helps others easily understand our function's
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.livescience.com/2493-mind-limit-4.html](https://www.livescience.com/2493-mind-limit-4.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Four parameters or fewer is the sweet spot, but seven is the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider our telephone numbers. How many digits? Seven. For example: 867-5309'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you think the seven digits are separated into two sets of numbers with
    the largest set having four digits?
  prefs: []
  type: TYPE_NORMAL
- en: What's wrong with a function signature with more than seven parameters?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function signature should not be so long and complicated that we are unable
    to comprehend it. Keep it simple. Use thoughtful, reasonable, and meaningful parameter
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Ever noticed that functions with a long parameter list are typically some type
    of constructor? And that those functions are prone to get even more parameters
    over time?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db4c530-01da-43f2-a7d6-dcf06b6b3101.png)'
  prefs: []
  type: TYPE_IMG
- en: It is natural for software engineers to want to reduce their functions' parameter
    lists. That's part of what we do when we refactor our application. As long as
    we keep the goal of comprehensibility in mind, we'll be fine. Sometimes, we might
    have a function signature that has ten parameters. If other alternatives would
    make our function signature ambiguous, then go for it. Clarity trumps ambiguity.
    How many parameters should we use? It depends.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code is the process of changing the structure of our code without
    changing its behavior. We are not adding features. Instead, we are making our
    code more readable and more easily maintained. Often, we take large functions
    (over 200 lines of code) and break them into smaller, more comprehensible units
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Some ways of accomplishing this feat are better than others.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring - the book
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever read the book *Refactoring*? It covers the topic of refactoring long parameter
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points are made:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods can query other objects' methods internally for data required to make
    decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods should depend on their host class for needed data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should pass one or more objects to simplify our call signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should use a technique called *replace parameter with method* to reduce the
    number of required parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass a whole object with required attributes to reduce the number of required
    parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a parameter object when we have unrelated data elements to pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can send separate parameters when we do not want to create a dependency on
    a larger parameter object; this is an exception and we should probably not do
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long parameter lists will change over time and are inherently difficult to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This advice is consistent with the pure object-oriented language design methodology.
    However, we as good Go programmers should only be in agreement with the last point.
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: How can it be that the advice that many have followed for almost 20 years could
    be so horribly wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Edsger W. Dijkstra says OOP is a bad idea
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Dutch computer scientist, Dijkstra, provides the following insight on OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Object-oriented programming is an exceptionally bad idea which could only
    have originated in California."'
  prefs: []
  type: TYPE_NORMAL
- en: '-  Edsger W. Dijkstra'
  prefs: []
  type: TYPE_NORMAL
- en: What? OOP is an *exceptionally bad idea*? Why?
  prefs: []
  type: TYPE_NORMAL
- en: First, let's understand a little bit more about Edsger W. Dijkstra.
  prefs: []
  type: TYPE_NORMAL
- en: What else did Edsger W. Dijkstra say?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dijkstra said things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The competent programmer is fully aware of the strictly limited size of his
    own skull; therefore he approaches the programming task in full humility, and
    among other things he avoids clever tricks like the plague."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Edsger W. Dijkstra'
  prefs: []
  type: TYPE_NORMAL
- en: 'He also said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Simplicity is prerequisite for reliability."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Edsger W. Dijkstra'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d6b32ec-a539-4e00-9b39-14bcf5e86cea.png)'
  prefs: []
  type: TYPE_IMG
- en: Mozart composition
  prefs: []
  type: TYPE_NORMAL
- en: '"Neither a lofty degree of intelligence nor imagination nor both together go
    to the making of genius. Love, love, love, that is the soul of genius."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Wolfgang Amadeus Mozart'
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra shared his thoughts about the differing programming styles found in
    software development. Dijkstra compared the difference between the way Mozart
    and Beethoven composed music. Dijkstra explained that Mozart began composing with
    the entire composition in mind. Beethoven, on the other hand, would write parts
    of the music before the composition was completed and would literally glue the
    corrections to create the final composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e11402-b3ea-4ef0-8031-458e27b6a63d.png)'
  prefs: []
  type: TYPE_IMG
- en: Beethoven composition
  prefs: []
  type: TYPE_NORMAL
- en: Edsger seems to prefer Mozart's style of programming. His own approach to programming
    illustrates that programs should be designed and correctly composed, not just
    hacked and debugged into correctness.
  prefs: []
  type: TYPE_NORMAL
- en: The reason Mozart was able to perform detailed design before implementation
    was due to the fact that he was a master of the art of music composition and had
    a lot of experience. Sometimes, when developing software, we won't have that luxury.
    When we are unable to identify a framework suited for our project, there will
    be much more trial-and-error programming.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, when I am not under a tight deadline, I prefer the Beethoven style
    of development. I think of it as recreational programming. It's self-exploratory
    in nature. For me, Mozart development requires more discipline. Typically, the
    end result is the same. Mozart development takes less time to complete, but Beethoven
    development is more enjoyable. I suppose that's why the developers enjoy R&D projects
    so much.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying OOP problem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted in [Chapter 4](../Text/Ch04.xhtml), *SOLID Design in Go*, you learned
    how Java (and OOP languages) places emphasis on a type hierarchy. The designers
    of OOP focused on nouns rather than verbs. Everything is an object. An object
    has attributes (data) and can perform actions (methods).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66b75afc-8bb8-415f-aada-746631d67ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: An inactive noun
  prefs: []
  type: TYPE_NORMAL
- en: One of the underlying problems with OOP is that it promotes storing and hiding
    data in the object's properties/attributes. It is assumed that our application
    will eventually want to access this object's data while executing one or more
    of the object's methods.
  prefs: []
  type: TYPE_NORMAL
- en: OOP inconsistency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An OOP application can recall its hidden information and mutate it. An object's
    method can be called multiple times during the lifetime of the application. Each
    call to the same method with the same call signature can produce different results
    every time. This characteristic of its behavior makes OOP unreliable and difficult
    to test effectively.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is inconsistent with basic mathematics. In OOP, due to an object's mutable
    state, we cannot always call a method with the same parameters each time and always
    get the same results. There is no mathematical model for OOP. For example, if
    we call `myMethod(1,2)` and get 3 the first time and get 4 the next time, due
    to the mutable state and internal calls to other objects, then the correctness
    of an OOP program cannot be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and cloud computing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The essence of functional programs is very different from OOP. Functional programs,
    given the same set of input parameters, will always yield the same results. We
    can easily run them in parallel. We can chain/compose them in ways that are faster
    and not possible with OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Our deployment model has changed from in-house servers, where admins would spend
    so much time configuring and optimizing them that they gave the server pet names.
    We used to see names follow a pattern such as Greek gods. There's *Zeus*, our
    database server, and *Apollo* our HR server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our servers are deployed in the cloud, our admins can add new servers
    with the click of a button or set up auto scaling: if the average CPU goes above
    80%, then add a new server. It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a52acd9f-b1c4-448a-b051-3d0aa11f467f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Pods in the preceding diagram represent a server, which might have a few
    related containers. One container in the pod would be running our `f(x)` function.
    If a server crashes, our auto scaling logic that's running in our container orchestrator
    would be notified and it will automatically start another server to replace it.
    Pods can quickly be provisioned and can be taken out of service based on our cloud
    deployment profile settings and our sites' traffic patterns. Since servers come
    and go so easily and quickly these days, we refer to them as cattle rather than
    pets. We are more concerned with the health of our herd of servers than we are
    about any one particular pet server.
  prefs: []
  type: TYPE_NORMAL
- en: The term *Pod* is taken from Kubernetes. Refer to [https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)
    to know more.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are the rough equivalent of OpenShift v2 gears and logically represent
    a *logical host*, where all service containers can communicate with each other
    via localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Other container orchestrators include Docker Swarm, Mesos, Marathon, and Nomad.
    Refer to [https://github.com/KaivoAnastetiks/container-orchestration-comparison](https://github.com/KaivoAnastetiks/container-orchestration-comparison).
  prefs: []
  type: TYPE_NORMAL
- en: Applications with FP characteristics behave reliably in our cloud environments;
    however, applications with OOP characteristics of mutable state do not do so.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at f(x)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's examine a basic function definition, where **f** is the function name
    and **x** is the input value. Another name for **x** is the input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire expression **f(x)** represents the output value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/533ed4de-b9bc-476d-bba2-516b17d7cca3.png)'
  prefs: []
  type: TYPE_IMG
- en: If *f(x) = x + 1*, then we know that every time we input the value 2, the output
    value will always be 3.
  prefs: []
  type: TYPE_NORMAL
- en: This pure and simple characteristic is what makes functional programming so
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we had an object with an `AddOne` method that would
    sometimes return 3 when given the value of 2, then how could we reliably scale
    our `object.AddOne` method? We can''t, and that is the main reason why, in the
    context of cloud computing, the following equation is true: *FP > OOP*.'
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's examine each point made in the Refactoring book in the light of functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Passing every parameter a function requires to do its job is not a good idea
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Why wouldn't we want our function signature to indicate the values (parameters)
    that it needs to make decisions?
  prefs: []
  type: TYPE_NORMAL
- en: How can we reduce the parameters that a function requires?
  prefs: []
  type: TYPE_NORMAL
- en: Methods can query other objects' methods internally for data required to make
    decisions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So, instead of calling the `GetTravelTime(startLocation, endLocation)` method,
    it would be better to call `GetTravelTime()`?
  prefs: []
  type: TYPE_NORMAL
- en: Where would we get the `startLocation` and `endLocation` values from?
  prefs: []
  type: TYPE_NORMAL
- en: How can we be sure that there aren't other values, such as `modeOfTransportation`,
    that would impact our travel time result?
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't that create internal, undocumented dependencies (assuming we document
    our external APIs)?
  prefs: []
  type: TYPE_NORMAL
- en: Methods should depend on their host class for needed data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Does this mean that we are relying on mutable data that could be updated before
    and during our function call?
  prefs: []
  type: TYPE_NORMAL
- en: If we want to prevent updates on data during the time our function is running,
    what extra code must we write to ensure data consistency? What locking mechanisms
    will we need to implement?
  prefs: []
  type: TYPE_NORMAL
- en: Will this prevent us from writing code that runs in parallel?
  prefs: []
  type: TYPE_NORMAL
- en: Is concurrent programming possible?
  prefs: []
  type: TYPE_NORMAL
- en: Pass a whole object with required attributes to reduce the number of required
    parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So, instead of `GetTravelTime(startLocation, endLocation, speed)`, our call
    should look like this: `GetTravelTime(info)`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are times when a function call like this `Initialize(Config)` makes sense,
    and it depends on our use case.
  prefs: []
  type: TYPE_NORMAL
- en: However, maybe we should strive to simplify what our function does so that it
    naturally requires fewer parameters rather than finding ways to jam more parameter
    values into a single input parameter object.
  prefs: []
  type: TYPE_NORMAL
- en: Replace parameter with method technique to reduce the number of required parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This technique instructs us to remove the parameter and let the receiver invoke
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: Before applying Replace Parameter with Method technique
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We start with a `getDiscountedPrice` function that takes two parameter: `lineItemPrice`
    and discount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Replace Parameter with Method* aggressively strives to reduce the number of
    parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case we have two parameters. That is clearly fewer than the four parameters.
    Why reduce this low number of parameters?
  prefs: []
  type: TYPE_NORMAL
- en: After applying Replace Parameter with Method technique
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After refactoring our code per our instructions, we have removed a parameter.
    Now we only have one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How will code maintainers know that the `totalPrice` can be reduced by a discount?
  prefs: []
  type: TYPE_NORMAL
- en: Does hiding the discount parameter improve understandability or does it actually
    increase code complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Use a parameter object when we have unrelated data elements to pass
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A parameter object contains only fields and crude methods for accessing them
    (getters and setters). It is a dead data structure used only to transfer data.
  prefs: []
  type: TYPE_NORMAL
- en: If we are passing a lot of unrelated data items into a function, then what are
    the odds that our function would fail the Single Responsibility Principle?
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to add logic that could modify a data value based on our runtime
    context?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we have a set of parameters that describe a new customer, we could
    consider grouping them into a data objects. Something like the following could
    be considered a reasonable thing to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bb268c-422e-4620-af03-b3a01bf5bad8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We grouped the `FullName` attributes (salutation, `firstName`, `middleName`,
    `lastName`, suffix) together to form a `FullName` data object. We also grouped
    address attributes to create an `Address` data object. Now, we can call `CreateCustomer`
    passing only two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The call with two parameters is an improvement over the following one with
    eight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, as with most things in the world, the right thing to do depends on our situation.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a problem with this approach?
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't this create a dependency upon the `fullName` and address objects?
  prefs: []
  type: TYPE_NORMAL
- en: What if either the `fullName` or address data objects changed after we began
    executing our `CreateCustomer` function but before it was complete? What data
    inconsistencies would we have then?
  prefs: []
  type: TYPE_NORMAL
- en: Long parameter lists will change over time and are inherently difficult to understand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This statement makes a lot of sense. The rest of this chapter will expound on
    this statement. We'll explore how we can manage an API that could change over
    time and that might need more than a few parameters to get the information it
    needs to complete its task(s).
  prefs: []
  type: TYPE_NORMAL
- en: If we compose our application like Beethoven, starting with a general idea of
    what we want to accomplish and beating our program into shape, then we might not
    know exactly what parameters an API will need at first.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98cbeafd-7c81-410c-8526-bda0051b3f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: An action verb
  prefs: []
  type: TYPE_NORMAL
- en: How do we design an API that requires more than a few parameters, yet has the
    following qualities?
  prefs: []
  type: TYPE_NORMAL
- en: Provides sensible defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicates which parameters are required/optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the entire power of language to init complex values rather than relaying
    via dead structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can grow over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is discoverable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is self-documenting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is highly configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about passing a configuration struct?
  prefs: []
  type: TYPE_NORMAL
- en: Like the `fullName` and address data objects we saw earlier, passing a configuration
    data object creates a dependency. The configuration object is retained by both
    the `caller` and the function `called`.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass pointers to our configuration object that would complicate issues
    if any mutations occurred, either by the caller or the callee.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution we''re looking for would allow a new constructor to accept a variable
    number of parameters with the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Predefining default values (where no parameter is passed for that particular
    setting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only passing values that have meaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harnessing the power of the Go programming language to customize the value of
    the parameter passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much of this design comes from one of Rob Pike's blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to self-referential functions and the design of options, by Rob Pike in
    his blog post at [https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html).
  prefs: []
  type: TYPE_NORMAL
- en: Kudos for sharing the closure technique of returning a function literal in which
    we set the value of our server setting. We'll see exactly how this works later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/899209bd-10b1-409e-b6d9-4cef3d91a999.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Three ways to pass multiple parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's keep in mind that there are three ways to pass multiple parameters to
    a function. We will discuss them in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Simply passing multiple parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here, we pass four parameters to the `InitLog` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Passing a configuration object/struct that contains multiple attributes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here, we pass the `ClientConfig` configuration data object and print its values
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A disadvantage of this approach is that we create a dependency between the caller
    and the callee. What if the caller or some other part of the caller's system modifies
    the configuration object while our function is processing?
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, as in the example provided earlier, it is fairly safe to assume that
    the configuration object will not change. In that case, passing a configuration
    object is the right thing to do. It's easy and effective with little chance of
    a mutation causing an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the parameter might need to be modified due to the additional complexity
    that lies inside the called function? Static values from a dead structure can't
    help.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Our third option is called **partial application**. We can accomplish this with
    currying.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind currying is to create new, more specific functions from other
    more general functions by partially applying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have have an `add` function that takes two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create another function that returns the `add` function with one of
    the parameters pre-inserted. We''ll take a simple example of adding one to any
    other number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of calling `add(1,2)` will be the same as calling `addOne(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Currying** is the ability of a function to return a new single argument function
    until the original function receives all of its arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling a curried function with only a few of its arguments is called **partial
    application**.
  prefs: []
  type: TYPE_NORMAL
- en: Function currying is a technique we can use to chop up complex functionality
    into smaller parts that are easier to reason about. Smaller units of logic are
    also easier to test. Our  application becomes a clean composition of the smaller
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: However, the solution that we will be pursuing in this chapter will be of the
    first variety, that is, we will pass all the required parameters. However, we
    will only need to pass the required parameters and we will use sensible default
    values for unprovided parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How can we accomplish this? By using functional parameters!
  prefs: []
  type: TYPE_NORMAL
- en: Functional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the `GetOptions()` utils function as we have in previous chapters
    and we''ll call `GetOptions` and `InitLog` in our init function so that our configuration
    values and logger will be set up prior to running any commands in the `main` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's subscribe to the `SIGINT` signal using signal `Notify`. Now, we can catch
    a *Ctrl* + *C* event before our program abruptly stops. We'll create a quit channel
    to hold our signal. It only needs to have a buffer size of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'When our `quit` channel receives a `SIGINT` signal, we can begin our graceful,
    orderly shutdown procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Pay close attention to the following code. This is where we pass our functional
    parameters!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we chose to provide four parameters (`MaxConcurrentConnections`,
    `MaxNumber`, `FormatNumber`, and `UseNumberHandler`) to our server's `New` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parameter names are self-explanatory. We passed the actual scalar
    values (4, 256, true) for the first three parameters. We could have chosen to
    use config values (`Config.MaxConcurrentConnections`, `Config.MaxNumber`, and
    `Config.UseNumberHandler`) or use environment variables. We could also use environment
    variables. We'd likely not use an environment variable for `UseNumberHandler`.
    Mostly, environment variables are used for settings that are likely to vary from
    development, test, QA and production environments, for example, `IPADDRESS` and
    `PORT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a handy library for dealing with environment variables in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/caarlos0/env](https://github.com/caarlos0/env)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last parameter `FormatNumber` accepts an anonymous function to change the
    display format of the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `%x` argument in the `fmt.Sprintf` statement instructs our handler to display
    the entered number in binary format.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user enters the number **2** in their request, this is what''s displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa6d94bd-da2b-47aa-b2a3-8a3c215ecc79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the call to `Server.New` fails, then log the error and exit the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we provide the parameters required for a running HTTP server. The `Addr`
    parameter is the address the server listens on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than letting the `http.Server` default to using `http.DefaultServeMux`
    to handle requests, we we pass our `newServer` function type variable to accept
    our custom `ServerOption` functional parameters to customize its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create a Goroutine for an anonymous function call.
  prefs: []
  type: TYPE_NORMAL
- en: Our Goroutine will wait until the user triggers a `SIGINT` interrupt (by pressing
    *Ctrl* + *C* in the terminal session where the server was started). At that time,
    the quit channel will receive the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Though `Context` can be used to pass request-scoped variables, we're only going
    to use it to pass a cancellation signal. We'll go into more detail about `Context`
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quit` channel is closed when the 2 second deadline expires or when the
    returned `cancel` function is called. As long as the server shutdown logic takes
    less than two seconds, the defer `cancel()` will be called; otherwise, the deadline
    will close the `quit` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The call to `Shutdown` will stop the server without interrupting any active
    connections. First, `Shutdown` closes open listeners, then it closes idle connections.
    Without a deadline, it could wait indefinitely for connections to return to idle
    before shutting them down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListenAndServe` function listens on the localhost port `Config.Port` and
    calls serve to handle requests on incoming connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our server will be listening for requests and our terminal will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ad4327e-c548-4b7b-9ea9-4ca0a041af18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can get that config information printed to our terminal by inserting
    the following as our first line in our `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The "`+`" in `%+v` tells the `Printf` function to print the field names as well
    as the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we press *Ctrl* + *C*, the code in the following line signals our Goroutine
    on the `quit` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/aea8c228-dec8-4f6e-ab7c-2ed1ab712c20.png)'
  prefs: []
  type: TYPE_IMG
- en: The `srv.Shutdown` method runs and then the last line in `main` executes to
    print `server shutdown gracefully`.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into more of our `func-param` project code, let's look more closely
    at to Go's `Context` package functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contexts are primarily used for requests spanning multiple processes and API
    boundaries. Contexts help maintain background information on the state of the
    object during different phases of a process life cycle as it traverses various
    API boundary processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example (from [https://blog.golang.org/context](https://blog.golang.org/context))
    of passing a `Context` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Passing the `Context` parameter to every function in every request provides
    control over timeouts and cancellation for requests that span APIs and process
    boundaries. Furthermore, it helps to ensure that critical values such as security
    credentials do not stay in transit longer than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries and frameworks, for example, Gorilla's ([http://github.com/gorilla/context](http://github.com/gorilla/context))
    package, provide a bridge between their packages and others that take a Context
    request-scoped parameter. This improves interoperability between heterogeneous
    packages when building scalable services.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an application context to provide control over stopping our server.
    The deadline ensures that our shutdown process does not exceed a reasonable amount
    of time (2 seconds in our example). Also, by sending the cancel signal, we provide
    our server with the opportunity to run its cleanup processes prior to shutting
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an illustration of what''s going on with our `Context` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7aab879a-c096-4374-bf09-00882e2709b0.png)'
  prefs: []
  type: TYPE_IMG
- en: When the admin user presses *Ctrl* + *C*, the `os.interrupt` signals the `quit`
    (buffered) channel. A `Context` (`ctx`) is created with a deadline of 2 seconds.
    That Context parameter is sent to the `srv.Shutdown` function, where the server's
    cleanup code is executed. If it takes longer than 2 seconds, then our Goroutine
    will be canceled. The result is that our server is gracefully shut down and we
    can be assured that it won't take longer than 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could build elaborate `Context` trees like the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56df5017-1483-4b5f-8870-c52db31d2b8a.png)'
  prefs: []
  type: TYPE_IMG
- en: However, before doing so, we should be aware of our `Context` limitations, which
    we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Context limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trees can be traversed upward, that is, from children nodes to parent nodes
    (not the other way).
  prefs: []
  type: TYPE_NORMAL
- en: We should only use values that advise, for example, this user's localname is
    `en_US`. The `en_US` can be used to enhance the user experience, but not to change
    the flow of the application. We should not store values that can affect the flow
    of control in the `Context` package.
  prefs: []
  type: TYPE_NORMAL
- en: Report example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example of the effects caused by storing the flow of control values in
    the `Context`, let''s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we passed only the context as a parameter. Inside
    our `Report` function, we extract the flow of control modifying values, `reportName`
    and filter. Now, we have the format in which the `Report` function needs to do
    its job.
  prefs: []
  type: TYPE_NORMAL
- en: Why do some people think that it's a good idea to query other objects' methods
    internally for data required to make decisions or to make a habit of passing a
    big amorphous object, filled with data that we must then extract inside our function
    in order to know what to do next?
  prefs: []
  type: TYPE_NORMAL
- en: It is typically best practice to pass all of the parameters that a function
    requires. This coding style creates self-documenting APIs. If we find that our
    parameter list is growing large, that is, over six parameters, then we should
    consider whether our function should be refactored. Is there any reusable code
    in our large function? Maybe we can create a helper function and reduce our parameter
    footprint?
  prefs: []
  type: TYPE_NORMAL
- en: Let's not forget what we discussed in the [Chapter 4](../Text/Ch04.xhtml), *SOLID
    Design in Go*. The *(S)ingle Responsibility principle* states that a class should
    have only a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: If we are passing a ton of parameters, could it be possible that our function
    is performing more than one task?
  prefs: []
  type: TYPE_NORMAL
- en: Writing good code is not unlike a good game of soccer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Play it simple. Make your passes crisp and short. Be intentional. Maintain control
    of the ball. Always keep your eye on the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Watch a recreational player and then watch an **elite player** (**EP**) play
    the game. What is the the main difference? How well does EP receive the ball?
    How well does EP pass the ball? Does EP play the ball into space in the path of
    their teammate or does EP kick long balls in the general direction of the opponent's
    goal?
  prefs: []
  type: TYPE_NORMAL
- en: Move (to open space), receive (the ball), then pass (the ball). Teams that do
    that well consistently win. What are we talking about here? Interfaces. Teams
    that pass the ball effectively from player to player win more games.
  prefs: []
  type: TYPE_NORMAL
- en: We can learn from this. If we strive to write self-documenting APIs (move to
    open space) then our API becomes more accessible to our clients. When the APIs
    that we call are similarly designed (as simple as possible, requiring only mandatory
    parameters, with sensible defaults) our system will be highly interoperable and
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dad32d2b-040a-4512-805b-64f2f26016e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Real Madrid, an amazing team, plays combinations and passing. Our APIs should
    interoperate like the Real Madrid team in the video at [https://www.youtube.com/watch?v=b6_IUVBAJJ0](https://www.youtube.com/watch?v=b6_IUVBAJJ0).
  prefs: []
  type: TYPE_NORMAL
- en: Was that a typical use case? Assuming the soccer ball is our data/message, when
    would we want to pass a message along, avoiding opponents, to move API endpoints
    and deposit it in the goal unchanged?
  prefs: []
  type: TYPE_NORMAL
- en: Functional parameters - Rowe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Watch the throw-in to Rowe. What Kelyn Rowe does with the ball is like what
    a functional parameter can do in its callee. Compare that magic with the passing
    we see in recreational soccer or with passing a dead value in a `Context`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4944efe-2911-4a8a-9961-48c4a403f2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Dom Dwyer scored Team USA 1-0 over Panama; refer to this video at [https://www.youtube.com/watch?v=CVXPeGhPXkE](https://www.youtube.com/watch?v=CVXPeGhPXkE).
  prefs: []
  type: TYPE_NORMAL
- en: Report example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The values in the `Context` are affecting the control flow of the application.
    Let''s refactor it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, using `Context` to pass values only obfuscates our intention and
    makes our code less readable. We'd be hard pressed to find a good use case for
    `Context` values in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: A more practical Context use case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more practical `Context` use case would be to send a `Cancel` message to a
    long-running function.
  prefs: []
  type: TYPE_NORMAL
- en: Several use cases come to mind when dealing with database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases a request could generate a number of child requests, each running
    for varying amounts of time and consuming various resources. If during our database
    transaction, one of our child requests panics, we could use the `Context` to signal
    all routines to cancel and to free up all transaction-related resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide access to the `sql.DB` commit and rollback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TxFunc` param is a functional parameter provided to the `db.WithTransaction`
    function. It will execute the given function within the context of the database
    transaction. If an error occurs, the transaction will be rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Db uses the `sql.DB` implementation to access the `Begin` and `Commit` transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WithTransaction` function is a function that provides a `Transaction`
    interface that can be used to perform SQL operations in a transaction. If the
    function returns an error, then the transaction will be rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Rollback if an error occurred during the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Execute the function that performs the SQL operations in the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: See the `fn(tx)` function?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where our functional parameter is executed. That''s where the real
    work is performed. It''s where the logic that performs SQL queries runs. It executes
    in the context of the transaction. So, if any of the queries or subqueries fail,
    the entire transaction will be rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the transaction and set `isCommitted` to true to indicate success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We're done with our look at Context. Now, back to the functional parameters
    solution...
  prefs: []
  type: TYPE_NORMAL
- en: src/server/server.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can skim the imports to get an idea of what we''ll be doing in this file.
    We''ll process some HTTP requests, marshal some JSON-converting strings to integers,
    handle errors, and implement a logger for our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define three constants and use them when defining our default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Server` struct has three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `Logger` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the handler to provide the `ServeHTTP`, which is a `Handler` that responds
    to HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: New is our server constructor. New is a variadic function that receives an arbitrary
    number of functional parameters of type `ServerOption`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `opt` param is a variadic parameter of type `ServerOption`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We return a pointer to our newly created `Server` object and the idiomatic
    `error` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we prepopulate our options with default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we iterate through each `ServerOption`. The following is the signature
    for a `ServerOption`. We see that we use it to define the function type variables
    that accept a pointer to the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If an error is found, we wrap our error to be returned and exit this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create our `Server` variable and populate it with the functional parameters
    (`opts`) as well as a `logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Before returning a call, our server's `register` method with our HTTP multiplexer
    (mux). A mux matches the URL incoming requests against registered patterns and
    calls the handler for the pattern that most closely matches the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the the `register` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `useNumberHandler` option to determine which handler to
    associate with our root path "`/`".
  prefs: []
  type: TYPE_NORMAL
- en: This is a contrived mux example used to illustrate a use for server options.
    In production, you're likely better off using packages such as [https://github.com/gorilla/mux](https://github.com/gorilla/mux)
    and [https://github.com/justinas/alice](https://github.com/justinas/alice) on
    top of [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/).
  prefs: []
  type: TYPE_NORMAL
- en: If `s.opts.useNumberHandler` is `true`, then the mux will call the `http.HandlerFunc`
    function and pass the `displayNumber` function as its only functional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `displayNumber` function in an HTTP  that uses a few server options to
    determine how to handle the `request:handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following block of code we compare the number entered by the user to
    the `maxNumber` server option value. If the entered value is greater than the
    max value, we display an error message; otherwise, we continue processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If there is no convert function (`convertFn`), then we set the number to be
    displayed (`displayNumber`) to the value entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if `convertFn` is defined, we pass the number to it, execute it, and
    assign the return value to `displayNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See how we use a function literal in `main()` with the `fmt.Sprintf` command
    to affect the displayed number?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To see our number in a hexadecimal format, we''ll open a web browser and enter
    this in the address bar:` http://localhost:8080/?number=255`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48c67ccc-29e5-4d74-ab0e-4a2ae7f3cca9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Want to see the `displayNumber` in different format? If so: stop the app by
    entering *Ctrl* + *C* in the terminal console. In `main.go`, change` fmt.Sprintf("%x",
    x)` to`  fmt.Sprintf("%b", x)` and restart the app by entering the `go-run` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When we go back to our web browser and refresh we see our number 255 in a binary
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5447be32-88c9-4b52-a5aa-d0c94d05ad63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to comment out the `server.FormatNumber` parameter, we''d get the
    number entered by the user without formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/820bcbad-1664-4d32-b794-b1099e3b13a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Refer to the following resource for more `Sprintf` options [http://lexsheehan.blogspot.com/search?q=octal+hex+printf](http://lexsheehan.blogspot.com/2015/02/fmtprintf-format-reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is an error, we display it. If there are no errors, we display our
    (possibly formatted) number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our last project file that we'll examine contains our `ServerOption` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The src/server/server_options.go file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''ll use the Go standard library errors package because we simply want to
    create an error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a `ServerOption` type to simplify our function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Currying allows functions to yield new functions as their return value. Is that
    what `MaxNumber` is doing? `MaxNumber` is a function and returns a `ServerOption`.
    A `SeverOption` is a function. So, yes. We have some currying going on here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first `ServerOption` function is `MaxNumber`. It has a simple responsibility:
    assigning the value of its argument (`n`) to our option''s `maxNumber` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that `MaxNumber` is a function that returns a function that returns an
    error. Since there is no possibility of an error occurring in this function, we
    simply return nil.
  prefs: []
  type: TYPE_NORMAL
- en: Other `ServerOption` functions can be more complicated and we might run into
    an error condition in one of those non-trivial functions and have the need to
    return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MaxConcurrenConnections` function has a conditional statement, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The next two functions provide the ability to format our input number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `convert` type is a function type that accepts an int and returns a string
    and possibly an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FormatNumber` function is another `ServerOption`. Unlike the other ones,
    which accept scalar input values, `FormatNumber` accepts a function parameter
    of type `convert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take another look at `main()`, where `FormatNumber` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FormatNumber` function''s argument is passed in as a functional parameter.
    It is an anonymous function that satisfies the signature of a convert function
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The function accepts an `int` and returns a string and and error.
  prefs: []
  type: TYPE_NORMAL
- en: '`FormatNumber` has one statement--the return statement. It returns a `ServerOption`
    function after it executes the convert function (fn).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t be confused by the fact that we know that the convert function receives
    an int but we do not see it in the anonymous return function: `o.convertFn = fn`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line of code, `o.convertFn = fn`, is executed by `main()`; when it runs
    it creates the `newServer` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'What it''s doing is assigning the `fn` function to the `convertFn` function''s
    `SeverOption` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not until the user submits a request and that request is handled by the
    `displayNumber` function that the following line is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: That's where the `int` number is actually passed to the `convertFn` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last `ServerOption` function is `UserNumberHandler`. It is simple, quite
    like `MaxNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go is designed using good ideas from both FP and OOP world. For example, go
    borrowed interfaces, duck typing, and composition over inheritance from OOP world
    and functions as first class citizens from the FP world.
  prefs: []
  type: TYPE_NORMAL
- en: Go is a perfect example of being pragmatic. Go took the better principles from
    both OOP and FP paradigms, while clearly ignoring many ideas from each. Perhaps,
    this perfectly balanced design is what makes Go so special? In that way, Go is
    the perfect ratio of software languages.
  prefs: []
  type: TYPE_NORMAL
- en: See [Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*, for a
    discussion about the golden ration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll delve more deeply into pure functional programming.
    We'll see how to leverage category theory and class types to abstract away details
    in order to glean new insights. We'll look at functors along with slightly stronger
    and more useful versions of functors called applicative functors. You'll also
    learn how to bring the world of side-effects under control using Monads and Monoids.
  prefs: []
  type: TYPE_NORMAL
