- en: 'Hello World! and Beyond: Your First Application'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Ah, the venerable "Hello World!" script. While very simple, it's a good first
    test of any language. Let's do a little more than just saying hello, though; let's
    work with several small applications that we'll use to get our hands dirty. After
    all, there's more to programming than just theory. We'll take a look at a common
    problem presented in coding challenges, as well as understand *how *our programs
    are working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: I/O with the console and alert messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with input in a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using objects as a datastore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding scope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clone or download the repository for this book from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers)
    and prepare to look through the `Chapter-5` material.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: I/O with the console and alert messages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how JavaScript can output information to the user. Consider
    the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we execute `Riker.sayHello()`, we will see the following in the console:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31e31351-b7e6-4a17-86a6-6c02c9132141.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Console output
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look for yourself in the `chapter-5` directory in the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, great. We have some console output, but that''s not a very efficient way
    to get output, as users don''t typically have the console open. There is a convenient
    method for output that, while not practical for a fully fledged web application,
    is useful for testing and debugging purposes: `alert()`. Here''s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try running the preceding code from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html)
    . What do you see?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1c244f86-7b66-4680-9d48-0782961ced06.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Alert message
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! We have one of those little annoying popups that you may have seen
    around the web. While they can be annoying when used improperly, they can be very
    handy when used appropriately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at something similar that will give us *input* from the
    user ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you load the page, you will see a pop-up box with the input field. Enter
    `name`, `rank`, or `posting` to see the result. If you refresh and enter something
    other than those options, you should get a response of Value not found.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah! But let''s also take a look at the following line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since this is frontend JavaScript, we don't know exactly what the user will
    enter, so we should plan for slight misformats. Data sanitization is a whole other
    topic, so for now, let's just agree that we can lowercase the whole string to
    match the expected values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. Now, let's take a look at how `answer` is used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Working with input in a function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we take a look at the preceding object, we''ll see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since we're dealing with arbitrary input, the first thing we're doing is checking
    against our array of answers to see whether the property requested exists. If
    it does not, a simple error message is alerted. If it *is* found, then we can
    alert the value. If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, object properties can be accessed via **dot notation**
    and **bracket notation**. In this case, we're working with a variable as the key,
    so we *can't* do this because it would be interpreted as the key. Thus, we use
    bracket notation to access the proper object value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Fibonacci sequence
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this exercise, construct a function to take a number. The end result should
    be the sum of numbers in the Fibonacci sequence ([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number))
    up to the specified number you entered. The first few numbers of the sequence
    are `[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`. Each number is the sum of the previous
    two numbers; for example, `f[6] = 13` because `f[5] = 8` and `f[4] = 5`, and thus
    `f[6] = 8+5 = 13`. You can use the starter code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code).
    Don't worry too much about the most efficient algorithms for calculating the number;
    just be sure not to hardcode values and instead rely on the input variables and
    the formula.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci sequence solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s dissect one possible solution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's take a look at the lines outside of the function first. All we're doing
    is simply asking the user for the point in the sequence up to which they'd like
    to calculate. The `response` variable is then fed into the `alert()` statement
    as a parameter to `fibonacci`, which takes the argument of `num`. From that point
    forward, the `while()` loop executes on `num`, decrementing `num` as the value
    of `b` is incremented according to the algorithm, and then finally returns into
    our alert message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: So that's really all there is to it! Now, let's try a variant because we never
    know what our user will input. What happens if they enter a string instead of
    a number? We should accommodate this and at the very least present an error message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this solution:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can find the solution on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: If we dive into the `while()` loop, we'll see our type-matching magic. First
    of all, since `response` inherently comes in a string, we decide we don't want
    to trust type coercion, which is what our previous solution is doing. We use the
    `parseInt()` method to cast `response` directly into a number. Great! But that
    doesn't give us the security that our user entered an integer to begin with. Remember,
    JavaScript doesn't have a conception of `int` versus `float`, so we have to make
    some manipulations to ensure our input is an integer by using the negation of
    the `Number.isInteger` method. This ensures that our input is a valid integer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: As a prelude to heavier work with JSON, let's take a look at how we can use
    objects as a datastore.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Using objects as a datastore
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an interesting problem that I've seen in programming interviews, as well
    as the most efficient way to solve it. It has an expensive input time, but an
    O(1) *retrieval* time, which is generally considered a metric of success for algorithmic
    complexities when you can expect more reads than writes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – multiplication
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, what's the solution within the paradigm of using an object? Let's take a
    look, break it down, and then reverse-engineer our use of objects as a data store
    (*spoiler alert:* have you heard of NoSQL?).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication solution
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, let''s break down the problem into two steps: given two arrays,
    we will first compute the products of each item in the arrays and store them in
    an object. Then, we will write a function to retrieve the product of two given
    numbers from the arrays. Let''s take a look.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – computing and storing
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, our `makeProducts` function will take the two arrays as its parameters.
    Using the `.forEach()` method of arrays, we''ll iterate over each item in the
    first array, naming the values `multiplicant`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, our end goal is to have an object that will tell us "the product of *x*
    and *y* is *z*." If we abstract this into using an object as a data store, we
    could arrive at a structure like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this object structure, all we need to do to retrieve our calculation is
    specify `x.y`, which will be `z`. We also don''t want to assume an order, so we
    do the reverse as well: `y.z`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we construct this data object? Remember that we can use **bracket
    notation** with objects if we''re not calling the literal key; here, we''re using
    a variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our first step is to check whether the `multiplicant` key exists in our object
    (`x`, in our previous theoretical discussion). If it doesn't, set it to a new
    object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our inner loop, let''s do the same for the multiplier:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Great! We have our keys set up for both `x` and `y`. Now, we just compute the
    product and store it in both locations, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Notice the decision to assign the reverse key value to the obverse key''s
    value, as opposed to recalculating the product*. Why would we do that? In fact,
    why are we going to all this trouble for a simple mathematical operation? Here''s
    the reason: what if, instead of simple multiplication, we''re doing a calculation
    *far* more complex? Maybe a calculation so complex it takes a full second or more
    to return? Now we can see that we want to reduce our time so that we only do the
    calculation once and then can read it repeatedly for optimal performance.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'After constructing this function, we would execute it on our arrays:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is easy enough to invoke!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – retrieval
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s write our retrieval function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we look at this logic, first we ensure the first key exists. If it exists,
    we return either `x.y` or `null` if `y` does not exist. Objects are picky in that
    if you try to refer to a *value* of a *key* that doesn''t exist, you''ll get an
    error. Thus, we first need to existence-check our key. If the key exists *and*
    the key/value pair exists, return the computed value; otherwise, we return `null`.
    Notice the `return products[a][b] || null` short-circuit: this is an efficient
    way of saying "return the value or something else." If `products[a][b]` does not
    exist, it will respond with a falsy value, and the `OR` operation will take over.
    Efficient!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the solution code for the answer to the bonus question. The same
    principles of existence-checking and calculation apply.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scope
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss scope for a while before we build a larger application. Simply
    put, scope defines when and where we can use a variable or a function. Scope in
    JavaScript is broken down into two discrete categories: local and global. If we
    look at our previous multiplication program, we can see that there are three variables
    outside any functions; they''re hanging out at the root level of our program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The variables in question are on lines 1, 2, and 6: `a`, `b`, and `products`,
    respectively. Great! That means that we can use them anywhere, such as on lines
    10, 11, 14, 15, and more, as long as we use them after they''re defined. Now,
    if we look closer, we also see we have some functions in the global scope: `makeProducts`
    and `getProducts`. Likewise, we can use them anywhere as long as they''ve already
    been defined.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: OK, great—that makes sense since JavaScript is read top to bottom. But wait!
    If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar,* a function declaration is hoisted to the top and thus can be used anywhere.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refactor our program to utilize hoisting and abstract our math to be
    the theoretical long-running process. We''ll also be using `Promises` as a great
    introduction to the concept. Before we go too far into it, it may be useful to
    read up on using `Promises`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at `index.js` in [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored).
    We'll be breaking this down step by step.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `index.html` in a browser. Make sure your console is open. After
    2 seconds, you will see a simple message in the console: 9 x 2 = 18. If you look
    at line 44 in `index.js`, you''ll see that it''s using `getProducts` to calculate
    the product of `a[4]` and `b[0]`, which are `9` and `2`, respectively. Great!
    So far, our functionality is the same with the addition of a perceived delay.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start at the beginning:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: OK, so far we have the same code. Now, what about our `makeProducts` function?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Hmm. OK, we have a few of the same pieces, but a few new pieces. First of all,
    let''s consider **`async`**. This keyword, when used with a function, implies
    that the consumer of this function is to expect *asynchronous behavior* as opposed
    to JavaScript''s generally top-down behavior. Before we dive into breaking down
    the new lines, 19–21, let''s look at *why* this function is asynchronous by checking
    out our `calculation` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s `async` again on line 37, and now we see a new keyword on line 38:
    `await`. `async` and `await` are one way to specify that we can work asynchronously:
    on line 38, we specify that we''re waiting for this `promise` to **resolve** before
    continuing. What is our `promise` doing? Well, as it turns out, not a whole lot!
    It''s simply using `setTimeout` to delay by 2,000 milliseconds. This delay is
    intended to simulate a long-running process, such as an Ajax call or a complex
    process that takes 2 seconds to complete (or even an indeterminate amount of time).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, great. So far, we''ve basically tricked the program into expecting a 2-second
    delay before continuing. Let''s look at line 9: a new array called `promises`.
    Now, to get back to our idea of *scope*, you can notice that our array is defined
    *within* `makeProducts`. That means the variable only exists within the local
    scope of the function. As opposed to products, we can''t access promises from
    outside this function. That''s OK—we don''t really need to. As a matter of fact,
    it''s considered best practice to keep the number of variables defined in the
    global scope to a minimum.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at line 19, which looks a little more nuanced:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we dissect this, we first see something familiar: we''re pushing something
    onto our `promises` array. What we''re pushing is a new `Promise`, similar to
    line 38, but in this case, we''re not waiting for it in-line, but rather just
    saying "resolve this `promise` with the value of `calculation()` — whenever it
    happens." So far, so good. How about the next part?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, here''s where some syntactic sugar comes into play: now that we have our
    `promise` in our array of `promises`, we access it with `[promises.length - 1]`
    because `length` returns the full length, starting from `1`. The `.then()` clause
    is our magic: it says that once the `promise` is done, do something with the result.
    In this case, our *something* is to assign `val` to both variants of the product.
    Finally, on line 25, we return the array of `promises`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getProducts` function hasn''t changed at all! The complexity of our retrieval
    function remains the same: efficient.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: How about this?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've seen `.then` before, so it's getting as its parameter the return value
    of `makeProducts`, which is the array of `promises`. Then, we can use `.all()`
    before `.then` to effectively say "when all the `promises` in `arrOfPromises`
    have resolved, then do the next function." That next function is to log our answer.
    You can add additional product checks after line 44; they will all return at the
    same time as line 44, as the delay in our "calculation" has already occurred.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Scope chains and scope trees
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Diving further into scope, we have the idea of **scope chains** and **scope
    trees**. Let''s consider the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What variable(s) does `someFunc` have access to? What does `zip` have access
    to? If you guessed that `someFunc` has access to `outerVar` but `zip` has access
    to both `innerVar` and `outerVar`, you're correct. That's because both variables
    exist in the scope chain of `zip`, but only `outerVar` exists in the scope of
    `someFunc`. Clear as mud? Great. Let's look at some diagrams.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can diagram a **scope tree** of our function from a top-down construction:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ddbada90-b172-4f3f-9773-c44ecc76904b.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Scope tree
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this tell us? `quux` kind of lives off in its own little world inside
    `someFunc`. It would have access to `someFunc`''s variables, but *not* to `zip`
    or `foo`. We can also look at it in the reverse with a **scope chain** to understand
    it from the bottom up:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3346d996-15a3-4f99-81c7-b4813235bfe6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Scope chain
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we're taking a look at what `foo` has access to. From the bottom
    up, we can see its relationship to the other parts of the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''ll get into **closures**, which is apparently a scary topic in JavaScript.
    However, the basic concept is approachable: a closure is simply a function inside
    another function with access to the scope chain of its parent function. In this case,
    it has three scope chains: its own, with variables defined within itself; global,
    with all the variables in the global scope accessible to it; and the parent function''s
    scope.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that we''ll dissect:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Which variables are accessible to which functions? Here''s a diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c9bc35d-24cb-4992-8095-a1804e39a5de.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Closures
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the bottom up, `foo` has access to `beep` and `bar`, whereas `zip`
    has access only to `bar`. So far, so good, right? Closures are just a way to describe
    the scope that each nested function has available to it. There's nothing inherently
    scary about them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: A basic example of a closure in practice
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, let''s look at this interesting construction: `sayHello(''Alice'')()`.
    Since our `sayAlert()` function is the return value of `sayHello`, we first invoke
    `sayHello` with one pair of parentheses with our argument and then invoke its
    return value (the `sayAlert` function) with the second pair of parentheses. Notice
    how `greeting` is within the scope of `sayHello`, and when we invoke our function,
    we''ll have an alert of Hello Alice. However, if we try to alert `greeting` by
    itself, we''ll get an error. Only `sayAlert` has access to `greeting`. Likewise,
    if we tried to access `name` from outside the function, we''d get an error.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for our programs to be useful, they usually depend on input from the
    user or other functions. By scaffolding our programs to be flexible, we also need
    to keep in mind the idea of scope: when and where we can use a function or variable.
    We also took a look at how objects can be used to store data efficiently for retrieval.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的程序有用，它们通常依赖于用户或其他函数的输入。通过搭建我们的程序以使其灵活，我们还需要牢记作用域的概念：何时何地可以使用函数或变量。我们还看了一下对象如何用于有效存储数据以便检索。
- en: Let's not forget closures, the seemingly complicated concept that is, in practice,
    just a way of describing scope.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记闭包，这个看似复杂的概念实际上只是一种描述作用域的方式。
- en: In the next chapter, we'll explore the frontend more as we get into using the
    **Document Object Model** (**DOM**) and manipulating information on the page instead
    of only interacting with alerts and the console.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，随着我们开始使用**文档对象模型**（**DOM**）并操纵页面上的信息，而不仅仅是与警报和控制台交互，我们将更多地探索前端。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Consider the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How would you get an alert of Hello Bob?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获得警报 Hello Bob？
- en: '`sayHello()(''Bob'')`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello()(''Bob'')`'
- en: '`sayHello(''Bob'')()`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello(''Bob'')()`'
- en: '`sayHello(''Bob'')`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello(''Bob'')`'
- en: '`someFunc()(sayHello(''Bob''))`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()(sayHello(''Bob''))`'
- en: What will `alert(greeting)` do in the preceding code?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，`alert(greeting)`会做什么？
- en: Alert greeting.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报问候语。
- en: Alert Hello Alice.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报 你好 Alice。
- en: Throw an error.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出错误。
- en: None of the above.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: How would we get an alert message of 1?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何获得警报消息1？
- en: '`someFunc()()`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()()`'
- en: '`sayHello().sayZip()`'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello().sayZip()`'
- en: '`alert(someFunc.bar)`'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alert(someFunc.bar)`'
- en: '`sayZip()`'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayZip()`'
- en: How would we get an alert message of 2?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何获得警报消息2？
- en: '`someFunc().foo()`.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc().foo()`.'
- en: '`someFunc()().beep`.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()().beep`。'
- en: We can't because it's not in the scope.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能，因为它不在作用域内。
- en: We can't because it's not defined.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能，因为它没有定义。
- en: How can we change `someFunc` to alert 1 1 2 ?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将`someFunc`更改为警报1 1 2？
- en: We can't.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能。
- en: Add `return foo` after `return zip`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return zip`后添加`return foo`。
- en: Change `return zip` to `return foo`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`return zip`更改为`return foo`。
- en: Add `return foo` after the `foo` declaration.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo`声明后添加`return foo`。
- en: Given a correct solution to the preceding question, how would we actually get
    three alerts of 1, 1, 2 ?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定前面问题的正确解决方案，我们如何实际获得三个警报1、1、2？
- en: '`someFunc()()()`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()()()`'
- en: '`someFunc()().foo()`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()().foo()`'
- en: '`someFunc.foo()`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc.foo()`'
- en: '`alert(someFunc)`'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alert(someFunc)`'
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: MDN – closures: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN - 闭包：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- en: '*Understand JavaScript Closures with Ease*: [http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*轻松理解JavaScript闭包*：[http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/)'
