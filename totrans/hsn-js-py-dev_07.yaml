- en: 'Hello World! and Beyond: Your First Application'
  prefs: []
  type: TYPE_NORMAL
- en: Ah, the venerable "Hello World!" script. While very simple, it's a good first
    test of any language. Let's do a little more than just saying hello, though; let's
    work with several small applications that we'll use to get our hands dirty. After
    all, there's more to programming than just theory. We'll take a look at a common
    problem presented in coding challenges, as well as understand *how *our programs
    are working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: I/O with the console and alert messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with input in a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using objects as a datastore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clone or download the repository for this book from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers)
    and prepare to look through the `Chapter-5` material.
  prefs: []
  type: TYPE_NORMAL
- en: I/O with the console and alert messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how JavaScript can output information to the user. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we execute `Riker.sayHello()`, we will see the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31e31351-b7e6-4a17-86a6-6c02c9132141.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look for yourself in the `chapter-5` directory in the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, great. We have some console output, but that''s not a very efficient way
    to get output, as users don''t typically have the console open. There is a convenient
    method for output that, while not practical for a fully fledged web application,
    is useful for testing and debugging purposes: `alert()`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Try running the preceding code from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html)
    . What do you see?
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1c244f86-7b66-4680-9d48-0782961ced06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Alert message
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! We have one of those little annoying popups that you may have seen
    around the web. While they can be annoying when used improperly, they can be very
    handy when used appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at something similar that will give us *input* from the
    user ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you load the page, you will see a pop-up box with the input field. Enter
    `name`, `rank`, or `posting` to see the result. If you refresh and enter something
    other than those options, you should get a response of Value not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah! But let''s also take a look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since this is frontend JavaScript, we don't know exactly what the user will
    enter, so we should plan for slight misformats. Data sanitization is a whole other
    topic, so for now, let's just agree that we can lowercase the whole string to
    match the expected values.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. Now, let's take a look at how `answer` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Working with input in a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we take a look at the preceding object, we''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since we're dealing with arbitrary input, the first thing we're doing is checking
    against our array of answers to see whether the property requested exists. If
    it does not, a simple error message is alerted. If it *is* found, then we can
    alert the value. If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, object properties can be accessed via **dot notation**
    and **bracket notation**. In this case, we're working with a variable as the key,
    so we *can't* do this because it would be interpreted as the key. Thus, we use
    bracket notation to access the proper object value.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Fibonacci sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this exercise, construct a function to take a number. The end result should
    be the sum of numbers in the Fibonacci sequence ([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number))
    up to the specified number you entered. The first few numbers of the sequence
    are `[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`. Each number is the sum of the previous
    two numbers; for example, `f[6] = 13` because `f[5] = 8` and `f[4] = 5`, and thus
    `f[6] = 8+5 = 13`. You can use the starter code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code).
    Don't worry too much about the most efficient algorithms for calculating the number;
    just be sure not to hardcode values and instead rely on the input variables and
    the formula.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci sequence solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s dissect one possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the lines outside of the function first. All we're doing
    is simply asking the user for the point in the sequence up to which they'd like
    to calculate. The `response` variable is then fed into the `alert()` statement
    as a parameter to `fibonacci`, which takes the argument of `num`. From that point
    forward, the `while()` loop executes on `num`, decrementing `num` as the value
    of `b` is incremented according to the algorithm, and then finally returns into
    our alert message.
  prefs: []
  type: TYPE_NORMAL
- en: So that's really all there is to it! Now, let's try a variant because we never
    know what our user will input. What happens if they enter a string instead of
    a number? We should accommodate this and at the very least present an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can find the solution on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check).
  prefs: []
  type: TYPE_NORMAL
- en: If we dive into the `while()` loop, we'll see our type-matching magic. First
    of all, since `response` inherently comes in a string, we decide we don't want
    to trust type coercion, which is what our previous solution is doing. We use the
    `parseInt()` method to cast `response` directly into a number. Great! But that
    doesn't give us the security that our user entered an integer to begin with. Remember,
    JavaScript doesn't have a conception of `int` versus `float`, so we have to make
    some manipulations to ensure our input is an integer by using the negation of
    the `Number.isInteger` method. This ensures that our input is a valid integer.
  prefs: []
  type: TYPE_NORMAL
- en: As a prelude to heavier work with JSON, let's take a look at how we can use
    objects as a datastore.
  prefs: []
  type: TYPE_NORMAL
- en: Using objects as a datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an interesting problem that I've seen in programming interviews, as well
    as the most efficient way to solve it. It has an expensive input time, but an
    O(1) *retrieval* time, which is generally considered a metric of success for algorithmic
    complexities when you can expect more reads than writes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, what's the solution within the paradigm of using an object? Let's take a
    look, break it down, and then reverse-engineer our use of objects as a data store
    (*spoiler alert:* have you heard of NoSQL?).
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, let''s break down the problem into two steps: given two arrays,
    we will first compute the products of each item in the arrays and store them in
    an object. Then, we will write a function to retrieve the product of two given
    numbers from the arrays. Let''s take a look.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – computing and storing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, our `makeProducts` function will take the two arrays as its parameters.
    Using the `.forEach()` method of arrays, we''ll iterate over each item in the
    first array, naming the values `multiplicant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our end goal is to have an object that will tell us "the product of *x*
    and *y* is *z*." If we abstract this into using an object as a data store, we
    could arrive at a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this object structure, all we need to do to retrieve our calculation is
    specify `x.y`, which will be `z`. We also don''t want to assume an order, so we
    do the reverse as well: `y.z`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we construct this data object? Remember that we can use **bracket
    notation** with objects if we''re not calling the literal key; here, we''re using
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our first step is to check whether the `multiplicant` key exists in our object
    (`x`, in our previous theoretical discussion). If it doesn't, set it to a new
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our inner loop, let''s do the same for the multiplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We have our keys set up for both `x` and `y`. Now, we just compute the
    product and store it in both locations, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Notice the decision to assign the reverse key value to the obverse key''s
    value, as opposed to recalculating the product*. Why would we do that? In fact,
    why are we going to all this trouble for a simple mathematical operation? Here''s
    the reason: what if, instead of simple multiplication, we''re doing a calculation
    *far* more complex? Maybe a calculation so complex it takes a full second or more
    to return? Now we can see that we want to reduce our time so that we only do the
    calculation once and then can read it repeatedly for optimal performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After constructing this function, we would execute it on our arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is easy enough to invoke!
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – retrieval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s write our retrieval function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at this logic, first we ensure the first key exists. If it exists,
    we return either `x.y` or `null` if `y` does not exist. Objects are picky in that
    if you try to refer to a *value* of a *key* that doesn''t exist, you''ll get an
    error. Thus, we first need to existence-check our key. If the key exists *and*
    the key/value pair exists, return the computed value; otherwise, we return `null`.
    Notice the `return products[a][b] || null` short-circuit: this is an efficient
    way of saying "return the value or something else." If `products[a][b]` does not
    exist, it will respond with a falsy value, and the `OR` operation will take over.
    Efficient!'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the solution code for the answer to the bonus question. The same
    principles of existence-checking and calculation apply.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss scope for a while before we build a larger application. Simply
    put, scope defines when and where we can use a variable or a function. Scope in
    JavaScript is broken down into two discrete categories: local and global. If we
    look at our previous multiplication program, we can see that there are three variables
    outside any functions; they''re hanging out at the root level of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables in question are on lines 1, 2, and 6: `a`, `b`, and `products`,
    respectively. Great! That means that we can use them anywhere, such as on lines
    10, 11, 14, 15, and more, as long as we use them after they''re defined. Now,
    if we look closer, we also see we have some functions in the global scope: `makeProducts`
    and `getProducts`. Likewise, we can use them anywhere as long as they''ve already
    been defined.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, great—that makes sense since JavaScript is read top to bottom. But wait!
    If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar,* a function declaration is hoisted to the top and thus can be used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refactor our program to utilize hoisting and abstract our math to be
    the theoretical long-running process. We''ll also be using `Promises` as a great
    introduction to the concept. Before we go too far into it, it may be useful to
    read up on using `Promises`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises).'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at `index.js` in [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored).
    We'll be breaking this down step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `index.html` in a browser. Make sure your console is open. After
    2 seconds, you will see a simple message in the console: 9 x 2 = 18. If you look
    at line 44 in `index.js`, you''ll see that it''s using `getProducts` to calculate
    the product of `a[4]` and `b[0]`, which are `9` and `2`, respectively. Great!
    So far, our functionality is the same with the addition of a perceived delay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: OK, so far we have the same code. Now, what about our `makeProducts` function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm. OK, we have a few of the same pieces, but a few new pieces. First of all,
    let''s consider **`async`**. This keyword, when used with a function, implies
    that the consumer of this function is to expect *asynchronous behavior* as opposed
    to JavaScript''s generally top-down behavior. Before we dive into breaking down
    the new lines, 19–21, let''s look at *why* this function is asynchronous by checking
    out our `calculation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s `async` again on line 37, and now we see a new keyword on line 38:
    `await`. `async` and `await` are one way to specify that we can work asynchronously:
    on line 38, we specify that we''re waiting for this `promise` to **resolve** before
    continuing. What is our `promise` doing? Well, as it turns out, not a whole lot!
    It''s simply using `setTimeout` to delay by 2,000 milliseconds. This delay is
    intended to simulate a long-running process, such as an Ajax call or a complex
    process that takes 2 seconds to complete (or even an indeterminate amount of time).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, great. So far, we''ve basically tricked the program into expecting a 2-second
    delay before continuing. Let''s look at line 9: a new array called `promises`.
    Now, to get back to our idea of *scope*, you can notice that our array is defined
    *within* `makeProducts`. That means the variable only exists within the local
    scope of the function. As opposed to products, we can''t access promises from
    outside this function. That''s OK—we don''t really need to. As a matter of fact,
    it''s considered best practice to keep the number of variables defined in the
    global scope to a minimum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at line 19, which looks a little more nuanced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we dissect this, we first see something familiar: we''re pushing something
    onto our `promises` array. What we''re pushing is a new `Promise`, similar to
    line 38, but in this case, we''re not waiting for it in-line, but rather just
    saying "resolve this `promise` with the value of `calculation()` — whenever it
    happens." So far, so good. How about the next part?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here''s where some syntactic sugar comes into play: now that we have our
    `promise` in our array of `promises`, we access it with `[promises.length - 1]`
    because `length` returns the full length, starting from `1`. The `.then()` clause
    is our magic: it says that once the `promise` is done, do something with the result.
    In this case, our *something* is to assign `val` to both variants of the product.
    Finally, on line 25, we return the array of `promises`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getProducts` function hasn''t changed at all! The complexity of our retrieval
    function remains the same: efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: How about this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've seen `.then` before, so it's getting as its parameter the return value
    of `makeProducts`, which is the array of `promises`. Then, we can use `.all()`
    before `.then` to effectively say "when all the `promises` in `arrOfPromises`
    have resolved, then do the next function." That next function is to log our answer.
    You can add additional product checks after line 44; they will all return at the
    same time as line 44, as the delay in our "calculation" has already occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Scope chains and scope trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Diving further into scope, we have the idea of **scope chains** and **scope
    trees**. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What variable(s) does `someFunc` have access to? What does `zip` have access
    to? If you guessed that `someFunc` has access to `outerVar` but `zip` has access
    to both `innerVar` and `outerVar`, you're correct. That's because both variables
    exist in the scope chain of `zip`, but only `outerVar` exists in the scope of
    `someFunc`. Clear as mud? Great. Let's look at some diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can diagram a **scope tree** of our function from a top-down construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ddbada90-b172-4f3f-9773-c44ecc76904b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Scope tree
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this tell us? `quux` kind of lives off in its own little world inside
    `someFunc`. It would have access to `someFunc`''s variables, but *not* to `zip`
    or `foo`. We can also look at it in the reverse with a **scope chain** to understand
    it from the bottom up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3346d996-15a3-4f99-81c7-b4813235bfe6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Scope chain
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we're taking a look at what `foo` has access to. From the bottom
    up, we can see its relationship to the other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we''ll get into **closures**, which is apparently a scary topic in JavaScript.
    However, the basic concept is approachable: a closure is simply a function inside
    another function with access to the scope chain of its parent function. In this case,
    it has three scope chains: its own, with variables defined within itself; global,
    with all the variables in the global scope accessible to it; and the parent function''s
    scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that we''ll dissect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Which variables are accessible to which functions? Here''s a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c9bc35d-24cb-4992-8095-a1804e39a5de.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Closures
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the bottom up, `foo` has access to `beep` and `bar`, whereas `zip`
    has access only to `bar`. So far, so good, right? Closures are just a way to describe
    the scope that each nested function has available to it. There's nothing inherently
    scary about them.
  prefs: []
  type: TYPE_NORMAL
- en: A basic example of a closure in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s look at this interesting construction: `sayHello(''Alice'')()`.
    Since our `sayAlert()` function is the return value of `sayHello`, we first invoke
    `sayHello` with one pair of parentheses with our argument and then invoke its
    return value (the `sayAlert` function) with the second pair of parentheses. Notice
    how `greeting` is within the scope of `sayHello`, and when we invoke our function,
    we''ll have an alert of Hello Alice. However, if we try to alert `greeting` by
    itself, we''ll get an error. Only `sayAlert` has access to `greeting`. Likewise,
    if we tried to access `name` from outside the function, we''d get an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for our programs to be useful, they usually depend on input from the
    user or other functions. By scaffolding our programs to be flexible, we also need
    to keep in mind the idea of scope: when and where we can use a function or variable.
    We also took a look at how objects can be used to store data efficiently for retrieval.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's not forget closures, the seemingly complicated concept that is, in practice,
    just a way of describing scope.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore the frontend more as we get into using the
    **Document Object Model** (**DOM**) and manipulating information on the page instead
    of only interacting with alerts and the console.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How would you get an alert of Hello Bob?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sayHello()(''Bob'')`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sayHello(''Bob'')()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sayHello(''Bob'')`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc()(sayHello(''Bob''))`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will `alert(greeting)` do in the preceding code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alert greeting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alert Hello Alice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we get an alert message of 1?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc()()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sayHello().sayZip()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`alert(someFunc.bar)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sayZip()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we get an alert message of 2?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc().foo()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc()().beep`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't because it's not in the scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't because it's not defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we change `someFunc` to alert 1 1 2 ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `return foo` after `return zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `return zip` to `return foo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `return foo` after the `foo` declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a correct solution to the preceding question, how would we actually get
    three alerts of 1, 1, 2 ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc()()()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc()().foo()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`someFunc.foo()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`alert(someFunc)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MDN – closures: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understand JavaScript Closures with Ease*: [http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
