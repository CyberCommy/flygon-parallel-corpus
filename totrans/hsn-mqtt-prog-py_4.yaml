- en: Writing Code to Control a Vehicle with Python and MQTT Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will write Python 3.x code to control a vehicle with MQTT
    messages delivered through encrypted connections (TLS 1.2). We will write code
    that will be able to run on different popular IoT platforms, such as a Raspberry
    Pi 3 board. We will understand how we can leverage our knowledge of the MQTT protocol
    to build a solution based on requirements. We will learn to work with the latest
    version of the Eclipse Paho MQTT Python client library. We will gain take an in-depth
    look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements to control a vehicle with MQTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the topics and commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the benefits of working with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a virtual environment with Python 3.x and PEP 405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the directory structure for a virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating the virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deactivating the virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing paho-mqtt for Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a client to the secured MQTT server with paho-mqtt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to topics with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring certificates for IoT boards that will work as clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class to represent a vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving messages in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple calls to the loop method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the requirements to control a vehicle with MQTT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we learned how MQTT works in detail. We understood
    how to establish a connection between an MQTT client and an MQTT server. We learned
    what happened when we subscribed to topic filters and when a publisher sent messages
    to specific topics. We installed a Mosquitto server and then we secured it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use Python as our main programming language to generate MQTT clients
    that will act as publishers and subscribers. We will connect a Python MQTT client
    to the MQTT server and we will process commands to control a small vehicle with
    MQTT messages. The small vehicle replicates many capabilities found in real-life
    road vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use TLS encryption and TLS authentication because we don''t want any
    MQTT client to be able to send commands to our vehicle. We want our Python 3.x
    code to run on many platforms because we will use the same code base to control
    vehicles that use the following IoT boards:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 3 Model B+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualcomm DragonBoard 410c
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BeagleBone Black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MinnowBoard Turbot Quad-Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LattePanda 2G
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UP Core 4GB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UP Squared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the platform, each vehicle is going to provide additional features
    because some boards are more powerful compared to other boards. However, we will
    focus on the basic features to keep our example simple and stay concentrated on
    MQTT. Then, we will be able to use this project as a baseline for other solutions
    that require us to run code on an IoT board that runs Python 3.x code, has to
    connect to an MQTT server, and processes commands.
  prefs: []
  type: TYPE_NORMAL
- en: The code that runs on the boards that power the vehicles must be able to process
    commands received in messages on a specific topic. We will use JSON strings in
    the payloads.
  prefs: []
  type: TYPE_NORMAL
- en: A client application also written in Python must be able to control one or more
    vehicles. We will also write the client application in Python and it will publish
    MQTT messages with JSON strings to the topic for each vehicle. The client application
    must display the results of executing each command. Each vehicle must publish
    a message to a specific topic whenever a command is successfully executed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the topics and commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following topic name to publish the commands for a vehicle:
    `vehicles/vehiclename/commands`, where `vehiclename` must be replaced with a unique
    name assigned to a vehicle. For example, if we assign `vehiclepi01` as the name
    for a vehicle that is powered by a Raspberry Pi 3 Model B+ board, we will have
    to publish commands to the `vehicles/vehiclepi01/commands` topic. The Python code
    that runs on this board will subscribe to this topic to receive messages with
    commands and react to them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following topic name to make the vehicles publish details about
    the successfully executed commands: `vehicles/vehiclename/executedcommands`, where
    `vehiclename` must be replaced with a unique name assigned to a vehicle. For example,
    if we assign `vehiclebeagle03` as the name for a vehicle that is powered by a
    BeagleBone Black board, the client that wants to receive information about successfully
    processed commands has to subscribe to the `vehicles/vehiclebeagle03/executedcommands`
    topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands will be sent in a JSON string with a key-value pair. The key must
    be equal to CMD and the value must specify any of the following valid commands.
    When the command requires additional parameters, the parameter name must be included
    in the next key and the value for this parameter in the value for this key:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TURN_ON_ENGINE`: Turn on the vehicle''s engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TURN_OFF_ENGINE`: Turn off the vehicle''s engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCK_DOORS`: Close and lock the vehicle''s doors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNLOCK_DOORS`: Unlock and open the vehicle''s doors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PARK`: Park the vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PARK_IN_SAFE_PLACE`: Park the vehicle in a safe place that is configured for
    the vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TURN_ON_HEADLIGHTS`: Turn on the vehicle''s headlights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TURN_OFF_HEADLIGHTS`: Turn off the vehicle''s headlights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TURN_ON_PARKING_LIGHTS`: Turn on the vehicle''s parking lights, also known
    as sidelights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TURN_OFF_PARKING_LIGHTS`: Turn off the vehicle''s parking lights, also known
    as sidelights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCELERATE`: Accelerate the vehicle, that is, press the gas pedal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BRAKE`: Brake the vehicle, that is, press the brake pedal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROTATE_RIGHT`: Make the vehicle rotate to the right. We must specify how many
    degrees we want the vehicle to rotate right in the value for the DEGREES key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROTATE_LEFT`: Make the vehicle rotate to the left. We must specify how many
    degrees we want the vehicle to rotate left in the value for the DEGREES key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_MAX_SPEED`: Set the maximum speed that we allow to the vehicle. We must
    specify the desired maximum speed in miles per hour in the value for the MPH key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_MIN_SPEED`: Set the minimum speed that we allow to the vehicle. We must
    specify the desired minimum speed in miles per hour in the value for the MPH key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following line shows an example of the payload for the command that turns
    on the vehicle''s engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows an example of the payload for the command that sets
    the maximum speed for the vehicle to five miles per hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have all the necessary details to start coding with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment with Python 3.6.x and PEP 405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next sections and chapters, we will be writing different pieces of Python
    code that will subscribe to topics and will also publish messages to topics. As
    happens whenever we want to isolate an environment that requires additional packages,
    it is convenient to work with Python virtual environments. Python 3.3 introduced
    lightweight virtual environments, and they were improved in Python 3.4\. We will
    work with these virtual environments, and therefore, you will need Python 3.4
    or greater. You can read more about PEP 405 Python Virtual Environment, which
    introduced the `venv` module, here: [https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405).'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples for this book were tested on Python 3.6.2 on macOS and Linux.
    The examples were also tested on the IoT boards mentioned throughout the book
    and their most popular operating systems. For example, all the examples were tested
    on Raspbian. Raspbian is based on Debian Linux, and therefore, all the instructions
    for Linux will work for Raspbian.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to use the popular `virtualenv` ([https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv))
    third-party virtual environment builder or the virtual environment options provided
    by your Python IDE, you just have to make sure that you activate your virtual
    environment with the appropriate mechanism whenever it is necessary to do so,
    instead of following the step explained to activate the virtual environment generated
    with the `venv` module integrated in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Each virtual environment we create with `venv` is an isolated environment and
    it will have its own independent set of installed Python packages in its site
    directories (folders). When we create a virtual environment with `venv` in Python
    3.4 and greater, `pip` is included in the new virtual environment. In Python 3.3,
    it was necessary to manually install `pip` after creating the virtual environment.
    Note that the instructions provided are compatible with Python 3.4 or greater,
    including Python 3.6.x. The following commands assume that you have Python 3.5.x
    or greater installed on Linux, macOS, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to select the target folder or directory for our lightweight
    virtual environment. The following is the path we will use in the example for
    Linux and macOS. The target folder for the virtual environment will be the `HillarMQTT/01`
    folder within our home directory. For example, if our home directory in macOS
    or Linux is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/HillarMQTT/01`.
    You can replace the specified path with your desired path in each command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the path we will use in the example for Windows. The target
    folder for the virtual environment will be the `HillarMQTT\01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\gaston`,
    the virtual environment will be created within `C:\Users\gaston\HillarMQTT\01`.
    You can replace the specified path with your desired path in each command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows PowerShell, the previous path would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to use the `-m` option followed by the `venv` module name and the
    desired path to make Python run this module as a script and create a virtual environment
    in the specified path. The instructions are different depending on the platform
    in which we are creating the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal in Linux or macOS and execute the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, in Command Prompt, execute the following command to create a virtual
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to work with Windows PowerShell, execute the following command
    to create a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: None of the previous commands produce any output. The script created the specified
    target folder and installed `pip` by invoking `ensurepip` because we didn't specify
    the `--without-pip` option.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the directory structure for a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specified target folder has a new directory tree that contains Python-executable
    files and other files that indicate it is a PEP405 virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory for the virtual environment, the `pyenv.cfg` configuration
    file specifies different options for the virtual environment and its existence
    is an indicator that we are in the root folder for a virtual environment. In Linux
    and macOS, the folder will have the following main subfolders: `bin`, `include`,
    `lib`, `lib/python3.6`, and `lib/python3.6/site-packages`. Note that the folder
    names can be different based on the specific Python version. In Windows, the folder
    will have the following main subfolders: `Include`, `Lib`, `Lib\site-packages`,
    and `Scripts`. The directory trees for the virtual environment in each platform
    are the same as the layout of the Python installation in these platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the folders and files in the directory trees
    generated for the `01` virtual environment in macOS and Linux platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89de4379-d681-4d7d-bfe2-e816e637fa68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the main folders in the directory trees generated
    for the virtual environment in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5e90a3e-c514-4f2a-be55-350e276a53e6.png)'
  prefs: []
  type: TYPE_IMG
- en: After we activate the virtual environment, we will install third-party packages
    into the virtual environment and the modules will be located within the `lib/python3.6/site-packages`
    or `Lib\site-packages` folder, based on the platform and the specific Python version.
    The executables will be copied to the `bin` or `Scripts` folder, based on the
    platform. The packages we install won't make changes to other virtual environments
    or our base Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a virtual environment, we will run a platform-specific
    script to activate it. After we activate the virtual environment, we will install
    packages that will only be available in this virtual environment. This way, we
    will work with an isolated environment in which all the packages we install won't
    affect our main Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in Terminal in Linux or macOS. Note that the results
    of this command will be accurate if you don''t start a different shell than the
    default shell in the Terminal session. If you have doubts, check your Terminal
    configuration and preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The command will display the name of the shell you are using in Terminal. In
    macOS, the default is `/bin/bash` and this means you are working with the bash
    shell. Depending on the shell, you must run a different command to activate the
    virtual environment in Linux or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal is configured to use the bash shell in Linux or macOS, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use the `fish` shell, run the following command
    to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parentheses as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see **(01)** as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the virtual environment activated in a macOS
    High Sierra Terminal with a `bash` shell, after executing the previously shown
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42c36ca7-12a9-421e-a366-c41041a57ec5.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the previous screenshot, the prompt changed from `Gastons-MacBook-Pro:~
    gaston$` to `(01) Gastons-MacBook-Pro:~ gaston$` after the activation of the virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, you can run either a batch file in Command Prompt or a Windows PowerShell
    script to activate the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer Command Prompt, run the following command in the Windows command
    line to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the virtual environment activated in a Windows
    10 Command Prompt, after executing the previously shown commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d93be1d1-aa98-40a6-94f6-e84f628a5ea3.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the previous screenshot, the prompt changed from `C:\Users\gaston`
    to `(01) C:\Users\gaston` after the activation of the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. Note that you must have scripts execution
    enabled in Windows PowerShell to be able to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you receive an error similar to the following, it means that you don''t
    have scripts execution enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows PowerShell default execution policy is `Restricted`. This policy
    allows the execution of individual commands but it doesn''t run scripts. Thus,
    if you want to work with Windows PowerShell, you will have to change the policy
    to allow the execution of scripts. It is very important to make sure that you
    understand the risks of the Windows PowerShell execution policies that allow you
    to run unsigned scripts. For more information about the different policies, check
    the following web page: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the virtual environment activated in a Windows
    10 PowerShell, after executing the previously shown commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14730ab3-23c5-456b-a559-bacda570a93a.png)'
  prefs: []
  type: TYPE_IMG
- en: Deactivating the virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is extremely easy to deactivate a virtual environment generated with the
    previously explained process. The deactivation will remove all the changes made
    in the environment variables and will change the prompt back to its default message.
    Once you deactivate a virtual environment, you will go back to the default Python
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In macOS or Linux, just type `deactivate` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: In Command Prompt, you have to run the `deactivate.bat` batch file included
    in the `Scripts` folder. In our example, the full path for this file is `%USERPROFILE%\HillarMQTT\01\Scripts\deactivate.bat`.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows PowerShell, you have to run the `Deactivate.ps1` script in the `Scripts`
    folder. In our example, the full path for this file is `$env:userprofile\HillarMQTT\01\Scripts\Deactivate.ps1`.
    Remember that you must have scripts execution enabled in Windows PowerShell to
    be able to run the script.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions in the next sections assume that the virtual environment we
    have created is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Installing paho-mqtt for Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Eclipse Paho project provides an open source client implementation of MQTT.
    The project includes a Python client, also known as the Paho Python Client or
    Eclipse Paho MQTT Python client library. This Python client has been contributed
    from the Mosquitto project and was originally known as the Mosquitto Python client.
    The following is the web page for the Eclipse Paho project: [http://www.eclipse.org/paho](http://www.eclipse.org/paho).
    The following is the web page for the Eclipse Paho MQTT Python client library
    version 1.3.1, that is, the `paho-mqtt` module version 1.3.1: [https://pypi.python.org/pypi/paho-mqtt/1.3.1](https://pypi.python.org/pypi/paho-mqtt/1.3.1).'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `paho-mqtt` in many modern IoT boards that support Python 3.x or
    greater. We just need to make sure that `pip` is installed to make it easier to
    install `paho-mqtt`. You can use your development computer to run the examples
    or any of the afore mentioned boards.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the virtual environment we created in the previous steps is activated
    before moving forward with the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to work with an IoT board to run the example, make sure that
    you run all the commands in the SSH terminal or the Terminal window that runs
    on the board. If you use your development computer, run the commands in a Terminal
    in macOS or Linux, or Command Prompt in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use `pip` installer to install `paho-mqtt` 1.3.1\. We just need
    to run the following command in the SSH terminal or the local terminal window
    we are using with the board, or on the computer we are using to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Some IoT boards have operating systems that will require you to install `pip`
    before running the previous commands. On Raspberry Pi 3 boards with Raspbian,
    `pip` is already installed. If you are using your computer, the Python installation
    usually includes `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Python installed in the default folder in Windows and you aren''t
    working with a Python virtual environment, you will have to run the previous command
    in an administrator Command Prompt. If you aren''t working with a Python virtual
    environment in Raspbian, you will have to run the previous command with `sudo`
    as a prefix: `sudo pip install paho-mqtt`. However, as previously explained, it
    is highly recommended to use a virtual environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last lines for the output will indicate that the `paho-mqtt` package version
    1.3.1 has been successfully installed. The output will be similar to the following
    lines, but not exactly the same because it will vary based on the platform in
    which you are running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Connecting a client to the secured MQTT server with paho-mqtt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will use `paho-mqtt` to create an MQTT client that connects to the
    Mosquitto MQTT server. We will write a few lines of Python code to establish a
    secured connection and subscribe to a topic.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](89bdce8f-72bc-4fda-82a0-5cab33fa4bd8.xhtml), *Securing an MQTT
    3.1.1 Mosquitto Server*, we secured our Mosquitto server, and therefore, we will
    use the digital certificates we created to authenticate the client. Most of the
    time, we will work with an MQTT server that uses TLS, and therefore, it is a good
    idea to learn how to establish a connection with TLS and TLS authentication. It
    is easier to establish an unsecured connection with an MQTT server, but it won't
    be the most common scenario we will face when developing applications that work
    with MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to copy the following files, which we created in [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*, to a directory on the computer or device we will
    use to run a Python script. We saved the files in a directory called `mqtt_certificates`.
    Create a `board_certificates` directory on the computer or board you are going
    to use as the MQTT client for this example. Copy the following three files to
    this new directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ca.crt`: Certificate authority certificate file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board001.crt`: Client certificate file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board001.key`: Client key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a new Python file named `config.py` in the main virtual
    environment folder. The following lines show the code for this file that defines
    many configuration values that will be used to establish a connection with the
    Mosquitto MQTT server. This way, all the configuration values are included in
    a specific Python script. You have to replace the `/Users/gaston/board_certificates` value
    in the `certificates_path` string with the path to the `board_certificates` directory
    you created. In addition, replace the value for the `mqtt_server_host` with the
    IP address or hostname for the Mosquitto server or any other MQTT server you might
    decide to use. The code file for the sample is included in the `mqtt_python_gaston_hillar_04_01`
    folder, in the `config.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the `certificates_path` variable initialized with a string
    that specifies the path in which you saved the certificate authority file, the
    client certificate file, and the client key (`ca.crt`, `board001.crt`, and `board001.key`).
    Then, the code declares the following string variables with the full path to the
    certificate and key files we need to configure TLS and the TLS client authentication:
    `ca_certificate`, `client_certificate`, and `client_key`.'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `os.path.join` makes it easy to join the path specified in the `certificates_path`
    variable with the filename and generate the full path. The `os.path.join` function
    works for any platform, and therefore, we don't have to worry about whether to
    use a slash (`/`) or a backslash (`\`) to join the path with the filename. Sometimes,
    we can develop and test in Windows and then run the code on an IoT board that
    can use different Unix or Linux flavors, such as Raspbian or Ubuntu. The usage
    of `os.path.join` makes our job easier in scenarios where we switch between different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The `mqtt_server_host`, `mqtt_server_port`, and `mqtt_keepalive` variables specify
    the IP address for the MQTT server (the Mosquitto server), the port that we want
    to use (`8883`), and the number of seconds for the keep alive option. It is very
    important to replace `192.168.1.101` with the IP address for the MQTT server.
    We specify `8883` for `mqtt_server_port` because we use TLS and this is the default
    port for MQTT over TLS, as we learned in [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new Python file named `subscribe_with_paho.py` in the
    main virtual environment folder. The following lines show the code for this file
    that establishes a connection with our Mosquitto MQTT server, subscribes to the
    `vehicles/vehiclepi01/tests` topic filter, and prints all the messages received
    in the subscribed topic filter. The code file for the sample is included in the
    `mqtt_python_gaston_hillar_04_01` folder, in the `subscribe_with_paho.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the code is compatible with `paho-mqtt` version 1.3.1\. Previous versions
    of `paho-mqtt` aren't compatible with the code. Hence, make sure you follow the
    previously explained steps to install `paho-mqtt` version 1.3.1.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous code uses the recently installed `paho-mqtt` version 1.3.1 module
    to establish an encrypted connection with the MQTT server, subscribe to the `vehicles/vehiclepi01/tests`
    topic filter, and run code when we receive messages in the topic. We will use
    this code to understand the basics of `paho-mqtt`. The code is a very simple version
    of an MQTT client that subscribes to a topic filter and we will definitely improve
    it in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports the variables we have declared in the previously coded
    `config.py` file. The second line imports `paho.mqtt.client` as `mqtt`. This way,
    whenever we use the `mqtt` alias, we will be referencing `paho.mqtt.client`.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a function, we pass this function as an argument to another
    function or method, or we assign this function to an attribute and then some code
    calls this function at some time; this mechanism is known as a **callback.** The
    name callback is used because the code calls back a function at some time. The
    `paho-mqtt` version 1.3.1 package requires us to work with many callbacks, and
    therefore, it is very important to understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following three functions that we specify as callbacks
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on_connect`: This function will be called when the MQTT client receives a
    `CONNACK` response from the MQTT server, that is, when a connection has been successfully
    established with the MQTT server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_subscribe`: This function will be called when the MQTT client receives
    a `SUBACK` response from the MQTT server, that is, when a subscription has been
    successfully completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_message`: This function will be called when the MQTT client receives a
    `PUBLISH` message from the MQTT server. Whenever the MQTT server publishes a message
    based on the subscriptions for the client, this function will be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next table summarizes the functions that will be called based on the received
    responses from the MQTT server:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Response from the MQTT server** | **Function that will be called** |'
  prefs: []
  type: TYPE_TB
- en: '| `CONNACK` | `on_connnect` |'
  prefs: []
  type: TYPE_TB
- en: '| `SUBACK` | `on_subscribe` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUBLISH` | `on_message` |'
  prefs: []
  type: TYPE_TB
- en: 'The code for the main block creates an instance of the `mqtt.Client` class
    (`paho.mqtt.client.Client`) that represents an MQTT client. We use this instance
    to communicate with our MQTT server: Mosquitto. If we used the default parameters
    to create the new instance, we would work with MQTT version 3.1\. We want to work
    with MQTT version 3.11, and therefore, we specified `mqtt.MQTTv311` as the value
    for the protocol argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Assigned function** |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_connect` | `on_connect` |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_message` | `on_message` |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_subscribe` | `on_subscribe` |'
  prefs: []
  type: TYPE_TB
- en: The call to the `client.tls_set` method configures encryption and authentication
    options. It is very important to call this method before running the `client.connect`
    method. We specify the full string paths to the certificate authority certificate
    file, the client certificate, and the client key in the `ca_certs`, `certfile`,
    and `keyfile` arguments. The `ca_certs` argument name is a bit confusing, but
    we just need to specify the string path to the certificate authority certificate
    file, not multiple certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main block calls the `client.connect` method and specifies the
    values for the `host`, `port`, and `keepalive` arguments. This way, the code asks
    the MQTT client to establish a connection to the specified MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: The `connect` method runs with an asynchronous execution, and therefore, it
    is a non-blocking call.
  prefs: []
  type: TYPE_NORMAL
- en: After a connection has been successfully established with the MQTT server, the
    specified callback in the `client.on_connect` attribute will be executed, that
    is, the `on_connect` function. This function receives the `mqtt.Client` instance
    that established the connection with the MQTT server in the client argument.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to establish a connection with an MQTT server that isn't using TLS,
    you don't need to call the `client.tls_set` method. In addition, you need to use
    the appropriate port instead of the `8883` port that is specified when working
    with TLS. Remember that the default port when you don't work with TLS is `1883`.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to topics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code calls the `client.subscribe` method with `"vehicles/vehiclepi01/tests"`
    as an argument to subscribe to this specific single topic and the `qos` argument
    set to `2` to request a QoS level of 2.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will only subscribe to one topic. However, it is very important
    to know that we are not limited to subscribing to a single topic filter; we might
    subscribe to many topic filters with a single call to the `subscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: After the MQTT server confirms the successful subscription to the specified
    topic filter with a `SUBACK` response, the specified callback in the `client.on_subscribe`
    attribute will be executed, that is, the `on_subscribe` function. This function
    receives a list of integers in the `granted_qos` argument that provides the QoS
    level that the MQTT server has granted for each of the topic filter subscription
    requests. The code in the `on_subscribe` function displays the QoS level granted
    by the MQTT server for the topic filter we specified. In this case, we just subscribed
    to a single topic filter, and therefore, the code grabs the first value from the
    received `granted_qos` array.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a new message received that matches the topic filter to which
    we have subscribed, the specified callback in the `client.on_messsage` attribute
    will be executed, that is, the `on_message` function. This function receives the
    `mqtt.Client` instance that established the connection with the MQTT server in
    the client argument and an `mqtt.MQTTMessage` instance in the `msg` argument.
    The `mqtt.MQTTMessage` class describes an incoming message.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, whenever the `on_message` function is executed, the value in `msg.topic`
    will always match `"vehicles/vehiclepi01/tests"` because we just subscribed to
    a single topic and no other topic name will match the topic filter. However, if
    we subscribed to one or many topic filters to which more than one topic might
    match, it would always be necessary to check which is the topic in which the message
    was sent by checking the value of the `msg.topic` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `on_message` function prints the topic for the message that
    has been received, `msg.topic`, and the string representation of the payload for
    the message, that is, the `msg.payload` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main block calls the `client.loop_forever` method that calls the
    `loop` method for us in an infinite blocking loop. At this point, we only want
    to run the MQTT client loop in our program. We will receive the messages whose
    topic matches the topic to which we have subscribed.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop` method is responsible for processing the network events, that is,
    it makes sure communication with the MQTT server is carried out. You can think
    about the `loop` method as the equivalent of synchronizing your email client to
    receive incoming messages and send the messages in the outbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the Mosquitto server or any other MQTT server you might want to use
    for this example is running. Then, execute the following line to start the example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see a traceback with an `SSLError` similar to the following lines, it
    means that the MQTT server hostname or IP doesn''t match the value specified for
    the `Common Name` attribute when you generated the server certificate file named
    `server.crt`. Make sure that you check the IP address for the MQTT server (Mosquitto
    server) and generate the server certificate file and key again with the appropriate
    IP address or hostname specified for `Common Name`, as explained in  [Chapter
    3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*, if you are working with the self-signed certificates
    we generated. If you are working with self-signed certificates, IP addresses,
    and a DHCP server, also check that the DHCP server didn''t change the IP address
    for your Mosquitto server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, follow these steps to use the MQTT.fx GUI utility to publish two messages
    to the `vehicles/vehiclepi01/tests` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch MQTT.fx and establish a connection with the MQTT server by following
    the steps we learned in  [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Publish and enter `vehicles/vehiclepi01/tests` in the drop-down menu at
    the left-hand side of the Publish button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click QoS 2 at the right-hand side of the Publish button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following text in the textbox under the Publish button: `{"CMD":
    " UNLOCK_DOORS"}`. Then, click the Publish button. MQTT.fx will publish the entered
    text to the specified topic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following text in the textbox under the Publish button: `{"CMD":
    "TURN_ON_HEADLIGHTS"}`. Then, click the Publish button. MQTT.fx will publish the
    entered text to the specified topic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t want to work with the MQTT.fx utility, you can run two `mosquitto_pub`
    commands to generate MQTT clients that publish messages to the topic. You just
    need to open another Terminal in macOS or Linux, or another Command Prompt in
    Windows, go to the directory in which Mosquitto is installed, and run the following
    commands. In this case, it isn''t necessary to specify the `-d` option. Replace
    `192.168.1.101` with the IP or hostname for the MQTT server. Remember to replace
    `ca.crt`, `board001.crt`, and `board001.key` with the full path to these files
    created in the `board_certificates` directory. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_04_01` folder, in the `script_01.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the device and window in which you executed the Python script. You will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Python program successfully established a secured and encrypted connection
    with the MQTT server and became a subscriber to the `vehicles/vehiclepi01/tests`
    topic with a granted QoS level of 2\. The program displayed the two messages it
    has received in the `vehicles/vehiclepi01/tests` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *C* to stop the execution of the program. The generated MQTT
    client will close the connection with the MQTT server. You will see an error message
    similar to the following output because the loop execution is interrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Configuring certificates for IoT boards that will work as clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will write Python code that will be ready to work on the different IoT
    boards. Of course, you can work with a single development computer or development
    board. There is no need to run the code on different devices. We just want to
    make sure we can write code that will be capable of running on different devices.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to copy the files we created in the previous chapter to a directory
    on the computer or device that will represent the board that controls a vehicle
    and that we will use to run a Python script. If you will be working with the same
    computer or device you have been using so far, you don't need to follow the next
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saved the files in a directory called `mqtt_certificates`. Create a `board_certificates`
    directory on the computer or board you are going to use as the MQTT client for
    this example. Copy the following three files to this new directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ca.crt`: Certificate authority certificate file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board001.crt`: Client certificate file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board001.key`: Client key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class to represent a vehicle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vehicle`: This class will represent a vehicle and provide methods that will
    be called whenever a command has to be processed. In order to keep the example
    simple, our methods will just print the actions that the vehicle executes after
    each method is called to the console output. A real-life class that represents
    a vehicle would interact with the engine, the lights, the actuators, the sensors,
    and the other different components of the vehicle whenever each method is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VehicleCommandProcessor`: This class will represent a command processor that
    will establish a connection with an MQTT server, subscribe to a topic in which
    the MQTT client will receive messages with commands, analyze the incoming messages,
    and delegate the execution of the commands to an associated instance of the `Vehicle`
    class. The `VehicleCommandProcessor` class will declare many static methods that
    we will specify as the callbacks for the MQTT client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new Python file named `vehicle_commands.py` in the main virtual environment
    folder. The following lines declare many variables with the values that identify
    each of the supported commands for the vehicle. In addition, the code declares
    many variables with the key string we will use to specify a command and the key
    we will use to specify a successfully executed command. All these variables are
    defined with all uppercase because we will use them as constants. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in
    the `vehicle_commands.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `COMMAND_KEY` variable defines the key string that defines what the code
    will understand as the command. Whenever we receive a message that includes the
    specified key string, we know that the value associated with this key in the dictionary
    will indicate the command that the message wants the code running in the board
    to be processed. The MQTT client won't receive messages as dictionaries, and therefore,
    it is necessary to convert them from strings to dictionaries when they are not
    just a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `SUCCESSFULLY_PROCESSED_COMMAND_KEY` variable defines the key string that
    defines what the code will use as a successfully processed command key in a response
    message published to the appropriate topic. Whenever we publish a message that
    includes the specified key string, we know that the value associated with this
    key in the dictionary will indicate the command that the board has successfully
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file, named `vehicle_mqtt_client.py`, in the main virtual
    environment folder. The following lines declare the necessary imports and the
    same variables we used in the previous example to establish the connection with
    the MQTT server. Then, the lines declare the `Vehicle` class. The code file for
    the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in the
    `vehicle_mqtt_client.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, all the configuration values to establish a connection
    with the Mosquitto MQTT server are defined in the Python file named `config.py`
    in the main virtual environment folder. If you want to run this example on a different
    device, you will have to create a new `config.py` file with the appropriate values
    and change the line that imports the values from the `config` module to use the
    new configuration file. Don't forget to replace the `/Users/gaston/board_certificates` value
    in the `certificates_path` string with the path to the `board_certificates` directory
    you created. In addition, replace the value for the `mqtt_server_host` with the
    IP address or hostname for the Mosquitto server or other MQTT server you might
    decide to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to specify the vehicle''s name in the name required argument. The constructor,
    that is, the `__init__` method, saves the received name in an attribute with the
    same name. Then, the constructor sets the initial values for two attributes: `min_speed_mph`
    and `max_speed_mph`. These attributes establish the minimum and maximum speed
    values for the vehicle, expressed in miles per hour.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Vehicle` class declares the `print_action_with_name_prefix` method that
    receives a string with the action that is being executed in the `action` argument
    and prints it with the value saved in the `name` attribute as a prefix. The other
    methods defined in this class call the `print_action_with_name_prefix` method
    to print messages indicating the actions that the vehicle is executing, with the
    vehicle's name as a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the recently installed `paho-mqtt` version 1.3.1 module to subscribe
    to a specific topic and run code when we receive messages in the topic. We will
    create a `VehicleCommandProcessor` class in the same Python file, named `vehicle_mqtt_client.py`,
    in the main virtual environment folder. This class will represent a command processor
    associated to an instance of the previously coded `Vehicle` class, configure the
    MQTT client and the subscription to the client, and declare the code for the callbacks
    that are going to be executed when certain events related to MQTT are fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will split the code for the `VehicleCommandProcessor` class into many code
    snippets to make it easier to understand each code section. You have to add the
    next lines to the existing `vehicle_mqtt_client.py` Python file. The following
    lines declare the `VehicleCommandProcessor` class and its constructor, that is,
    the `__init__` method. The code file for the sample is included in the `mqtt_python_gaston_hillar_04_01`
    folder, in the `vehicle_mqtt_client.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify a name for the command processor and the `Vehicle` instance
    that the command processor will control in the `name` and `vehicle` required arguments.
    The constructor, that is, the `__init__` method, saves the received `name` and
    `vehicle` in attributes with the same names. Then, the constructor sets the values
    for the `commands_topic` and `processed_commands_topic` class attributes. The
    constructor uses the received `name` to determine the topic name for the commands
    and for the successfully processed commands, based on the specifications we discussed
    earlier. The MQTT client will receive messages in the topic name saved in the
    `command_topic` class attribute, and will publish messages to the topic name saved
    in the `processed_commands_topic` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the constructor creates an instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    that represents an MQTT client and that we will use to communicate with an MQTT
    server. The code assigns this instance to the `client` attribute (`self.client`).
    As in our previous example, we want to work with MQTT version 3.11, and therefore,
    we specified `mqtt.MQTTv311` as the value for the protocol argument.
  prefs: []
  type: TYPE_NORMAL
- en: The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in the static methods that the
    constructor will specify as callbacks for the different events that the MQTT client
    fires. We want to have all the methods related to the vehicle command processor
    in the `VehicleCommandProcessor` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code assigns static methods to attributes of the `self.client` instance.
    The following table summarizes these assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Assigned static method** |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_connect` | `VehicleCommandProcessor.on_connect` |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_message` | `VehicleCommandProcessor.on_message` |'
  prefs: []
  type: TYPE_TB
- en: '| `client.on_subscribe` | `VehicleCommandProcessor.on_subscribe` |'
  prefs: []
  type: TYPE_TB
- en: Static methods do not receive either `self` or `cls` as the first argument,
    and therefore, we can use them as callbacks with the required number of arguments.
    Note that we will code and analyze these static methods in the next paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: The call to the `self.client.tls_set` method configures encryption and authentication
    options. Finally, the constructor calls the `client.connect` method and specifies
    the values for the `host`, `port`, and `keepalive` arguments. This way, the code
    asks the MQTT client to establish a connection to the specified MQTT server. Remember
    that the `connect` method runs with an asynchronous execution, and therefore,
    it is a non-blocking call.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to establish a connection with an MQTT server that isn't using TLS,
    you need to remove the call to the `self.client.tls_set` method. In addition,
    you need to use the appropriate port instead of the `8883` port that is specified
    when working with TLS. Remember that the default port when you don't work with
    TLS is `1883`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the `on_connect` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After a connection has been successfully established with the MQTT server, the
    specified callback in the `self.client.on_connect` attribute will be executed,
    that is, the `on_connect` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT server in the client argument.
  prefs: []
  type: TYPE_NORMAL
- en: The code checks the value of the `rc` argument that provides the `CONNACK` code
    returned by the MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`, it
    means that the MQTT server accepted the connection request, and therefore, the
    code calls the `client.subscribe` method with `VehicleCommandProcessor.commands_topic`
    as an argument to subscribe to the topic specified in the `commands_topic` class
    attribute and specifies a QoS level of 2 for the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the `on_subscribe` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `on_subscribe` static method displays the QoS level granted by the MQTT
    server for the topic filter we specified. In this case, we just subscribed to
    a single topic filter, and therefore, the code grabs the first value from the
    received `granted_qos` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the `on_message` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Whenever there is a new message received in the topic saved in the `commands_topic`
    class attribute to which we have subscribed, the specified callback in the `self.client.on_messsage`
    attribute will be executed, that is, the previously coded `on_message` static
    method (marked with the `@staticmethod` decorator). This static method receives
    the `mqtt.Client` instance that established the connection with the MQTT server
    in the client argument and an `mqtt.MQTTMessage` instance in the `msg` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `mqtt.MQTTMessage` class describes an incoming message.
  prefs: []
  type: TYPE_NORMAL
- en: The `msg.topic` attribute indicates the topic in which the message has been
    received. Thus, the static method checks whether the `msg.topic` attribute matches
    the value in the `commands_topic` class attribute. In this case, whenever the
    `on_message` method is executed, the value in `msg.topic` will always match the
    value in the topic class attribute because we just subscribed to one topic. However,
    if we subscribe to more than one topic, it is always necessary to check which
    is the topic in which the message was sent and in which we are receiving the message.
    Hence, we included the code to have a clear idea of how to check the `topic` for
    the received message.
  prefs: []
  type: TYPE_NORMAL
- en: The code prints the payload for the message that has been received, that is,
    the `msg.payload` attribute. Then, the code assigns the result of the `json.loads`
    function to deserialize `msg.payload` to a Python object and assigns the results
    to the `message_dictionary` local variable. If the contents of `msg.payload` are
    not JSON, a `ValueError` exception will be captured, the code will print a message
    indicating that the message doesn't include a valid command, and no more code
    will be executed in the static method. If the contents of `msg.payload` are JSON,
    we will have a dictionary in the `message_dictionary` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code checks whether the value saved in the `COMMAND_KEY` string is
    included in the `message_dictionary` dictionary. If the expression evaluates to
    `True`, it means that the JSON message converted to a dictionary includes a command
    that we have to process. However, before we can process the command, we have to
    check which is the command, and therefore, it is necessary to retrieve the value
    associated with the key equivalent to the value saved in the `COMMAND_KEY` string.
    The code is capable of running specific code when the value is any of the commands
    that we have analyzed as requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `active_instance` class attribute that has a reference to
    the active `VehicleCommandProcessor` instance to call the necessary methods for
    the associated vehicle based on the command that has to be processed. We had to
    declare the callbacks as static methods, and therefore, we use this class attribute
    to access the active instance. Once the command has been successfully processed,
    the code sets the `is_command_executed` flag to `True`. Finally, the code checks
    the value of this flag, and if it is equal to `True`, the code calls the `publish_executed_command_message`
    for the `VehicleCommandProcessor` instance saved in the `active_instance` class
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in a real-life example, we should add more validations. The previous
    code is simplified to allow us to keep our focus on MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines declare the `publish_executed_command_message` method that
    is part of the `VehicleCommandProcessor` class. You have to add these lines to
    the existing `vehicle_mqtt_client.py` Python file. The code file for the sample
    is included in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `publish_executed_command_message` method receives the message dictionary
    that has been received with the command in the message argument. The method calls
    the `json.dumps` function to serialize a dictionary to a JSON-formatted string
    with the response message that indicates the command has been successfully processed.
    Finally, the code calls the `client.publish` method with the `processed_commands_topic`
    variable as the topic argument and the JSON-formatted string (`response_message`)
    in the `payload` argument.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are not evaluating the response received from the `publish`
    method. In addition, we are using the default value for the `qos` argument that
    specifies the desired quality of service. Thus, we will publish this message with
    a QoS level equal to 0\. In [Chapter 5](1fa4ce92-f009-4676-813f-bd4590593c27.xhtml),
    *Testing and Improving our Vehicle Control Solution in Python*, we will work with
    more advanced scenarios in which we will add code to check the results of the
    method and we will add code to the `on_publish` callback that is fired when a
    message is successfully published, as we did in our previous example. In this
    case, we use QoS level 2 only for the messages that we receive with the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple calls to the loop method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines declare the `process_incoming_commands` method that is
    part of the `VehicleCommandProcessor` class. You have to add these lines to the
    existing `vehicle_mqtt_client.py` Python file. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `process_incoming_commands` method calls the `loop` method for the MQTT
    client and ensures communication with the MQTT server is carried out. Think about
    the call to the `loop` method as synchronizing your mailbox. Any pending messages
    to be published in the outgoing box will be sent, any incoming messages will arrive
    to the inbox, and the events that we have previously analyzed will be fired. This
    way, the vehicle command processor will receive messages and process commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following lines declare the main block of code. You have to add
    these lines to the existing `vehicle_mqtt_client.py` Python file. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in
    the `vehicle_mqtt_client.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `__main__` method creates an instance of the `Vehicle` class, named vehicle,
    with `"vehiclepi01"` as the value for the name argument. The next line creates
    an instance of the `VehicleCommandProcessor` class, named `vehicle_command_processor`,
    with `"vehiclepi01"` and the previously created `Vehicle` instance, *X*, as the
    values for the `name` and `vehicle` arguments. This way, `vehicle_command_processor`
    will delegate the execution of the commands to instance methods in `vehicle`.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for the `VehicleCommandProcessor` class will subscribe to the
    `vehicles/vehiclepi01/commands` topic in the MQTT server, and therefore, we must
    publish messages to this topic in order to send the commands that the code will
    process. Whenever a command is successfully processed, new messages will be published
    to the `vehicles/vehiclepi01/executedcommands` topic. Hence, we must subscribe
    to this topic to check the commands that the vehicle has executed.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop calls the `vehicle_command_processor.process_commands` method
    and sleeps for one second. The `process_commands` method calls the loop method
    for the MQTT client and ensures communication with the MQTT server is carried
    out.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a threaded interface that we can run by calling the `loop_start`
    method for the MQTT client. This way, we can avoid multiple calls to the loop
    method. However, we call the loop method to make it easier to debug the code and
    understand how everything works under the hood. We will work with the threaded
    interfaces in [Chapter 5](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129), *Testing
    and Improving our Vehicle Control Solution in Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following Python modules is the Paho Python Client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`paho-mqtt`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`paho-client-pip`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`paho-python-client`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To establish a connection with an MQTT server that uses TLS, which method do
    you have to call for the `paho.mqtt.client.Client` instance before calling `connect`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect_with_tls`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tls_set`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`configure_tls`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `paho.mqtt.client.Client` instance establishes a connection with the
    MQTT server, the callback assigned to which of the following attributes will be
    called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`on_connection`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`on_connect`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect_callback`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `paho.mqtt.client.Client` instance receives a message from one of
    the topic filters to which it has subscribed, the callback assigned to which of
    the following attributes will be called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`on_message_arrived`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`on_message`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`message_arrived_callback`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods of a `paho.mqtt.client.Client` instance calls
    the loop method for us in an infinite blocking loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`infinite_loop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_while_true`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loop_forever`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the requirements to control a vehicle with MQTT
    messages. We defined the topics that we would use and the commands that would
    be part of the messages’ payloads to control a vehicle. Then, we worked with the
    Paho Python Client to write Python code that connected an MQTT client to the MQTT
    server.
  prefs: []
  type: TYPE_NORMAL
- en: We understood the methods we needed to call for the Paho Python Client and their
    parameters. We analyzed how callbacks worked and we wrote code to subscribe to
    topic filters as well as to receive and process messages.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote code that processed commands for a vehicle with Python. The code is
    able to run on different IoT platforms, including Raspberry Pi 3 family boards,
    Qualcomm DragonBoard, BeagleBone Black, MinnowBoard Turbot, LattePanda, UP squared,
    and also on any computer that is capable of executing Python 3.6.x code. We worked
    with the network loop for the MQTT client in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood the basics to use Python to work with MQTT, we will
    use and improve our vehicle control solution with MQTT messages and Python code
    and we will take advantage of additional MQTT features, which are the topics we
    are going to discuss in [Chapter 5](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129), *Testing
    and Improving our Vehicle Control Solution in Python*.
  prefs: []
  type: TYPE_NORMAL
