- en: Calculus and Differential Equations
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss various topics related to calculus. Calculus
    is the branch of mathematics that concerns the processes of differentiation and
    integration. Geometrically, the derivative of a function represents the gradient
    of the curve of the function, and the integral of a function represents the area
    below the curve of the function. Of course, these characterizations only hold
    in certain circumstances, but they provide a reasonable foundation for this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looking at calculus for a simple class of functions: the polynomials.
    In the first recipe, we create a class that represents a polynomial and define
    methods that differentiate and integrate the polynomial. Polynomials are convenient
    because the derivative or integral of a polynomial is again a polynomial. Then,
    we use the SymPy package to perform symbolic differentiation and integration on
    more general functions. After that, we see methods for solving equations using
    the SciPy package. Next, we turn our attention to numerical integration (quadrature)
    and solving differential equations. We use the SciPy package to solve ordinary
    differential equations and systems of ordinary differential equations, and then
    use a finite difference scheme to solve a simple partial differential equation.
    Finally, we use the fast Fourier transform to process a noisy signal and filter
    out the noise.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Working with polynomials and calculus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving equations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating functions numerically using SciPy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving simple differential equations numerically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of differential equations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving partial differential equations numerically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using discrete Fourier transforms for signal processing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the scientific Python packages NumPy and SciPy, we also need
    the SymPy package. This can be installed using your favorite package manager,
    such as `pip`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the`Chapter 03` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/32HuH4X](https://bit.ly/32HuH4X).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Working with polynomials and calculus
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polynomials are among the simplest functions in mathematics and are defined
    as a sum:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21d2a94c-cfae-48b2-92cd-b345dd6fe425.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '*x* represents a placeholder to be substituted, and *a[i]* is a number. Since
    polynomials are simple, they provide an excellent means for a brief introduction
    to calculus. Calculus concerns the *differentiation* and *integration* of functions.
    Integration is, roughly speaking, *anti-differentiation*, in the sense that first
    integrating and then differentiating yields the original function.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will define a simple class that represents a polynomial and
    write methods for this class to perform differentiation and integration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geometrically, the *derivative*, obtained by *differentiating*, of a function
    is its *gradient*, and the *integral*, obtained by *integrating*, of a function
    is the area that lies between the curve of the function and the *x* axis, accounting
    for whether the curve lies above or below the axis. In practice, differentiating
    and integrating are done symbolically, using a set of rules and standard results
    that are particularly simple for polynomials.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: There are no additional packages required for this recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a class representing a polynomial
    and implement differentiation and integration methods for this class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a simple class to represent a polynomial:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have defined a basic class for a polynomial, we can move on to
    implement the differentiation and integration operations for this `Polynomial`
    class to illustrate how these operations change polynomials. We start with differentiation.
    We generate new coefficients by multiplying each element in the current list of
    coefficients without the first element. We use this new list of coefficients to
    create a new `Polynomial` instance that is returned:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为多项式定义了一个基本类，我们可以继续实现这个`Polynomial`类的微分和积分操作，以说明这些操作如何改变多项式。我们从微分开始。我们通过将当前系数列表中的每个元素（不包括第一个元素）相乘来生成新的系数。我们使用这个新的系数列表来创建一个新的`Polynomial`实例，然后返回：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To implement the integration method, we need to create a new list of coefficients
    containing the new constant (converted to a float for consistency) given by the
    argument. We then add to this list of coefficients the old coefficients divided
    by their new position in the list:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现积分方法，我们需要创建一个包含由参数给出的新常数（转换为浮点数以保持一致性）的新系数列表。然后我们将旧系数除以它们在列表中的新位置，加到这个系数列表中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, to make sure these methods work as expected, we should test these
    two methods with a simple case. We can check this using a very simple polynomial,
    such as *x² - 2x + 1*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保这些方法按预期工作，我们应该用一个简单的案例测试这两种方法。我们可以使用一个非常简单的多项式来检查，比如*x² - 2x + 1*：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Polynomials offer an easy introduction to the basic operations of calculus,
    but it isn't so easy to construct Python classes for other general classes of
    functions. That being said, polynomials are extremely useful because they are
    well understood and, perhaps more importantly, calculus for polynomials is very
    easy. For powers of a variable *x*, the rule for differentiation is to multiply
    by the power and reduce the power by 1, so that *x^n* becomes *nx^(n-1)*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式为我们提供了一个对微积分基本操作的简单介绍，但对于其他一般类的函数来说，构建Python类并不那么容易。也就是说，多项式非常有用，因为它们被很好地理解，也许更重要的是，对于多项式的微积分非常容易。对于变量*x*的幂，微分的规则是乘以幂并减少1，因此*x^n*变为*nx^(n-1)*。
- en: Integration is more complex, since the integral of a function is not unique.
    We can add any constant to an integral and obtain a second integral. For powers
    of a variable *x*, the rule for integration is to increase the power by 1 and
    divide by the new power, so that *x^n* becomes *x^(n+1)/*(*n+1*), so to integrate
    a polynomial, we increase each power of *x* by 1 and divide the corresponding
    coefficient by the new power.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 积分更复杂，因为函数的积分不是唯一的。我们可以给积分加上任意常数并得到第二个积分。对于变量*x*的幂，积分的规则是将幂增加1并除以新的幂，因此*x^n*变为*x^(n+1)/*(*n+1*)，所以要对多项式进行积分，我们将每个*x*的幂增加1，并将相应的系数除以新的幂。
- en: The `Polynomial` class that we defined in the recipe is rather simplistic, but
    represents the core idea. A polynomial is uniquely determined by its coefficients,
    which we can store as a list of numerical values. Differentiation and integration
    are operations that we can perform on this list of coefficients. We include a
    simple `__repr__` method to help with the display of `Polynomial` objects, and
    a `__call__` method to facilitate evaluation at specific numerical values. This
    is mostly to demonstrate the way that a polynomial is evaluated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个食谱中定义的`Polynomial`类相当简单，但代表了核心思想。多项式由其系数唯一确定，我们可以将其存储为一组数值值的列表。微分和积分是我们可以对这个系数列表执行的操作。我们包括一个简单的`__repr__`方法来帮助显示`Polynomial`对象，以及一个`__call__`方法来促进在特定数值上的评估。这主要是为了演示多项式的评估方式。
- en: Polynomials are useful for solving certain problems that involve evaluating
    a computationally expensive function. For such problems, we can sometimes use
    some kind of polynomial interpolation, where we "fit" a polynomial to another
    function, and then use the properties of polynomials to help solve the original
    problem. Evaluating a polynomial is much "cheaper" than the original function,
    so this can lead to dramatic improvements in speed. This usually comes at the
    cost of some accuracy. For example, Simpson's rule for approximating the area
    under a curve approximates the curve by quadratic polynomials over intervals defined
    by three consecutive mesh points. The area below each quadratic polynomial can
    be calculated easily by integration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式对于解决涉及评估计算昂贵函数的某些问题非常有用。对于这样的问题，我们有时可以使用某种多项式插值，其中我们将一个多项式“拟合”到另一个函数，然后利用多项式的性质来帮助解决原始问题。评估多项式比原始函数要“便宜”得多，因此这可能会大大提高速度。这通常是以一些精度为代价的。例如，辛普森法则用二次多项式逼近曲线下的面积，这些多项式是由三个连续网格点定义的间隔内的。每个二次多项式下面的面积可以通过积分轻松计算。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Polynomials have many more important roles in computational programming than
    simply demonstrating the effect of differentiation and integration. For this reason,
    a much richer `Polynomial` class is provided in the NumPy package, `numpy.polynomial`.
    The NumPy `Polynomial` class, and the various derived subclasses, are useful in
    all kinds of numerical problems, and support arithmetic operations as well as
    other methods. In particular, there are methods for fitting polynomials to collections
    of data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式在计算编程中扮演的角色远不止是展示微分和积分的效果。因此，NumPy包中提供了一个更丰富的`Polynomial`类，`numpy.polynomial`。NumPy的`Polynomial`类和各种派生子类在各种数值问题中都很有用，并支持算术运算以及其他方法。特别是，有用于将多项式拟合到数据集合的方法。
- en: NumPy also provides classes, derived from `Polynomial`, that represent various
    special kinds of polynomials. For example, the `Legendre` class represents a specific
    system of polynomials called the **Legendre** polynomials. The Legendre polynomials
    are defined for *x* satisfying *-1 ≤ x ≤ 1* and form an orthogonal system, which
    is important for applications such as numerical integration and the **finite element
    method** for solving partial differential equations. The Legendre polynomials
    are defined using a recursive relation. We define
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了从`Polynomial`派生的类，表示各种特殊类型的多项式。例如，`Legendre`类表示一种特定的多项式系统，称为**Legendre**多项式。Legendre多项式是为满足*-1
    ≤ x ≤ 1*的*x*定义的，并且形成一个正交系统，这对于诸如数值积分和**有限元方法**解决偏微分方程等应用非常重要。Legendre多项式使用递归关系定义。我们定义
- en: '![](assets/52bf688b-c298-4854-8933-fe2424d18981.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52bf688b-c298-4854-8933-fe2424d18981.png)'
- en: and for each *n ≥ 2*, we define the *n*th Legendre polynomial to satisfy the
    recurrence relation,
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个*n ≥ 2*，我们定义第*n*个Legendre多项式满足递推关系，
- en: '![](assets/70211164-f54e-4915-8a81-c7e8dfb8c69b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70211164-f54e-4915-8a81-c7e8dfb8c69b.png)'
- en: There are several other so called *orthogonal (systems of) polynomials*, including
    *Laguerre**polynomials*, *Chebyshev polynomials*, and *Hermite polynomials*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些所谓的*正交（系统的）多项式*，包括*Laguerre*多项式*，*Chebyshev多项式*和*Hermite多项式*。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Calculus is certainly well documented in mathematical texts, and there are many
    textbooks that cover from the basic methods all the way to the deep theory. Orthogonal
    systems of polynomials are also well documented among numerical analysis texts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分在数学文本中有很好的文档记录，有许多教科书涵盖了从基本方法到深层理论的内容。正交多项式系统在数值分析文本中也有很好的文档记录。
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号微分和积分
- en: At some point, you may have to differentiate a function that is not a simple
    polynomial, and you may need to do this in some kind of automated fashion, for
    example, if you are writing software for education. The Python scientific stack
    includes a package called SymPy, which allows us to create and manipulate symbolic
    mathematical expressions within Python. In particular, SymPy can perform differentiation
    and integration of symbolic functions, just like a mathematician.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，您可能需要区分一个不是简单多项式的函数，并且可能需要以某种自动化的方式来做这件事，例如，如果您正在编写教育软件。Python科学堆栈包括一个名为SymPy的软件包，它允许我们在Python中创建和操作符号数学表达式。特别是，SymPy可以执行符号函数的微分和积分，就像数学家一样。
- en: In this recipe, we will create a symbolic function, and then differentiate and
    integrate this function using the SymPy library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个符号函数，然后使用SymPy库对这个函数进行微分和积分。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Unlike some of the other scientific Python packages, there does not seem to
    be a standard alias under which SymPy is imported in the literature. Instead the
    documentation uses a star import at several points, which is not in line with
    the PEP8 style guide. This is possibly to make the mathematical expressions more
    natural. We will simply import the module under its name `sympy`, to avoid any
    confusion with the `scipy` package''s standard abbreviation, `sp` (which is the
    natural choice for `sympy` too):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些科学Python软件包不同，文献中似乎没有一个标准的别名来导入SymPy。相反，文档在几个地方使用了星号导入，这与PEP8风格指南不一致。这可能是为了使数学表达更自然。我们将简单地按照其名称`sympy`导入模块，以避免与`scipy`软件包的标准缩写`sp`混淆（这也是`sympy`的自然选择）：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this recipe, we will define a symbolic expression that represents the function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将定义一个表示函数的符号表达式
- en: '![](assets/d45795ee-95b9-4f79-85b3-b118aafc7d48.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d45795ee-95b9-4f79-85b3-b118aafc7d48.png)'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Differentiating and integrating symbolically (as you would do by hand) is very
    easy using the SymPy package. Follow these steps to see how it is done:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SymPy软件包进行符号微分和积分（就像您手工操作一样）非常容易。按照以下步骤来看看它是如何完成的：
- en: 'Once SymPy is imported, we define the symbols that will appear in our expressions.
    This is a Python object that has no particular value, just like a mathematical
    variable, but can be used in formulas and expressions to represent many different
    values simultaneously. For this recipe, we need only define a symbol for *x*,
    since we will only require constant (literal) symbols and functions in addition
    to this. We use the `symbols` routine from `sympy` to define a new symbol. To
    keep the notation simple, we will name this new symbol `x`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入了SymPy，我们就定义将出现在我们的表达式中的符号。这是一个没有特定值的Python对象，就像数学变量一样，但可以在公式和表达式中表示许多不同的值。对于这个示例，我们只需要定义一个符号用于*x*，因为除此之外我们只需要常数（文字）符号和函数。我们使用`sympy`中的`symbols`例程来定义一个新符号。为了保持符号简单，我们将这个新符号命名为`x`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The symbols defined using the `symbols` function support all of the arithmetic
    operations, so we can construct the expression directly using the symbol `x` we
    just defined:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`symbols`函数定义的符号支持所有算术运算，因此我们可以直接使用我们刚刚定义的符号`x`构造表达式：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can use the symbolic calculus capabilities of SymPy to compute the derivative
    of `f`, that is, differentiate `f`. We do this using the `diff` routine in `sympy`,
    which differentiates a symbolic expression with respect to a specified symbol,
    and returns an expression for the derivative. This is often not expressed in its
    simplest form, so we use the `sympy.simplify` routine to simplify the result:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用SymPy的符号微积分能力来计算`f`的导数，即对`f`进行微分。我们使用`sympy`中的`diff`例程来完成这个操作，它对指定的符号进行符号表达式微分，并返回导数的表达式。这通常不是以最简形式表达的，因此我们使用`sympy.simplify`例程来简化结果：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can check whether the result of the symbolic differentiation using SymPy
    is correct, compared to the derivative computed by hand, defined as a SymPy expression,
    as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式检查使用SymPy进行符号微分的结果是否正确，与手工计算的导数相比，定义为SymPy表达式：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'SymPy equality tests whether two expressions are equal, but not whether they
    are symbolically equivalent. Therefore, we must first simplify the difference
    of the two statements we wish to test and test for equality to `0`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SymPy相等性测试两个表达式是否相等，但不测试它们是否在符号上等价。因此，我们必须首先简化我们希望测试的两个语句的差异，并测试是否等于`0`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can integrate the function `f`using SymPy by using the `integrate`function.
    It is a good idea to also provide the symbol with which the integration is to
    be performed by providing it as the second optional argument:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用SymPy通过`integrate`函数对函数`f`进行积分。还可以通过将其作为第二个可选参数提供来提供要执行积分的符号：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SymPy defines various classes to represent certain kinds of expressions. For
    example, symbols, represented by the `Symbol` class, are examples of *atomic expressions*.
    Expressions are built up in a similar way to how Python builds an abstract syntax
    tree from source code. These expression objects can then be manipulated using
    methods and the standard arithmetic operations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy定义了表示某些类型表达式的各种类。例如，由`Symbol`类表示的符号是*原子表达式*的例子。表达式是以与Python从源代码构建抽象语法树的方式构建起来的。然后可以使用方法和标准算术运算来操作这些表达式对象。
- en: SymPy also defines standard mathematical functions that can operate on the `Symbol`
    objects to create symbolic expressions. The most important feature is the ability
    to perform symbolic calculus – rather than the numerical calculus that we explore
    in the remainder of this chapter – and give exact (sometimes called *analytic*)
    solutions to calculus problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy还定义了可以在`Symbol`对象上操作以创建符号表达式的标准数学函数。最重要的特性是能够执行符号微积分 - 而不是我们在本章剩余部分中探索的数值微积分
    - 并给出对微积分问题的精确（有时称为*解析*）解决方案。
- en: The `diff` routine from the SymPy package performs differentiation on these
    symbolic expressions. The result of this routine is usually not in its simplest
    form, which is why we used the `simplify` routine to simplify the derivative in
    the recipe. The `integrate` routine symbolically integrates a `scipy` expression
    with respect to a given symbol. (The `diff` routine also accepts a symbol argument
    that specifies the symbol for differentiating against.) This returns an expression
    whose derivative is the original expression. This routine does not add a constant
    of integration, which is good practice when doing integrals by hand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy软件包中的`diff`例程对这些符号表达式进行微分。这个例程的结果通常不是最简形式，这就是为什么我们在配方中使用`简化`例程来简化导数的原因。`integrate`例程用给定的符号对`scipy`表达式进行符号积分。（`diff`例程还接受一个符号参数，用于指定微分的符号。）这将返回一个其导数为原始表达式的表达式。这个例程不会添加积分常数，这在手工积分时是一个好的做法。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: SymPy can do much more than simple algebra and calculus. There are submodules
    for various areas of mathematics, such as number theory, geometry, and other discrete
    mathematics (such as combinatorics).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy可以做的远不止简单的代数和微积分。它有各种数学领域的子模块，如数论、几何和其他离散数学（如组合数学）。
- en: 'SymPy expressions (and functions) can be built into Python functions that can
    be applied to NumPy arrays. This is done using the `lambdify` routine from the
    `sympy.utilities` module. This converts a SymPy expression to a numerical expression
    that uses the NumPy equivalents of the SymPy standard functions to evaluate the
    expressions numerically. The result is similar to defining a Python Lambda, hence
    the name. For example, we could convert the function and derivative from this
    recipe into Python functions using this routine:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy表达式（和函数）可以构建成Python函数，可以应用于NumPy数组。这是使用`sympy.utilities`模块中的`lambdify`例程完成的。这将SymPy表达式转换为使用SymPy标准函数的NumPy等价函数来数值评估表达式。结果类似于定义Python
    Lambda，因此得名。例如，我们可以使用这个例程将这个配方中的函数和导数转换为Python函数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `lambdify` routine takes two arguments. The first is the variables to be
    provided, `x` in the previous code block, and the second is the expression to
    be evaluated when this function is called. For example, we can evaluate the lambdified
    SymPy expressions defined previously as if they were ordinary Python functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify`例程接受两个参数。第一个是要提供的变量，上一个代码块中的`x`，第二个是在调用此函数时要评估的表达式。例如，我们可以评估之前定义的lambdified
    SymPy表达式，就好像它们是普通的Python函数一样：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can even evaluate these lambdified expressions on NumPy arrays:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在NumPy数组上评估这些lambdified表达式：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `lambdify` routine uses the Python `exec` routine to execute the code, so
    it should not be used with unsanitized input.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify`例程使用Python的`exec`例程来执行代码，因此不应该与未经过消毒的输入一起使用。'
- en: Solving equations
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解方程
- en: Many mathematical problems eventually reduce to solving an equation of the form*f(x*)
    = 0, where *f* is a function of a single variable. Here, we try to find a value
    of *x* for which the equation holds. The values of *x* for which the equation
    holds are sometimes called *roots* of the equation. There are numerous algorithms
    for finding solutions to equations of this form. In this recipe, we will use the
    Newton-Raphson and secant methods to solve an equation of the form *f(x*) = 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数学问题最终归结为解形式为*f(x*) = 0的方程，其中*f*是单变量函数。在这里，我们试图找到一个使方程成立的*x*的值。使方程成立的*x*的值有时被称为方程的*根*。有许多算法可以找到这种形式的方程的解。在这个配方中，我们将使用牛顿-拉弗森和弦截法来解决形式为*f(x*)
    = 0的方程。
- en: The Newton-Raphson method (Newton's method) and the secant method are good,
    standard root finding algorithms that can be applied in almost any situation.
    These are*iterative methods* that start with an approximation of the root and
    iteratively improve this approximation until it lies within a given tolerance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法（牛顿法）和弦截法是良好的标准根查找算法，几乎可以应用于任何情况。这些是*迭代方法*，从一个根的近似值开始，并迭代改进这个近似值，直到它在给定的容差范围内。
- en: To demonstrate these techniques, we will use the function from the *Symbolic
    calculus using SymPy* recipe defined by
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些技术，我们将使用*使用SymPy进行符号计算*配方中定义的函数
- en: '![](assets/c13a1277-2b71-46bc-9151-3a68073ce5b6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c13a1277-2b71-46bc-9151-3a68073ce5b6.png)'
- en: which is defined for all real values of *x* and has exactly two roots, one at*x*
    = 0 and one at*x*= 2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它对所有实数*x*都有定义，并且恰好有两个根，一个在*x*=0，另一个在*x*=2。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The SciPy package contains routines for solving equations (among many other
    things). The root finding routines can be found in the `optimize`module from the
    `scipy` package.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy包含用于解方程的例程（以及许多其他内容）。根查找例程可以在`scipy`包的`optimize`模块中找到。
- en: If your equation is not in the form *f*(*x*) = *0*, then you will need to rearrange
    it so that this is the case. This is usually not too difficult, and simply requires
    moving any terms on the right-hand side over to the left-hand side. For example,
    if you wish to find the fixed points of a function, that is, when*g*(*x*)*= x*,
    then we would apply the method to the related function given by *f*(*x*) =*g*(*x*)*-
    x.*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方程不是形式上的*f*(*x*) = *0*，那么你需要重新排列它，使其成为这种情况。这通常不太困难，只需要将右侧的任何项移到左侧即可。例如，如果你希望找到函数的不动点，也就是当*g*(*x*)*=
    x*时，我们会将方法应用于由*f*(*x*) =*g*(*x*)*- x.*给出的相关函数。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `optimize` package provides routines for numerical root finding. The following
    instructions describe how to use the `newton` routine from this module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimize`包提供了用于数值根查找的例程。以下说明描述了如何使用该模块中的`newton`例程：'
- en: 'The `optimize`module is not listed in the `scipy`namespace, so you must import
    it separately:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimize`模块没有列在`scipy`命名空间中，所以你必须单独导入它：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we must define this function and its derivative in Python:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们必须在Python中定义这个函数及其导数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The derivative of this function was computed in the previous recipe:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的导数在前一个配方中被计算出来：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For both the Newton-Raphson and secant methods, we use the `newton` routine
    from `optimize`. Both the secant method and the Newton-Raphson method require
    the function and the first argument and the first approximation,`x0`, as the second
    argument. To use the Newton-Raphson method, we must provide thederivative of*f*,
    using the `fprime`keyword argument:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于牛顿-拉弗森和割线法，我们使用`optimize`中的`newton`例程。割线法和牛顿-拉弗森法都需要函数和第一个参数以及第一个近似值`x0`作为第二个参数。要使用牛顿-拉弗森法，我们必须提供*f*的导数，使用`fprime`关键字参数：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To use the secant method, only the function is needed, but we must provide
    the first two approximations for the root; the second is provided as the `x1`keyword
    argument:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用割线法时，只需要函数，但是我们必须提供根的前两个近似值；第二个作为`x1`关键字参数提供：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Neither the Newton-Raphson nor the secant method are guaranteed to converge
    to a root. It is perfectly possible that the iterates of the method will simply
    cycle through a number of points (periodicity) or fluctuate wildly (chaos).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森法和割线法都不能保证收敛到根。完全有可能方法的迭代只是在一些点之间循环（周期性）或者波动剧烈（混沌）。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Newton-Raphson method for a function*f*(*x*) with derivative*f'*(*x*) and
    initial approximation *x[0]*is defined iteratively using the formula
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有导数*f'*(*x*)和初始近似值*x[0]*的函数*f*(*x*)，牛顿-拉弗森方法使用以下公式进行迭代定义
- en: '![](assets/f3f99361-b4f0-4dde-8420-e7e76aa123a3.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f3f99361-b4f0-4dde-8420-e7e76aa123a3.png)'
- en: for each integer*i* ≥*0*. Geometrically, this formula arises by considering
    the direction in which the gradient is negative (so the function is decreasing)
    if*f(x[i])*>*0* or positive (so the function is increasing) if*f*(*x[i]*) <*o*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个整数*i* ≥*0*。从几何上讲，这个公式是通过考虑梯度的负方向（所以函数是递减的）如果*f(x[i])*>*0*或正方向（所以函数是递增的）如果*f*(*x[i]*)
    <*o*。
- en: The secant method is based on the Newton-Raphson method, but replaces the first
    derivative by the approximation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法基于牛顿-拉弗森法，但是用近似值替换了一阶导数
- en: '![](assets/f2412966-ce93-4807-8fb9-cadb324252e5.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2412966-ce93-4807-8fb9-cadb324252e5.png)'
- en: when*x[i]*-*x[i-1]* is sufficiently small, which occurs if the method is converging,
    then this is a good approximation. The price paid for not requiring the derivative
    of the function*f* is that we require an additional initial guess to start the
    method. The formula for the method is given by
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x[i]*-*x[i-1]*足够小时，这意味着方法正在收敛，这是一个很好的近似值。不需要函数*f*的导数的代价是我们需要一个额外的初始猜测来启动方法。该方法的公式如下
- en: '![](assets/85704de4-933f-4fd1-86a4-792565350241.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85704de4-933f-4fd1-86a4-792565350241.png)'
- en: Generally speaking, if either method is given an initial guess (guesses for
    the secant method) that is sufficiently close to a root, then the method will
    converge to that root. The Newton-Raphson method can also fail if the derivative
    is zero at one of the iterations, in which case the formula is not well defined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果任一方法得到一个足够接近根的初始猜测（割线法的猜测），那么该方法将收敛于该根。牛顿-拉弗森法在迭代中导数为零时也可能失败，此时公式未被很好地定义。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The methods mentioned in this recipe are general purpose methods, but there
    are others that may be faster or more accurate in some circumstances. Broadly
    speaking, root finding algorithms fall into two categories: algorithms that use
    information about the function''s gradient at each iterate (Newton-Raphson, secant,
    Halley) and algorithms that require bounds on the location of a root (bisection
    method, regula-falsi, Brent). The algorithms discussed so far are of the first
    kind, and while generally quite fast, they may fail to converge.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中提到的方法是通用方法，但在某些情况下可能有更快或更准确的方法。广义上讲，根查找算法分为两类：在每次迭代中使用函数梯度信息的算法（牛顿-拉弗森、割线、Halley）和需要根位置的界限的算法（二分法、regula-falsi、Brent）。到目前为止讨论的算法属于第一类，虽然通常相当快，但可能无法收敛。
- en: 'The second kind of algorithms are those for which a root is known to exist
    within a specified interval*a ≤**x* ≤*b*. We can check whether a root lies within
    such an interval by checking that*f*(*a*) and*f*(*b*) have different signs, that
    is, one of *f*(*a*) <*0*<*f*(*b*) or*f*(*b*) <*0*<*f*(*a*) is true. (Provided,
    of course, that the function is*continuous,* which tends to be the case in practice.)
    The most basic algorithm of this kind is the bisection algorithm, which repeatedly
    bisects the interval until a sufficiently good approximation to the root is found.
    The basic premise is to split the interval between*a*and *b*at the mid-point and
    select the interval in which the function changes sign. The algorithm repeats
    until the interval is very small. The following is a rudimentary implementation
    of this algorithm in Python:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method is guaranteed to converge, since at each step the distance*b-a*
    is halved. However, it is possible that the method will require more iterations
    than Newton-Raphson or the secant method. A version of the bisection method can
    also be found in`optimize`. This version is implemented in C and is considerably
    more efficient that the version presented here, but the bisection method is not
    the fastest method in most cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Brent''s method is an improvement on the bisection method, and is available
    in the`optimize` module as`brentq`. It uses a combination of bisection and interpolation
    to quickly find the root of an equation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is important to note that the techniques that involve bracketing (bisection,
    regula-falsi, Brent) cannot be used to find the root functions of a complex variable,
    whereas those techniques that do not use bracketing (Newton, secant, Halley) can.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Integrating functions numerically using SciPy
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration can be interpreted as the area that lies between a curve and the
    *x*axis, signed according to whether this area is above or below the axis. Some
    integrals cannot be computed directly, using symbolic means, and instead have
    to be approximated numerically. One classic example of this is the Gaussian error
    function, which was mentioned in the *Basic mathematical functions* section in
    [Chapter1](6bc3b1d7-d916-4560-b4a3-8f4001bee082.xhtml), *Basic Packages, Functions,
    and Concepts*. This is defined by the formula
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97d08d9b-2e67-4e07-88c0-f52be50f2ae1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: and the integral that appears here cannot be evaluated symbolically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use the numerical integration routines in
    the SciPy package to compute the integral of a function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `scipy.integrate`module, which contains several routines for computing
    numerical integrals. We import this module as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to numerically integrate a function using
    SciPy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We evaluate the integral that appears in the definition of the error function
    at the value *x = 1*. For this, we need to define the integrand (the function
    that appears inside the integral) in Python:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are two main routines in `scipy.integrate`for performing numerical integration
    (quadrature) that can be used. The first is the `quad`function, which uses QUADPACK
    to perform the integration, and the second is `quadrature`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quad`routine is a general-purpose integration tool. It expects three arguments,
    which are the function to be integrated (`erf_integrand`), the lower limit (`-1.0`),
    and the upper limit (`1.0`):'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first returned value is the value of the integral and the second is an estimate
    for the error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeating the computation with the `quadrature`routine, we get the following.
    The arguments are the same as for the `quad` routine:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output is the same format as the code, with the value of the integral and
    then an estimate of the error. Notice that the error is larger for the `quadrature`routine.
    This is a result of the method terminating once the estimated error falls below
    a given tolerance, which can be modified when the routine is called.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most numerical integration techniques follow the same basic procedure. First,
    we choose points *x[i]*for *i = 1, 2,…, n* in the region of integration, and then
    use these values and the values *f*(*x[i]*) to approximate the integral. For example,
    with the trapezium rule, we approximate the integral by
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数值积分技术都遵循相同的基本过程。首先，我们选择积分区域中的点*x[i]*，对于*i = 1, 2,…, n*，然后使用这些值和值*f*(*x[i]*)来近似积分。例如，使用梯形法则，我们通过以下方式近似积分
- en: '![](assets/ae1f28f9-d69a-446b-a943-b34ce41e4bcb.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae1f28f9-d69a-446b-a943-b34ce41e4bcb.png)'
- en: 'where *a < x[1]< x[2]< … < x[n-1]< b* and *h*is the (common) difference between
    adjacent *x[i]*values, including the end points *a*and *b*. This can be implemented
    in Python as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a < x[1]< x[2]< … < x[n-1]< b*，*h*是相邻*x[i]*值之间的（公共）差异，包括端点*a*和*b*。这可以在Python中实现如下：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The algorithms used by `quad`and `quadrature`are far more sophisticated than
    this. Using this function to approximate the integral of `erf_integrand`using
    `trapezium`yields a result of 1.4936463036001209, which agrees with the approximations
    from the `quad` and `quadrature` routines to 5 decimal places.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad`和`quadrature`使用的算法比这复杂得多。使用这个函数来近似使用`trapezium`积分`erf_integrand`的积分得到的结果是1.4936463036001209，这与`quad`和`quadrature`例程的近似结果在5位小数的情况下是一致的。'
- en: The `quadrature`routine uses a fixed tolerance Gaussian quadrature, whereas
    the `quad`routine uses an adaptive algorithm implemented in the Fortran library
    QUADPACK routines. Timing both routines, we find that the `quad` routine is approximately
    5 times faster than the `quadrature` routine for the problem described in the
    recipe. The `quad` routine executes in approximately 27 µs, averaged over 1 million
    executions, while the `quadrature` routine executes in approximately 134 µs. (Your
    results may differ depending on your system.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`quadrature`例程使用固定容差的高斯积分，而`quad`例程使用Fortran库QUADPACK例程中实现的自适应算法。对两个例程进行计时，我们发现对于配方中描述的问题，`quad`例程大约比`quadrature`例程快5倍。`quad`例程在大约27微秒内执行，平均执行1百万次，而`quadrature`例程在大约134微秒内执行。（您的结果可能会因系统而异。）'
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The routines mentioned in this section require the integrand function to be
    known, which is not always the case. Instead, it might be the case that we know
    a number of pairs (*x*,y) with *y = f*(*x*), but we don't know the function *f*to
    evaluate at additional points. In this case, we can use one of the sampling quadrature
    techniques from `scipy.integrate`. If the number of known points is very large
    and all points are equally spaced, we can use Romberg integration for a good approximation
    of the integral. For this, we use the `romb`routine. Otherwise, we can use a variant
    of the trapezium rule (as above) using the `trapz`routine, or Simpson's rule using
    the `simps` routine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到的例程需要知道被积函数，但情况并非总是如此。相反，可能是我们知道一些(*x*,y)对，其中*y = f*(*x*)，但我们不知道要在额外点上评估的函数*f*。在这种情况下，我们可以使用`scipy.integrate`中的采样积分技术之一。如果已知点的数量非常大，并且所有点都是等间距的，我们可以使用Romberg积分来很好地近似积分。为此，我们使用`romb`例程。否则，我们可以使用梯形法则的变体（如上所述）使用`trapz`例程，或者使用`simps`例程使用辛普森法则。
- en: Solving simple differential equations numerically
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值解简单微分方程
- en: Differential equations arise in situations where a quantity evolves, usually
    over time, according to a given relationship. They are extremely common in engineering
    and physics, and appear quite naturally. One of the classic examples of a (very
    simple) differential equation is the law of cooling devised by Newton. The temperature
    of a body cools at a rate proportional to the current temperature. Mathematically,
    this means that we can write the derivative of the temperature *T* of the body
    at time *t > 0* using the differential equation
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程出现在一个数量根据给定关系演变的情况中，通常是随着时间的推移。它们在工程和物理学中非常常见，并且自然地出现。一个经典的（非常简单）微分方程的例子是牛顿提出的冷却定律。物体的温度以与当前温度成比例的速率冷却。从数学上讲，这意味着我们可以写出物体在时间*t
    > 0*时的温度*T*的导数，使用微分方程
- en: '![](assets/81295a45-5fdf-4837-86ac-96caf899fa75.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81295a45-5fdf-4837-86ac-96caf899fa75.png)'
- en: where *k* is a positive constant that determines the rate of cooling. This differential
    equation can be solved *analytically* by first "separating the variables" and
    then integrating and rearranging. After performing this procedure, we obtain the
    general solution
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 常数*k*是一个确定冷却速率的正常数。这个微分方程可以通过首先“分离变量”，然后积分和重新排列来解析地解决。执行完这个过程后，我们得到了一般解
- en: '![](assets/ddae7c6c-e2c7-43aa-b764-484f7b27b095.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ddae7c6c-e2c7-43aa-b764-484f7b27b095.png)'
- en: where *T[0]* is the initial temperature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*T[0]*是初始温度。
- en: In this recipe, we will solve a simple ordinary differential equation numerically
    using the `solve_ivp` routine from SciPy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用SciPy的`solve_ivp`例程数值地解决一个简单的常微分方程。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will demonstrate the technique for solving a differential equation numerically
    in Python using the cooling equation described previously since we can compute
    the true solution in this case. We take the initial temperature to be *T[0]= 50*
    and *k = 0.2*. Let's also find the solution for *t* values between 0 and 5.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示在Python中使用先前描述的冷却方程数值地解决微分方程的技术，因为在这种情况下我们可以计算真实解。我们将初始温度取为*T[0]= 50*和*k
    = 0.2*。让我们也找出*t*值在0到5之间的解。
- en: A general (first order) differential equation has the form
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一般（一阶）微分方程的形式为
- en: '![](assets/4df58dda-2ef5-4b6e-a9c6-b14742a31fcb.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4df58dda-2ef5-4b6e-a9c6-b14742a31fcb.png)'
- en: where *f* is some function of *t* (the independent variable) and *y* (the dependent
    variable). In this formula, *T* is the dependent variable and *f(t, T) = -kt*.
    The routines for solving differential equations in the SciPy package require the
    function *f* and an initial value *y[0]*[and the range of *t* values where we
    need to compute the solution. To get started, we need to define our function *f*
    in Python and create the variables *y[0]*[and *t* range ready to be supplied to
    the SciPy routine:]]
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*f*是*t*（自变量）和*y*（因变量）的某个函数。在这个公式中，*T*是因变量，*f(t, T) = -kt*。SciPy包中用于解决微分方程的例程需要函数*f*和初始值*y[0]*[以及我们需要计算解的*t*值范围。要开始，我们需要在Python中定义我们的函数*f*并创建变量*y[0]*[和*t*范围，准备提供给SciPy例程：]]
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to define the initial condition from which the solution should
    be found. For technical reasons, the initial *y* values must be specified as a
    one-dimensional NumPy array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义应从中找到解的初始条件。出于技术原因，初始*y*值必须指定为一维NumPy数组：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since, in this case, we already know the true solution, we can also define
    this in Python ready to compare to the numerical solution that we will compute:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下，我们已经知道真实解，我们也可以在Python中定义这个解，以便与我们将计算的数值解进行比较：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to solve a differential equation numerically and plot the
    solution along with the error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤数值求解微分方程并绘制解以及误差：
- en: 'We use the`solve_ivp` routine from the `integrate` module in SciPy to solve
    the differential equation numerically. We add a parameter for the maximum step
    size, with a value of `0.1`, so the solution is computed at a reasonable number
    of points:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用SciPy中的`integrate`模块中的`solve_ivp`例程来数值求解微分方程。我们添加了一个最大步长的参数，值为`0.1`，这样解就可以在合理数量的点上计算出来：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we extract the solution values from the `sol`object returned from the
    `solve_ivp`method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从`solve_ivp`方法返回的`sol`对象中提取解的值：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we plot the solution on a set of axes as follows. Since we are also going
    to plot the approximation error on the same figure, we create two subplots using
    the `subplots` routine:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按如下方式在一组坐标轴上绘制解。由于我们还将在同一图中绘制近似误差，我们使用`subplots`例程创建两个子图：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This plots the solution on a set of axes displayed in the left-hand side of
    *Figure 3.1*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*图3.1*的左侧显示了解决方案的图。
- en: 'To do this, we need to compute the true solution at the points that we obtained
    from the `solve_ivp` routine, and then calculate the absolute value of the difference
    between the true and approximated solutions:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们需要计算从`solve_ivp`例程中获得的点处的真实解，然后计算真实解和近似解之间的差的绝对值：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, on the right-hand side of *Figure 3.1*, we plot the error in the approximation
    with a logarithmic scale on the *y* axis. We can then plot this on the right-hand
    side with a logarithmic scale *y* axis using the `semilogy` plot command as we
    saw in [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml), *Mathematical
    Plotting with Matplotlib*:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在*图3.1*的右侧，我们使用*y*轴上的对数刻度绘制近似误差。然后，我们可以使用`semilogy`绘图命令在右侧使用对数刻度*y*轴，就像我们在[第2章](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml)中看到的那样，*使用Matplotlib进行数学绘图*：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The left-hand plot in *Figure 3.1* shows decreasing temperature over time,
    while the right-hand plot shows that the error increases as we move away from
    the known value given by the initial condition:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*中的左侧图显示随时间降低的温度，而右侧图显示随着我们远离初始条件给出的已知值，误差增加：'
- en: '![](assets/4c0a6446-02e4-49ec-9940-00d778538fbe.png)Figure 3.1: Plot of the
    numerical solution to the cooling equation obtained using the solve_ivp routine
    with default settings'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4c0a6446-02e4-49ec-9940-00d778538fbe.png)图3.1：使用默认设置使用solve_ivp例程获得冷却方程的数值解的绘图'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most methods for solving differential equations are "time-stepping" methods.
    The pairs (*t[i], y[i]*) are generated by taking small *t* steps and approximating
    the value of the function *y.* This is perhaps best illustrated by Euler's method,
    which is the most basic time-stepping method. Fixing a small step size *h > 0*,
    we form the approximation at the *i*th step using the formula
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解决微分方程的大多数方法都是“时间步进”方法。(*t[i], y[i]*)对是通过采取小的*t*步骤并逼近函数*y*的值来生成的。这可能最好地通过欧拉方法来说明，这是最基本的时间步进方法。固定一个小的步长*h
    > 0*，我们使用以下公式在第*i*步形成近似值
- en: '![](assets/62d74fc6-de22-40c3-a06b-eca3c00eaf85.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62d74fc6-de22-40c3-a06b-eca3c00eaf85.png)'
- en: 'starting from the known initial value *y[0].* We can easily write a Python
    routine that performs Euler''s method as follows (there are, of course, many different
    ways to implement Euler''s method; this is a very simple example):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从已知的初始值*y[0]*开始。我们可以轻松地编写一个执行欧拉方法的Python例程如下（当然，实现欧拉方法有许多不同的方法；这是一个非常简单的例子）：
- en: 'First, we set up the method by creating lists that will store the *t* values
    and *y* values that we will return:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过创建将存储我们将返回的*t*值和*y*值的列表来设置方法：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Euler''s method continues until we hit the end of the *t* range. Here, we use
    a `while` loop to accomplish this. The body of the loop is very simple; we first
    increment a counter `i`, and then append the new *t* and *y* values to their respective
    lists:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欧拉方法一直持续到我们达到*t*范围的末尾。在这里，我们使用`while`循环来实现这一点。循环的主体非常简单；我们首先递增计数器`i`，然后将新的*t*和*y*值附加到它们各自的列表中。
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The method used by the `solve_ivp` routine, by default, is the Runge-Kutta-Fehlberg
    method (RK45), which has the ability to adapt the step size to ensure that the
    error in the approximation stays within a given tolerance. This routine expects
    three positional arguments: the function *f,* the *t* range on which the solution
    should be found, and the initial *y* value (*T[0]*in our example). Optional arguments
    can be provided to change the solver, the number of points to compute, and several
    other settings.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The function passed to the `solve_ivp` routine must have two arguments as in
    the general differential equation described in *Getting ready* section. The function
    can have additional arguments, which can be provided using the `args` keyword
    for the `solve_ivp` routine, but these must be positioned after the two necessary
    arguments. Comparing the `euler` routine we defined earlier to the `solve_ivp`
    routine, both with a step size of 0.1, we find that the maximum true error between
    the `solve_ivp` solution is in the order of 10^(-6), whereas the `euler` solution
    only manages an error of 31\. The `euler` routine is working, but the step size
    is much too large to overcome the accumulating error.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The `solve_ivp` routine returns a solution object that stores information about
    the solution that has been computed. Most important here are the `t` and `y` attributes,
    which contain the *t* values on which the solution *y* is computed and the solution
    *y* itself. We used these values to plot the solution we computed. The *y*values
    are stored in a NumPy array of shape `(n, N)`, where `n`is the number of components
    of the equation (here, 1), and `N`is the number of points computed. The *y*values
    held in `sol`are stored in a two-dimensional array, which in this case has 1 row
    and many columns. We use the slice `y[0, :]`to extract this first row as a one-dimensional
    array that can be used to plot the solution in *step 4*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We use a logarithmically scaled *y* axis to plot the error because what is interesting
    there is the order of magnitude. Plotting it on a non-scaled *y* axis would give
    a line that is very close to the *x* axis, which doesn't show the increase in
    the error as we move through the *t* values. The logarithmically scaled *y* axis
    shows this increase clearly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `solve_ivp` routine is a convenient interface for a number of solvers for
    differential equations, the default being the Runge-Kutta-Fehlberg (RK45) method.
    The different solvers have different strengths, but the RK45 method is a good
    general-purpose solver.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more detailed instructions on how to add subplots to a figure in Matplotlib,
    see the*Adding subplots* recipe from [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml),
    *Mathematical Plotting with Matplotlib*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Solving systems of differential equations
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Differential equations sometimes occur in systems consisting of two or more
    interlinked differential equations. A classical example is a simple model of the
    populations of competing species. This is a simple model of competing species
    labeled *P* (the prey)*and *W* (the predators) given by the following equations:*
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '*![](assets/e6e64a45-d031-4ff3-9d17-bac1ea19c5ec.png)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The first equation dictates the growth of the prey species *P*, which, without
    any predators, would be exponential growth. The second equation dictates the growth
    of the predator species *W*, which, without any prey, would be exponential decay.
    Of course, these two equations are *coupled*; each population change depends on
    both populations. The predators consume the prey at a rate proportional to the
    product of their two populations, and the predators grow at a rate proportional
    to the relative abundance of prey (again the product of the two populations).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will will analyze a simple system of differential equations
    and use the SciPy `integrate` module to obtain approximate solutions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tools for solving a system of differential equations using Python are the
    same as those for solving a single equation. We again use the `solve_ivp` routine
    from the `integrate` module in SciPy. However, this will only give us a predicted
    evolution over time with given starting populations. For this reason, we will
    also employ some plotting tools from Matplotlib to better understand the evolution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps walk through how to analyze a simple system of differential
    equations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to define a function that holds the system of equations.
    This function needs to take two arguments as for a single equation, except the
    dependent variable *y* (in the notation from the *Solving simple differential
    equations numerically* recipe) will now be an array with as many elements as there
    are equations. Here, there will be two elements. The function we need for the
    example system in this recipe is as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have defined the system in Python, we can use the `quiver` routine from
    Matplotlib to produce a plot that will describe how the populations will evolve—given
    by the equations—at numerous starting populations. We first set up a grid of points
    on which we will plot this evolution. It is a good idea to choose a relatively
    small number of points for the `quiver` routine, otherwise it becomes difficult
    to see details in the plot. For this example, we plot the population values between
    0 and 100:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we compute the values of the system at each of these pairs. Notice that
    neither equation in the system is time-dependent (they are autonomous); the time
    variable *t* is unimportant in the calculation. We supply the value `0` for the
    *t* argument:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The variables `dp` and `dw` now hold the "direction" in which the population
    of *P* and *W* will evolve, respectively, if we started at each point in our grid.
    We can plot these directions together using the `quiver` routine from `matplotlib.pyplot`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Plotting the result of these commands now gives us *Figure 3.2*, which gives
    a "global" picture of how solutions evolve:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e756b45-1557-4de1-99a4-980dfa5dbb69.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: A quiver plot showing the population dynamics of two competing
    species modeled by a system of differential equations'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: To understand a solution more specifically, we need some initial conditions
    so we can use the `solve_ivp` routine described in the previous recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two equations, our initial conditions will have two values. (Recall
    in the *Solving simple differential equations numerically* recipe, we saw that
    the initial condition provided to `solve_ivp` needs to be a NumPy array.) Let''s
    consider the the initial values *P(0) = 85* and *W(0) = 40*. We define these in
    a NumPy array, being careful to place them in the correct order:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use `solve_ivp` from the `scipy.integrate` module. We need to provide
    the `max_step` keyword argument to make sure that we have enough points in the
    solution to give a smooth solution curve:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s plot this solution on our existing figure to show how this specific
    solution relates to the direction plot we have already produced. We also plot
    the initial condition at the same time:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result of this is shown in *Figure 3.3*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23767cc7-85e5-4168-93d3-7ab550febf33.png)Figure 3.3: Solution trajectory
    plotted over a quiver plot showing the general behavior'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method used for a system of ordinary differential equations is exactly the
    same as for a single ordinary differential equation. We start by writing the system
    of equations as a single vector differential equation,
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/949a688b-96e9-4194-80e5-6c1537087601.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: that can then be solved using a time-stepping method as though **y** were a
    simple scalar value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The technique of plotting the directional arrows on a plane using the `quiver`
    routine is a quick and easy way of learning how a system might evolve from a given
    state. The derivative of a function represents the gradient of the curve (*x*,
    *u*(*x*)), and so a differential equation describes the gradient of the solution
    function at position *y* and time *t*. A system of equations describes the gradient
    of separate solution functions at a given position **y** and time *t.* Of course,
    the position is now a two-dimensional point, so when we plot the gradient at a
    point, we represent this as an arrow that starts at the point, in the direction
    of the gradient. The length of the arrow represents the size of the gradient;
    the longer the arrow, the "faster" the solution curve will move in that direction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'When we plot the solution trajectory on top of this direction field, we can
    see that the curve (starting at the point) follows the direction indicated by
    the arrows. The behavior shown by the solution trajectory is a *limit cycle*,
    where the solution for each variable is periodic as the two species populations
    grow or decline. This description of the behavior is perhaps more clear if we
    plot each population against time, as seen in *Figure 3.4*. What is not immediately
    obvious from *Figure 3.3* is that the solution trajectory loops around several
    times, but this is clearly shown in *Figure 3.4*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2de769a-db1c-4ac4-b755-a8f69457b59d.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Plots of populations *P* and *W* against time. Both populations
    exhibit periodic behavior'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique of analyzing a system of ordinary differential equations by plotting
    the variables against one another, starting at various initial conditions, is
    called *phase space (plane) analysis.* In this recipe, we used the `quiver` plotting
    routine to quickly generate an approximation of the phase plane for the system
    of differential equations. By analyzing the phase plane of a system of differential
    equations, we can identify different local and global characteristics of the solution,
    such as limit cycles.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Solving partial differential equations numerically
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial differential equations are differential equations that involve *partial
    derivatives* of functions in two or more variables, as opposed to *ordinary derivatives*
    in only a single variable. Partial differential equations is a vast topic, and
    could easily fill a series of books. A typical example of a partial differential
    equation is the (one-dimensional) *heat equation*
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6184866a-5a48-48db-9c1f-a991e60c83b6.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: where α is a positive constant and *f*(*t*, *x*) is a function. The solution
    to this partial differential equation is a function *u*(*t*, *x*), which represents
    the temperature of a rod, occupying the *x* range 0 ≤ *x ≤* *L*, at a given time
    *t* > 0\. To keep things simple, we will take *f*(*t*, *x*) = 0, which amounts
    to saying that no heating/cooling is applied to the system, α = 1, and *L = 2*.
    In practice, we can rescale the problem to fix the constant α, so this is not
    a restrictive problem. In this example, we will use the boundary conditions
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/245337ee-7e9f-441a-8425-7bbebaec6f5d.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: which are equivalent to saying that the ends of the rod are held at the constant
    temperature 0\. We will also use the initial temperature profile
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9723b438-e560-4a28-a6de-ca9930ec343a.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: This initial temperature profile describes a smooth curve between the values
    of 0 and 2, that peaks at a value of 3, which might be the result of heating the
    rod at the center to a temperature of 3.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use a method called *finite differences*, where we divide the
    rod into a number of equal segments and the time range into a number of discrete
    steps. We then compute approximations for the solution at each of the segments
    and each time step.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use finite differences to solve a simple partial differential
    equation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy package and Matplotlib package, imported
    as `np` and `plt` as usual. We also need to import the `mplot3d` module from `mpl_toolkits`
    since we will be producing a 3D plot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will also need some modules from the SciPy package.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we work through solving the heat equation using finite
    differences:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create variables that represent the physical constraints of the
    system: the extent of the bar and the value of α:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We first divide the *x*range into *N* equal*intervals—we take *N = 10*for this
    example—using *N+1*points. We can use the `linspace`routine from NumPy to generate
    these points. We also need the common length of each interval *h:**
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the steps in the time direction. We take a slightly
    different approach here; we set the time step size *k* and the number of steps
    (implicitly making the assumption that we start at time 0):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In order for the method to behave properly, we must have
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bda8c9e8-45ba-4021-99ba-9cfaa5b43f1a.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: 'otherwise the system can become unstable. We store the left-hand side of this
    in a variable for use in *Step 4*, and use an assertion to check that this inequality
    holds:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can construct a matrix that holds the coefficients from the finite difference
    scheme. To do this, we use the `diags`routine from the `scipy.sparse`module to
    create a sparse, tridiagonal matrix:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we create a blank matrix that will hold the solution:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need to add the initial profile to the first row. The best way to do this
    is to create a function that holds the initial profile and store the result of
    evaluating this function on the `x` array in the matrix `u` that we just created:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can simply loop through each step, computing the next row of the matrix
    `u` by multiplying `A` and the previous row:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, to visualize the solution we have just computed, we can plot the solution
    as a surface using Matplotlib:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result of this is the surface plot shown in *Figure 3.5*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7aca3573-b5b9-40e9-a959-4908ff776868.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Surface plot of the solution of the heat equation over the range
    0 ≤ *x* ≤ 2 computed using the finite difference method with 10 mesh points'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The finite difference method works by replacing each of the derivatives with
    a simple fraction that involves only the value of the function, which we can estimate.
    To implement this method, we first break down the spatial range and time range
    into a number of discrete intervals, separated by mesh points. This process is
    called *discretization*. Then we use the differential equation and the initial
    conditions and boundary conditions to form successive approximations, in a manner
    very similar to the time-stepping methods used by the `solve_ivp` routine in the
    *Solving differential equations numerically* recipe.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve a partial differential equation such as the heat equation,
    we need at least three pieces of information. Usually, for the heat equation,
    this will come in the form of*boundary conditions* for the spatial dimension,
    which tell us what the behavior is at either end of the rod, and *initial conditions*for
    the time dimension, which is the initial temperature profile over the rod.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The finite difference scheme described previously is usually referred to as
    the **forward time central spatial** (**FTCS**) scheme, since we use the *forward
    finite difference* to estimate the time derivative and the *central finite difference*
    to estimate the (second order) spatial derivative. The formulas for these finite
    differences are given by
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d60f63d-ee29-4640-ab39-515bf356bad2.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: and
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea3d52cb-c07d-4a36-a313-713d29ff4f74.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Substituting these approximations into the heat equation, and using the approximation
    *u*[*i*]^(*j*)for the value of *u*(*t[j]*, x[i]) after *j*time steps at the *i*spatial
    point, we get
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3c59b14-5e8f-4dcb-9122-65f09009fd65.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: which can be rearranged to obtain the formula
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/58222441-072c-406c-a4c3-07fe3033a114.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Roughly speaking, this equation says that the next temperature at a given point
    depends on the surrounding temperatures at the previous time. This also shows
    why the condition on the `r` value is necessary; if the condition does not hold,
    the middle term on the right-hand side will be negative.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We can write this system of equations in matrix form,
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37370a20-7786-4985-9625-53e11fbdbe08.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: where **u***^j* is a vector containing the approximation *u[i]^j*and matrix
    *A*, which was defined in *step 4*. This matrix is tridiagonal, which means the
    non-zero entries appear on, or adjacent to, the leading diagonal. We use the `diag`
    routine from the SciPy `sparse` module, which is a utility for defining these
    kinds of matrices. This is very similar to the process described in the *Solving
    equations* recipe of this chapter. The first and last row of this matrix have
    zeros, except in the topleft and bottom right, respectively, that represent the
    (non-changing) boundary conditions. The other rows have coefficients that are
    given by the finite difference approximations for the derivatives on either side
    of differential equation. We first create the diagonal entries and the entries
    above and below the diagonal, and then we use the `diags` routine to create the
    sparse matrix. The matrix should have *N+1* rows and columns, to match the number
    of mesh points, and we set the data type as double-precision floats and CSR format.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The initial profile gives us the vector **u**⁰, and from this first point, we
    can compute each subsequent time step by simply performing a matrix multiplication,
    as we saw in *step 7*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method we describe here is rather crude since the approximation can become
    unstable, as we mentioned, if the relative sizes of time steps and spatial steps
    are not carefully controlled. This method is *explicit* since each time step is
    computed explicitly using only information from the previous time step. There
    are also *implicit* methods, which give a system of equations that can be solved
    to obtain the next time step. Different schemes have different characteristics
    in terms of the stability of the solution.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: When the function *f*(*t*, *x*) is not 0, we can easily accommodate this change
    by instead using the assignment
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34ccf6b9-a549-469c-a194-2d67678204d2.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'where the function is suitably vectorized to make this formula valid. In terms
    of the code used to solve the problem, we need only include the definition of
    the function and then change the loop of the solution as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Physically, this function represents an external heat source (or sink) at each
    point along the rod. This may change over time, which is why, in general, the
    function should have both *t* and *x* as arguments (though they need not both
    be used).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The boundary conditions we gave in this example represent the ends of the rod
    being kept at a constant temperature of 0\. These kinds of boundary conditions
    are sometimes called *Dirichlet* boundary conditions. There are also *Neumann*
    boundary conditions, where the derivative of the function *u* is given at the
    boundary. For example, we might have been given the boundary conditions
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20efdf73-2579-492b-ad91-657fd131d376.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: which could be interpreted physically as the ends of the rod being insulated
    so that heat cannot escape through the end points. For such boundary conditions
    we need to modify the matrix *A* slightly, but otherwise the method remains the
    same. Indeed, inserting an imaginary *x* value to the left of the boundary and
    using the backward finite difference at the left-hand boundary (*x = 0*), we obtain
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3df7eb78-60b0-45a4-8ac8-a3d354f85c02.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Using this in the second order finite difference approximation, we get
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8b3a28a-812c-4e04-bfc3-e40be3cb4481.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: which means that the first row of our matrix should contain *1-r*,*then *r*,
    followed by 0\. Using a similar computation for the right-hand limit gives a similar
    final row of the matrix:*
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: For more complex problems involving partial differential equations, it is probably
    more appropriate to use a *finite elements* solver. Finite element methods use
    a more sophisticated approach for computing solutions than partial differential
    equations, which are generally more flexible than the finite difference method
    we saw in this recipe. However, this comes at the cost of requiring more setup
    that relies on more advanced mathematical theory. On the other hand, there is
    a Python package for solving partial differential equations using finite element
    methods such as FEniCS ([fenicsproject.org](https://fenicsproject.org)). The advantage
    of using a package such as FEniCS is that they are usually tuned for performance,
    which is important when solving with complex problems to high accuracy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FEniCS documentation gives a good introduction to the finite element method
    and a number of examples of using the package to solve various classic partial
    differential equations. A more comprehensive introduction to the method and the
    theory is given in the following book:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '*Johnson, C. (2009).Numerical solution of partial differential equations by
    the finite element method. Mineola, N.Y.: Dover Publications.*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on how to produce three-dimensional surface plots using Matplotlib,
    see the *Surface and contour plots* recipe from [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml),
    *Mathematical Plotting with Matplotlib*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Using discrete Fourier transforms for signal processing
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful tools coming from calculus is the *Fourier transfor**m*.
    Roughly speaking, the Fourier transform changes the representation, in a reversible
    way, of certain functions. This change of representation is particularly useful
    in dealing with signals represented as a function of time. In this instance, the
    Fourier transform takes the signal and represents it as a function of frequency;
    we might describe this as transforming from signal space to frequency space. This
    can be used to identify the frequencies present in a signal for identification
    and other processing. In practice, we will usually have a discrete sample of a
    signal, so we have to use the *discrete Fourier transform* to perform this kind
    of analysis. Fortunately, there is a computationally efficient algorithm, called
    the **fast Fourier transform***(**FFT**), for applying the discrete Fourier transform
    to a sample.*
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '*We will follow a common process for filtering a noisy signal using FFT. The
    first step is to apply the FFT and use the data to compute the power spectral
    density of the signal. Then we identify the peaks and filter out the frequencies
    that do no contribute a sufficiently large amount to the signal. Then we apply
    the inverse FFT to obtain the filtered signal.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use the FFT to analyze a sample of a signal and identify
    the frequencies present and clean the noise from the signal.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will only need the NumPy and Matplotlib packages imported
    as `np` and `plt`, as usual.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to use the FFT to process a noisy signal:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a function that will generate our underlying signal:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we create our sample signal by adding some Gaussian noise to the underlying
    signal. We also create an array that holds the true signal at the sample *t* values
    for convenience later:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We use the `fft`module from NumPy to compute discrete Fourier transforms. We
    import this from NumPy before we start our analysis:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To see what the noisy signal looks like, we can plot the sample signal points
    with the true signal superimposed:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The plot created here is shown in *Figure 3.6*. As we can see, the noisy signal
    does not bear much resemblance to the true signal (shown with the dashed line):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d0bf476c-f0fd-4b59-b167-0db423f6cc22.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Noisy signal sample with true signal superimposed'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the discrete Fourier transform to extract the frequencies
    that are present in the sample signal. The `fft` routine in the `fft` module performs
    the FFT (discrete Fourier transform):'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `fft` module provides a routine for constructing the appropriate frequency
    values called `fftfreq`. For convenience, we also generate an array containing
    the integers at which the positive frequencies occur:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, compute the **power spectral density** (**PSD**) of the signal as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can plot the PSD of the signal for the positive frequencies and use
    this plot to identify the frequencies:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The result can be seen in *Figure 3.7*. We can see in this diagram that there
    are spikes at roughly 4 and 7, which are the frequencies of the signal that we
    defined earlier:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dbf2eebf-e200-4bc8-8319-4a6d67561fc7.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Power spectral density of a signal generated using the FFT'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify these two frequencies to try and reconstruct the true signal
    from the noisy sample. All of the minor peaks that appear are not larger than
    10,000, so we can use this as a cut-off value for the filter. Let''s now extract
    from the list of all positive frequency indices the (hopefully 2) indices that
    correspond to the peaks above 10,000 in the PSD:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we create a new, clean spectrum that contains only the frequencies that
    we have extracted from the noisy signal. We do this by creating an array that
    contains only 0, and then copying the value of `spectrum` from those indices that
    correspond to the filtered frequencies and the negatives thereof:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we use the inverse FFT (using the `ifft` routine) to transform this clean
    spectrum back to the time domain of the original sample. We take the real part
    using the `real` routine from NumPy to eliminate the erroneous imaginary parts:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we plot this filtered signal over the true signal and compare the
    results:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result of *step 12* is shown in *Figure 3.8*. We can see that the filtered
    signal closely matches the true signal, except for some small discrepancies:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c00691ae-14b1-4470-bda0-b8b048536c69.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Plot comparing the filtered signal generated using FFTs and filtering
    to the true signal'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Fourier transform* of a function *f*(*t*) is given by the integral
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4eb1fffb-6aa9-4f17-875a-51c90d9c3040.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: and the discrete Fourier transform is given by
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87485bb8-515f-4654-9621-e8930510e1c5.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: Here, the *f[k]*values are the sample values as complex numbers. The discrete
    Fourier transform can be computed using the preceding formula, but in practice
    this is not efficient. Computing using this formula is *O*(*N*²). The FFT algorithm
    improves the complexity to *O*(*N* log *N*), which is significantly better. The
    book *Numerical Recipes* (full bibliographic details given in the *Further reading*
    section) gives a very good description of the FFT algorithm and the discrete Fourier
    transform.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We will apply the discrete Fourier transform to a sample generated from a known
    signal (with known frequency modes) so we can see the connection between the results
    we obtain and the original signal. To keep this signal simple, we created a signal
    that has only two frequency components with values 4 and 7\. From this signal,
    we generated the sample that we analyzed. Because of the way the FFT works, it
    is best if the sample has a size that is a power of 2; if this isn't the case,
    we can pad the sample with zero elements to make this the case. We add some Gaussian
    noise to the sample signal, which takes the form of a normally distributed random
    number.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The array returned by the `fft` routine contains *N+1*elements, where *N*is
    the sample size. The element that index 0 corresponds to is the 0 frequency, or
    DC shift. The next *N/2* elements are the values corresponding to the positive
    frequencies, and the final *N/2*elements are the values corresponding to the negative
    frequencies. The actual values of the frequencies are determined by the number
    of sampled points *N*and the sample spacing, which, in this example, is stored
    in `sample_d`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The power spectral density at the frequency *ω* is given by the formula
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c55d8f3-b759-4931-a310-85478b2e65c6.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: where *H*(*ω*) represents the Fourier transformof the signal at frequency *ω*.
    The power spectral density measures the contribution of each frequency to the
    overall signal, which is why we see peaks at approximately 4 and 7\. Since Python
    indexing allows us to use negative indices for elements starting from the end
    of the sequence, we can use the positive index array to get both the positive
    and negative frequency elements from `spectrum`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9,* we extracted the indices of the two frequencies that peak above
    10,000 on the plot. The frequencies that correspond to these indices are 3.984375
    and 6.97265625, which are not exactly equal to 4 and 7, but are very close. The
    reason for this discrepancy is the fact that we have sampled a continuous signal
    using a finite number of points. (Using more points will, of course, yield better
    approximations.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11*, we took the real part of the data returned from the inverse FFT.
    This is because, technically speaking, the FFT works with complex data. Since
    our data contained only real data, we expect that this new signal should also
    contain only real data. However, there will be some small errors made, meaning
    that the results are not totally real. We can remedy this by taking the real part
    of the inverse FFT. This is appropriate because we can see that the imaginary
    parts are very small.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure 3.8* that the filtered signal very closely matches the
    true signal, but not exactly. This is because, as mentioned previously, we are
    approximating a continuous signal with a relatively small sample.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signal processing in a production setting would probably make use of a specialized
    package, such as the `signal` module from `scipy`, or some lower-level code or
    hardware to perform filtering or cleaning of a signal. This recipe should be taken
    as more of a demonstration of the use of FFT as a tool for working with data sampled
    from some kind of underlying periodic structure (the signal). FFTs are useful
    for solving partial differential equations, such as the heat equation seen in
    the *Solving partial differential equations numerically* recipe.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about random numbers and the normal distribution (Gaussian)
    can be found in [Chapter 4](5da67d86-40e0-4cc5-9dd1-26b6d52369af.xhtml), *Working
    with Randomness and Probability*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calculus is a very important part of every undergraduate mathematics course.
    There are a number of excellent textbooks on calculus, including the classic textbook
    by Spivak and the more comprehensive course by Adams and Essex:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '*Spivak, M. (2006). Calculus. 3rd ed. Cambridge: Cambridge University Press*'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adams, R. and Essex, C. (2018). Calculus: A Complete Course. 9th ed. Don Mills,
    Ont: Pearson.Guassian*'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good source for numerical differentiation and integration is the classic
    *Numerical Recipes* book, which gives a comprehensive description of how to solve
    many computational problems in C++, including a summary of the theory:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '*Press, W., Teukolsky, S., Vetterling, W. and Flannery, B. (2007). Numerical
    recipes:* *The Art of Scientific Computing. 3rd ed. Cambridge: Cambridge University
    Press*****'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
