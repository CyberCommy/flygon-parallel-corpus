- en: Chapter 7. Customizing Concurrency Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the `ThreadPoolExecutor` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a priority-based `Executor` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `ThreadFactory` interface to generate custom threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using our `ThreadFactory` in an `Executor` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in a scheduled thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `ThreadFactory` interface to generate custom threads for the
    Fork/Join framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the Fork/Join framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom `Lock` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer queue based on priorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java concurrency API provides a lot of interfaces and classes to implement concurrent
    applications. They provide low-level mechanisms, such as the `Thread` class, the
    `Runnable` or `Callable` interfaces, or the `synchronized` keyword, and also high-level
    mechanisms, such as the Executor framework and the Fork/Join framework added in
    the Java 7 release. Despite this, you may find yourself developing a program where
    none of the java classes meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you may need to implement your own custom-concurrent utilities
    based on the ones provided by Java. Basically, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an interface to provide the functionality defined by that interface.
    For example, the `ThreadFactory` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override some methods of a class to adapt its behavior to your needs. For example,
    overriding the `run()` method of the `Thread` class which, by default, does nothing
    useful and is supposed to be overridden to offer some functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the recipes of this chapter, you will learn how to change the behavior
    of some Java concurrency API classes without the need to design a concurrency
    framework from scratch. You can use these recipes as an initial point to implement
    your own customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ThreadPoolExecutor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Executor framework is a mechanism that allows you to separate the thread
    creation from its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces with the `ThreadPoolExecutor` class that implements both interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks for their execution in the pooled threads. These tasks are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Runnable` interface to implement tasks that don't return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Callable` interface to implement tasks that return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, you only send the task to the executor. The executor uses one
    of its pooled threads or creates a new one to execute those tasks. The executor
    also decides the moment in which the task is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to override some methods of the `ThreadPoolExecutor`
    class to calculate the execution time of the tasks that you execute in the executor
    and to write in the console statistics about the executor when it completes its
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps described below to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyExecutor` that extends the `ThreadPoolExecutor` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ConcurrentHashMap` attribute parameterized with the `String`
    and `Date` classes named `startTimes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor for the class. Call a constructor of the parent class
    using the `super` keyword and initialize the `startTime` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Override the `shutdown()` method. Write in the console information about the
    executed tasks, the running tasks, and the pending tasks. Then, call the `shutdown()`
    method of the parent class using the `super` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Override the `shutdownNow()` method. Write in the console information about
    the executed tasks, the running tasks, and the pending tasks. Then, call the `shutdownNow()`
    method of the parent class using the `super` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Override the `beforeExecute()` method. Write a message in the console with the
    name of the thread that is going to execute the task and the hash code of the
    task. Store the start date in `HashMap` using the hash code of the task as the
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Override the `afterExecute()` method. Write a message in the console with the
    result of the task and calculate the running time of the task subtracting the
    start date of the task stored in `HashMap` of the current date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `SleepTwoSecondsTask`that implements the `Callable` interface
    parameterized with the `String` class. Implement the `call()` method. Put the
    current thread to sleep for 2 seconds and return the current date converted to
    a `String` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyExecutor` object named `myExecutor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a list of `Future` objects parameterized with the `String` class to store
    the resultant objects of the tasks you're going to send to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Submit 10 `Task` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Get the result of the execution of the first five tasks using the `get()` method.
    Write them in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finish the execution of the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Get the result of the execution of the last five tasks using the `get()` method.
    Write them in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the completion of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Write a message indicating the end of the execution of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have implemented our custom executor extending the `ThreadPoolExecutor`
    class and overriding four of its methods. The `beforeExecute()` and `afterExecute()`
    methods were used to calculate the execution time of a task. The `beforeExecute()`
    method is executed before the execution of a task. In this case, we have used
    `HashMap` to store in it the start date of the task. The `afterExecute()` method
    is executed after the execution of a task. You get `startTime` of the task that
    has finished from `HashMap` and then, calculate the difference between the actual
    date and that date to get the execution time of the task. You have also overridden
    the `shutdown()` and `shutdownNow()` methods to write statistics about the tasks
    executed in the executor to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: The executed tasks, using the `getCompletedTaskCount()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tasks that are running at this time, using the `getActiveCount()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pending tasks, using the `size()` method of the blocking queue where the
    executor stores the pending tasks. The `SleepTwoSecondsTask` class that implements
    the `Callable` interface puts its execution thread to sleep for 2 seconds and
    the `Main` class, where you send 10 tasks to your executor that uses it and the
    other classes to demo their features.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the program and you will see how the program shows the time span of
    each task that is running and the statistics of the executor upon calling the
    `shutdown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using our ThreadFactory in an Executor* object recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a priority-based Executor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first versions of the Java concurrency API, you had to create and run
    all the threads of your application. In Java Version 5, with the appearance of
    the Executor framework, a new mechanism was introduced for the execution of concurrency
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With the Executor framework, you only have to implement your tasks and send
    them to the executor. The executor is responsible for the creation and execution
    of the threads that execute your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, an executor uses a blocking queue to store pending tasks. These
    are stored in the order of their arrival to the executor. One possible alternative
    is the use of a priority queue to store new tasks. In this way, if a new task
    with high priority arrives to the executor, it will be executed before other threads
    that have already been waiting for a thread to execute, but have lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement an executor that will use a
    priority queue to store the tasks you send for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyPriorityTask` that implements the `Runnable` and `Comparable`
    interfaces parameterized with the `MyPriorityTask` class interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `priority`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to return the value of the priority attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compareTo()` method declared in the `Comparable` interface. It
    receives a `MyPriorityTask` object as a parameter and compares the priorities
    of the two objects, the current one and the parameter. You let the tasks with
    higher priority execute before the tasks with lower priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Put the current thread to sleep for 2 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ThreadPoolExecutor` object named `executor`. Use `PriorityBlockingQueue`
    parameterized with the `Runnable` interface as the queue that this executor will
    use to store its pending tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Send four tasks to the executor using the counter of the loop as priority of
    the tasks. Use the `execute()` method to send the tasks to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Put the current thread to sleep for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Send four additional tasks to the executor using the counter of the loop as
    priority of the tasks. Use the `execute()` method to send the tasks to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console indicating the finalization of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To convert an executor to a priority-based one is simple. You only have to pass
    a `PriorityBlockingQueue` object parameterized with the `Runnable` interface as
    a parameter. But with the executor, you should know that all the objects stored
    in a priority queue have to implement the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the `MyPriorityTask` class that implements the `Runnable`
    interface, to be a task, and the `Comparable` interface, to be stored in the priority
    queue. This class has a `Priority` attribute that is used to store the priority
    of the tasks. If a task has a higher value for this attribute, it will be executed
    earlier. The `compareTo()` method determines the order of the tasks in the priority
    queue. In the `Main` class, you sent eight tasks to the executor with different
    priorities. The first tasks you sent to the executor are the first tasks that
    are executed. As the executor is idle waiting for tasks to be executed, and as
    the first tasks arrive to the executor, it executes them immediately. You have
    created the executor with two execution threads, so the first two tasks will be
    the first ones that are executed. Then, the rest of the tasks are executed based
    on their priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows one execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can configure `Executor` to use any implementation of the `BlockingQueue`
    interface. One interesting implementation is `DelayQueue`. This class is used
    to store elements with a delayed activation. It provides methods that only return
    the active objects. You can use this class to implement your own version of the
    `ScheduledThreadPoolExecutor` class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Thread Executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing the ThreadPoolExecutor* class recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **factory pattern** is a widely used design pattern in the object-oriented
    programming world. It is a creational pattern and its objective is to develop
    a class whose mission will be creating objects of one or several classes. Then,
    when we want to create an object of one of those classes, we use the factory instead
    of using the new operator.
  prefs: []
  type: TYPE_NORMAL
- en: With this factory, we centralize the creation of objects gaining an advantage
    of easily changing the class of objects created or the way we create these objects
    that are easily limiting the creation of objects for limited resources. For example,
    we can only have *N* objects of a type that is easily generating statistical data
    about the creation of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java provides the `ThreadFactory` interface to implement a `Thread` object factory.
    Some advanced utilities of the Java concurrency API, as the Executor framework
    or the Fork/Join framework, use thread factories to create threads.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of the factory pattern in the Java Concurrency API is the `Executors`
    class. It provides a lot of methods to create different kinds of `Executor` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will extend the `Thread` class by adding new functionalities
    and you will implement a thread factory class to generate threads of that new
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyThread` that extends the `Thread` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Declare three private `Date` attributes named `creationDate`, `startDate`, and
    `finishDate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class. It receives the name and the `Runnable`
    object to execute as parameters. Store the creation date of the thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Store the start date of the thread, call the `run()`
    method of the parent class, and store the finish date of the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to establish the value of the `creationDate` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to establish the value of the `startDate` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to establish the value of the `finishDate` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method named`getExecutionTime()` that calculates the execution time
    of the thread as the difference between the start date and the finish date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Override the `toString()` method to return the creation date and the execution
    time of the thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyThreadFactory` that implements the `ThreadFactory` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `prefix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `newThread()` method. Create a `MyThread` object and increment
    the `counter` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyTask` that implements the `Runnable` interface. Implement
    the `run()` method. Put the current thread to sleep for 2 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyThreadFactory` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Task` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyThread` object to execute the task using the `newThread()` method
    of the factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Start the thread and wait for its finalization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Write information about the thread using the `toString()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented a custom `MyThread` class extending the
    `Thread` class. The class has three attributes to store the creation date, the
    start date of its execution, and the end date of its execution. Using the start
    date and the end date attributes, you have implemented the `getExecutionTime()`
    method that returns the time that the thread has been executing its task. Finally,
    you have overridden the `toString()` method to generate information about a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Once you had your own thread class, you have implemented a factory to create
    objects of that class implementing the `ThreadFactory` interface. It's not mandatory
    to make use of the interface if you're going to use your factory as an independent
    object, but if you want to use this factory with other classes of the Java concurrency
    API, you must construct your factory by implementing that interface. The `ThreadFactory`
    interface only has one method, the `newThread()` method that receives a `Runnable`
    object as a parameter and returns a `Thread` object to execute that `Runnable`
    object. In your case, you return a `MyThread` object.
  prefs: []
  type: TYPE_NORMAL
- en: To check these two classes, you have implemented the `MyTask` class that implements
    the `Runnable` object. This is the task to be executed in threads managed by the
    `MyThread` object. A `MyTask` instance puts its execution thread to sleep for
    2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In the main method of the example, you have created a `MyThread` object using
    a `MyThreadFactory` factory to execute a `Task` object. Execute the program and
    you will see a message with the start date and the execution time of the thread
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output generated by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java Concurrency API provides the `Executors` class to generate thread executors,
    usually objects of the `ThreadPoolExecutor` class. You can also use this class
    to obtain the most basic implementation of the `ThreadFactory` interface using
    the `defaultThreadFactory()` method. The factory generated by this method generates
    basic `Thread` objects belonging to all of them to the same `ThreadGroup` object.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `ThreadFactory` interface in your program for any purposes,
    not necessarily related to the Executor framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using our ThreadFactory in an Executor object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Implementing the ThreadFactory interface to generate
    custom threads*, we introduced the factory pattern and provided an example of
    how to implement a factory of threads implementing the `ThreadFactory` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Executor framework is a mechanism that allows you the separation of the
    thread creation and its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces and in the `ThreadPoolExecutor` class that implements both interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks for their execution in the pooled threads. These two kinds
    of tasks are:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that implement the `Runnable` interface, to implement tasks that don't
    return a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that implement the `Callable` interface, to implement tasks that return
    a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, an Executor framework uses a `ThreadFactory` interface to create
    the threads that it uses to generate the new threads. In this recipe, you will
    learn how to implement your own thread class, a thread factory to create threads
    of that class, and how to use that factory in an executor, so the executor will
    execute your threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the previous recipe, *Implementing a ThreadFactory interface to generate
    custom threads*, and implement its example.
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy into the project the classes `MyThread`, `MyThreadFactory`, and `MyTask`
    implemented in the recipe *Implementing a ThreadFactory interface to generate
    custom threads*, so you are going to use them in this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `MyThreadFactory` object named `threadFactory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Executor` object using the `newCachedThreadPool()` method of the
    `Executors` class. Pass the factory object created earlier as a parameter. The
    new `Executor` object will use that factory to create the necessary threads, so
    it will execute `MyThread` threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Task` object and send it to the executor using the `submit()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to indicate the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *How it works...* section of the previous recipe, *Implementing a ThreadFactory
    interface to generate custom threads*, you can read a detailed explanation of
    how the `MyThread`, `MyThreadFactory`, and `MyTask` classes works.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` method of the example, you have created an `Executor` object
    using the `newCachedThreadPool()` method of the `Executors` class. You have passed
    the factory object created earlier as a parameter, so the `Executor` object created
    will use that factory to create the threads it needs and it will execute threads
    of the `MyThread` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the program and you will see a message with information about the thread''s
    start date and its execution time. The following screenshot shows the output generated
    by this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing a ThreadFactory interface to generate custom threads* recipe
    in [Chapter 7](ch07.html "Chapter 7. Customizing Concurrency Classes"), *Customizing
    Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in a scheduled thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **scheduled thread pool** is an extension of the basic thread pool of the
    Executor framework that allows you to schedule the execution of tasks to be executed
    after a period of time. It''s implemented by the `ScheduledThreadPoolExecutor`
    class and it permits the execution of the following two kinds of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delayed tasks**: These kinds of tasks are executed only once after a period
    of time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Periodic tasks**: These kinds of tasks are executed after a delay and then
    periodically every so often'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayed tasks can execute both, the `Callable` and `Runnable` objects, but the
    periodic tasks can only execute `Runnable` objects. All the tasks executed by
    a scheduled pool are an implementation of the `RunnableScheduledFuture` interface.
    In this recipe, you will learn how to implement your own implementation of the
    `RunnableScheduledFuture` interface to execute delayed and periodic tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps described below to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyScheduledTask` parameterized with a generic type named
    `V`. It extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `RunnableScheduledFuture` attribute named `task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ScheduledThreadPoolExecutor` named `executor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `long` attribute named `period`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `long` attribute named `startDate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class. It receives the `Runnable` object that
    is going to be executed by a task, the result that will be returned by this task,
    the `RunnableScheduledFuture` task that will be used to create the `MyScheduledTask`
    object, and the `ScheduledThreadPoolExecutor` object that is going to execute
    the task. Call the constructor of its parent class and store the task and `executor`
    attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getDelay()` method. If the task is a periodic task and the `startDate`
    attribute has a value different from zero, calculate the returned value as the
    difference between the `startDate` attribute and the actual date. Otherwise, return
    the delay of the original task stored in the `task` attribute. Don't forget that
    you have to return the result in the time unit passed as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compareTo()` method. Call the `compareTo()` method of the original
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `isPeriodic()` method. Call the `isPeriodic()` method of the original
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. If it's a periodic task, you have to update its
    `startDate` attribute with the start date of the next execution of the task. Calculate
    it as the sum of the actual date and the period. Then, add the task again to the
    queue of the `ScheduledThreadPoolExecutor` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Print a message with the actual date to the console, execute the task calling
    the `runAndReset()` method, and then print another message with the actual date
    to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setPeriod()` method to establish the period of this task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyScheduledThreadPoolExecutor` to implement a `ScheduledThreadPoolExecutor`
    object that executes `MyScheduledTask` tasks. Specify that this class extends
    the `ScheduledThreadPoolExecutor` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class which merely calls the constructor of its
    parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `decorateTask()` method. It receives as a parameter the `Runnable`
    object that is going to be executed and the `RunnableScheduledFuture` task that
    will execute that `Runnable` object. Create and return a `MyScheduledTask` task
    using those objects to construct them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Override the `scheduledAtFixedRate()` method. Call the method of its parent
    class, convert the returned object into a `MyScheduledTask` object, and establish
    the period of that task using the `setPeriod()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Print a message at the start of the task, put
    the current thread to sleep 2 seconds, and print another message at the end of
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyScheduledThreadPoolExecutor` object named `executor`. Use `2` as
    a parameter to have two threads in the pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Task` object named `task`. Write the actual date in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Send a delayed task to the executor using the `schedule()` method. The task
    will be executed after a 1 second delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Put the main thread to sleep for 3 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Create another `Task` object. Print the actual date in the console again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Send a periodic task to the executor using the `scheduleAtFixedRate()` method.
    The task will be executed after a 1 second delay and then will be executed every
    3 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Put the main thread to sleep for 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the executor using the `shutdown()` method. Wait for the finalization
    of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyScheduledTask` class to implement
    a custom task that can execute on a `ScheduledThreadPoolExecutor` executor. This
    class extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface. It implements the `RunnableScheduledFuture` interface, because all
    the tasks executed in a scheduled executor must implement that interface and extend
    the `FutureTask` class, because this class provides valid implementations of the
    methods declared in the `RunnableScheduledFuture` interface. All the interfaces
    and classes mentioned earlier are parameterized classes, with the type of data
    that will be returned by the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To use a `MyScheduledTask` task in a scheduled executor, you have overridden
    the `decorateTask()` method in the `MyScheduledThreadPoolExecutor` class. This
    class extends the `ScheduledThreadPoolExecutor` executor and that method provides
    a mechanism to convert the default scheduled tasks implemented by the `ScheduledThreadPoolExecutor`
    executor to `MyScheduledTask` tasks. So, when you implement your own version of
    scheduled tasks, you have to implement your own version of a scheduled executor.
  prefs: []
  type: TYPE_NORMAL
- en: The `decorateTask()` method simply creates a new `MyScheduledTask` object with
    the parameter; a `Runnable` object that is going to be executed in the task. A
    resultant object that is going to be returned by that task. In this case, the
    task won't return a result, so you used the `null` value. An original task is
    used to execute the `Runnable` object. This is the task that the new object is
    going to replace in the pool; an executor that is going to execute the task. In
    this case, you use the `this` keyword to reference the executor that is creating
    the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyScheduledTask` class can execute delayed and periodic tasks. You have
    implemented two methods with all the necessary logic to execute both kinds of
    tasks. They are the `getDelay()` and the `run()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDelay()` method is called by the scheduled executor to know if it has
    to execute a task. The behavior of this method changes in delayed and periodic
    tasks. As we mentioned earlier, the constructor of the `MyScheduledClass` class
    receives the original `ScheduledRunnableFuture` object that was going to execute
    the `Runnable` object and stores it as an attribute of the class to have access
    to its methods and its data. When we are going to execute a delayed task, the
    `getDelay()` method returns the delay of the original task, but in the case of
    the periodic task, the `getDelay()` method returns the difference between the
    `startDate` attribute and the actual date.
  prefs: []
  type: TYPE_NORMAL
- en: The `run()` method is the one that executes the task. One particularity of the
    periodic tasks is that you have to put the next execution of the task in the queue
    of the executor as a new task if you want the task to be executed again. So, if
    you're executing a periodic task, you establish the `startDate` attribute value
    adding to the actual date and the period of execution of the task and store the
    task again in the queue of the executor. The `startDate` attribute stores the
    date when the next execution of the task will begin. Then, you execute the task
    using the `runAndReset()` method provided by the `FutureTask` class. In the case
    of the delayed tasks, you don't have to put them in the queue of the executor,
    because they only execute once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have also to take into account if the executor has been shutdown. In that
    case, you don't have to store again the periodic tasks into the queue of the executor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you have overridden the `scheduleAtFixedRate()` method in the `MyScheduledThreadPoolExecutor`
    class. We mentioned earlier that, for periodic tasks, you establish the value
    of the `startDate` attribute using the period of the task, but you haven't initialized
    that period yet. You have to override this method that receives that period as
    a parameter, to pass it to the `MyScheduledTask` class so it can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example is complete with the `Task` class that implements the `Runnable`
    interface and is the task executed in the scheduled executor. The main class of
    the example creates a `MyScheduledThreadPoolExecutor` executor and sends the following
    two tasks to them:'
  prefs: []
  type: TYPE_NORMAL
- en: A delayed task, to be executed 1 second after the actual date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A periodic task, to be executed for the first time 1 second after the actual
    date and then every 3 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the execution of this example. You can
    check as the two kinds of tasks are executed properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ScheduledThreadPoolExecutor` class provides another version of the `decorateTask()`
    method that receives a `Callable` object as a parameter instead of a `Runnable`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running a task in an executor after a delay* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running a task in an executor periodically* recipe [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads for the
    Fork/Join framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting features of Java 7 is the Fork/Join framework. It's
    an implementation of the `Executor` and `ExecutorService` interfaces that allow
    you the execution of the `Callable` and `Runnable` tasks without managing the
    threads that execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This executor is oriented to execute tasks that can be divided into smaller
    parts. Its main components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A special kind of task, implemented by the `ForkJoinTask` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two operations for dividing a task into subtasks (the `fork` operation) and
    to wait for the finalization of those subtasks (the `join` operation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An algorithm, denominating the work-stealing algorithm, that optimizes the use
    of the threads of the pool. When a task is waiting for its subtasks, the thread
    that was executing it is used to execute another thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main class of the Fork/Join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement a customized worker thread to
    be used in a `ForkJoinPool` class and how to use it using a factory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyWorkerThread` that extends the `ForkJoinWorkerThread`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Declare and create a private `ThreadLocal` attribute parameterized with the
    `Integer` class named `taskCounter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Override the `onStart()` method. Call the method on its parent class, print
    a message to the console, and set the value of the `taskCounter` attribute for
    this thread to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Override the `onTermination()` method. Write the value of the `taskCounter`
    attribute for this thread in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `addTask()` method. Increment the value of the `taskCounter` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface. Implement the `newThread()` method. Create and return a `MyWorkerThread`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyRecursiveTask` that extends the `RecursiveTask` class
    parameterized with the `Integer` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` array named `array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `int` attributes named `start` and `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compute()` method to sum all the elements of the array between
    the start and end positions. First, convert the thread that is executing the task
    into a `MyWorkerThread` object and use the `addTask()` method to increment the
    counter of tasks for that thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `addResults()` method. Calculate and return the sum of the results
    of the two tasks received as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 10 milliseconds and return the result of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyWorkerThreadFactory` object named `factory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ForkJoinPool` object named `pool`. Pass to the constructor the factory
    object created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Create an array of 100,000 integers. Initialize all the elements to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Task` object to sum all the elements of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Send the task to the pool using the `execute()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the end of the task using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the pool using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the result of the task using the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console indicating the end of the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Threads used by the Fork/Join framework are called worker threads. Java includes
    the `ForkJoinWorkerThread` class that extends the `Thread` class and implements
    the worker threads used by the Fork/Join framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyWorkerThread` class that extends
    the `ForkJoinWorkerThread` class and overrides two methods of that class. Your
    objective is to implement a counter of tasks in each worker thread so you can
    know how many tasks a worker thread has executed. You have implemented the counter
    with a `ThreadLocal` attribute. This way, each thread will have its own counter
    in a transparent way for you, the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: You have overridden the `onStart()` method of the `ForkJoinWorkerThread` class
    to initialize the task counter. This method is called when the worker thread begins
    its execution. You also have overridden the `onTermination()` method to print
    the value of the task counter to the console. This method is called when the worker
    thread finishes its execution. You have also implemented a method in the `MyWorkerThread`
    class. The `addTask()` method increments the task counter of each thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class, as all the executors in the Java concurrency API,
    creates its threads using a factory, so if you want to use the `MyWorkerThread`
    threads in a `ForkJoinPool` class, you have to implement your thread factory.
    For the Fork/Join framework, this factory has to implement the `ForkJoinPool.ForkJoinWorkerThreadFactory`
    class. You have implemented the `MyWorkerThreadFactory` class for this purpose.
    This class only has one method that creates a new `MyWorkerThread` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you only have to initialize a `ForkJoinPool` class with the factory
    you have created. You have done this in the `Main` class, using the constructor
    of the `ForkJoinPool` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the `ForkJoinPool` object has executed four worker threads and
    how many tasks have executed each of them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take into account that the `onTermination()` method provided by the `ForkJoinWorkerThread`
    class is called when a thread finishes normally or throws an `Exception` exception.
    The method receives a `Throwable` object as a parameter. If the parameter takes
    the `null` value, the worker thread finishes normally, but if the parameter takes
    a value, the thread throws an exception. You have to include the necessary code
    to process that situation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Create a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating Threads through a factory* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread Management*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the Fork/Join framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework separates the task creation and its execution. With it,
    you only have to implement the `Runnable` objects and use an `Executor` object.
    You send the `Runnable` tasks to the executor and it creates, manages, and finalizes
    the necessary threads to execute those tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 provides a special kind of executor in the Fork/Join framework. This
    framework is designed to solve those problems that can be broken into smaller
    tasks using the divide and conquer technique. Inside a task, you have to check
    the size of the problem you want to resolve and, if it's bigger than an established
    size, you divide the problem in two or more tasks and execute those tasks using
    the framework. If the size of the problem is smaller than the established size,
    you resolve the problem directly in the task and then, optionally, it returns
    a result. The Fork/Join framework implements the work-stealing algorithm that
    improves the overall performance of these kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main class of the Fork/Join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the tasks executed by a `ForkJoinPool` class are objects of the
    `ForkJoinTask` class. You also can send to a `ForkJoinPool` class the `Runnable`
    and `Callable` objects, but they can''t take advantage of all the benefits of
    the Fork/Join framework. Normally, you will send to the `ForkJoinPool` objects
    one of two subclasses of the `ForkJoinTask` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecursiveAction`: If your tasks don''t return a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecursiveTask`: If your tasks return a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own tasks for the Fork/Join
    framework implementing a task that extends the `ForkJoinTask` class. The task
    you're going to implement measures and writes in the console its execution time,
    so you can control its evolution. You can also implement your own Fork/Join task
    to write log information, to get resources used in the tasks, or to post-process
    the results of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyWorkerTask` and specify that it extends the `ForkJoinTask`
    class parameterized with the `Void` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name` to store the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getRawResult()` method. This is one of the abstract methods of
    the `ForkJoinTask` class. As the `MyWorkerTask` tasks won't return any result,
    this method must return the `null` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setRawResult()` method. This is another abstract method of the
    `ForkJoinTask` class. As the `MyWorkerTask` tasks won't return any result, leave
    the body of this method empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `exec()` method. This is the main method of the task. In this
    case, delegate the logic of the task to the `compute()` method. Calculate the
    execution time of that method and write it in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getName()` method to return the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Declare the abstract method `compute()`. As we mentioned earlier, this method
    will implement the logic of the tasks and must be implemented by the child classes
    of the `MyWorkerTask` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` that extends the `MyWorkerTask` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private array of `int` values named `array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Implement a constructor of the class that initializes its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compute()` method. This method increments the block of elements
    of the array determined by the start and end attributes. If this block of elements
    has more than 100 elements, divide the block in two parts and create two `Task`
    objects to process each part. Send those tasks to the pool using the `invokeAll()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: If the block of elements has less than 100 elements, increment all the elements
    using a `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Finally, put the thread that is executing the task to sleep for 50 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main(`) method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Create an `int` array of 10,000 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ForkJoinPool` object named `pool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Task` object to increment all the elements of the array. The parameters
    of the constructor are `Task` as the name of the task, the array object, and the
    values `0` and `10000` to indicate to this task that it has to process the entire
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Send the task to the pool using the `execute()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Shut down the pool using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyWorkerTask` class that extends the
    `ForkJoinTask` class. It's your own base class to implement tasks that can be
    executed in a `ForkJoinPool` executor and that can take advantage of all the benefits
    of that executor, as the work-stealing algorithm. This class is equivalent to
    the `RecursiveAction` and `RecursiveTask` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you extend the `ForkJoinTask` class, you have to implement the following
    three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setRawResult()`: This method is used to establish the result of the task.
    As your tasks don''t return any results, you leave this method empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRawResult()`: This method is used to return the result of the task. As
    your tasks don''t return any results, this method returns the `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec()`: This method implements the logic of the task. In your case, you have
    delegated the logic in the abstract method `compute()` (as the `RecursiveAction`
    and `RecursiveTask` classes) and in the `exec()` method you measure the execution
    time of that method, writing it in the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the main class of the example, you have created an array of 10,000
    elements, a `ForkJoinPool` executor, and a `Task` object to process the whole
    array. Execute the program and you'll see how the different tasks that are executed
    write their execution time in the console.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the Fork/Join framework* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom Lock class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Locks are one of the basic synchronization mechanisms provided by the Java
    concurrency API. It allows the programmers to protect a critical section of code,
    so only one thread can execute that block of code at a time. It provides the following
    two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lock()`: You call this operation when you want to access a critical section.
    If there is another thread running that critical section, other threads are blocked
    until they''re woken up by the lock to get the access to the critical section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock()`: You call this operation at the end of the critical section, to
    allow other threads to access the critical section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Java Concurrency API, locks are declared in the `Lock` interface and
    implemented in some classes, for example, the `ReentrantLock` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own `Lock` object implementing
    a class that implements the `Lock` interface that can be used to protect a critical
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyQueuedSynchronizer` that extends the `AbstractQueuedSynchronizer`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AtomicInteger` attribute named `state`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Implement the`tryAcquire()` method. This method tries to change the value of
    the state variable from zero to one. If it can, it returns the `true` value else
    it returns `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `tryRelease()` method. This method tries to change the value of
    the state variable from one to zero. If it can, it returns the `true` value else
    it returns the `false` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `MyLock` and specify that it implements the `Lock` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AbstractQueuedSynchronizer` attribute named `sync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize the `sync` attribute with
    a new `MyAbstractQueueSynchronizer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `lock()` method. Call the `acquire()` method of the `sync` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `lockInterruptibly()` method. Call the `acquireInterruptibly()`
    method of the `sync` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `tryLock()` method. Call the `tryAcquireNanos()` method of the
    `sync` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Implement another version of the `tryLock()` method with two parameters. A long
    parameter named `time` and a `TimeUnit` parameter named `unit`. Call the `tryAcquireNanos()`
    method of the `sync` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `unlock()` method. Call the `release()` method of the `sync` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `newCondition()` method. Create a new object of the internal class
    of the `sync` object `ConditionObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `MyLock` attribute named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Implement the`run()` method of the class. Acquire the lock, put the thread to
    sleep for 2 seconds and then, release the `lock` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyLock` object named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Create and execute 10 `Task` tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Try to get the lock using the `tryLock()` method. Wait for a second and if you
    don't get the lock, write a message and try again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Write a message indicating that you got the lock and release it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Write a message indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java Concurrency API provides a class that can be used to implement synchronization
    mechanisms with features of locks or semaphores. It''s `AbstractQueuedSynchronizer`
    and, as its name suggests, it''s an abstract class. It provides operations to
    control access to a critical section and to manage a queue of threads that are
    blocked awaiting access to the critical section. The operations are based on two
    abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method is called to try to get access to a critical section.
    If the thread that calls it can access the critical section, the method returns
    the `true` value. Otherwise, the method returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryRelease()`: This method is called to try to release access to a critical
    section. If the thread that calls it can release the access, the method returns
    the `true` value. Else, the method returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these methods, you have to implement the mechanism you use to control the
    access to the critical section. In your case, you have implemented the `MyQueuedSynchonizer`
    class that extends the `AbstractQueuedSyncrhonizer` class and implements the abstract
    methods using an `AtomicInteger` variable to control the access of the critical
    section. That variable will store the `0` value if the lock is free, so a thread
    can have access to the critical section, and the `1` value if the lock is blocked,
    so a thread can't have access to the critical section.
  prefs: []
  type: TYPE_NORMAL
- en: You have used the `compareAndSet()` method provided by the `AtomicInteger` class
    that tries to change the value you specify as the first parameter for the value
    you specify as the second parameter. To implement the `tryAcquire()` method, you
    try to change the value of the atomic variable from zero to one. Similarly, to
    implement the `tryRelease()` method, you try to change the value of the atomic
    variable from one to zero.
  prefs: []
  type: TYPE_NORMAL
- en: You have to implement this class because other implementations of the `AbstractQueuedSynchronizer`
    class (for example, the one used by the `ReentrantLock` class), are implemented
    as private classes internally in the class that uses it, so you don't have access
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have implemented the `MyLock` class. This class implements the `Lock`
    interface and has a `MyQueuedSynchronizer` object as an attribute. To implement
    all the methods of the `Lock` interface, you have used methods of the `MyQueuedSynchronizer`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you have implemented the `Task` class, that implements the `Runnable`
    interface and uses a `MyLock` object to get the access to a critical section.
    That critical section puts the thread to sleep for 2 seconds. The main class creates
    a `MyLock` object and runs 10 `Task` objects that share that lock. The main class
    also tries to get the access to the lock using the `tryLock()` method.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the example, you can see how only one thread has access to
    the critical section and when that thread finishes, another one gets the access
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your own `Lock` to write log messages about its utilization, control
    the time that is locked, or implement advanced synchronization mechanisms, to
    control, for example, the access to a resource so that it's only available at
    certain times.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AbstractQueuedSynchronizer` class provides two methods that can be used
    to manage the state of the lock. They are the `getState()` and `setState()` methods.
    These methods receive and return an integer value with the state of the lock.
    You could have used those methods instead of the `AtomicInteger` attribute to
    store the state of the lock.
  prefs: []
  type: TYPE_NORMAL
- en: Java concurrency API provides another class to implement synchronization mechanisms.
    It's the `AbstractQueuedLongSynchronizer` class, that is equivalent to the `AbstractQueuedSynchronizer`
    class, but uses a `long` attribute to store the state of the threads.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer Queue based on priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 7 API provides several data structures to work with concurrent applications.
    From these, we want to highlight the following two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedTransferQueue`: This data structure is supposed to be used in those
    programs that have a producer/consumer structure. In those applications, you have
    one or more producers of data and one or more consumers of data and a data structure
    is shared by all of them. The producers put data in the data structure and the
    consumers take data from the data structure. If the data structure is empty, the
    consumers are blocked until they have data to consume. If the data structure is
    full, the producers are blocked until they have space to put their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue`: In this data structure, elements are stored in an
    ordered way. The elements have to implement the `Comparable` interface with the
    `compareTo()` method. When you insert an element in the structure, it''s compared
    to the elements of the structure until it finds its position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of the `LinkedTransferQueue` are stored in the same order as they arrive,
    so earlier arrivals are consumed first. It may be the case when you want to develop
    a producer/consumer program, where data is consumed according to some priority
    instead of arrival time. In this recipe, you will learn how to implement a data
    structure to be used in the producer/consumer problem, whose elements will be
    ordered by their priority. Those elements with higher priority will be consumed
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyPriorityTransferQueue` that extends the `PriorityBlockingQueue`
    class and implements the `TransferQueue` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AtomicInteger` attribute named `counter` to store the number
    of consumers that are waiting for elements to consume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `LinkedBlockingQueue` attribute named `transferred`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ReentrantLock` attribute named `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `tryTransfer()` method. This method tries to send the element
    to a waiting consumer immediately, if possible. If there isn't any waiting consumer,
    the method returns the `false` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `transfer()` method. This method tries to send the element to
    a waiting consumer immediately, if possible. If there isn't a waiting consumer,
    the method stores the element in a special queue to be sent to the first consumer
    that tries to get an element and blocks the thread until the element is consumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `tryTransfer()` method that receives three parameters: The element,
    the time to wait for a consumer, if there is none, and the unit of time used to
    specify that time. If there is a consumer waiting, it sends the element immediately.
    Otherwise, convert the time specified to milliseconds and use the `wait()` method
    to put the thread to sleep. When the consumer takes the element, if the thread
    is sleeping in the `wait()` method, you are going to wake it up using the `notify()`
    method as you''ll see in a moment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `hasWaitingConsumer()` method. Use the value of the counter attribute
    to calculate the return value of this method. If the counter has a value bigger
    than zero, return `true`. Else, return `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getWaitingConsumerCount()` method. Return the value of the `counter`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `take()` method. This `method` is called by the consumers when
    they want an element to consume. First, get the lock defined earlier and increment
    the number of waiting consumers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: If there aren't any elements in the transferred queue, free the lock and try
    to get an element from the queue using the `take()` element and get the lock again.
    If there aren't any elements in the queue, this method will put the thread to
    sleep until there are elements to consume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, take the element from the transferred queue and wake up the thread
    that is waiting for the consummation of that element, if there is one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Finally, decrement the counter of waiting consumers and free the lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `Event` that extends the `Comparable` interface parameterized
    with the `Event` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `thread` to store the name of the
    thread that creates the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `priority` to store the priority of
    the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to return the value of the thread attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method to return the value of the priority attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compareTo()` method. This method compares the actual event with
    an event received as a parameter. Return `-1` if the actual event has a bigger
    priority than the parameter, `1` if the actual event has a lower priority than
    the parameter, and `0` if both events have the same priority. You will get the
    list ordered by priority in the descending order. Events with higher priority
    will be stored first in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `Producer` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `MyPriorityTransferQueue` attribute parameterized with the
    `Event` class named `buffer` to store the events generated by this producer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the class. Create 100 `Event` objects using
    its order of creation as priority (the latest event will have the highest priority)
    and insert them in the queue using the `put()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `Consumer` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `MyPriorityTransferQueue` attribute parameterized with the
    `Event` class named buffer to get the events consumed by this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It consumes 1002 `Events` (all the events generated
    in the example) using the `take()` method and write the number of the thread that
    generated the event and its priority in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Create a `MyPriorityTransferQueue` object named `buffer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Producer` task and launch 10 threads to execute that task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch a `Consumer` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the actual consumer count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Transfer an event to the consumer using the `transfer()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the producers using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Write the actual consumer count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Transfer another event using the `transfer()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the consumer using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Write a message indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyPriorityTransferQueue` data structure.
    It's a data structure to be used in the producer/consumer problem, but its elements
    are ordered by priority, not by their arrival order. As Java doesn't allow multiple
    inheritance, the first decision you have taken is the base class of the `MyPriorityTransferQueue`
    class. You have extended the `PriorityBlockingQueue` class, to have implemented
    the operations that insert the elements in the structure ordered by priority.
    You also have implemented the `TransferQueue` interface to add the methods related
    with the producer/consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MyPriortyTransferQueue` class have the following three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AtomicInteger` attribute, named `counter`: This attribute stores the number
    of consumers that are waiting for taking an element for the data structure. When
    a consumer calls the `take()` operation to take an element from the data structure,
    the counter is incremented. When the consumer finishes the execution of the `take()`
    operation, the counter is decremented again. This counter is used in the implementation
    of the `hasWaitingConsumer()` and `getWaitingConsumerCount()` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `ReentrantLock` attribute named `lock`: This attribute is used to control
    the access to the implemented operations. Only one thread can be working with
    the data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a `LinkedBlockingQueue` list to store the transferred elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have implemented some methods in the `MyPriorityTransferQueue`. All the
    methods are declared in the `TransferQueue` interface and the `take()` method
    implemented in the `PriorityBlockingQueue` interface. Two of them were described
    before. Here is a description of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tryTransfer(E``e)`: This method tries to send an element directly to a consumer.
    If there is a consumer waiting, the method stores the element in the priority
    queue to be consumed immediately by the consumer and then returns the `true` value.
    If there isn''t a consumer waiting, the method returns the `false` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer(E``e)`: This method transfers an element directly to a consumer.
    It there is a consumer waiting, the method stores the element in the priority
    queue to be consumed immediately by the consumer. Otherwise, the element is stored
    in the list for transferred elements and the thread is blocked until the element
    is consumed. While the thread is put to sleep, you have to free the lock because
    if not, you block the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryTransfer(E``e,``long``timeout,``TimeUnit``unit)`: This method is similar
    to the `transfer()` method, but the thread blocks the period of time determined
    by its parameters. While the thread is put to sleep, you have to free the lock
    because, if not, you block the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns the next element to be consumed. If there are
    elements in the list of transferred elements, the element to be consumed is taken
    from that list. Otherwise, it is taken from the priority queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have implemented the data structure, you have implemented the `Event`
    class. It is the class of the elements you have stored in the data structure.
    The `Event` class has two attributes to store the ID of the producer and the priority
    of the event, and implements the `Comparable` interface, because it is a requirement
    of your data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have implemented the `Producer` and the `Consumer` classes. In the
    example, you have 10 producers and a consumer and they share the same buffer.
    Each producer generates 100 events with incremental priority, so the events with
    higher priority are the last generated ones.
  prefs: []
  type: TYPE_NORMAL
- en: The main class of example creates a `MyPriorityTransferQueue` object, 10 producers,
    and a consumer and uses the `transfer()` method of the `MyPriorityTransferQueue`
    buffer to transfer two events to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the events with higher priority are consumed first, and that
    a consumer consumes the transferred event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic variables were introduced in Java Version 5 and provide atomic operations
    on single variables. When a thread is doing an operation with an atomic variable,
    the implementation of the class includes a mechanism to check that the operation
    is done in one step. Basically, the operation gets the value of the variable,
    changes the value in a local variable, and then tries to change the old value
    for the new one. If the old value is still the same, it does the change. If not,
    the method begins the operation again.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to extend an atomic object and how to implement
    two operations that follow the mechanisms of the atomic objects to guarantee that
    all the operations are done in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `ParkingCounter` and specify that it extends the `AtomicInteger`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `maxNumber` to store the maximum number
    of cars admitted in the parking lot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `carIn()` method. This method increments the counter of cars if
    it has a value smaller than the established maximum value. Construct an infinite
    loop and get the value of the internal counter using the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: If the value is equal to the `maxNumber` attribute, the counter can't be incremented
    (the parking lot is full and the car can't enter). The method returns the `false`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, increment the value and use the `compareAndSet()` method to change
    the old value to the new one. This method returns the `false` value; the counter
    was not incremented, so you have to begin the loop again. If it returns the `true`
    value, it means the change was made and then, you return the `true` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `carOut()` method. This method decrements the counter of cars
    if it has a value bigger than `0`. Construct an infinite loop and get the value
    of the internal counter using the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Sensor1` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ParkingCounter` attribute named `counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Call the `carIn()` and `carOut()` operations several
    times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Sensor2` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ParkingCounter` attribute named `counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Call the `carIn()` and `carOut()` operations several
    times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ParkingCounter` object named `counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch a `Sensor1` task and a `Sensor2` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of both tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the actual value of the counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console a message indicating the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ParkingCounter` class extends the `AtomicInteger` class with two atomic
    operations, `carIn()` and `carOut()`. The example simulates a system that controls
    the number of cars inside a parking lot. The parking lot can admit a number of
    cars, represented by the `maxNumber` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `carIn()` operation compares the actual number of cars in the parking lot
    with the maximum value. If they are equal, the car can''t enter the parking lot
    and the method returns the `false` value. Otherwise, it uses the following structure
    of the atomic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the value of the atomic object in a local variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the new value in a different variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `compareAndSet()` method to try to replace the old value by the new
    one. If this method returns the `true` value, the old value you sent as a parameter
    was the value of the variable, so it makes the change of values. The operation
    was made in an atomic way as the `carIn()` method returns the `true` value. If
    the `compareAndSet()` method returns the `false` value, the old value you sent
    as a parameter is not the value of the variable (the other thread modified it),
    so the operation can't be done in an atomic way. The operation begins again until
    it can be done in an atomic way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `carOut()` method is analogous to the `carIn()` method. You have also implemented
    two `Runnable` objects that use the `carIn()` and `carOut()` methods to simulate
    the activity of the parking. When you execute the program, you can see that the
    parking lot never overcomes the maximum value of cars in the parking lot.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
