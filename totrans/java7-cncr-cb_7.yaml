- en: Chapter 7. Customizing Concurrency Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。自定义并发类
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Customizing the `ThreadPoolExecutor` class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义`ThreadPoolExecutor`类
- en: Implementing a priority-based `Executor` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于优先级的`Executor`类
- en: Implementing the `ThreadFactory` interface to generate custom threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`ThreadFactory`接口以生成自定义线程
- en: Using our `ThreadFactory` in an `Executor` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Executor`对象中使用我们的`ThreadFactory`
- en: Customizing tasks running in a scheduled thread pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义在计划线程池中运行的任务
- en: Implementing the `ThreadFactory` interface to generate custom threads for the
    Fork/Join framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`ThreadFactory`接口以为Fork/Join框架生成自定义线程
- en: Customizing tasks running in the Fork/Join framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义在Fork/Join框架中运行的任务
- en: Implementing a custom `Lock` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义`Lock`类
- en: Implementing a transfer queue based on priorities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于优先级实现传输队列
- en: Implementing your own atomic object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自己的原子对象
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Java concurrency API provides a lot of interfaces and classes to implement concurrent
    applications. They provide low-level mechanisms, such as the `Thread` class, the
    `Runnable` or `Callable` interfaces, or the `synchronized` keyword, and also high-level
    mechanisms, such as the Executor framework and the Fork/Join framework added in
    the Java 7 release. Despite this, you may find yourself developing a program where
    none of the java classes meet your needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了许多接口和类来实现并发应用程序。它们提供低级机制，如`Thread`类、`Runnable`或`Callable`接口或`synchronized`关键字，以及高级机制，如Executor框架和Java
    7版本中添加的Fork/Join框架。尽管如此，您可能会发现自己正在开发一个程序，其中没有任何java类满足您的需求。
- en: 'In this case, you may need to implement your own custom-concurrent utilities
    based on the ones provided by Java. Basically, you can:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能需要基于Java提供的工具来实现自己的自定义并发工具。基本上，您可以：
- en: Implement an interface to provide the functionality defined by that interface.
    For example, the `ThreadFactory` interface.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个接口以提供该接口定义的功能。例如，`ThreadFactory`接口。
- en: Override some methods of a class to adapt its behavior to your needs. For example,
    overriding the `run()` method of the `Thread` class which, by default, does nothing
    useful and is supposed to be overridden to offer some functionality.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写类的一些方法以使其行为适应您的需求。例如，重写`Thread`类的`run()`方法，默认情况下不执行任何有用的操作，应该重写以提供一些功能。
- en: Through the recipes of this chapter, you will learn how to change the behavior
    of some Java concurrency API classes without the need to design a concurrency
    framework from scratch. You can use these recipes as an initial point to implement
    your own customizations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的示例，您将学习如何更改一些Java并发API类的行为，而无需从头设计并发框架。您可以将这些示例作为实现自定义的初始点。
- en: Customizing the ThreadPoolExecutor class
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义ThreadPoolExecutor类
- en: 'The Executor framework is a mechanism that allows you to separate the thread
    creation from its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces with the `ThreadPoolExecutor` class that implements both interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks for their execution in the pooled threads. These tasks are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架是一种允许您将线程创建与其执行分离的机制。它基于`Executor`和`ExecutorService`接口，使用实现了这两个接口的`ThreadPoolExecutor`类。它具有内部线程池，并提供方法，允许您发送两种类型的任务以在池化线程中执行。这些任务是：
- en: The `Runnable` interface to implement tasks that don't return a result
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runnable`接口以实现不返回结果的任务'
- en: The `Callable` interface to implement tasks that return a result
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`接口以实现返回结果的任务'
- en: In both cases, you only send the task to the executor. The executor uses one
    of its pooled threads or creates a new one to execute those tasks. The executor
    also decides the moment in which the task is executed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您只需将任务发送到执行器。执行器使用其池化线程之一或创建一个新线程来执行这些任务。执行器还决定任务执行的时机。
- en: In this recipe, you will learn how to override some methods of the `ThreadPoolExecutor`
    class to calculate the execution time of the tasks that you execute in the executor
    and to write in the console statistics about the executor when it completes its
    execution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何重写`ThreadPoolExecutor`类的一些方法，以计算在执行器中执行的任务的执行时间，并在执行器完成执行时在控制台中写入有关执行器的统计信息。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the steps described below to implement the example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面描述的步骤实现示例：
- en: Create a class named `MyExecutor` that extends the `ThreadPoolExecutor` class.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyExecutor`的类，它扩展了`ThreadPoolExecutor`类。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declare a private `ConcurrentHashMap` attribute parameterized with the `String`
    and `Date` classes named `startTimes`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`ConcurrentHashMap`属性，参数化为`String`和`Date`类，命名为`startTimes`。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the constructor for the class. Call a constructor of the parent class
    using the `super` keyword and initialize the `startTime` attribute.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该类的构造函数。使用`super`关键字调用父类的构造函数并初始化`startTime`属性。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Override the `shutdown()` method. Write in the console information about the
    executed tasks, the running tasks, and the pending tasks. Then, call the `shutdown()`
    method of the parent class using the `super` keyword.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`shutdown()`方法。在控制台中写入有关已执行任务、正在运行任务和待处理任务的信息。然后，使用`super`关键字调用父类的`shutdown()`方法。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Override the `shutdownNow()` method. Write in the console information about
    the executed tasks, the running tasks, and the pending tasks. Then, call the `shutdownNow()`
    method of the parent class using the `super` keyword.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`shutdownNow()`方法。在控制台中写入有关已执行任务、正在运行任务和待处理任务的信息。然后，使用`super`关键字调用父类的`shutdownNow()`方法。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Override the `beforeExecute()` method. Write a message in the console with the
    name of the thread that is going to execute the task and the hash code of the
    task. Store the start date in `HashMap` using the hash code of the task as the
    key.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`beforeExecute()`方法。在控制台中写入将执行任务的线程的名称和任务的哈希码的消息。使用任务的哈希码作为键，将开始日期存储在`HashMap`中。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Override the `afterExecute()` method. Write a message in the console with the
    result of the task and calculate the running time of the task subtracting the
    start date of the task stored in `HashMap` of the current date.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`afterExecute()`方法。在控制台中写入任务的结果，并计算任务的运行时间，减去存储在`HashMap`中的任务的开始日期。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a class named `SleepTwoSecondsTask`that implements the `Callable` interface
    parameterized with the `String` class. Implement the `call()` method. Put the
    current thread to sleep for 2 seconds and return the current date converted to
    a `String` type.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SleepTwoSecondsTask`的类，实现带有`String`类参数的`Callable`接口。实现`call()`方法。将当前线程休眠2秒，并返回转换为`String`类型的当前日期。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的主类来实现示例的主要类，其中包含一个`main()`方法。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a `MyExecutor` object named `myExecutor`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`myExecutor`的`MyExecutor`对象。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a list of `Future` objects parameterized with the `String` class to store
    the resultant objects of the tasks you're going to send to the executor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`String`类参数的`Future`对象列表，用于存储您要发送到执行器的任务的结果对象。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Submit 10 `Task` objects.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交10个`Task`对象。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Get the result of the execution of the first five tasks using the `get()` method.
    Write them in the console.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`get()`方法获取前五个任务的执行结果。在控制台中写入它们。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finish the execution of the executor using the `shutdown()` method.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法结束执行器的执行。
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Get the result of the execution of the last five tasks using the `get()` method.
    Write them in the console.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`get()`方法获取最后五个任务的执行结果。在控制台中写入它们。
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait for the completion of the executor using the `awaitTermination()` method.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的完成。
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Write a message indicating the end of the execution of the program.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息指示程序执行结束。
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have implemented our custom executor extending the `ThreadPoolExecutor`
    class and overriding four of its methods. The `beforeExecute()` and `afterExecute()`
    methods were used to calculate the execution time of a task. The `beforeExecute()`
    method is executed before the execution of a task. In this case, we have used
    `HashMap` to store in it the start date of the task. The `afterExecute()` method
    is executed after the execution of a task. You get `startTime` of the task that
    has finished from `HashMap` and then, calculate the difference between the actual
    date and that date to get the execution time of the task. You have also overridden
    the `shutdown()` and `shutdownNow()` methods to write statistics about the tasks
    executed in the executor to the console:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们扩展了`ThreadPoolExecutor`类来实现我们的自定义执行器，并覆盖了它的四个方法。`beforeExecute()`和`afterExecute()`方法用于计算任务的执行时间。`beforeExecute()`方法在任务执行之前执行。在这种情况下，我们使用`HashMap`来存储任务的开始日期。`afterExecute()`方法在任务执行后执行。您可以从`HashMap`中获取已完成任务的`startTime`，然后计算实际日期与该日期之间的差异，以获取任务的执行时间。您还覆盖了`shutdown()`和`shutdownNow()`方法，以将执行器中执行的任务的统计信息写入控制台：
- en: The executed tasks, using the `getCompletedTaskCount()` method
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getCompletedTaskCount()`方法执行的任务
- en: The tasks that are running at this time, using the `getActiveCount()` method
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getActiveCount()`方法获取当前正在运行的任务
- en: The pending tasks, using the `size()` method of the blocking queue where the
    executor stores the pending tasks. The `SleepTwoSecondsTask` class that implements
    the `Callable` interface puts its execution thread to sleep for 2 seconds and
    the `Main` class, where you send 10 tasks to your executor that uses it and the
    other classes to demo their features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阻塞队列的`size()`方法来存储待处理任务的执行器。实现`Callable`接口的`SleepTwoSecondsTask`类将其执行线程休眠2秒，`Main`类中，您向执行器发送10个任务，使用它和其他类来演示它们的特性。
- en: Execute the program and you will see how the program shows the time span of
    each task that is running and the statistics of the executor upon calling the
    `shutdown()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，您将看到程序显示每个正在运行的任务的时间跨度以及在调用`shutdown()`方法时执行器的统计信息。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a Thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*创建线程执行器*配方，*线程执行器*'
- en: The *Using our ThreadFactory in an Executor* object recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章 自定义并发类")中的*在执行器中使用我们的ThreadFactory*对象配方，*自定义并发类*'
- en: Implementing a priority-based Executor class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于优先级的执行器类
- en: In the first versions of the Java concurrency API, you had to create and run
    all the threads of your application. In Java Version 5, with the appearance of
    the Executor framework, a new mechanism was introduced for the execution of concurrency
    tasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java并发API的早期版本中，您必须创建和运行应用程序的所有线程。在Java版本5中，随着执行器框架的出现，引入了一种新的机制来执行并发任务。
- en: With the Executor framework, you only have to implement your tasks and send
    them to the executor. The executor is responsible for the creation and execution
    of the threads that execute your tasks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用执行器框架，您只需实现您的任务并将其发送到执行器。执行器负责创建和执行执行您的任务的线程。
- en: Internally, an executor uses a blocking queue to store pending tasks. These
    are stored in the order of their arrival to the executor. One possible alternative
    is the use of a priority queue to store new tasks. In this way, if a new task
    with high priority arrives to the executor, it will be executed before other threads
    that have already been waiting for a thread to execute, but have lower priority.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，执行程序使用阻塞队列来存储待处理任务。这些任务按照它们到达执行程序的顺序进行存储。一种可能的替代方案是使用优先级队列来存储新任务。这样，如果具有高优先级的新任务到达执行程序，它将在已经等待线程执行的其他线程之前执行，但具有较低优先级。
- en: In this recipe, you will learn how to implement an executor that will use a
    priority queue to store the tasks you send for execution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何实现一个执行程序，该执行程序将使用优先级队列来存储您发送的任务以供执行。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `MyPriorityTask` that implements the `Runnable` and `Comparable`
    interfaces parameterized with the `MyPriorityTask` class interface.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyPriorityTask`的类，该类实现了`Runnable`和`Comparable`接口，参数化为`MyPriorityTask`类接口。
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Declare a private `int` attribute named `priority`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`priority`的私有`int`属性。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Declare a private `String` attribute named `name`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现类的构造函数来初始化其属性。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implement a method to return the value of the priority attribute.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来返回优先级属性的值。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implement the `compareTo()` method declared in the `Comparable` interface. It
    receives a `MyPriorityTask` object as a parameter and compares the priorities
    of the two objects, the current one and the parameter. You let the tasks with
    higher priority execute before the tasks with lower priority.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Comparable`接口中声明的`compareTo()`方法。它接收一个`MyPriorityTask`对象作为参数，并比较两个对象的优先级，当前对象和参数对象。您让具有更高优先级的任务在具有较低优先级的任务之前执行。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implement the `run()` method. Put the current thread to sleep for 2 seconds.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。将当前线程休眠2秒。
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a `ThreadPoolExecutor` object named `executor`. Use `PriorityBlockingQueue`
    parameterized with the `Runnable` interface as the queue that this executor will
    use to store its pending tasks.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`executor`的`ThreadPoolExecutor`对象。使用`PriorityBlockingQueue`参数化为`Runnable`接口作为此执行程序将用于存储其待处理任务的队列。
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Send four tasks to the executor using the counter of the loop as priority of
    the tasks. Use the `execute()` method to send the tasks to the executor.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环的计数器作为任务的优先级，向执行程序发送四个任务。使用`execute()`方法将任务发送到执行程序。
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Put the current thread to sleep for 1 second.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前线程休眠1秒。
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Send four additional tasks to the executor using the counter of the loop as
    priority of the tasks. Use the `execute()` method to send the tasks to the executor.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环的计数器作为任务的优先级，向执行程序发送四个额外的任务。使用`execute()`方法将任务发送到执行程序。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Shut down the executor using the `shutdown()` method.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行程序。
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行程序的完成。
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write a message in the console indicating the finalization of the program.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入一条消息，指示程序的完成。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To convert an executor to a priority-based one is simple. You only have to pass
    a `PriorityBlockingQueue` object parameterized with the `Runnable` interface as
    a parameter. But with the executor, you should know that all the objects stored
    in a priority queue have to implement the `Comparable` interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行程序转换为基于优先级的执行程序很简单。您只需传递一个使用`Runnable`接口参数化的`PriorityBlockingQueue`对象作为参数。但是对于执行程序，您应该知道存储在优先级队列中的所有对象都必须实现`Comparable`接口。
- en: You have implemented the `MyPriorityTask` class that implements the `Runnable`
    interface, to be a task, and the `Comparable` interface, to be stored in the priority
    queue. This class has a `Priority` attribute that is used to store the priority
    of the tasks. If a task has a higher value for this attribute, it will be executed
    earlier. The `compareTo()` method determines the order of the tasks in the priority
    queue. In the `Main` class, you sent eight tasks to the executor with different
    priorities. The first tasks you sent to the executor are the first tasks that
    are executed. As the executor is idle waiting for tasks to be executed, and as
    the first tasks arrive to the executor, it executes them immediately. You have
    created the executor with two execution threads, so the first two tasks will be
    the first ones that are executed. Then, the rest of the tasks are executed based
    on their priority.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经实现了`MyPriorityTask`类，该类实现了`Runnable`接口，用作任务，并实现了`Comparable`接口，用于存储在优先级队列中。该类具有一个`Priority`属性，用于存储任务的优先级。如果任务的这个属性具有更高的值，它将更早执行。`compareTo()`方法确定了优先级队列中任务的顺序。在`Main`类中，您向执行程序发送了八个具有不同优先级的任务。您发送给执行程序的第一个任务是最先执行的任务。当执行程序空闲等待要执行的任务时，随着第一个任务到达执行程序，它立即执行它们。您使用两个执行线程创建了执行程序，因此前两个任务将是最先执行的任务。然后，其余的任务将根据它们的优先级执行。
- en: 'The following screenshot shows one execution of this example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例的一个执行：
- en: '![How it works...](img/7881_07_01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_07_01.jpg)'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can configure `Executor` to use any implementation of the `BlockingQueue`
    interface. One interesting implementation is `DelayQueue`. This class is used
    to store elements with a delayed activation. It provides methods that only return
    the active objects. You can use this class to implement your own version of the
    `ScheduledThreadPoolExecutor` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置`Executor`以使用`BlockingQueue`接口的任何实现。一个有趣的实现是`DelayQueue`。这个类用于存储延迟激活的元素。它提供了只返回活动对象的方法。您可以使用这个类来实现自己版本的`ScheduledThreadPoolExecutor`类。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a Thread Executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*创建线程执行器*配方，*线程执行器*'
- en: The *Customizing the ThreadPoolExecutor* class recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章 自定义并发类")中的*自定义ThreadPoolExecutor类*配方，*自定义并发类*'
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用按优先级排序的阻塞线程安全列表*配方，*并发集合*'
- en: Implementing the ThreadFactory interface to generate custom threads
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ThreadFactory接口以生成自定义线程
- en: The **factory pattern** is a widely used design pattern in the object-oriented
    programming world. It is a creational pattern and its objective is to develop
    a class whose mission will be creating objects of one or several classes. Then,
    when we want to create an object of one of those classes, we use the factory instead
    of using the new operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂模式**是面向对象编程世界中广泛使用的设计模式。它是一个创建模式，其目标是开发一个类，其任务是创建一个或多个类的对象。然后，当我们想要创建这些类中的一个对象时，我们使用工厂而不是使用`new`运算符。'
- en: With this factory, we centralize the creation of objects gaining an advantage
    of easily changing the class of objects created or the way we create these objects
    that are easily limiting the creation of objects for limited resources. For example,
    we can only have *N* objects of a type that is easily generating statistical data
    about the creation of objects.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个工厂，我们集中了对象的创建，从而方便地改变创建的对象的类或创建这些对象的方式，从而轻松限制了有限资源的对象创建。例如，我们可以只有*N*个对象，这些对象很容易生成有关对象创建的统计数据。
- en: Java provides the `ThreadFactory` interface to implement a `Thread` object factory.
    Some advanced utilities of the Java concurrency API, as the Executor framework
    or the Fork/Join framework, use thread factories to create threads.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`ThreadFactory`接口来实现`Thread`对象工厂。Java并发API的一些高级工具，如Executor框架或Fork/Join框架，使用线程工厂来创建线程。
- en: Another example of the factory pattern in the Java Concurrency API is the `Executors`
    class. It provides a lot of methods to create different kinds of `Executor` objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API中工厂模式的另一个例子是`Executors`类。它提供了许多方法来创建不同类型的`Executor`对象。
- en: In this recipe, you will extend the `Thread` class by adding new functionalities
    and you will implement a thread factory class to generate threads of that new
    class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将通过添加新功能来扩展`Thread`类，并实现一个线程工厂类来生成该新类的线程。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `MyThread` that extends the `Thread` class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyThread`的类，它继承`Thread`类。
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Declare three private `Date` attributes named `creationDate`, `startDate`, and
    `finishDate`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个私有的`Date`属性，分别命名为`creationDate`、`startDate`和`finishDate`。
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implement a constructor of the class. It receives the name and the `Runnable`
    object to execute as parameters. Store the creation date of the thread.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它接收名称和`Runnable`对象作为参数。存储线程的创建日期。
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implement the `run()` method. Store the start date of the thread, call the `run()`
    method of the parent class, and store the finish date of the execution.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。存储线程的开始日期，调用父类的`run()`方法，并存储执行的完成日期。
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implement a method to establish the value of the `creationDate` attribute.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来建立`creationDate`属性的值。
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implement a method to establish the value of the `startDate` attribute.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来建立`startDate`属性的值。
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implement a method to establish the value of the `finishDate` attribute.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法来建立`finishDate`属性的值。
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Implement a method named`getExecutionTime()` that calculates the execution time
    of the thread as the difference between the start date and the finish date.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`getExecutionTime()`的方法，它计算线程的执行时间，即开始日期和完成日期之间的差异。
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Override the `toString()` method to return the creation date and the execution
    time of the thread.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`toString()`方法以返回线程的创建日期和执行时间。
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create a class named `MyThreadFactory` that implements the `ThreadFactory` interface.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyThreadFactory`的类，它实现`ThreadFactory`接口。
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Declare a private `int` attribute named `counter`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`int`属性，命名为`counter`。
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Declare a private `String` attribute named `prefix`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性，命名为`prefix`。
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implement the `newThread()` method. Create a `MyThread` object and increment
    the `counter` attribute.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`newThread()`方法。创建一个`MyThread`对象并增加`counter`属性。
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Create a class named `MyTask` that implements the `Runnable` interface. Implement
    the `run()` method. Put the current thread to sleep for 2 seconds.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyTask`的类，它实现`Runnable`接口。实现`run()`方法。让当前线程休眠2秒。
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加一个`main()`方法来实现示例的主类。
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a `MyThreadFactory` object.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyThreadFactory`对象。
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create a `Task` object.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象。
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a `MyThread` object to execute the task using the `newThread()` method
    of the factory.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Start the thread and wait for its finalization.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Write information about the thread using the `toString()` method.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented a custom `MyThread` class extending the
    `Thread` class. The class has three attributes to store the creation date, the
    start date of its execution, and the end date of its execution. Using the start
    date and the end date attributes, you have implemented the `getExecutionTime()`
    method that returns the time that the thread has been executing its task. Finally,
    you have overridden the `toString()` method to generate information about a thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Once you had your own thread class, you have implemented a factory to create
    objects of that class implementing the `ThreadFactory` interface. It's not mandatory
    to make use of the interface if you're going to use your factory as an independent
    object, but if you want to use this factory with other classes of the Java concurrency
    API, you must construct your factory by implementing that interface. The `ThreadFactory`
    interface only has one method, the `newThread()` method that receives a `Runnable`
    object as a parameter and returns a `Thread` object to execute that `Runnable`
    object. In your case, you return a `MyThread` object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: To check these two classes, you have implemented the `MyTask` class that implements
    the `Runnable` object. This is the task to be executed in threads managed by the
    `MyThread` object. A `MyTask` instance puts its execution thread to sleep for
    2 seconds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In the main method of the example, you have created a `MyThread` object using
    a `MyThreadFactory` factory to execute a `Task` object. Execute the program and
    you will see a message with the start date and the execution time of the thread
    executed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output generated by this example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java Concurrency API provides the `Executors` class to generate thread executors,
    usually objects of the `ThreadPoolExecutor` class. You can also use this class
    to obtain the most basic implementation of the `ThreadFactory` interface using
    the `defaultThreadFactory()` method. The factory generated by this method generates
    basic `Thread` objects belonging to all of them to the same `ThreadGroup` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `ThreadFactory` interface in your program for any purposes,
    not necessarily related to the Executor framework.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Using our ThreadFactory in an Executor object
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Implementing the ThreadFactory interface to generate
    custom threads*, we introduced the factory pattern and provided an example of
    how to implement a factory of threads implementing the `ThreadFactory` interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The Executor framework is a mechanism that allows you the separation of the
    thread creation and its execution. It''s based on the `Executor` and `ExecutorService`
    interfaces and in the `ThreadPoolExecutor` class that implements both interfaces.
    It has an internal pool of threads and provides methods that allow you to send
    two kinds of tasks for their execution in the pooled threads. These two kinds
    of tasks are:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Classes that implement the `Runnable` interface, to implement tasks that don't
    return a result
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes that implement the `Callable` interface, to implement tasks that return
    a result
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, an Executor framework uses a `ThreadFactory` interface to create
    the threads that it uses to generate the new threads. In this recipe, you will
    learn how to implement your own thread class, a thread factory to create threads
    of that class, and how to use that factory in an executor, so the executor will
    execute your threads.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the previous recipe, *Implementing a ThreadFactory interface to generate
    custom threads*, and implement its example.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来实现示例：
- en: Copy into the project the classes `MyThread`, `MyThreadFactory`, and `MyTask`
    implemented in the recipe *Implementing a ThreadFactory interface to generate
    custom threads*, so you are going to use them in this example.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在*实现ThreadFactory接口以生成自定义线程*中实现的`MyThread`、`MyThreadFactory`和`MyTask`类复制到项目中，以便在此示例中使用它们。
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类。
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create a new `MyThreadFactory` object named `threadFactory`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`threadFactory`的新`MyThreadFactory`对象。
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Create a new `Executor` object using the `newCachedThreadPool()` method of the
    `Executors` class. Pass the factory object created earlier as a parameter. The
    new `Executor` object will use that factory to create the necessary threads, so
    it will execute `MyThread` threads.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个新的`Executor`对象。将之前创建的工厂对象作为参数传递。新的`Executor`对象将使用该工厂来创建必要的线程，因此它将执行`MyThread`线程。
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create a new `Task` object and send it to the executor using the `submit()`
    method.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象，并使用`submit()`方法将其发送到执行器。
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Shut down the executor using the `shutdown()` method.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器。
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的完成。
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Write a message to indicate the end of the program.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息来指示程序的结束。
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the *How it works...* section of the previous recipe, *Implementing a ThreadFactory
    interface to generate custom threads*, you can read a detailed explanation of
    how the `MyThread`, `MyThreadFactory`, and `MyTask` classes works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例的*How it works...*部分，*实现ThreadFactory接口以生成自定义线程*中，您可以阅读有关`MyThread`、`MyThreadFactory`和`MyTask`类如何工作的详细解释。
- en: In the `main()` method of the example, you have created an `Executor` object
    using the `newCachedThreadPool()` method of the `Executors` class. You have passed
    the factory object created earlier as a parameter, so the `Executor` object created
    will use that factory to create the threads it needs and it will execute threads
    of the `MyThread` class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的`main()`方法中，使用`Executors`类的`newCachedThreadPool()`方法创建了一个`Executor`对象。您已将之前创建的工厂对象作为参数传递，因此创建的`Executor`对象将使用该工厂来创建所需的线程，并执行`MyThread`类的线程。
- en: 'Execute the program and you will see a message with information about the thread''s
    start date and its execution time. The following screenshot shows the output generated
    by this example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，您将看到一个关于线程启动日期和执行时间的信息。以下截图显示了此示例生成的输出：
- en: '![How it works...](img/7881_07_03.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_07_03.jpg)'
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Implementing a ThreadFactory interface to generate custom threads* recipe
    in [Chapter 7](ch07.html "Chapter 7. Customizing Concurrency Classes"), *Customizing
    Concurrency Classes*
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。自定义并发类")的*自定义并发类*中的*实现ThreadFactory接口以生成自定义线程*食谱中
- en: Customizing tasks running in a scheduled thread pool
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义在定时线程池中运行的任务
- en: 'The **scheduled thread pool** is an extension of the basic thread pool of the
    Executor framework that allows you to schedule the execution of tasks to be executed
    after a period of time. It''s implemented by the `ScheduledThreadPoolExecutor`
    class and it permits the execution of the following two kinds of tasks:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时线程池**是Executor框架的基本线程池的扩展，允许您安排任务在一段时间后执行。它由`ScheduledThreadPoolExecutor`类实现，并允许执行以下两种类型的任务：'
- en: '**Delayed tasks**: These kinds of tasks are executed only once after a period
    of time'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟任务**：这种类型的任务在一段时间后只执行一次'
- en: '**Periodic tasks**: These kinds of tasks are executed after a delay and then
    periodically every so often'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期性任务**：这种类型的任务在延迟后定期执行'
- en: Delayed tasks can execute both, the `Callable` and `Runnable` objects, but the
    periodic tasks can only execute `Runnable` objects. All the tasks executed by
    a scheduled pool are an implementation of the `RunnableScheduledFuture` interface.
    In this recipe, you will learn how to implement your own implementation of the
    `RunnableScheduledFuture` interface to execute delayed and periodic tasks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟任务可以执行`Callable`和`Runnable`对象，但周期性任务只能执行`Runnable`对象。定时池执行的所有任务都是`RunnableScheduledFuture`接口的实现。在此示例中，您将学习如何实现自己的`RunnableScheduledFuture`接口的实现来执行延迟和周期性任务。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps described below to implement the example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面描述的步骤来实现示例：
- en: Create a class named `MyScheduledTask` parameterized with a generic type named
    `V`. It extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyScheduledTask`的类，参数化为一个名为`V`的泛型类型。它扩展了`FutureTask`类并实现了`RunnableScheduledFuture`接口。
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Declare a private `RunnableScheduledFuture` attribute named `task`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`task`的私有`RunnableScheduledFuture`属性。
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Declare a private `ScheduledThreadPoolExecutor` named `executor`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`executor`的私有`ScheduledThreadPoolExecutor`。
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Declare a private `long` attribute named `period`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`period`的私有`long`属性。
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Declare a private `long` attribute named `startDate`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`startDate`的私有`long`属性。
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Implement a constructor of the class. It receives the `Runnable` object that
    is going to be executed by a task, the result that will be returned by this task,
    the `RunnableScheduledFuture` task that will be used to create the `MyScheduledTask`
    object, and the `ScheduledThreadPoolExecutor` object that is going to execute
    the task. Call the constructor of its parent class and store the task and `executor`
    attributes.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个类的构造函数。它接收一个将由任务执行的`Runnable`对象，将由此任务返回的结果，将用于创建`MyScheduledTask`对象的`RunnableScheduledFuture`任务，以及将执行任务的`ScheduledThreadPoolExecutor`对象。调用其父类的构造函数并存储任务和`executor`属性。
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Implement the `getDelay()` method. If the task is a periodic task and the `startDate`
    attribute has a value different from zero, calculate the returned value as the
    difference between the `startDate` attribute and the actual date. Otherwise, return
    the delay of the original task stored in the `task` attribute. Don't forget that
    you have to return the result in the time unit passed as a parameter.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getDelay()`方法。如果任务是一个周期性任务，并且`startDate`属性的值不为零，则计算返回值为`startDate`属性和实际日期之间的差值。否则，返回存储在`task`属性中的原始任务的延迟。不要忘记以参数传递的时间单位返回结果。
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Implement the `compareTo()` method. Call the `compareTo()` method of the original
    task.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`compareTo()`方法。调用原始任务的`compareTo()`方法。
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Implement the `isPeriodic()` method. Call the `isPeriodic()` method of the original
    task.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`isPeriodic()`方法。调用原始任务的`isPeriodic()`方法。
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the `run()` method. If it's a periodic task, you have to update its
    `startDate` attribute with the start date of the next execution of the task. Calculate
    it as the sum of the actual date and the period. Then, add the task again to the
    queue of the `ScheduledThreadPoolExecutor` object.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。如果是一个周期性任务，你必须更新它的`startDate`属性，以便将来执行任务的开始日期。计算方法是将实际日期和周期相加。然后，再次将任务添加到`ScheduledThreadPoolExecutor`对象的队列中。
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Print a message with the actual date to the console, execute the task calling
    the `runAndReset()` method, and then print another message with the actual date
    to the console.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印一条带有实际日期的消息，调用`runAndReset()`方法执行任务，然后再次在控制台中打印一条带有实际日期的消息。
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implement the `setPeriod()` method to establish the period of this task.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setPeriod()`方法来设定该任务的周期。
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Create a class named `MyScheduledThreadPoolExecutor` to implement a `ScheduledThreadPoolExecutor`
    object that executes `MyScheduledTask` tasks. Specify that this class extends
    the `ScheduledThreadPoolExecutor` class.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyScheduledThreadPoolExecutor`的类，以实现执行`MyScheduledTask`任务的`ScheduledThreadPoolExecutor`对象。指定该类扩展`ScheduledThreadPoolExecutor`类。
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Implement a constructor of the class which merely calls the constructor of its
    parent class.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个类的构造函数，它仅调用其父类的构造函数。
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Implement the `decorateTask()` method. It receives as a parameter the `Runnable`
    object that is going to be executed and the `RunnableScheduledFuture` task that
    will execute that `Runnable` object. Create and return a `MyScheduledTask` task
    using those objects to construct them.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`decorateTask()`方法。它接收一个将要执行的`Runnable`对象和将执行该`Runnable`对象的`RunnableScheduledFuture`任务作为参数。使用这些对象创建并返回一个`MyScheduledTask`任务。
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Override the `scheduledAtFixedRate()` method. Call the method of its parent
    class, convert the returned object into a `MyScheduledTask` object, and establish
    the period of that task using the `setPeriod()` method.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`scheduledAtFixedRate()`方法。调用其父类的方法，将返回的对象转换为`MyScheduledTask`对象，并使用`setPeriod()`方法设定该任务的周期。
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Create a class named `Task` that implements the `Runnable` interface.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现`Runnable`接口。
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Implement the `run()` method. Print a message at the start of the task, put
    the current thread to sleep 2 seconds, and print another message at the end of
    the task.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。在任务开始时打印一条消息，让当前线程休眠2秒，然后在任务结束时再打印一条消息。
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类和一个`main()`方法来实现示例的主类。
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Create a `MyScheduledThreadPoolExecutor` object named `executor`. Use `2` as
    a parameter to have two threads in the pool.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`executor`的`MyScheduledThreadPoolExecutor`对象。使用`2`作为参数，在池中有两个线程。
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Create a `Task` object named `task`. Write the actual date in the console.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`task`的`Task`对象。在控制台中写下实际日期。
- en: '[PRE80]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Send a delayed task to the executor using the `schedule()` method. The task
    will be executed after a 1 second delay.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`schedule()`方法向执行器发送一个延迟任务。该任务将在1秒延迟后执行。
- en: '[PRE81]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Put the main thread to sleep for 3 seconds.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让主线程休眠3秒。
- en: '[PRE82]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Create another `Task` object. Print the actual date in the console again.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`Task`对象。再次在控制台中打印实际日期。
- en: '[PRE83]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Send a periodic task to the executor using the `scheduleAtFixedRate()` method.
    The task will be executed after a 1 second delay and then will be executed every
    3 seconds.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scheduleAtFixedRate()`方法向执行器发送一个周期性任务。该任务将在1秒延迟后执行，然后每3秒执行一次。
- en: '[PRE84]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Put the main thread to sleep for 10 seconds.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让主线程休眠10秒。
- en: '[PRE85]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Shut down the executor using the `shutdown()` method. Wait for the finalization
    of the executor using the `awaitTermination()` method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器。使用`awaitTermination()`方法等待执行器的完成。
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Write a message in the console indicating the end of the program.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写一条消息，指示程序结束。
- en: '[PRE87]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, you have implemented the `MyScheduledTask` class to implement
    a custom task that can execute on a `ScheduledThreadPoolExecutor` executor. This
    class extends the `FutureTask` class and implements the `RunnableScheduledFuture`
    interface. It implements the `RunnableScheduledFuture` interface, because all
    the tasks executed in a scheduled executor must implement that interface and extend
    the `FutureTask` class, because this class provides valid implementations of the
    methods declared in the `RunnableScheduledFuture` interface. All the interfaces
    and classes mentioned earlier are parameterized classes, with the type of data
    that will be returned by the tasks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您已经实现了`MyScheduledTask`类，以实现可以在`ScheduledThreadPoolExecutor`执行器上执行的自定义任务。该类扩展了`FutureTask`类并实现了`RunnableScheduledFuture`接口。它实现了`RunnableScheduledFuture`接口，因为在计划的执行器中执行的所有任务都必须实现该接口并扩展`FutureTask`类，因为该类提供了在`RunnableScheduledFuture`接口中声明的方法的有效实现。之前提到的所有接口和类都是参数化类，具有将由任务返回的数据类型。
- en: To use a `MyScheduledTask` task in a scheduled executor, you have overridden
    the `decorateTask()` method in the `MyScheduledThreadPoolExecutor` class. This
    class extends the `ScheduledThreadPoolExecutor` executor and that method provides
    a mechanism to convert the default scheduled tasks implemented by the `ScheduledThreadPoolExecutor`
    executor to `MyScheduledTask` tasks. So, when you implement your own version of
    scheduled tasks, you have to implement your own version of a scheduled executor.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计划的执行器中使用`MyScheduledTask`任务，您已经覆盖了`MyScheduledThreadPoolExecutor`类中的`decorateTask()`方法。该类扩展了`ScheduledThreadPoolExecutor`执行器，该方法提供了一种将`ScheduledThreadPoolExecutor`执行器实现的默认计划任务转换为`MyScheduledTask`任务的机制。因此，当您实现自己的计划任务版本时，必须实现自己的计划执行器的版本。
- en: The `decorateTask()` method simply creates a new `MyScheduledTask` object with
    the parameter; a `Runnable` object that is going to be executed in the task. A
    resultant object that is going to be returned by that task. In this case, the
    task won't return a result, so you used the `null` value. An original task is
    used to execute the `Runnable` object. This is the task that the new object is
    going to replace in the pool; an executor that is going to execute the task. In
    this case, you use the `this` keyword to reference the executor that is creating
    the task.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decorateTask()`方法只是使用参数创建一个新的`MyScheduledTask`对象；一个将在任务中执行的`Runnable`对象。该任务将返回一个结果。在这种情况下，任务不会返回结果，因此使用了`null`值。原始任务用于执行`Runnable`对象。这是新对象将在池中替换的任务；将执行任务的执行器。在这种情况下，您使用`this`关键字引用创建任务的执行器。'
- en: The `MyScheduledTask` class can execute delayed and periodic tasks. You have
    implemented two methods with all the necessary logic to execute both kinds of
    tasks. They are the `getDelay()` and the `run()` methods.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyScheduledTask`类可以执行延迟和周期性任务。您已经实现了两种任务的所有必要逻辑的两种方法，它们是`getDelay()`和`run()`方法。'
- en: The `getDelay()` method is called by the scheduled executor to know if it has
    to execute a task. The behavior of this method changes in delayed and periodic
    tasks. As we mentioned earlier, the constructor of the `MyScheduledClass` class
    receives the original `ScheduledRunnableFuture` object that was going to execute
    the `Runnable` object and stores it as an attribute of the class to have access
    to its methods and its data. When we are going to execute a delayed task, the
    `getDelay()` method returns the delay of the original task, but in the case of
    the periodic task, the `getDelay()` method returns the difference between the
    `startDate` attribute and the actual date.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduled executor`调用`getDelay()`方法来确定是否执行任务。此方法在延迟和周期性任务中的行为不同。正如我们之前提到的，`MyScheduledClass`类的构造函数接收原始的`ScheduledRunnableFuture`对象，该对象将执行`Runnable`对象，并将其存储为类的属性，以便访问其方法和数据。当要执行延迟任务时，`getDelay()`方法返回原始任务的延迟，但是对于周期性任务，`getDelay()`方法返回`startDate`属性与实际日期之间的差异。'
- en: The `run()` method is the one that executes the task. One particularity of the
    periodic tasks is that you have to put the next execution of the task in the queue
    of the executor as a new task if you want the task to be executed again. So, if
    you're executing a periodic task, you establish the `startDate` attribute value
    adding to the actual date and the period of execution of the task and store the
    task again in the queue of the executor. The `startDate` attribute stores the
    date when the next execution of the task will begin. Then, you execute the task
    using the `runAndReset()` method provided by the `FutureTask` class. In the case
    of the delayed tasks, you don't have to put them in the queue of the executor,
    because they only execute once.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法是执行任务的方法。周期性任务的一个特点是，如果要再次执行任务，您必须将任务的下一次执行放入执行器的队列中作为新任务。因此，如果要执行周期性任务，您要确定`startDate`属性的值，将其添加到实际日期和任务执行的周期，并将任务再次存储在执行器的队列中。`startDate`属性存储了任务的下一次执行将开始的日期。然后，您使用`FutureTask`类提供的`runAndReset()`方法执行任务。对于延迟任务，您不必将它们放入执行器的队列中，因为它们只执行一次。'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You have also to take into account if the executor has been shutdown. In that
    case, you don't have to store again the periodic tasks into the queue of the executor.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须考虑执行器是否已关闭。在这种情况下，您不必再将周期性任务存储到执行器的队列中。
- en: Finally, you have overridden the `scheduleAtFixedRate()` method in the `MyScheduledThreadPoolExecutor`
    class. We mentioned earlier that, for periodic tasks, you establish the value
    of the `startDate` attribute using the period of the task, but you haven't initialized
    that period yet. You have to override this method that receives that period as
    a parameter, to pass it to the `MyScheduledTask` class so it can use it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您已经覆盖了`MyScheduledThreadPoolExecutor`类中的`scheduleAtFixedRate()`方法。我们之前提到，对于周期性任务，您要使用任务的周期来确定`startDate`属性的值，但是您还没有初始化该周期。您必须覆盖此方法，该方法接收该周期作为参数，然后将其传递给`MyScheduledTask`类，以便它可以使用它。
- en: 'The example is complete with the `Task` class that implements the `Runnable`
    interface and is the task executed in the scheduled executor. The main class of
    the example creates a `MyScheduledThreadPoolExecutor` executor and sends the following
    two tasks to them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: A delayed task, to be executed 1 second after the actual date
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A periodic task, to be executed for the first time 1 second after the actual
    date and then every 3 seconds
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the execution of this example. You can
    check as the two kinds of tasks are executed properly:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_04.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ScheduledThreadPoolExecutor` class provides another version of the `decorateTask()`
    method that receives a `Callable` object as a parameter instead of a `Runnable`
    object.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running a task in an executor after a delay* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running a task in an executor periodically* recipe [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ThreadFactory interface to generate custom threads for the
    Fork/Join framework
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting features of Java 7 is the Fork/Join framework. It's
    an implementation of the `Executor` and `ExecutorService` interfaces that allow
    you the execution of the `Callable` and `Runnable` tasks without managing the
    threads that execute them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'This executor is oriented to execute tasks that can be divided into smaller
    parts. Its main components are as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: A special kind of task, implemented by the `ForkJoinTask` class.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two operations for dividing a task into subtasks (the `fork` operation) and
    to wait for the finalization of those subtasks (the `join` operation).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An algorithm, denominating the work-stealing algorithm, that optimizes the use
    of the threads of the pool. When a task is waiting for its subtasks, the thread
    that was executing it is used to execute another thread.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main class of the Fork/Join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement a customized worker thread to
    be used in a `ForkJoinPool` class and how to use it using a factory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyWorkerThread` that extends the `ForkJoinWorkerThread`
    class.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Declare and create a private `ThreadLocal` attribute parameterized with the
    `Integer` class named `taskCounter`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Implement a constructor of the class.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Override the `onStart()` method. Call the method on its parent class, print
    a message to the console, and set the value of the `taskCounter` attribute for
    this thread to zero.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Override the `onTermination()` method. Write the value of the `taskCounter`
    attribute for this thread in the console.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Implement the `addTask()` method. Increment the value of the `taskCounter` attribute.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Create a class named `MyWorkerThreadFactory` that implements the `ForkJoinWorkerThreadFactory`
    interface. Implement the `newThread()` method. Create and return a `MyWorkerThread`
    object.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Create a class named `MyRecursiveTask` that extends the `RecursiveTask` class
    parameterized with the `Integer` class.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Declare a private `int` array named `array`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Declare two private `int` attributes named `start` and `end`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Implement the constructor of the class that initializes its attributes.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Implement the `compute()` method to sum all the elements of the array between
    the start and end positions. First, convert the thread that is executing the task
    into a `MyWorkerThread` object and use the `addTask()` method to increment the
    counter of tasks for that thread.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Implement the `addResults()` method. Calculate and return the sum of the results
    of the two tasks received as parameters.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Put the thread to sleep for 10 milliseconds and return the result of the task.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Create a `MyWorkerThreadFactory` object named `factory`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Create a `ForkJoinPool` object named `pool`. Pass to the constructor the factory
    object created earlier.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Create an array of 100,000 integers. Initialize all the elements to `1`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Create a new `Task` object to sum all the elements of the array.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Send the task to the pool using the `execute()` method.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Wait for the end of the task using the `join()` method.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Shut down the pool using the `shutdown()` method.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Write in the console the result of the task using the `get()` method.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Write a message in the console indicating the end of the example.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Threads used by the Fork/Join framework are called worker threads. Java includes
    the `ForkJoinWorkerThread` class that extends the `Thread` class and implements
    the worker threads used by the Fork/Join framework.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyWorkerThread` class that extends
    the `ForkJoinWorkerThread` class and overrides two methods of that class. Your
    objective is to implement a counter of tasks in each worker thread so you can
    know how many tasks a worker thread has executed. You have implemented the counter
    with a `ThreadLocal` attribute. This way, each thread will have its own counter
    in a transparent way for you, the programmer.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: You have overridden the `onStart()` method of the `ForkJoinWorkerThread` class
    to initialize the task counter. This method is called when the worker thread begins
    its execution. You also have overridden the `onTermination()` method to print
    the value of the task counter to the console. This method is called when the worker
    thread finishes its execution. You have also implemented a method in the `MyWorkerThread`
    class. The `addTask()` method increments the task counter of each thread.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class, as all the executors in the Java concurrency API,
    creates its threads using a factory, so if you want to use the `MyWorkerThread`
    threads in a `ForkJoinPool` class, you have to implement your thread factory.
    For the Fork/Join framework, this factory has to implement the `ForkJoinPool.ForkJoinWorkerThreadFactory`
    class. You have implemented the `MyWorkerThreadFactory` class for this purpose.
    This class only has one method that creates a new `MyWorkerThread` object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you only have to initialize a `ForkJoinPool` class with the factory
    you have created. You have done this in the `Main` class, using the constructor
    of the `ForkJoinPool` class.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_05.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: You can see how the `ForkJoinPool` object has executed four worker threads and
    how many tasks have executed each of them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take into account that the `onTermination()` method provided by the `ForkJoinWorkerThread`
    class is called when a thread finishes normally or throws an `Exception` exception.
    The method receives a `Throwable` object as a parameter. If the parameter takes
    the `null` value, the worker thread finishes normally, but if the parameter takes
    a value, the thread throws an exception. You have to include the necessary code
    to process that situation.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Create a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating Threads through a factory* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread Management*
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing tasks running in the Fork/Join framework
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework separates the task creation and its execution. With it,
    you only have to implement the `Runnable` objects and use an `Executor` object.
    You send the `Runnable` tasks to the executor and it creates, manages, and finalizes
    the necessary threads to execute those tasks.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 provides a special kind of executor in the Fork/Join framework. This
    framework is designed to solve those problems that can be broken into smaller
    tasks using the divide and conquer technique. Inside a task, you have to check
    the size of the problem you want to resolve and, if it's bigger than an established
    size, you divide the problem in two or more tasks and execute those tasks using
    the framework. If the size of the problem is smaller than the established size,
    you resolve the problem directly in the task and then, optionally, it returns
    a result. The Fork/Join framework implements the work-stealing algorithm that
    improves the overall performance of these kinds of problems.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The main class of the Fork/Join framework is the `ForkJoinPool` class. Internally,
    it has the following two elements:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: A queue of tasks that are waiting to be executed
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pool of threads that execute the tasks
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the tasks executed by a `ForkJoinPool` class are objects of the
    `ForkJoinTask` class. You also can send to a `ForkJoinPool` class the `Runnable`
    and `Callable` objects, but they can''t take advantage of all the benefits of
    the Fork/Join framework. Normally, you will send to the `ForkJoinPool` objects
    one of two subclasses of the `ForkJoinTask` class:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '`RecursiveAction`: If your tasks don''t return a result'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecursiveTask`: If your tasks return a result'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own tasks for the Fork/Join
    framework implementing a task that extends the `ForkJoinTask` class. The task
    you're going to implement measures and writes in the console its execution time,
    so you can control its evolution. You can also implement your own Fork/Join task
    to write log information, to get resources used in the tasks, or to post-process
    the results of the tasks.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyWorkerTask` and specify that it extends the `ForkJoinTask`
    class parameterized with the `Void` type.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Declare a private `String` attribute named `name` to store the name of the task.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Implement the `getRawResult()` method. This is one of the abstract methods of
    the `ForkJoinTask` class. As the `MyWorkerTask` tasks won't return any result,
    this method must return the `null` value.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Implement the `setRawResult()` method. This is another abstract method of the
    `ForkJoinTask` class. As the `MyWorkerTask` tasks won't return any result, leave
    the body of this method empty.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Implement the `exec()` method. This is the main method of the task. In this
    case, delegate the logic of the task to the `compute()` method. Calculate the
    execution time of that method and write it in the console.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Implement the `getName()` method to return the name of the task.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Declare the abstract method `compute()`. As we mentioned earlier, this method
    will implement the logic of the tasks and must be implemented by the child classes
    of the `MyWorkerTask` class.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Create a class named `Task` that extends the `MyWorkerTask` class.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Declare a private array of `int` values named `array`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Implement a constructor of the class that initializes its attributes.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Implement the `compute()` method. This method increments the block of elements
    of the array determined by the start and end attributes. If this block of elements
    has more than 100 elements, divide the block in two parts and create two `Task`
    objects to process each part. Send those tasks to the pool using the `invokeAll()`
    method.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: If the block of elements has less than 100 elements, increment all the elements
    using a `for` loop.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Finally, put the thread that is executing the task to sleep for 50 milliseconds.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main(`) method.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Create an `int` array of 10,000 elements.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Create a `ForkJoinPool` object named `pool`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Create a `Task` object to increment all the elements of the array. The parameters
    of the constructor are `Task` as the name of the task, the array object, and the
    values `0` and `10000` to indicate to this task that it has to process the entire
    array.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Send the task to the pool using the `execute()` method.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Shut down the pool using the `shutdown()` method.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Write a message in the console indicating the end of the program.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: How it works...
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyWorkerTask` class that extends the
    `ForkJoinTask` class. It's your own base class to implement tasks that can be
    executed in a `ForkJoinPool` executor and that can take advantage of all the benefits
    of that executor, as the work-stealing algorithm. This class is equivalent to
    the `RecursiveAction` and `RecursiveTask` classes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'When you extend the `ForkJoinTask` class, you have to implement the following
    three methods:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '`setRawResult()`: This method is used to establish the result of the task.
    As your tasks don''t return any results, you leave this method empty.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRawResult()`: This method is used to return the result of the task. As
    your tasks don''t return any results, this method returns the `null` value.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec()`: This method implements the logic of the task. In your case, you have
    delegated the logic in the abstract method `compute()` (as the `RecursiveAction`
    and `RecursiveTask` classes) and in the `exec()` method you measure the execution
    time of that method, writing it in the console.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the main class of the example, you have created an array of 10,000
    elements, a `ForkJoinPool` executor, and a `Task` object to process the whole
    array. Execute the program and you'll see how the different tasks that are executed
    write their execution time in the console.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the Fork/Join framework* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom Lock class
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Locks are one of the basic synchronization mechanisms provided by the Java
    concurrency API. It allows the programmers to protect a critical section of code,
    so only one thread can execute that block of code at a time. It provides the following
    two operations:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '`lock()`: You call this operation when you want to access a critical section.
    If there is another thread running that critical section, other threads are blocked
    until they''re woken up by the lock to get the access to the critical section.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlock()`: You call this operation at the end of the critical section, to
    allow other threads to access the critical section.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Java Concurrency API, locks are declared in the `Lock` interface and
    implemented in some classes, for example, the `ReentrantLock` class.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement your own `Lock` object implementing
    a class that implements the `Lock` interface that can be used to protect a critical
    section.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyQueuedSynchronizer` that extends the `AbstractQueuedSynchronizer`
    class.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Declare a private `AtomicInteger` attribute named `state`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Implement the`tryAcquire()` method. This method tries to change the value of
    the state variable from zero to one. If it can, it returns the `true` value else
    it returns `false`.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Implement the `tryRelease()` method. This method tries to change the value of
    the state variable from one to zero. If it can, it returns the `true` value else
    it returns the `false` value.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Create a class named `MyLock` and specify that it implements the `Lock` interface.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Declare a private `AbstractQueuedSynchronizer` attribute named `sync`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Implement the constructor of the class to initialize the `sync` attribute with
    a new `MyAbstractQueueSynchronizer` object.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Implement the `lock()` method. Call the `acquire()` method of the `sync` object.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Implement the `lockInterruptibly()` method. Call the `acquireInterruptibly()`
    method of the `sync` object.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Implement the `tryLock()` method. Call the `tryAcquireNanos()` method of the
    `sync` object.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Implement another version of the `tryLock()` method with two parameters. A long
    parameter named `time` and a `TimeUnit` parameter named `unit`. Call the `tryAcquireNanos()`
    method of the `sync` object.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Implement the `unlock()` method. Call the `release()` method of the `sync` object.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Implement the `newCondition()` method. Create a new object of the internal class
    of the `sync` object `ConditionObject`.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Declare a private `MyLock` attribute named `lock`.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Declare a private `String` attribute named `name`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Implement the`run()` method of the class. Acquire the lock, put the thread to
    sleep for 2 seconds and then, release the `lock` object.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Create a `MyLock` object named `lock`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Create and execute 10 `Task` tasks.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Try to get the lock using the `tryLock()` method. Wait for a second and if you
    don't get the lock, write a message and try again.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Write a message indicating that you got the lock and release it.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Write a message indicating the end of the program.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: How it works...
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java Concurrency API provides a class that can be used to implement synchronization
    mechanisms with features of locks or semaphores. It''s `AbstractQueuedSynchronizer`
    and, as its name suggests, it''s an abstract class. It provides operations to
    control access to a critical section and to manage a queue of threads that are
    blocked awaiting access to the critical section. The operations are based on two
    abstract methods:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method is called to try to get access to a critical section.
    If the thread that calls it can access the critical section, the method returns
    the `true` value. Otherwise, the method returns the `false` value.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryRelease()`: This method is called to try to release access to a critical
    section. If the thread that calls it can release the access, the method returns
    the `true` value. Else, the method returns the `false` value.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these methods, you have to implement the mechanism you use to control the
    access to the critical section. In your case, you have implemented the `MyQueuedSynchonizer`
    class that extends the `AbstractQueuedSyncrhonizer` class and implements the abstract
    methods using an `AtomicInteger` variable to control the access of the critical
    section. That variable will store the `0` value if the lock is free, so a thread
    can have access to the critical section, and the `1` value if the lock is blocked,
    so a thread can't have access to the critical section.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: You have used the `compareAndSet()` method provided by the `AtomicInteger` class
    that tries to change the value you specify as the first parameter for the value
    you specify as the second parameter. To implement the `tryAcquire()` method, you
    try to change the value of the atomic variable from zero to one. Similarly, to
    implement the `tryRelease()` method, you try to change the value of the atomic
    variable from one to zero.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: You have to implement this class because other implementations of the `AbstractQueuedSynchronizer`
    class (for example, the one used by the `ReentrantLock` class), are implemented
    as private classes internally in the class that uses it, so you don't have access
    to it.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have implemented the `MyLock` class. This class implements the `Lock`
    interface and has a `MyQueuedSynchronizer` object as an attribute. To implement
    all the methods of the `Lock` interface, you have used methods of the `MyQueuedSynchronizer`
    object.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you have implemented the `Task` class, that implements the `Runnable`
    interface and uses a `MyLock` object to get the access to a critical section.
    That critical section puts the thread to sleep for 2 seconds. The main class creates
    a `MyLock` object and runs 10 `Task` objects that share that lock. The main class
    also tries to get the access to the lock using the `tryLock()` method.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the example, you can see how only one thread has access to
    the critical section and when that thread finishes, another one gets the access
    to it.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: You can use your own `Lock` to write log messages about its utilization, control
    the time that is locked, or implement advanced synchronization mechanisms, to
    control, for example, the access to a resource so that it's only available at
    certain times.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AbstractQueuedSynchronizer` class provides two methods that can be used
    to manage the state of the lock. They are the `getState()` and `setState()` methods.
    These methods receive and return an integer value with the state of the lock.
    You could have used those methods instead of the `AtomicInteger` attribute to
    store the state of the lock.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Java concurrency API provides another class to implement synchronization mechanisms.
    It's the `AbstractQueuedLongSynchronizer` class, that is equivalent to the `AbstractQueuedSynchronizer`
    class, but uses a `long` attribute to store the state of the threads.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a transfer Queue based on priorities
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 7 API provides several data structures to work with concurrent applications.
    From these, we want to highlight the following two data structures:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedTransferQueue`: This data structure is supposed to be used in those
    programs that have a producer/consumer structure. In those applications, you have
    one or more producers of data and one or more consumers of data and a data structure
    is shared by all of them. The producers put data in the data structure and the
    consumers take data from the data structure. If the data structure is empty, the
    consumers are blocked until they have data to consume. If the data structure is
    full, the producers are blocked until they have space to put their data.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue`: In this data structure, elements are stored in an
    ordered way. The elements have to implement the `Comparable` interface with the
    `compareTo()` method. When you insert an element in the structure, it''s compared
    to the elements of the structure until it finds its position.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements of the `LinkedTransferQueue` are stored in the same order as they arrive,
    so earlier arrivals are consumed first. It may be the case when you want to develop
    a producer/consumer program, where data is consumed according to some priority
    instead of arrival time. In this recipe, you will learn how to implement a data
    structure to be used in the producer/consumer problem, whose elements will be
    ordered by their priority. Those elements with higher priority will be consumed
    first.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `MyPriorityTransferQueue` that extends the `PriorityBlockingQueue`
    class and implements the `TransferQueue` interface.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Declare a private `AtomicInteger` attribute named `counter` to store the number
    of consumers that are waiting for elements to consume.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Declare a private `LinkedBlockingQueue` attribute named `transferred`.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Declare a private `ReentrantLock` attribute named `lock`.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Implement the `tryTransfer()` method. This method tries to send the element
    to a waiting consumer immediately, if possible. If there isn't any waiting consumer,
    the method returns the `false` value.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Implement the `transfer()` method. This method tries to send the element to
    a waiting consumer immediately, if possible. If there isn't a waiting consumer,
    the method stores the element in a special queue to be sent to the first consumer
    that tries to get an element and blocks the thread until the element is consumed.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Implement the `tryTransfer()` method that receives three parameters: The element,
    the time to wait for a consumer, if there is none, and the unit of time used to
    specify that time. If there is a consumer waiting, it sends the element immediately.
    Otherwise, convert the time specified to milliseconds and use the `wait()` method
    to put the thread to sleep. When the consumer takes the element, if the thread
    is sleeping in the `wait()` method, you are going to wake it up using the `notify()`
    method as you''ll see in a moment.'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Implement the `hasWaitingConsumer()` method. Use the value of the counter attribute
    to calculate the return value of this method. If the counter has a value bigger
    than zero, return `true`. Else, return `false`.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Implement the `getWaitingConsumerCount()` method. Return the value of the `counter`
    attribute.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Implement the `take()` method. This `method` is called by the consumers when
    they want an element to consume. First, get the lock defined earlier and increment
    the number of waiting consumers.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: If there aren't any elements in the transferred queue, free the lock and try
    to get an element from the queue using the `take()` element and get the lock again.
    If there aren't any elements in the queue, this method will put the thread to
    sleep until there are elements to consume.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Otherwise, take the element from the transferred queue and wake up the thread
    that is waiting for the consummation of that element, if there is one.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Finally, decrement the counter of waiting consumers and free the lock.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Implement a class named `Event` that extends the `Comparable` interface parameterized
    with the `Event` class.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Declare a private `String` attribute named `thread` to store the name of the
    thread that creates the event.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Declare a private `int` attribute named `priority` to store the priority of
    the event.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Implement a method to return the value of the thread attribute.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Implement a method to return the value of the priority attribute.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Implement the `compareTo()` method. This method compares the actual event with
    an event received as a parameter. Return `-1` if the actual event has a bigger
    priority than the parameter, `1` if the actual event has a lower priority than
    the parameter, and `0` if both events have the same priority. You will get the
    list ordered by priority in the descending order. Events with higher priority
    will be stored first in the queue.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Implement a class named `Producer` that implements the `Runnable` interface.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Declare a private `MyPriorityTransferQueue` attribute parameterized with the
    `Event` class named `buffer` to store the events generated by this producer.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Implement the `run()` method of the class. Create 100 `Event` objects using
    its order of creation as priority (the latest event will have the highest priority)
    and insert them in the queue using the `put()` method.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Implement a class named `Consumer` that implements the `Runnable` interface.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Declare a private `MyPriorityTransferQueue` attribute parameterized with the
    `Event` class named buffer to get the events consumed by this class.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Implement the `run()` method. It consumes 1002 `Events` (all the events generated
    in the example) using the `take()` method and write the number of the thread that
    generated the event and its priority in the console.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Create a `MyPriorityTransferQueue` object named `buffer`.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Create a `Producer` task and launch 10 threads to execute that task.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Create and launch a `Consumer` task.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Write in the console the actual consumer count.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Transfer an event to the consumer using the `transfer()` method.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Wait for the finalization of the producers using the `join()` method.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Put the thread to sleep for 1 second.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Write the actual consumer count.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Transfer another event using the `transfer()` method.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Wait for the finalization of the consumer using the `join()` method.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Write a message indicating the end of the program.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: How it works...
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have implemented the `MyPriorityTransferQueue` data structure.
    It's a data structure to be used in the producer/consumer problem, but its elements
    are ordered by priority, not by their arrival order. As Java doesn't allow multiple
    inheritance, the first decision you have taken is the base class of the `MyPriorityTransferQueue`
    class. You have extended the `PriorityBlockingQueue` class, to have implemented
    the operations that insert the elements in the structure ordered by priority.
    You also have implemented the `TransferQueue` interface to add the methods related
    with the producer/consumer.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MyPriortyTransferQueue` class have the following three attributes:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AtomicInteger` attribute, named `counter`: This attribute stores the number
    of consumers that are waiting for taking an element for the data structure. When
    a consumer calls the `take()` operation to take an element from the data structure,
    the counter is incremented. When the consumer finishes the execution of the `take()`
    operation, the counter is decremented again. This counter is used in the implementation
    of the `hasWaitingConsumer()` and `getWaitingConsumerCount()` methods.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `ReentrantLock` attribute named `lock`: This attribute is used to control
    the access to the implemented operations. Only one thread can be working with
    the data structure.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a `LinkedBlockingQueue` list to store the transferred elements.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have implemented some methods in the `MyPriorityTransferQueue`. All the
    methods are declared in the `TransferQueue` interface and the `take()` method
    implemented in the `PriorityBlockingQueue` interface. Two of them were described
    before. Here is a description of the rest:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '`tryTransfer(E``e)`: This method tries to send an element directly to a consumer.
    If there is a consumer waiting, the method stores the element in the priority
    queue to be consumed immediately by the consumer and then returns the `true` value.
    If there isn''t a consumer waiting, the method returns the `false` value.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer(E``e)`: This method transfers an element directly to a consumer.
    It there is a consumer waiting, the method stores the element in the priority
    queue to be consumed immediately by the consumer. Otherwise, the element is stored
    in the list for transferred elements and the thread is blocked until the element
    is consumed. While the thread is put to sleep, you have to free the lock because
    if not, you block the queue.'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryTransfer(E``e,``long``timeout,``TimeUnit``unit)`: This method is similar
    to the `transfer()` method, but the thread blocks the period of time determined
    by its parameters. While the thread is put to sleep, you have to free the lock
    because, if not, you block the queue.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns the next element to be consumed. If there are
    elements in the list of transferred elements, the element to be consumed is taken
    from that list. Otherwise, it is taken from the priority queue.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have implemented the data structure, you have implemented the `Event`
    class. It is the class of the elements you have stored in the data structure.
    The `Event` class has two attributes to store the ID of the producer and the priority
    of the event, and implements the `Comparable` interface, because it is a requirement
    of your data structure.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have implemented the `Producer` and the `Consumer` classes. In the
    example, you have 10 producers and a consumer and they share the same buffer.
    Each producer generates 100 events with incremental priority, so the events with
    higher priority are the last generated ones.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: The main class of example creates a `MyPriorityTransferQueue` object, 10 producers,
    and a consumer and uses the `transfer()` method of the `MyPriorityTransferQueue`
    buffer to transfer two events to the buffer.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_07_06.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
- en: You can see how the events with higher priority are consumed first, and that
    a consumer consumes the transferred event.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your own atomic object
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic variables were introduced in Java Version 5 and provide atomic operations
    on single variables. When a thread is doing an operation with an atomic variable,
    the implementation of the class includes a mechanism to check that the operation
    is done in one step. Basically, the operation gets the value of the variable,
    changes the value in a local variable, and then tries to change the old value
    for the new one. If the old value is still the same, it does the change. If not,
    the method begins the operation again.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to extend an atomic object and how to implement
    two operations that follow the mechanisms of the atomic objects to guarantee that
    all the operations are done in one step.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `ParkingCounter` and specify that it extends the `AtomicInteger`
    class.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Declare a private `int` attribute named `maxNumber` to store the maximum number
    of cars admitted in the parking lot.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Implement the `carIn()` method. This method increments the counter of cars if
    it has a value smaller than the established maximum value. Construct an infinite
    loop and get the value of the internal counter using the `get()` method.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: If the value is equal to the `maxNumber` attribute, the counter can't be incremented
    (the parking lot is full and the car can't enter). The method returns the `false`
    value.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Otherwise, increment the value and use the `compareAndSet()` method to change
    the old value to the new one. This method returns the `false` value; the counter
    was not incremented, so you have to begin the loop again. If it returns the `true`
    value, it means the change was made and then, you return the `true` value.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Implement the `carOut()` method. This method decrements the counter of cars
    if it has a value bigger than `0`. Construct an infinite loop and get the value
    of the internal counter using the `get()` method.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Create a class named `Sensor1` that implements the `Runnable` interface.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Declare a private `ParkingCounter` attribute named `counter`.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Implement the `run()` method. Call the `carIn()` and `carOut()` operations several
    times.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Create a class named `Sensor2` that implements the `Runnable` interface.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Declare a private `ParkingCounter` attribute named `counter`.
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Implement the `run()` method. Call the `carIn()` and `carOut()` operations several
    times.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Create a `ParkingCounter` object named `counter`.
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Create and launch a `Sensor1` task and a `Sensor2` task.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Wait for the finalization of both tasks.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Write in the console the actual value of the counter.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Write in the console a message indicating the end of the program.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: How it works...
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ParkingCounter` class extends the `AtomicInteger` class with two atomic
    operations, `carIn()` and `carOut()`. The example simulates a system that controls
    the number of cars inside a parking lot. The parking lot can admit a number of
    cars, represented by the `maxNumber` attribute.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'The `carIn()` operation compares the actual number of cars in the parking lot
    with the maximum value. If they are equal, the car can''t enter the parking lot
    and the method returns the `false` value. Otherwise, it uses the following structure
    of the atomic operations:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Get the value of the atomic object in a local variable.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the new value in a different variable.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `compareAndSet()` method to try to replace the old value by the new
    one. If this method returns the `true` value, the old value you sent as a parameter
    was the value of the variable, so it makes the change of values. The operation
    was made in an atomic way as the `carIn()` method returns the `true` value. If
    the `compareAndSet()` method returns the `false` value, the old value you sent
    as a parameter is not the value of the variable (the other thread modified it),
    so the operation can't be done in an atomic way. The operation begins again until
    it can be done in an atomic way.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `carOut()` method is analogous to the `carIn()` method. You have also implemented
    two `Runnable` objects that use the `carIn()` and `carOut()` methods to simulate
    the activity of the parking. When you execute the program, you can see that the
    parking lot never overcomes the maximum value of cars in the parking lot.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
