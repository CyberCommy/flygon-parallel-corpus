- en: Chapter 6. Context Map – The Big Picture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。上下文地图-整体情况
- en: The dungeon manager application, for now, only contains the functionality to
    manage prisoner transportation, but as our application grows, the need to organize
    the code increases as well. The number of developers able to concurrently work
    on a piece of software is limited. Jeff Bezos (founder and CEO of Amazon.com)
    once stated that the size of a team should be no more than that can be fed by
    two pizzas ([http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200](http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200)).
    The idea is that any team larger than this will have trouble with communication
    as the number of connections within this team grows very quickly. As we add more
    people, the amount of communication needed to keep everybody up to date grows
    as well, and sooner or later the team will be slowed down by its constant need
    for meetings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢管理应用程序目前只包含管理囚犯运输的功能，但随着我们应用程序的增长，组织代码的需求也在增加。能够同时在一款软件上工作的开发人员数量有限。亚马逊创始人兼首席执行官杰夫·贝索斯曾经说过，一个团队的规模不应该超过两个披萨所能满足的人数。这个想法是，任何比这更大的团队在沟通方面都会遇到麻烦，因为团队内部的联系数量会迅速增长。随着我们增加更多的人，保持每个人都了解最新情况所需的沟通量也会增加，团队迟早会因为不断需要开会而变慢。
- en: 'This fact causes somewhat of a dilemma because, as we described earlier, the
    perfect application would be one where everybody would know everything about how
    the development happened and how the decisions around the changes were made. This
    leaves us with very few options: we can either decide to not grow the team, building
    the application but opting for a slower development cycle that can be handled
    by this team alone (along with a smaller feature-set on the application as a whole),
    or alternatively we can try to make multiple teams work on the same application.
    Both strategies have been successful as far as business goes. Staying small and
    growing naturally, while most likely not resulting in hockey-stick growth can
    result in a well run and successful company as the likes of Basecamp Inc. and
    other independent software developers have proved. On the other hand, this does
    not work for applications that are inherently complex and aim for a much broader
    scope, so the likes of Amazon and Netflix, for example, started growing their
    teams around the idea of creating a larger application comprising of smaller parts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实造成了一种困境，因为正如我们之前所描述的，完美的应用程序应该是每个人都了解开发过程以及围绕变化做出决策的应用程序。这给我们留下了很少的选择：我们可以决定不扩大团队，构建应用程序，但选择一个更慢的开发周期，这个团队可以独立处理（以及整个应用程序上的较小功能集），或者我们可以尝试让多个团队共同开发同一个应用程序。这两种策略在商业上都取得了成功。保持小规模并自然增长，虽然可能不会导致爆发式增长，但可以导致一个运行良好且成功的公司，就像Basecamp
    Inc.和其他独立软件开发者所证明的那样。另一方面，这对于固有复杂性并且目标范围更广的应用程序来说是行不通的，因此亚马逊和Netflix等公司开始围绕创建由较小部分组成的更大应用程序的理念来扩大他们的团队。
- en: 'Assuming that we opt for the idea of domain-driven design, we more likely have
    an application that is part of the inherently complex realm, so the following
    chapter will introduce some common ways to handle this scenario. One important
    point not to miss when designing an application like this is that we should always
    strive to reduce complexity as far as possible. You will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择领域驱动设计的理念，我们更有可能拥有一个属于固有复杂领域的应用程序，因此接下来的章节将介绍处理这种情况的一些常见方法。在设计这样的应用程序时不容忽视的一个重要点是，我们应该始终努力尽可能减少复杂性。你将学到：
- en: How to organize a growing application technically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在技术上组织不断增长的应用程序
- en: How to test the integration of applications in a system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试系统中应用程序的集成
- en: How to organize expanding contexts in the application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织应用程序中不断扩展的上下文
- en: Don't fear the monolith
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要害怕单体应用
- en: In recent times, there has been a strong move toward breaking applications apart
    and designing them as a set of services communicating via messages. This is a
    well-established concept for large-scale applications; the problem is finding
    the correct time to break the application apart and also deciding whether breaking
    it apart is the right thing to do. When we break an application into multiple
    services, we increase the complexity at this point since we now have to deal with
    handling communication problems crossing multiple services. We have to consider
    the resilience of the services, and the dependencies each service has, to provide
    its features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 近来，人们开始更加倾向于将应用程序拆分并设计成一组通过消息进行通信的服务。这对于大规模应用程序来说是一个成熟的概念；问题在于找到正确的时间来拆分应用程序，以及决定是否拆分是正确的做法。当我们将一个应用程序拆分成多个服务时，这一点会增加复杂性，因为现在我们必须处理跨多个服务的通信问题。我们必须考虑服务的弹性以及每个服务提供其功能所需的依赖关系。
- en: On the other hand, when we break an application apart at a late stage, problems
    arise when extracting logic from the application. There is no reason why a monolith
    application can't be well-factored and remain easy to maintain for a long time.
    Breaking up an application will always cause problems, and staying with a well-factored
    application for a long time works. The problem is that a large codebase with a
    lot of developers working on it is more likely to deteriorate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们在后期拆分应用程序时，从应用程序中提取逻辑会出现问题。没有理由一个单体应用程序不能被很好地因素化，并且在很长一段时间内保持易于维护。拆分应用程序总会带来问题，而长期保持一个良好因素化的应用程序是可行的。问题在于，一个代码库庞大且有很多开发人员在上面工作的情况更容易恶化。
- en: How can we avoid such problems? The best way is to design the application in
    a way that breaks it up as simply as possible but keeps the problem of communication
    between sub-systems out of the picture for as long as possible. This is what a
    strong domain model excels at; the domain will allow us to have strong separation
    from the underlying frameworks, but also makes it clear where to break apart the
    application when we have to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免这样的问题？最好的方法是以尽可能简单的方式设计应用程序，但尽可能长时间地避免子系统之间的通信问题。这正是强大的领域模型擅长的；领域将使我们能够与底层框架强烈分离，但也清楚地指出了在必须分解应用程序时应该如何分解。
- en: In the domain model, we already established areas that can be separated out
    later because we designed them as separate parts. A good example is the prisoner
    transport, which is hidden behind an interface that can later be extracted. There
    can be a team working on just the prisoner transport feature, and as long as there
    is no change to the public interface exposed, their work can be done without worrying
    about other changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，我们已经确定了可以稍后分离的区域，因为我们将它们设计为单独的部分。一个很好的例子是囚犯运输，它被隐藏在一个接口后面，以后可以被提取出来。可以有一个团队专门负责囚犯运输功能，只要公共接口没有改变，他们的工作就可以进行，而不必担心其他改变。
- en: Going a step further, it does not matter where the actual logic is executed,
    from a purely logical perspective. The prisoner transfer might just be a façade
    that calls into a separate backend, or it might be run in a process. This is what
    a well-factored application is all about—it provides an interface sub-domain functionality
    and exposes it in an abstract enough way to make the underlying system easy to
    change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，从纯逻辑角度来看，实际逻辑执行的位置并不重要。囚犯转移可能只是一个调用单独后端的幌子，或者可能在一个进程中运行。这就是一个良好分解的应用程序的全部意义——它提供了一个接口子域功能，并以足够抽象的方式暴露出来，使底层系统易于更改。
- en: We only want to separate out a service if it is necessary, and if there is a
    clear benefit in doing so, reducing the complexity of deployment or development
    dependencies so the development of the process can be scaled, at best, along with
    a team to take care of the service moving forward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在必要的情况下，如果分离出一个服务，并且这样做有明显的好处，减少部署或开发依赖的复杂性，使流程的开发能够尽可能地扩展，最好是有一个团队来负责服务的进一步发展。
- en: Service-oriented architecture and microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构和微服务
- en: In the extreme form, a **service-oriented architecture** (**SOA**) ends in microservices;
    a concept where each service is only responsible for a very limited feature set,
    therefore with very few reasons to change and is easy to maintain. In terms of
    domain-driven design, this means that a service is established for each bounded
    context inside the application. The context can eventually be broken down to mean
    that each aggregate is managed by separate services. The service managing the
    aggregate can ensure the inner consistency, and the interface as a service means
    that the access points are very clearly defined. Most of the problems are shifted
    to the communication layer, which has to deal with the resilience. This can be
    a big challenge to the communication layer in the application, and also for the
    services themselves that now have to deal with more failure modes due to the communication
    failing between the dependents. Microservices have been used in some scenarios
    with great success, but the overall concept is still young and needs to prove
    itself in a wider range of use cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在极端情况下，**面向服务的架构**（**SOA**）最终会变成微服务；每个服务只负责非常有限的功能集，因此很少有改变的理由，易于维护。在领域驱动设计方面，这意味着为应用程序中的每个有界上下文建立一个服务。上下文最终可以被分解为每个聚合由单独的服务管理。管理聚合的服务可以确保内部一致性，服务作为接口意味着访问点非常清晰地定义。大部分问题都转移到了通信层，必须处理弹性。这可能是应用程序中通信层的一个重大挑战，也是服务本身的挑战，因为它们现在必须处理更多的故障模式，由于依赖方之间的通信失败。微服务在某些场景中取得了巨大成功，但整体概念仍然年轻，需要在更广泛的用例中证明自己。
- en: The micro-service architecture is more or less an extension of the actor model,
    only if the move to making the actors self-sufficient services is an extension
    to this. This increases the communication overhead for better isolation; in domain-driven
    design, this could mean constructing services around entities, as they are the
    managers around the life cycle of parts of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构或多或少是演员模型的延伸，只有当将演员变成自给自足的服务时，才是对此的延伸。这增加了更好隔离的通信开销；在领域驱动设计中，这可能意味着围绕实体构建服务，因为它们是应用程序部分生命周期的管理者。
- en: Overall, whatever architecture ends up being the one of choice, it is useful
    to think about how to prepare the application for being broken up later. Carefully
    crafting a flexible domain model and leveraging bounded contexts is the key to
    evolving application design in such a way. Even in the case where the application
    is never actually broken into pieces, having a clear separation makes each part
    easier to work with and the combined application less error-prone because of better
    understandable, and therefore simpler to modify, components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，无论最终选择哪种架构，都有必要考虑如何准备应用程序以便以后可以分解。精心打造灵活的领域模型并利用有界上下文是以这种方式发展应用程序设计的关键。即使应用程序从未真正分解成部分，有清晰的分离也使每个部分更容易处理，并且由于更易理解，因此更容易修改，组件组合应用程序更少出错。
- en: A key point there is to have the core domain well identified and it is best
    to have it isolated to evolve it from other pieces of the system. Not every piece
    of the software is always going to be well designed, but having a core domain
    and its sub-domains isolated and defined makes the application as a whole ready
    to evolve, as those are the core pieces of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Keeping it all in your head
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time we open our editor of choice to work on code, there is a bit of overhead
    to know where to start and what section we actually need to modify. Understanding
    where to start a modification to move toward a certain goal is often the difference
    between an application that is a joy to work on and one nobody likes to touch.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When we start working on a piece of code, there is a maximum amount of context
    we can keep in our head any a given time. Even though it is not possible to give
    exact constraints, it is easy to notice when a certain part of the code exceeds
    this limit. It is often the point where refactoring gets harder, the test starts
    to become brittle, and unit tests seem to lose their value as their passing no
    longer ensures the functionality of the system. In the open source world, this
    is often a breaking point for a project and it is very visible due to its open
    nature. Either a library or application at this point proves valuable enough if
    people invest their time into really understanding the inner workings and continue
    to work towards making progress toward a more modular design, or the development
    stops. Enterprise applications suffer from the same fate, except that people are
    much more hesitant to give up on a project that provides a source of income or
    another important business aspect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When projects become complicated, often people fear any modifications and nobody
    really understands what is going on anymore. When the pain and the uncertainty
    starts to grow, it is important to recognize this and start to separate the contexts
    of the application to keep its size manageable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the contexts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have drawn out the application, we have been recognizing certain parts
    of the application and the way they communicate with each other. We can use this
    knowledge now to make sure we have an idea of what the context of the application
    could look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the contexts](graphics/B03704_06_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 1](ch01.html "Chapter 1. A Typical JavaScript Project"), *A Typical
    JavaScript Project*, we had about six contexts in the realm with which we were
    dealing. With the understanding gained from recent chapters, this has changed
    a bit, but the basics are there. Those contexts are identified as the communication
    between them happens by exchanging messages and not by modifying the internal
    state. In a case where we are building an API, we can't rely on the fact that
    we are in a situation where the internal state can be modified, nor should there
    be a way to reach inside a context and modify its internals, as this is a very
    deep coupling between contexts that would obviate the usefulness of contexts in
    general.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Messages are the key foundation of an easy-to-model API; if we think in messages,
    it is easy to image breaking apart the application and the messages no longer
    being sent locally, but over a network. Of course, breaking up an application
    is still not easy because suddenly there is a lot more complexity to deal with,
    but having the ability to deal with the messaging is a big part of the complexity
    out of the way already.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functional programming language **Erlang** takes this concept as far as
    possible. Erlang makes it easy to split applications apart into so-called processes,
    which are only able to communicate via messages being sent. This allows Erlang
    to relocate the processes to different machines and abstract away a whole slew
    of problems of multiprocessor machines, or multimachine systems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Having a well-defined API allows us to make refactoring changes inside the context
    without breaking the applications on the outside. The contexts become roles in
    our system that we can regard as black boxes, and we can model other parts with
    the knowledge they encapsulate abstracted out. Inside a context, an application
    is a coherent whole, and represents its data in an abstracted way to the outside.
    When we expose domains and sub-domains as interfaces, we generate the building
    blocks to a malleable system. When they need to share data, there is a clear way
    to do it, and the goal should always be to share underlying data and expose different
    views on this data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有明确定义的API使我们能够在不破坏外部应用程序的情况下对上下文内部进行重构更改。上下文成为我们系统中可以视为黑匣子的角色，并且我们可以使用它们封装的知识来建模其他部分。在上下文内部，应用程序是一个连贯的整体，并且以一种抽象的方式向外部表示其数据。当我们将域和子域公开为接口时，我们生成了一个可塑性系统的构建块。当它们需要共享数据时，有一种明确的方法可以做到这一点，目标应该始终是共享底层数据并在这些数据上公开不同的视图。
- en: Testing in contexts
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在上下文中测试
- en: As we identify the contexts we can regard as black boxes, we should start using
    this knowledge in our tests as well. We have already seen how mocking allows us
    to separate us based on different roles, and a context in this way is a perfect
    candidate for a role to mock during our unit testing. As we break our application
    into contexts, we can, of course, also start with different styles of testing
    in different contexts, making the development process evolve as our understanding
    and the application changes. When we do this, we need to keep in mind that the
    application as a whole needs to continue running, so the integration of the application
    needs to be tested as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确定可以视为黑匣子的上下文时，我们也应该在测试中使用这些知识。我们已经看到模拟允许我们根据不同的角色进行分离，而上下文在这种方式上是进行单元测试时的一个完美候选。当我们将应用程序分解为上下文时，当然也可以在不同的上下文中开始使用不同的测试风格，使开发过程随着我们的理解和应用程序的变化而发展。在这样做时，我们需要记住整个应用程序需要继续运行，因此还需要测试应用程序的集成。
- en: Integration across boundaries
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨边界的集成
- en: 'At the boundaries of contexts, there are multiple things we need to test from
    the view of the context developer:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文的边界处，从上下文开发者的角度，有多个需要测试的事情：
- en: Our side of the context needs to adhere to its contract, which means the API.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们这一方的上下文需要遵守其合同，也就是API。
- en: The integration of the two contexts needs to work, so cross-boundary tests need
    to be in place.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个上下文的集成需要正常工作，因此需要进行跨边界测试。
- en: 'For the first point, we can think of our tests as the consumers of the API.
    When we think about our messaging API for example, we want to have a test confirming
    that our API does what it promises. This is best served by an outside-in test
    covering the contract on the side of the context. Have a fictive `Notifier` that
    works as follows, as we previously used the notifier sending a message via the
    `message` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一点，我们可以将我们的测试视为API的使用者。例如，当我们考虑我们的消息API时，我们希望有一个测试来确认我们的API是否实现了它承诺的功能。这最好通过一个外部测试来覆盖上下文一侧的合同。假设有一个虚构的`Notifier`，它的工作方式如下，就像我们之前使用通知器通过`message`函数发送消息一样：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to test whether the backend is called in the correct way when the notifier
    is called with the public API:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用通知器时，我们需要测试后端是否以正确的方式被调用：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would not be an extensive test but the basic assertion is that the backend
    we are using, which the notifier abstracts us from, is called. To make this more
    valuable, we would also need to assert the correct way of calling, as well as
    the calling of the dependencies further down.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会是一个详尽的测试，但基本的断言是我们使用的后端是否被调用了。为了使其更有价值，我们还需要断言正确的调用方式，以及进一步调用依赖项。
- en: 'The second point requires an integration test to be set up to cover the interaction
    between the two or more contexts without the involvement of mocks or stubs. This
    of course means that the test will most likely be more complicated than a test
    allowing mocks and stubs to tightly control the environment, and therefore it
    is often limited to quite a simple test, to ensure that a basic interaction works.
    An integration test should not go into too much detail in this case, as this might
    ossify the API more than intended. The following code tests the integration of
    the prisoner transfer system in the system as a whole, using the different required
    subsystems like the dungeon as integration points:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要建立一个集成测试，以覆盖两个或更多上下文之间的交互，而不涉及模拟或存根。当然，这意味着测试很可能会比允许使用模拟和存根来严格控制环境的测试更复杂，因此通常限于相当简单的测试，以确保基本交互正常工作。在这种情况下，集成测试不应该过于详细，因为这可能比预期的更加僵化API。以下代码测试了系统中囚犯转移系统的集成，使用了地牢等不同的子系统作为集成点：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code shows how much more involved an end-to-end test ensuring
    a prisoner transfer can be. Due to this complexity, it only makes sense to test
    simple interactions as otherwise the end-to-end tests quickly become hard to maintain
    with small changes, and they should only cover the interactions on a higher level.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了确保囚犯转移的端到端测试可以涉及多么复杂。由于这种复杂性，只有测试简单交互才有意义，否则端到端测试很快就会随着小的变化而变得难以维护，并且它们应该只覆盖更高级别的交互。
- en: The goal of end-to-end or, integration tests across the boundaries of the system,
    is to ensure that the basic interactions work. The goal of unit tests is that
    the module in itself behaves as we want it to. This leaves a level open, which
    becomes obvious when running a service in production.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端或系统边界的集成测试的目标是确保基本交互正常工作。单元测试的目标是模块本身的行为符合我们的期望。这留下了一个开放的层次，在生产环境中运行服务时会变得明显。
- en: TDD and testing in production
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD和生产测试
- en: Test-driven development allows us to design a system that is easy to change
    and evolve; on the contrary, it does not ensure a perfect function of course.
    We first write a "broken" test, a test where the underlying functionality is still
    missing, and then write the code to satisfy it. We don't write tests to be perfectly
    safe from production bugs, because we can never anticipate all the possible complications
    that may arise. We write the tests to allow our system to be flexible and also
    to allow it to be ready for production in the sense that we can introspect its
    behavior and have the contexts reasonably well isolated to deal with failure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: When moving code to production, we are exercising the system in a new way, and
    for this we need to be ready to monitor and introspect. This kind of introspection
    and monitoring also allows easy tests due to the injection of logging modules
    and others that allow simpler assertions of integration tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how a system of contexts can help us create a more stable and
    easier to maintain system. In the following section, we are focusing on how to
    actually maintain the context within the application to fight the leaking of abstractions
    and leaking context across, and how this relates to different ways of organizing
    the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The different ways to manage contexts
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the main purpose of the context in our application has been to separate
    different modules and make the complexity of the whole application more manageable
    by abstracting out APIs. The other important benefits of separate contexts are
    the fact that we can start to explore different ways of managing application development
    in those decoupled parts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The way applications are developed evolves as the industry around software evolves
    at a rapid pace. Development principles that were state of the art just a couple
    years ago are being frowned upon now and developers want to move to new ways of
    making them more productive while promising bug-free, easier to manage applications.
    Of course, switching out the development principles is not free, and more often
    than not new ways don't necessarily match the way complete organizations can,
    or want, to work. By separating out the contexts of the application, we can start
    exploring those new ways alongside the well-established ones and keep the team
    evolving and developing alongside the applications they maintain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The first step towards manageable contexts is drawing a map of their relationships
    and starting to make a clear separation, using the language we established. With
    this map, we can start to think of ways to divide the application and break it
    into different ways to enable maximum productivity within the team.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a context map
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prisoner transport application that we have been following throughout the
    book so far involves multiple contexts. Each context can be abstracted by a clear
    API, and aggregates multiple collaborators to make the prisoner transport, as
    a whole, work. We can follow these collaborators in the integration test we have
    seen before, and draw out their relationship on a map for everybody on the project
    to keep in mind. The following diagram shows an outline of the different contexts
    involved in the prisoner transport, including their role:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a context map](graphics/B03704_06_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'The map, for now, involves four main contexts as we saw in the previous integration
    test:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Prisoner management
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dungeons
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messaging system
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transports
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each context is responsible for providing the collaborators needed to make an
    actual transport between the dungeons happen, and provided the API stays consistent,
    it can be replaced with a different implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Investigation into the context shows differences that are going to increase
    as the application evolves, which means different strategies are needed to manage
    the contexts. There is the dungeon as the main entry point to the application,
    which manages most of the raw resources. The dungeon is going to be like the sun
    in the dungeon management solar system. It provides access to the resources, which
    can then be used to accomplish different tasks. Due to this, the dungeon is a
    shared core of the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are different sub-domains that use the resources provided
    by the dungeon that gather around. The messaging system, for example, provides
    infrastructure to different systems, in a largely decoupled way to augment tasks
    as they are done by other systems. The prisoner transfer we have seen is one of
    the sub-domains tying those other sub-domains together. We use resources provided
    by the dungeon to build a prisoner transfer, and we use the decoupled messaging
    functionality to augment the transfer task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Those three systems show how we have different contexts working together and
    providing resources to accomplish the tasks the system is to build. As we build
    them, we need to think about how those sub-domains should be related. Depending
    on the different types of subsystem that are being built, different forms of context
    relationships are useful and best support the development. One thing to keep in
    mind, so as long as the application is simple enough, is that most of those will
    add more overhead to the development than they add flexibility, as sharing aspects
    of the application will, by definition, become more complicated than it has been
    before.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic architecture
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When starting out with development, the team developing the application is most
    likely small and the context of the application is in itself not large yet. At
    this stage, it most likely does not make sense to break out the contexts of the
    application domain, as those are still flexible and have not evolved enough to
    warrant a separate team to take care of them. Also, APIs at this stage are not
    stable enough to implement a solid abstraction, no matter how much planning has
    gone into the details beforehand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Martin Fowler has been talking about this as well and he recommends a strategy
    of building a monolith first and breaking it up as needed. You can find more on
    this on his blog at [http://martinfowler.com/bliki/MonolithFirst.html](http://martinfowler.com/bliki/MonolithFirst.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, application development will progress best using a monolithic
    architecture that provides shared access to the models. This does not mean, of
    course, that everything should be one big pile of code, but especially in a monolith
    it is easy to break out objects as everybody has access to them anyway. This will
    make it easier to break apart the application afterwards as borders tend to evolve
    during development.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the way we have been developing the application so far; even though
    we recognize that there are contexts, those contexts don''t necessarily mean separation
    into different applications or domains, but for now they are a map in the developer''s
    mind to guide the location of the code as well as the flow of interactions. Taking
    a look at the prisoner transport, it can look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Right now, the code accesses each part of the application directly. Even though
    the communication is wrapped into an object that controls the flow, the prisoner
    transfer has a lot of interaction happening, which will need to be accessed over
    the network if the application is broken apart. This kind of organization is typical
    for a monolithic application and will change when it is broken into different
    pieces, but the overall contexts will remain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A shared kernel
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that the dungeon is like the sun in our orc dungeon management
    universe, so it only makes sense to share its functionality across the applications
    that interact with it in some way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，地牢就像我们的兽人地牢管理宇宙中的太阳，因此将其功能跨应用程序共享是有意义的。
- en: This kind of development is a **shared kernel**. The dungeon itself provides
    functionality that will need to be replicated in many different places unless
    it is shared in some way, and since the functionality is such a crucial part,
    it does not go well with a slow interface that is part of a supply chain, for
    example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发方式是一种**共享内核**。地牢本身提供的功能需要在许多不同的地方进行复制，除非以某种方式进行共享，而且由于功能是如此关键的一部分，它与供应链的慢接口并不相容，例如。
- en: 'The dungeon provides many useful interfaces for the different parts that use
    it, so the functionality needs to be developed in tandem with the consumers. Going
    back to the prisoner transport, the code will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢为使用它的不同部分提供了许多有用的接口，因此功能需要与使用者一起开发。回到囚犯运输，代码将如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we used a common pattern, which uses an `init` method
    to encapsulate some logic needed to initialize the dungeon. This is often useful
    to make the creation easy to use from the outside, and instead of handling it
    in a complex constructor, we move it out to a separate factory method. The advantage
    is that the return of a simple method is easier to handle than using a complex
    constructor, as a failing constructor might end in a half-initialized object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个常见的模式，它使用`init`方法来封装一些初始化地牢所需的逻辑。这通常对于使外部创建变得容易很有用，而不是在复杂的构造函数中处理它，我们将其移到一个单独的工厂方法中。优点是，简单方法的返回值比使用复杂构造函数更容易处理，因为失败的构造函数可能会导致一个半初始化的对象。
- en: The important point in this is that the dungeon now supports a specific endpoint
    to provide the resources needed for the transfer to happen. This would most likely
    lock the given resources and initialize a transaction for them so they don't get
    reused without their reuse being possible in the physical world.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要一点是，地牢现在支持一个特定的端点，以提供转移所需的资源。这很可能会锁定给定的资源并为其初始化一个事务，以便它们在物理世界中不会被重复使用。
- en: 'Due to our shared kernel nature, this change can happen in the prisoner transfer
    and the dungeon part of the application in tandem. The shared kernel is, of course,
    not without problems, as it creates strong coupling between the parts. It is always
    useful to keep this in mind and think twice about whether pieces are really needed
    in the shared kernel or whether they belong in another part of the application.
    Shared data does not mean there is a reason to share code. The view of what a
    prisoner transfer is can be different throughout the application: while the transfer
    itself might care more about details, the messaging service sharing the data of
    the transfer to create a message to send cares only about the target and the source,
    as well as the prisoners involved in the transfer. So sharing code between the
    two contexts would confuse each domain with unnecessary and unrelated knowledge.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的共享内核特性，这种变化可以同时发生在囚犯转移和应用程序的地牢部分。共享内核当然并非没有问题，因为它在部分之间创建了强耦合。牢记这一点并仔细考虑，是否真的需要在共享内核中使用这些部分，或者它们是否属于应用程序的另一部分，这总是有用的。共享数据并不意味着有理由共享代码。对于应用程序中囚犯转移的视图可能会有所不同：虽然转移本身可能更关心细节，但消息服务共享转移数据以创建要发送的消息只关心目标和来源，以及参与转移的囚犯。因此，在两个上下文之间共享代码会使每个领域混淆不必要和无关的知识。
- en: The architecture of a shared context like this means that the teams working
    inside the shared context must work closely together, and that this part of the
    application has to be vigorously refactored and reviewed so it does not get out
    of hand. It is a straight evolution of the monolith, so to speak, but it takes
    the application a step further towards being split into multiple ones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的共享上下文架构意味着在共享上下文内工作的团队必须紧密合作，这部分应用程序必须进行大力重构和审查，以免失控。可以说，这是单体架构的直接演变，但它使应用程序更进一步地分割成多个部分。
- en: For many applications, splitting out some basic elements with a lot of churn
    is enough, and the application can evolve much more quickly using a shared kernel
    where the development team coordinates. This of course forces the team to trust
    each others decisions in general and the communication overhead between the engineers
    can grow with the shared kernel, evolving at this point, the application has solidified
    to a stage where teams can take over the responsibilities for application parts,
    rolling them in their own.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，将一些基本元素分离出来并进行大量变更就足够了，应用程序可以通过共享内核更快地演进，开发团队进行协调。当然，这迫使团队在一般情况下信任彼此的决定，并且工程师之间的沟通开销可能会随着共享内核的演变而增加，此时应用程序已经稳定到一个阶段，团队可以接管应用程序部分的责任，并将其整合到自己的部分中。
- en: The APIs
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: Building distinct applications requires a set of APIs that can be relied upon.
    With APIs like this, it is possible to extract certain sub-domains from the main
    domain and application, which can start to evolve completely separately to the
    main application as long as they continue to conform to the same API as before.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建不同的应用程序需要一组可靠的API。有了这样的API，可以从主域和应用程序中提取某些子域，这些子域可以开始完全独立于主应用程序演进，只要它们继续遵守之前的相同API。
- en: It is important to identify a sub-domain first to allow it to have a clean API
    layer to build upon. Looking at the context map will show the interactions of
    the sub-domains, and those interactions are what an API model should be based
    on. Starting out by building in a more monolithic way and breaking out pieces
    as they are solidified in their sub-domain will lead towards this naturally.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要识别一个子域，以便为其提供一个清晰的API层来构建。查看上下文映射将显示子域的交互，而这些交互是API模型应该基于的。首先以更单片式的方式构建，然后在其子域中巩固时分解出部分，将自然地朝着这个方向发展。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Conforming to the same API as before is often only regarded as taking the same
    input and producing the same output, there is more to it so to provide a drop-in
    replacement. New applications need to provide similar guarantees towards response
    time and other service levels, such as data persistence for example. A drop-in
    replacement is easier said than done in most cases, but evolving an application
    toward better service levels is often easier in isolation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前相同的API一致通常只被视为接受相同的输入并产生相同的输出，但实际上还有更多内容，以便提供一个可替换的组件。新应用程序需要提供类似的保证，以确保响应时间和其他服务水平，例如数据持久性。在大多数情况下，实现一个可替换的组件并不像表面上那么容易，但将应用程序发展到更好的服务水平通常在孤立环境中更容易。
- en: As we develop the application, we are now free to branch off while staying true
    to the mission of the application. We are providing a service to other applications
    who need to conform to our way of doing things but only up to the call of the
    application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发应用程序，我们现在可以自由地分支出去，同时保持对应用程序使命的忠诚。我们为其他需要遵循我们做事方式的应用程序提供服务，但仅限于应用程序的调用。
- en: The customer and the supplier
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顾客和供应商
- en: An application that provides a service is a supplier of a certain service. We
    can think of the messaging system as such a service. It provides other applications
    with an entry point to send messages across certain end points. Those end points
    need to provide the necessary calls if they want to receive messages while the
    messaging system takes care of the delivery of the message. An application using
    the messaging system needs to call into the system in a certain way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提供服务的应用程序是某种服务的供应商。我们可以将消息系统视为这样的服务。它为其他应用程序提供了一个发送消息到特定端点的入口点。如果它们想要接收消息，这些端点需要提供必要的调用，而消息系统则负责传递消息。使用消息系统的应用程序需要以某种方式调用系统。
- en: Such a way of interaction is very abstract, and a good application like this
    does not provide many endpoints but very high-level entry points to the system
    in general to make the use as easy as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种互动方式非常抽象，而且像这样的一个好应用程序并不提供很多端点，而是提供了非常高级的入口点，以便尽可能地使使用变得容易。
- en: Developing a client
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发客户端
- en: 'Using an internal application like this can be done in multiple ways. The interface
    can be very simple, for example, a very basic call over HTTP like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用内部应用程序可以有多种方式。接口可以非常简单，例如，像这样通过HTTP进行非常基本的调用：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A call like this does not need a separate client for most languages as it is
    very easy to interact with and will be bundled in to the customer application
    in whatever way is deemed best.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的调用对大多数语言来说并不需要单独的客户端，因为它非常容易进行交互，并且将被捆绑到客户应用程序中，以任何被认为最佳的方式。
- en: Not every application can provide such an easy interface of course, so at this
    stage there is the need to provide a client, which at best is shared between the
    different customers of the application, to not duplicate work. This can be provided
    either by the developing application in the case of complex clients or can be
    initiated by one of the customer applications and then shared in the same style
    as a shared kernel. While in most bigger systems it seems that the client is more
    often than not provided by the application development team, this is not necessarily
    the best way as they are not always aware of the intricacies that using their
    application involves, and therefore invite wrapping clients for each consumer
    to evolve alongside the internal client.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个应用程序都能提供如此简单的接口，因此在这个阶段需要提供一个客户端，最好是在应用程序的不同客户之间共享，以避免重复工作。这可以由开发应用程序提供，例如在复杂客户端的情况下，也可以由其中一个客户应用程序发起，然后以与共享内核相同的方式共享。在大多数更大的系统中，客户端往往是由应用程序开发团队提供的，但这并不一定是最好的方式，因为他们并不总是了解使用他们应用程序的复杂性，因此邀请每个消费者的封装客户端与内部客户端一起发展可能更好。
- en: The conformist
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 墨守成规
- en: The split of an application into an API supplier and consumer is a very distinct
    split and, even with the provided clients, it means that the application now consists
    of multiple parts that are no longer developed as a unit. This kind of split is
    often suggested to increase the speed of development as the team can be smaller
    and there is no longer such a strong communication needed. However, this comes
    at a price when the two separate applications need to work together to provide
    new features.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分割为API供应商和消费者是一个非常明显的分割，即使有提供的客户端，这意味着应用程序现在由多个部分组成，不再作为一个单元进行开发。这种分割通常被认为可以增加开发速度，因为团队可以更小，不再需要如此强烈的沟通。然而，当两个独立的应用程序需要共同提供新功能时，这是需要付出代价的。
- en: When we need to communicate across borders, it is expensive, not only in terms
    of networking and method call speed, but in terms of team communication overall.
    The teams providing different parts of the application are not set up to work
    with each other and the time it takes to set this structure up is an overhead
    we have to pay for every time a feature is developed in collaboration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要跨界通信时，这是昂贵的，不仅在网络和方法调用速度方面，而且在整体团队沟通方面也是如此。提供应用程序不同部分的团队并不是为了相互合作而设立的，建立这种结构所需的时间是我们每次开发合作功能时都要付出的额外开销。
- en: '|   | *Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations…* |  
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '|   | --*M. Conway* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: This kind of development is kind of the inverse effect of *Conway's law*, because
    as organizations will produce systems constrained by their structure, forcing
    different structures will inadvertently slow down the team as it is not fit to
    develop such an application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'When confronted with an increasing application, we need to make a choice: we
    can either decide to break up the application or deal with the result of growing
    pains. Dealing with the pains of a legacy application and just conforming to the
    development route it took can be a good choice depending on where the overall
    system is supposed to go. If, for example, the application is in maintenance mode
    for some time and it is unlikely that it will gain features any time soon, deciding
    to just continue on this route, even if the model is not perfect and the code
    base seems legacy, might well be the best choice.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Being a conformist is the unpopular choice, but it follows the suit of "never
    do a rewrite" and, after all, it is more rewarding to work on an application that
    is actually useful than on one that might be nicely engineered but does not provide
    value and is therefore neglected sooner or later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The anticorruption layer
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a certain point in the application's life where just adding more features
    and conforming to the already present design is not productive anymore. At this
    stage, it makes sense to split from the main application and start to break out
    of the cycle of ever increasing complexity in the software. At this stage, it
    is a good idea to reform the domain language as well and see where the legacy
    codebase fits into the model, as this allows you to create solid abstractions
    and design a nice API on top of it. This kind of development provides a façade
    over the code, and by this, we mean providing a layer to shield the application
    from old terms and problems that might leak in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The anticorruption layer is a very important pattern when it comes to improving
    applications that are already in production. Isolating a new feature makes it
    easier not only to test , but also can increase reliability and ease the introduction
    of new patterns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the methodologies
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we build a layer like this, we are all about isolating us from the underlying
    technology; this of course means that we should also isolate ourselves from the
    ways of building software present below, and we can start using all the new ways
    developed since the original application was started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: This has one very bad side-effect, which is that the old application instantly
    becomes the legacy not many people want to work on anymore and much blame might
    be thrown toward it. Make sure such a strong split is necessary for this reason.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: An anticorruption layer might also make sense in the case where an outside application
    is integrated into the system, for example, credit card processing by an outside
    banking system. External dependencies are best served when isolated from the core
    application, and be it just for the fact that the external API can change and
    adjusting all callers is most likely more complicated then adjusting the internal
    abstraction. This is exactly what an anticorruption layer is good at, so soon
    your internal dependencies are best treated like external ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Separate ways
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to an anticorruption layer, in a more separate way, tries to solve the
    problem of an application growing apart in the domain. As we develop a common
    language across the system and are breaking the application apart, the language
    will become more refined for some models and the models will increase in complexity
    in certain applications, but not necessarily in others. This can lead to problems
    where a shared core is used because this core needs to incorporate the maximum
    complexity required by each sub-domain and therefore continues to grow while we
    would rather keep it small.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The problem is deciding when a certain application needs to be split at the
    domain model level because the increased complexity for one part does not enhance
    another parts' usability anymore. In our application, the likely candidate is
    the dungeon model that is shared across the other applications. We want to keep
    it as small as possible, but parts of the application will have different demands
    on it. The messaging subsystem will have to focus on the delivery of messages
    to the dungeon and increase the complexity of this part, while the system to handle
    prisoner transport prerequisites will care about other resource management parts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Unrelated applications
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With different applications having such different requirements towards the core
    domain, it can make sense not share the model but build a specific one for the
    applications that need it, sharing only a datastore or some other means to share
    the state. The goal is to reduce dependencies and this can mean only sharing what
    actually needs to be shared, even if the names might suggest otherwise. When sharing
    a data store, it is important to keep in mind that only the sub-domain that owns
    the data should be able to modify it, while all others should be using an API
    to access the data, or only have read-only access. It comes down to whether the
    overhead of an API is sustainable, or whether direct integration is needed for
    performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When applications start using models in different ways and the only reason they
    share a model is the fact that the model is named the same, we can start to look
    for more specific names that are fit for purpose, and at some point we can even
    get rid of the primary model completely. In our dungeon example, the case may
    be that, over time, the dungeon itself gets reduced to only being the entry point
    of the application, acting as a router to the managing sub-domain applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Moving more functionality outside the initially shared context of the application
    into other contexts means that we reduce the surface of our shared sub-domain,
    and that we misidentified the role of this domain in the beginning. This is nothing
    bad since every application should be built to evolve, and as contexts become
    more clear, this can in turn clarify the sub-domain borders that were previously
    unclear.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't get too attached to your understanding of the borders of domains and sub-domains.
    As gaining experience from business experts can improve your understanding of
    a sub-domain, so can the refining of a bounded context in turn influence the domain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: An open protocol
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step in making applications truly independent is publishing them as
    an open protocol. The point is to make the core functionality of the application
    accessible openly from the outside as a published standard. This is very seldom
    the case as it requires a lot of maintenance and setup initially. The best candidates
    for an open protocol are special communication layers used to communicate with
    the application to allow external clients.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The API of an application can be considered an open protocol when it invites
    in external users, and maybe even external clients. In our dungeon applications
    we might, at some point, want to make the messaging subsystem an open protocol
    to allow other dungeons to plug in via their own local applications, and therefore
    establishing the standard in the Dungeon Management™.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As this stage, when thinking about the Open Protocols, what we need to focus
    on is the fact of how we can share knowledge of the protocol in an effective way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Sharing knowledge
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We split the application apart into multiple sub-applications of the sub-domains,
    we do this to increase the size of the team and enable better cooperation between
    them. This also means that the team needs to find a way to share the information
    about the application and their usage with new developers as well as with developers
    tapping into the sub-domain to accomplish a certain goal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The domain language is an important part of our design and we invested some
    time into building it throughout the development so far. We can draw on this and
    make this language available for other developers. The language, as we have seen
    it, slightly adjusts for each module and is a working document that needs to be
    kept up to date, and that means we need to find a way to keep it published.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The publishing language
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The language we have been developing is an ever-evolving document, and as such
    we have to think about how to share the knowledge embedded in it. Again let's
    first define what we would do in a perfect world and see how we can approximate
    this situation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, the team that started out developing the application would
    stay together for the whole lifetime of the application and continue to grow,
    but the core developers would always be there. A team like this would have the
    major advantage of the terminology and the assumptions of the project being shared
    by the team as they have been following the application through its life, and
    new developers would join and learn from the core team by osmosis, so to speak.
    They would slowly adapt to the team and follow the rules, breaking them if necessary,
    and if agreed upon via the consensus of the team.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We don't live in a perfect world though, and teams are likely to have some churn
    where core developers leave for whatever reason and are replaced with new faces.
    When this happens, there is the risk that the core principles of the application
    can could be lost, that the language around the project does not follow the original
    rules more, and many other bad things. Luckily, compared to olden times, we don't
    have to rely on word of mouth but can document our findings for others to find.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Creating the documentation
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation is often not the favorite part of software development, but this
    comes from the fact that a lot of documentation is not useful in many projects.
    When we create documentation, the important thing is to not state the obvious
    but to actually document the problems and ideas arising during development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Often, the documentation found on projects is the outline of the methods, what
    parameters they take in, and what they return. This is a good start but not not
    the end of all documentation necessary. When different people are using the project
    they need to understand the intention behind it to use the API properly. When
    we create an application and decide on what kind of features we want and how they
    work, this is important to document. So far in this book, we have been focusing
    a lot on how to think about application development and also how to make sure
    it is in an understandable form for others to follow. All this is documentation
    that needs to be kept around. We want to be sure that the next person can follow
    the thinking that went into the development, knows what the terms mean, and how
    they relate to each other.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: A good way to start is to keep a central document where this kind of information
    lives close to the application and is accessible to everybody interested. Making
    the document as short as possible and having a way to see it evolve along with
    the project is key, so having some kind of versioning is a very useful feature.
    Going back in time in source code is very common to find out how a certain piece
    of code has changed, and being able to relate the right piece of documentation
    to it is very helpful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping a simple text file as the README for the project is a good place to
    start. This README can live inside the application repository, making the relationship
    between documentation and application a very strong one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following we see this by the example of the canned fake API server,
    available at [https://github.com/sideshowcoder/canned](https://github.com/sideshowcoder/canned):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the documentation](graphics/B03704_06_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'The important points for documentation are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the project in a short statement
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design ideas followed throughout the project to guide new developers
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example usages of features
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation notes for very important pieces of code
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change history of major changes
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup instructions
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the documentation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping the documentation close to the application has some essential advantages;
    it is just way too easy to neglect some document off in a wiki somewhere that
    needs special permissions to access, while looking at something every day when
    working on a project will more likely be kept up-to-date.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is a living and breathing piece of the overall project and it
    therefore needs to be part of the project itself. Especially in the modern, open
    source inspired development world, the idea that everybody should be able to contribute
    to a project quickly is ingrained in the developer culture and this is a good
    thing. Code speaks louder than a thousand architecture specs, so to speak, and
    therefore limiting the documentation to the core design ideas while letting the
    code explain the specific implementation makes the documentation more useful in
    the long run and keeps developers engaged in the updating process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Tests are not the only documentation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One side note about tests: often TDD is stated as having the benefit of providing
    tests as part of the documentation, as they are the examples on how to use the
    code after all. This is often an excuse to not bother to write up any examples
    outside this and also to not document the overall design since reading the tests
    states the design.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that for the tests, all methods are equally
    important. It is very hard to convey an auxiliary decision made because it did
    not seem to have an impact at this moment from a core design idea of the project.
    This makes refactoring hard and is prone to side-track the project and maintain
    features that were never intended to be any in the beginning. For a developer
    coming into a project, the documentation should specify what the core functionality
    is, and if he or she finds a use for some obscure function outside this core,
    this is great and a good place for reading the tests, but there is a way to distinguish
    a feature that has support from the main application versus an auxiliary one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: One approach to try to make this more interactive is README-driven development,
    where we write the README first and make the examples executable, trying to make
    our code pass the examples we specified as the first layer of tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more on README-driven development at Tom Preston-Werner's blog,
    [http://tom.preston-werner.com/2010/08/23/readme-driven-development.html](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the interaction between different subprojects
    forming sub-domains and collaborating with each other by different means. This
    collaboration can take many forms and depending on the context and the state of
    the application as a whole, some can be more valuable then others.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The right choice for collaboration is always up for debate, of course, and it
    is very possible to change the mode as the project evolves. An important point
    I would like to get across is that those collaboration ideas are not set in stone;
    it is a sliding scale and every team should decide what works best for them and
    what keeps the actual complexity in the application and the team work low.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In the last part, the chapter focused on the important things when creating
    documentation for a project and how we can make it useful while not diving into
    the realm of creating elaborate specifications that nobody ever touches or even
    understands as soon as they leave the hands of the architect who created them
    in the first place.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore how other development methods fit
    into domain-driven design, how a good object-oriented structure can support the
    design in general, and how domain-driven design is influenced by many other techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
