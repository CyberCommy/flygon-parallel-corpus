- en: Chapter 6. Context Map – The Big Picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dungeon manager application, for now, only contains the functionality to
    manage prisoner transportation, but as our application grows, the need to organize
    the code increases as well. The number of developers able to concurrently work
    on a piece of software is limited. Jeff Bezos (founder and CEO of Amazon.com)
    once stated that the size of a team should be no more than that can be fed by
    two pizzas ([http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200](http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200)).
    The idea is that any team larger than this will have trouble with communication
    as the number of connections within this team grows very quickly. As we add more
    people, the amount of communication needed to keep everybody up to date grows
    as well, and sooner or later the team will be slowed down by its constant need
    for meetings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This fact causes somewhat of a dilemma because, as we described earlier, the
    perfect application would be one where everybody would know everything about how
    the development happened and how the decisions around the changes were made. This
    leaves us with very few options: we can either decide to not grow the team, building
    the application but opting for a slower development cycle that can be handled
    by this team alone (along with a smaller feature-set on the application as a whole),
    or alternatively we can try to make multiple teams work on the same application.
    Both strategies have been successful as far as business goes. Staying small and
    growing naturally, while most likely not resulting in hockey-stick growth can
    result in a well run and successful company as the likes of Basecamp Inc. and
    other independent software developers have proved. On the other hand, this does
    not work for applications that are inherently complex and aim for a much broader
    scope, so the likes of Amazon and Netflix, for example, started growing their
    teams around the idea of creating a larger application comprising of smaller parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we opt for the idea of domain-driven design, we more likely have
    an application that is part of the inherently complex realm, so the following
    chapter will introduce some common ways to handle this scenario. One important
    point not to miss when designing an application like this is that we should always
    strive to reduce complexity as far as possible. You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to organize a growing application technically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test the integration of applications in a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize expanding contexts in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't fear the monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, there has been a strong move toward breaking applications apart
    and designing them as a set of services communicating via messages. This is a
    well-established concept for large-scale applications; the problem is finding
    the correct time to break the application apart and also deciding whether breaking
    it apart is the right thing to do. When we break an application into multiple
    services, we increase the complexity at this point since we now have to deal with
    handling communication problems crossing multiple services. We have to consider
    the resilience of the services, and the dependencies each service has, to provide
    its features.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we break an application apart at a late stage, problems
    arise when extracting logic from the application. There is no reason why a monolith
    application can't be well-factored and remain easy to maintain for a long time.
    Breaking up an application will always cause problems, and staying with a well-factored
    application for a long time works. The problem is that a large codebase with a
    lot of developers working on it is more likely to deteriorate.
  prefs: []
  type: TYPE_NORMAL
- en: How can we avoid such problems? The best way is to design the application in
    a way that breaks it up as simply as possible but keeps the problem of communication
    between sub-systems out of the picture for as long as possible. This is what a
    strong domain model excels at; the domain will allow us to have strong separation
    from the underlying frameworks, but also makes it clear where to break apart the
    application when we have to.
  prefs: []
  type: TYPE_NORMAL
- en: In the domain model, we already established areas that can be separated out
    later because we designed them as separate parts. A good example is the prisoner
    transport, which is hidden behind an interface that can later be extracted. There
    can be a team working on just the prisoner transport feature, and as long as there
    is no change to the public interface exposed, their work can be done without worrying
    about other changes.
  prefs: []
  type: TYPE_NORMAL
- en: Going a step further, it does not matter where the actual logic is executed,
    from a purely logical perspective. The prisoner transfer might just be a façade
    that calls into a separate backend, or it might be run in a process. This is what
    a well-factored application is all about—it provides an interface sub-domain functionality
    and exposes it in an abstract enough way to make the underlying system easy to
    change.
  prefs: []
  type: TYPE_NORMAL
- en: We only want to separate out a service if it is necessary, and if there is a
    clear benefit in doing so, reducing the complexity of deployment or development
    dependencies so the development of the process can be scaled, at best, along with
    a team to take care of the service moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the extreme form, a **service-oriented architecture** (**SOA**) ends in microservices;
    a concept where each service is only responsible for a very limited feature set,
    therefore with very few reasons to change and is easy to maintain. In terms of
    domain-driven design, this means that a service is established for each bounded
    context inside the application. The context can eventually be broken down to mean
    that each aggregate is managed by separate services. The service managing the
    aggregate can ensure the inner consistency, and the interface as a service means
    that the access points are very clearly defined. Most of the problems are shifted
    to the communication layer, which has to deal with the resilience. This can be
    a big challenge to the communication layer in the application, and also for the
    services themselves that now have to deal with more failure modes due to the communication
    failing between the dependents. Microservices have been used in some scenarios
    with great success, but the overall concept is still young and needs to prove
    itself in a wider range of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The micro-service architecture is more or less an extension of the actor model,
    only if the move to making the actors self-sufficient services is an extension
    to this. This increases the communication overhead for better isolation; in domain-driven
    design, this could mean constructing services around entities, as they are the
    managers around the life cycle of parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, whatever architecture ends up being the one of choice, it is useful
    to think about how to prepare the application for being broken up later. Carefully
    crafting a flexible domain model and leveraging bounded contexts is the key to
    evolving application design in such a way. Even in the case where the application
    is never actually broken into pieces, having a clear separation makes each part
    easier to work with and the combined application less error-prone because of better
    understandable, and therefore simpler to modify, components.
  prefs: []
  type: TYPE_NORMAL
- en: A key point there is to have the core domain well identified and it is best
    to have it isolated to evolve it from other pieces of the system. Not every piece
    of the software is always going to be well designed, but having a core domain
    and its sub-domains isolated and defined makes the application as a whole ready
    to evolve, as those are the core pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping it all in your head
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time we open our editor of choice to work on code, there is a bit of overhead
    to know where to start and what section we actually need to modify. Understanding
    where to start a modification to move toward a certain goal is often the difference
    between an application that is a joy to work on and one nobody likes to touch.
  prefs: []
  type: TYPE_NORMAL
- en: When we start working on a piece of code, there is a maximum amount of context
    we can keep in our head any a given time. Even though it is not possible to give
    exact constraints, it is easy to notice when a certain part of the code exceeds
    this limit. It is often the point where refactoring gets harder, the test starts
    to become brittle, and unit tests seem to lose their value as their passing no
    longer ensures the functionality of the system. In the open source world, this
    is often a breaking point for a project and it is very visible due to its open
    nature. Either a library or application at this point proves valuable enough if
    people invest their time into really understanding the inner workings and continue
    to work towards making progress toward a more modular design, or the development
    stops. Enterprise applications suffer from the same fate, except that people are
    much more hesitant to give up on a project that provides a source of income or
    another important business aspect.
  prefs: []
  type: TYPE_NORMAL
- en: When projects become complicated, often people fear any modifications and nobody
    really understands what is going on anymore. When the pain and the uncertainty
    starts to grow, it is important to recognize this and start to separate the contexts
    of the application to keep its size manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have drawn out the application, we have been recognizing certain parts
    of the application and the way they communicate with each other. We can use this
    knowledge now to make sure we have an idea of what the context of the application
    could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing the contexts](graphics/B03704_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 1](ch01.html "Chapter 1. A Typical JavaScript Project"), *A Typical
    JavaScript Project*, we had about six contexts in the realm with which we were
    dealing. With the understanding gained from recent chapters, this has changed
    a bit, but the basics are there. Those contexts are identified as the communication
    between them happens by exchanging messages and not by modifying the internal
    state. In a case where we are building an API, we can't rely on the fact that
    we are in a situation where the internal state can be modified, nor should there
    be a way to reach inside a context and modify its internals, as this is a very
    deep coupling between contexts that would obviate the usefulness of contexts in
    general.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are the key foundation of an easy-to-model API; if we think in messages,
    it is easy to image breaking apart the application and the messages no longer
    being sent locally, but over a network. Of course, breaking up an application
    is still not easy because suddenly there is a lot more complexity to deal with,
    but having the ability to deal with the messaging is a big part of the complexity
    out of the way already.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functional programming language **Erlang** takes this concept as far as
    possible. Erlang makes it easy to split applications apart into so-called processes,
    which are only able to communicate via messages being sent. This allows Erlang
    to relocate the processes to different machines and abstract away a whole slew
    of problems of multiprocessor machines, or multimachine systems.
  prefs: []
  type: TYPE_NORMAL
- en: Having a well-defined API allows us to make refactoring changes inside the context
    without breaking the applications on the outside. The contexts become roles in
    our system that we can regard as black boxes, and we can model other parts with
    the knowledge they encapsulate abstracted out. Inside a context, an application
    is a coherent whole, and represents its data in an abstracted way to the outside.
    When we expose domains and sub-domains as interfaces, we generate the building
    blocks to a malleable system. When they need to share data, there is a clear way
    to do it, and the goal should always be to share underlying data and expose different
    views on this data.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we identify the contexts we can regard as black boxes, we should start using
    this knowledge in our tests as well. We have already seen how mocking allows us
    to separate us based on different roles, and a context in this way is a perfect
    candidate for a role to mock during our unit testing. As we break our application
    into contexts, we can, of course, also start with different styles of testing
    in different contexts, making the development process evolve as our understanding
    and the application changes. When we do this, we need to keep in mind that the
    application as a whole needs to continue running, so the integration of the application
    needs to be tested as well.
  prefs: []
  type: TYPE_NORMAL
- en: Integration across boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the boundaries of contexts, there are multiple things we need to test from
    the view of the context developer:'
  prefs: []
  type: TYPE_NORMAL
- en: Our side of the context needs to adhere to its contract, which means the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The integration of the two contexts needs to work, so cross-boundary tests need
    to be in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first point, we can think of our tests as the consumers of the API.
    When we think about our messaging API for example, we want to have a test confirming
    that our API does what it promises. This is best served by an outside-in test
    covering the contract on the side of the context. Have a fictive `Notifier` that
    works as follows, as we previously used the notifier sending a message via the
    `message` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to test whether the backend is called in the correct way when the notifier
    is called with the public API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would not be an extensive test but the basic assertion is that the backend
    we are using, which the notifier abstracts us from, is called. To make this more
    valuable, we would also need to assert the correct way of calling, as well as
    the calling of the dependencies further down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second point requires an integration test to be set up to cover the interaction
    between the two or more contexts without the involvement of mocks or stubs. This
    of course means that the test will most likely be more complicated than a test
    allowing mocks and stubs to tightly control the environment, and therefore it
    is often limited to quite a simple test, to ensure that a basic interaction works.
    An integration test should not go into too much detail in this case, as this might
    ossify the API more than intended. The following code tests the integration of
    the prisoner transfer system in the system as a whole, using the different required
    subsystems like the dungeon as integration points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how much more involved an end-to-end test ensuring
    a prisoner transfer can be. Due to this complexity, it only makes sense to test
    simple interactions as otherwise the end-to-end tests quickly become hard to maintain
    with small changes, and they should only cover the interactions on a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of end-to-end or, integration tests across the boundaries of the system,
    is to ensure that the basic interactions work. The goal of unit tests is that
    the module in itself behaves as we want it to. This leaves a level open, which
    becomes obvious when running a service in production.
  prefs: []
  type: TYPE_NORMAL
- en: TDD and testing in production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test-driven development allows us to design a system that is easy to change
    and evolve; on the contrary, it does not ensure a perfect function of course.
    We first write a "broken" test, a test where the underlying functionality is still
    missing, and then write the code to satisfy it. We don't write tests to be perfectly
    safe from production bugs, because we can never anticipate all the possible complications
    that may arise. We write the tests to allow our system to be flexible and also
    to allow it to be ready for production in the sense that we can introspect its
    behavior and have the contexts reasonably well isolated to deal with failure.
  prefs: []
  type: TYPE_NORMAL
- en: When moving code to production, we are exercising the system in a new way, and
    for this we need to be ready to monitor and introspect. This kind of introspection
    and monitoring also allows easy tests due to the injection of logging modules
    and others that allow simpler assertions of integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how a system of contexts can help us create a more stable and
    easier to maintain system. In the following section, we are focusing on how to
    actually maintain the context within the application to fight the leaking of abstractions
    and leaking context across, and how this relates to different ways of organizing
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The different ways to manage contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the main purpose of the context in our application has been to separate
    different modules and make the complexity of the whole application more manageable
    by abstracting out APIs. The other important benefits of separate contexts are
    the fact that we can start to explore different ways of managing application development
    in those decoupled parts.
  prefs: []
  type: TYPE_NORMAL
- en: The way applications are developed evolves as the industry around software evolves
    at a rapid pace. Development principles that were state of the art just a couple
    years ago are being frowned upon now and developers want to move to new ways of
    making them more productive while promising bug-free, easier to manage applications.
    Of course, switching out the development principles is not free, and more often
    than not new ways don't necessarily match the way complete organizations can,
    or want, to work. By separating out the contexts of the application, we can start
    exploring those new ways alongside the well-established ones and keep the team
    evolving and developing alongside the applications they maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The first step towards manageable contexts is drawing a map of their relationships
    and starting to make a clear separation, using the language we established. With
    this map, we can start to think of ways to divide the application and break it
    into different ways to enable maximum productivity within the team.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a context map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prisoner transport application that we have been following throughout the
    book so far involves multiple contexts. Each context can be abstracted by a clear
    API, and aggregates multiple collaborators to make the prisoner transport, as
    a whole, work. We can follow these collaborators in the integration test we have
    seen before, and draw out their relationship on a map for everybody on the project
    to keep in mind. The following diagram shows an outline of the different contexts
    involved in the prisoner transport, including their role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a context map](graphics/B03704_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The map, for now, involves four main contexts as we saw in the previous integration
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: Prisoner management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dungeons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messaging system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each context is responsible for providing the collaborators needed to make an
    actual transport between the dungeons happen, and provided the API stays consistent,
    it can be replaced with a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Investigation into the context shows differences that are going to increase
    as the application evolves, which means different strategies are needed to manage
    the contexts. There is the dungeon as the main entry point to the application,
    which manages most of the raw resources. The dungeon is going to be like the sun
    in the dungeon management solar system. It provides access to the resources, which
    can then be used to accomplish different tasks. Due to this, the dungeon is a
    shared core of the application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are different sub-domains that use the resources provided
    by the dungeon that gather around. The messaging system, for example, provides
    infrastructure to different systems, in a largely decoupled way to augment tasks
    as they are done by other systems. The prisoner transfer we have seen is one of
    the sub-domains tying those other sub-domains together. We use resources provided
    by the dungeon to build a prisoner transfer, and we use the decoupled messaging
    functionality to augment the transfer task.
  prefs: []
  type: TYPE_NORMAL
- en: Those three systems show how we have different contexts working together and
    providing resources to accomplish the tasks the system is to build. As we build
    them, we need to think about how those sub-domains should be related. Depending
    on the different types of subsystem that are being built, different forms of context
    relationships are useful and best support the development. One thing to keep in
    mind, so as long as the application is simple enough, is that most of those will
    add more overhead to the development than they add flexibility, as sharing aspects
    of the application will, by definition, become more complicated than it has been
    before.
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When starting out with development, the team developing the application is most
    likely small and the context of the application is in itself not large yet. At
    this stage, it most likely does not make sense to break out the contexts of the
    application domain, as those are still flexible and have not evolved enough to
    warrant a separate team to take care of them. Also, APIs at this stage are not
    stable enough to implement a solid abstraction, no matter how much planning has
    gone into the details beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Martin Fowler has been talking about this as well and he recommends a strategy
    of building a monolith first and breaking it up as needed. You can find more on
    this on his blog at [http://martinfowler.com/bliki/MonolithFirst.html](http://martinfowler.com/bliki/MonolithFirst.html).
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, application development will progress best using a monolithic
    architecture that provides shared access to the models. This does not mean, of
    course, that everything should be one big pile of code, but especially in a monolith
    it is easy to break out objects as everybody has access to them anyway. This will
    make it easier to break apart the application afterwards as borders tend to evolve
    during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the way we have been developing the application so far; even though
    we recognize that there are contexts, those contexts don''t necessarily mean separation
    into different applications or domains, but for now they are a map in the developer''s
    mind to guide the location of the code as well as the flow of interactions. Taking
    a look at the prisoner transport, it can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Right now, the code accesses each part of the application directly. Even though
    the communication is wrapped into an object that controls the flow, the prisoner
    transfer has a lot of interaction happening, which will need to be accessed over
    the network if the application is broken apart. This kind of organization is typical
    for a monolithic application and will change when it is broken into different
    pieces, but the overall contexts will remain.
  prefs: []
  type: TYPE_NORMAL
- en: A shared kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that the dungeon is like the sun in our orc dungeon management
    universe, so it only makes sense to share its functionality across the applications
    that interact with it in some way.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of development is a **shared kernel**. The dungeon itself provides
    functionality that will need to be replicated in many different places unless
    it is shared in some way, and since the functionality is such a crucial part,
    it does not go well with a slow interface that is part of a supply chain, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dungeon provides many useful interfaces for the different parts that use
    it, so the functionality needs to be developed in tandem with the consumers. Going
    back to the prisoner transport, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used a common pattern, which uses an `init` method
    to encapsulate some logic needed to initialize the dungeon. This is often useful
    to make the creation easy to use from the outside, and instead of handling it
    in a complex constructor, we move it out to a separate factory method. The advantage
    is that the return of a simple method is easier to handle than using a complex
    constructor, as a failing constructor might end in a half-initialized object.
  prefs: []
  type: TYPE_NORMAL
- en: The important point in this is that the dungeon now supports a specific endpoint
    to provide the resources needed for the transfer to happen. This would most likely
    lock the given resources and initialize a transaction for them so they don't get
    reused without their reuse being possible in the physical world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to our shared kernel nature, this change can happen in the prisoner transfer
    and the dungeon part of the application in tandem. The shared kernel is, of course,
    not without problems, as it creates strong coupling between the parts. It is always
    useful to keep this in mind and think twice about whether pieces are really needed
    in the shared kernel or whether they belong in another part of the application.
    Shared data does not mean there is a reason to share code. The view of what a
    prisoner transfer is can be different throughout the application: while the transfer
    itself might care more about details, the messaging service sharing the data of
    the transfer to create a message to send cares only about the target and the source,
    as well as the prisoners involved in the transfer. So sharing code between the
    two contexts would confuse each domain with unnecessary and unrelated knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of a shared context like this means that the teams working
    inside the shared context must work closely together, and that this part of the
    application has to be vigorously refactored and reviewed so it does not get out
    of hand. It is a straight evolution of the monolith, so to speak, but it takes
    the application a step further towards being split into multiple ones.
  prefs: []
  type: TYPE_NORMAL
- en: For many applications, splitting out some basic elements with a lot of churn
    is enough, and the application can evolve much more quickly using a shared kernel
    where the development team coordinates. This of course forces the team to trust
    each others decisions in general and the communication overhead between the engineers
    can grow with the shared kernel, evolving at this point, the application has solidified
    to a stage where teams can take over the responsibilities for application parts,
    rolling them in their own.
  prefs: []
  type: TYPE_NORMAL
- en: The APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building distinct applications requires a set of APIs that can be relied upon.
    With APIs like this, it is possible to extract certain sub-domains from the main
    domain and application, which can start to evolve completely separately to the
    main application as long as they continue to conform to the same API as before.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to identify a sub-domain first to allow it to have a clean API
    layer to build upon. Looking at the context map will show the interactions of
    the sub-domains, and those interactions are what an API model should be based
    on. Starting out by building in a more monolithic way and breaking out pieces
    as they are solidified in their sub-domain will lead towards this naturally.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conforming to the same API as before is often only regarded as taking the same
    input and producing the same output, there is more to it so to provide a drop-in
    replacement. New applications need to provide similar guarantees towards response
    time and other service levels, such as data persistence for example. A drop-in
    replacement is easier said than done in most cases, but evolving an application
    toward better service levels is often easier in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: As we develop the application, we are now free to branch off while staying true
    to the mission of the application. We are providing a service to other applications
    who need to conform to our way of doing things but only up to the call of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The customer and the supplier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application that provides a service is a supplier of a certain service. We
    can think of the messaging system as such a service. It provides other applications
    with an entry point to send messages across certain end points. Those end points
    need to provide the necessary calls if they want to receive messages while the
    messaging system takes care of the delivery of the message. An application using
    the messaging system needs to call into the system in a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: Such a way of interaction is very abstract, and a good application like this
    does not provide many endpoints but very high-level entry points to the system
    in general to make the use as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using an internal application like this can be done in multiple ways. The interface
    can be very simple, for example, a very basic call over HTTP like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A call like this does not need a separate client for most languages as it is
    very easy to interact with and will be bundled in to the customer application
    in whatever way is deemed best.
  prefs: []
  type: TYPE_NORMAL
- en: Not every application can provide such an easy interface of course, so at this
    stage there is the need to provide a client, which at best is shared between the
    different customers of the application, to not duplicate work. This can be provided
    either by the developing application in the case of complex clients or can be
    initiated by one of the customer applications and then shared in the same style
    as a shared kernel. While in most bigger systems it seems that the client is more
    often than not provided by the application development team, this is not necessarily
    the best way as they are not always aware of the intricacies that using their
    application involves, and therefore invite wrapping clients for each consumer
    to evolve alongside the internal client.
  prefs: []
  type: TYPE_NORMAL
- en: The conformist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The split of an application into an API supplier and consumer is a very distinct
    split and, even with the provided clients, it means that the application now consists
    of multiple parts that are no longer developed as a unit. This kind of split is
    often suggested to increase the speed of development as the team can be smaller
    and there is no longer such a strong communication needed. However, this comes
    at a price when the two separate applications need to work together to provide
    new features.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to communicate across borders, it is expensive, not only in terms
    of networking and method call speed, but in terms of team communication overall.
    The teams providing different parts of the application are not set up to work
    with each other and the time it takes to set this structure up is an overhead
    we have to pay for every time a feature is developed in collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations…* |  
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*M. Conway* |'
  prefs: []
  type: TYPE_TB
- en: This kind of development is kind of the inverse effect of *Conway's law*, because
    as organizations will produce systems constrained by their structure, forcing
    different structures will inadvertently slow down the team as it is not fit to
    develop such an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When confronted with an increasing application, we need to make a choice: we
    can either decide to break up the application or deal with the result of growing
    pains. Dealing with the pains of a legacy application and just conforming to the
    development route it took can be a good choice depending on where the overall
    system is supposed to go. If, for example, the application is in maintenance mode
    for some time and it is unlikely that it will gain features any time soon, deciding
    to just continue on this route, even if the model is not perfect and the code
    base seems legacy, might well be the best choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Being a conformist is the unpopular choice, but it follows the suit of "never
    do a rewrite" and, after all, it is more rewarding to work on an application that
    is actually useful than on one that might be nicely engineered but does not provide
    value and is therefore neglected sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: The anticorruption layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a certain point in the application's life where just adding more features
    and conforming to the already present design is not productive anymore. At this
    stage, it makes sense to split from the main application and start to break out
    of the cycle of ever increasing complexity in the software. At this stage, it
    is a good idea to reform the domain language as well and see where the legacy
    codebase fits into the model, as this allows you to create solid abstractions
    and design a nice API on top of it. This kind of development provides a façade
    over the code, and by this, we mean providing a layer to shield the application
    from old terms and problems that might leak in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The anticorruption layer is a very important pattern when it comes to improving
    applications that are already in production. Isolating a new feature makes it
    easier not only to test , but also can increase reliability and ease the introduction
    of new patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the methodologies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we build a layer like this, we are all about isolating us from the underlying
    technology; this of course means that we should also isolate ourselves from the
    ways of building software present below, and we can start using all the new ways
    developed since the original application was started.
  prefs: []
  type: TYPE_NORMAL
- en: This has one very bad side-effect, which is that the old application instantly
    becomes the legacy not many people want to work on anymore and much blame might
    be thrown toward it. Make sure such a strong split is necessary for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: An anticorruption layer might also make sense in the case where an outside application
    is integrated into the system, for example, credit card processing by an outside
    banking system. External dependencies are best served when isolated from the core
    application, and be it just for the fact that the external API can change and
    adjusting all callers is most likely more complicated then adjusting the internal
    abstraction. This is exactly what an anticorruption layer is good at, so soon
    your internal dependencies are best treated like external ones.
  prefs: []
  type: TYPE_NORMAL
- en: Separate ways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to an anticorruption layer, in a more separate way, tries to solve the
    problem of an application growing apart in the domain. As we develop a common
    language across the system and are breaking the application apart, the language
    will become more refined for some models and the models will increase in complexity
    in certain applications, but not necessarily in others. This can lead to problems
    where a shared core is used because this core needs to incorporate the maximum
    complexity required by each sub-domain and therefore continues to grow while we
    would rather keep it small.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is deciding when a certain application needs to be split at the
    domain model level because the increased complexity for one part does not enhance
    another parts' usability anymore. In our application, the likely candidate is
    the dungeon model that is shared across the other applications. We want to keep
    it as small as possible, but parts of the application will have different demands
    on it. The messaging subsystem will have to focus on the delivery of messages
    to the dungeon and increase the complexity of this part, while the system to handle
    prisoner transport prerequisites will care about other resource management parts.
  prefs: []
  type: TYPE_NORMAL
- en: Unrelated applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With different applications having such different requirements towards the core
    domain, it can make sense not share the model but build a specific one for the
    applications that need it, sharing only a datastore or some other means to share
    the state. The goal is to reduce dependencies and this can mean only sharing what
    actually needs to be shared, even if the names might suggest otherwise. When sharing
    a data store, it is important to keep in mind that only the sub-domain that owns
    the data should be able to modify it, while all others should be using an API
    to access the data, or only have read-only access. It comes down to whether the
    overhead of an API is sustainable, or whether direct integration is needed for
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: When applications start using models in different ways and the only reason they
    share a model is the fact that the model is named the same, we can start to look
    for more specific names that are fit for purpose, and at some point we can even
    get rid of the primary model completely. In our dungeon example, the case may
    be that, over time, the dungeon itself gets reduced to only being the entry point
    of the application, acting as a router to the managing sub-domain applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving more functionality outside the initially shared context of the application
    into other contexts means that we reduce the surface of our shared sub-domain,
    and that we misidentified the role of this domain in the beginning. This is nothing
    bad since every application should be built to evolve, and as contexts become
    more clear, this can in turn clarify the sub-domain borders that were previously
    unclear.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't get too attached to your understanding of the borders of domains and sub-domains.
    As gaining experience from business experts can improve your understanding of
    a sub-domain, so can the refining of a bounded context in turn influence the domain.
  prefs: []
  type: TYPE_NORMAL
- en: An open protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step in making applications truly independent is publishing them as
    an open protocol. The point is to make the core functionality of the application
    accessible openly from the outside as a published standard. This is very seldom
    the case as it requires a lot of maintenance and setup initially. The best candidates
    for an open protocol are special communication layers used to communicate with
    the application to allow external clients.
  prefs: []
  type: TYPE_NORMAL
- en: The API of an application can be considered an open protocol when it invites
    in external users, and maybe even external clients. In our dungeon applications
    we might, at some point, want to make the messaging subsystem an open protocol
    to allow other dungeons to plug in via their own local applications, and therefore
    establishing the standard in the Dungeon Management™.
  prefs: []
  type: TYPE_NORMAL
- en: As this stage, when thinking about the Open Protocols, what we need to focus
    on is the fact of how we can share knowledge of the protocol in an effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We split the application apart into multiple sub-applications of the sub-domains,
    we do this to increase the size of the team and enable better cooperation between
    them. This also means that the team needs to find a way to share the information
    about the application and their usage with new developers as well as with developers
    tapping into the sub-domain to accomplish a certain goal.
  prefs: []
  type: TYPE_NORMAL
- en: The domain language is an important part of our design and we invested some
    time into building it throughout the development so far. We can draw on this and
    make this language available for other developers. The language, as we have seen
    it, slightly adjusts for each module and is a working document that needs to be
    kept up to date, and that means we need to find a way to keep it published.
  prefs: []
  type: TYPE_NORMAL
- en: The publishing language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The language we have been developing is an ever-evolving document, and as such
    we have to think about how to share the knowledge embedded in it. Again let's
    first define what we would do in a perfect world and see how we can approximate
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, the team that started out developing the application would
    stay together for the whole lifetime of the application and continue to grow,
    but the core developers would always be there. A team like this would have the
    major advantage of the terminology and the assumptions of the project being shared
    by the team as they have been following the application through its life, and
    new developers would join and learn from the core team by osmosis, so to speak.
    They would slowly adapt to the team and follow the rules, breaking them if necessary,
    and if agreed upon via the consensus of the team.
  prefs: []
  type: TYPE_NORMAL
- en: We don't live in a perfect world though, and teams are likely to have some churn
    where core developers leave for whatever reason and are replaced with new faces.
    When this happens, there is the risk that the core principles of the application
    can could be lost, that the language around the project does not follow the original
    rules more, and many other bad things. Luckily, compared to olden times, we don't
    have to rely on word of mouth but can document our findings for others to find.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation is often not the favorite part of software development, but this
    comes from the fact that a lot of documentation is not useful in many projects.
    When we create documentation, the important thing is to not state the obvious
    but to actually document the problems and ideas arising during development.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the documentation found on projects is the outline of the methods, what
    parameters they take in, and what they return. This is a good start but not not
    the end of all documentation necessary. When different people are using the project
    they need to understand the intention behind it to use the API properly. When
    we create an application and decide on what kind of features we want and how they
    work, this is important to document. So far in this book, we have been focusing
    a lot on how to think about application development and also how to make sure
    it is in an understandable form for others to follow. All this is documentation
    that needs to be kept around. We want to be sure that the next person can follow
    the thinking that went into the development, knows what the terms mean, and how
    they relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to start is to keep a central document where this kind of information
    lives close to the application and is accessible to everybody interested. Making
    the document as short as possible and having a way to see it evolve along with
    the project is key, so having some kind of versioning is a very useful feature.
    Going back in time in source code is very common to find out how a certain piece
    of code has changed, and being able to relate the right piece of documentation
    to it is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping a simple text file as the README for the project is a good place to
    start. This README can live inside the application repository, making the relationship
    between documentation and application a very strong one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following we see this by the example of the canned fake API server,
    available at [https://github.com/sideshowcoder/canned](https://github.com/sideshowcoder/canned):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the documentation](graphics/B03704_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The important points for documentation are:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the project in a short statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design ideas followed throughout the project to guide new developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example usages of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation notes for very important pieces of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change history of major changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping the documentation close to the application has some essential advantages;
    it is just way too easy to neglect some document off in a wiki somewhere that
    needs special permissions to access, while looking at something every day when
    working on a project will more likely be kept up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is a living and breathing piece of the overall project and it
    therefore needs to be part of the project itself. Especially in the modern, open
    source inspired development world, the idea that everybody should be able to contribute
    to a project quickly is ingrained in the developer culture and this is a good
    thing. Code speaks louder than a thousand architecture specs, so to speak, and
    therefore limiting the documentation to the core design ideas while letting the
    code explain the specific implementation makes the documentation more useful in
    the long run and keeps developers engaged in the updating process.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are not the only documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One side note about tests: often TDD is stated as having the benefit of providing
    tests as part of the documentation, as they are the examples on how to use the
    code after all. This is often an excuse to not bother to write up any examples
    outside this and also to not document the overall design since reading the tests
    states the design.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that for the tests, all methods are equally
    important. It is very hard to convey an auxiliary decision made because it did
    not seem to have an impact at this moment from a core design idea of the project.
    This makes refactoring hard and is prone to side-track the project and maintain
    features that were never intended to be any in the beginning. For a developer
    coming into a project, the documentation should specify what the core functionality
    is, and if he or she finds a use for some obscure function outside this core,
    this is great and a good place for reading the tests, but there is a way to distinguish
    a feature that has support from the main application versus an auxiliary one.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to try to make this more interactive is README-driven development,
    where we write the README first and make the examples executable, trying to make
    our code pass the examples we specified as the first layer of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more on README-driven development at Tom Preston-Werner's blog,
    [http://tom.preston-werner.com/2010/08/23/readme-driven-development.html](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the interaction between different subprojects
    forming sub-domains and collaborating with each other by different means. This
    collaboration can take many forms and depending on the context and the state of
    the application as a whole, some can be more valuable then others.
  prefs: []
  type: TYPE_NORMAL
- en: The right choice for collaboration is always up for debate, of course, and it
    is very possible to change the mode as the project evolves. An important point
    I would like to get across is that those collaboration ideas are not set in stone;
    it is a sliding scale and every team should decide what works best for them and
    what keeps the actual complexity in the application and the team work low.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part, the chapter focused on the important things when creating
    documentation for a project and how we can make it useful while not diving into
    the realm of creating elaborate specifications that nobody ever touches or even
    understands as soon as they leave the hands of the architect who created them
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore how other development methods fit
    into domain-driven design, how a good object-oriented structure can support the
    design in general, and how domain-driven design is influenced by many other techniques.
  prefs: []
  type: TYPE_NORMAL
