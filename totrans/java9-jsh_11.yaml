- en: Chapter 11. Advanced Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。高级泛型
- en: 'In this chapter, we will dive deep into parametric polymorphism and how Java
    9 allows us to write generic code with classes that use two constrained generic
    types. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨参数多态性以及Java 9如何允许我们编写使用两个受限泛型类型的类的通用代码。我们将：
- en: Work with more advanced scenarios in which we take advantage of parametric polymorphism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更高级的场景中使用参数多态性
- en: Create a new interface to be used as a constraint for a second type parameter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新接口，用作第二个类型参数的约束
- en: Declare two classes that implement an interface to work with two type parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明两个实现接口以处理两个类型参数的类
- en: Declare a class that works with two constrained generic types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个使用两个受限泛型类型的类
- en: Use a generic class with two generic type parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有两个泛型类型参数的泛型类
- en: Creating a new interface to be used as a constraint for a second type parameter
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新接口，用作第二个类型参数的约束
- en: So far, we have been working with parties in which the party members were sociable
    animals. However, it is difficult to enjoy a party without some music. The sociable
    animals need to hear something in order to make them dance and enjoy their party.
    We want to create a party of sociable animals and something hearable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理派对，其中派对成员是善于社交的动物。然而，没有一些音乐很难享受派对。善于社交的动物需要听到一些东西，以便让它们跳舞并享受他们的派对。我们想要创建一个由善于社交的动物和一些可听到的东西组成的派对。
- en: Now, we will create a new interface that we will use as a constraint later when
    we define another class that takes advantage of generics with two constrained
    generic types. The following lines show the code for the `Hearable` interface.
    This interface specifies the requirements that a type must meet in order to be
    considered as hearable, that is, a generator of music for a party in our application
    domain. The `public` modifier followed by the `interface` keyword and the interface
    name, `Hearable`, composes the interface declaration, as follows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的接口，稍后在定义另一个利用两个受限泛型类型的类时将使用该接口作为约束。以下是`Hearable`接口的代码。
- en: The code file for the sample is included in the `java_9_oop_chapter_11_01` folder,
    in the `example11_01.java` file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的代码文件包含在`java_9_oop_chapter_11_01`文件夹中的`example11_01.java`文件中。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interface declares two method requirements: `playMusic` and `playMusicWithLyrics`.
    As we learned in the previous chapters, the interface includes only the method
    declarations because the classes that implement the `Hearable` interface will
    be responsible for providing the implementation of the two methods.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明了两个方法要求：`playMusic`和`playMusicWithLyrics`。正如我们在之前的章节中学到的，接口只包括方法声明，因为实现`Hearable`接口的类将负责提供这两个方法的实现。
- en: Declaring two classes that implement an interface to work with two type parameters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明两个实现接口以处理两个类型参数
- en: Now, we will declare a class named `Smartphone` that implements the previously
    defined `Hearable` interface. We can read the class declaration as "the `Smartphone`
    class implements the `Hearable` interface." The following lines show the code
    for the new class. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_01.java` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明一个名为`Smartphone`的类，该类实现先前定义的`Hearable`接口。我们可以将类声明解读为“`Smartphone`类实现`Hearable`接口”。以下是新类的代码。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Smartphone` class declares a constructor that assigns the value of the
    required `modelName` argument to the `modelName` immutable field. In addition,
    the class implements the two methods required by the `Hearable` interface: `playMusic`
    and `playMusicWithLyrics`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Smartphone`类声明了一个构造函数，将必需的`modelName`参数的值分配给`modelName`不可变字段。此外，该类实现了`Hearable`接口所需的两个方法：`playMusic`和`playMusicWithLyrics`。'
- en: The `playMusic` method prints a message that displays the smartphone model name
    and indicates that the device starts playing music. Then, the method prints multiple
    sounds in words. The `playMusicWithLyrics` method prints a message that displays
    the smartphone model name followed by another message with sounds in words and
    the lyrics received as an argument.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`playMusic`方法打印一条消息，显示智能手机型号名称，并指示设备开始播放音乐。然后，该方法以文字形式打印多个声音。`playMusicWithLyrics`方法打印一条消息，显示智能手机型号名称，然后是另一条包含文字声音和作为参数接收的歌词的消息。'
- en: Now we will declare a class named `AnimalMusicBand` that also implements the
    previously defined `Hearable` interface. We can read the class declaration as
    "the `AnimalMusicBand` class implements the `Hearable` interface." The following
    lines show the code for the new class. The code file for the sample is included
    in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明一个名为`AnimalMusicBand`的类，该类也实现了先前定义的`Hearable`接口。我们可以将类声明解读为“`AnimalMusicBand`类实现`Hearable`接口”。以下是新类的代码。示例的代码文件包含在`java_9_oop_chapter_11_01`文件夹中的`example11_01.java`文件中。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `AnimalMusicBand` class declares a constructor that assigns the value of
    the required `bandName` and `numberOfMembers` arguments to the immutable field
    with the same name as these arguments. In addition, the class implements the two
    methods required by the `Hearable` interface: `playMusic` and `playMusicWithLyrics`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimalMusicBand`类声明了一个构造函数，将必需的`bandName`和`numberOfMembers`参数的值分配给与这些参数同名的不可变字段。此外，该类实现了`Hearable`接口所需的两个方法：`playMusic`和`playMusicWithLyrics`。'
- en: The `playMusic` method prints a message that introduces the animal music band
    to the audience and indicates the number of members. Then, the method prints multiple
    sounds in words. The `playMusicWithLyrics` method prints a message that asks the
    audience to sing together with the animal music band followed by another message
    with sounds in words and the lyrics received as an argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class that works with two constrained generic types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines declare a `PartyWithHearable` subclass of the previously
    created `Party<T>` class that takes advantage of generics to work with two constrained
    types. The type constraints declaration is included within angle brackets (`<>`).
    In this case, we have two generic type parameters: `T` and `U`. The generic type
    parameter named `T` must implement both the `Sociable` and `Comparable<Sociable>`
    interfaces, as it happened in the `Party<T>` superclass. The generic type parameter
    named `U` must implement the `Hearable` interface. Notice that the `extends` keyword
    that follows the type parameter allows us to add the constraints to the generic
    type parameters and the same keyword after the angle brackets specifies that the
    class inherits from the `Party<T>` superclass. This way, the class specifies constraints
    for both the `T` and `U` generic type parameters, and inherits from `Party<T>`.The
    code file for the sample is included in the `java_9_oop_chapter_11_01` folder,
    in the `example11_01.java` file.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When type parameters have constraints in Java, they are also known as **bounded
    type parameters**. In addition, the type constraint is also known as the **upper
    bound** for the bounded type parameter because any class that implements the interface
    used as an upper bound or any subclass of the class indicated as an upper bound
    can be used for the type parameter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will analyze many code snippets to understand how the code included
    in the `PartyWithHearable<T, U>` class works. The following line starts the class
    body and declares a protected immutable `soundGenerator` field of the type specified
    by `U`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following lines declare an initializer that receives two arguments, `partyLeader`
    and `soundGenerator`, whose types are `T` and `U`. The arguments specify the first
    party leader that will also become the first member of the party, and the sound
    generator that will make the party members dance and sing. The constructor calls
    the constructor defined in its superclass, with `partyLeader` as an argument,
    by using the `super` keyword.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following lines declare a `makeMembersDance` method that overrides the
    method with the same declaration included in the superclass. The code calls the
    `soundGenetor.playMusic` method and then the `super.makeMembersDance` method,
    that is, the `makeMembersDance` method defined in the `Party<T>` superclass, by
    using the `super` keyword:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we override a method in a subclass, we can call the method defined in the
    superclass by using the `super` keyword followed by a dot (`.`) and the method
    name, and passing the required arguments to the method. The usage of the `super`
    keyword allows us to call the instance method defined in the superclass that we
    have overridden. This way, we can add new features to a method and still call
    the base method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following lines declare a `makeMembersSingALyric` method that
    overrides the method with the same declaration included in the superclass. The
    code calls the `soundGenerator.playMusicWithLyrics` method with the received `lyrics`
    as an argument. Then, the code calls the `super.makeMembersSingALyric` method
    with the received `lyrics` as an argument, that is, the `makeMembersSingALyric`
    method defined in the `Party<T>` superclass:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The following UML diagram shows the interface and the concrete subclasses that
    we will create, including all the fields and methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring a class that works with two constrained generic types](img/00091.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Creating instances of a generic class with two generic type parameters
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create instances of the `PartyWithHearable<T, U>` class by replacing
    both the `T` and `U` generic type parameters with any type names that conform
    to the constraints or the upper bounds specified in the declaration of the `PartyWithHearable<T,
    U>` class. We have three concrete classes that implement both the `Sociable` and
    `Comparable<Sociable>` interfaces required by the `T` generic type parameter:
    `SocialLion`, `SocialParrot`, and `SocialSwan`. We have two classes that implement
    the `Hearable` interface required by the `U` generic type parameter: `Smartphone`
    and `AnimalMusicBand`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We can use `SocialLion` and `Smartphone` to create an instance of `PartyWithHearable<SocialLion,
    Smartphone>`, that is, a party of social lions and a smartphone. Then, we can
    use `SocialParrot` and `AnimalMusicBand` to create an instance of `PartyWithHearable<SocialParrot,
    AnimalMusicBand>`, that is, a party of social parrots and an animal music band.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a `Smartphone` instance named `android`. Then, the
    code creates a `PartyWithHearable<SocialLion, Smartphone>` instance named `nalaParty`
    and passes `nala` and `android` as arguments. We take advantage of type inference
    and we use the diamond notation we learned in the previous chapter, [Chapter 10](part0089_split_000.html#2KS221-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 10. Maximization of Code Reuse with Generics"), *Maximization of Code
    Reuse with Generics*. This way, we create a party of social lions that use a smartphone,
    where `Nala` is the party leader, and `Super Android Smartphone` is the hearable
    or music generator. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_01.java` file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `nalaParty` instance will only accept a `SocialLion` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The `nalaParty` instance will only accept a `Smartphone` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `U`. The following lines add the previously created three instances of `SocialLion`
    to the party by calling the `addMember` method. The code file for the sample is
    included in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java`
    file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00092.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: The following lines call the `makeMembersDance` method to make the smartphone's
    playlist invite all the lions to dance and make them dance. Then, the code calls
    the `removeMember` method to remove a member that isn't the party leader, use
    the `declareNewPartyLeader` method to declare a new leader, and finally calls
    the `makeMembersSingALyric` method to make the smartphone's playlist invite all
    the lions to sing a specific lyric and make them sing this lyric. Remember that
    we add the `try` keyword before the calls to `removeMember` and `declareNewPartyLeader`
    because these methods can throw exceptions. The code file for the sample is included
    in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java` file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00093.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following lines create an `AnimalMusicBand` instance named `band`. Then,
    the code creates a `PartyWithHearable<SocialParrot, AnimalMusicBand>` instance
    named `ramboParty` and passes `rambo` and `band` as arguments. As happened in
    the previous example, we take advantage of type inference and we use the diamond
    notation we learned in the previous chapter, [Chapter 10](part0089_split_000.html#2KS221-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 10. Maximization of Code Reuse with Generics"), *Maximization of Code
    Reuse with Generics*. This way, we create a party of social parrots that have
    a music band composed of four animals, where `Rambo` is the party leader, and
    `Black Eyed Paws` is the hearable or music generator. The code file for the sample
    is included in the `java_9_oop_chapter_11_01` folder, in the `example11_02.java`
    file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`band`的`AnimalMusicBand`实例。然后，代码创建了一个名为`ramboParty`的`PartyWithHearable<SocialParrot,
    AnimalMusicBand>`实例，并将`rambo`和`band`作为参数传递。与之前的示例一样，我们利用了类型推断，并且使用了我们在上一章学习的菱形符号，[第10章](part0089_split_000.html#2KS221-bc1530b4c4784270ae8a31a7038f8341
    "第10章。泛型的代码重用最大化"), *泛型的代码重用最大化*。这样，我们创建了一个由四只动物组成的音乐乐队的社交鹦鹉派对，其中`Rambo`是派对领袖，`Black
    Eyed Paws`是可听到的或音乐发生器。示例的代码文件包含在`java_9_oop_chapter_11_01`文件夹中的`example11_02.java`文件中。
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ramboParty` instance will only accept a `SocialParrot` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `T`. The `ramboParty` instance will only accept an `AnimalMusicBand` instance
    for all the arguments in which the class definition uses the generic type parameter
    named `U`. The following lines add the previously created three instances of `SocialParrot`
    to the party by calling the `addMember` method. The code file for the sample is
    included in the `java_9_oop_chapter_11_01` folder, in the `example11_02.java`
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ramboParty`实例只接受`SocialParrot`实例作为类定义中使用泛型类型参数`T`的所有参数。`ramboParty`实例只接受`AnimalMusicBand`实例作为类定义中使用泛型类型参数`U`的所有参数。以下行通过调用`addMember`方法将之前创建的三个`SocialParrot`实例添加到派对中。示例的代码文件包含在`java_9_oop_chapter_11_01`文件夹中的`example11_02.java`文件中。'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following screenshot shows the results of executing the previous code in
    JShell.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上一个代码的结果。
- en: '![Creating instances of a generic class with two generic type parameters](img/00094.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用两个泛型类型参数创建泛型类的实例](img/00094.jpeg)'
- en: The following lines call the `makeMembersDance` method to make the animal music
    band invite all the parrots to dance, tell them they are four members in the band
    and make them dance. Then, the code calls the `removeMember` method to remove
    a member that isn't the party leader, use the `declareNewPartyLeader` method to
    declare a new leader, and finally calls the `makeMembersSingALyric` method to
    make the animal music band invite all the parrots to sing a specific lyric and
    make them sing this lyric. Remember that we add the `try` keyword before the calls
    to `removeMember` and `declareNewPartyLeader` because these methods can throw
    exceptions. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_02.java` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`makeMembersDance`方法，使动物音乐乐队邀请所有鹦鹉跳舞，告诉它们乐队中有四名成员并让它们跳舞。然后，代码调用`removeMember`方法来移除不是派对领袖的成员，使用`declareNewPartyLeader`方法来声明一个新的领袖，最后调用`makeMembersSingALyric`方法，使动物音乐乐队邀请所有鹦鹉唱特定的歌词并让它们唱这个歌词。请记住，在调用`removeMember`和`declareNewPartyLeader`之前我们加上了`try`关键字，因为这些方法可能会抛出异常。示例的代码文件包含在`java_9_oop_chapter_11_01`文件夹中的`example11_02.java`文件中。
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上一个代码的结果：
- en: '![Creating instances of a generic class with two generic type parameters](img/00095.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用两个泛型类型参数创建泛型类的实例](img/00095.jpeg)'
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在JShell中运行前面的代码片段后的输出。但是，我们必须考虑到新派对领袖的伪随机选择，因此结果在每次执行时会有所不同：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Test your knowledge
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The `PartyWithHearable<T extends Sociable & Comparable<Sociable>, U extends
    Hearable>` line means:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PartyWithHearable<T extends Sociable & Comparable<Sociable>, U extends Hearable>`这一行的意思是：'
- en: The generic type constraint specifies that `T` must implement either the `Sociable`
    or `Comparable<Sociable>` interfaces, and `U` must implement the `Hearable` interface.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类型约束指定`T`必须实现`Sociable`或`Comparable<Sociable>`接口，`U`必须实现`Hearable`接口。
- en: The class is a subclass of the `Sociable`, `Comparable<Sociable>`, and `Hearable`
    classes.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类是`Sociable`、`Comparable<Sociable>`和`Hearable`类的子类。
- en: The generic type constraint specifies that `T` must implement both the `Sociable`
    and `Comparable<Sociable>` interfaces, and `U` must implement the `Hearable` interface.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类型约束指定`T`必须实现`Sociable`和`Comparable<Sociable>`接口，`U`必须实现`Hearable`接口。
- en: 'Which of the following lines is equivalent to `PartyWithHearable<SocialLion,
    Smartphone>lionsParty = new PartyWithHearable<SocialLion, Smartphone>(nala, android);`
    in Java 9:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一行等同于Java 9中的`PartyWithHearable<SocialLion, Smartphone>lionsParty = new PartyWithHearable<SocialLion,
    Smartphone>(nala, android);`：
- en: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable<>(nala,
    android);`'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable<>(nala,
    android);`'
- en: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable(nala,
    android);`'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable(nala,
    android);`'
- en: '`let lionsParty = new PartyWithHearable(nala, android);`'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let lionsParty = new PartyWithHearable(nala, android);`'
- en: 'When we use a bounded type parameter with the `extends` keyword:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在使用`extends`关键字的有界类型参数时：
- en: Any class that implements the interface indicated as an upper bound can be used
    for the type parameter. In case the indicated name is a name of a class, its subclasses
    cannot be used for the type parameter.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any class that implements the interface indicated as an upper bound or any subclass
    of the class indicated as an upper bound can be used for the type parameter.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any subclass of the class indicated as an upper bound can be used for the type
    parameter. In case the indicated name is a name of an interface, the classes that
    implement the interface cannot be used for the type parameter.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When type parameters have constraints in Java, they are also known as:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flexible type parameters.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbounded type parameters.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bounded type parameters.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets declares a class whose generic type constraint
    specifies that `T` must implement the `Sociable` interface and `U` must implement
    the `Convertible` interface:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T: where T is Sociable, U: where U is Convertible>`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable> where U: Convertible`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable, U extends Convertible>`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to maximize code reuse by writing code capable
    of working with two type parameters. We worked with more complex scenarios that
    involve interfaces, generics, and multiple type parameters that have constraints,
    also known as bounded type parameters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We created a new interface and then we declared two classes that implemented
    this new interface. Then, we declared a class that worked with two constrained
    generic type parameters. We combined class inheritance and interfaces to maximize
    the reusability of code. We could make classes work with many different types
    and we were able to code the behavior of a party with different music generators
    that could then be reused to create parties of lions with a smartphone and parties
    of parrots with bands of animals.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 allows us to work with more complex scenarios in which we can specify
    more restrictions or bounds to the generic type parameters. However, most of the
    time, we will work with the cases covered by the samples we learned in this chapter
    and in the previous one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned advanced usages of parametric polymorphism and generics,
    we are ready to combine object-oriented programming and functional programming
    in Java 9, which is the topic we are going to discuss in the next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
