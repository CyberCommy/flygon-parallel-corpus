- en: Chapter 11. Advanced Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive deep into parametric polymorphism and how Java
    9 allows us to write generic code with classes that use two constrained generic
    types. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with more advanced scenarios in which we take advantage of parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new interface to be used as a constraint for a second type parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare two classes that implement an interface to work with two type parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare a class that works with two constrained generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a generic class with two generic type parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new interface to be used as a constraint for a second type parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with parties in which the party members were sociable
    animals. However, it is difficult to enjoy a party without some music. The sociable
    animals need to hear something in order to make them dance and enjoy their party.
    We want to create a party of sociable animals and something hearable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a new interface that we will use as a constraint later when
    we define another class that takes advantage of generics with two constrained
    generic types. The following lines show the code for the `Hearable` interface.
    This interface specifies the requirements that a type must meet in order to be
    considered as hearable, that is, a generator of music for a party in our application
    domain. The `public` modifier followed by the `interface` keyword and the interface
    name, `Hearable`, composes the interface declaration, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The code file for the sample is included in the `java_9_oop_chapter_11_01` folder,
    in the `example11_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface declares two method requirements: `playMusic` and `playMusicWithLyrics`.
    As we learned in the previous chapters, the interface includes only the method
    declarations because the classes that implement the `Hearable` interface will
    be responsible for providing the implementation of the two methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring two classes that implement an interface to work with two type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will declare a class named `Smartphone` that implements the previously
    defined `Hearable` interface. We can read the class declaration as "the `Smartphone`
    class implements the `Hearable` interface." The following lines show the code
    for the new class. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Smartphone` class declares a constructor that assigns the value of the
    required `modelName` argument to the `modelName` immutable field. In addition,
    the class implements the two methods required by the `Hearable` interface: `playMusic`
    and `playMusicWithLyrics`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `playMusic` method prints a message that displays the smartphone model name
    and indicates that the device starts playing music. Then, the method prints multiple
    sounds in words. The `playMusicWithLyrics` method prints a message that displays
    the smartphone model name followed by another message with sounds in words and
    the lyrics received as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will declare a class named `AnimalMusicBand` that also implements the
    previously defined `Hearable` interface. We can read the class declaration as
    "the `AnimalMusicBand` class implements the `Hearable` interface." The following
    lines show the code for the new class. The code file for the sample is included
    in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AnimalMusicBand` class declares a constructor that assigns the value of
    the required `bandName` and `numberOfMembers` arguments to the immutable field
    with the same name as these arguments. In addition, the class implements the two
    methods required by the `Hearable` interface: `playMusic` and `playMusicWithLyrics`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `playMusic` method prints a message that introduces the animal music band
    to the audience and indicates the number of members. Then, the method prints multiple
    sounds in words. The `playMusicWithLyrics` method prints a message that asks the
    audience to sing together with the animal music band followed by another message
    with sounds in words and the lyrics received as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class that works with two constrained generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines declare a `PartyWithHearable` subclass of the previously
    created `Party<T>` class that takes advantage of generics to work with two constrained
    types. The type constraints declaration is included within angle brackets (`<>`).
    In this case, we have two generic type parameters: `T` and `U`. The generic type
    parameter named `T` must implement both the `Sociable` and `Comparable<Sociable>`
    interfaces, as it happened in the `Party<T>` superclass. The generic type parameter
    named `U` must implement the `Hearable` interface. Notice that the `extends` keyword
    that follows the type parameter allows us to add the constraints to the generic
    type parameters and the same keyword after the angle brackets specifies that the
    class inherits from the `Party<T>` superclass. This way, the class specifies constraints
    for both the `T` and `U` generic type parameters, and inherits from `Party<T>`.The
    code file for the sample is included in the `java_9_oop_chapter_11_01` folder,
    in the `example11_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When type parameters have constraints in Java, they are also known as **bounded
    type parameters**. In addition, the type constraint is also known as the **upper
    bound** for the bounded type parameter because any class that implements the interface
    used as an upper bound or any subclass of the class indicated as an upper bound
    can be used for the type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will analyze many code snippets to understand how the code included
    in the `PartyWithHearable<T, U>` class works. The following line starts the class
    body and declares a protected immutable `soundGenerator` field of the type specified
    by `U`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare an initializer that receives two arguments, `partyLeader`
    and `soundGenerator`, whose types are `T` and `U`. The arguments specify the first
    party leader that will also become the first member of the party, and the sound
    generator that will make the party members dance and sing. The constructor calls
    the constructor defined in its superclass, with `partyLeader` as an argument,
    by using the `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines declare a `makeMembersDance` method that overrides the
    method with the same declaration included in the superclass. The code calls the
    `soundGenetor.playMusic` method and then the `super.makeMembersDance` method,
    that is, the `makeMembersDance` method defined in the `Party<T>` superclass, by
    using the `super` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we override a method in a subclass, we can call the method defined in the
    superclass by using the `super` keyword followed by a dot (`.`) and the method
    name, and passing the required arguments to the method. The usage of the `super`
    keyword allows us to call the instance method defined in the superclass that we
    have overridden. This way, we can add new features to a method and still call
    the base method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following lines declare a `makeMembersSingALyric` method that
    overrides the method with the same declaration included in the superclass. The
    code calls the `soundGenerator.playMusicWithLyrics` method with the received `lyrics`
    as an argument. Then, the code calls the `super.makeMembersSingALyric` method
    with the received `lyrics` as an argument, that is, the `makeMembersSingALyric`
    method defined in the `Party<T>` superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The following UML diagram shows the interface and the concrete subclasses that
    we will create, including all the fields and methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring a class that works with two constrained generic types](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating instances of a generic class with two generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create instances of the `PartyWithHearable<T, U>` class by replacing
    both the `T` and `U` generic type parameters with any type names that conform
    to the constraints or the upper bounds specified in the declaration of the `PartyWithHearable<T,
    U>` class. We have three concrete classes that implement both the `Sociable` and
    `Comparable<Sociable>` interfaces required by the `T` generic type parameter:
    `SocialLion`, `SocialParrot`, and `SocialSwan`. We have two classes that implement
    the `Hearable` interface required by the `U` generic type parameter: `Smartphone`
    and `AnimalMusicBand`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `SocialLion` and `Smartphone` to create an instance of `PartyWithHearable<SocialLion,
    Smartphone>`, that is, a party of social lions and a smartphone. Then, we can
    use `SocialParrot` and `AnimalMusicBand` to create an instance of `PartyWithHearable<SocialParrot,
    AnimalMusicBand>`, that is, a party of social parrots and an animal music band.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a `Smartphone` instance named `android`. Then, the
    code creates a `PartyWithHearable<SocialLion, Smartphone>` instance named `nalaParty`
    and passes `nala` and `android` as arguments. We take advantage of type inference
    and we use the diamond notation we learned in the previous chapter, [Chapter 10](part0089_split_000.html#2KS221-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 10. Maximization of Code Reuse with Generics"), *Maximization of Code
    Reuse with Generics*. This way, we create a party of social lions that use a smartphone,
    where `Nala` is the party leader, and `Super Android Smartphone` is the hearable
    or music generator. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `nalaParty` instance will only accept a `SocialLion` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The `nalaParty` instance will only accept a `Smartphone` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `U`. The following lines add the previously created three instances of `SocialLion`
    to the party by calling the `addMember` method. The code file for the sample is
    included in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines call the `makeMembersDance` method to make the smartphone's
    playlist invite all the lions to dance and make them dance. Then, the code calls
    the `removeMember` method to remove a member that isn't the party leader, use
    the `declareNewPartyLeader` method to declare a new leader, and finally calls
    the `makeMembersSingALyric` method to make the smartphone's playlist invite all
    the lions to sing a specific lyric and make them sing this lyric. Remember that
    we add the `try` keyword before the calls to `removeMember` and `declareNewPartyLeader`
    because these methods can throw exceptions. The code file for the sample is included
    in the `java_9_oop_chapter_11_01` folder, in the `example11_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The following lines create an `AnimalMusicBand` instance named `band`. Then,
    the code creates a `PartyWithHearable<SocialParrot, AnimalMusicBand>` instance
    named `ramboParty` and passes `rambo` and `band` as arguments. As happened in
    the previous example, we take advantage of type inference and we use the diamond
    notation we learned in the previous chapter, [Chapter 10](part0089_split_000.html#2KS221-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 10. Maximization of Code Reuse with Generics"), *Maximization of Code
    Reuse with Generics*. This way, we create a party of social parrots that have
    a music band composed of four animals, where `Rambo` is the party leader, and
    `Black Eyed Paws` is the hearable or music generator. The code file for the sample
    is included in the `java_9_oop_chapter_11_01` folder, in the `example11_02.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ramboParty` instance will only accept a `SocialParrot` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `T`. The `ramboParty` instance will only accept an `AnimalMusicBand` instance
    for all the arguments in which the class definition uses the generic type parameter
    named `U`. The following lines add the previously created three instances of `SocialParrot`
    to the party by calling the `addMember` method. The code file for the sample is
    included in the `java_9_oop_chapter_11_01` folder, in the `example11_02.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous code in
    JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines call the `makeMembersDance` method to make the animal music
    band invite all the parrots to dance, tell them they are four members in the band
    and make them dance. Then, the code calls the `removeMember` method to remove
    a member that isn't the party leader, use the `declareNewPartyLeader` method to
    declare a new leader, and finally calls the `makeMembersSingALyric` method to
    make the animal music band invite all the parrots to sing a specific lyric and
    make them sing this lyric. Remember that we add the `try` keyword before the calls
    to `removeMember` and `declareNewPartyLeader` because these methods can throw
    exceptions. The code file for the sample is included in the `java_9_oop_chapter_11_01`
    folder, in the `example11_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous code in
    JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of a generic class with two generic type parameters](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PartyWithHearable<T extends Sociable & Comparable<Sociable>, U extends
    Hearable>` line means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generic type constraint specifies that `T` must implement either the `Sociable`
    or `Comparable<Sociable>` interfaces, and `U` must implement the `Hearable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is a subclass of the `Sociable`, `Comparable<Sociable>`, and `Hearable`
    classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generic type constraint specifies that `T` must implement both the `Sociable`
    and `Comparable<Sociable>` interfaces, and `U` must implement the `Hearable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines is equivalent to `PartyWithHearable<SocialLion,
    Smartphone>lionsParty = new PartyWithHearable<SocialLion, Smartphone>(nala, android);`
    in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable<>(nala,
    android);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PartyWithHearable<SocialLion, Smartphone> lionsParty = new PartyWithHearable(nala,
    android);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`let lionsParty = new PartyWithHearable(nala, android);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we use a bounded type parameter with the `extends` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any class that implements the interface indicated as an upper bound can be used
    for the type parameter. In case the indicated name is a name of a class, its subclasses
    cannot be used for the type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any class that implements the interface indicated as an upper bound or any subclass
    of the class indicated as an upper bound can be used for the type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any subclass of the class indicated as an upper bound can be used for the type
    parameter. In case the indicated name is a name of an interface, the classes that
    implement the interface cannot be used for the type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When type parameters have constraints in Java, they are also known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flexible type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbounded type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bounded type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets declares a class whose generic type constraint
    specifies that `T` must implement the `Sociable` interface and `U` must implement
    the `Convertible` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T: where T is Sociable, U: where U is Convertible>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable> where U: Convertible`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class Game<T extends Sociable, U extends Convertible>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to maximize code reuse by writing code capable
    of working with two type parameters. We worked with more complex scenarios that
    involve interfaces, generics, and multiple type parameters that have constraints,
    also known as bounded type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We created a new interface and then we declared two classes that implemented
    this new interface. Then, we declared a class that worked with two constrained
    generic type parameters. We combined class inheritance and interfaces to maximize
    the reusability of code. We could make classes work with many different types
    and we were able to code the behavior of a party with different music generators
    that could then be reused to create parties of lions with a smartphone and parties
    of parrots with bands of animals.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 allows us to work with more complex scenarios in which we can specify
    more restrictions or bounds to the generic type parameters. However, most of the
    time, we will work with the cases covered by the samples we learned in this chapter
    and in the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned advanced usages of parametric polymorphism and generics,
    we are ready to combine object-oriented programming and functional programming
    in Java 9, which is the topic we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
