- en: Authentication Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证攻击
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: WEP attacks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WEP攻击
- en: WPA attacks and WPA2 attacks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPA攻击和WPA2攻击
- en: Attacking WPS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击WPS
- en: Attacks against authentication
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对身份验证的攻击
- en: 'In this chapter we are going to explore another form of attack: attacks against
    authentication mechanisms and the components surrounding the system. Attacking
    an authentication mechanism on a wireless network can give attackers the ability
    to access parts of the system and the resources hosted on it with very little
    or no resistance whatsoever. In fact, the very reason for having an authentication
    mechanism is to be able to validate the identity of a user or host, and if this
    is subverted or circumvented in some way, then we end up with a situation where
    all sorts of access and actions can be carried out. However, before we get into
    this chapter, let''s take a look at what authentication is, what it is designed
    to accomplish, and how it can work in a very abstract form, and then we can use
    this knowledge to understand the attacks in this chapter that much better.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨另一种形式的攻击：针对身份验证机制及其周围系统的组件的攻击。对无线网络上的身份验证机制进行攻击可以使攻击者能够非常轻松地或几乎毫无阻力地访问系统的部分和其中托管的资源。实际上，设置身份验证机制的原因是为了能够验证用户或主机的身份，如果这种验证被颠覆或绕过，那么我们最终会面临各种访问和操作。然而，在进入本章之前，让我们先看看身份验证是什么，它的设计目的是什么，以及它如何以非常抽象的形式工作，然后我们可以利用这些知识更好地理解本章中的攻击。
- en: 'So first let''s get things started by talking about what happens when you as
    a user attempt to log into a system, really any system for all purposes here.
    When a user logs into a system they are going to be subject to a number of events.
    The first thing they will do is to present an identity, which is a statement as
    to who they are claiming to be to the system they are trying to access. Now, identity
    is something that on its own is not to be used to allow access to a system, because
    all it is just a claim or assertion to someone; it''s not definitive in any way.
    This means that I can claim I am a movie star, a politician, or even the president
    of the United States, but without providing something to validate that identity,
    it''s just a claim without any merit or weight assigned to it, and therefore not
    enough to go to the later steps which grant access to trusted information resources.
    To do this, we need to move to the authentication step. The following diagram
    shows the authentication process:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们开始谈论当用户尝试登录系统时会发生什么，实际上任何系统都是如此。当用户登录系统时，他们将经历一系列事件。他们首先要做的是提供一个身份，这是关于他们声称自己是谁的陈述。现在，身份本身并不能用来允许访问系统，因为它只是对某人的声明或断言；它并没有任何明确的意义。这意味着我可以声称自己是电影明星、政客，甚至是美国总统，但如果没有提供一些东西来验证身份，那么这只是一个没有任何价值或权重的声明，因此不足以进入后续授予对受信任信息资源访问的步骤。为了做到这一点，我们需要转向身份验证步骤。以下图表显示了身份验证过程：
- en: '![](img/9130aed4-b931-416a-a7fe-26172fb6a1a3.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9130aed4-b931-416a-a7fe-26172fb6a1a3.png)'
- en: The authentication process
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证过程
- en: 'When we say authentication, we are performing some sort of action which proves
    that the claim a user is making about who they are is actually valid. The most
    common way to do this is through the use of a password; many of us have run the
    situations where we provide a username, which would be our identity, and then
    we provide a password, which is a secret piece of information that only we know,
    that can be used to say we are who we say we are and you can trust us. So, as
    we can see, an identity in the form of a username is not enough on its own to
    prove anything; it has to be authenticated to validate that this party can be
    trusted by them providing an answer that only the person with that identity would
    know. And the system that they are authenticating to would have some way of comparing
    their provided answer—or password in this case—to something that they already
    have stored locally in order to ensure that the provided answer is correct and
    the right one. The following screenshot is an example of a Windows login box:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说身份验证时，我们正在执行一些行动，证明用户关于自己是谁的声明实际上是有效的。最常见的方法是通过使用密码；我们中的许多人都遇到过这样的情况，我们提供用户名（即我们的身份），然后提供密码，这是只有我们知道的秘密信息，可以用来证明我们是我们所说的那个人，你可以信任我们。因此，可以看到，仅仅以用户名的形式的身份本身是不足以证明任何事情的；它必须经过身份验证，以验证该方可以通过提供只有具有该身份的人才会知道的答案来证明可以信任。他们正在进行身份验证的系统将有某种方式来比较他们提供的答案（或在这种情况下是密码）与他们已经本地存储的东西，以确保提供的答案是正确的。以下屏幕截图是Windows登录框的一个示例：
- en: '![](img/e079316a-33da-43ef-ae7b-5d4f03847fe7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e079316a-33da-43ef-ae7b-5d4f03847fe7.png)'
- en: A login box
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 登录框
- en: 'In practice, there are three recognized ways of authenticating which should
    be thought of as general categories of authenticating to a resource. Just to complete
    your knowledge of these different ways, let''s take a brief look at each of them:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有三种公认的身份验证方式，应该被视为对资源进行身份验证的一般类别。为了完善你对这些不同方式的了解，让我们简要地看一下每种方式：
- en: Factor 1 authentication covers any situation where a piece of information such
    as a pass code or passphrase or PIN number has to be provided in order to authenticate
    an identity. The important detail or element of this first factor of authentication
    is that it is something that you know and store in your brain and provide when
    requested. This is by far the most common form of authentication that is used
    in computer networks and software as well as our wireless networks, as we will
    see.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因素1身份验证涵盖了任何需要提供信息（如密码、口令或PIN码）以验证身份的情况。身份验证的第一个因素的重要细节或要素是，这是你知道并存储在大脑中的东西，并在请求时提供。这是计算机网络和软件以及我们的无线网络中最常用的身份验证形式，正如我们将看到的那样。
- en: Factor 2 authentication covers any sort of situation where a physical item has
    to be provided to authenticate an individual or system. Items such as a key for
    a door, an ATM card, or even a token can be used to present to the system or generate
    a special code that can be used to validate the identity of the user much like
    before. This form of authentication is also sometimes referred to as something
    you have—as in something you possess—which we can see in the case of a car door
    key. This type of authentication is not common to see in the case of wireless
    networks, but there are some exceptions, such as situations where a special code
    may be generated to log in to a corporate network or a guest network as the case
    may require.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双因素认证涵盖了任何需要提供物理物品来验证个人或系统的情况。例如，门的钥匙、ATM卡或者令牌都可以用来呈现给系统或生成一个特殊代码，用于验证用户的身份，就像之前一样。这种形式的认证有时也被称为你所拥有的东西，就像你拥有汽车门钥匙一样。这种类型的认证在无线网络中并不常见，但也有一些例外情况，比如在需要生成特殊代码登录企业网络或访客网络的情况下。
- en: 'The following photograph shows an example of factor 2 authentication technology:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了双因素认证技术的一个例子：
- en: '![](img/20b742ad-e0a9-495e-ac83-0d9cf622fe39.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20b742ad-e0a9-495e-ac83-0d9cf622fe39.png)'
- en: A factor 2 authentication token from RSA labs
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RSA实验室的双因素认证令牌
- en: 'Factor 3 authentication is a form of vindication which relies on what is commonly
    known as biometrics. Simply put, biometrics are a method by which we measure a
    characteristic or trait of a physical organism and use that as a way of validating
    an identity, much like you did with the first two factors. Characteristics such
    as fingerprints, eyeballs, palm prints or even facial recognition have all been
    used to provide this authentication factor. While this form of authentication
    can be very accurate and highly reliable, it does have a drawback over the other
    factors that tend to make it less common as it is more tricky to implement, considering
    the expense and complexity involved in setting up such systems. It is also worth
    noting that it is extremely rare to see this type of authentication factor with
    wireless networks as a form of authentication. This doesn''t mean you can''t use
    these authentication mechanisms with a wireless network; it just means that they''re
    not used to authenticate to the wireless network in most cases. This type of authentication
    is just included here for your reference. It is not something that we are going
    to be looking at subverting or circumventing in this book. The following image
    shows an example of factor 3 authentication technology:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三因素认证是一种依赖于所谓的生物识别的认证形式。简单来说，生物识别是一种通过测量生物体的特征或特质并将其用作验证身份的方法，就像你在前两个因素中所做的那样。诸如指纹、眼球、手掌纹甚至面部识别等特征都被用来提供这种认证因素。虽然这种认证形式可能非常准确和可靠，但它与其他因素相比有一个缺点，这使得它不太常见，因为在设置这种系统时涉及的费用和复杂性更大。值得注意的是，在无线网络中很少见到这种类型的认证因素。这并不意味着你不能使用这些认证机制来连接无线网络；这只是意味着它们在大多数情况下不用于连接无线网络的认证。这种认证类型只是包含在这里供你参考。这不是我们在本书中要试图颠覆或规避的内容。以下图片显示了第三因素认证技术的一个例子：
- en: '![](img/7124d2b1-8c18-4817-86d7-031402cc3731.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7124d2b1-8c18-4817-86d7-031402cc3731.jpg)'
- en: A factor 3 fingerprint reader
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三因素指纹识别器
- en: Now that we have covered authentication, the next thing to cover is what happens
    after the system has validated who you are claiming to be. Remember, all that
    the authentication has done is validate that the identity you have provided to
    the system is not just a claim, it is actually true and correct and can be trusted
    as to its accuracy. This in no way means that you have been granted access to
    a system. Think of it as providing a driver's license or some other piece of information
    to an official. Just because that documentation checks out and says you are who
    you are claiming to be it does not mean that you will be allowed to, for example,
    enter restricted areas or carry out some other actions, because all it does is
    prove that you are who you are claiming to be, and that's it. For you to be able
    to move to the next step you have to undergo a process known as authorization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了认证，接下来要讨论的是系统在验证了你所声称的身份后会发生什么。请记住，认证所做的只是验证你向系统提供的身份不仅仅是一个声明，它实际上是真实和正确的，并且可以被信任为准确。这绝不意味着你已经被授予了对系统的访问权限。可以把它想象成向官员提供驾驶执照或其他一些信息。仅仅因为那些文件核实并且说你是你所声称的人，并不意味着你将被允许，例如，进入受限区域或执行其他一些操作，因为它只是证明你是你所声称的人，仅此而已。要想进入下一步，你必须经历一个称为授权的过程。
- en: So, what is authorization? Well authorization is actually quite simple. Authorization
    takes your validated identity and compares it against a set of rules that are
    configured on the system. These rules are used to determine what your specific
    level of access and interaction with the system will be and are configured and
    put in place by whoever the system owner administrator happens to be, in accordance
    with their guidance and the standards that they wish to have in place.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是授权？授权实际上非常简单。授权将你的验证身份与系统上配置的一组规则进行比较。这些规则用于确定你与系统的具体访问和交互级别，并由系统所有者管理员根据他们的指导和希望制定的标准进行配置和实施。
- en: Once authorization is complete then the user will have access to the system
    in whatever capacity or level the system owner wishes them to have. So, they can
    continue to have whatever interactions they have been granted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦授权完成，用户将以系统所有者希望他们拥有的任何能力或级别访问系统。因此，他们可以继续进行被授予的任何交互。
- en: Something to remember with authentication is that authentication is not unique
    to wireless. It's something that plays a role in controlling access to different
    applications, devices, networks and other items. Without authentication, system
    and device security becomes a much bigger challenge, and therefore it has to be
    present across a diverse range of items. In this chapter we talk about authentication
    in the context of wireless devices and technology, but don't forget that it is
    present not just in wireless but also on the network's applications that you access
    through the wireless as well as those ones that you access through traditional
    wired means.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证中需要记住的一点是，认证并不局限于无线。它在控制对不同应用程序、设备、网络和其他项目的访问中起着作用。没有认证，系统和设备的安全性将会变得更加具有挑战性，因此它必须存在于各种各样的项目中。在本章中，我们讨论了无线设备和技术的认证，但不要忘记，它不仅存在于无线中，还存在于通过无线访问的网络应用程序以及通过传统有线方式访问的应用程序中。
- en: 'In a wireless network, there are many attacks that can target authentication,
    and we can only cover a few of them here in this book. But the ones we will cover
    are some of the more common ones that you will run into, and which can affect
    wireless networks and performance. Authentication on wireless networks includes
    a diverse number of technologies and mechanisms, many of which we have covered
    in previous chapters, but just to be complete, let''s talk about a few of the
    different items here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在无线网络中，有许多可以针对认证的攻击，我们只能在这本书中覆盖其中的一部分。但我们将覆盖的这些攻击是一些比较常见的，你可能会遇到的，它们可能会影响无线网络和性能。无线网络上的认证包括多种技术和机制，其中许多我们在之前的章节中已经涵盖了，但为了完整起见，让我们在这里谈谈其中的一些不同项目：
- en: '**Encryption**: the use of encryption is vital in just about all authentication
    mechanisms that are available, as it provides a way to ensure both the confidentiality
    of credentials as well as the integrity of those credentials and the systems that
    store them. Without encryption it would be very tough to protect credentials when
    they are being stored as well as when they are being transmitted. It would also
    be very tough to ensure that these credentials are accurate when they are transmitted
    across a network, or if they''ve been altered from their original form. It''s
    safe to say that without cryptography, we would not have authentication available
    in many of the forms that we do now.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：加密的使用在几乎所有可用的认证机制中都是至关重要的，因为它提供了一种方式来确保凭据的机密性以及存储这些凭据的系统的完整性。没有加密，保护凭据在存储和传输时将会非常困难。同样，要确保这些凭据在网络上传输时是准确的，或者它们是否已经被改变，也将会非常困难。可以说，没有密码学，我们现在许多形式的认证将不会存在。'
- en: '**Pre-Shared Key** (**PSK**) **systems**: This involves the use of systems
    where a common key is entered on each workstation of a device that allows it to
    authenticate to the wireless access point. This type of protection usually comes
    in the form of non-enterprise WEP, WPA or WPA2\. It is worth noting that pre-shared
    key systems are extremely common in home and small business environments, but
    when you start scaling up environments to medium, large, and enterprise size environments
    then pre-shared key systems tend to be avoided in favor of enterprise authentication
    systems.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预共享密钥**（**PSK**）**系统**：这涉及使用在每台工作站或设备上输入一个共同密钥，以允许其对无线接入点进行认证的系统。这种保护通常以非企业WEP、WPA或WPA2的形式出现。值得注意的是，预共享密钥系统在家庭和小型企业环境中非常常见，但当你开始将环境扩展到中型、大型和企业规模的环境时，预共享密钥系统往往会被避免，而更倾向于使用企业认证系统。'
- en: '**Enterprise authentication**: In large environments it is not uncommon to
    see heavy-duty authentication systems in the form of enterprise authentication
    mechanisms. These mechanisms allow for the scaling up of authentication as well
    as the centralized control and management of authentication. This means that these
    authentication systems can not only provide a robust way of authenticating wireless
    clients in this case but they can also be used to set a uniform set of rules or
    even fine-tune these rules for authorization on a site by site basis.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业认证**：在大型环境中，使用重型认证系统形式的企业认证机制并不罕见。这些机制允许认证的扩展以及认证的集中控制和管理。这意味着这些认证系统不仅可以为在这种情况下认证无线客户端提供强大的认证方式，还可以用于为授权设置统一的规则，甚至可以针对每个站点对这些规则进行微调。'
- en: While this is a list of just three things that are part of authentication in
    the enterprises, there are many more that exist that can possibly be deployed.
    We, however, will refrain from getting too far into some of the more exotic and
    complex forms that are out there, and just stick with the basic ones which you
    are most likely to encounter in your explorations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是企业认证中的三个部分的列表，但还有许多其他可能被部署的部分。然而，我们将避免深入研究一些更为奇特和复杂的形式，只专注于你在探索中最有可能遇到的基本形式。
- en: Types of attack
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击类型
- en: The attacks that target authentication on wireless networks are varied, with
    each having its own advantages and disadvantages that make them useful or not
    useful in any given situation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 针对无线网络上的认证的攻击是多种多样的，每种攻击都有其自身的优势和劣势，使它们在特定情况下有用或无用。
- en: Before we start exploring each one of our attacks, let's first lay out the attacks
    that will be covered in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索每一种攻击之前，让我们先列出本章将涵盖的攻击。
- en: WEP attacks
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WEP攻击
- en: WPA attacks
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPA攻击
- en: WPA2 attacks
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPA2攻击
- en: WPS attacks
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPS攻击
- en: Remember these are just a few of the types of attack that can be used to subvert
    the authentication of a wireless network; they should never be considered the
    only types of attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些只是可以用来颠覆无线网络认证的攻击类型中的一部分；它们不应被视为唯一的攻击类型。
- en: WEP attacks
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WEP攻击
- en: The first attack we are going take a look at or re-examine in this particular
    chapter is the attack against the wired equivalent privacy, or WEP, protocol.
    We've encountered this protocol a few times in our journey through this book,
    and we're to take another look at it here, with some additional items added that
    weren't there before, and endeavor to expand on this attack so as to discuss the
    real weaknesses in this protocol that make it so vulnerable to attacks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the WEP protocol is something that was implemented and designed
    when wireless security was something that was understood to be an issue, but the
    people at designed wireless technologies did not really understand how to properly
    implement security, nor did they consult with outside parties that could have
    helped them do it better. In all practical senses, WEP should no longer be used
    in any active network as it presents too much of a target of opportunity for someone
    wishing to cause you harm by stealing your data or modifying data on your network
    during transmission. A few years ago the attacks that were successful against
    this protocol were a lot tougher to carry out successfully than they are now simply
    because the tools required a higher degree of knowledge and experience to operate.
    Nowadays the tools designed to target this protocol are much more refined and
    easy to use, and they are accessible by a much wider audience; they just need
    to be aware of the tools and be willing to follow a few cookbook style directions
    to make them work in a way that achieves a successful result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Let's fill a little more back story on the WEP protocol, just to fully flesh
    out the angle we're approaching things from. This protocol was designed way back
    in 1997 as part of the original wireless standards. It was designed to use a reasonably
    strong encryption protocol known as RC4, designed to protect traffic against accidental
    disclosure, and it used CRC 32 for integrity protection. Neither of these protective
    measures were a bad decision. However, they were used improperly in the design
    and implementation of WEP.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: To understand one of the problems with WEP, we need to understand how keys are
    generated in this protocol. In practice the standard 64-bit WEP protocol makes
    use of a 40-bit key plus a 24-bit initialization vector or IV which together forms
    what is known as the RC4 key. This key is what was used to encrypt and protect
    traffic during transmission.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will quickly look at the fact that we are using a 40-bit key
    plus a 24-bit initialization vector as a problem - specifically, the 40-bit key
    is a big problem to concern ourselves with. At the time this 40-bit number was
    decided upon, technology was already available that made cracking the short version
    of the key more than possible in a reasonable amount of time. Nowadays, cracking
    a key of this sort is extremely easy and takes little to no time at all. So inevitably
    the question comes up as to why the developers of this protocol decide to use
    such a short key when longer encryption keys are stronger and better in most cases.
    The biggest reason is that at the time that WEP was designed, the United States
    government had strict export controls on cryptographic technologies and any technology
    or device that implemented or made use of such cryptographic tools. It was due
    to these restrictions that the key size was limited to such a degree. Later on
    after such restrictions were lifted the key links were increased to 104-bits with
    a 24-bit initialization vector. There are some longer links available, but even
    with this 128-bit key size the protocol still has vulnerabilities and thus should
    not be used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In most access points that used WEP, the key was entered as a hexadecimal value
    or was translated into a hexadecimal value, meaning that it used a key that incorporated
    values from `0` to `9` and `A` through `F`. Consumers or systems administrators
    using WEP on their access point would be entering their key directly on the access
    point and then enter the same key on all the clients they wish to connect and
    everything would work accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Something that can be utilized within the WEP encryption system that is of concern
    to us here are the different types of authentication that identify a client, not
    a user, to a network. Two authentication methods are **Open Systems Authentication**
    (**OSA**) and **Shared Key Authentication** (**SKA**). Both of these have seen
    use to varying degrees, with most people opting for the latter over the former,
    although the former is seen in a number of cases.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: In the case of OSA we have a situation where a client is able to attach to the
    wireless access point without having to provide any credentials or anything to
    identify itself. In effect, any client is able to authenticate directly to the
    access point and associate. What this really means is that if you split hairs
    there is no authentication occurring at all, even though it says so in the name
    of the system. However, a client can subsequently encrypt their traffic after
    the fact by having access to a WEP key to do so. This means that the key will
    have to be provided to a client to make this happen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In our second authentication mechanism, which is shared key, a client will
    have to provide a WEP key to authenticate to the network in order to properly
    associate and communicate on that network. In practice it breaks down to a four
    step process which we should talk about to understand the process that we are
    working with in order to recover our keys:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The client will send a request to authenticate to a wireless network, or specifically
    an access point.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The access point will respond to this request to associate with a clear text
    message or challenge.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client will then take this clear text message and will encrypt it using
    the preconfigured WEP key and then take the results and transmit back to the access
    point as another authentication request.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point the access point will take its copy of the WEP key, use it to
    decrypt the encrypted key it has received, and then compare the results it gets
    to its original clear text response; if the results match, then association will
    occur. If not, it will be rejected. The following diagram shows the process of
    the WEP process:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5a16ebc-2aae-4a0d-ac07-a9244684b452.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: The WEP authentication process
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Once the decryption process is completed, the WEP key does not get pushed to
    the background, waiting for another authentication to happen; rather, it is used
    to now encrypt the traffic that is transmitted between the client and any other
    point on the network or access point.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: It really is important to point out that despite the obvious notion that shared
    key authentication is more secure because there is authentication going on before
    a client is allowed to associate to the network, this is actually not true. In
    fact it's the opposite situation due to the fact that in a shared key system,
    data is exchanged prior to it being encrypted and if the key is short, it is possible
    to extract the key from this sequence of authenticating a client to a network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The way this protocol was constructed in the key links that were made available
    leads to some definite problems that make our chance of attack and its success
    quite high. You should examine why this is possible so we can understand why the
    attack that we're using works as well as it does. First let's understand that
    the RC4 is a symmetric and stream cipher that quickly loses its effectiveness
    if the same key is used twice during the same transmission of data. If the key
    is used twice it opens up a door that allows us to compare traffic and look for
    patterns that may reveal the key. The way the designers decided to defeat this
    type of situation was to use a 24-bit initialization vector which when combined
    with the 40-bit key was intended to prevent keys being reused during the same
    transmission. However the short 24-bit length of the initialization vector means
    that on a sufficiently busy network the chances of the same key being reused over
    and over increases dramatically. In fact just to throw out some numbers, the chance
    of the same key being reused increases to about 50 percent after around 5000 packets
    have been transmitted. Therefore it's not hard to imagine that on a sufficiently
    busy network you could gather this amount of packets pretty quickly. In fact,
    our attack relies on the fact that we are able to capture several thousand or
    hundred thousand plus packets and use them to successfully recover the key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议的构造方式以及提供的密钥链接导致了一些明显的问题，使我们的攻击机会和成功率相当高。您应该研究为什么这是可能的，这样我们就能理解我们使用的攻击为什么如此有效。首先，让我们了解RC4是一种对称和流密码，如果在相同的数据传输过程中使用相同的密钥两次，它会迅速失去效力。如果密钥被重复使用，就会打开一个门，允许我们比较流量并寻找可能揭示密钥的模式。设计者决定打败这种情况的方式是使用一个24位的初始化向量，当与40位密钥结合使用时，旨在防止在相同的传输过程中重复使用密钥。然而，初始化向量的短24位长度意味着在足够繁忙的网络上，相同的密钥被重复使用的机会会大大增加。事实上，仅仅举个例子，大约传输5000个数据包后，相同密钥被重复使用的机会就会增加到约50%。因此，可以想象在足够繁忙的网络上，您可以很快地收集到这么多数据包。事实上，我们的攻击依赖于我们能够捕获数千甚至数十万个数据包，并使用它们成功地恢复密钥。
- en: Just to give you some numbers on how easy it is to successfully and quickly
    break this protocol, think of some of the cases that are on record. In 2005 it
    was shown that a WEP key could be recovered from a wireless network using the
    protocol in around just three minutes, or even less depending on the environment.
    Later attacks that showed up over the following years have further reduced this
    time and some have even claimed that they are able to recover the key from traffic
    using as few as 40,000 packets with a better than 50 percent probability of success
    each and every time. This should really bring into focus why this is just not
    a good protocol to be using, and those who are still using it should be strongly
    encouraged and move away from the technology before they end up in a bad situation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解成功并快速破解该协议有多容易，可以考虑一些已有记录的案例。2005年，有人展示了可以在大约三分钟内从无线网络中恢复使用该协议的WEP密钥，甚至在环境允许的情况下可能更短。随后几年出现的攻击进一步缩短了这个时间，有些人甚至声称他们能够使用不到40,000个数据包就成功地恢复密钥，每次成功的概率超过50%。这应该让人明白为什么这不是一个好的协议，仍在使用它的人应该受到鼓励并远离这项技术，以免陷入困境。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要准备以下物品：
- en: A wireless card capable of entering monitor mode
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够进入监视模式的无线网卡
- en: Kali Linux
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A second wired or wireless adapter to connect to the internet
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个有线或无线适配器连接到互联网
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In order to crack the WEP key for an access point running the protocol, there
    is a process involved that requires the collection of what are known as **Initialization
    Vectors** (**IVs**). The problem with this process is that under normal conditions
    a network does not generate a lot of these items in a short period of time. Under
    normal conditions this means we would have to wait a prolonged period of time
    to get enough IVs to retrieve the network key. However, we can speed up this process
    by utilizing the information from our previous recipe, together with some new
    skills, to retrieve the key. To put it simply, we will inject packets into the
    network in an effort to get the access point to generate a large number of packets
    in a substantially shorter period of time, which means that the ability to capture
    more packets with weak IVs is increased.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了破解运行该协议的接入点的WEP密钥，需要一个过程，其中需要收集所谓的**初始化向量**（**IVs**）。这个过程的问题在于，在正常情况下，网络在短时间内不会生成大量的这些项目。在正常情况下，这意味着我们需要等待很长时间才能获得足够的IVs来检索网络密钥。然而，我们可以通过利用前面教程中的信息以及一些新技能来加快这个过程，以检索密钥。简而言之，我们将试图向网络注入数据包，以促使接入点在较短的时间内生成大量数据包，从而增加捕获具有弱IVs的数据包的能力。
- en: With this process being completed, we can then use the captured traffic to retrieve
    the key.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个过程后，我们可以使用捕获的流量来检索密钥。
- en: 'In short, the steps we will be looking at here in this recipe will be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在这个教程中，我们将要学习的步骤是：
- en: Start the wireless interface in monitor mode on the specific AP channel.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特定的AP频道上启动无线接口的监视模式。
- en: Test the injection capability of the wireless device to the AP.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试无线设备对接入点的注入能力。
- en: Use `aireplay-ng` to do a fake authentication with the access point.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`aireplay-ng`与接入点进行虚假认证。
- en: Start `airodump-ng` on AP channel with a `bssid` filter to collect the new unique
    IVs.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AP频道上使用`bssid`过滤器启动`airodump-ng`以收集新的唯一IVs。
- en: Start `aireplay-ng` in ARP request replay mode to inject packets.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`aireplay-ng`以ARP请求重放模式注入数据包。
- en: Run `aircrack-ng` to crack the key using the IVs collected.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`aircrack-ng`使用收集的IVs来破解密钥。
- en: 'The first step we need to perform for breaking WEP is to switch our card into
    monitor much like we did previously. In most cases the card that is installed
    in your system, if your system came with a built-in wireless network adapter,
    will be very easily capable of switching into monitor mode. If it is not, then
    you can always go with a third-party adapter, such as a USB adapter or an adapter
    card that is installed into your system directly to support this capability. We
    need this mode in order to allow the network interface to detect every packet
    that is being transmitted by nearby networks without being associated to those
    same networks. To do this on a network interface named `wlan0`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打破WEP的第一步是像之前一样将我们的卡切换到监视模式。在大多数情况下，安装在你的系统中的卡，如果你的系统配备了内置无线网络适配器，将很容易地能够切换到监视模式。如果不行，那么你可以随时选择第三方适配器，比如USB适配器或直接安装到系统中以支持这种功能的适配器卡。我们需要这种模式来允许网络接口检测附近网络发送的每个数据包，而不与这些网络关联。要在名为`wlan0`的网络接口上执行此操作：
- en: '`airodump-ng start wlan0 9` (the `9` will lock the card to listening on channel
    `9`, but this can be changed to the channel on the access point you wish to observe.
    You can discover the channel of the access point you wish to target by running
    the command without the channel designator).'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`airodump-ng start wlan0 9`（`9`将锁定卡监听频道`9`，但这可以更改为你想要观察的接入点的频道。你可以通过在没有频道指示符的情况下运行命令来发现你想要定位的接入点的频道）。'
- en: Press `Enter`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`Enter`键。
- en: An important detail to remember is that most wireless networks tend to run on
    one of three channels which are `1`, `6` or `11`. The reason for this is that
    these are the only three channels in this range that do not fully overlap, and
    therefore if you use one of them the risk of interference is reduced. You can
    use other channels than the ones specified here but you can expect to get some
    degree of interference which may be higher than you would like. In this recipe
    I have stuck with using channel `9` only as an example. When you scan for targets
    in your area, check the channel of the target that you wish to work with and use
    that channel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的一个重要细节是，大多数无线网络往往在`1`、`6`或`11`中的一个频道上运行。原因是这是在这个范围内唯一不完全重叠的三个频道，因此如果你使用其中一个，干扰的风险会降低。你可以使用这里没有指定的其他频道，但可能会遇到一定程度的干扰，可能会比你想要的更高。在这个示例中，我只使用了频道`9`。当你扫描你所在区域的目标时，检查你想要使用的目标的频道，并使用该频道。
- en: Once the card has responded that it is in monitor mode, we can now move on to
    the next step, which is to prepare ourselves to perform a packet injection on
    the target network. So, verify that any prompts you have received on screen are
    verifying that you have indeed switched into monitor mode on the specified channel,
    and you can proceed. If you have not gotten a response indicating that you have
    switched into monitor mode, then retry the command to see if perhaps you entered
    something wrong or you're getting some other problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦卡响应说它处于监视模式，我们现在可以继续下一步，即准备好对目标网络执行数据包注入。所以，验证你在屏幕上收到的任何提示是否验证了你确实已经切换到了指定频道的监视模式，然后你可以继续。如果你没有得到一个表明你已经切换到监视模式的响应，那么请重试命令，看看也许你输入了错误的东西或者你遇到了其他问题。
- en: 'Our next step is to ensure that we are in a situation where we can properly
    perform our packet injection against our target network. So we want to verify
    that we are at close enough proximity or getting a strong enough signal to be
    able to perform this packet injection and get the results that we''re looking
    for. Fortunately we have a tool that is designed to help us with this situation
    and ensure that we are where we need to be:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是确保我们处于一个可以正确执行我们对目标网络的数据包注入的情况。所以我们要验证我们是否足够接近或者信号足够强，能够执行这个数据包注入并得到我们想要的结果。幸运的是，我们有一个旨在帮助我们应对这种情况并确保我们在需要的位置的工具：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-e ganon` is the wireless network's name and `-a 00:28:6C:E4:40:80` is
    the access point's MAC address.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e ganon`是无线网络的名称，`-a 00:28:6C:E4:40:80`是接入点的MAC地址。'
- en: The system should respond with a prompt that it is waiting for a beacon frame,
    and in short order it should also respond that the injection process is working
    and it has found the access point that you have defined. If you do not get this
    response along with information indicating channel, speed, and maybe even power,
    then you may try to move closer to your target or change position, or maybe even
    consider using an antenna or a different adapter to get a better signal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该会响应一个等待信标帧的提示，很快它也应该会响应说注入过程正在进行，并且它已经找到了你定义的接入点。如果你没有得到这个响应以及指示频道、速度甚至功率的信息，那么你可以尝试靠近你的目标或改变位置，甚至考虑使用天线或不同的适配器来获得更好的信号。
- en: Ideally the response that you should get back at this point should indicate
    that you are getting close to 100 percent of a signal from the access point or
    target network. If you get anything indicating that you're getting less than 100
    percent it's not necessarily a bad thing, but as you drop below 90 and then 80
    and then 70 percent you get a less reliable signal, and this could impact the
    chances of this attack actually working successfully. Don't always expect to get
    a 100 percent signal or response, but you want to get something that is as close
    as possible. Lesser values may work successfully and you shouldn't necessarily
    let a lower value stop your attempt at an attack ,but be aware you could end up
    with less than stellar results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，此时你应该得到的响应应该表明你接收到了接入点或目标网络近乎100%的信号。如果你得到任何表明你接收到的信号少于100%的东西，这不一定是坏事，但当你下降到90%，然后80%，然后70%以下时，你会得到一个不太可靠的信号，这可能会影响这次攻击成功的机会。不要总是期望得到100%的信号或响应，但你希望得到尽可能接近的东西。较小的值可能会成功，你不一定要让一个较低的值阻止你尝试攻击，但要意识到你可能会得到不太理想的结果。
- en: With the above steps out of the way now, we can move on to the step of actually
    capturing initialization vectors or IVs. If you recall from the introduction to
    this attack, this was the crucial item that ensures that the same key is not reused
    over and over again on traffic. We also learned that the short length of the initialization
    vector led to traffic on high-volume networks, potentially reusing the same key
    after only 5000 packets had been transmitted. So what we need to do is prep ourselves
    to capture this traffic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过上述步骤，我们可以继续进行实际捕获初始化向量或IVs的步骤。如果您还记得这次攻击的介绍，这是确保相同密钥不会一次又一次地在流量中重复使用的关键项目。我们还了解到，初始化向量的短长度导致在高容量网络上的流量可能在仅传输了5000个数据包后就重复使用相同的密钥。因此，我们需要准备好捕获这些流量。
- en: 'To do this you will be opening a second console session. So, leave your previous
    session up and open up a second one in the Kali interface to run the following
    command (do not close the first console):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您将打开第二个控制台会话。因此，在Kali界面中打开第二个控制台会话来运行以下命令（不要关闭第一个控制台）：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`--bssid 00:14:6C:7E:40:80` is the access point''s MAC address. This eliminates
    extraneous traffic. `-w` capture is the file name prefix for the file which will
    contain the IVs.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “-bssid 00:14:6C:7E:40:80”是接入点的MAC地址。这可以消除多余的流量。“-w”捕获是包含IVs的文件的文件名前缀。
- en: Once this command is executed you will start seeing that the traffic is being
    captured—albeit very slowly in comparison to what we are going to be doing in
    the next few steps to generate more traffic. Remember that WEP has a better than
    50 percent chance of reusing a key after 5,000 packets have been generated. So
    what we want to do is induce a situation where a large volume of packets is generated
    in a very short period of time. If you just waited and watched what was being
    generated on screen, as you are at this stage, you'll see that the number of packets
    or information being gathered moves up at a gradual and unsteady pace.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了这个命令，您将开始看到流量被捕获——尽管与我们接下来要做的生成更多流量的步骤相比，速度非常慢。请记住，WEP在生成5,000个数据包后有超过50%的机会重用密钥。因此，我们想要制造一种情况，即在很短的时间内生成大量数据包。如果您只是等待并观察屏幕上生成的内容，就像您现在所处的阶段一样，您会看到数据包或信息的数量以渐进且不稳定的速度增加。
- en: Conceivably, you could just collect traffic this way at the normal pace of the
    network, but keep in mind that if we have to generate or collect several thousand
    packets to be able to successfully increase our chances of success, you could
    be waiting a while. The less active a network is, the less chance you have of
    just passively sitting by and in a short period of time collected enough trafficking
    to be able to recover a key. In fact, it is possible you could find yourself waiting
    and listening for two or three days just for enough traffic to successfully recover
    the key. That can be a little challenging and also dramatically increases your
    chances of being detected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以以网络的正常速度收集流量，但请记住，如果我们必须生成或收集数千个数据包才能成功增加我们的成功机会，您可能需要等待一段时间。网络越不活跃，您
    passively sitting by and in a short period of time collected enough trafficking
    to be able to recover the key. In fact, it is possible you could find yourself
    waiting and listening for two or three days just for enough traffic to successfully
    recover the key. That can be a little challenging and also dramatically increases
    your chances of being detected.
- en: Now we are going to perform an authentication with the access point. We need
    to do this because we are going to be injecting packets on to the wireless network
    and to be able to do that we need to create an authentication. If we have not
    authenticated and associated with the network then we run into a situation where
    our attempt at connecting will be outright rejected, and fail. What we are doing
    is performing a fake authentication and attempting to connect to the network.
    The way we do this is by grabbing the MAC address of a client that is already
    associated to that wireless network successfully.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将对接入点执行身份验证。我们需要这样做是因为我们将要向无线网络注入数据包，为了能够做到这一点，我们需要创建一个身份验证。如果我们没有经过身份验证和关联网络，那么我们会遇到一个情况，我们的连接尝试将被直接拒绝并失败。我们正在进行的是伪身份验证，并尝试连接到网络。我们这样做的方式是通过获取已成功关联到该无线网络的客户端的MAC地址。
- en: 'In order to associate a client with an access point we will use fake authentication:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将客户端与接入点关联，我们将使用伪身份验证：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or another variation for picky access points:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于挑剔的接入点的另一种变体：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If everything works successfully, you should get a message saying that you have
    associated successfully. If not you will get a message indicating that you have
    not associated successfully with a wireless network and you'll need to try again
    at that point, but generally, if you follow the steps here, you should be more
    than likely to associate with your target. If you don't successfully associate
    and authenticate to your wireless network by spoofing the MAC address of a victim,
    then you will not be able to move on to the next step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会收到一条消息，表示您已成功关联。如果没有，您将收到一条消息，指示您未能成功关联到无线网络，那么您需要在那时再次尝试，但通常情况下，如果您遵循这里的步骤，您应该更有可能关联到您的目标。如果您通过欺骗受害者的MAC地址成功关联和身份验证到无线网络，那么您将无法继续进行下一步。
- en: Now let's move on to the moment of truth, where we will be generating or inducing
    our target network to generate traffic that we can use to recover the key. The
    way this process works is by using something known as an ARP request or broadcast.
    What we're trying to do is send out an ARP request just like any normal network
    client would. However, when this broadcast goes out looking for a client, the
    access point will, by design, rebroadcast this out to the network every time we
    send one out. So it has the effect of generating a lot of traffic that is in turn
    encrypted and protected with the WEP key. And since we are going to be listening
    and capturing this traffic to a file, if things go right we will have recorded
    a bunch of traffic that used the key (if we're patient), and that we can run a
    cracking operation or recovery operation on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the injection we need to open another console and enter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It will start listening for ARP requests and when it hears one, `aireplay-ng`
    will immediately start to inject it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm that you are injecting by checking your `airodump-ng` screen.
    The data packets should be increasing rapidly. The `#/s` should be a decent number.
    However, 'decent' depends on a large variety of factors. A typical range is 300
    to 400 data packets per second. It can be as low as a 100/second and as high as
    a 500/second.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have captured the traffic to a `.cap` file we will now try to retrieve
    the key from the captured packets. To do this we do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another new console session and enter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can run this while generating packets. In a short time, the WEP key will
    be calculated and presented. You will need approximately 250,000 IVs for 64-bit
    and 1,500,000 IVs for 128-bit keys. Note that these values are rough guidelines
    and other variables can impact how much traffic and IVs you actually need to collect.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'If the process completes successfully you should see something like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9affb85-dba9-4dbe-a58e-b201479de225.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Note that the key is not displayed as you would expect it. The characters next
    to `Key Found`, between the square brackets, is the passkey in hexadecimal. If
    you remove the colons and then paste the remaining characters into your wireless
    client when prompted to be associated with the network, it will still work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: WPA and WPA2 attacks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next attack targets a technology known as WPA or Wi-Fi protected access.
    As seen in our previous recipe WEP has a lot of drawbacks and vulnerabilities
    that could be exploited quite simply to gain access to and expose the information
    on networks protected with this protocol. Due to vulnerabilities and issues with
    WEP a replacement was sought, and an immediate replacement came in the form of
    WPA. WPA was designed to be an update or upgrade to WEP that can be implemented
    strictly to firmware upgrades on wireless network cards as well as wireless access
    points that were able to support the newer standard. When this new technology
    was introduced it solved a lot of the problems that WEP had brought to the table
    and made system administrators and consumers breathe a little bit easier.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that while most wireless cards were able to have a simple
    firmware update performed to include the new features and capabilities available
    with WPA, not every wireless card could be upgraded through firmware to support
    the new technology. In some cases wireless network cards had to be outright replaced
    in order to take advantage of the newer technology as it debuted. On the other
    side of the equation, access points that were used to anchor a wireless network
    required much more extensive upgrades and work to be done than could be allowed
    on a standard firmware update in most cases. As a result most of the access points
    available before 2003 were unable to be upgraded to support WPA, which meant that
    users had to replace these access points rather than upgrade them. In most cases
    it was because the older hardware did not have the processing power available
    to support the beefier requirements that were seen in the newer standard.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'WPA is built on a standard known as IEEE 802.11i. The standard defined a number
    of things, not all of which would be implemented immediately with WPA; some would
    have to wait for the newer WPA2 standard protocol to be implemented. However from
    this standard we did see the implementation of what is known as the Temporal Key
    Integrity Protocol, or TKIP. This technology was designed to replace what WEP
    used with its 64 or 128-bit keys. With this new protocol, keys were generated
    dynamically on a per packet basis with a new 128-bit key for each packet, meaning
    that the attacks that we saw with WEP are no longer possible with WPA. The following
    image shows the WPA process:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/585a5cb5-ef65-46d3-8988-0b31b371b92f.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: The WPA process
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: WPA also updated and streamlined the integrity checking that was present in
    WEP. WPA uses what's called a message integrity check, which is designed to perform
    the same purpose as prior technologies, meaning that it is designed to stop an
    attacker from altering or re-sending data packets in what is known as a data replay
    attack. The reason for this replacement of the old CRC protocol is that the older
    protocol wasn't really sufficient to protect against all sorts of data integrity
    checks and replay attacks. Thus, it was decided that the newer message integrity
    checking—that actually had been in use in many forms for a while—should be implemented
    in WPA. It is actually worth mentioning that one of the reasons why some older
    network cards and access points cannot be updated to the newer WPA protocol is
    that the message integrity check is actually more computationally intensive than
    the old CRC check used in WEP.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note that since the newer WPA protocol with the message integrity check in place
    was implemented, it has been found that there are some flaws in the protocol relating
    to this technology. It is also important to note that the encryption technology
    used overall in WPA has been found to have flaws as well. However, it is also
    important to note that while there are flaws in WPA they are not as dramatic and
    glaring as those that are present in WEP. Nevertheless, at the end of the day,
    if one has an option to upgrade to WPA2 they should take that option, rather than
    staying with WPA or even WEP.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'In the WPA protocol there are some terminologies that relate to authentication
    of which you should be aware:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**WPA personal**: This authentication mechanism, also known as WPA – PSK, is
    primarily targeted to home and small office networks that don''t require or don''t
    have centralized authentication system. In this set-up each wireless device will
    derive unique 128-bit encryption keys from a shared 256-bit key. This key is entered
    individually into the access point as well as each individual client that will
    be connecting to this access point or wireless network. This key can be entered
    in 64 hexadecimal digits or as a passphrase of 8 to 63 characters as desired.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WPA enterprise**: This is a mode of authentication which is sometimes also
    referred to as WPA – 802.1x. This type of set up is designed for enterprise-level
    networks and relies on the fact that a centralized authentication server or system
    exists and can be configured to support this deployment. It is expected within
    enterprise-level networks that a centralized authentication system will be present,
    as it is well suited to these environments. It also has the drawback of having
    a much more complicated setup than WPA personal, however with that extra set-up
    and complication we also get the benefit of having additional security when compared
    to a shared key system. The following image shows the concept of the WPA Enterprise
    authentication process:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4b37f7dc-dadb-4085-9a91-2f2b1049214b.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: The WPA enterprise process
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Wi-Fi protected setup**: This technology, also known as WPS, is yet another
    authentication mechanism that has been implemented both with WPA and WPA2\. It
    is intended for situations where a consumer wishes to streamline the configuration
    process related to keys. Using this technology, a consumer can simply click a
    couple of buttons on both the access points and in their wireless device (if it
    supports WPS), and the devices will perform a handshake type operation and exchange
    keys to allow communication with the wireless network to proceed. This technology
    has the benefit of being convenient but also has the downside of opening up a
    major vulnerability in the wireless network environment. Because this is an important
    concern of ours when relating to Wi-Fi, we will cover this technology and how
    to defeat it in a later recipe in this chapter.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second wired or wireless adapter to connect to the internet.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''re going to do in this particular recipe is go through a few steps
    on how to break a WPA that happens be using a weak passphrase:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Terminal window and find the name of the wireless adapter. Most likely
    this adapter will be named something along the lines of `wlan0`. You should use
    `ifconfig` or `iwconfig` for this.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we enable monitor mode on the interface noted in step one using   `airmon-ng`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With some wireless cards you may get an error message when you attempt to enable
    monitor mode on them. If this happens use the `airmon-ng `check kill command.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the following command to view a list of target access points as well
    as the clients attaching to those access points:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, leave this Terminal open, as it will help us know if we are being successful
    in our attack or not. We will be opening a new Terminal window for the following
    steps.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in this next step we will attempt to capture packets in the air from the
    wireless network that is being targeted:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we want to deauthenticate the connected clients to the Wi-Fi:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding command it is optional to give the client MAC address; it is
    given by `-c <client mac>`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Boot a client off the network so that the client tries to connect to the Wi-Fi
    again. At that time, we will capture the packets which are sent from the client.
    From this result, we will get a WPA handshake.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should start cracking the Wi-Fi. The captured packets command for this
    is:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`-w` is the path to the word list. In my case it is `/root/Desktop/wordlist.txt`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a word list, you can get one by downloading one or using
    one of the ones built into Kali Linux.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now press *Enter.* `aircrack` will start cracking the Wi-Fi and a key will be
    found.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Attacking WPS
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next attack in this chapter is against the technology known as WPS or Wi-Fi
    Protected Setup. This technology was introduced over a decade ago as a way to
    simplify the configuration of clients to a wireless network. The features were
    actually targeted towards consumers and those who do not have IT backgrounds,
    or those with IT heavy backgrounds that simply wish to purchase a computer or
    other device and hit a couple of buttons and have connection to their wireless
    network. If we just consider this capability or feature, then WPS has actually
    done its job quite effectively. However, there are security risks, which is why
    we are talking about it and learning how to exploit it in this particular recipe.
    But before we get too far, let's delve into the mechanics of WPS just a little
    bit more to set up this recipe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: WPS will only work when both the router and the Wi-Fi client support the technology.
    Something to remember as well when discussing WPS is that although the Wi-Fi alliance
    has gone to great lengths to ensure that WPS is standardized across vendors and
    their respective devices, there are some cases where the technology is incompatible
    on two different devices from two different vendors. However, it is important
    to remember that modern devices include not just access points but smart phones,
    tablets and laptops as well as operating systems that support this feature with
    little to no interoperability problems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To set up a discussion on WPS let's first envision a scenario where we would
    want to use WPS. Imagine a network that is using WPA or WPA2 in a personal configuration,
    not an enterprise configuration. In this situation we would have a key entered
    into the access point that we in turn share with any of the clients that wish
    to connect to that access point so they can authenticate and encrypt their traffic.
    As we discussed in the previous recipes, if you want to use this setup or you
    have it in place in your environment it simply means that the key that you entered
    on the access point will now have to go to each client manually, at which point
    they will be able to connect to the wireless network and go about their business.
    This is the scenario that WPS is trying to address. The WPS technology is trying
    to simplify this process so that with a simple push of a button, the key can be
    configured.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Something to remember with WPS is that it does not work with deprecated technologies
    and only works with WPA or its successor. Specifically, this means that WPS will
    not work with WEP in any way, shape, or form and thus if your router does not
    support anything newer then WEP it will not have this feature. It is also possible
    that if your router does support WPA or its successor that it may not support
    WPS either if it came out around the time frame that WPS was just being introduced.
    It is possible that some of these routers may still be in existence or be present
    in your environment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In this setup, a user trying to share out the key would need to perform a few
    tasks to get to the point where they could enter the key. First of all, they would
    go to the access point and enter in the key within the guidelines or rules required
    by the protocol that they have selected. Then they would go to each device and
    open up their wireless client and select the wireless network that they wish to
    attach to; in this case, the one that they configured with the key. Once they
    picked the network by clicking on it there would be a request sent out by the
    client to connect to the wireless network, and in turn the wireless network would
    issue a challenge and the user would be prompted for the key, which they would
    then put in. The problems for those that are not technically savvy or a little
    bit uncomfortable to process are many. One of the biggest issues is that they
    can put the wrong key in and have to go through the process again and undoubtedly,
    they would check the access point to ensure that they actually got the correct
    key, and it would lead to frustration and a lengthy configuration process for
    some.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: WPS works in a number of different ways according to the specification that
    has been put forth by the Wi-Fi alliance. Let's take a look at some of the methods
    that we can use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way we can use WPS is to simply press the WPS button on your router
    which turns on the discovery of new devices. At this point you will go to your
    device and then select the network that you wish to connect to from your wireless
    client. At this point the device will automatically connect to the wireless network
    without entering the password or key. The following photograph shows the WPS button
    on a router:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/31826a88-5b6f-4742-9847-536e342a776d.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: WPS button on a router.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is when you have wireless devices such as printers or range
    extenders that have their own WPS button that will be used when quick connections
    need to be made to these items. When you need to connect these devices to the
    wireless network, what you will do is press the WPS button on the router and then
    on each of the devices that you wish to connect to the wireless network. During
    this process you will not have to put in any data or anything else, as the devices
    will take care of the handshake and perform a communication of information on
    their own. Once the process has completed you will not have to concern yourself
    with using WPS again unless you change a password or reconfigure the network in
    some manner, as the devices will remember the WPS credentials on their own. The
    following image shows a range extender with a WPS button on the front:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ec4f9871-b198-4916-8680-1087eb66e118.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Wi-Fi range extender with WPS
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Yet another method of using WPS is through the use of an eight-digit PIN code.
    Any router that has or makes use of WPS will have a PIN code that will be automatically
    generated and not changeable by users. This PIN is usually on the configuration
    page of the manual or on the router itself, and should be noted. In some cases,
    devices that are WPS button that still have WPS support will ask for the PIN,
    so it is important to record this piece of information. In these cases, when you
    try to attempt a connection to the wireless network you will be prompted for the
    code, and when you enter it the devices will key themselves to the wireless network
    itself and then perform the process of exchanging the proper key.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is one last method that can be used, which also uses an eight-digit
    PIN to authenticate clients during the WPS configuration process. On devices that
    do not have a WPS button that do happen to have WPS support, a specific client
    PIN code will be generated. In these situations, you will take this PIN and enter
    into the router's wireless configuration options. The router will use it to recognize
    the device that's being added and then add it to the network and exchange the
    key as before.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of performance the first two methods on this list are very rapid and
    are the most attractive and more likely to be preferred by consumers who are not
    savvy about working with technology. The last two methods are the slowest, with
    the last option being the slowest of all four options that are available because
    it requires logging in to the router and doing some configuration on that before
    any of the processes working in the device will be authenticated. It's also worth
    noting that nothing requires a vendor to implement WPS in their technology to
    implement all four methods. They can choose to enable just a single one of these
    methods if they so wish.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Just as a footnote to this discussion, it is possible that you may run into
    another way of synchronizing or sharing the WPS pin codes with clients from the
    router. This method uses NFC or Near Field Communication. In this situation, a
    client wishing to connect to the wireless network will take their tablet or smart
    phone and waved over a spot on the router which will in turn read the code into
    the device and allow it to sync with the network. The method in use is similar
    to the same type of technique you would use if you happen to be a consumer that
    makes use of technologies such as Apple Pay or Android Pay, where you simply wave
    your device over a terminal at a cash register and payment is made.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Just about all modern routers support WPS, as this item is the central component
    of the vast majority of wireless networks, especially in the consumer space such
    as homes or small businesses. Since these form the core component, it makes sense
    that this device would be essential in supporting this network security standard.
    On many routers you'll even find that the WPS technology is enabled by default
    and is ready to be used as soon as the router is powered up and made part of a
    network. There are some situations where you must manually enable WPS by going
    directly into the wireless router and using options in the interface to turn this
    feature on, but in most cases you will have to manually turn the feature off because
    it is usually on by default.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A little footnote on the support of WPS in routers is that many routers not
    only have WPS support enabled but it is incredibly difficult if not impossible
    to shut off. In some routers you may have to disable other features available
    on the router in order to just be able to disable WPS itself. For example, on
    some wireless access points you may have to disable the main wireless network
    and instead go with the guest network as your primary network. In other wireless
    networks the access point will allow for WPS to be enabled if you do things such
    as shutting off the broadcast of the SSID of the network. However in this latter
    case this may not be something that you want to do. Always look to your access
    point to see how to disable WPS if you choose to do so.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As far as WPS support within operating systems goes, there is almost universal
    support and inclusion of the feature. In the case of Microsoft, Windows WPS is
    up and supported in every operating system release since 2007 which essentially
    boils down to everything from Windows Vista and later. On the Android side there
    has been full support for WPS since 2011 with version 4 of Android, Ice Cream
    Sandwich. Every version of Android since that version fully supports WPS. Support
    in operating systems such as Linux is nearly universal with some versions of the
    operating system not supporting it as it has been removed or disabled by the developers
    of the distribution, but overall support is present in the operating system in
    most cases. That leaves us with the Apple family of operating systems, on both
    their computers as well as anything using iOS, where in this case we have no native
    support for WPS; it is only available through add-ons or other enhancements from
    third parties.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the WPS dialog in Windows 7:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1032813c-b09e-4a4d-8418-2b1b073dd9f2.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: WPS dialog in Windows 7
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we know what WPS is, let''s discuss what its problems are, before
    we go into the specific recipe designed to defeat the technology. There are a
    number of problems that exist with the WPS standard, and we''re to take a look
    at these things to see what they actually mean to us as someone evaluating this
    technology:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest problems with WPS is that if someone gets physical access
    to the router they can simply turn the router over and take a picture; in a lot
    of cases, the label on the router will have a code that allows an override of
    the WPA2 password. The following diagram shows a router with the code on its label:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f85f0f61-b977-4230-b215-2a5291f7d043.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: label including PIN code
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In many routers the use of the WPS protocol cannot be disabled easily, if at
    all, which means that if you are not going to make use of it in the future you
    cannot take basic security measures to shut it off if you're not using it.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another big problem is the way WPS is implemented, due to the fact that the
    protocol it exchanges a PIN code which is eight characters long, and the way it
    is stored presents some problems. Without getting into all the particulars, essentially
    this eight-digit PIN is broken into two four-digit blocks that are exchanged between
    the client and the access point. Due to the way this code is checked between the
    client and the access point there is not a strong system for validating this code.
    Due to the way this code is broken into two blocks and how this process behaves
    afterwards it becomes easy for an attacker to use software to guess the correct
    PIN code. In fact just to make things easy and to step away for the mathematics
    of the whole process, because of the way the PIN code is validated we find that
    it is possible for someone to get the correct code by only making 5,500 guesses,
    which is easy for modern computers to do. In Kali, we find that we have software
    that allows us to make 11,000 guesses very quickly and efficiently with little
    effort on our side.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are someone who's running the math on this and trying to figure out how
    many possible PIN code combinations there are, you may have come to a much larger
    number than the one stated here in this text. In fact, if you consider the fact
    that a PIN code only allows the numbers zero through nine to be used in every
    one of the eight slots in the PIN code you could do the math and come up with
    around 100 million possible code combinations. However, this is just not the case.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we don't even have eight digits for the PIN code, as the last
    digit is used as a checksum or way to verify that the code has been transmitted
    correctly and there are no flaws. So that leaves us with seven digits. However,
    the problem here is that though seven digits are not evaluated as one contiguous
    number; it is in fact broken into two pieces. The Wi-Fi enabled device will send
    the router for the first four digits, which will get validated, and then it will
    send the last three separately for validation. If we do the math at this level
    we find that with four digits we have 10,000 different combinations and with three
    digits we have 1,000 different combinations; if we add these two together we have
    11,000 possible combinations of codes. If we do the math little bit more and use
    a little logic, we find that more likely an attacker probably would have to guess
    about half the codes before they get something that successfully solves the problem.
    This is where we get the aforementioned 5,500 guesses. However, if we wanted to
    it and do an exhaustive brute force search of all the possible codes, this would
    be 11,000 different combinations which still is not any sort of monumental task
    that can't be overcome by any modern computer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are the basic requirements and you could easily use more
    (or different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we're going to do in this particular recipe is go through a few steps on
    how to break a WPA that happens be using a weak passphrase.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we start our attack against WPS is to use a familiar command, `airmon-ng`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again we are putting our card into monitor mode to detect wireless networks
    in the area. We could follow this command up with `airodump-ng`, like we did with
    WEP and WPA/WPA2, but we will instead switch over to using the `reaver` suite
    and use it''s built-in commands. In this case we will issue the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command is designed to hunt for networks that use WPA specifically. When
    you run the command, you will get an output similar to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b847af2-7138-434f-947b-47652ed02795.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Results of wash command
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The results should find networks in the area. The networks displayed will include
    everything in the immediate area. Of these networks there may be some that are
    vulnerable. In the results you will notice a WPS locked column; this is far from
    a definitive indicator, but in general, you'll find that APs which are listed
    as unlocked are much more likely to be susceptible to the brute force that we
    are attempting here. You can still attempt to launch an attack against a network
    which is WPS locked, but the chances of success are diminished dramatically.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Once you've found a network you wish to run the attack against, operating `reaver`
    is very straightforward. The basic command needs only the local interface, channel,
    and ESSID to be specified.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the command to launch `reaver` against the mordred network would
    look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only part of the above command that might not be immediately obvious is
    `-vv`; this enables verbose output which greatly helps when trying to gauge how
    well `reaver` is functioning.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve started `reaver`, you''ll start seeing output like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38cf3d81-d910-419d-8834-22aaeda34d6c.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: This output shows that WPS pins are successfully being tried against the target
    (here we see `12345670` and `00005678` are being tested), and `reaver` is operating
    normally.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This process may take a lengthy period of time, but you will see feedback telling
    you that the attack is in progress and functioning. What may slow down the attack
    is the fact that many vendors have been trying to implement protections against
    WPS attacks, and additional options may be required to get the attack moving.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, `reaver` keeps a progress log file automatically, so you can stop the
    attack at any time and resume whenever it's convenient. Spending a few hours a
    day running `reaver` against the same network should uncover its PIN, and through
    that the WPA passphrase.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
