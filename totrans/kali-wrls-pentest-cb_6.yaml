- en: Authentication Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: WEP attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA attacks and WPA2 attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking WPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacks against authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we are going to explore another form of attack: attacks against
    authentication mechanisms and the components surrounding the system. Attacking
    an authentication mechanism on a wireless network can give attackers the ability
    to access parts of the system and the resources hosted on it with very little
    or no resistance whatsoever. In fact, the very reason for having an authentication
    mechanism is to be able to validate the identity of a user or host, and if this
    is subverted or circumvented in some way, then we end up with a situation where
    all sorts of access and actions can be carried out. However, before we get into
    this chapter, let''s take a look at what authentication is, what it is designed
    to accomplish, and how it can work in a very abstract form, and then we can use
    this knowledge to understand the attacks in this chapter that much better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So first let''s get things started by talking about what happens when you as
    a user attempt to log into a system, really any system for all purposes here.
    When a user logs into a system they are going to be subject to a number of events.
    The first thing they will do is to present an identity, which is a statement as
    to who they are claiming to be to the system they are trying to access. Now, identity
    is something that on its own is not to be used to allow access to a system, because
    all it is just a claim or assertion to someone; it''s not definitive in any way.
    This means that I can claim I am a movie star, a politician, or even the president
    of the United States, but without providing something to validate that identity,
    it''s just a claim without any merit or weight assigned to it, and therefore not
    enough to go to the later steps which grant access to trusted information resources.
    To do this, we need to move to the authentication step. The following diagram
    shows the authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9130aed4-b931-416a-a7fe-26172fb6a1a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The authentication process
  prefs: []
  type: TYPE_NORMAL
- en: 'When we say authentication, we are performing some sort of action which proves
    that the claim a user is making about who they are is actually valid. The most
    common way to do this is through the use of a password; many of us have run the
    situations where we provide a username, which would be our identity, and then
    we provide a password, which is a secret piece of information that only we know,
    that can be used to say we are who we say we are and you can trust us. So, as
    we can see, an identity in the form of a username is not enough on its own to
    prove anything; it has to be authenticated to validate that this party can be
    trusted by them providing an answer that only the person with that identity would
    know. And the system that they are authenticating to would have some way of comparing
    their provided answer—or password in this case—to something that they already
    have stored locally in order to ensure that the provided answer is correct and
    the right one. The following screenshot is an example of a Windows login box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e079316a-33da-43ef-ae7b-5d4f03847fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: A login box
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, there are three recognized ways of authenticating which should
    be thought of as general categories of authenticating to a resource. Just to complete
    your knowledge of these different ways, let''s take a brief look at each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Factor 1 authentication covers any situation where a piece of information such
    as a pass code or passphrase or PIN number has to be provided in order to authenticate
    an identity. The important detail or element of this first factor of authentication
    is that it is something that you know and store in your brain and provide when
    requested. This is by far the most common form of authentication that is used
    in computer networks and software as well as our wireless networks, as we will
    see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factor 2 authentication covers any sort of situation where a physical item has
    to be provided to authenticate an individual or system. Items such as a key for
    a door, an ATM card, or even a token can be used to present to the system or generate
    a special code that can be used to validate the identity of the user much like
    before. This form of authentication is also sometimes referred to as something
    you have—as in something you possess—which we can see in the case of a car door
    key. This type of authentication is not common to see in the case of wireless
    networks, but there are some exceptions, such as situations where a special code
    may be generated to log in to a corporate network or a guest network as the case
    may require.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following photograph shows an example of factor 2 authentication technology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20b742ad-e0a9-495e-ac83-0d9cf622fe39.png)'
  prefs: []
  type: TYPE_IMG
- en: A factor 2 authentication token from RSA labs
  prefs: []
  type: TYPE_NORMAL
- en: 'Factor 3 authentication is a form of vindication which relies on what is commonly
    known as biometrics. Simply put, biometrics are a method by which we measure a
    characteristic or trait of a physical organism and use that as a way of validating
    an identity, much like you did with the first two factors. Characteristics such
    as fingerprints, eyeballs, palm prints or even facial recognition have all been
    used to provide this authentication factor. While this form of authentication
    can be very accurate and highly reliable, it does have a drawback over the other
    factors that tend to make it less common as it is more tricky to implement, considering
    the expense and complexity involved in setting up such systems. It is also worth
    noting that it is extremely rare to see this type of authentication factor with
    wireless networks as a form of authentication. This doesn''t mean you can''t use
    these authentication mechanisms with a wireless network; it just means that they''re
    not used to authenticate to the wireless network in most cases. This type of authentication
    is just included here for your reference. It is not something that we are going
    to be looking at subverting or circumventing in this book. The following image
    shows an example of factor 3 authentication technology:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7124d2b1-8c18-4817-86d7-031402cc3731.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A factor 3 fingerprint reader
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered authentication, the next thing to cover is what happens
    after the system has validated who you are claiming to be. Remember, all that
    the authentication has done is validate that the identity you have provided to
    the system is not just a claim, it is actually true and correct and can be trusted
    as to its accuracy. This in no way means that you have been granted access to
    a system. Think of it as providing a driver's license or some other piece of information
    to an official. Just because that documentation checks out and says you are who
    you are claiming to be it does not mean that you will be allowed to, for example,
    enter restricted areas or carry out some other actions, because all it does is
    prove that you are who you are claiming to be, and that's it. For you to be able
    to move to the next step you have to undergo a process known as authorization.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is authorization? Well authorization is actually quite simple. Authorization
    takes your validated identity and compares it against a set of rules that are
    configured on the system. These rules are used to determine what your specific
    level of access and interaction with the system will be and are configured and
    put in place by whoever the system owner administrator happens to be, in accordance
    with their guidance and the standards that they wish to have in place.
  prefs: []
  type: TYPE_NORMAL
- en: Once authorization is complete then the user will have access to the system
    in whatever capacity or level the system owner wishes them to have. So, they can
    continue to have whatever interactions they have been granted.
  prefs: []
  type: TYPE_NORMAL
- en: Something to remember with authentication is that authentication is not unique
    to wireless. It's something that plays a role in controlling access to different
    applications, devices, networks and other items. Without authentication, system
    and device security becomes a much bigger challenge, and therefore it has to be
    present across a diverse range of items. In this chapter we talk about authentication
    in the context of wireless devices and technology, but don't forget that it is
    present not just in wireless but also on the network's applications that you access
    through the wireless as well as those ones that you access through traditional
    wired means.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a wireless network, there are many attacks that can target authentication,
    and we can only cover a few of them here in this book. But the ones we will cover
    are some of the more common ones that you will run into, and which can affect
    wireless networks and performance. Authentication on wireless networks includes
    a diverse number of technologies and mechanisms, many of which we have covered
    in previous chapters, but just to be complete, let''s talk about a few of the
    different items here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**: the use of encryption is vital in just about all authentication
    mechanisms that are available, as it provides a way to ensure both the confidentiality
    of credentials as well as the integrity of those credentials and the systems that
    store them. Without encryption it would be very tough to protect credentials when
    they are being stored as well as when they are being transmitted. It would also
    be very tough to ensure that these credentials are accurate when they are transmitted
    across a network, or if they''ve been altered from their original form. It''s
    safe to say that without cryptography, we would not have authentication available
    in many of the forms that we do now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-Shared Key** (**PSK**) **systems**: This involves the use of systems
    where a common key is entered on each workstation of a device that allows it to
    authenticate to the wireless access point. This type of protection usually comes
    in the form of non-enterprise WEP, WPA or WPA2\. It is worth noting that pre-shared
    key systems are extremely common in home and small business environments, but
    when you start scaling up environments to medium, large, and enterprise size environments
    then pre-shared key systems tend to be avoided in favor of enterprise authentication
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise authentication**: In large environments it is not uncommon to
    see heavy-duty authentication systems in the form of enterprise authentication
    mechanisms. These mechanisms allow for the scaling up of authentication as well
    as the centralized control and management of authentication. This means that these
    authentication systems can not only provide a robust way of authenticating wireless
    clients in this case but they can also be used to set a uniform set of rules or
    even fine-tune these rules for authorization on a site by site basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is a list of just three things that are part of authentication in
    the enterprises, there are many more that exist that can possibly be deployed.
    We, however, will refrain from getting too far into some of the more exotic and
    complex forms that are out there, and just stick with the basic ones which you
    are most likely to encounter in your explorations.
  prefs: []
  type: TYPE_NORMAL
- en: Types of attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The attacks that target authentication on wireless networks are varied, with
    each having its own advantages and disadvantages that make them useful or not
    useful in any given situation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start exploring each one of our attacks, let's first lay out the attacks
    that will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: WEP attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA2 attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPS attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember these are just a few of the types of attack that can be used to subvert
    the authentication of a wireless network; they should never be considered the
    only types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: WEP attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first attack we are going take a look at or re-examine in this particular
    chapter is the attack against the wired equivalent privacy, or WEP, protocol.
    We've encountered this protocol a few times in our journey through this book,
    and we're to take another look at it here, with some additional items added that
    weren't there before, and endeavor to expand on this attack so as to discuss the
    real weaknesses in this protocol that make it so vulnerable to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the WEP protocol is something that was implemented and designed
    when wireless security was something that was understood to be an issue, but the
    people at designed wireless technologies did not really understand how to properly
    implement security, nor did they consult with outside parties that could have
    helped them do it better. In all practical senses, WEP should no longer be used
    in any active network as it presents too much of a target of opportunity for someone
    wishing to cause you harm by stealing your data or modifying data on your network
    during transmission. A few years ago the attacks that were successful against
    this protocol were a lot tougher to carry out successfully than they are now simply
    because the tools required a higher degree of knowledge and experience to operate.
    Nowadays the tools designed to target this protocol are much more refined and
    easy to use, and they are accessible by a much wider audience; they just need
    to be aware of the tools and be willing to follow a few cookbook style directions
    to make them work in a way that achieves a successful result.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fill a little more back story on the WEP protocol, just to fully flesh
    out the angle we're approaching things from. This protocol was designed way back
    in 1997 as part of the original wireless standards. It was designed to use a reasonably
    strong encryption protocol known as RC4, designed to protect traffic against accidental
    disclosure, and it used CRC 32 for integrity protection. Neither of these protective
    measures were a bad decision. However, they were used improperly in the design
    and implementation of WEP.
  prefs: []
  type: TYPE_NORMAL
- en: To understand one of the problems with WEP, we need to understand how keys are
    generated in this protocol. In practice the standard 64-bit WEP protocol makes
    use of a 40-bit key plus a 24-bit initialization vector or IV which together forms
    what is known as the RC4 key. This key is what was used to encrypt and protect
    traffic during transmission.
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will quickly look at the fact that we are using a 40-bit key
    plus a 24-bit initialization vector as a problem - specifically, the 40-bit key
    is a big problem to concern ourselves with. At the time this 40-bit number was
    decided upon, technology was already available that made cracking the short version
    of the key more than possible in a reasonable amount of time. Nowadays, cracking
    a key of this sort is extremely easy and takes little to no time at all. So inevitably
    the question comes up as to why the developers of this protocol decide to use
    such a short key when longer encryption keys are stronger and better in most cases.
    The biggest reason is that at the time that WEP was designed, the United States
    government had strict export controls on cryptographic technologies and any technology
    or device that implemented or made use of such cryptographic tools. It was due
    to these restrictions that the key size was limited to such a degree. Later on
    after such restrictions were lifted the key links were increased to 104-bits with
    a 24-bit initialization vector. There are some longer links available, but even
    with this 128-bit key size the protocol still has vulnerabilities and thus should
    not be used.
  prefs: []
  type: TYPE_NORMAL
- en: In most access points that used WEP, the key was entered as a hexadecimal value
    or was translated into a hexadecimal value, meaning that it used a key that incorporated
    values from `0` to `9` and `A` through `F`. Consumers or systems administrators
    using WEP on their access point would be entering their key directly on the access
    point and then enter the same key on all the clients they wish to connect and
    everything would work accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Something that can be utilized within the WEP encryption system that is of concern
    to us here are the different types of authentication that identify a client, not
    a user, to a network. Two authentication methods are **Open Systems Authentication**
    (**OSA**) and **Shared Key Authentication** (**SKA**). Both of these have seen
    use to varying degrees, with most people opting for the latter over the former,
    although the former is seen in a number of cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of OSA we have a situation where a client is able to attach to the
    wireless access point without having to provide any credentials or anything to
    identify itself. In effect, any client is able to authenticate directly to the
    access point and associate. What this really means is that if you split hairs
    there is no authentication occurring at all, even though it says so in the name
    of the system. However, a client can subsequently encrypt their traffic after
    the fact by having access to a WEP key to do so. This means that the key will
    have to be provided to a client to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our second authentication mechanism, which is shared key, a client will
    have to provide a WEP key to authenticate to the network in order to properly
    associate and communicate on that network. In practice it breaks down to a four
    step process which we should talk about to understand the process that we are
    working with in order to recover our keys:'
  prefs: []
  type: TYPE_NORMAL
- en: The client will send a request to authenticate to a wireless network, or specifically
    an access point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The access point will respond to this request to associate with a clear text
    message or challenge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client will then take this clear text message and will encrypt it using
    the preconfigured WEP key and then take the results and transmit back to the access
    point as another authentication request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point the access point will take its copy of the WEP key, use it to
    decrypt the encrypted key it has received, and then compare the results it gets
    to its original clear text response; if the results match, then association will
    occur. If not, it will be rejected. The following diagram shows the process of
    the WEP process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5a16ebc-2aae-4a0d-ac07-a9244684b452.png)'
  prefs: []
  type: TYPE_IMG
- en: The WEP authentication process
  prefs: []
  type: TYPE_NORMAL
- en: Once the decryption process is completed, the WEP key does not get pushed to
    the background, waiting for another authentication to happen; rather, it is used
    to now encrypt the traffic that is transmitted between the client and any other
    point on the network or access point.
  prefs: []
  type: TYPE_NORMAL
- en: It really is important to point out that despite the obvious notion that shared
    key authentication is more secure because there is authentication going on before
    a client is allowed to associate to the network, this is actually not true. In
    fact it's the opposite situation due to the fact that in a shared key system,
    data is exchanged prior to it being encrypted and if the key is short, it is possible
    to extract the key from this sequence of authenticating a client to a network.
  prefs: []
  type: TYPE_NORMAL
- en: The way this protocol was constructed in the key links that were made available
    leads to some definite problems that make our chance of attack and its success
    quite high. You should examine why this is possible so we can understand why the
    attack that we're using works as well as it does. First let's understand that
    the RC4 is a symmetric and stream cipher that quickly loses its effectiveness
    if the same key is used twice during the same transmission of data. If the key
    is used twice it opens up a door that allows us to compare traffic and look for
    patterns that may reveal the key. The way the designers decided to defeat this
    type of situation was to use a 24-bit initialization vector which when combined
    with the 40-bit key was intended to prevent keys being reused during the same
    transmission. However the short 24-bit length of the initialization vector means
    that on a sufficiently busy network the chances of the same key being reused over
    and over increases dramatically. In fact just to throw out some numbers, the chance
    of the same key being reused increases to about 50 percent after around 5000 packets
    have been transmitted. Therefore it's not hard to imagine that on a sufficiently
    busy network you could gather this amount of packets pretty quickly. In fact,
    our attack relies on the fact that we are able to capture several thousand or
    hundred thousand plus packets and use them to successfully recover the key.
  prefs: []
  type: TYPE_NORMAL
- en: Just to give you some numbers on how easy it is to successfully and quickly
    break this protocol, think of some of the cases that are on record. In 2005 it
    was shown that a WEP key could be recovered from a wireless network using the
    protocol in around just three minutes, or even less depending on the environment.
    Later attacks that showed up over the following years have further reduced this
    time and some have even claimed that they are able to recover the key from traffic
    using as few as 40,000 packets with a better than 50 percent probability of success
    each and every time. This should really bring into focus why this is just not
    a good protocol to be using, and those who are still using it should be strongly
    encouraged and move away from the technology before they end up in a bad situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second wired or wireless adapter to connect to the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to crack the WEP key for an access point running the protocol, there
    is a process involved that requires the collection of what are known as **Initialization
    Vectors** (**IVs**). The problem with this process is that under normal conditions
    a network does not generate a lot of these items in a short period of time. Under
    normal conditions this means we would have to wait a prolonged period of time
    to get enough IVs to retrieve the network key. However, we can speed up this process
    by utilizing the information from our previous recipe, together with some new
    skills, to retrieve the key. To put it simply, we will inject packets into the
    network in an effort to get the access point to generate a large number of packets
    in a substantially shorter period of time, which means that the ability to capture
    more packets with weak IVs is increased.
  prefs: []
  type: TYPE_NORMAL
- en: With this process being completed, we can then use the captured traffic to retrieve
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the steps we will be looking at here in this recipe will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the wireless interface in monitor mode on the specific AP channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the injection capability of the wireless device to the AP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `aireplay-ng` to do a fake authentication with the access point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `airodump-ng` on AP channel with a `bssid` filter to collect the new unique
    IVs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `aireplay-ng` in ARP request replay mode to inject packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `aircrack-ng` to crack the key using the IVs collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step we need to perform for breaking WEP is to switch our card into
    monitor much like we did previously. In most cases the card that is installed
    in your system, if your system came with a built-in wireless network adapter,
    will be very easily capable of switching into monitor mode. If it is not, then
    you can always go with a third-party adapter, such as a USB adapter or an adapter
    card that is installed into your system directly to support this capability. We
    need this mode in order to allow the network interface to detect every packet
    that is being transmitted by nearby networks without being associated to those
    same networks. To do this on a network interface named `wlan0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`airodump-ng start wlan0 9` (the `9` will lock the card to listening on channel
    `9`, but this can be changed to the channel on the access point you wish to observe.
    You can discover the channel of the access point you wish to target by running
    the command without the channel designator).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `Enter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An important detail to remember is that most wireless networks tend to run on
    one of three channels which are `1`, `6` or `11`. The reason for this is that
    these are the only three channels in this range that do not fully overlap, and
    therefore if you use one of them the risk of interference is reduced. You can
    use other channels than the ones specified here but you can expect to get some
    degree of interference which may be higher than you would like. In this recipe
    I have stuck with using channel `9` only as an example. When you scan for targets
    in your area, check the channel of the target that you wish to work with and use
    that channel.
  prefs: []
  type: TYPE_NORMAL
- en: Once the card has responded that it is in monitor mode, we can now move on to
    the next step, which is to prepare ourselves to perform a packet injection on
    the target network. So, verify that any prompts you have received on screen are
    verifying that you have indeed switched into monitor mode on the specified channel,
    and you can proceed. If you have not gotten a response indicating that you have
    switched into monitor mode, then retry the command to see if perhaps you entered
    something wrong or you're getting some other problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to ensure that we are in a situation where we can properly
    perform our packet injection against our target network. So we want to verify
    that we are at close enough proximity or getting a strong enough signal to be
    able to perform this packet injection and get the results that we''re looking
    for. Fortunately we have a tool that is designed to help us with this situation
    and ensure that we are where we need to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-e ganon` is the wireless network's name and `-a 00:28:6C:E4:40:80` is
    the access point's MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: The system should respond with a prompt that it is waiting for a beacon frame,
    and in short order it should also respond that the injection process is working
    and it has found the access point that you have defined. If you do not get this
    response along with information indicating channel, speed, and maybe even power,
    then you may try to move closer to your target or change position, or maybe even
    consider using an antenna or a different adapter to get a better signal.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally the response that you should get back at this point should indicate
    that you are getting close to 100 percent of a signal from the access point or
    target network. If you get anything indicating that you're getting less than 100
    percent it's not necessarily a bad thing, but as you drop below 90 and then 80
    and then 70 percent you get a less reliable signal, and this could impact the
    chances of this attack actually working successfully. Don't always expect to get
    a 100 percent signal or response, but you want to get something that is as close
    as possible. Lesser values may work successfully and you shouldn't necessarily
    let a lower value stop your attempt at an attack ,but be aware you could end up
    with less than stellar results.
  prefs: []
  type: TYPE_NORMAL
- en: With the above steps out of the way now, we can move on to the step of actually
    capturing initialization vectors or IVs. If you recall from the introduction to
    this attack, this was the crucial item that ensures that the same key is not reused
    over and over again on traffic. We also learned that the short length of the initialization
    vector led to traffic on high-volume networks, potentially reusing the same key
    after only 5000 packets had been transmitted. So what we need to do is prep ourselves
    to capture this traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this you will be opening a second console session. So, leave your previous
    session up and open up a second one in the Kali interface to run the following
    command (do not close the first console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`--bssid 00:14:6C:7E:40:80` is the access point''s MAC address. This eliminates
    extraneous traffic. `-w` capture is the file name prefix for the file which will
    contain the IVs.'
  prefs: []
  type: TYPE_NORMAL
- en: Once this command is executed you will start seeing that the traffic is being
    captured—albeit very slowly in comparison to what we are going to be doing in
    the next few steps to generate more traffic. Remember that WEP has a better than
    50 percent chance of reusing a key after 5,000 packets have been generated. So
    what we want to do is induce a situation where a large volume of packets is generated
    in a very short period of time. If you just waited and watched what was being
    generated on screen, as you are at this stage, you'll see that the number of packets
    or information being gathered moves up at a gradual and unsteady pace.
  prefs: []
  type: TYPE_NORMAL
- en: Conceivably, you could just collect traffic this way at the normal pace of the
    network, but keep in mind that if we have to generate or collect several thousand
    packets to be able to successfully increase our chances of success, you could
    be waiting a while. The less active a network is, the less chance you have of
    just passively sitting by and in a short period of time collected enough trafficking
    to be able to recover a key. In fact, it is possible you could find yourself waiting
    and listening for two or three days just for enough traffic to successfully recover
    the key. That can be a little challenging and also dramatically increases your
    chances of being detected.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to perform an authentication with the access point. We need
    to do this because we are going to be injecting packets on to the wireless network
    and to be able to do that we need to create an authentication. If we have not
    authenticated and associated with the network then we run into a situation where
    our attempt at connecting will be outright rejected, and fail. What we are doing
    is performing a fake authentication and attempting to connect to the network.
    The way we do this is by grabbing the MAC address of a client that is already
    associated to that wireless network successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to associate a client with an access point we will use fake authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or another variation for picky access points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If everything works successfully, you should get a message saying that you have
    associated successfully. If not you will get a message indicating that you have
    not associated successfully with a wireless network and you'll need to try again
    at that point, but generally, if you follow the steps here, you should be more
    than likely to associate with your target. If you don't successfully associate
    and authenticate to your wireless network by spoofing the MAC address of a victim,
    then you will not be able to move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the moment of truth, where we will be generating or inducing
    our target network to generate traffic that we can use to recover the key. The
    way this process works is by using something known as an ARP request or broadcast.
    What we're trying to do is send out an ARP request just like any normal network
    client would. However, when this broadcast goes out looking for a client, the
    access point will, by design, rebroadcast this out to the network every time we
    send one out. So it has the effect of generating a lot of traffic that is in turn
    encrypted and protected with the WEP key. And since we are going to be listening
    and capturing this traffic to a file, if things go right we will have recorded
    a bunch of traffic that used the key (if we're patient), and that we can run a
    cracking operation or recovery operation on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the injection we need to open another console and enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It will start listening for ARP requests and when it hears one, `aireplay-ng`
    will immediately start to inject it.
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm that you are injecting by checking your `airodump-ng` screen.
    The data packets should be increasing rapidly. The `#/s` should be a decent number.
    However, 'decent' depends on a large variety of factors. A typical range is 300
    to 400 data packets per second. It can be as low as a 100/second and as high as
    a 500/second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have captured the traffic to a `.cap` file we will now try to retrieve
    the key from the captured packets. To do this we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another new console session and enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can run this while generating packets. In a short time, the WEP key will
    be calculated and presented. You will need approximately 250,000 IVs for 64-bit
    and 1,500,000 IVs for 128-bit keys. Note that these values are rough guidelines
    and other variables can impact how much traffic and IVs you actually need to collect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the process completes successfully you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9affb85-dba9-4dbe-a58e-b201479de225.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the key is not displayed as you would expect it. The characters next
    to `Key Found`, between the square brackets, is the passkey in hexadecimal. If
    you remove the colons and then paste the remaining characters into your wireless
    client when prompted to be associated with the network, it will still work.
  prefs: []
  type: TYPE_NORMAL
- en: WPA and WPA2 attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next attack targets a technology known as WPA or Wi-Fi protected access.
    As seen in our previous recipe WEP has a lot of drawbacks and vulnerabilities
    that could be exploited quite simply to gain access to and expose the information
    on networks protected with this protocol. Due to vulnerabilities and issues with
    WEP a replacement was sought, and an immediate replacement came in the form of
    WPA. WPA was designed to be an update or upgrade to WEP that can be implemented
    strictly to firmware upgrades on wireless network cards as well as wireless access
    points that were able to support the newer standard. When this new technology
    was introduced it solved a lot of the problems that WEP had brought to the table
    and made system administrators and consumers breathe a little bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that while most wireless cards were able to have a simple
    firmware update performed to include the new features and capabilities available
    with WPA, not every wireless card could be upgraded through firmware to support
    the new technology. In some cases wireless network cards had to be outright replaced
    in order to take advantage of the newer technology as it debuted. On the other
    side of the equation, access points that were used to anchor a wireless network
    required much more extensive upgrades and work to be done than could be allowed
    on a standard firmware update in most cases. As a result most of the access points
    available before 2003 were unable to be upgraded to support WPA, which meant that
    users had to replace these access points rather than upgrade them. In most cases
    it was because the older hardware did not have the processing power available
    to support the beefier requirements that were seen in the newer standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'WPA is built on a standard known as IEEE 802.11i. The standard defined a number
    of things, not all of which would be implemented immediately with WPA; some would
    have to wait for the newer WPA2 standard protocol to be implemented. However from
    this standard we did see the implementation of what is known as the Temporal Key
    Integrity Protocol, or TKIP. This technology was designed to replace what WEP
    used with its 64 or 128-bit keys. With this new protocol, keys were generated
    dynamically on a per packet basis with a new 128-bit key for each packet, meaning
    that the attacks that we saw with WEP are no longer possible with WPA. The following
    image shows the WPA process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/585a5cb5-ef65-46d3-8988-0b31b371b92f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The WPA process
  prefs: []
  type: TYPE_NORMAL
- en: WPA also updated and streamlined the integrity checking that was present in
    WEP. WPA uses what's called a message integrity check, which is designed to perform
    the same purpose as prior technologies, meaning that it is designed to stop an
    attacker from altering or re-sending data packets in what is known as a data replay
    attack. The reason for this replacement of the old CRC protocol is that the older
    protocol wasn't really sufficient to protect against all sorts of data integrity
    checks and replay attacks. Thus, it was decided that the newer message integrity
    checking—that actually had been in use in many forms for a while—should be implemented
    in WPA. It is actually worth mentioning that one of the reasons why some older
    network cards and access points cannot be updated to the newer WPA protocol is
    that the message integrity check is actually more computationally intensive than
    the old CRC check used in WEP.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since the newer WPA protocol with the message integrity check in place
    was implemented, it has been found that there are some flaws in the protocol relating
    to this technology. It is also important to note that the encryption technology
    used overall in WPA has been found to have flaws as well. However, it is also
    important to note that while there are flaws in WPA they are not as dramatic and
    glaring as those that are present in WEP. Nevertheless, at the end of the day,
    if one has an option to upgrade to WPA2 they should take that option, rather than
    staying with WPA or even WEP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the WPA protocol there are some terminologies that relate to authentication
    of which you should be aware:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WPA personal**: This authentication mechanism, also known as WPA – PSK, is
    primarily targeted to home and small office networks that don''t require or don''t
    have centralized authentication system. In this set-up each wireless device will
    derive unique 128-bit encryption keys from a shared 256-bit key. This key is entered
    individually into the access point as well as each individual client that will
    be connecting to this access point or wireless network. This key can be entered
    in 64 hexadecimal digits or as a passphrase of 8 to 63 characters as desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WPA enterprise**: This is a mode of authentication which is sometimes also
    referred to as WPA – 802.1x. This type of set up is designed for enterprise-level
    networks and relies on the fact that a centralized authentication server or system
    exists and can be configured to support this deployment. It is expected within
    enterprise-level networks that a centralized authentication system will be present,
    as it is well suited to these environments. It also has the drawback of having
    a much more complicated setup than WPA personal, however with that extra set-up
    and complication we also get the benefit of having additional security when compared
    to a shared key system. The following image shows the concept of the WPA Enterprise
    authentication process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4b37f7dc-dadb-4085-9a91-2f2b1049214b.png)'
  prefs: []
  type: TYPE_IMG
- en: The WPA enterprise process
  prefs: []
  type: TYPE_NORMAL
- en: '**Wi-Fi protected setup**: This technology, also known as WPS, is yet another
    authentication mechanism that has been implemented both with WPA and WPA2\. It
    is intended for situations where a consumer wishes to streamline the configuration
    process related to keys. Using this technology, a consumer can simply click a
    couple of buttons on both the access points and in their wireless device (if it
    supports WPS), and the devices will perform a handshake type operation and exchange
    keys to allow communication with the wireless network to proceed. This technology
    has the benefit of being convenient but also has the downside of opening up a
    major vulnerability in the wireless network environment. Because this is an important
    concern of ours when relating to Wi-Fi, we will cover this technology and how
    to defeat it in a later recipe in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second wired or wireless adapter to connect to the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''re going to do in this particular recipe is go through a few steps
    on how to break a WPA that happens be using a weak passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Terminal window and find the name of the wireless adapter. Most likely
    this adapter will be named something along the lines of `wlan0`. You should use
    `ifconfig` or `iwconfig` for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we enable monitor mode on the interface noted in step one using   `airmon-ng`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With some wireless cards you may get an error message when you attempt to enable
    monitor mode on them. If this happens use the `airmon-ng `check kill command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the following command to view a list of target access points as well
    as the clients attaching to those access points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, leave this Terminal open, as it will help us know if we are being successful
    in our attack or not. We will be opening a new Terminal window for the following
    steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in this next step we will attempt to capture packets in the air from the
    wireless network that is being targeted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to deauthenticate the connected clients to the Wi-Fi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command it is optional to give the client MAC address; it is
    given by `-c <client mac>`.
  prefs: []
  type: TYPE_NORMAL
- en: Boot a client off the network so that the client tries to connect to the Wi-Fi
    again. At that time, we will capture the packets which are sent from the client.
    From this result, we will get a WPA handshake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should start cracking the Wi-Fi. The captured packets command for this
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`-w` is the path to the word list. In my case it is `/root/Desktop/wordlist.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a word list, you can get one by downloading one or using
    one of the ones built into Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Now press *Enter.* `aircrack` will start cracking the Wi-Fi and a key will be
    found.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking WPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next attack in this chapter is against the technology known as WPS or Wi-Fi
    Protected Setup. This technology was introduced over a decade ago as a way to
    simplify the configuration of clients to a wireless network. The features were
    actually targeted towards consumers and those who do not have IT backgrounds,
    or those with IT heavy backgrounds that simply wish to purchase a computer or
    other device and hit a couple of buttons and have connection to their wireless
    network. If we just consider this capability or feature, then WPS has actually
    done its job quite effectively. However, there are security risks, which is why
    we are talking about it and learning how to exploit it in this particular recipe.
    But before we get too far, let's delve into the mechanics of WPS just a little
    bit more to set up this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: WPS will only work when both the router and the Wi-Fi client support the technology.
    Something to remember as well when discussing WPS is that although the Wi-Fi alliance
    has gone to great lengths to ensure that WPS is standardized across vendors and
    their respective devices, there are some cases where the technology is incompatible
    on two different devices from two different vendors. However, it is important
    to remember that modern devices include not just access points but smart phones,
    tablets and laptops as well as operating systems that support this feature with
    little to no interoperability problems.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a discussion on WPS let's first envision a scenario where we would
    want to use WPS. Imagine a network that is using WPA or WPA2 in a personal configuration,
    not an enterprise configuration. In this situation we would have a key entered
    into the access point that we in turn share with any of the clients that wish
    to connect to that access point so they can authenticate and encrypt their traffic.
    As we discussed in the previous recipes, if you want to use this setup or you
    have it in place in your environment it simply means that the key that you entered
    on the access point will now have to go to each client manually, at which point
    they will be able to connect to the wireless network and go about their business.
    This is the scenario that WPS is trying to address. The WPS technology is trying
    to simplify this process so that with a simple push of a button, the key can be
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Something to remember with WPS is that it does not work with deprecated technologies
    and only works with WPA or its successor. Specifically, this means that WPS will
    not work with WEP in any way, shape, or form and thus if your router does not
    support anything newer then WEP it will not have this feature. It is also possible
    that if your router does support WPA or its successor that it may not support
    WPS either if it came out around the time frame that WPS was just being introduced.
    It is possible that some of these routers may still be in existence or be present
    in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this setup, a user trying to share out the key would need to perform a few
    tasks to get to the point where they could enter the key. First of all, they would
    go to the access point and enter in the key within the guidelines or rules required
    by the protocol that they have selected. Then they would go to each device and
    open up their wireless client and select the wireless network that they wish to
    attach to; in this case, the one that they configured with the key. Once they
    picked the network by clicking on it there would be a request sent out by the
    client to connect to the wireless network, and in turn the wireless network would
    issue a challenge and the user would be prompted for the key, which they would
    then put in. The problems for those that are not technically savvy or a little
    bit uncomfortable to process are many. One of the biggest issues is that they
    can put the wrong key in and have to go through the process again and undoubtedly,
    they would check the access point to ensure that they actually got the correct
    key, and it would lead to frustration and a lengthy configuration process for
    some.
  prefs: []
  type: TYPE_NORMAL
- en: WPS works in a number of different ways according to the specification that
    has been put forth by the Wi-Fi alliance. Let's take a look at some of the methods
    that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way we can use WPS is to simply press the WPS button on your router
    which turns on the discovery of new devices. At this point you will go to your
    device and then select the network that you wish to connect to from your wireless
    client. At this point the device will automatically connect to the wireless network
    without entering the password or key. The following photograph shows the WPS button
    on a router:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/31826a88-5b6f-4742-9847-536e342a776d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: WPS button on a router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is when you have wireless devices such as printers or range
    extenders that have their own WPS button that will be used when quick connections
    need to be made to these items. When you need to connect these devices to the
    wireless network, what you will do is press the WPS button on the router and then
    on each of the devices that you wish to connect to the wireless network. During
    this process you will not have to put in any data or anything else, as the devices
    will take care of the handshake and perform a communication of information on
    their own. Once the process has completed you will not have to concern yourself
    with using WPS again unless you change a password or reconfigure the network in
    some manner, as the devices will remember the WPS credentials on their own. The
    following image shows a range extender with a WPS button on the front:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ec4f9871-b198-4916-8680-1087eb66e118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wi-Fi range extender with WPS
  prefs: []
  type: TYPE_NORMAL
- en: Yet another method of using WPS is through the use of an eight-digit PIN code.
    Any router that has or makes use of WPS will have a PIN code that will be automatically
    generated and not changeable by users. This PIN is usually on the configuration
    page of the manual or on the router itself, and should be noted. In some cases,
    devices that are WPS button that still have WPS support will ask for the PIN,
    so it is important to record this piece of information. In these cases, when you
    try to attempt a connection to the wireless network you will be prompted for the
    code, and when you enter it the devices will key themselves to the wireless network
    itself and then perform the process of exchanging the proper key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is one last method that can be used, which also uses an eight-digit
    PIN to authenticate clients during the WPS configuration process. On devices that
    do not have a WPS button that do happen to have WPS support, a specific client
    PIN code will be generated. In these situations, you will take this PIN and enter
    into the router's wireless configuration options. The router will use it to recognize
    the device that's being added and then add it to the network and exchange the
    key as before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of performance the first two methods on this list are very rapid and
    are the most attractive and more likely to be preferred by consumers who are not
    savvy about working with technology. The last two methods are the slowest, with
    the last option being the slowest of all four options that are available because
    it requires logging in to the router and doing some configuration on that before
    any of the processes working in the device will be authenticated. It's also worth
    noting that nothing requires a vendor to implement WPS in their technology to
    implement all four methods. They can choose to enable just a single one of these
    methods if they so wish.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a footnote to this discussion, it is possible that you may run into
    another way of synchronizing or sharing the WPS pin codes with clients from the
    router. This method uses NFC or Near Field Communication. In this situation, a
    client wishing to connect to the wireless network will take their tablet or smart
    phone and waved over a spot on the router which will in turn read the code into
    the device and allow it to sync with the network. The method in use is similar
    to the same type of technique you would use if you happen to be a consumer that
    makes use of technologies such as Apple Pay or Android Pay, where you simply wave
    your device over a terminal at a cash register and payment is made.
  prefs: []
  type: TYPE_NORMAL
- en: Just about all modern routers support WPS, as this item is the central component
    of the vast majority of wireless networks, especially in the consumer space such
    as homes or small businesses. Since these form the core component, it makes sense
    that this device would be essential in supporting this network security standard.
    On many routers you'll even find that the WPS technology is enabled by default
    and is ready to be used as soon as the router is powered up and made part of a
    network. There are some situations where you must manually enable WPS by going
    directly into the wireless router and using options in the interface to turn this
    feature on, but in most cases you will have to manually turn the feature off because
    it is usually on by default.
  prefs: []
  type: TYPE_NORMAL
- en: A little footnote on the support of WPS in routers is that many routers not
    only have WPS support enabled but it is incredibly difficult if not impossible
    to shut off. In some routers you may have to disable other features available
    on the router in order to just be able to disable WPS itself. For example, on
    some wireless access points you may have to disable the main wireless network
    and instead go with the guest network as your primary network. In other wireless
    networks the access point will allow for WPS to be enabled if you do things such
    as shutting off the broadcast of the SSID of the network. However in this latter
    case this may not be something that you want to do. Always look to your access
    point to see how to disable WPS if you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: As far as WPS support within operating systems goes, there is almost universal
    support and inclusion of the feature. In the case of Microsoft, Windows WPS is
    up and supported in every operating system release since 2007 which essentially
    boils down to everything from Windows Vista and later. On the Android side there
    has been full support for WPS since 2011 with version 4 of Android, Ice Cream
    Sandwich. Every version of Android since that version fully supports WPS. Support
    in operating systems such as Linux is nearly universal with some versions of the
    operating system not supporting it as it has been removed or disabled by the developers
    of the distribution, but overall support is present in the operating system in
    most cases. That leaves us with the Apple family of operating systems, on both
    their computers as well as anything using iOS, where in this case we have no native
    support for WPS; it is only available through add-ons or other enhancements from
    third parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the WPS dialog in Windows 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1032813c-b09e-4a4d-8418-2b1b073dd9f2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: WPS dialog in Windows 7
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we know what WPS is, let''s discuss what its problems are, before
    we go into the specific recipe designed to defeat the technology. There are a
    number of problems that exist with the WPS standard, and we''re to take a look
    at these things to see what they actually mean to us as someone evaluating this
    technology:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest problems with WPS is that if someone gets physical access
    to the router they can simply turn the router over and take a picture; in a lot
    of cases, the label on the router will have a code that allows an override of
    the WPA2 password. The following diagram shows a router with the code on its label:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f85f0f61-b977-4230-b215-2a5291f7d043.png)'
  prefs: []
  type: TYPE_IMG
- en: label including PIN code
  prefs: []
  type: TYPE_NORMAL
- en: In many routers the use of the WPS protocol cannot be disabled easily, if at
    all, which means that if you are not going to make use of it in the future you
    cannot take basic security measures to shut it off if you're not using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another big problem is the way WPS is implemented, due to the fact that the
    protocol it exchanges a PIN code which is eight characters long, and the way it
    is stored presents some problems. Without getting into all the particulars, essentially
    this eight-digit PIN is broken into two four-digit blocks that are exchanged between
    the client and the access point. Due to the way this code is checked between the
    client and the access point there is not a strong system for validating this code.
    Due to the way this code is broken into two blocks and how this process behaves
    afterwards it becomes easy for an attacker to use software to guess the correct
    PIN code. In fact just to make things easy and to step away for the mathematics
    of the whole process, because of the way the PIN code is validated we find that
    it is possible for someone to get the correct code by only making 5,500 guesses,
    which is easy for modern computers to do. In Kali, we find that we have software
    that allows us to make 11,000 guesses very quickly and efficiently with little
    effort on our side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are someone who's running the math on this and trying to figure out how
    many possible PIN code combinations there are, you may have come to a much larger
    number than the one stated here in this text. In fact, if you consider the fact
    that a PIN code only allows the numbers zero through nine to be used in every
    one of the eight slots in the PIN code you could do the math and come up with
    around 100 million possible code combinations. However, this is just not the case.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we don't even have eight digits for the PIN code, as the last
    digit is used as a checksum or way to verify that the code has been transmitted
    correctly and there are no flaws. So that leaves us with seven digits. However,
    the problem here is that though seven digits are not evaluated as one contiguous
    number; it is in fact broken into two pieces. The Wi-Fi enabled device will send
    the router for the first four digits, which will get validated, and then it will
    send the last three separately for validation. If we do the math at this level
    we find that with four digits we have 10,000 different combinations and with three
    digits we have 1,000 different combinations; if we add these two together we have
    11,000 possible combinations of codes. If we do the math little bit more and use
    a little logic, we find that more likely an attacker probably would have to guess
    about half the codes before they get something that successfully solves the problem.
    This is where we get the aforementioned 5,500 guesses. However, if we wanted to
    it and do an exhaustive brute force search of all the possible codes, this would
    be 11,000 different combinations which still is not any sort of monumental task
    that can't be overcome by any modern computer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are the basic requirements and you could easily use more
    (or different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we're going to do in this particular recipe is go through a few steps on
    how to break a WPA that happens be using a weak passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we start our attack against WPS is to use a familiar command, `airmon-ng`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again we are putting our card into monitor mode to detect wireless networks
    in the area. We could follow this command up with `airodump-ng`, like we did with
    WEP and WPA/WPA2, but we will instead switch over to using the `reaver` suite
    and use it''s built-in commands. In this case we will issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is designed to hunt for networks that use WPA specifically. When
    you run the command, you will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b847af2-7138-434f-947b-47652ed02795.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of wash command
  prefs: []
  type: TYPE_NORMAL
- en: The results should find networks in the area. The networks displayed will include
    everything in the immediate area. Of these networks there may be some that are
    vulnerable. In the results you will notice a WPS locked column; this is far from
    a definitive indicator, but in general, you'll find that APs which are listed
    as unlocked are much more likely to be susceptible to the brute force that we
    are attempting here. You can still attempt to launch an attack against a network
    which is WPS locked, but the chances of success are diminished dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've found a network you wish to run the attack against, operating `reaver`
    is very straightforward. The basic command needs only the local interface, channel,
    and ESSID to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the command to launch `reaver` against the mordred network would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only part of the above command that might not be immediately obvious is
    `-vv`; this enables verbose output which greatly helps when trying to gauge how
    well `reaver` is functioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve started `reaver`, you''ll start seeing output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38cf3d81-d910-419d-8834-22aaeda34d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: This output shows that WPS pins are successfully being tried against the target
    (here we see `12345670` and `00005678` are being tested), and `reaver` is operating
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: This process may take a lengthy period of time, but you will see feedback telling
    you that the attack is in progress and functioning. What may slow down the attack
    is the fact that many vendors have been trying to implement protections against
    WPS attacks, and additional options may be required to get the attack moving.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, `reaver` keeps a progress log file automatically, so you can stop the
    attack at any time and resume whenever it's convenient. Spending a few hours a
    day running `reaver` against the same network should uncover its PIN, and through
    that the WPA passphrase.
  prefs: []
  type: TYPE_NORMAL
