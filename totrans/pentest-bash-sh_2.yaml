- en: Chapter 2. Customizing Your Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every aspect of your bash terminal is customizable. Now that you've learned
    to make use of some of the important information processing utilities, we can
    move on to learning how to use them to customize your shell. A lot of what we
    will cover in this chapter involves grabbing information from one program, piping
    it into another program, and filtering out whatever details are important to us.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn something about bash scripting, which is what a large chunks
    of the applications in your Kali Linux—and the larger Linux family—are made of.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the terminal output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything printed on your bash terminal is done by the cursor, which is just
    another component of your bash terminal you can control using very convenient
    shorthands. This section will cover how to control the color and basic formatting
    of the output printed on your terminal and you will also see some very cool tips
    and tricks in action later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, let's talk about control sequences. Control sequences are character
    patterns that introduce special behavior for text being displayed on your terminal.
    These special characters always precede the output they format. Control sequences
    are often delimited by escape characters, and the one we are interested in is
    denoted by `\e`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this control sequence, we can do pretty cool things; observe the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of the previous command in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another example would be the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of the previous command in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How does this work? Well we need to discuss some of the basic text formatting
    control sequences. These control the style of the text, which includes properties
    such as emboldening text, underlining, and inverting the terminal printing. The
    control sequences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**0m**: This will remove all formatting and print normal text. We will use
    this to reset all the properties of the terminal text. It acts as a control to
    limit the amount of text we would like to affect with whatever formatting precedes
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[1m**: This will embolden any text following it. For instance, consider the
    following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command line would give the following output on your terminal
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**[2m**: This will *dim* the text being printed, following is a demonstration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the output should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**[4m**: This will underline any text following it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[5m**: On some terminals, this will cause the text following it to blink
    on and off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[7m**: This causes the video or colors following it to be inverted. Consider
    the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command line would give the following output on your terminal
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**[8m**: This will hide any text following it, which means the text simply
    won''t be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please don't forget that there control sequences only work if they are preceded
    by the `\e` escape character. Another way to write this escape character is to
    use the octal format \033, which is supported on some older versions of the bash
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful function of these control sequences is that you can reset a
    given attribute. For instance, if you underline and embolden a piece of text,
    and you would like to only remove the underline for a given section of text, you
    can do that as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should print out the following text on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the terminal output](img/5107OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s not hard to figure out how the rest of these resetting escape sequences
    work; if you wish to turn off a given formatting rule, all you need to do is precede
    the control number with a `2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[21m` turns of emboldening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[22m` turns off dimming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[25m` turns off blinking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not done here! You can also control the color of the text being printed
    by using other control sequences. Just like the reset control sequences they work
    by prefixing a given number that controls the kind of color to another number
    that controls the color being selected. Here''s how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3xm` simply changes the text to the color indexed by the number `x`. The
    number `x` can be anyone of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` for black'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` for red'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` for green'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` for yellow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4` for blue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` for magenta'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6` for cyan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7` for light gray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine these with the other formatting options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The prompt string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prompt string is the string that marks or delimits your bash command line.
    The default prompt string for Kali Linux is `root@kali:#`. This string is not
    a static value and can be changed to whatever you'd like it to be. This section
    will cover some very useful modifications you can make to your prompt string.
    We're going to make it display some helpful information about your Linux System.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the value displayed as your prompt string, you need to modify the
    value of the PS1 variable, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The prompt string](img/5107OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So you might be wondering when and how this value is set for your bash terminal.
    Well, as it turns out, the prompt string is set in the `~/.bashrc` file that is
    usually executed as soon as your terminal starts up. Following is the part of
    the `.bashrc` file that mentions the prompt string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://%20http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we can see that the prompt string has three possible
    settings so that your terminal can accommodate color printing, though it needs
    to make sure the actual shell can support it. This is why it first checks if the
    `color_prompt` variable is set affirmatively. Let''s look at the first possible
    `PS1` setting (should color printing be supported) in detail, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `${debian_chroot:+($debian_chroot)}` part of the code uses variable expansion
    to grab details about whether the shell is being executed on a chrooted filesystem
    and displays information to indicate this. It's not completely crucial to understand
    this just yet, because for most cases you probably will never make use of this.
  prefs: []
  type: TYPE_NORMAL
- en: The `\[\033[01;32m\]` part, as discussed in the previous section, causes the
    terminal to print bold green text. The format here is slightly different from
    the examples discussed in the previous section, because escaped brackets are used
    to demarcate the beginning and end of the control sequences. As we've seen in
    previous examples, these are not a hard requirement for later bash shell versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `\u` part is another one of those really useful escape characters. This
    one acts as a shorthand for your username or the username of current user.
  prefs: []
  type: TYPE_NORMAL
- en: The `\h` part this escape character follows the `@` sign in this example—the
    `@` sign is just plain text, nothing special about it. The `\h` escape character
    will print your current hostname in its place when the prompt string is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `\[\033[00m\]` part as discussed in the previous section. This will reset
    all the formatting rules so that everything following it is printed as normal
    text. After resetting the formatting, we see `\[\033[01;34m\]`. This will format
    all the text that precedes it so that it appears emboldened in blue.
  prefs: []
  type: TYPE_NORMAL
- en: The `\w` part is a shorthand for the current working directory. Directly after
    the working directory is a good old line feed that is printed by using the `\n`
    escape character shorthand. Following this is the`\$` escape character, which
    is a shorthand that will print a `$` sign if anything besides the root user is
    currently using the shell and a `#` when the root user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: The bash shell offers a few other useful shorthands to make use of in your prompt
    string, each causing a different piece of information to be printed directly into
    your prompt string. To find out more about these, please see the links provided
    in the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Prompt string customizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how text formatting and the general process of editing your
    prompt string works, let's walk through some useful customizations.
  prefs: []
  type: TYPE_NORMAL
- en: You should see your prompt string as something that should supply you with general
    information that you will find useful most of the time. To get you going with
    your own prompt string modifications, we will discuss how to display some of this
    information neatly in your terminal prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add bits of information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The current working directory by using the `\w` escape character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current date time by using the date command and a little command substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of jobs running in the background by using the `\j` escape character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The privilege level of the current user by using the `\$` escape character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return code of the previous command by using the `\$?` escape characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is what the prompt string looks like once these details have been
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look closely enough, you should see all the escape characters we''ve
    mentioned being used in the prompt string. If all goes well and you manage to
    set your prompt string exactly as in the example, you should see the following
    code appear on your terminal screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prompt string customizations](img/5107OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the `\$?` escape character in action.
    The user visits a directory that doesn't exist and the return code is set to `1`,
    indicating that the previous command exited under an erroneous condition or did
    not succeed.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of excellent modifications you could make. What was demonstrated
    here serve merely as an example (though it is useful in their own right) in an
    effort to get you cracking away at your own modifications. See the *Further reading*
    section for even more powerful and dazzling modifications you can make to your
    prompt string.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aliases are a way of effectively assigning a name to a given collection of
    commands or a single command line. The `.bashrc` file that comes with every standard
    issue bash shell includes a few useful ones by default. A few of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What these do is allow you to use one—usually simpler—command to invoke a number
    of complex commands. So, with respect to the previous code, you can use `grep`
    to invoke `grep –-color=auto`, which enables text output highlighting or color
    printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general purpose or aim of aliases is to make things simpler. So, for instance,
    if you need to SSH into a given host very often and want to avoid entering the
    IP address or domain name of the said host repeatedly, you could add an alias
    to your `.bashrc` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example would be if you practice password cracking with John The Ripper
    and you''d like to make use of a given cipher and cracking mode very often; you
    could add these aliases to make invoking `john` in the desired way a less tedious
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can also use them if you''d like to use specific word lists,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should immediately see the benefit of relying on `alias` to simplify fire
    off certain complex commands.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the command history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, during a penetration test or whenever you're using some pretty lengthy
    command lines to accomplish your tasks, you may want to reuse them quite often
    or recall them for future use. Making sure that your terminal records the correct
    details about your commands and—more importantly—records enough of them is an
    important modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other topics discussed, there''s of course a main page dedicated to
    customizing command history behavior. You can reach this man page by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Look for the section that mentions the `HISTORY` variable and those associated
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, like most other components and functions of the bash terminal, you
    have quite a bit of say in how things get done when it comes to command logging.
    These environment variables that control what gets logged and how are discussed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HISTSIZE`: This controls the number of commands that are initialized to the
    history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTFILE`: This specifies which file should be used to initialize the command
    history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTFILEZIE`: This specifies how many commands from `HISTFILE` should be used
    to initialize the command history. If `HISTFILE` is longer than `HISTFILESIZE`
    lines, it will be truncated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTCONTROL`: This determines certain attributes about which commands a logged,
    for instance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If set to `ignorespace` it will ignore (and not record to the history) all
    the commands that start with a space, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If set to `ignoredups`, bash will not record any command that has the same invocation
    as the preceding command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If set to `erasedups`, bash will completely erase any duplicate commands throughout
    the entire history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also combine different options by separating them with colons, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Try adding some settings of you own to the end of your `.bashrc` file to automatically
    apply when you start up your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting sensitive information from leakage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.bash_history` file is where all your commands will be saved. Usually,
    this is located in the root of your home folder; for Kali Linux users, this is
    the `/root` folder. An important thing to remember about this file is that it
    is likely to contain all the commands you've executed on your machine during terminal
    use. This means if you've entered anything sensitive into the command line, such
    as a password, username, or any important and sensitive information, the file
    will contain it.
  prefs: []
  type: TYPE_NORMAL
- en: It's best to make sure that this is information is not duplicated and always
    saved in places relevant to its protection, namely a place that requires the same
    amount of effort or knowledge to compromise or access as the resource it protects.
    For instance, if you need to protect a password for a website, it should be as
    hard or harder for an unauthorized party to access storage that protects the password
    as the actual site it's used for. In the information security profession, we say
    storage is insecure or inadequate if this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure you don''t save any sensitive information to your command line,
    you may want to offload sensitive information to a more secure location and include
    it in your bash environment when necessary. Perform the following steps to do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file for your sensitive environment variables. Here, we will call
    our `sens_env.sh`, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Save it in a safe location and encrypt it if possible. Try using `TrueCrypt`
    for this and see the *Further reading* section for information about using `TrueCrypt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command into this file for each username, password, or
    secure credential you need to save securely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time you need to use the information saved in this file, all you need
    to do is decrypt, unzip, or access it anyway you are required to, and then execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will execute these commands without exposing the sensitive information
    to your `.bash_history` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this information by substituting the information for the variables
    used to reference them, for instance, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This way only the command executed will be saved in the history, and it will
    not contain the actual username, but instead the variable used to refer it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to remember is that if you need to save sensitive information
    in your `.bash_history` file or for any other reason would like to backup or make
    a copy of your `.bash_history` file, you can do so by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The history command allows you to issue commands that affect the history file.
    Here, we are using `–w switch`, which tells it to save a copy of the current contents
    to the file specified by the `[FILENAME]` argument.
  prefs: []
  type: TYPE_NORMAL
- en: That's about it for command history. Please see the *Further reading* section
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing tab completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tab completion is what happens when you type a command and press the *Tab* key
    twice on your keyboard. The list of possible options that shows up is the completion
    suggestion. Believe it or not, you can actually control the commands and even
    the arguments that show up when you use tab completion, depending on which command
    you are executing. Being able to control your tab completion can prove to be quite
    an invaluable skill during your everyday experiences with bash. So, without rambling
    on about it for too long, let's find out how tab completion actually works.
  prefs: []
  type: TYPE_NORMAL
- en: When you press the *Tab* key twice, a special predefined function is executed
    by the bash shell. This function determines which command you are executing (if
    any) and hooks in (this is just jargon for schedules) another defined function
    that is in charge of determining which options to display as suggestions. What
    we will do in this section is actually develop one or two of these functions to
    make use some of the tools on the Kali bash command line a little more user-friendly
    and once again devise another way to put more useful information right at your
    fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of a completion function (this one is for `tcpdump`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to note in the previous example. First of all,
    the `_tcpdump` function being defined is the function that will get called when
    you press *TAB* twice after typing `tcpdump` into your command line. This is because
    of the very last line in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that when completion suggestions for `tcpdump` are to be determined,
    the function—specified by `–F` option—that will be called is `_tcpdump`. The sole
    purpose of a completion function is to fill the `COMPREPLY` environment variable
    with the suggestions needed to complete the command. The `COMPREPLY` variable
    is what is stuck into the command line when you require suggestions. There are
    a number of other very useful environment variables that are designed to help
    you in scripting your completion function. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COMP_LINE`, which is the current command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMP_WORDS`, which is an array holding the individual words currently appearing
    on the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMP_CWORD`, which is the index of the last word entered into the command
    line. This index is used to calculate the current word using the `COMP_WORDS`
    array as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So basically, the game you play when you develop a completion function for a
    given command is to check the last entered word—or for that matter any word entered—to
    determine what exactly to put into the `COMPREPLY` array. Of course, this is simply
    a bash script being executed and anything goes. If you'd like to determine the
    suggestions to display in another way, you can of course do this. For instance,
    you could record all the invocations of the given command to a special file using
    the `history` command, and then suggest the `host common` command executed based
    on the options supplied. If you know a little about natural language processing
    or machine learning, the applications of this simple functionality become endless.
    For instance, think about a bash terminal that learns to suggest the command you
    like best at a given time of day, even according to the music you're listening
    to, or network connections currently active on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important piece of information that you may need to develop your own
    completion functions is where to stick your function when you''re done. Most of
    the completion functions currently installed on your system appear at `/etc/bash_completion.d/`.
    However, if you''re going to develop your own extensions to the completion system,
    you would probably want to put your scripts in a place that is under your control.
    A popular convention is to create a directory called `.bash_completion.d/` in
    the root of your `home` folder, by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All of your own completion scripts should appear in this folder, saved under
    the name corresponding to the command it completes. For instance, the one we will
    develop for John the Ripper—designated `john` on the command line—will be called
    `john`. Also, for your completion functions to take effect, you''d probably want
    to avoid having to execute them yourself before using any of the affected commands.
    So to make this easy and autonomous, you should stick this command in your `.bashrc`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve executed the preceding command, you probably want to unzip the
    `rockyou.txt.gz` wordlist that comes with your Kali Linux install, by using the
    following command-line code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You're now ready to write a completion function for `john`. Here's what it should
    look like
  prefs: []
  type: TYPE_NORMAL
- en: '(the following code will be made available on this book''s website):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first few lines of the function, the script grabs the current word and
    the previous word—the word preceding the current—and stores then in the `cur`
    and `prev` variables respectively. What it does then is step into a case statement,
    which is basically a compounded if statement with many comparisons and many unique
    logical exit points, and compares the word to the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--format`: This is the option John the Ripper uses to specify the cipher format
    being cracked. The script fills the `COMPREPLY` array with all the formats with
    names similar to the current word `$cur`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--wordlist`: This is the option John the Ripper uses to specify the word that
    is to be used, if any. Here, the script simply grabs all the files in the `/usr/share/wordlists`
    directory and uses them as the suggestions to be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What follows is an `if` statement that is used to match any options being typed
    into the command line, which would be anything starting with a hyphen. It then
    fills the `COMPREPLY` array with anything matching the current one closely enough.
  prefs: []
  type: TYPE_NORMAL
- en: Please note this script is only meant for demonstration; it is missing completion
    suggestions for the other command line arguments for `john`. As an exercise, you
    could fill in the rest of John the Ripper's command-line options and possible
    arguments for those functions by adding a few cases to the `switch` statement.
    You can find out more about John the Ripper's arguments from the manual page or
    by executing `man john`.
  prefs: []
  type: TYPE_NORMAL
- en: Another really useful application you could use this for is the Metasploit command-line
    interface. We will be covering this collection of tools in later chapters, and
    you may find it very useful to write a set of tab completion rules for it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered text output formatting and colorizing terminal text.
    We then saw how text formatting can be used to modify the bash prompt string and
    also discussed novel tricks and tips that you can use to display some helpful
    information using your `prompt` string. We then moved onto aliases and discussed
    making some complex and tedious commands a lot simpler by using simple mnemonic
    aliases. Finally, we covered tab completion and learned how to modify it to suit
    our needs. We also discussed an example involving the John the Ripper password
    and hash cracking tool.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you've taken a few useful tips from this chapter and will be able
    to make much needed and productive modifications to your terminal so that you
    can wield it effectively during penetration tests. A good exercise would be to
    look at some of the tools installed on the Kali Linux command line and think about
    ways to make them easier and more efficient to use by whipping out one or two
    of the tricks covered in this chapter. For instance, think about some useful aliases,
    tab completion scripts, and text formatting tricks to use with commands Nmap,
    Wireshark, Aircrack-NG, or Netcat.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on how to use some of the Kali Linux tools to make
    sure your data, especially evidence from penetration tests and sensitive information
    security-related work, is protected at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux documentation project, Tab Expansions, at [http://tldp.org/LDP/abs/html/tabexpansion.html](http://tldp.org/LDP/abs/html/tabexpansion.html)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux documentation project, Aliases, at [http://tldp.org/LDP/abs/html/aliases.html](http://tldp.org/LDP/abs/html/aliases.html)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Openwall – John the ripper Options at [http://www.openwall.com/john/doc/OPTIONS.shtml](http://www.openwall.com/john/doc/OPTIONS.shtml)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu Man Pages, John at [http://manpages.ubuntu.com/manpages/natty/man8/john.8.html](http://manpages.ubuntu.com/manpages/natty/man8/john.8.html)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArchLinux Wiki and Color Bash Prompt at [https://wiki.archlinux.org/index.php/Color_Bash_Prompt](https://wiki.archlinux.org/index.php/Color_Bash_Prompt)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash history facilities at [http://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html](http://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html)
    [accessed 2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TrueCrypt at [http://www.truecrypt.org/](http://www.truecrypt.org/) [accessed
    2014/04/28]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
