- en: '*Chapter 9*: Advanced Uses of Cypress Test Runner'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started on advanced uses of the Test Runner, it is crucial that
    you understand how Cypress works, the role of the Test Runner, and how tests are
    executed in the Test Runner. This chapter builds on the knowledge of Cypress that
    you have acquired in the previous eight chapters and will focus on assisting you
    to understand the advanced functions of the Test Runner that we have not yet explored
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will utilize the Test Runner and learn how to write
    better tests by making use of the built-in functions of the Test Runner. By learning
    how to use the Test Runner, we will have a deeper understanding of how tests run,
    what happens when they are failing, and how they can be improved. We will cover
    the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the instrument panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Selector Playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test Runner keyboard shortcuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will have a full understanding
    of the Test Runner and how to fully utilize it in the process of writing your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we recommend you clone the repository containing the source
    code and all the tests that we will write in this chapter from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how to read and interpret Cypress errors in the Test Runner
    in [*Chapter 5*](B15616_05_Final_NM_ePUB.xhtml#_idTextAnchor119), *Debugging Cypress
    Tests*. In that chapter, we also covered how we can interact with DOM snapshots
    in the Test Runner, where we covered the interaction between elements and the
    command log. In this chapter, we might make references to [*Chapter 5*](B15616_05_Final_NM_ePUB.xhtml#_idTextAnchor119),
    *Debugging Cypress Tests*, or further expound on the information provided in that
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-09` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the instrument panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instrument panel is a special panel in the Cypress Test Runner that is only
    visible when Cypress is providing you with additional information about your tests.
    The appearance of the instrument panel is triggered by specific commands that
    provide more information about the tests. The commands that trigger the instrument
    panel include `cy.stub()`, `cy.intercept()`, and `cy.spy()`. In this section,
    we will explore how we can use the instrument panel to display additional information
    about tests.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve our goal of understanding how the instrument panel works, we will
    have to understand how **intercepts**, **stubs**, and **spies** work, along with
    what specific information is displayed on the instrument panel when stubs, routes,
    and spies are called in Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress uses the `cy.intercept()` command to manage the behavior of HTTP requests
    in the network layer of a test. To understand intercepts, we first need to understand
    how network requests take place in Cypress. Cypress automatically indicates on
    the Test Runner when an **XHR** (**XMLHttpRequest**) request is made from the
    running test. Cypress additionally creates a DOM snapshot of the moment when the
    request was called and when the response was received, which gives us an idea
    of what the DOM was like before and after the request. The following code block
    is an example of a request to get the response to an XHR request from our Todo
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows Cypress' `cy.intercept()` command listening for
    an XHR response that it expects Cypress to make on initialization of the application.
    In the test, we are verifying that the request was indeed made to the application,
    as we are waiting for the route response to have been called before our test completes
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress has the capability to interpret requests, which makes it easy for the
    framework to manage HTTP requests by listening to the HTTP requests that the tests
    are making and knowing the responses that are returned by the request calls.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepts in Cypress, using the `cy.intercept()` command, provide the ability
    to override XHR responses returned by the requests made by Cypress tests during
    execution. Overriding the XHR responses made by our application is what we call
    **stubbing** and we will look at this concept later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress logs all the intercepts information on the instrument panel, and by
    looking at the panel, we can tell the number of matched routes in our tests, whether
    there were any responses that matched our routes, and whether they are stubbed
    or not. The following screenshot illustrates the use of the instrument panel to
    elaborate the information logged by Cypress concerning the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Cypress instrument panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Cypress instrument panel
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* shows the area represented by the instrument panel labeled **Routes**
    and in it, it contains columns of different types of information that the route
    responses have when a test has completed running. The different columns in the
    instrument panel for the routes have different purposes and are significant to
    both the running test and the instrument panel. The following are the different
    columns, each described with its use and significance in Cypress routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method** (**1**): The **Method** column represents the request that the `cy.intercept()`
    command is expecting, and depending on the expected request, it can either be
    **GET**, **POST**, **PUT**, **PATCH**, or even **DELETE**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Url** (**2**): The **Url** column will display the URL expected by our `cy.intercept()`
    command when running the Cypress tests. In this case, we have told Cypress to
    look for any route that ends with `learn.json` and if it encounters it then our
    test should pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubbed** (**3**): The **Stubbed** column will show whether our route has
    been stubbed or not. When a route is stubbed, Cypress will not return the response
    that was received, but the response that we pass to the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alias** (**4**): The **Alias** column shows the aliases that we have given
    our route in Cypress. In [*Chapter 8*](B15616_08_Final_NM_ePUB.xhtml#_idTextAnchor183),
    *Understanding Variables and Aliases in Cypress*, we learned about aliases and
    how they can be useful when we need to access the information of an element, a
    route, or even a request. The alias provided in the **Alias** column is what we
    use to call our route, and this we will do by appending an `@` prefix before the
    alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**#** (**5**): This match column will show the count of the responses that
    matched our route. In our case, the request to our URL was only made once and
    therefore our route was only called once in our tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instrument panel information on the routes is sufficient for you to understand
    if any XHR requests were made to the routes that have already been declared in
    our tests and if the methods and number of request times are consistent with what
    is expected in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stubs in Cypress are used to replace a function, control its behavior, or record
    its usage. Stubs can be used to replace actual methods with synthetic responses
    that we write ourselves. In the following code block, we will just verify that
    we can stub a method called `foo` when our test runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `foo()` method shown in the preceding code block illustrates stubbing in
    action and from the code, we can see that we are expecting Cypress to know that
    our stub was called when the `foo` function is called from the test. The following
    screenshot shows the test executing and the details of the passed tests with the
    type of stub, stub name, and the number of times the stub was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Cypress stubbing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Cypress stubbing
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9.2*, Cypress shows our created stubs in the instrument panel and
    also shows the number of times the stubs were called during the execution of our
    tests. Stubbing comes in handy as we can stub out dependencies or functions that
    we do not necessarily want to test in our scope.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spies behave just like stubs, with the difference that they wrap a method in
    the spy for them to record the calls and the arguments to the function. Spies
    are only used for verification of working elements or methods in Cypress. The
    most common use in tests is to verify that certain calls were made in the test
    and not necessarily for changing the expectations of the calls as in the case
    of stubs. The following screenshot shows the spy of a method where we verify that
    the `foo` method was called inside our `cy.spy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Cypress spying'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Cypress spying
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9.3*, the instrument panel plays a crucial role in showing us calls
    that were made to our `spy` function, what the name of the function is, the aliases
    allocated to our spy method, and the type of our test method.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding the instrument panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how we can utilize the instrument panel to understand
    intercepts, spies, and stubs in Cypress. We also learned how intercepts, spies,
    and stubs actually work and how the information on the instrument panel is useful
    to understand whether our implementation is correct. In the next section, we will
    dive into understanding the Selector Playground in Cypress and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Selector Playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Selector Playground is an interactive feature of the Cypress Test Runner.
    The Selector Playground gives you the ability to determine unique selectors, check
    elements that match a specific selector, and check the elements that match a specific
    text in the Cypress application. In this section, we will look at different strategies
    that Cypress uses to select elements and how from the Test Runner we can identify
    the selectors that we can use in our tests. By the end of this section, you will
    learn how to use Cypress to uniquely select elements using the Selector Playground
    and also how to use the selector strategies that Cypress utilizes to run tests.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting unique elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Selector Playground could be one of the most underutilized features in the
    Cypress Test Runner, but also one of the most useful for anyone who wants to write
    tests that have meaningful selectors. The Selector Playground enables us to identify
    valid selectors and unique selectors for elements in our test application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Selector Playground, Cypress calculates a unique selector for the targeted
    element and determines the selector by evaluating built-in selector strategies
    that are enabled by default in the test framework. The following shows two added
    todo items and an open Cypress Selector Playground showing how we can uniquely
    select any of the todo items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Cypress Selector Playground'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Cypress Selector Playground
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to click the Selector Playground button and once you click
    on it, the Selector Playground menu appears as shown in *Figure 9.4*. In the Selector
    Playground menu, you have the option to change the type of selector to either
    select elements with their selectors using `cy.get()` or using the element text,
    which can be found by toggling the selector to be `cy.contains()`. Inside, either
    the `cy.get()` command or the `cy.contains()` command is the specific element
    or text that we want to get from our application preview. For any element or text
    to qualify to be a unique element selector, the number of matched elements, represented
    by the gray color on the Selector Playground, should be **1** in order to ensure
    that we do not have duplicates of the element or the text. The buttons next to
    the label of the matched elements represent a copy command to copy the selector
    to the clipboard, while the next button is a print button that will print our
    selected or chosen command to the browser's console log.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse button below the Selector Playground is clicked, Cypress automatically
    shows a popup when a user hovers over an element and automatically selects a unique
    selector that can be used to identify the element in our tests. In *Figure 9.4*,
    we can see that once the **New Todo** item is hovered over, Cypress shows the
    unique selector as a tooltip and also populates the `cy.get()` command when the
    element is clicked. When an element is selected on the Selector Playground menu,
    Cypress will return the unique selector on the Selector Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Determination of selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Cypress to determine unique selectors in the Selector Playground, it uses
    a strategy of preference where the selectors selected are based on a series of
    strategies known to Cypress. Cypress has a preference for the following strategies
    when selecting and allocating unique selectors to elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data-cy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-testid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nth-child`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The Selector Playground prefers selector strategies that begin with `data-*`
    in their identification format. In most instances, the selector strategies are
    custom and therefore eliminate the chances of flaky tests due to the use of dynamic
    IDs, class names in an application, or a change of CSS due to content changes.
    With custom `data-*` tags, the selector identifiers do not change and can be persisted
    throughout the life cycle of the application.
  prefs: []
  type: TYPE_NORMAL
- en: When an element can be identified by any of these selector strategies, Cypress
    will then display the unique selector of the element. While these strategies are
    what Cypress prefers, it is possible to alter the configuration and make Cypress
    recognize your selector strategy by adding it to the list of recognizable selector
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Editing selector elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Selector Playground gives users the ability to edit the selectors for the
    selected elements. Having the ability to edit the selector elements is important
    as a more targeted selection and a more refined selector tag can be generated
    in a way that Cypress may not be able to by itself. Cypress automatically recognizes
    the changes made to the Selector Playground and will highlight the Selector Playground
    in blue when there is a match for the edited selector elements, or in red if there
    was no match for the edited selector identifier in the Selector Playground of
    the application preview. *Figure 9.5* and *Figure 9.6* show editing the Selector
    Playground with correct element selectors and also with an incorrect element selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Valid element selector in the Playground'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Valid element selector in the Playground
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9.5*, editing the Selector Playground with an invalid element selector
    shows an error and highlights the Selector Playground in red to show us that no
    element was found using the selector element that we provided. *Figure 9.6*, on
    the other hand, shows editing the Selector Playground element selector is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Invalid element selector in the Playground'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.6_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Invalid element selector in the Playground
  prefs: []
  type: TYPE_NORMAL
- en: As observed in *Figure 9.6*, we are able to select both of our todo items with
    the selector that we edited in the Selector Playground. The blue color shows that
    Cypress found the elements that we are searching for, and did this by showing
    a count of the elements on the right side of the element selector input in the
    Selector Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding the Selector Playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned what the Selector Playground is and how important
    it is when using the Test Runner to run our tests. We learned how we can use the
    Selector Playground to select elements, modify elements, and even select and copy
    unique elements from the application preview of the Cypress Test Runner. We also
    learned how Cypress identifies elements and the selector strategies that are preferred
    when selecting elements. Finally, we learned how we can edit the locators in the
    Selector Playground and how we can identify whether our selectors are valid or
    not. In the next section, we will look at how the keyboard shortcuts work on the
    Test Runner.
  prefs: []
  type: TYPE_NORMAL
- en: Test Runner keyboard shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keyboard shortcuts come in handy especially when we do not want to perform manual
    actions on the browser that involve a series of steps. In this section, we will
    learn how to use three keyboard shortcuts to control the Cypress Test Runner and
    to run our tests effectively. With the Test Runner, we will perform common actions
    more quickly than we would when explicitly triggering the actions with the browser
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the mappings of different keyboard keys and their associated
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*R* – Rerunning the tests of a spec file(s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S* – Stopping the running tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F* – Viewing all tests in the spec window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These keyboard keys will trigger different actions on the Test Runner depending
    on the key presses made by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – Test Runner keyboard shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how Cypress keyboard shortcuts can be used to control
    the common actions of the Test Runner using three keys on the keyboard. We also
    learned that performing actions using the keyboard yields quicker actions than
    when triggering the same actions using the browser actions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the instrument panel, Selector Playground,
    and keyboard shortcuts in the Cypress Test Runner. We explored how the instrument
    panel works with stubs, spies, and routes and explored how routes, stubs, and
    spies work, and what information is shown in the instrument panel. We also looked
    at how the Selector Playground is utilized in Cypress and how we can leverage
    it to identify elements for the application under test, and also to optimize the
    selectors that Cypress uses to uniquely select elements. Finally, we learned what
    Cypress keyboard shortcuts do and what keys are mapped to the actions that are
    available using the browser functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know and understand how different elements in Cypress tie together,
    we can go further to test our knowledge on the topics we have learned through
    our exercises. In the next chapter, we will test our knowledge on navigation,
    network requests, and navigation configuration options for tests.
  prefs: []
  type: TYPE_NORMAL
