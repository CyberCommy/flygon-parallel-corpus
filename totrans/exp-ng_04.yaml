- en: Working with Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss different techniques and strategies for working
    with Angular components:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and configuring components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data and communicating between components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter assumes that the reader has knowledge of JavaScript and TypeScript
    programming fundamentals and web development in general, and is familiar with
    the contents of [Chapter 1](ce100032-6082-4f73-94af-b50a56f63334.xhtml)*,* *Architectural
    Overview and Building a Simple App in Angular*, from this book. All the examples
    from this chapter use TypeScript and can also be found on GitHub, at [https://github.com/popalexandruvasile/mastering-angular2/tree/master/Chapter4](https://github.com/popalexandruvasile/mastering-angular2/tree/master/Chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: A telling sign of a successful open source project is excellent documentation,
    and Angular is no exception to this rule. I strongly recommend reading through
    all the available documentation from [https://angular.io/](https://angular.io/)
    and following the examples available there as well. As a general rule, all the
    examples from this chapter follow the format and conventions from the official
    documentation, and I have used a simplified version of the Angular example seed
    from [https://github.com/angular/quickstart](https://github.com/angular/quickstart)
    as an example. If you want to experiment or play with your own Angular creations,
    you can use the contents of the `Example1` folder from the code for this chapter
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Components 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the building blocks of Angular applications, and any such application
    needs at least one component called the root component to be defined before it
    can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: A basic root component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A component is defined in Angular as a class with specific metadata that associates
    it with an HTML template and a jQuery-like HTML DOM selector:'
  prefs: []
  type: TYPE_NORMAL
- en: The component template can be bound to any properties or functions that belong
    to the component class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component selector (similar to a jQuery selector) can target an element
    tag, attribute, or style class that defines the component insertion point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executed within an Angular application, a component will usually render
    an HTML snippet in a specific page location that can react to user input and display
    dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: The component metadata is expressed as a TypeScript decorator and supports additional
    configuration that will be covered throughout the examples from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`TypeScript` decorators are covered in [Chapter 1](ce100032-6082-4f73-94af-b50a56f63334.xhtml),
    *Architectural Overview and Building a Simple App in Angular*. They are essential
    for understanding how components are configured, and they are currently proposed
    to become part of the JavaScript specification (ECMAScript).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example from this chapter is for a basic component that is also a
    root component (of which any Angular app needs at least one to initialize its
    component tree):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The component template relies on the Bootstrap frontend design framework ([http://getbootstrap.com/](http://getbootstrap.com/))
    for styling, and is bound to the properties of the component class to retrieve
    some of its displayed text. It contains template expressions that interpolate
    data from the properties of the component class, such as `{{title}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root component uses an inline template (the template content resides in
    the same file with its component) and an element selector that will render the
    component template within the `index.html` page, replacing the highlighted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the example in action, you can run the following command line in the
    `Example1` folder from the source code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the rendered component in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1ce556c-854b-418a-9502-1e09dfb8f98b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An Angular application needs at least one root module, and in the `main.ts`
    file, we are bootstrapping this module for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `app.module.ts` module file to define the application root module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A module can import other modules using the `imports` property, and a module
    can have one or more root components defined under the `bootstrap` property. Each
    such root component will initialize its own component tree, which in our example
    consists of only one component. Any component, directive, or pipe needs to be
    added in the `declarations` property before being used in the module.
  prefs: []
  type: TYPE_NORMAL
- en: Defining child components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a root component represents the container for an Angular app, you will
    also need other components that are direct or indirect descendants of a root component.
    When a root component is rendered, it will also render all its children components.
  prefs: []
  type: TYPE_NORMAL
- en: 'These child components can receive data from their parent component and can
    also send data back. Let''s view some of these concepts at play in a more complex
    example that builds on the previous one. Note that, in the `Example1`, we suggested
    that a child component can be inserted within the root component template; one
    such child component is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first highlighted code snippet shows the component selector using a custom
    element attribute rather than a custom element tag. When working with the existing
    CSS styles and HTML markup, more often than not you need to ensure that your Angular
    components integrate naturally with their contextual look and feel. This is where
    attributes or CSS selectors prove to be really useful.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the component class structure looks somewhat similar to the
    one from `Example1`--with the exception of the two new decorators in the second
    highlighted code snippet. The first decorator is `@Input()`, and it should be
    applied to any component property that can receive data from the parent component.
    The second decorator is `@Output()`, and it should be applied to any property
    that can send data to the parent component. Angular 2 defines an `EventEmitter`
    class that facilitates generating and consuming events using a similar approach
    with Node.js `EventEmitter` or jQuery events. The output event of the `string`
    type is generated in the `onClick()` method, and any parent component can subscribe
    to this event to receive data from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: The EventEmitter class extends the RxJS Subject class, which in turn is a special
    type of RxJS Observable that allows multicasting. Further details about observables,
    subscribers, and other reactive programming concepts can be found in [Chapter
    7](8eacfd6f-0cc3-49d5-9c85-f823dad66ad6.xhtml), *Asynchronous Programming Using
    Observables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We took advantage of the `static` class properties in TypeScript to generate
    a unique instance identifier, `instanceId`, that is used in the message sent by
    the child component via the `onChildMessage` output property. We will use this
    message to make it obvious that each child component instance sends a unique message
    to its subscribers, which is the `AppComponent` root component in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows how the root component is referencing and binding
    the `ChildComponent` elements. The `onChildMessage` output property is bound to
    an `AppComponent` method using the same parenthesis notation that Angular 2 uses
    to bind native HTML DOM events; for example, `<button (click)="onClick($event)">`.
  prefs: []
  type: TYPE_NORMAL
- en: The input property is simply assigned to a static value for the first `ChildComponent`
    instance and is bound via the bracket notation to the `AppComponentsecondComponentText`
    property. The bracket notation is not required when we are simply assigning fixed
    values, and it is also used by Angular 2 when binding to native HTML element properties;
    for example, `<input type="text" [value]="myValue">`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not yet familiar with how Angular binds to a native HTML element
    properties and events, you can refer to [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml),
    *Creating Directives and Implementing Change Detection*, for further reference.
  prefs: []
  type: TYPE_NORMAL
- en: For both the `ChildComponent` instances, we used the same `AppComponentonChildMessageReceived`
    method to bind to the `onChildMessage` event using a simple event handling approach
    that will display the last child component message on the application page. The
    root component selector was changed to use an element tag and CSS class selector,
    and this approach leads to a simpler structured `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to modify the `AppModule` definition to ensure that `ChildComponent`
    can be referenced by `AppComponent` and any other component from the same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find this example in the `Example2` folder from the code for this chapter.
    The concepts covered here, such as component properties and events, component
    data flow, and component composition, can go a long way in building a relatively
    complex application, and we will explore them further throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside components, Angular has the concept of directives, which can also
    be found in Angular 1\. Each Angular component is also a directive, and we can
    roughly define a directive as a component without any template. The `@Component`
    decorator interface extends the `@Directive` decorator interface, and we will
    discuss more about directives in [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml),
    *Creating Directives and Implementing Change Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each component rendered by Angular has its own life cycle: it is initialized,
    checked for changes, and destroyed (among other events). Angular provides a `hook`
    method, where we can insert application code to participate in the component life
    cycle. These methods are available through TypeScript function interfaces that
    can be optionally implemented by the component class, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnChanges`: This is called once data-bound component properties get initialized
    before `ngOnInit` and each time data-bound component properties are changed. It
    is also part of the directive life cycle (the convention is that the interface
    implementation function name has the `ng` prefix added to the interface name;
    for example, `ngOnInit` and `OnInit`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnInit`: This is called once after the first `ngOnChanges` and when data-bound
    component properties and input properties are all initialized. It is also part
    of the directive life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngDoCheck`: This is called as part of the Angular change detection process
    and should be used to execute custom change detection logic. It is also part of
    the directive life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentInit`: This is called once after the first call to `ngDoCheck`,
    and when the component template is fully initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentChecked`: This is called once after `ngAfterContentInit` and
    after every `ngDoCheck` call, when the component contents are verified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewInit`: This is called once after the first `ngAfterContentChecked`
    and when all the component views and their children views are initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewChecked`: This is called once after `ngAfterViewInit` and after
    every `ngAfterContentChecked` call, when all the component views and their children
    views are verified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnDestroy`: This is called when the component is about to be destroyed and
    should be used for cleanup operations; for example, unsubscribing from observables
    and detaching from events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will adapt our earlier example to showcase some of these life cycle `hooks`,
    and we will use a parent and a child component that either displays or logs all
    their life cycle events to the console. The events triggered until a component
    is fully loaded are displayed/logged distinctly from the events that occur after
    the initial load, as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2c60a3af-bf42-4fdb-bbba-b934b037a198.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for the parent component is pretty similar to the code for the child
    component, and the child component has a button that sends a message to the parent
    component on demand. When a message is sent, both the `child` component and the
    parent component respond to life cycle events that are generated by the change
    detection mechanism from Angular. You can see the code for the child component
    in the `child.component.ts` file found in the `Example3` folder from the source
    code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All the methods starting with `ng` are component life cycle hooks and when
    triggered, most of them log events that are stored in the component and displayed
    via data binding (see the highlighted code snippets from the previous code listing).
    Two of the life cycle hooks--`ngAfterViewInit` and `ngAfterViewChecked`--log events
    to the console instead of storing them as component data because any change in
    the component state at that point in the component life cycle will generate an
    exception in the Angular application. For example, let''s change the `ngAfterViewInit`
    method body with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the application page browser console, you should see this error
    message after making the change:'
  prefs: []
  type: TYPE_NORMAL
- en: Expression has changed after it was checked.
  prefs: []
  type: TYPE_NORMAL
- en: On the initial run of the example, the `ngDoCheck` and `ngAfterContentChecked`
    methods (and `ngAfterViewChecked` if you look at the browser console output) were
    triggered twice already for each component before any user interaction. Also,
    each time we press the example button, the same three methods get triggered, once
    for each component. In practice, you may rarely use these life cycle hooks apart
    from `ngOnChanges`, `ngOnInit`, and `ngAfterViewInit` unless you are writing more
    advanced components or a library of components. We will revisit these core life
    cycle hooks in [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml), *Creating
    Directives and Implementing Change Detection*, as they are really useful in the
    context of forms and other interactive components.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating and sharing data between components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already used the simplest way to communicate and share data between components:
    the `Input` and `Output` decorators. Properties decorated with the `Input` decorator
    initialize a component by passing through data, and the `Output` decorator can
    be used to assign event listeners that will receive data out of the component.
    This approach can be observed with the components found in the `Example2` folder
    from the source code for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Referencing child components from a parent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can bypass the declarative binding to component properties and events using
    a template reference variable or by injecting the target component into the parent
    component via the `ViewChild` and `ViewChildren` property decorators. In both
    the scenarios, we get a reference to the target component and can assign its properties
    or invoke its methods programmatically. To demonstrate these capabilities in action,
    we will slightly alter the `ChildComponent` class from `Example2` and ensure that
    the `myText` property has a default text set. This can be seen in the highlighted
    code snippet within the `child.component.ts` file found in the `Example4` folder
    from the source code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then change the `app.component.ts` file to include the template reference
    approach for the first child component and the component injection approach for
    the second child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First of all, the two child components from the third highlighted HTML snippet
    don't have any properties or event bindings. The first child component has a `#firstChildComponent`
    attribute, which represents a template reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: Template reference variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A template reference variable can be set in an Angular template against any
    component, directive, or DOM element and will make the reference available to
    the current template. In the first highlighted HTML snippet from the preceding
    example, we have two buttons that are using inline Angular expressions to set
    the `myText` property and bind to the `onChildMessage` event via the `firstChildComponent`
    template reference variable. When running the example, if we click on the Set
    first child component text button and then the Set first child component message
    output button, we will manipulate the first child component directly through the
    template reference variable, as seen in the first highlighted HTML snippet from
    the earlier example. This approach is suitable for initializing and reading component
    properties, but it proves to be cumbersome when we need to bind to component events.
  prefs: []
  type: TYPE_NORMAL
- en: A template reference variable cannot be accessed in a component class; hence,
    the contrived way we have is to bind to the first child component event. However,
    this type of variable will prove very useful when working with forms, and we will
    revisit them in [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml), *Creating
    Directives and Implementing Change Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting child components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the second child component, we used a technique based on injecting components
    via this property declaration from the `app.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewChildren` decorator takes a selector for the `ChildComponent` type
    that will identify and collect all the `ChildComponent` instances from the parent
    component template into a specialized list of the `QueryList` type. This list
    allows iterating through the child component instances, and we can get a reference
    for the second child component using the `QueryList.Last()` call in the `AppComponent.
    setSecondChildComponentProperties()` method. When running the code found in the
    `Example4` folder for the source code for this chapter, the second HTML snippet
    from the previous code listing will spring into action if you click on the Set
    second child component properties button.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting child components is a versatile technique, and we can access the referenced
    components from the parent component code in a more efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using services with components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now evolve `Example2` once again and refactor some of the code that
    was defined at the component level into an Angular service.
  prefs: []
  type: TYPE_NORMAL
- en: A service is a TypeScript class that has a decorator called `Injectable` without
    any parameters that allows the service to be part of the dependency injection
    (DI) mechanism in Angular 2\. DI will ensure that a service instance will be created
    only once per application, and this instance will be injected in any class that
    declares it as a dependency in their constructor declarations. Apart from the
    specific decorator, a service needs to be declared as a provider usually in a
    module definition, but it can also be declared in component, directive, or pipe
    definitions. Before jumping into our example for this section, you can find more
    information about services in [Chapter 12](998d521f-cf30-4688-9763-12878fcd23e9.xhtml),
    *Implementing Angular Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Even if a service does not have other dependencies, it is a good practice to
    ensure that it is decorated with Injectable in case it has dependencies in the
    future and to simplify its usage when used as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will build upon the `Example2` code into a new example
    found in the `Example4` folder from the source code for this chapter. We will
    start by extracting most of the logic for the parent and `child` component into
    a new service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The service stores the description used by the child components in the `componentDescriptions`
    array and provides a message handler through the `sendMessage()` method that also
    stores any processed message in the `AppService.componentMessages` property. The
    child component `onChildMessage` property of the `EventEmitter` type from `Example2`
    is now moved to `AppService.appServiceMessage$`, and it is available to any component
    or service that requires it. The `child` component definition is now greatly simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Child` component messages are now sent via the `AppService`. `sendMessage()`
    method. Also, the only `@Input()` property, called `index`, stores the component
    index used to set the `myText` property via the `AppService.getComponentDescription()`
    method. Apart from the `index` property, the `ChildComponent` class relies solely
    on `AppService` to read and write data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppComponent` class now has very little logic and although it displays
    all the messages provided by the `AppService` instance, it also registers a custom
    subscription in the `ngOnInit` method that stores the last received message. The
    `AppService.appServiceMessage$` property of the `EventEmitter` type provides a
    public subscription for any other Angular classes interested in consuming this
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we started with a `ChildComponent` class that relied on the
    `@Input()` properties to get the data it needs; we switched to a class that needs
    just a key value to get its data from a service class. The two styles of writing
    components don't exclude each other, and using a service provides further support
    for writing modular components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first looked at a basic component example and then we explored
    parent and child components. An exposure to the component's life cycle was followed
    by examples of how to communicate and share data between components.
  prefs: []
  type: TYPE_NORMAL
