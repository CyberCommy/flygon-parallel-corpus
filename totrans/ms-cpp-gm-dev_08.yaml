- en: Advanced Gameplay Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games are more than just simple mechanics and underlying engines. They are made
    up of complex gameplay systems that allow us to interact with the game world,
    making us feel included and immersed. These systems often take large amounts of
    time and developer expertise to implement. In this chapter, we will look at a
    couple of these advanced gameplay systems and how we can give ourselves a layer
    of help when implementing them in our own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a scripting language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a dialog system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting quests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a scripting language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, implementing an advanced gameplay system can often
    take many coding hours and could require the developer to have expertise in that
    specific system. We can, however, make this a little easier on ourselves and others
    working on the project by including support for a scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: Why a scripting language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be wondering why we are spending time talking about scripting languages
    when this is a book about C++ after all. Why incorporate a scripting language?
    Couldn't we just build the whole engine and game in C++? Yes, we could! However,
    once you start to work on larger and larger projects, you will quickly notice
    the amount of time lost to compiling and re-compiling every time you need to make
    a change. While there are some ways to get around this, like breaking the game
    and engine into smaller modules and loading them dynamically, or using a JSON
    or XML descriptive file system, techniques like these cannot provide all the benefits
    of implementing a scripting system.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the benefits of adding a scripting language to your game engine?
    Well, first, most scripting languages you will use are interpreted languages,
    meaning unlike C++, you do not have to compile the code. Instead, your code is
    loaded and executed at runtime. The big advantage to this is you can make changes
    to a script file and quickly see the results without having to recompile the entire
    game. In fact, you could reload the script on the fly while the game is running
    and see the changes immediately. Another possible benefit of using a scripting
    language is the perceived ease of use when compared to a language like C++. Most
    scripting languages are dynamically typed, with a simplified syntax and structure.
    This can open up opportunities for the creative side of the team, such as artists
    and designers, to be able to make small changes to the project without the need
    to understand the complexity of a language like C++. Imagine a GUI designer being
    able to create, place, and modify GUI elements without the need to know how the
    IGUI framework is implemented. Adding scripting support also opens up a path to
    the community content support—think maps, levels, and items all designed by the
    players of the game. This is becoming a huge selling point for new games and provides
    some possible longevity to your title. On the topic of longevity, the implementation
    of DLC can be done through scripts. This allows for quicker development turnaround
    and can be dropped into the game without the need for a hefty patch.
  prefs: []
  type: TYPE_NORMAL
- en: Those are some of the benefits of using a scripting language, but they are not
    always the best solution in every situation. Scripting languages are notorious
    for running slower than native code, and as we know, performance matters when
    building games. So, when should you use a script instead of using C++? We will
    take a closer look at some system examples, but as a simple rule to follow, you
    should always use C++ for anything that can be considered CPU intensive. Program
    flow and other high-level logic are great candidates for a script. Let's take
    a look at where scripts can be used in our game engine components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the physics components. Of course, when we think of physics,
    we immediately think of heavy CPU usage. For the most part, this is true. The
    heart of the physics system should be constructed in C++, but there are opportunities
    to introduce scripting into this system as well. Take, for instance, the concept
    of physics materials. We can define the materials' properties in a script—things
    like mass, friction, viscosity, and so on. We can even modify these values from
    inside the script itself. Another potential use of scripts in the physics system
    would be defining the response to collisions. We could handle the generation of
    sounds, special effects, and other events, all from within the script.
  prefs: []
  type: TYPE_NORMAL
- en: How about the AI system? This is arguably one of the most common uses for a
    scripting language in game engines, and one we will look at deeper in the next
    chapter. A lot of the components of the AI system can be moved into scripts. These
    include things like complex behavior definitions, the specification of AI objectives,
    inter-AI communication, the definition of AI personalities and traits, plus much
    more. While the list is large, you should note that the examples given are not
    CPU intensive, and again the complex components of the AI system such as pathfinding,
    fuzzy logic, and other intensive algorithms should be handled in C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: You can even add scripting to systems seemingly CPU and GPU heavy, such as the
    graphics engine. Scripts can handle the setting of lighting parameters, adjust
    effects like fog, and even add and remove gameplay elements from the screen. As
    you can see, there is very little in the engine that cannot be supplemented with
    some form of script abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: So, what scripting language should you use? There are a lot of options out there,
    from game-specific languages such as GameMonkey (which appears to be defunct at
    the time of writing this book), to more general languages such as Python and JavaScript.
    The choice really depends on your specific needs. While languages like Python
    and JavaScript have some amazing features, they add more complexity to learning
    and execution to get those features. For our example in this book, we are going
    to use a language called Lua. Lua has been around for many years, and while its
    popularity has seen a decline in recent years, it has a very strong track record
    in the game development industry. In the next part of this chapter, we will get
    to know Lua a little better, and see how we can incorporate it into our existing
    engine systems.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LUA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua, pronounced LOO-ah, is a lightweight, embeddable scripting language. It
    supports modern programming methodologies such as object-oriented, data-driven,
    functional, and procedural programming. Lua is a portable language that is able
    to be built on almost every system that provides a standard C compiler. Lua runs
    on all flavors of Unix, Windows, and Mac. Lua can even be found on mobile devices
    running Android, iOS, Windows Phone, and Symbian. This makes it a great fit for
    most gaming titles and is one of the main reasons that companies including Blizzard
    Entertainment have used it for titles such as World of Warcraft. Lua is also free,
    is distributed under an MIT permissions license, and may be used for any commercial
    purpose with no cost incurred.
  prefs: []
  type: TYPE_NORMAL
- en: Lua is also a simple but powerful language. In Lua, there's just a single data
    structure referred to as a **table**. This table data structure can be used like
    a simple array, a key-value dictionary, and we can even implement a form of OOP
    by using tables as prototypes. This is very similar to doing OPP in other languages
    such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: While we won't go through the language in full detail, there are some great
    resources available for that, including the Lua documentation website. What we
    will do is skim over some of the key language concepts that we will see in action
    throughout the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with variables and simple program flow. In Lua, all numbers are
    doubles. You assign a number with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the lack of a type identifier and a semicolon to denote the statement
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings in Lua can be defined in a few ways. You can define them with single
    quotes, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For a string that spans multiple lines, you can use double square brackets
    to denote the start and end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lua is a garbage collected language. You can remove a definition by setting
    the object to `nil`, the equivalent to *NULL* in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Statement blocks in Lua are denoted with language keywords such as `do` and
    `end`. A `while` loop block would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may notice we used number `+ 1` here, as there are no increment and decrement
    operators (`++`, `--`) in the Lua language.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `if` condition code block would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in Lua are constructed in a similar fashion, using end to denote
    the completion of the functions code statement block. A simple function to calculate
    Fibonacci numbers would look similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, tables are the only compound data structure in the Lua language.
    They are considered associative array objects, very similar to JavaScript objects.
    Tables are hash lookup dictionaries that can also be treated as lists. Using a
    table as a map/dictionary would look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the JavaScript-like dot notation when working with tables.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This removes `key2` from the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This adds a new key/value pair to the table.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our very quick look at Lua language specifics; you will have
    the chance to learn more as we build out our examples. If you want to know more
    about Lua, I would again recommend reading through the documentation on the official
    website [http://www.lua.org/manual/5.3/](http://www.lua.org/manual/5.3/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the process of including Lua language support
    in our example game engine project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing LUA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for us to use Lua in our example engine, we need to take a few steps.
    First, we will need to obtain the Lua interpreter as a library that we can then
    include in our project. Next, we will have to obtain, or build our own, helper
    bridge to make the interaction between our C++ code and the Lua scripts easier.
    Finally, we will have to *expose* or *bind* functions, variables, and other objects
    that we wish to have access to our Lua scripts. While these steps might be slightly
    different for each implementation, this will provide us with a good starting point
    for our next examples.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we will need a copy of Lua as a library that we can use in our
    engine. For our examples, we are going to use Lua 5.3.4, which at the time of
    writing is the latest version of the language. I have opted to use a dynamic library
    in the examples. You can download both the dynamic and static version of the library,
    as well as the necessary include files, at the precompiled binaries page on the
    Lua project site ([http://luabinaries.sourceforge.net/](http://luabinaries.sourceforge.net/)).
    Once you have the precompiled library downloaded, extract it and then include
    the necessary files in our project. I am not going to go through the process of
    including a library in our project again. If you do need a refresher, flip back
    to [Chapter 2](190c5e44-8ae4-4747-8ff6-9540fabb79eb.xhtml), *Understanding Libraries*,
    where we walked through the steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: As with other examples we have seen throughout the book, it is sometimes important
    to create helper classes and functions to allow easier interop between various
    libraries and components. This is again the case when we are working with Lua.
    To make the interaction easier for us as developers, we need to create a bridge
    class and functions to provide the functionality we need. We could build this
    bridge using the interface provided by Lua itself, which has great documentation,
    but there is also the option of using one of the numerous libraries available,
    which were created for this purpose. For the examples in this chapter and throughout
    the rest of the book, I have chosen to use the `sol2` library ([https://github.com/ThePhD/sol2](https://github.com/ThePhD/sol2)
    ), as this library is lightweight (a header only library), fast, and provides
    all the features we will need for our examples. Having this library in place will
    abstract a lot of the maintenance of the bridge and allow us to focus on implementation.
    To use the library in our project, all we have to do is copy the single header
    implementation into our `include` folder, and it will be ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Lua engine and the `sol2` bridge library in place, we can
    move on to the last step, the implementation of the scripts. As mentioned, in
    order for us to use the underlying game engine components, they have to be exposed
    to Lua first. This is where the `sol2` library fits in. To demonstrate how this
    can be accomplished in our example engine, I have created a little project called
    `Bind_Example`. You can find the full source code in the `Chapter08` folder in
    the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s first look at the Lua script itself. In this case, I
    have called mine `BindExample.lua`, and have placed it in the `Scripts` folder
    of my example projects parent directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our Lua script is quite basic. We have a table named `player`
    with two elements. An element with the key `name` and the value `Bob`, and an
    element with the key `isSpawned` and a value of `false`. Next, we have a simple
    Lua function named `fib`. This function will calculate all the numbers in the
    Fibonacci sequence up to the number passed in. I thought it would be fun to sneak
    a little math in for this example. I should note that this calculation can become
    quite processor intense the higher the sequence, so if you want it to process
    quickly, don't pass in a number larger than, say, 20.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us some quick example Lua code to work with. Now we need to connect
    our program and its logic to this newly created script. For this example, we will
    add this connection code to our `GameplayScreen` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out by adding the necessary include for the `sol2` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the Lua state. A `state` in Lua can be considered analogous
    to an operation environment for your code. Think of it as a virtual machine. This
    `state` is where your code will be executed, and it is through this `state` that
    you will have access to the code running within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open a few helper libraries that we will need for our Lua code interaction.
    These libraries can be thought of as the equivalent of `#include` in C++. The
    Lua philosophy is to keep the core small, and to offer more functionality through
    these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have opened the libraries, we can then move on to loading the actual
    Lua script file. We do this by calling the `script_file` method of the Lua `state`
    we created previously. This method takes one parameter: the location of the file
    as a string. When this method is executed, the file will be loaded and executed
    automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the script now loaded, we can begin to interact with it. First, let''s
    look at how we can pull data out of a variable (table) in Lua and use it in our
    C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The process of retrieving data from the Lua script is quite simple. In this
    case, we are creating a string called `stringFromLua` and assigning it the value
    stored in the Lua table players' `name` element. The syntax looks similar to calling
    an array element, but here we are specifying the element with a string. If we
    wanted the `isSpawned` element values, we would use `lua["player"]["isSpawned"]`,
    which in our case would currently return a Boolean value of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a Lua function is just as easy and quite similar to retrieving values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we are creating a variable of the type double, called `numberFromLua`,
    and assigning it the value of the return from the Lua function `fib`. Here, we
    specify the function name as a string, `fib`, and we then specify any parameters
    needed by that function. In this example, we are passing in the value of 20 to
    calculate the Fibonacci sequence up to the twentieth number.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `Bind_Example` project, you will see the following output in
    the engine''s command window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c1eeb50-54c3-410b-bb35-75080880eaef.png)'
  prefs: []
  type: TYPE_IMG
- en: While this covers the basics of the interaction between our C++ code and the
    Lua scripting system, there is a lot more to be discovered. In the next few sections,
    we will look at ways to utilize this scripting structure to augment various advanced
    gameplay systems and provide us with a flexible way to expand our gaming projects.
  prefs: []
  type: TYPE_NORMAL
- en: Building a dialog system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common forms of interacting with the game world is through some
    form of dialog. Being able to communicate with `NPC` classes, getting information
    and quests, and of course, driving the story narrative through dialog is a must
    in most modern game titles. While you could easily hardcode interactions, this
    approach would leave us with very little flexibility. Each time we wanted to make
    a slight change to any dialog or interaction, we would have to open up the source
    code, dig through the project, make any necessary changes, and then recompile
    to see the effects. Obviously, this is a tedious process. Just think about how
    many games you have played where spelling, grammar, or other errors appeared.
    The good news is there is another approach we can take. Using a scripting language,
    such as Lua, we can drive our interactions in a dynamic way, which will allow
    us to make quick changes without the need for the tedious process described previously.
    In this section, we will look at the detailed process of building a dialog system
    that, at a high-level description, will load a script, attach it to an `NPC`,
    present dialog with choices to the player, and, finally, drive a dialog tree based
    on the returned player input.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the C++ infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start, we will need to build the infrastructure in our example engine to
    support the scripting of the dialog system. There are quite literally thousands
    of different ways that you could approach this implementation. For our example,
    I am going to do my best to keep it simple. We are going to use some of the techniques
    and patterns we have learned throughout the previous chapters, including the state
    and update patterns, as well as the GUI system we built to handle interactions
    and display.
  prefs: []
  type: TYPE_NORMAL
- en: 'They say a picture is worth a thousand words, so to give you a general idea
    of how this system is going to be connected, let''s take a look at a code map
    diagram that depicts the connections between all the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c014d784-590f-4a51-aba9-60a48686ceb6.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a bit going on here, so we will break it down class by class. To begin,
    let's look at the `DialogGUI` class. This class builds off of the IGUI example
    we built in a previous chapter. Since we have already gone through the design
    of the IGUI class in depth, we will only cover the specific aspects we are adding
    to provide the functionality we need for our dialog system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need a few variables to hold the dialog and any choices that
    we want to provide the player with. In `DialogGUI.h`, we have the following: the
    vector of `IGUILabel` objects for the choices and a single `IGUILabel` for the
    dialog. For the implementation of the `IGUILabel` class, take a look at its source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to add a few new functions to provide us with the needed
    interaction for our GUI and the data being provided from the scripts. To do this,
    we will add three methods to our `DialogGUI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetDialog` function, as its name suggests, will handle the setting of
    the dialog text for each of the interaction screens. The function takes only one
    parameter, the text we want to place on the GUI for this interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the function body, we are assigning the `m_dialog` label variable to a new
    instance of an `IGUILabel` object. The constructor should look similar to the
    `IGUIButton` seen previously, where the text value is passed in. Finally, we add
    the label to the GUI panel by calling the `AddGUIElement` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SetOption` function, again as its name suggests, sets the text for each
    option on the current interaction screen. This function takes two parameters.
    The first is the text we want to set the `IGUILabel` to, and the second is the
    choice number, which is its number in the list of choice options being presented.
    We use this to see which option has been selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the function body, we are doing a very similar process to the `SetDialog`
    function. The difference here is we are going to be adding the `IGUILabel` instance
    to the choices vector. First, we perform a little trick to increase the size of
    the vector by one, and this will then allow us to assign the new label instance
    to the vector position at the choice number value passed in. Finally, we add the
    `IGUILabel` to the panel with the `AddGUIElement` method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function we add to the `DialogGUI` class is the `RemoveAllPanelElements`,
    which of course will handle removing all the elements we have added to the current
    dialog screen. We are removing the elements so we can reuse the panel and avoid
    recreating the panel each time we change interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveAllGUIElements` function in turn just calls the same method on the
    `m_panel` object. The `IGUIPanel` class'' implementation simply calls the clear
    method on the vector, removing all of its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of the GUI setup for our dialog system, so now we can move on
    to building the `NPC` class which will handle the majority of the script to engine
    bridging.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned previously, we are going to be employing some of the patterns
    we learned in previous examples to help us build our dialog system. To help us
    control when we are constructing the GUI elements and when we are waiting for
    the player to make a choice, we are going to use a finite-state machine coupled
    with an update pattern. To start with, in the `NPC.h` file we have the `enum`
    that will define the states we will use. In this case, we have only two states,
    `Display` and `WaitingForInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we will also need a way to track the states, so we have an `InteractionState`
    variable called `currentState` that we will set to the state we are currently
    in. Later, we will see the completion of this state machine in the `Update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a variable for holding our Lua state, which we saw in the previous
    section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You might recall from the code map diagram shown earlier that our `NPC` will
    have an instance of a `DialogGUI` for handling the displaying of the dialog content
    and interaction with the player, so we will also need a variable to hold it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the implementation of the `NPC` class, we first will look at the
    constructor for the class in the `NPC.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes a single parameter, a reference to the dialog instance
    we will be using for our interaction. We set this reference to the member variable
    `m_gui` for later use. We then handle the loading of the Lua script we will use.
    Finally, we set the current state of our internal state machine to the `Display`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit our code map to see the different connections we need to implement
    for passing the `NPC` class'' loaded script information to the GUI instance we
    have attached to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eae789ce-a9e9-4382-b250-d184582e7da9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we have two methods that are handling the connection. The `Say`
    function is the simplest of the two. Here, the `NPC` class is just calling the
    `SetDialog` method on the attached GUI, passing along a string containing the
    dialog to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PresentOptions` function has slightly more to it. To start, the function
    retrieves a table from the Lua script that denotes the choices for this current
    interaction, and we will see how this is set up in the script shortly. Next, we
    are going to iterate through the table, if it is valid, and simply call the `SetOption`
    method on the attached GUI, passing along the choice text as a string and the
    choice number used for selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of our engine side of the dialog system we need to put in place
    is the `Update` method. This method, as we have seen many times, will drive the
    system forward. By connecting to the existing `Update` event system of the engine,
    our `NPC ` class'' `Update` method will be able to control what is happening with
    our dialog system on each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As with our previous finite-state machine implementation, we are going to use
    a switch case to determine what code should be run based on the current state
    we are in. For this example, our `Display` state is where we are going to call
    our connecting methods `Say` and `PresentOptions`. Here, the `Say` call is passing,
    alone, the text it is pulling from the script file that has been loaded. We will
    see how this works in the script next. If, in this example, we are in the `WaitingForInput`
    state, we are going to iterate through each of the choices we have loaded and
    see if the player has selected any of them yet. If one is found, we are going
    to call back to the script and tell it which choice has been selected. We are
    then going to switch our state to the `Display` state, which will kick off the
    loading of the next dialog screen. Then, we will clear our choices vector in the
    attached `DisplayGUI`, allowing it to be then loaded with the next set of choices,
    and finally calling the `RemoveAllPanelElements` method to clean up our GUI for
    reuse.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Update` method in place, we now have all the framework set up to handle
    the loading, displaying, and input handling needed for our `NPC` interaction scripts.
    Next, we will look at how we can construct one of these scripts to use with our
    engine's newly created dialog system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dialog tree script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dialog or conversation tree can be thought of as the determined flow of an
    interaction. In essence, it works by first providing a statement, then, based
    on a selection of presented responses, the interaction can branch off into different
    paths. A visual representation of how our example dialog flow is determined is
    pictured in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ce1e167-083a-4863-a04d-41230fa52cf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we are beginning the dialog tree with an intro. The user is then presented
    with two choices: **Yes, need help** and **No, leave me alone**. If the user selects
    the **Yes** path, then we move on to the **Express helpfulness** dialog. If the
    user selects **No**, we move to the **Goodbye man** dialog. From the **Express
    helpfulness** dialog, we present three choices: **Okay**, **Start over**, and
    **Weak**. Based on the choice, we then move again to the next stage of the dialog
    tree. **Okay** leads to the **leave nice** dialog. **Weak** leads to the **Goodbye
    man** dialog, and **Start over**, well, starts over. This is a basic example,
    but it demonstrates the overall concept of how dialog trees work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at how we can implement this example tree in our Lua
    scripting engine. The following is the full script, and we will dive into the
    details next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the whole script is not that long. We have a few concepts that
    make this script work. First is a very simple version of a state machine. We have
    a variable called `CurrentDialog`, and this variable will point to the active
    dialog. At the very end of our script we are initially setting this to the `intro`
    dialog object, which will kick off the dialog tree upon the loading of the script.
    The next important concept we have in our script design is the concept of every
    interaction screen being described as a table object. Let''s take a look at the
    intro dialog table as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Each dialog table object has a `Say` element, and this element is the text that
    will be displayed when the `Say` function asks the script for its dialog content.
    Next, we have two optional elements, but that are required if you want to have
    an interaction with the player. The first is a nested table called `choices`,
    which has elements that house the choices that will be presented to the player
    when requested by the dialog system. The second option element is actually a function.
    This function is called when the user selects a choice, and is comprised of some
    `if` statements. These `if` statements will test which choice has been selected,
    and based on that choice, will set the `CurrentDialog` object to the next dialog
    on the path of the dialog tree.
  prefs: []
  type: TYPE_NORMAL
- en: That's really it. The greatest bonus of designing our dialog tree system this
    way is that, with very little guidance, even a non-programmer could design a simple
    script like the one previously shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go ahead and run the `Dialog_Example` project using the `Chapter08`
    solution, you will see this script in action and will be able to interact with
    it. Following are a few screenshots showing what the output would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90b8913b-b9d6-4f62-9c06-f50dcb30720d.png)'
  prefs: []
  type: TYPE_IMG
- en: Although this is a simple system implementation, it is very flexible. It should
    be noted again that these scripts do not need to be recompiled to make changes.
    Try it for yourself. Make some changes to the `NPC.lua` file, rerun the example
    program, and you will see your changes appear.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can take the inclusion of a scripting
    system even further by implementing a quest system driven by Lua scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting quests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very common advanced gameplay system is the quest system. While more
    commonly seen in role-playing games, quests can appear in other genres as well.
    Often, these other genres will disguise a quest system by referring to it as a
    different name. For example, some games have challenges, which in essence are
    really the same as quests.
  prefs: []
  type: TYPE_NORMAL
- en: A quest can be simply thought of as an attempt to achieve a specific outcome.
    Typically, a quest will involve a certain number of steps that must be conducted
    before the quest will be considered complete. Some types of common quests include
    kill quests, where players typically will have to kill a specific number of enemies,
    commonly referred to as **grinding**, and **delivery** quests, where a player
    will have to play the role of courier and often has to travel to new locations
    in the game world to deliver goods. This, of course, is a great way to get the
    player to travel to the next desired location without forcing them. In gathering
    quests, a player will have to collect a certain amount of a specific item. In
    escort quests, often dreaded by players because of historically bad implementations,
    players often have to accompany an `NPC` to a new location while protecting them
    from harm. Lastly, hybrid quests are often a mix of the mentioned types, and are
    more typically longer quests.
  prefs: []
  type: TYPE_NORMAL
- en: Another common part of a quest system is the support for what is referred to
    as a quest chain or quest line. In a quest chain, the completion of each quest
    is a prerequisite for beginning the next quest in the sequence. These quests often
    involve more and more complex quests as the player progresses through the chain.
    These quests are a great way to reveal a plotline gradually.
  prefs: []
  type: TYPE_NORMAL
- en: That explains what quests are. In the next section, we will discuss a few different
    ways we can add support for quests in our game projects. However, before we look
    at the specifics of implementation, it is useful for us to define what we expect
    each quest object to require.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of our simple examples, we will assume that quest objects will
    be comprised of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A quest name**: The name of the quest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objectives**: The actions that must be taken to complete the quest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reward(s)**: What the player will receive for completing the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A little information about the quest, maybe some backstory
    as to why the player is undertaking the task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quest giver**: The `NPC` that gave the quest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these simple elements, we can construct our basic quest system.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in previous gameplay system examples, there are many different
    ways we could approach the implementation of our quest system in the example engine.
    Let's now take a brief look at a few and discuss their merits and pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In engine support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way we could go about supporting a quest system would to be to build it
    into the game engine itself. The entire system would be designed close to the
    engine code and in the native engine language, in our case C++. We would create
    an infrastructure to support the quest using techniques we have seen numerous
    times. Using inheritance, we could expose the basic functions and variables needed
    and let the developer build this construct. A simple, high-level quest class might
    then look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is just meant to be a simple demonstration, and in this case,
    we will skip the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The pros of this implementation approach are that it is writing in native code,
    meaning it will run fast, and it's close to the engine, meaning it will have greater
    access to the underlying systems without the need of interface layers or other
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The cons of this implementation approach include that as it's part of the game
    engine or game code itself, and this means that any changes that are made will
    need to be recompiled. This also makes it harder for non-coders to add their own
    ideas for quests or to handle the expansion of the quest system after release.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach does work, it's more suited to smaller projects where you
    will not have to, or want to, make changes to the quests or system once it is
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Engine/script bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This approach is the same approach we took to implement our `NPC` dialog system
    earlier. In this design, we create an interface class that handles the loading
    of the scripts and the passing of data to and from the quest scripts. Since we
    have seen a similar implementation before, I will skip the example code here and
    instead move on to the pros and cons of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: The pros of this implementation approach include flexibility when compared to
    the engine only implementation. If we want to make any changes, we simply need
    to load up the script in an editor, make the changes, and reload the game. This
    again also makes it far more accessible for non-coders to create their own quests.
  prefs: []
  type: TYPE_NORMAL
- en: The cons of this implementation approach include that it is still partially
    tied to the engine itself. The scripts can only have access to elements and functions
    exposed by the engines interface. If you wanted to add more functionality to a
    quest, you would have to build that into the engine side before any scripts could
    make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is better suited to larger projects, but as noted, still has its
    drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Script-based system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach we can take is to build the entire system within our scripting
    language, with only generic methods exposed from the engine. These generic methods
    would likely be good candidates for template functions. In this approach, the
    quests system internals and quest scripts alike would be written in the scripting
    language. Each quest written in a script would include a reference to the quest
    system script that would handle the management. This approach is very similar
    to the engine only approach; it's just been moved out of the engine and into the
    scripting system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple version of the quest system script. Some pieces
    are omitted for brevity''s sake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, I have omitted a few functions to save space, but the core components
    needed to understand the system are here. First, we have a function that creates
    a new quest, taking in the name, objective, description, and quest giver. We then
    have the accept function that sets the quest to active. Notice how we are using
    the key/pair lookup method to iterate through our tables—we will do this a lot.
    Then we have a function to turn in the quest, and finally a simple function that
    returns all the quest information. The functions not depicted here are for getting
    and setting the various objective values for the quest. For the full implementation,
    take a look at the `Quest_Example` project in the `Chapter08` folder of the code
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the quest system script in place, we have a few options. First, we
    could just add this system to other scripts by using the Lua build in the `require`
    system which would allow us to use the script in other scripts. The syntax for
    this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Or we could simply load the script in our game engine and use an interface,
    like we did in the previous example, and interact with our quest system that way.
    With this flexibility, the choice is up to the developer and situation.
  prefs: []
  type: TYPE_NORMAL
- en: The pros of this implementation approach include great flexibility. In this
    approach, changes not only to the quest but the quest system itself can be modified
    on the fly without the need to rebuild the game or engine. This is often a method
    that is used to include downloadable content (DLC), game modifications (mods),
    and other extra content after a product's release.
  prefs: []
  type: TYPE_NORMAL
- en: The cons of this implementation include, although it is very flexible, the addition
    of an extra layer of complexity. It can also be slower because the system is writing
    in a scripting language that is interpreted, and performance can take a hit. It
    also requires developers to have greater knowledge of the scripting language and
    can require more learning time.
  prefs: []
  type: TYPE_NORMAL
- en: Like the other approaches, this one, too, has its place and time. While I tend
    to lean towards a system like this in larger projects, if the team is not prepared,
    this approach could add more overhead then ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a great deal when it comes to implementing advanced
    gameplay systems. We dove deep into how you can include a scripting language like
    Lua in your game projects. Then we built on that knowledge to examine ways of
    implementing dialog and quest systems into our example engine. While we did discuss
    a lot, we have barely scratched the surface of this topic. In the next chapter,
    we will continue to build on this newfound knowledge to construct some artificial
    intelligence for our games.
  prefs: []
  type: TYPE_NORMAL
