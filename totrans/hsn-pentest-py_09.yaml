- en: Automated Web Application Scanning - Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing our discussion from the previous chapter, we are now going to study
    how to use Python to automatically detect **Cross-site scripting** (**XSS**),
    **Cross-site request forgery** (**CSRF**), clickjacking, and **secure sockets
    layer** (**SSL**) stripping. All the techniques that we are going to discuss in
    this chapter will help us to expedite the web application assessment process.
    I recommend that you should not be confined to the approaches that we are going
    to discuss in this chapter. The approaches discussed can be taken as a baseline,
    and the same ideas can be extended and improved to arrive at better solutions
    or to develop tools that aid the pen testing community. This chapter will discuss
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site request Forgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clickjacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL strip (missing HSTS header)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XSS **attacks belong to the injection category of web application attacks.
    They are mainly caused by not sanitizing the user input that is passed to the
    web application from the end user. This does not lead to the server being compromised,
    but the implications are very serious in terms of the user''s data being compromised.
    Attacks happen when an attacker is able to inject some sort of Java script or
    HTML content into the web page that will be served to the user. This malicious
    content may attempt to steal sensitive information from the user visiting the
    website. In the following sections, we will take a look at different types of
    XSS attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Stored or Type 1 XSS attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stored XSS** are attacks in which the supplied malicious input from the attacker
    is persisted and stored in the back-end database or repository. Whenever that
    content is retrieved and rendered to be displayed on the web page, the browser
    is completely unaware of it and it either executes the malicious JavaScript that
    comes from the database or renders the malicious HTML markup, instead of displaying
    it as text. The stored XSS will remain permanently in the database and will impact
    all users visiting the affected web page.'
  prefs: []
  type: TYPE_NORMAL
- en: Reflected or Type 2 XSS attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reflected XSS** attacks are the second type of XSS attack vector, in which
    the malicious XSS payload is not stored in the database table for persistence,
    but is still injected in some parameter of the web page that gets rendered back
    to the user. The browser, unaware of this change, simply either renders the injected
    malicious HTML or executes the injected malicious Java script code, again resulting
    in the user''s data being compromised.'
  prefs: []
  type: TYPE_NORMAL
- en: DOM-based or Type 0 XSS attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **document object model-**based XSS is the third category of XSS attacks.
    Here, the XSS payload is not sent to the server, but due to implementation flaws
    and changing the state/DOM of the web page with the help of client-side JavaScript,
    an attacker paces the payload that gets picked up with the JavaScript responsible
    for manipulating the state of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus here is to understand how can we automate the detection of XSS using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic detection of XSS with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we shall see an approach that we will use to automatically detect XSS
    in web applications using Python, Beautifulsoup, Selenium, and Phantomjs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the dependencies by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the objective of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BeautifulSoup** is a brilliant Python library that is required for web scraping
    and parsing web pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium **is an automation framework used for automatically testing web
    applications. Its functionality is particularly important in the security domain
    and is used for browser simulation and automatically traversing the workflows
    of a web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phantomjs** is a utility that is used for headless browsing. It performs
    all activities of a browser without actually loading it, but instead running it
    in the background, which makes it lightweight and very useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After installing Phantomjs, we need to execute the following command on the
    console: `unset QT_QPA_PLATFORM`. This is used to handle the error thrown by the
    Phantomjs version on Ubuntu 16.04, which is as follows: `Message: Service phantomjs
    unexpectedly exited. Status code was: -6`.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the objective of this exercise is to simulate normal
    user behavior and find the injection points within the web application. What we
    mean by *injection points* are all the input fields in which the user can supply
    the input. To find the injection points, we shall make use of the `BeautifulSoup`
    library. From the web page, we extract all fields whose type is either text, password,
    or textarea. Once we find the injection points, we will use selenium to pass our
    payload values in the injection points. Once the payload is set in the injection
    points, we will then locate the submit button for the form, again with the help
    of `BeautifulSoup`. After this, we pass the ID of the submit button to silinium,
    to click it, in order to submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: The payload we will be using is `<a href=#> Malicious Link XSS </a>`. If this
    is created, we can deduce that the website is vulnerable to XSS. It must also
    be noted that, after submitting the payload, we also capture a screenshot of the
    webpage to see if the link was actually created, which will serve as a proof of
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that we will demonstrate the proof of concept of our script
    on the DVWA application that is running locally on our IP `http://192.168.250.1/dvwa`.
    As we know, the application requires the user to log in. We will first make our
    script log into the application automatically and then set the appropriate cookies
    and session. Then, after logging in, we will navigate to the pages where XSS is
    present and carry out the mentioned operation. We will also update the cookie
    value and set security=low, for XSS to be possible in the DVWA application. It
    should be noted that the same concept can be extended and applied to any web application,
    as we are using a very generic approach of identifying the injection points and
    submitting a payload in them. Modify the script and extend it further as appropriate.
    I will be working toward the development of a fully-featured XSS detection tool
    on top of this script, which will be located on my GitHub repository. Please feel
    free to contribute to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at extreme automation.
  prefs: []
  type: TYPE_NORMAL
- en: Script in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s name our script `Xss_automate.py` and add the content shown in the following 
    screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/484f429d-bd64-41a3-920c-38e3892b6249.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/08909770-f649-4193-b2e3-6416f920f08b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/a024dced-fd3e-4fe9-bd23-81486e046e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/c03fe143-c7a6-4041-b336-c4f73782c3fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The script can now be run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a24eb513-17ea-4f53-b2e6-58201c03ddd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go and check the current path to see whether the screenshots were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8657ffd-643f-4ed4-9469-31216243196c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we indicated previously, three screenshots were created and captured. Let''s
    open each to validate the proof of concept. The following screenshot is what we
    see, after successfully logging in with our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d525220-1a2a-4f08-817a-06c5b9d13592.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the exploitation of the reflected XSS vulnerability
    with the creation of the link. Notice the value of security, which is set as low:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/063194e2-c175-43e2-8fd9-21457c9a288e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the Stored XSS vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfa0cf01-a5eb-4a50-8110-625e472120eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that we only applied the previous method to detect XSS in
    two pages, just to reduce the execution time and demonstrate the power of the
    concept. However, this can be extended for all the web pages of the application.
    We would be required to remove the condition of checking if the fetched URL from
    the `<a>` tag is present in the list: `self.target_links=["vulnerabilities/xss_r/","vulnerabilities/xss_s/"]`.
    Try this approach, removing this condition, and modify the script if needed to
    see what it covers.'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CSRF** is an attack with the help of which an attacker exploits a valid user
    session in a manner that allows certain actions to be performed on the behalf
    of currently logged-in user. For example, let''s say an admin user is logged into
    the application and has a valid session cookie set at the browser. There is an
    option for the admin to delete all users from website by clicking the delete all
    button, which internally invokes the HTTP request `http://www.mysite.com/delete?users=all`.
    One of the properties of the web browser to send the session parameters/cookies
    to the server for every subsequent request after the user has logged in to the
    application. This can be exploited by the attacker by crafting a fake page that
    has an HTML image, such as `<img src"http://www.mysite.com/delete?users=all" style="display:hidden">`.
    The attacker can send the link of this fake page to the admin who would be currently
    logged in to his website `mysite.com`. Not aware of the malicious intent, if the
    admin user loads the web page, the HTTP request to delete all users will be triggered
    on their behalf, and the valid session cookies will be sent, causing the server
    to delete all users.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically detecting CSRF with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will look at an approach that we will use to automatically detect CSRF
    in web applications using Python, Beautifulsoup, Selenium, and Phantomjs. Before
    automating the detection, however, let's discuss the approach that we shall take.
    We know that CSRF attacks can be mitigated by implementing anti-CSRF tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Any form that would be served from the server, which will potentially modify
    the state at the server, should have a hidden field that contains a random cryptic
    value called a CSRF token. The principle behind most CSRF tokens is that this
    form and a cookie must also be set with a cryptic value that translates to the
    same value of the token served in the hidden field. When the form is posted back
    to the server, the secret value of the cookie is extracted and compared with the
    hidden value posted back to the server within the hidden field. If both secrets
    match, the request is assumed to be genuine and is processed further.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same approach in our detection mechanism. For any form that
    would be posted back to the server, we will extract all the input fields and compare
    them with a list of commonly used hidden field parameter names for CSRF across
    various technologies such as Java, PHP, Python/Django, ASP.NET, and Ruby. Furthermore,
    we will also take a look at the cookies that are set before the form is submitted
    and compare the names of the cookies with the commonly used names for CSRF protection
    across all well known technology stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it should be noted that the script will simulate normal human behavior.
    It will log into the application and maintain a valid session and then try to
    look for CSRF flaws. The most commonly used CSRF hidden filed parameters along
    with technology stacks are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ASP.NET [Hiddenfiled : __RequestVerificationToken, Cookie : RequestVerificationToken]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PHP [Hiddenfiled : token, Cookie : token], [Hiddenfileld :_csrfToken, Cookie
    : csrfToken]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PHP [Hiddenfiled : _csrftoken, Cookie : csrftoken]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list could be more exhaustive but it is fine for our purposes.
    We will be using the DVWA application to create our proof of concept script.
  prefs: []
  type: TYPE_NORMAL
- en: Script in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a script called `Csrf_detection.py` with the content
    shown in the following  screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/005e85f7-756e-4087-b759-4ccf0ddf62a1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/30d156ff-af96-4a4d-a911-1326a0eeed0c.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/00ec8910-e107-4368-b0f9-4e654ef280d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we execute the script, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b598296e-27e3-4d2f-ab9a-056a8874d1f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot created is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9395078-a5a6-4dfc-8569-d01a54dd881a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The captured screenshot for DVWA application is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f7cec96-632d-491f-a3b8-f6340ce0f9ca.png)'
  prefs: []
  type: TYPE_IMG
- en: It should be noted that we applied the previous method to detect CSRF in only one
    page, just to reduce the execution time and demonstrate the power of the concept.
    However, this can be extended for all web pages of the application. We would be
    required to remove the condition of checking if the fetched URL from the `<a>`
    tag falls in the list: `self.target_links=["vulnerabilities/csrf"]`. Try the same
    approach, removing this condition, and modify the script if needed to see what
    it covers.
  prefs: []
  type: TYPE_NORMAL
- en: Clickjacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Clickjacking** is an attack in which the attacker overlays a custom-made
    attack page on a legitimate website or web page. Consider the same scenario as
    mentioned in the case of the CSRF attack. The web page that can delete all the
    users can be made transparent in such a way that the buttons on the page are not
    visible to the user. What is visible, therefore, is an attack page below the transparent
    layer of a legitimate web page. An attacker can craft a web page, for example,
    that displays iPhone offers and that might have a button that says **win iPhone
    now** placed under the transparent button **delete all users**. Thus, when a victim, **the
    admin user,** thinks they are clicking on a win iPhone button, they are actually
    clicking on the transparent button that deletes all users from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways for a website to prevent itself from Clickjacking is by implementing
    a special header called X-Frame-Options, which is defined in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: X-Frame-Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a special HTTP response header called **X-Frame-Options** by which
    a website can state that it should not be rendered inside a frame or iframe. The
    client browser, on receiving this header, checks for the value that is set within
    the frame limit and, based on the value set, appropriate actions are taken. The
    various values are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DENY**: This value will prevent the web page from being loaded into a frame
    or iFrame. This is the recommended value to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAMEORIGIN**: This value will only allow the page to be loaded in the frame
    or iframe if the page that is trying to load it into the iframe comes from the
    same origin as the page that is being loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALLOW-FROM**: This value defines locations that are permitted to load the
    page into a frame or iframe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically detecting clickjacking with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will see an approach that we will use to see if a website is vulnerable
    to clickjacking. We will use a simple Python script that will check whether X-Frame-Options
    is present in the response header rendered by the application. We will call the
    script `CJ_detector.py` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21e9f24e-ebae-4ab8-9cbb-e3472a0e0793.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will run the script and see if the DVWA application is protected against
    Clickjacking or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8bfe5d-13f7-4f6f-aec8-b5edca533ad8.png)'
  prefs: []
  type: TYPE_IMG
- en: SSL stripping (missing HSTS header)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSL stripping,** or **SSL downgrade,** is an attack vector that downgrades
    an HTTPS connection to HTTP. This attack is carried out by an attacker who is
    between the victim and the web server and acts as a transparent proxy. It further
    maintains a HTTP based downstream connection with the victim and a proper HTTPS
    upstream connection with the server.'
  prefs: []
  type: TYPE_NORMAL
- en: An attack is therefore carried out by the combination of ARP poisoning, SSL
    stripping, and setting up a transparent proxy between the attacker and the victim.
    Let's say that a victim wants to visit a site called `abc.com`. By default, `abc.com` is
    served by the server on HTTPS as `https://www.abc.com`, but when the user types
    the URL in the browser, `abc.com`, the browser sends the request as `http://www.abc.com` to
    the server, which responds with a 302 response and redirects the user to `https://www.abc.com`.
    What's important to note is that the first request from the user browser to the
    server went over plain HTTP, as the user typed `abc.com`. This is what is exploited
    by an attacker using an SSL strip.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an attacker who is placed on the same network and who is ARP poisoning
    the victim and router. In this case, the victim request to `abc.com` first comes
    to the attacker. The attacker has a transparent proxy set up from which they can
    forward the request to the actual server. The server responds with a 302 response.
    The attacker proxy sends a request to `https://abc.com` and receives the response,
    which is nothing but a web page. The attacker proxy has an additional capability
    of parsing the whole response, replacing all HTTPS links with plain HTTP, and
    then rendering back a plain page to victim. In the next request, the victim posts
    their credentials, not knowing that the traffic is passing via the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this kind of attack, the website must include a special header in
    the response they would be sending to the client. This header will be saved in
    the browser preferences and then whenever a connection is made to the website,
    the first request itself will be sent over HTTPS; therefore, making it impossible
    for the attacker to sniff the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security** (**HSTS**) is a security mechanism using
    which the browser remembers that this host is an HSTS host, and saves the details
    in the browser preferences. Thus, whenever this site is visited again, even if
    the user types `abc.com` in the browser, before releasing the request to the server,
    the browser will convert the request to HTTPS internally as it checks its HSTS
    list and finds the target host or server complaint. If the first request is HTTPS,
    the attacker no window to downgrade the request.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically detecting missing HSTS with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will see an approach that we will use in order to identify whether
    the website is vulnerable to clickjacking. We will use a simple Python script
    that will check whether Strict-Transport-Security is present in the response header
    rendered by the application. We will name the script `HSTS_detector.py` and put
    the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eca5a805-7183-4545-9e35-5574f75f05e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the script and see if the application DVWA is protected against
    Clickjacking or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abcd12ce-31c4-460a-b738-686c049c7c47.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the approaches that we can use to automate our
    web application scanning and assessment with Python. We saw how can we use Python
    to automate the detection of web application vulnerabilities such as XSS, CSRF,
    clickjacking and SSL stripping. All of these can come very handy during a real
    assessment and will help you as pen-testers to get a decent grasp of automating
    things with python.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore various concepts related to reverse engineering,
    fuzzing, and buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What other application security use cases can be automated with Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use Python to integrate network scanning and web application scanning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learning Python web penetration testing: [https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html](https://www.lynda.com/Python-tutorials/Learning-Python-Web-Penetration-Testing/521198-2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python for Pentesters: [https://www.pentesteracademy.com/course?id=1](https://www.pentesteracademy.com/course?id=1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penetration Testing Automation Using Python and Kali Linux: [https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux](https://niccs.us-cert.gov/training/search/pluralsight/penetration-testing-automation-using-python-and-kali-linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
