- en: Building a Falcon Application with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement an application based on the Falcon
    framework. This application will be related to quotes; you will be able to fetch
    a quote of the day and generate a random quote. I hope it will be interesting
    to you. We are going to include a scheduler, which will be responsible for fetching
    a random quote from a third party API and putting it into our database. We will
    set this scheduler to be executed once a day. Let's get ready for the ride.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Falcon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing Falcon APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying the Falcon APIs using Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving ahead with the development work in this chapter, I would like
    to recommend fulfilling the prerequisites in order to set up the development environment.
    The following is the list of technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/macOS/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falcon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peewee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gunicorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, I have described the complete information for setting up
    the environment. Let's gear up for it and discover the journey toward serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Falcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring the Python application development requires us to set up virtual
    environments. With the help of a virtual environment, we are going to maintain
    all required packages. As discussed in [Chapter 6](part0151.html#4G04U0-8241a43bed654018b51365a570bcef1d),
    *Building a Django REST API with Zappa*, the pipenv packing tool maintains all
    installed packages in a virtual environment and keeps track of versions and dependencies.
    Let's move on to set up the virtual environment using the pipenv tool.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting the actual implementation, we will set up the virtual environment
    using the pipenv tool. The following is the command to create a new virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I explicitly mentioned the Python version because I use many other Python
    versions on my system. This command will create a `Pipfile` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code has basic information about the environment
    but doesn't have anything under packages because we have not yet installed any
    packages. This file maintains a list of all installed packages. The pipenv tool
    creates a virtual environment at `~/.local/share/virtualenvs/`, and it will create
    the new environment from the directory when we call the preceding command. Once
    you execute the command, `Pipfile` will be created, as mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute the `pipenv shell` command to enable the virtual environment.
    Let's move on to the next section where we will install all the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, we are going to create a Falcon-based API application.
    So, we need to install some packages that we are going to use in our application.
    The following is the list of packages we will use in the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`falcon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zappa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gunicorn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peewee`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install these packages using the `pipenv install <package_name>` command.
  prefs: []
  type: TYPE_NORMAL
- en: You can install multiple packages at once by specifying the other packages separated
    by whitespace, such as `pipenv install <package_one> <package_two> ...`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed all these packages, pipenv will create a file named
    `Pipfile.lock`, which holds the information about versioning and dependencies.
    `Pipfile` will get updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`Pipfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with the virtual environment setup, it is time to move
    on to implementing the application. But before moving on to setting up the environment,
    let's understand some important packages and their usage.
  prefs: []
  type: TYPE_NORMAL
- en: What is Falcon?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falcon is a bare-metal Python web API framework. It can be used to build microservices
    with very fast performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very flexible and easy to implement. It has a markable benchmark, compared
    to other frameworks. There are many giant organizations that are using Falcon
    such as Linkedin, OpenStack, RackSpace, and more. The following is a sample code
    snippet from Falcon''s site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It requires `gunicorn` to execute the API on the localhost server, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Falcon is really simple, and it's much easier to implement REST APIs in Falcon,
    as it encourages us to follow REST architectural styles. You can read more about
    Falcon at: [https://falconframework.org/#](https://falconframework.org/#).
  prefs: []
  type: TYPE_NORMAL
- en: What is Peewee?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Peewee is a simple and small **ORM** (**Object Relational Mapper**). It is designed
    to provide an ORM interface similar to Django or SQLAlchemy. It supports databases
    such as MySQL, Postgres, and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample code snippet , from Peewee''s GitHub page, for defining
    model classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's really amazing—we got the feasibility of designing the database models
    in Django fashion with a tiny wrapper. Peewee makes it really great and can be
    considered for writing small microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Peewee at: [http://docs.peewee-orm.com/en/latest/](http://docs.peewee-orm.com/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we will be using Falcon and Peewee
    practically.
  prefs: []
  type: TYPE_NORMAL
- en: Designing Falcon APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to design a REST API based on a quote concept. A quote might be
    something a famous person said, or it might be a dialog from a movie. We are going
    to use Mashape's **Random Famous Quotes** API ([https://market.mashape.com/andruxnet/random-famous-quotes](https://market.mashape.com/andruxnet/random-famous-quotes)).
    Mashape is an API platform and it provides many categories of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will create a single API with the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate or retrieve a quote for the day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a random quote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first operation, we will need to store a random quote from the Mashape
    API into our database on a daily basis. Hence, we need to design a task scheduler
    to execute on a daily basis and to store the quote from the Mashape API into our
    database so that our API user can get the quote for the day.
  prefs: []
  type: TYPE_NORMAL
- en: For the second operation, we don't need to persist each and every randomly generated
    quote from the Mashape API. Instead, we return the generated random quote to our
    API user.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing any application, scaffolding is an essential step to consider
    before implementing the solution. It helps us to manage the code base in an optimistic
    way. The following is the scaffolding of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we divided the code base into different modules based on functionality.
    Let's have a look at each module in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the model class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined the `QuoteModel` by extending the `Model` class and defined
    attributes using the features of the Peewee library. The most essential part here
    is the database connectivity; as you can see, we used an SQLite database. We created
    the database file and placed it in the `/tmp` directory so that it would accessible
    in an AWS Lambda environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined the database using the `SqliteDatabase` class, we connect
    the database and create database tables as defined by models.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.create_tabless` method creates tables only if they do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to use this `Model` class to perform any query operation. But,
    before creating resources, let's have a look at `mashape.py`, where we integrated
    the third-party API to get a random quote.
  prefs: []
  type: TYPE_NORMAL
- en: Mashape API integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mashape is the largest API marketplace for private and public APIs. There are
    thousands of API providers and consumers registered. Have a look at the marketplace
    at [https://market.mashape.com](https://market.mashape.com/). We are going to
    use the Random Famous Quote API ([https://market.mashape.com/andruxnet/random-famous-quotes](https://market.mashape.com/andruxnet/random-famous-quotes)).
    Once you are logged in to the Mashape marketplace, you can explore these APIs
    in detail. The following code snippet has one of the APIs that we are using to
    fetch a random quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`mashape.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have written a method named `fetch_quote`. This method is responsible
    for fetching the quote from the Mashape API and returning the quote data in Python
    dictionary format. We are going to use this method at different places as per
    our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating API resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`resources.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the `QuoteResource` class and implemented the `on_get` method
    to handle `GET` requests. In order to perform different operations of generating
    the daily quote and random quote, we defined a query parameter named `type`, for
    example, `http://<API_URL>?type=daily|random`. Hence, based on the query parameter,
    we serve the request.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the implementation. We will look at the execution, scheduling,
    and deployment in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying Falcon APIs using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of other frameworks, Falcon requires the `gunicorn` library for
    execution. Gunicorn is a lightweight Python WSGI HTTP server. Falcon doesn't have
    any default behavior to server WSGI; instead, Falcon mainly focuses on API architectural
    styles and performance. Let's move on to executing the API in the local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Local execution using gunicorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For local execution, we are going to use `gunicorn`. The following is the log
    of the `gunicorn` execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `resources` module and the `api` object for the execution.
    We created the `api` object using the `resources` module.
  prefs: []
  type: TYPE_NORMAL
- en: API for the daily quote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We implemented the `/quote` API and separated operations based on the query
    parameters. Let''s execute the `/quote?type=daily` API. The following is the log
    snippet of the daily quote API execution using the cURL command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This API will return a unique quote every day.
  prefs: []
  type: TYPE_NORMAL
- en: API of the random quote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s execute another operation on the `/quote` API such as `/quote?type=random`.
    This API will return a random quote on each request. The following is a log of
    the API execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This API will return a random quote record on each request.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have installed Zappa while setting up the virtual environment, we are
    good to configure Zappa with our application. The following are the operations
    we would execute in order to configure Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined the configuration as per the requirements. As the key defines
    each configuration, we can see the usages of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_region`: The AWS region where the lambda would get uploaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app_function`: The import path of the `api` object from the `resources` module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile_name`: The AWS CLI configuration profile that is defined in the `~/.aws/credentials`
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project_name`: The project name for the uploading lambda function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: The Python runtime interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s3_bucket`: Creates an Amazon S3 bucket and uploads the deployment packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_env`: Sets the environment variable of all the key-value pairs mentioned
    in the uploaded JSON file at the Amazon S3 location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of this configuration information, we can proceed with the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are done with the configuration, then we can process the deployment.
    Zappa provides two different commands to perform the deployment, `zappa deploy
    <stage_name>` and `zappa update <stage_name>`. Initially, we use the `zappadeploy
    <stage_name>` command as it is the first time that we are deploying this lambda
    application.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already deployed the application and want to redeploy it, then you
    would use the `zappa update <stage_name>` command. In the previous chapter, we
    had a detailed discussion about the deployment process of Zappa, so you can refer
    to that for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the log of our deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, I use `zappa update dev` to deploy my existing application. This command
    will print the deployed URL at the end; we can use it to test the application
    in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Executing in the production environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we deployed our application on AWS Lambda using Zappa, Zappa configures
    the API Gateway with the proxy to AWS Lambda. Hence, it will have a randomly generated
    API Gateway link, as mentioned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's execute our API using the generated link ([https://0uqnn5ql3a.execute-api.ap-south-1.amazonaws.com/dev/quote](https://0uqnn5ql3a.execute-api.ap-south-1.amazonaws.com/dev/quote)).
  prefs: []
  type: TYPE_NORMAL
- en: Daily quote API execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The execution operation will be similar to the local execution, but it will
    have a little bit of an impact on the API Gateway, because there are many features
    available in the AWS API Gateway that can be used to enhance our API performance
    and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the log snippet of the daily quote API execution using cURL
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our application is live as a serverless application. You can use it without
    worrying much about the server, as it is capable of serving millions of request
    per second and Amazon will take care of its scalability and availability. Let's
    try another API.
  prefs: []
  type: TYPE_NORMAL
- en: Random quote API execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s execute the random quote API. The following is a snippet of the random
    quote API execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this execution takes 1.369 seconds, because we are explicitly
    making another request to the Mashape API to fetch the random quote. We can make
    this execution faster by adding caching support to the API Gateway service.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling caching on the API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AWS API Gateway provides a feature to add caching for your API endpoint
    responses. It will help to reduce the network latency and return cached responses
    to the user without hitting the AWS Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa has the ability to configure caching on the AWS API Gateway; you don't
    need to configure the caching manually from the AWS web console. The following
    is the configuration needed to add in the `zappa_settings.json` file to enable
    caching on the API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, the caching options in the `zappa_settings.json` file. Let''s
    see its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cache_cluster_enabled`: Default is `false`; this option is set to `true` to
    enable the API Gateway cache cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache_cluster_size`: Default is 0.5 GB; this indicates the cache memory size.
    If required, we can increase the size as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache_cluster_ttl`: Default is 300 seconds; this option is to set the **time-to-live**
    (**TTL**) for the response caches in memory. It has a maximum limit of 3,600 seconds,
    and in order to disable it, you can set it to 0 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache_cluster_encrypted`: Default is `false`; set this option to `true` if
    you want to encrypt the cached responses data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how you can enable the API Gateway caching mechanism without any manual
    intervention. Only `GET` request methods should be cached.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS API Gateway doesn't support the free tier. It's charged on an hourly
    basis. Read more about API Gateway Pricing at [https://aws.amazon.com/api-gateway/pricing/](https://aws.amazon.com/api-gateway/pricing/).
  prefs: []
  type: TYPE_NORMAL
- en: Event scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Lambda can be configured alongside AWS CloudWatch Events. If you want to
    execute your Lambda function to be executed on a regular schedule, for example,
    every five minutes, you can use rate expression or you can configure a `cron`
    expression to schedule a timed event for the execution.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about schedule expression at [https://docs.aws.amazon.com/lambda/latest/dg/tutorial-scheduled-events-schedule-expressions.html](https://docs.aws.amazon.com/lambda/latest/dg/tutorial-scheduled-events-schedule-expressions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS Lambda with a scheduled event requires more manual intervention.
    You can have a look at the official documentation at [https://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html](https://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html).
  prefs: []
  type: TYPE_NORMAL
- en: Zappa provides a very flexible way to configure the schedule events without
    any manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring events using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zappa supports both scheduled events and AWS events. Scheduled events are bound
    to time and date, whereas AWS events are related to any AWS service such as AWS
    S3 events and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can schedule the Lambda function execution based on any AWS events, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Zappa supports almost all AWS events to execute the AWS lambda function. You
    can read more about execution in response to AWS events at [https://github.com/Miserlou/Zappa#executing-in-response-to-aws-events](https://github.com/Miserlou/Zappa#executing-in-response-to-aws-events).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you add the events configuration, you can execute the following command
    to schedule the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we are going to schedule a time-bounded event to execute a function
    to fetch a daily quote and store it in the database. Let's see how we can configure
    our application to schedule a daily event.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling an event to set the quote of the day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already designed our `/quote?type=daily` API to fetch a quote of the day,
    this API will return the quote if it exists in the database or else fetch it from
    the Mashape API and store it in the database. This operation is to prevent API
    failure in case the quote record does not exist in the database.
  prefs: []
  type: TYPE_NORMAL
- en: But we want to make sure that the quote record does exist in the database. For
    that, we are going to schedule a daily event that will occur at midnight. We will
    execute a function to perform the `fetch quote` operation.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the Zappa settings snippet with events configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`schedulers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to enable the scheduled events, let''s run the `zappa schedule
    dev` command. The following is the log of the `schedule` command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's it; we are done with scheduling now. Now, daily, at midnight, the `set_quote_of_the_day`
    method will invoke and perform a fetch quote operation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to create high-performance APIs based on the Falcon
    framework. We also learned to configure the API Gateway caching mechanism using
    Zappa. The most interesting part we covered was scheduling. Now you don't need
    to worry about any third-party scheduling tools, as Zappa makes it super easy
    to enable scheduling based on time and AWS events.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter. Now let's dive into the next chapter to explore
    Zappa's features. We are going to set the custom domain for our application and
    SSL certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Falcon differ from other Python frameworks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of Peewee library over `SQLAlchemy`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does scheduling work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
