- en: More Advanced Command Lines and Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic networking concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing new software and updating the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic system troubleshooting and firewalling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setuid`, `setgid`, and `sticky bit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic networking concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the foundations of networking in Linux. Everything
    about networking is within the classic domain of Unix and Linux, and, in fact,
    the old Unix folks do say that Unix has been created for network communication.
    Linux is considered one of the best systems to use, learn, test, play, diagnose,
    and troubleshoot computer networks because a lot of great tools are available
    in Linux for free and come right out of the box, or just need a single command
    to install. There's a lot to learn about the subject of computer networks, and
    here we can only teach you the fundamentals of it using the CentOS 7 Linux operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn about computer networks from 10,000 up. The two most fundamental
    concepts in networking are the network, or subnetwork, and the IP address. The
    three most important facts every Linux user needs to know are the network, or
    sometimes called the subnetwork, the IP address, and the rules of the network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: The network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every network, or sometimes called subnetwork, has a so-called network address
    consisting of only numbers, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/350a4969-33cb-4b4e-8f34-8d04af3d0d28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rule 2: The IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every computer needs an IP address for communication, which is part of a subnetwork''s
    address. In our example, the first three numbers divided by dots are the same
    between the IP addresses and the network address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8143da7-1838-4d7a-9c09-19dc442dc282.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rule 3: The same network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The easiest way for network communication between two or multiple computers
    is to connect them physically (for example, by using network cables and a single
    switch), and then put them in the same network, which means choosing all of the
    computers'' IP addresses from the same range as our subnetwork''s network address.
    In our example, choose `10.0.2` as the first three digits for all our IP addresses.
    As you can see, only the last digit is variable. Every computer that wants to
    talk to another computer in the same network then only needs the correct IP address
    of the recipient. This is also the basic setup of almost all private networks
    you may have at home:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82fd0c2c-7b75-4719-98f7-d4eac7a40776.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have just learned, for normal network communication, all participants
    need to be in the same network. If this was all there was to networking, we would
    have to stop here and modern communication and the World Wide Web would not exist.
    The reality is that there are millions of networks connected together around the
    globe, such as our own private one, which are all connected through routers. If
    you want to communicate with another machine in your network or any other network,
    your computer needs to have a so-called IP routing table that defines static routes
    or the next hop towards a particular destination. This IP routing table is part
    of every Linux operating system. For example, if we have a private network consisting
    of three subnetworks with the following IP network addresses, if you want to get
    into contact with another computer in your subnetwork, your routing table could
    work the following way. If there is an entry in the table that defines what to
    do if someone wants to access the IP address of the `10.0.2.0` subnetwork, for
    example, with the IP `10.0.2.15`, there is a route entry in the table that defines
    that you should hop to the `10.0.2.0` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cc02cbc-89a6-49bf-981a-7831a5248fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same happens if you want to access the machine with the IP address `192.168.122`.
    Because there is an entry in the table, the routing table will hop to the `192.168.1.0`
    network that this computer is part of:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c290d1ac-a116-4c33-b712-677910b343dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For all the other IP addresses where there is no explicit rule, the so-called
    default route will be used. In most private networks, the default rule is the
    IP address of a real hardware router, which basically is the same as an IP routing
    table, but which can do more, as it is connected to other routers around the globe
    where it will find its way to the correct destination address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c01d8f98-0bf5-49bf-95e4-06f4020e8a36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is also called dynamic routing, as the router or path between the source
    and the destination can vary depending on which routers it will use. Normally,
    each private network that most internet service providers offer has only one public
    IP address that connects to the public internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b03a412-0b6b-439f-b6a1-77849dc6c292.png)'
  prefs: []
  type: TYPE_IMG
- en: All machines from our private network need to go via this router, with its single
    public IP address, if they want to communicate with other computers in the public
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if an outside public machine from the internet wants to access
    the private computers from our subnetwork, the router needs to handle the correct
    delivery of messages to the correct recipient, which has an internal IP address
    only visible within our private network.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can you define an IP address for a computer? The IP address needs to
    be set on an OS level in the correct configuration location associated with a
    certain network interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09f07a3c-9a4a-4bde-b997-d2df61ddd88f.png)'
  prefs: []
  type: TYPE_IMG
- en: But, as mentioned before, the IP addresses need to be unique in the same subnetwork;
    otherwise, the correct recipient for a network message cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can you take care of that? The first approach is to manually manage
    a list of computers and all free and reserved IP addresses available in this network.
    Here, we need to assign static IP addresses, which means every computer gets an
    IP address hardcoded into the system, which will not change and remain stable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a981e2c-3333-4380-90ab-3fe3e8f26644.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Often, important services in networks, such as a mail or web server, have a
    static IP because they must be reachable under the same address all the time from
    multiple other computers or services. But, as you can imagine, this system is
    very inflexible and needs manual intervention all the time. Just think about a
    public wireless hotspot and all the people who are connecting to this network
    all the time with multiple devices, such as smartphones, laptops, and tablets.
    A much better solution is to use a so-called DHCP server. This is a service running
    in your network that listens to new devices and keeps a database of all devices
    currently connected to the network. It automatically assigns or revokes, and manages,
    in a very reliable manner, IP addresses to all the machines connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a6a7d59-ae58-42cf-99a1-a57362865dc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The IP addresses assigned to the computers are dynamic, which means tomorrow,
    your computer can have an IP address other than the one used today. The great
    thing about this system is that it can also send additional information about
    your network to the computers connected, for example, the IP address of a private
    DNS or mail server in your network, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f579f775-7eeb-4f85-9df7-6a3f491e357b.png)'
  prefs: []
  type: TYPE_IMG
- en: A DNS server is another very important networking feature that we need to know
    about. As we have just learned, computers communicate with each other using IP
    addresses only, which are just numbers. As we humans are not so good at memorizing
    or recalling long sequences of numbers, but are much better working with names
    for objects or things, a system has been developed to assign names or aliases
    to these IP addresses so that we can address computers by names instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A DNS server has a database that stores these relationships. As computers can
    only work with numbers and not names on the network, every time we want to connect
    the computer using a name, a corresponding DNS server gets asked internally to
    translate the name to its corresponding IP address so that we can make the right
    connection with the IP address instead. Now, for resolving names of the normal
    internet, such as `google.com`, we will use some public DNS servers normally provided
    by your ISP or from another source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7436e53-37c4-4f67-ac08-c92aca2dc5a2.png)'
  prefs: []
  type: TYPE_IMG
- en: But how can we give names to our internal private computers' IP addresses in
    our subnetwork when the public DNS servers don't have this information? One solution
    would be to install and set up our own private DNS server and add new names to
    IP address relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this needs a lot of work to install and configure. An easier, and quicker,
    solution is to put the name to an IP address relationship locally in a special
    file called the `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01781fed-e595-4932-8c2d-ea8805ed09ee.png)'
  prefs: []
  type: TYPE_IMG
- en: The biggest disadvantage of using the hosts file is that you have to put this
    file on every single computer in your network that wants to resolve network names,
    and also you have to keep this file up to date at all times so that each time
    a new computer is added to the network, every computer in the network needs to
    update their hosts file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have only spoken of names to IP address relationships when it
    comes to DNS servers and the hosts file. But here we need to discuss the anatomy
    of such a name in greater detail. For example, you could give all the computers
    in your network hostnames of the persons working with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc16a2b3-f028-4381-8ea8-66ddbc9429c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use any name schema you like, but, as you can imagine, these hostnames
    are not unique enough to fully qualify a computer in a network so that we can
    address it directly. Bear in mind that our private network can consist of several
    different subnetworks, for example, one for the IT department, and one for the
    human resources department:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c009193b-7539-4697-90f4-1c0e0abe623f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, two people can easily exist with the same name in different subnetworks,
    so this would not work because the computer hostname, Carl, exists in both networks
    and we just cannot use the hostname alone to differentiate between unique computer
    names. Therefore, we can also give names to subnetworks or network addresses.
    This kind of name is also called the DNS name, or domain name. The hostname or
    name of the computer plus the DNS name, combined together and separated by a dot,
    is called the **fully-qualified domain name** (**FQDN**), and really is needed
    each time we need to access computers in different networks outside our own local
    subnetwork:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bf24fce-9aed-48ff-bedc-288f2b8a38c3.png)'
  prefs: []
  type: TYPE_IMG
- en: So here, using the fully-qualified name to address Carl at **it-department.com**
    will not clash with the Carl in the **human-resources.com** subnetwork.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap! The hostname is a computer name (for example, Carl), the DNS name
    is the name of a network or subnetwork, such as `my-company.com` or `google.com`,
    and the fully-qualified domain name is the hostname plus the DNS name separated
    by a dot (for example, `Carl.my-company.com` or `mail.google.com`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml), *Introduction to
    Linux*, of this book, we set up three VMs called **Master**, **client1**, and
    **client2**. We configured the network of our three machines to have one network
    interface per VM, always with the same isolated IP `10.0.2.15`, which means no
    internal connections between the three VMs can be made because they all have the
    same IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29ecc67-d1c8-41f4-a29e-64fc94d2adac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use VirtualBox port forwarding to access our machines from outside through
    SSH using the host ports `2222`, `2223`, and `2224`, which all map to port `22`,
    the internal SSH port of the machines. Now, we want to make the machines able
    to communicate with each other using an internal private network. As each network
    interface can only have one IP address, we will accomplish this by adding a second
    virtual network adapter with a new IP address from another subnetwork to each
    machine, so that every VM has one network adapter for public access via SSH, and
    one for internal subnetwork communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c4ab2d6-47ea-468a-8086-7b9b4f8df068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we use a second subnetwork called `10.0.5` instead of our `10.0.2`
    for our internal network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2845aa26-4aaa-4d9e-b1b3-6164484e45c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you type in the `ip addr list`, you will get a list of all the network interfaces
    currently attached to your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6875b8b1-1a5c-42eb-8518-fbcb34ba4428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first device is the loopback device, which is a non-physical device so
    that we can make a network connection to our own computer. It always has the IP
    address `127.0.0.1`. The second network interface is enp0s3, which is a virtual
    network interface provided by the VirtualBox configuration. This reflects to adapt
    the one in the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb9ae48a-e5ae-4748-b868-7c9fc6c7e71a.png)'
  prefs: []
  type: TYPE_IMG
- en: This virtual network interface has the IP address `10.0.2.15` and is mainly
    used so we can SSH to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add another network interface to our virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, first shut down the machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e46dca3-5bb3-4787-87c4-bb076c37c06d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to add a new network interface for internal communication between your
    virtual machines, add a second network interface to each machine in the following
    way. First, open your VM Settings, go to Network, open the tab Adapter 2, enable
    it, and attach it to the internal network. As you can see, the name of the internal
    network is called internet. We will put all our other VMs in the same network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f26c507d-ad70-443c-8f8f-377cf5bc89f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, press OK to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for every VM you want to have as part of your internal network for
    communication between the machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's start one of your VMs to test the network settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you again run the IP address list, you will see that our newly added
    network interface appears at interface number 3 with the name `enp0s8`. Also,
    you will see that currently, no IP address has been associated to this device
    automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73d2b578-48b4-4c74-a1ce-8cb883c2a864.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get some information about our current network. Let''s show the IP routing
    table for our network devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c96398b-731e-42d5-a76e-63bb483819a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `enp0s3` network adapter with the IP address `10.0.2.15`,
    which is the interface we used to connect via SSH from the host machine using
    port forwarding, currently has two routes in the IP routing table. The first route
    is the route for the subnetwork we are currently a member of, `10.0.2.0`. This
    means that this route will be taken if we try to contact another computer in our
    subnetwork. For example, `10.0.2.16`. All the other IP addresses we want to reach
    are using the default route, which points to the IP address `10.0.2.2`. This is
    the IP address of our router. So, for example, if you want to go to www.google.com,
    first the domain name will be translated to an IP address using a DNS server,
    and then it will be matched against our routes there. We can use the `nslookup`
    command to resolve any domain name into an IP address using the system''s default
    DNS server. As you can see, the `google.com` domain name has the following IP
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62bfc9da-cce4-4664-8dac-671ef3cee1a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the IP addresses starting with `172` are not part of our subnetwork, the
    default route will be used. Behind the `10.0.2.2` IP address sits a real hardware
    router; it will take care of the proper routing between the virtual machine and
    the `google.com` website.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create a new network connection between our three virtual machines
    using the `enp0s8` network interface, let's set three unique FQDNs. We will do
    this using the root account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print out the FQDN, use the `hostnamectl status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b2fee6-5c14-4e70-8cd7-9abf309a5f1b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, currently we have the FQDN of `localhost.localdomain`. Now,
    to change the FQDN, use the set-hostname option of the `hostnamectl` command.
    In our example, we used the hostname or computer name master and the DNS name,
    `centos7vt.com`. The fully-qualified domain name is `master.centos7vt.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recheck using the `status` option. On our two other VMs, we will later
    set the `hostnames`, `client1` and `client2`, and the same DNS name, `centos7vt.com`.
    You can also set the FQDN by editing the `/etc/hostname` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change your system''s default DNS server IP address, open the file called
    `/etc/resolv.conf`. Under the keyword name server, you can change or add new name
    servers. For example, to add a new name server, introduce a new name server line
    and change the IP address. In this example, we will use Google''s official DNS
    server address, or you can just use `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c13125f7-07d1-4c24-9338-b0f1fdbfa1f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s set up a new static network configuration for our new network
    adapter, `enp0s8`. On CentOS 7, all the network configuration files can be found
    at `/etc/sysconfig/network-scripts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ee5ade4-92f0-467d-bfc4-5c02715d4b29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, for the `enp0s3` network interface, a corresponding network
    interface configuration file called `ifcfg-enp0s3`. Let''s view its content by
    typing `cat ifcfg-eno0s3` exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a6f1619-bd75-49dd-b4c5-e3611bb8b4a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The most important things to know about this Ethernet network device are that
    it's getting its IP address from a DHCP server, the device is activated on boot
    up, and has the device ID `enp0s3`. The other items you see in this configuration
    file can also become very important when configuring different network devices
    in different environments. Since there is no visual manual page for the `if` configuration
    file format, please refer to the excellent documentation at `/usr/share/doc/initscripts-*
    sysconfig.txt:`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9755575b-bd9e-4891-89bd-2233ccefee41.png)'
  prefs: []
  type: TYPE_IMG
- en: If you open the file and search for `ifcfg`, you will come to the section where
    all the different items of the `ifcfg` file format are being explained. For example,
    the BOOTPROTO item can have the values `none`, `bootp`, and `dhcp`. Since both
    `bootp` and `dhcp` refer to a DHCP client for our new network device, `enp0s8`,
    that we want to configure as a static device, we will use the `BOOTPROTO none`,
    but what items do we need for setting up our simple static network connection?
    Since we are setting up an internal network only, we don't need any routing set
    up and only need very little information in our **interface config** (**ifcfg**)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we will need the following items: the name, the device, the IP address,
    because we will hardcode a static IP address, and the BOOTPROTO, which we will
    set to none. So let''s review our plan network configuration from the introduction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will remember, the master node we are currently logged in should have
    a second network interface with the static IP address `10.0.5.1`. **Client1**
    should have a second network adapter with the static IP address `10.0.5.2`, and
    **client2** should have `10.0.5.3`, all for internal network communication between
    the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a14839a1-810b-49f4-8e5c-2e6373551eb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So let''s configure our new device:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are currently in the network scripts folder, where all our
    network interface''s configuration files can be found. So let''s first create
    a new configuration file for our new network interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d882dba1-3d6e-442f-9f4b-1d3edcd914de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will make our life easy by copying the existing configuration file for the
    `enp0s3` network device to the new `enp0s8` configuration file. Now let''s open
    this new configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9df1539f-96c1-49e3-9820-e523df3ef92c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the boot protocol to `none` for the static IP configuration.
    Most of the items are not needed, so just delete the lines. Change the name of
    the device to `s8`; UUID is not needed here. Also, change the device ID, leave
    the `ONBOOT` as `yes`, so the interface will come up on server restart, and finally,
    add a new line that defines the hardcoded IP address of our static internet network
    configuration. Use the IP address `10.0.5.1` for our master server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/160a492c-6f77-4aae-9044-45a61fba1ec6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now save the file and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then need to hard reset our `enp0s8` network interface so that the changes
    we made to the configuration file can be applied to the device and the static
    IP address can get active. In order to do so, first shut down the `enp0s8` device
    using the `ifdown` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then bring it back online using the `ifup` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let's review the `ip addr` list command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you compare the output of `enp0s8` before we restarted the device and afterwards,
    you will see that the changes we made to the configuration file were valid, and
    now we have a static IP of `10.0.5.1` for our `enp0s8` network device.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after we set up the static network configuration for the enp0s8 network
    adapter, let's recheck our IP routing table with the `ip route show` command.
    If you compare the routing table before and after we have set up the new network
    interface, `enp0s8`, you will see that a new route has been created for routing
    network communications in our new `10.0.0.0` subnetwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing still left on the master node, as we don''t have a private DNS
    server, is to set up our network''s computer names to IP relationships in the
    `/etc/hosts` file. Always start adding new entries at the end of the file by using
    the fully-qualified domain names first, and then you can add further short hostnames.
    You can always add multiple names for the same IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cf43398-71bf-472c-a115-572956e2d689.png)'
  prefs: []
  type: TYPE_IMG
- en: The first entry will be our own machine we just set up. The other entries are
    for our clients we are about to set up shortly. Save and exit the file. Now start
    the two client VMs. After booting up the VMs is complete, open two new tabs in
    your Terminal emulator of your choosing. The first tab on the left holds the connection
    to the `master` node. On the next tab to the right, please log in to the `client2`
    VM using the SSH port forwarding on port `2223`. In the third tab, log into the
    `client2` VM on port `2224`. Now go to the middle tab where our `client1` VM is
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here let''s repeat the steps to configure our `enp0s8` network interface so
    we can make the connection between our servers:'
  prefs: []
  type: TYPE_NORMAL
- en: First, log in as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set a fully-qualified domain name to `client1.centos7vt.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a configuration file for our new **enp0s8** static network connection.
    Here, enter the same information as on the master; only change the IP address
    to the `10.0.5.2`. Save and exit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, restart the network interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef38b7ea-cd77-4153-baf2-3a571405c203.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have successfully assigned the `10.0.5.2` IP address to
    our enp0s8 network interface. Finally, add entries to the `/etc/hosts` file so
    that we can resolve other domain names in our subnetwork. Add the same information
    as on the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33c6d24e-7726-4bbb-952c-8172592ebe07.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and exit the file. Next, do the same steps for the `client2` VM in the
    third tab. First log, in as root, use `client2` for the hostname, use the `10.0.5.3`
    for the IP address, restart your network interface, and finally, add entries to
    the `/etc/hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have set up our private network for communication, the easiest
    way to test whether it is working properly is to use the `ping` command. This
    command can be used to see whether another host is alive and reachable. If it
    is not reachable, the following error message will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdd15634-cffe-40ad-b43b-dcb7674c2595.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s start our connection tests from the `master` in the first tab. First,
    let''s test if we can reach `client1` with the IP address `10.0.5.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e37912ee-7319-4678-96be-9c0de4eb968a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it works. Also, test if we can reach `client2` with the IP
    address `10.0.5.3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5922c243-45c3-4a53-ba99-9d7d36306baa.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this also works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, test if our `/etc/hosts` configuration is also working. In
    order to do so, let''s ping the various hostnames we set up in this file. The
    fully-qualified domain name of client1 is working. Also, the hostname client1
    is working. C2 is also working as a short name for client2\. The fully-qualified
    domain name of client2 is also working. The short name client2 is working and
    the very short name c2 is also working for client2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f2f0d87-9ba5-48e1-a600-db4e829f1f73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s move to client1\. Here, let''s test if we can reach the master server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ed41205-90b4-4282-a324-4b959042b53e.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, it's working. Also, you can test the master server under a different name.
    Let's also test the client2 connection. Test the master under a different name,
    and also test client1\. In summary, we can say that the network configuration
    between our three VM machines is now working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Installing new software and updating the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how you can install new software on your computer
    and how to update your CentOS 7 system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s show all the currently installed RPM packages on the system.
    Type `yum list installed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30cb1957-3e81-4667-b8e7-54f241c1757d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the installation chapter in [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml),
    *Introduction to Linux*, we already demonstrated how you can do a full system
    update using the `yum` command, which will update all of the RPM packages that
    are already included in the minimal installation, and also all the packages we
    have installed afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of all the updates currently available for all the software packages
    already installed on your system, type the following command to see what''s new:
    `yum check update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c76558bf-ee55-433a-922b-ef67b0f63992.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, all the RPM software packages are listed with the new version of the
    updates you can install. All updates must be done using the root user. So first
    log in as root. To update only a single ROM software package, such as the `vim-minimal`
    package, which was presented in the list of available software updates, use `yum
    update` and then incorporate the name of the package; for example, `vim-minimal`.
    Type yes when asked to update the software package, and type `yes` again to confirm
    the importing of the GBG key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b690227d-48d5-4072-ac95-acd40de53ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `vim-minimal` package has been successfully updated to the
    latest version. As we have already learned in [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml), *Introduction
    to Linux*, in this book, just type `yum update` to do a full system update of
    all the packages currently installed on your system. Now let's press the *N* key
    to cancel the download and installation of the updates of all the packages. Most
    yum commands need some kind of confirmation by the user; for example, to confirm
    the update of software packages. If you are absolutely sure that you will answer
    yes to any question, you can further automate the `yum` command of your choosing
    by providing the `-y` flag. This works on almost any command. This will perform
    the yum action of your choosing without further confirmation by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that there is a big ongoing debate as to whether you need to restart
    your system after packages have been updated. The consensus is that normally this
    is not needed, but, if the kernel or glibc software packages have been updated,
    you should do it. Of course, you should really do it for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the reboot is necessary when we compare the currently
    installed kernel with the currently running kernel in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51086241-cad9-4526-b139-3c426fdb7c0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The currently running kernel ends with `514.el7`. The currently installed latest
    kernel ends with `514.21`, so we are currently not running the latest kernel.
    So let''s reboot the system. After rebooting has finished and you are logged in
    as the root user back to the system, type the `uname -r` command again, and now
    we can see that we are now running the latest kernel, so rebooting was necessary
    in this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ffbc806-45d5-4371-8a2c-66c649bd0ced.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to search in your package repositories using a keyword (for example, `Apache2
    Web Server`), use the `yum search` command and then the keyword. This will print
    out a list of all the software packages matching the keyword; in our example,
    apache, in the package name or in the package description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a60ce958-e594-4ec3-962a-5c37c94874b8.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to get more information about one of the package names (for example,
    the HTTP package name), you can use the `yum info` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another really useful feature is if you know the name of a file or command
    included in an RPM package, but actually don''t know the name of the RPM package
    where this command or file is from, you can use the `yum whatprovides` command,
    prefixing the command or file you are searching for with an `*/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1abd357-91c0-4b4d-985f-0d707cd77ac6.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we are searching for all the package names that include files
    or commands named `ifconfig`. As we can see, we have one hit in the `net-tools`
    RPM package where a binary or command exists in `/bin/ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to install a software package, use the `yum install` command, providing
    the package name as an argument. Here, in this example, we install the Apache
    HTTP server package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6586b70-c9d5-4aab-8427-6300090f38f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Another interesting command is the `rpm -ql` command followed by the name of
    the installed software package to get a list of all the files and their exact
    location in the filesystem that has been installed by this software package. To
    remove a software package, you can use the `yum remove` command and then the name
    of the software package you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](5cb16aa6-1fad-46e8-a176-8eb9ce50e63c.xhtml), *Working with the
    Command Line*, we showed you how to use a third-party repository, called `epl`,
    to install software such as `htop`, and `iotop `because they are not available
    from the official CentOS 7 repositories. For example, if you search for the `htop`
    package, it''s not available from official sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbd7df80-c72e-4d4b-b55b-ba849eb087c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So let''s install the `epl` repository, as it is available from default package
    sources. As you can see, the `epl` repository can be installed using the `epl-release`
    RPM package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f6ab4a0-25f8-43af-877c-a6faa714eed1.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the following command to see if the `epl` repository has been successfully
    installed by retrieving a list of all the available repositories in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now find the `htop` package, as it is part of `epl`. Installing other
    repositories is not so easy, since no RPM packages are available from the official
    sources, but most third-party repositories can be installed by downloading an
    external RPM. You will most likely find the repositories on a web page. For example,
    for the famous `remi` repository, you can first download the official `remi` repository
    RPM package from the official `remi` website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b24cc00c-09b8-401c-960a-8068b8877e71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, install this downloaded `remi` repository RPM using the `rpm` command
    with the capital `Uvh` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36b3d925-073f-482d-aad1-94c694276e48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you need to enable the `remi` repository by editing the `remi yum config`
    file. First, open the `remi.repo` file in your `/etc/yum.repos.d` folder. Here,
    in this file, go to the section `remi`, then go down to the keyword enabled and
    change it from `0` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdbbea0b-df94-4d34-904e-2c99c9ec5176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now save the file. Then you can use your newly installed third-party repository
    after updating your repositories software packages list. To recheck if the third-party
    repositories have been installed correctly, you can also use the `yum repolist`
    command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f823d15b-ac5d-4591-9288-7371a77ad319.png)'
  prefs: []
  type: TYPE_IMG
- en: Introduction to services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to work with services in CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open your three VMs, master, client1, and client2, from the previous section
    of this chapter in three different tabs that are connected together on the same
    internal subnetwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by installing a simple networking service. In our example, let''s
    install the Apache2 web server on the master server, as it is very easy to set
    up and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1c94fc5-d607-4404-b5fb-02b51325e815.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, following installation of the `httpd` package on CentOS 7, you can manage
    services using the `systemctl` command, which is part of the `systemd` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of all the units currently available in the system, use the following
    command: `system ctl list-units`. This will open the unit list with less navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f10184d1-dbf5-4f50-9514-9da0f0dcafc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, different kinds of unit files are available; for example, one
    that ends with `device`, one that ends with `mount`, and the service files. Press
    *q* to quit the navigation. To get a list of all the services currently available
    in your system, just type `systemctl list-unit-files` and then filter for services
    by using `--type=service`. In this list, you will see all the available services
    currently enabled or disabled in your system. As we installed Apache2 Web Server
    an `httpd services` file that is currently disabled also exists. To get a detailed
    status of a single service, use the `systemctl` command with the `status` option
    and the service name; in our example, the `httpd` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eae9ca8-290b-4f07-821c-3ea361bd9d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, following installation of our new Apache HTTP server, the service
    is not running. By default, there are two different states a `systemd` service
    can have that are important for us: enabled or disabled, and active or inactive.
    In our example, the `httpd` service is disabled and inactive by default after
    installation. Just like any other service, the Apache HTTP server, by default,
    is disabled and inactive. Enabled means that a service should automatically start
    every time you start your Linux system, which is also referred to as on boot.
    Active means that a service is currently running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a service, use the `systemctl start` option and then the name of the
    service; in our, example, the `httpd.service`. Now recheck the service, using
    the `status` option again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e89d371a-9b1a-4bc9-89e1-153ae2eb91d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it''s now running. Also, you can see two other very important
    things in the output here. First, you can see that a service can consist of several
    processes. In our example, the httpd service consists of six different HTTP processes.
    The other important thing is that the `systemctl status` command will output the
    last lines of messages generated by the service when it is started up. Such lines
    of useful text generated by a process are also called a log and can give us useful
    information about the running behavior of a service. Still, our service is disabled.
    To enable it, use the `systemctl enable` option. Now view the status again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9c38fcc-8e8d-4750-b4e7-91730e31363f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see now that it's also enabled, so this service will automatically start
    up every time we restart our server. To stop a currently running service, use
    the `systemctl stop` option. We will see that it's inactive again.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that starting or stopping will not influence the service's
    disabled or enabled server boot behavior. Here, this service is still enabled
    while it's not running. This is also true for the other way around. Disabling
    or enabling a service will not start or stop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable a service, use the `systemctl disable` option. Then, again, start
    the service up. Now, to test if our HTTP server is working and can host and deliver
    web content, let''s first create a standard home page for our server. The standard
    home page for our server is the `index.html` file in the `/var/www/html` folder.
    Now, incorporate the following HTML content, which is a greeting message from
    our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cff68994-f27a-4b15-8029-9a4659952270.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save and exit the file. Now, to access our home page from our new web server
    on the master server where this web server is located, use `wget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eadcb655-17c1-4942-8cfc-03b71c88fcfb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can properly access the home page locally from our master
    server. Now, what happens if you stop the web service and try again to access
    our web page? You will see that the web page is not accessible any more. Restart
    the web server. Now, let's test if we can access our new web server from another
    machine in our local network. Just go to the client1 tab and test if the web server
    is accessible through the network. You will see that it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Basic system troubleshooting and firewalling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will continue our work on the Apache2 Web Server we started
    in the last section, so as to make it accessible for other computers in our subnetwork.
    Also, we will give you a brief introduction to Linux firewalls in CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'As briefly mentioned in the first section of this chapter, a network connection
    is always made through a combination of an IP address and the port, which together
    is called a socket address. Now, every Linux network service, such as a mail or
    web server, must be connected to an IP address and the port so that we can establish
    a connection to it at all from a different computer in the network or from the
    same local one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca19ad25-2863-484d-a1d2-e52c22dcc128.png)'
  prefs: []
  type: TYPE_IMG
- en: When we are talking about network communication, we often refer to this as "a
    service is listening to IP address a port b". For example, our web server is listening
    on port `80` of the IP address `10.0.2.15`, the mail service is listening on port
    `24`, the web service is listening on port `80` of the IP address `10.0.2.15`,
    and the FTP service is listening on port `21` of IP address `10.0.2.15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But maybe you are wondering which IP address does a service use for communication
    if we have configured multiple network interfaces on our system, all with a different
    IP address? The answer to this is simple. Most networking services on any Linux
    system listen to all available network interfaces for network connections by default
    after installation. For almost all standard services, you can also change this
    to listen only to a specific network interface, or network connection, or subnetwork,
    or even ranges of networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/572ef538-ecca-44bf-89a9-a9dfd2bf1c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Some even only listen to a localhost by default after installation, as these
    often are very critical services where system administrators need to change the
    listening address intentionally as a measurement of responsibility to make them
    aware of the risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s say you have a Linux server that is running several networking services
    and each is listening on a different port. A firewall is a tool for managing connections
    to your computer. In Linux, the standard firewall is called **firewalld**. This
    firewall can protect your system against unwanted network connections from outside
    your system, for example, if some intruder is trying to break into your system
    and steal data. It does so by managing your incoming network ports for communication.
    By default, `firewalld` closes all incoming network ports except the port `22`
    for SSH connections. Otherwise, you would not be able to remotely connect to your
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09ebe94d-250e-4f5e-a26f-83b843a62f48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So if you want to have some kind of network communication, you have to explicitly
    tell the firewall to do so. You can open or close individual ports or ranges of
    ports, and so on. This helps a lot in managing security on your server, but it''s
    important to note that, by default, firewalld does not restrict any local network
    communication within a system, so the localhost network connection is always working
    and is not blocked by the firewall. Also, it''s very important to know that firewalld,
    by default, is an incoming firewall only, which means it does not block any outgoing
    connections at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/052891d5-d628-4e37-a634-28f6aea3e317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to fix this problem, we need to know how we can troubleshoot a system
    service. So, first go back to our master server where this web server is running.
    To find out if something is wrong with your service, there are always at least
    three places where to look. The first thing we should do is to check the `systemctl
    status` output, as we have done before. As you can see, the service is currently
    running and the final current lines of output of the service also look `OK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4852cf3c-9a62-4c11-a9ae-684b1aaf659a.png)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, here in this output, you will find error messages or warnings if
    a service is not functioning normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the last two lines of the log output for a service are not enough,
    so the second place to look for if you need to troubleshoot your service, is the
    `journalctl` command. If you use the `journalctl` command with the `-u` flag,
    you can filter log messages for your service of choice; in our example, the `httpd`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b5c5c41-1015-4efd-ab03-45686d58a550.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, in our example, no suspicious log output can be found in `journald`, which
    is the service that writes all the log messages of all the services running into
    a centralized database. The journal log for the Apache HTTP Server looks normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the third place where we can have a look for troubleshooting services is
    the `rsyslog` log file, which is located at `/var/log/messages`. Open this file
    and go to the end of it, pressing capital *G*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2171118-83f1-4ffa-8b87-340940d9040d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here also, nothing really suspicious has been logged to the `rsyslog` file.
  prefs: []
  type: TYPE_NORMAL
- en: Some services, such as our Apache HTTP Web Server, provide their own log files
    for troubleshooting or getting info about the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that there is no standardized directory where a service outputs
    its own log files, but some services write their log files into a subdirectory
    under the `/var/log` file directory. Here, you can find two log files. One is
    the `access_log`, which logs user access to our web server (for example, the files
    on the server that have been downloaded). The other is the `error_log` file, which
    logs all kinds of errors that this service may encounter. So, first have a look
    at the `access_log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e668333-8e35-4fab-bb91-e36ce2a42c17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This looks very normal. Now, also open the `error_log` file. Jump to the end
    using capital *G*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5c1e5a5-f975-48b6-b180-f452087d2a57.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, no special error messages can be found.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the problem of why nobody outside of our server can access the
    Apache HTTP Web Server instead of CentOS 7 is that a very restrictive firewall
    is active that blocks almost any incoming network connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the currently allowed firewall rules by typing `firewall-cmd --list-all`.
    On CentOS 7, the standard firewall is called firewalld:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35a33271-a875-4714-8a9e-5de4ff1c6e07.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see here, only the SSH service is allowed by default to communicate
    with our server. Firewalld is mainly protecting all incoming network connections.
    Outgoing connections from our server to other servers are not restricted or limited;
    that's the reason why we can access our web server from the localhost, but not
    from any other host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we can open the HTTP service, also known as opening port
    80, in our firewall. So that we can do that permanently, use the following two
    commands: `firewall-cmd --permanent --add-service`, and then `http`. So that the
    changes can be applied, next reload the firewall rules. Finally, let''s see if
    the HTTP service is now enabled in the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/082b7f50-01bf-4157-bc61-71755cc6b741.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s test if we can make remote connections to our Apache Web Server
    from another server. Go to client1 and repeat the `wget` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92529b85-e4fc-4cf6-864b-3e7e42283faa.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, it works! You are now able to access your web server in your network.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we haven't talked about how to remove a service from the firewall.
    To remove the HTTP service or port from the firewall configuration, use the following
    firewall command syntax, `firewall-cmd --permanent --remove-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the service of choice; in our example, the `http` service. Similar to
    adding a service, you also have to reload the firewall here. Let''s recheck our
    firewall settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e52883d-5cfc-41f4-a520-2197296924a7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, HTTP port has been closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a very useful feature of the firewalld service is to open individual
    port numbers without providing a service name. This is very useful if you need
    to open a port where no service file, such as the HTTP, is available. For example,
    to open port `12345`, use the TCP protocol. Let''s show the new firewall configuration
    after we have reloaded the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4341af-f9ed-4dad-8a59-1d58e993016b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the port `12345` is now open using the TCP protocol. Instead
    of TCP, you can also use the UDP protocol. Now, to close the port `12345` using
    the TCP protocol, use the following command. Here, also reload the firewall configuration.
    Let''s perform a recheck:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ddbcd4-835b-4b8f-b995-f77c4afefc3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s summarize what we have learned so far:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is a service-related problem, first have a look at the `systemctl` output
    for the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the problem persists, next look at the `journalctl` output for the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is a general system problem, or you cannot fix your service problems with
    the `systemctl` and `journalctl` outputs, next have a look at the `/var/log-messages
    rsyslog` output file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, some services provide special log file locations outside of `journald`
    or the `rsyslog` file, so also have a look there. But you must be aware that not
    every service or program has such a special log file directory or output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we gave you a brief introduction to the firewalld service using predefined
    service files, such as the HTTP, and also we showed you how to work with individual
    ports that are not defined by service files. In the next chapter, we will show
    you advanced file permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introducing ACLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will give you a brief introduction to how ACLs, or access
    control lists, work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux has some special file and folder permissions, namely the ACLs, `setuid`,
    `setgid`, and `sticky bit`. If you look at the file in the filesystem, such as
    a new file that only the root user has access to, currently we are logged in as
    `olip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4906246a-fcfb-4bf9-86e9-485310d7210e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `olip` user has no write access on that file. Maybe you
    have already asked yourself this question: how can you give permissions to a file
    or folder to individual users who are not the file or group owner, in our example
    root? The only way is to use the others group, but this is not individual as all
    users who are not the file or group owner fall into this category. But here, we
    want to set single user permissions; for example, for the `olip` user.'
  prefs: []
  type: TYPE_NORMAL
- en: Access control lists, or ACLs, is a system that extends our normal file access
    control under Linux with its simple ownership and permission model. With ACLs
    you can define file or folder permissions on a single user or group-level basis.
    To work with ACLs, use the `getfacl` and `setfacl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to display ACLs, use the `getfacl` command and then the filename
    where you want to show permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/187752b3-8eaf-47ae-81d9-33a67ca25adf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, as you can see, no ACLs have currently been set on this file. As with
    normal file permissions, if we want to change something, we need to log in as
    root. Now, to set ACLs, for example, for the `olip` user, use the following command.
    If you remember [Chapter 3](4a931838-be11-4c95-90f4-7662129e4d32.xhtml), *The
    Linux Filesystem*, this should be self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1266dd6d-4277-4aea-b587-93992323d892.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To display the ACL, again view the ACL of this file. If you compare the `getfacl`
    command output before and after, you will see that we now have single user permissions
    for the `olup` user: `read`, `write`, and `execute`. Now, the `olip` user should
    be able to write to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64db54e-37ed-42ff-9426-d0033d817100.png)'
  prefs: []
  type: TYPE_IMG
- en: Success; the ACLs are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set ACLs on a group-level basis. Here, instead of using the user,
    we will use the group identifier. To remove a single ACL, use the `-x` flag. You
    can also see if a file has an ACL set by the marked plus in the output of the
    `ls -l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26a876b0-52ee-4f1c-b04c-6e65a86eeda1.png)'
  prefs: []
  type: TYPE_IMG
- en: setuid, setgid and sticky bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you everything you need to know about the special
    file permission flags, `setid`, `setgid`, and the `sticky bit`.
  prefs: []
  type: TYPE_NORMAL
- en: setuid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's talk about `setuid`, `setgid`, and the `sticky bit`. As we work with
    users, groups, and file permissions, let's first log in as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new user, group, and the copy of the `whoami` command
    locally to see what''s going on with the `setuid` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f1fd404-74c4-410a-a80f-8e03419f224e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s change the file owner and group owner of this command to `awesome_user`
    and `awesome_group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02f714b5-54cd-48dc-ae56-1a3c17a4abc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting the `setuid`, `setgid`, and the `sticky bit` can also be done using
    octal notations. You already know about them from the file permissions chapter.
    These special permissions can be represented by one single additional bit in the
    file permission string, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ee75da5-26b6-492a-a168-1c73dc777f65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `setuid` has the number `4`, the `setgid` the number `2`, and the `sticky
    bit` the number `1`. Similar to the files'' simple `read`, `write`, and `execute`
    permissions, here you can also add combinations of special permissions to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7bd5161-7c6d-43a6-9d0f-5b17628d3aed.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to set both `setuid` and `setgid` flags, you need to add up the
    `4` and the `2`, which totals `6`, or `setgid` and `sticky bit` are represented
    by the `3`, or `sticky bit` and `setuid` are represented by the `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how do we set the special permission information? It can be set using
    an additional number in the `chmod` command. You already know that it takes three
    numbers to define permissions for the user, group, and others. To display special
    permissions on the file, you can use the `ls -l` command, but this is very hard
    to read and it''s more easy to use the `getfacl` command, which not only works
    for ACLs, but also shows flags that are the names for our special permissions.
    By default, no flag or special permission is defined on any file, as you can see
    in the output of the `getfacl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73ae921a-d3f2-4c5a-b852-e6be40e65382.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to add a special permission flag to a file, or, in other words, set the
    `setuid`, `setgid`, or `sticky bit`, you can use the `chmod` command with four
    numbers instead of three, where the first leading number defines the special permission.
    For example, if you use a `2` as the leading first number for the `chmod` command,
    you will set the set group ID flag, which is shown in the flags line. If we have
    an `s` at the second position, it''s the set group ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51782889-847f-4473-96e9-0750a1376dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to set the `setuid` flag, use number `4` as your first number in the `chmod`
    command. Recheck using the `getfacl` command. Here, in the flags line, the first
    leftmost character has been set to an `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f985704-14a6-4a96-a593-8d284882d887.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, adding a combination of special file permission flags (for example, number
    6, which is a combination of `setuid` and `setgid`, or 4 plus 2, equals 6), is
    shown in the following way in the `getfacl` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4d68e59-0267-415d-b6de-289461895060.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first leftmost flag is the `setuid` flag, and the second flag is the `setgid`
    flag. To set all three permission types, `setuid`, `setgid`, and `sticky bit`,
    use `getfacl` (path):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b272143f-9236-44b3-92c2-10b5457fa3bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you see that all three flags have been set. The short flag for the `sticky
    bit` is a `t` instead of an `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove all special file permissions, just use `0` as the number for the
    file permission encoding, and just use `0` as the first number for the `chmod`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfc57246-c6f3-46c0-95a4-3810d23fd8f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's briefly discuss the `setuid` permissions. The `setuid` flag is only
    important on executable commands and never on a directory or other file types.
    It is also important to know that it does not work on script files for security
    reasons, but only on compiled binary executable files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, each process has an associated user that we refer to
    as "a user runs a command". Here, in this example, all the processes you see are
    run by the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fef88911-1180-4dd1-8764-0ed7b8b37028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the `setuid` permission flag will run a command as the user that is defined
    as the file owner of that file. This is important and useful for some special
    commands in the system; for example, commands that must be run as the root user
    because they access protected filesystem files or folders, but must also be executable
    for normal users. Take, for example, the `passwd` command. It accesses and writes
    to files such as the `etc/passwd` file, which is only writable for root, so this
    command must be run as root, but normal users also need to change their passwords
    on the `passwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa0ec1bc-0c90-46ae-8cf3-9d208d33c490.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's exit the root user to test the `setuid` flag with a normal user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recheck if we are really the `olip` user. Now, without setting the `setuid`
    flag on a file, if we execute our local `whoami` command, it will print out our
    username, as we are the user who started it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/486f3310-e830-4d30-94c0-5b00bb286f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, what happens if we set the `setuid` permission on that command and execute
    it again? First, let''s view the permission flags. We will see that the `setuid`
    flag has been successfully set on that file. Now, let''s execute a command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e855733-11e5-4b59-8287-eb5efb3fc26a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `setuid` flag works as expected. We run our command as the
    `olip` user but the file owner, `awesome_user`, was used during the execution
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: setgid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's learn about the `setgid` permission. This flag has two different
    meanings, which is important to know about and should be memorized. When set on
    a file, it has the same effect as the `setuid` permission, but here it will execute
    a command with the rights of the group owner instead of the file owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the `setgid` flag on the file, use the number `2` in the `chmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6045bc66-e569-4642-b5ab-758dbd38206a.png)'
  prefs: []
  type: TYPE_IMG
- en: The second meaning of the `setgid` flag is very important and should be memorized
    because it can be a typical use case. If you set the `setgid` on a folder instead
    of a file, every new file, or folder, or subfolder created within this folder
    will automatically get the group permissions of the folder where you set the `setgid`
    flag. This works for all the files included recursively. This can become very
    important because normally the group permissions of new files created automatically
    get assigned by the creator of the file.
  prefs: []
  type: TYPE_NORMAL
- en: So if you want to separate locations in your filesystems for collaborations
    or group work where you can put in shared files for anyone belonging to a special
    group, `setgid` is a very powerful feature. This is like a shared folder you may
    know about from other operating systems. So if you want to separate your filesystems
    into locations for collaborations or group work, where anybody who is belonging
    to a special group can create documents that automatically can be fully accessed
    by other persons of that same group, just set a `setgid` flag on a folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder under the username `olip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change the group ownership to `awesome_group`. Now, if a user creates a
    new file in this folder, it will have the group ownership of that user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's set the `setgid` flag on that folder and see what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a new file under the username `olip` in that folder where we
    set the `setgid` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31c7762e-1527-44a9-b50d-73ecf61a3018.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, any new file created in this folder now gets the group ownership
    of the folder, which is `awesome_group`. So our `setgid` flag is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: sticky bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sticky bit` only has an effect on directories and not on files. If `sticky
    bit` is set on a folder, only the owner of a specific file, folder, or subfolder
    created in that directory is allowed to delete it. There are some special cases
    where this is useful, for example, in the `/tmp` directory, where anybody should
    be allowed to see anything, but quite often processes create and rely on data
    stored in that folder, so it would be very bad if someone other than the creator
    of the process could be able to delete files from other users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbc27a8e-a024-4001-bbfa-f2ff6d7cf5a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, `sticky bit` has been set on the `/tmp` directory, so let''s
    create a new file with the `olip` user in the `/tmp` directory. Now, let''s look
    in with `awesome_user`. As no password has been set, let''s set one for it. Now, `awesome_user`
    will also create a new file in the `/tmp` directory. Now, let''s try to delete
    our own file, which works. Now, let''s try to delete the file of the `olip` user;
    this does not work, so `sticky bit` is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc153ad7-1db1-4491-a264-ef49b370a034.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave you a brief introduction to special file permission
    flags in Linux. The `setuid` flag works only on commands and not on scripts, and
    lets a program execute as the user defined as the file owner instead of the user
    who is running that program. The `setgid` flag has two special meanings. The first
    is for commands and the other for folders. If you set it on a command, it will
    work like the `setuid` flag, but will run it as the group ownership of that file
    instead of the file owner of that file. The second meaning is if you set it on
    a folder, the group owner of the folder where you set `setgid` will automatically
    be assigned to every new file you created within that folder. Within a directory
    where `sticky bit` has been set, only the file owner can delete his own files
  prefs: []
  type: TYPE_NORMAL
