- en: Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with prepared statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling the pending query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading query result metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from query result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing query result into map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing stored procedures and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each database server has its own specifics and also, the protocols are different.
    Naturally, the communication with the database within the language library must
    be customized to work with the specific protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library provides a unified API for communication and operations
    on the database server. This API is located in the `sql` package. To use the specific
    database server, the driver must be imported. This driver needs to be `sql` package-compliant.
    This way, you will be able to benefit from the unified approach. In this chapter,
    we will describe the basics of database operations, transaction handling, and
    finally, how to use the stored procedures. Note that we are going to illustrate
    the approach on the PostgreSQL database, but the approaches are applicable to
    most other databases.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essential part of working with the database is the connection to the database
    itself. The Go standard package covers only the abstraction on how the interaction
    with the database works, and a third-party driver must be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to connect to the PostgreSQL database. However,
    the approach is applicable to all other databases whose driver implements the
    standard API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull the PostgreSQL driver by `go get -u github.com/lib/pq`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the PostgreSQL database server (optionally use a Docker image instead
    of installing to your host system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use default user `postgres` with password `postgres`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a database named `example`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter08/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `connect.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run connect.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc43c34f-78b8-4cd5-82e5-6541753840dc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard lib package, `database/sql,` provides the `Open` function to initialize
    the connection to the database with the driver name and connection details (connection
    URL in this case). Note that the `Open` function does not create the connection
    immediately, and may only validate the parameters passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: The connection to the database could be verified by the `Ping` method, which
    is available in the returned `DB` struct pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The driver itself is initialized in the `init` function of the `driver` package.
    The driver registers itself with the driver name by the `Register` function of
    the `sql` package. The `github.com/lib/pq` driver registers itself as `postgres`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The connections to the database in the driver implementation may be pooled,
    and it is possible that the connection pulled out of the pool is broken. This
    recipe will show how to verify if the connection is alive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter08/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `verify.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run verify.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d5ba3af-08c2-4c54-93bd-25541dc94e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous recipe, *Connecting the database*, the `Open` function
    may just verify the connection details, but it is not mandatory to connect the
    database immediately. The actual connection to the database is usually lazy loaded
    and it is created by the first execution of statement against the database.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the `DB` structure provides the `Ping` method, which usually
    does an idempotent call to the database. The variation to the `Ping` method is
    `PingContext`, which just adds the ability to cancel or time out the database
    call. Note that if the `Ping` function fails, the connection is removed from the
    database pool.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the `DB`  struct also provides the method `Conn` to retrieve
    the connection from the database pool. By using the connection, you are actually
    guaranteed that the same database session is used. In the same way the pointer
    to the `DB` struct contains the `PingContext` method, the `Conn` pointer provides
    the `PingContext` method to check if the connection is still alive.
  prefs: []
  type: TYPE_NORMAL
- en: Executing statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous recipes, we have gone through how to connect and validate the connection
    to the database. This recipe will describe how to execute statements against the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `statement.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run statement.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17b952d6-d23c-442a-bfb1-cbb262c3e22b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, there are two types of statements that we can execute against the
    database. With the first type of statements we do not expect any rows as a result
    and finally, we get no output or just a number of affected rows. This type of
    statement is executed by the `Exec` method on the `DB` struct pointer. In the
    preceding sample code, we have the `TRUNCATE` and `INSERT` statements. But this
    way, the DDL and DCL statements could be executed too.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main categories of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DDL** (**Data Definition Language**): This language allows you to create
    and modify the database scheme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DML** (**Data Modeling Language**): This language helps you to modify the
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DCL** (**Data Control Language**): This language defines the access control
    over the objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCL** (**Transaction Control Language**): This language controls the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second type is the statement where we are expecting the result in the form
    of rows; these are usually called queries. This type of statement is usually executed
    by the `Query` or `QueryContext` method.
  prefs: []
  type: TYPE_NORMAL
- en: Operations with prepared statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepared statements bring security, efficiency, and convenience. Naturally,
    it is possible to use them with the Go standard library; this recipe will show
    how.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `prepared.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run prepared.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f93601d9-2fb8-4db8-a3dd-e263f03b0cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the prepared statement, the `Prepare` method of the pointer to the `DB`
    struct needs to be called. After this, the `Exec` or `Query` method on the `Stmt`
    pointer is called with given parameters for the statement.
  prefs: []
  type: TYPE_NORMAL
- en: The prepared statement is created within the scope of the `DB` pointer, but
    on the specific connection from the connection pool. The statement remembers which
    connection has been used, and when it is invoked, it tries to use the same connection.
    If the connection is busy or was closed, then it recreates the prepared statement
    and calls the statement on a new connection.
  prefs: []
  type: TYPE_NORMAL
- en: The situation changes if you use the prepared statement within an opened transaction
    `*Tx`, in this case, the prepared statement is bound to one connection which is
    related to the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that prepared statements prepared within the transaction cannot be used
    with the DB pointer, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the prepared statement works the way the statement is created on
    the database side. The database returns the identifier of the prepared statement.
    The prepared statement is executed during the following call, and only the parameters
    for the statement are provided.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling the pending query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you need to prune long running statements to limit the consumption
    of resources, or just if the result is not relevant, or if the statement is running
    too long. Since Go 1.8, the canceling of queries is possible. This recipe explains how
    to use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *G**etting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `cancelable.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run cancelable.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd8da9ab-b8ad-4b5b-bf43-3f0d766910ea.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `database/sql` package provides the possibility of canceling the pending
    statement. All the methods named `XXXContext` of `DB` struct pointer are the ones
    that consume the context, and it is possible to cancel the pending statement.
  prefs: []
  type: TYPE_NORMAL
- en: The canceling of the statement is possible only if the driver supports the `Context`
    variant. If it doesn't, the variant without the `Context` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Context` variant and `context.WithTimeout`, you can create a timeout
    of the statement call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the sample code execution ends with the error `pq: canceling statement
    due to user request`, which corresponds with that of `CancelFunc`, which was called
    right after the query was executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading query result metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the data itself, the result of a query contains metadata related to
    the result set. This contains information about the column names, types, and other
    information about the data. This recipe will explain how to retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready *section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `metadata.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run metadata.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48545a27-4614-44a1-a20b-5abdf0ae7f82.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Query` and `QueryContext` methods of the pointer to the `DB` struct result
    in the `Rows` struct pointer. The `Rows` pointer provides the methods `Columns`
    and `ColumnTypes,` which contain the information about the structure of the returned
    result set.
  prefs: []
  type: TYPE_NORMAL
- en: The `Columns` method returns just the slice of strings with column names.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColumnTypes` method returns the slice of `ColumnType` pointers, which contains
    more rich information about the returned result set. The preceding code prints
    out the detailed information of what information the `ColumnType` pointer exposes.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from a query result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with the database, the basic part is the extraction of data through
    executed query. This recipe will illustrate how it is done when using the standard
    library `database/sql` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `data.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run data.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ac9cc08-6adb-48da-b0a6-a89657d80791.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pointer to `Rows` coming from the `Query` method of the pointer to the `DB`
    struct provides the methods to read and extract the data from the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Note that first the `Next` method should be called to shift the cursor to the
    next result row. The `Next` method returns `true` if there is any other row, or
    `false` if not.
  prefs: []
  type: TYPE_NORMAL
- en: After the new row is fetched by `Next`, the `Scan` method could be called to
    extract the data into a variable. The number of variables must match the number
    of columns in `SELECT`, otherwise, the `Scan` method is not able to extract the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of the code is that, after each `Next` method, the `Err`
    method should be called to find out if there was an error during the reading of
    the next row.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example intentionally uses the `NULL` value for the second record.
    The `NULL` database values could not be extracted to not nullable types, `string`,
    in this case, the `NullString` type must be used.
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, the sample code covers the `QueryRow` method, which slightly
    differs from the `Query` method. This one returns a pointer to the `Row` struct
    which provides only the `Scan` method. Note, the fact that there are no rows could
    only be detected after the `Scan` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the query result into a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the result of the query or the structure of the table is not clear,
    and the result needs to be extracted to some flexible structure. This brings us
    to this recipe, where the extraction of values mapped to column names will be
    presented.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `querymap.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run querymap.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d69cc84f-33e3-48b3-9d36-1a85b6f52253.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the preceding code represents two approaches. The `parseWithRawBytes`
    function uses the preferred approach, but it is highly dependent on the driver
    implementation. It works the way that the slice of `RawBytes`, with the same length
    as the number of the columns in the result, is created. Because the `Scan` function
    requires pointers to values, we need to create the slice of pointers to the slice
    of `RawBytes` (slice of byte slices), then it can be passed to the `Scan` function.
  prefs: []
  type: TYPE_NORMAL
- en: After it is successfully extracted, we just remap the values. In the example
    code, we cast it to the `string` because the driver uses the `string` type to
    store the values if the `RawBytes` is the target. Beware that the form of stored
    values depends on driver implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach, `parseToMap`, is usable in the case that the first one
    does not work. It uses almost the same approach, but the slice of values is defined
    as the slice of empty interfaces. This approach relies on the driver. The driver
    should determine the default type to assign to the value pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Handling transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transaction control comes under the common things that need to be kept in mind
    while working with the database. This recipe will show you how to handle the transaction
    with the help of the `sql` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `transaction.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run transaction.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/237bdb28-3ba6-4a4a-8c08-f1212e8f43fc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transaction handling, as the preceding code illustrates, is very simple.
    The method, `Begin`, of the `DB` struct pointer creates the transaction with a
    default isolation level (depends on driver). The transaction, by its nature, is
    kept on the single connection and is represented by the returned pointer to the `Tx`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer, `Tx`, implements all the methods available to the `DB` struct pointer;
    the exception is that all the operations are done within the transaction (if the
    database is able to process the statement in the transaction).  The transaction
    is ended by calling the `Rollback` or `Commit` method on the `Tx` struct pointer.
    After this call, the transaction is finished and other operations will end by
    the error `ErrTxDone`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more useful method on the `DB` struct pointer called `BeginTx`,
    which creates the transaction `Tx` struct pointer but is also enhanced with given
    context. If the context is canceled, the transaction will be rolled back  (a further
    `Commit` call will result in the error). The `BeginTx` also consumes the pointer
    to `TxOptions`, which is optional and could define the isolation level.
  prefs: []
  type: TYPE_NORMAL
- en: Executing stored procedures and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with stored procedures and functions is always more complex than usual
    statements, especially if the procedures contain custom types. The standard library
    provides the API to deal with these, but the final word of how much the stored
    procedure calls are supported is in the driver implementation. This recipe will
    show a very simple function/procedure call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verify if Go is properly installed by calling the `go version` command in your
    Terminal. If the command fails, follow the *Getting ready* section in the first
    recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the PostgreSQL server, as mentioned in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL script against your sample database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Open the console and create the folder `chapter08/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `procedure.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run procedure.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25194205-e33a-4b71-b9d9-e9653189ff44.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The calling of stored procedures is highly dependent on the driver and the database.
    Note that retrieving result on PostgreSQL database is very similar to querying
    tables. The `Query` or `QueryRow` method of the `DB` struct pointer is called,
    and the resulted rows or row pointer can be parsed to obtain the values.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL driver uses the `CALL` statement, if the stored procedure needs to
    be called.
  prefs: []
  type: TYPE_NORMAL
- en: The general problem for almost all drivers ia the `OUTPUT` parameters of stored
    procedures. Go 1.9 added support for such parameters, but the majority of drivers
    of commonly-used databases do not implement this yet. The solution, then, could
    be the usage of the driver with a nonstandard API.
  prefs: []
  type: TYPE_NORMAL
- en: The way the `OUTPUT` params are supposed to work is that the procedure call
    will use the type `NamedArg` parameter from the `Named` function of the `database/sql`
    package. The `Value` field of the `NamedArg` struct should be of type `Out` which
    contains the `Dest` field, where the actual value of the `OUTPUT` parameter should
    be placed.
  prefs: []
  type: TYPE_NORMAL
