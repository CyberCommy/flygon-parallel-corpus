- en: NetBIOS Name Service and LLMNR - Obsolete but Still Deadly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use those legacy proprietary and broken
    protocols, still hanging around on almost every network, to your advantage and
    gain the access that you want. This is Bo's favorite attack vector, his favorite
    *low-hanging fruit*, and normally results in the *total pwnage* of the domain
    and every account associated with that domain. Over a year, most likely 80% of
    the epic-fail testing results come from this attack vector in some manner of exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is it that the first machines that I target are Windows systems? The answer
    is: NetBIOS, LLMNR, NTML, and the SMB protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NetBIOS name service and NTLM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sniffing and capturing traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A running copy of Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several Windows OSes (running these as VMs will work fine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBIOS name service and NTLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the early days of networking, just after the birth of the PC, people
    wanted the ability to share files from one system to another. In business applications,
    systems already had the ability to network themselves using proprietary networking
    protocols such as IPX (Internetwork Packet Exchange), Tolkien Ring, and coaxial
    bus networks. One big problem with all these proprietary protocols is that none
    of them could cross-communicate between themselves. This became known as vendor
    lock-in, and we still have some of this even today with proprietary systems and
    protocols. (Yes, I am pointing the finger at you, Microsoft.) Using these protocols
    meant paying a license fee for each system on the network-not just a cost for
    the OS, but an extra cost to network each system, then an extra fee on top of
    that for each workstation connecting to a server across that network. Then, yes,
    you could have two networks remote from each other and connect them using the
    existing phone lines of the day, but the system had to be running the same OS
    and networking protocols in order to communicate. A DEC network could not talk
    to a Netware network even in the same building, much less over the phone lines.
    This was also the problem faced by the government and military, with communications
    across the country and the coming age of data transmission and phone calls routed
    through many single points of failure, with no means to make this traffic self-route.
    Communication networks could be shut down by hitting a few strategic points. A
    self-routing network with a common communication language was needed, and so along
    came ARPANET and the TCP/IP protocol suite. I was lucky enough to work on this
    in the beginning, and I never thought it would grow to what we have today.
  prefs: []
  type: TYPE_NORMAL
- en: During this time, Microsoft came up with their own protocols to network Windows
    systems, but again, these protocols are proprietary and could only run on Windows
    systems. The first of these was NetBUI. NetBUI was a non-routable protocol that
    needed very little configuration, and systems connected to the same local switch
    or hub could communicate and happily share files and data; however, if you wished
    to send a file across town, well, better get yourself a floppy. If you had a UNIX
    box on your local network, you would again need your floppy to transfer data from
    your Windows PC to the UNIX server. NetBUI was Windows-only! Sure, it was easy
    to use-you didn't need to be a network engineer to connect to the network, you
    just plugged in your cable and magically, by knowing the names of the other computers,
    you could connect to them share files, delete files, and even remotely control
    the system. Wow, that's cool! Except, in these days, Windows had no security-none.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this was sold as a stand-alone PC, a system where security could be
    controlled by watching who was sitting in the chair at the computer. No logins,
    no user accounts, no ACLs, just open and unlimited access to every system on the
    local network. OK, so you're reading this book because you either work in internet
    security or have an interest in it, so here's a class question for you. *Do you
    see a problem with this network model?* If not, please get a refund on this book
    and buy a copy of Better Homes and Gardens-you will be better served. Unlike UNIX,
    which was designed from the ground up to be a networked OS, Windows was never
    designed for this from the very outset, and still suffers today from these bad
    beginnings.
  prefs: []
  type: TYPE_NORMAL
- en: So how does this magic work? When you connected a system to the network, the
    system would send out ARP broadcasts saying, *Hey, my computer name is WS3 and
    I have these goodies stored here*. One system, normally the first one on the network,
    would be the Master Browser, which kept track of the machine names and the network
    resources. If this system went down, then all the systems on the network would
    have an election over ARP and decide who would be the next Master Browser. Now,
    this is all well and good if you have fewer than 20 machines on a network, but
    have more than 20 machines on the same network and you now have a communication
    problem which only grows with each extra machine added to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Remember Trumpet Winsock? Trumpet Winsock was third-party software you had to
    manually load on your Windows system and fight with the com ports in order to
    get it to work. This was the first TCP/IP network stack for Windows. Microsoft
    later bought out the Winsock guys, and their source code was the base and first
    version of the Windows TCP/IP interface built into Windows NT. (No, Microsoft
    did not invent TCP/IP).
  prefs: []
  type: TYPE_NORMAL
- en: 'We all know what the problem is: using this method means you have access to
    everything on the network. No data is safe from prying eyes or a thief on any
    system on the network, and with this method, there is no way of tracing who is
    accessing this data. Also, you can remotely control this system without a login
    and without any credentials. Yes-you could run `del C:\Windows\*` and completely
    hose a machine. Additionally, systems at remote locations could not talk to the
    home office because NetBUI was non-routable. So, we all knew this wasn''t going
    to work. Microsoft finally came around and figured this out too, and thus along
    came NetBIOS-an improvement, but not a fix. This was also about the time that
    Microsoft stole David Cutler from IBM, who took his designs from IBM''s OS2 with
    him, and from that designed and built Windows NT. (Yes, NT''s Daddy is OS2.) NT
    was designed to be a networked OS with file-level security user accounts and ACLs.'
  prefs: []
  type: TYPE_NORMAL
- en: A real network OS. It was also somewhat compliant with Portable Operating System
    Interface (POSIX), so it could, on a limited basis, communicate with UNIX-based
    machines. They had to land government contracts, and at the time it was a requirement
    for all government systems to be POSIX-compliant. Here, again, we get vendor lock-in-yes,
    NT had some limited APIs that were considered POSIX-compliant that looked good
    on paper, but they never worked in the real world. When attempting to get these
    to work, Microsoft's solution was *Buy more Microsoft products*. It also came
    with a TCP/IP stack for the network interface. Now, we might say, *Now we are
    ready for prime time*. Hmm-not quite. Microsoft, as always, had "ease of use"
    at the front of their minds-sure, simple and easy to use is a good thing, but
    this is not always true when it comes to security. Think about how easy it would
    be to enter your house if you didn't have to lock the door and keep a hold of
    the key. If you don't have a lock on your door, you will never lock yourself out.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft and companies like it want all your business, not just some of it,
    and go to great lengths to break common protocols. Here we go again-vendor lock-in.
    Sure, we will make our systems easy to use and easy to connect to other systems
    that you have paid us for, but forget it when it comes to talking to that UNIX
    server. Oh, you want access to the file server? Then buy our server and then your
    PCs will be able to talk to the server. So, thanks to vendor lock-in, we are stuck
    with the NetBIOS and NTLM services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of NTLM is to find systems and resources on the network. In an
    Active Directory Domain environment, Kerberos LDAP and DNS take care of logins
    and the location of shared network resources. DNS is a protocol of the TCP/IP
    suite for this use, and is the protocol we use every day on the internet to find
    what we are looking for. Windows does use DNS for system calls, but if a **fully
    qualified domain name** (**FQDN**) is not in use, then Windows defaults back to
    NTLM for a system lookup. Here is our attack vector: to make system lookups revert
    back to NTLM, so that information is now sent through ARP broadcasts, instead
    of direct calls to a DNS server using TCP or UDP to transmit the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user goes to connect to a service using a computer name, Windows looks
    at the following to resolve the name to an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: Local hosts file—`C:\Windows\System32\drivers\etc\hosts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NBNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could ask, how does a name lookup get past DNS to do a lookup? Well, by
    design. Windows may use DNS for lookups in a domain, but the system still likes
    to use the shortened version of the machine name, or their NetBIOS name, so instead
    of using DNS, the machine will send an ARP broadcast over the network. This will
    also happen when using an IP address to access a website, instead of a domain
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The domain controller, by default, will still accept this for login purposes.
    So instead of my machine logging in as, say, `//SRV1.companyname.net`, it logs
    in as `\\SRV1`. In these broadcast packets is my machine name, my IP address,
    my username, and my password, so that anyone passively listening on the network
    with a packet sniffer, such as Wireshark, can easily capture these credentials.
    A little ARP spoofing, and these credentials start popping all over the network,
    and then...
  prefs: []
  type: TYPE_NORMAL
- en: 'NTLM is still used in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is authenticating to a server using an IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client is authenticating to a server that belongs to a different Active
    Directory forest that has a legacy NTLM trust, instead of a transitive inter-forest
    trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client is authenticating to a server that doesn't belong to a domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No Active Directory domain exists (this is commonly referred to as workgroup
    or peer-to-peer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where a firewall would otherwise restrict the ports required by Kerberos (typically
    TCP 88)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, NTLM is like screaming your username and password in a crowded bar,
    whereas AD/DNS is more like a quiet conversation between two people.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing and capturing traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see the practical use of what we learned in [Chapter
    4](20fa14ea-ee8e-413e-80b6-bba429512e6c.xhtml), *Sniffing and Spoofing*, on sniffing
    and capturing tools. When we ran these tools in [Chapter 4](https://cdp.packtpub.com/kali_linux_2018_x__windows_penetration_testing_/wp-admin/post.php?post=332&action=edit#post_162), *Sniffing
    and Spoofing*, we captured both NTLM and clear-text passwords. We also found the
    location of prime targets. Here, we are going to use the golden keys gathered
    from the fruits of our labor. Normally, the first time you capture a hash and
    you look at it, you think, *What can I do with that? It's encrypted*. After all,
    weren't you told that, if it is encrypted, then it's protected? The truth is,
    over half the time when I breach a Windows system, I don't know the actual password.
    Why spend time cracking a password when you can just *Pass the Hash*?
  prefs: []
  type: TYPE_NORMAL
- en: Using Ettercap data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot is a copy of the captured data from our poisoning
    attack in [Chapter 4](https://cdp.packtpub.com/kali_linux_2018_x__windows_penetration_testing_/wp-admin/post.php?post=332&action=edit#post_162), *Sniffing
    and Spoofing*, using Ettercap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c146a3b2-3665-4866-8691-0853fc85aa59.png)'
  prefs: []
  type: TYPE_IMG
- en: NetBIOS scanning using NBTscan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working in a Windows Domain environment, your best results come from knowing
    the domain name you are attacking. You can sometimes gather some credentials using
    the default `WORKSTATION` group, but this handy little tool quickly finds the
    domain information you''re looking for. The following is the help file for NBTscan:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the help file from the command line, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run Ettercap first, the target list will give you some addresses to
    scan to find out the domain information quickly, or you can use this tool to scan
    the whole local subnet by using a CIDR network listing. For this network, it would
    be `172.16.42.0/24`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7978b14-0cd6-4226-aa62-8aa5bf952ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the domain name (`LAB1`) or the Workgroup name, we can move
    to using Responder next.
  prefs: []
  type: TYPE_NORMAL
- en: Responder - so many hashes, so little time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Responder.py** is a Python tool that attacks just about all vectors of NTLM
    and the SMB protocol. In the following screenshot, we have the Responder Help
    file. We will go over some of the options and their uses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the Responder Help file on Kali Linux from the command line, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4d9b9336-865f-4e05-b08b-6c9ef432ace4.png)'
  prefs: []
  type: TYPE_IMG
- en: The main flag you will have to use is the `-I` or `-interface= flag`, as you
    have to tell Responder which interface to use. All other flags are optional, but
    these flags give a lot of control to your attack.
  prefs: []
  type: TYPE_NORMAL
- en: Responder comes with its own password and hash gathering tools, but we can also
    use Metasploit to capture our loot, so we can then use these credentials in further
    attacks using Metasploit modules. We will cover both ways to gather captured credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will set up Responder to do its own thing and gather its own hashes.
    First is the `-I` flag-set this to the active interface. Here, it will be `wlan0`.
    This is the most important flag. Responder will run the default configuration
    without any other flags set, but the interface must be set in order to run. In
    the following command, I have also set `-w` to start the `wpad` server; the `-F`
    flag to force basic authentication on the `wpad` server, which will capture and
    `wpad` logins in clear text; the `-lm` flag in an attempt to downgrade the NTLM
    authentication to NTLMv1; the `-b` flag to downgrade NTLM HTTP connections to
    basic or clear text; the `-r` flag to redirect the `wpad` connection; and the
    `-d LAB1` flag to set the domain to attack. Then hit *Enter* to run. You then
    get a screen print of the running services and the attack will start. The full
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the attack starts, Responder poisons the SMB ARP broadcasts on the network.
    The best time to run this attack is when there is a lot of user traffic on the
    network. If this attack is run during off-hours, and there is no user traffic,
    then only system accounts will be captured. There has to be user traffic in order
    to capture user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we see the start of the poisoning attack and the
    capture of the Administrator account''s credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20faa5aa-a719-4e5c-b7d4-a7c76ef8aa90.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that we have captured the Administrator
    login from the `\\WIN10-01` workstation. This was captured when the user logged
    on to the domain from the workstation. Notice this is a NTLMv2 hash, which is
    a salted NTLMv1 hash. A salted hash is basically a re-hashed hash. During the
    challenge and response part of the SMB login, a 16-bit random hash value is exchanged.
    The NTLMv1 56-bit hash is then hashed with this random value. This new hash, which
    is then transmitted to the server, is the NTLMv2 hash value. Since the salt is
    a random value, the captured v2 hash is non-replayable, but the good news is that
    programs, such as good old John the Ripper or Hashcat, can crack these hashes
    offline. They just can't be used in a *Pass the Hash* style attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we have the login for `LAB1\rred`. Again, this
    is from the user logging into the domain, and the non-replayable NTLMv2 hash is
    captured again. After both captures, you will notice, a few lines down, that Responder
    again captures the login, but doesn''t repeat it onscreen. It is still logged
    to the log file as a separate hash. In the log file, you can see when the challenge
    and response hash changes from the non-replayable changes in the file. The actual
    password has not changed, but the challenge and response hashes have changed between
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/391ca14a-d7b4-4866-8c25-f7b517faf2af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we can see poisoned answers sent to the various
    machines on the network. Next, we can see the HTTP capture. This capture comes
    from setting the -b flag to downgrade HTTP logins to clear text, instead of using
    NTLM hashes for the password. As we can see, we have a set of user credentials
    in clear text. Jackpot! Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4166f23d-3109-438f-bb1c-63ddec607bf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After our little attack, let''s look at the logs. All screen output from the
    attack is stored in separate files in Responder''s logs directory. By default,
    this is found at `/usr/share/responder/logs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/102a3a61-5839-41e1-b551-7a8d8a69e681.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we see the various logs that were outputted during
    the attack. Responder does a very nice job of breaking this data down into usable
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: The `Analyzer-Session.log` on this run is blank. When you run the `-A` flag,
    the raw output of the NBT-NS responses is saved to this file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Config-Responder.log` file is an output of the configuration and the variables
    used during the attack when running Responder.
  prefs: []
  type: TYPE_NORMAL
- en: The `Poisoners-Session.log` is the session output of the poisoned sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HTTP-Basic-ClearText-<IPAddress>.txt` file is the output of the captured
    credentials captured from `<IPAddress>`. Each system''s captured credentials are
    kept in separate files. We can see two files from our attack listed in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/554f39fa-e1ee-4165-b47e-0408300df5c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `SMB-NTLMv2-<IPAddress>.txt` files are the captured non-replayable hashes
    and user accounts. This file is formatted in what is called *John* format. What
    this means is that John the Ripper will readily read the file without any extra
    formatting. Hashcat and most other password crackers will also read these files
    without a problem. While running the attack, the output shows the repeated capture
    but not the captured hashes. In the following screenshot, we see all the captured
    hashes. Notice the hash values are not the same in each capture, but the password
    hasn''t changed. This is the salt in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27254163-6e2e-4d61-8c76-cef9b7e8fbce.png)'
  prefs: []
  type: TYPE_IMG
- en: Delete all but one entry in the file before running it through your password
    cracker of choice. This will shorten your runtime, as the cracker will not have
    to run through all the different salts.
  prefs: []
  type: TYPE_NORMAL
- en: Using Responder with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to use Responder and send the captures to running Metasploit
    modules. This way, the credentials will be saved to the Metasploit database and
    the captured credentials can be used when running exploits from Metasploit. Basically,
    what we are going to do is disable the capture servers that come with the Responder
    toolkit, and run the same servers using Metasploit's capture servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the Responder''s servers, we''ll edit the Responder configuration
    file. The file is found at `/etc/responder/Responder.conf`. Open the file in your
    favorite text editor. At the top of the file, you see the list of servers with
    the configuration set to `On`-change these settings to `Off` and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9c2d461-d8e7-44b1-9332-083cd9b38544.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the file after the changes has been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19bb35a-eb23-40d2-aa81-782815ab0ebb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to fire up Metasploit and start the capture servers. To start
    Metasploit, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fire up the servers. The startup order doesn''t matter here, but these
    servers are the big three you''ll need for this attack. After changing into your
    workspace, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/131e8c77-7a26-4bb8-ac7b-f34138f0cb80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I find it best to set the `SRVHOST` setting. Keeping it at `0.0.0.0` will set
    the server to listen on all interfaces at the listed ports. Hard-setting the `SRVHOST`
    will cut down on any network/interface confusion. Especially if you are running
    several active interfaces, exploits can get confused about which way to go, or
    services such as `wpad` will actively listen on the wrong interface. Best to hard-set
    just to be sure. For this attack, the local IP address is `172.16.42.139`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To fire it off run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s fire up the SMB capture server with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/241649d8-ec9c-4c71-b42e-f531bbccf93c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, set the `SRVHOST`. You can use the arrow up key to go back to the properties
    with which you set it last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two methods to capture HTTP traffic. One is the `auxiliary/server/capture/http_ntlm`
    module. This module will capture the credentials in their NTLM hashes. These hashes
    will be replayable, since our attacking server sent the the challenge. The challenge
    salt value was defined previously-we see it set to `1122334455667788`. The captured
    hashes from this attack can be used in *Pass the Hash*-style attacks. To set and
    run this module, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ffe2c9ce-d224-4fb3-b7eb-c71b814914c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, set the `SRVHOST`. You can use the arrow up key to go back to the way
    that you set it last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `wpad` server is running on port `80`, we will need to move this
    service to a different HTTP port, so we will set it to run on port `443` and set
    SSL to true, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second method will cause the NTLM login to downgrade to clear text, just
    like the HTTP server that comes with Responder. Using this capture method, the
    credentials will be ready to use. You can only use one of these modules at a time.
    Attempting to run both will cause the second one to crash, and will sometimes
    cause the first HTTP server to start to hang.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up and start the HTTP basic capture server, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1a856477-c062-40d6-a332-52cb5989e931.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, set the `SRVHOST`. You can use the arrow up key to go back to the settings
    you specified last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated before, since the `wpad` server is running on port `80`, we will
    need to move this service to a different HTTP port, so we will set it to run on
    port `443` and set SSL to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/384cfceb-ec5d-4a33-9d8d-3b260aa6e99c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also can run a spoofer to help with the capture. This is the `auxiliary/spoof/nbns/nbns_response`
    module. The help file has the best description of this, so I''ve provided it here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description:'
  prefs: []
  type: TYPE_NORMAL
- en: This module forges **NetBIOS Name Service** (**NBNS**) responses. It will listen
    for NBNS requests sent to the local subnet's broadcast address and spoof a response,
    redirecting the querying machine to an IP of the attacker's choosing. Combined
    with `auxiliary/server/capture/smb` or `auxiliary/server/capture/http_ntlm` it
    is a highly effective means of collecting crackable hashes on common networks.
    This module must be run as root and will bind to UDP/137 on all interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'References:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.packetstan.com/2011/03/nbns-spoofing-on-your-way-to-world.html](http://www.packetstan.com/2011/03/nbns-spoofing-on-your-way-to-world.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our attack, we are going to spoof the domain controller. The domain controller''s
    IP address is `172.16.42.5` for this attack. So, let''s set up our spoofer and
    run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see right at the start that the module is spoofing the `wpad` request
    from `172.16.42.105`, and this is without Responder running yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9ed2693-7a23-4aae-9361-5d75e045a459.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to start Responder again. Start a new Terminal window on Kali
    and start Responder with the same flags as last time. The only difference in this
    run is that the poisoning attack will run, but the Responder servers will be disabled
    and Metasploit will catch the traffic this time around.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we see Metasploit spoofing and capturing the traffic
    from `172.16.42.105`. We can see the module responding to the address of the domain
    controller at `172.16.42.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed6ed5f1-24e8-4435-bbd7-5501ff618901.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we see the captured SMB traffic coming in, and
    we can tell these are NTLMv2 hashes by looking at the length of the challenge.
    If you run the `creds` command, the output will show these are non-replayable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbcf8cc6-a67e-4c6f-8ebc-6c151f4ed42d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By running the `creds` command, we can see the captured credentials, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70fc75f0-5531-4025-a1ca-16fd3b1d5594.png)'
  prefs: []
  type: TYPE_IMG
- en: OK, so these are non-replayable hashes, but we have a part of the puzzle that
    we don't get in normal captured traffic, such as what we captured with the Responder
    services. This time, we have the challenge salt. When we set up the SMB capture
    module, the challenge salt is set to `1122334455667788`. So, if we run this non-replayable
    hash through John the Ripper, along with the captured salted hash, we are basically
    now only cracking the NTLM hash and are not burning up CPU time calculating the
    salt. In the previous screenshot, the output is in John format, and we can this
    the challenge salt in the first section of the hash. This basically breaks the
    security of the salted hash
  prefs: []
  type: TYPE_NORMAL
- en: NetBIOS response BadTunnel brute force spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is also an NBNS name spoofer but, unlike the one previously discussed,
    this one will traverse firewall connections that use NAT. Most NetBIOS spoofers
    only work on the local network. Used along with other tools, this is a great spoofer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best description of how this spoofer works comes from the info file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Description:'
  prefs: []
  type: TYPE_NORMAL
- en: This module listens for a NetBIOS name request and then continuously spams NetBIOS
    responses to a target for the given hostname, causing the target to cache a malicious
    address for this name. On high-speed networks, the PPSRATE value should be increased
    to speed up this attack. As an example, a value of around 30,000 is almost 100%
    successful when spoofing a response for a WPAD lookup. Distant targets may require
    more time and lower rates for a successful attack. This module works when the
    target is behind a NAT gateway, since the stream of NetBIOS responses will keep
    the NAT mapping alive after the initial setup. To trigger the initial NetBIOS
    request to the Metasploit system, force the target to access a UNC link pointing
    to the same address (HTML, Office attachment, and so on). This NAT-piercing issue
    was named the BadTunnel vulnerability by the discoverer, Yu Yang (`@tombkeeper`).
    Microsoft patches (MS16-063/MS16-077) impact the way that the proxy host (WPAD)
    host is identified, but do not change the predictability of NetBIOS requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up this module, we will need to set the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get EvilGrade set up and running, we''ll run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our NBNS spoofer set up, let's set up EvilGrade and get it
    running.
  prefs: []
  type: TYPE_NORMAL
- en: EvilGrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EvilGrade is a modular framework that allows the user to exploit upgrade implementations
    by injecting fake updates, not only for Windows OSes but also for other popular
    Windows applications. The list is long. The framework comes with pre-made binaries
    (agents), but custom binaries can also be pushed to the victim machine. The framework
    comes with its own web server and DNS server modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the attack, we are going to exploit the Windows `wpad` service and push out
    a bad Windows update. Instead of using the pre-built binary, we will build our
    own payload so we can upload a Metasploit Meterpreter shell to the victim machine.
    This way we can use Metasploit tools for further compromising.
  prefs: []
  type: TYPE_NORMAL
- en: 'EvilGrade doesn''t come with the default install of Kali, so we will need to
    install it from the repository. So, leaving our BadTunnel window open, now open
    a new Terminal window and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After the install, we are ready to go. Open a new Terminal window and from
    the command line type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the following output. You will see a list of available modules
    as they load. The framework has an interface similar to Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd1bec9d-dc31-4e9d-b1d4-0fcc12ca5e64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows a continuation of the `modules` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22242ab4-90cc-4669-9304-a6d52c4c5cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By running `show options` we can see a list of modules. Notice all the modules
    for different types of application, including update services for hardware vendors.
    Yes, you can upload a rootkit to, say, an Acer or Lenovo laptop. This is beyond
    the scope of this book, but with a little configuration, much like what we are
    doing here, this tool will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Security note:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a big attack vector on Windows systems. Unlike Linux, where all packages
    can be downloaded from a central repository and verified by GPG keys, with Window
    applications each application depends on its own individual updater. This allows
    this style of attack to be used on many common applications which you would never
    normally consider as an attack vector. This is also the reason why, when working
    with Kali as shown in this book, you should download your applications from the
    repository, avoiding downloading and installing individual applications from other
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set the IP address for the DNS service. Type the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6d5e47f3-c123-4e39-8924-9099fd387cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re using Windows Update Service (wpad) in this attack, so to load the Windows
    Update module enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need our payload. To build the payload, we'll use MSFvenom. Open
    a new Terminal window and, from the command line, type the following code. The
    `-p` flag is the payload to be used. We are using the `windows/meterpreter/reverse_tcp`
    payload. Since this is a reverse shell, you must set the local host and local
    port for the payload to call to on the attacking machine. Our Kali machine is
    at `172.16.42.139`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set our port at `445`, a standard Windows port, and save it out using
    the `-o` flag to `/tmp/windowsupdate.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/35cce0f2-19da-4421-bb4f-8010723ab26b.png)'
  prefs: []
  type: TYPE_IMG
- en: We have saved the payload to `/tmp/windowsupdate.exe`, so we will need to set
    the agent to this path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the running EvilGrade framework window, type the following to set the payload
    to our custom payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3f277827-fadf-48a1-a3ac-cf3f39bbcc19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to allow the connection, we will need to set up a multi/handler to accept
    the in-bound connection once the system has been compromised. From our running
    Metasploit Terminal on which we have BadTunnel running in the background, we''ll
    start a `multi/handler` and run it also in the background. From within Metasploit,
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e89e7ba0-13e1-4c87-82bb-414e83240ae4.png)'
  prefs: []
  type: TYPE_IMG
- en: Ettercap setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ettercap is a great spoofing tool that we have used quite a bit in this book,
    and again, we''re going to whip it out. We need to spoof the DNS service and get
    it directed to our Kali box. Ettercap comes with a plugin just for this. On this
    attack, since our Kali box is local to the victim network, we can use the GUI
    version. You''ll find this under Sniffing & Spoofing | ettercap-graphical. The
    procedure goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up our DNS A records that we will use when spoofing.
    If this is the first time you have spoofed a DNS, you will need to make a new
    file with your favorite text editor. Add the following A records to the file.
    By wildcarding the records (`*.`), we should be good, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file to `/usr/share/ettercap/etter.dns`. Close the editor-your spoofed
    records are ready to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b546ecbf-cdd4-4ec5-864e-fc61307dee55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to set the active interface to spoof traffic from, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af955885-cb75-4cff-93ba-0fff8b00dbfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll need to activate the DNS spoofing plugin. In the menu bar, go
    to Plugins, then Manage the plugins. This will give you a window listing all the
    various plugins available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31b5dda6-c956-4da2-827a-87931d64fbb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, pick dns_spoof from the list and double-click it. A star will appear
    on the left to show it is activated. You will also see this in the text window
    at the bottom of Ettercap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6061473b-580d-4488-819b-2385a3a3a2eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, let''s run a scan to find our targets, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a66b409d-6b93-43bb-8e1a-b9bb488afed1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the scan, we need to pick the router as target 1, and our target machine
    (`win7-01`) as target 2\. You can do this by picking the address and right-clicking
    it-a menu will allow you to set the target number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d7ffae8-ccd6-4a34-a14d-7ce1a2c30f27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After picking the targets, you can view them by going to Targets | Current
    Targets in the menu bar. To start the process, go to Mitm | ARP Poisoning in the
    menu bar and click. You will get a box to set the type of sniffing. Once this
    starts, you can watch the output in the bottom screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2df5a3a-a3e9-4ba5-9282-c7989ab43f5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're all set up now, and our attack is fully running. We have Metasploit running
    BadTunnel NBNS spoofing, EvilGrade running both a DNS server and a web server
    to hand out the update with a bogus Windows Update site running. We have also
    set up our handler for the payload to connect to. Now we're just waiting for our
    unsuspecting victim to update their Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows workstation, when the victim uses IE to manually update their
    system, they are presented with the following page. Looks pretty normal-you can
    see that the address in the address bar says the site is [http://www.microsoft.com](http://www.microsoft.com).
    No real warning signs that this isn't Microsoft's site.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s click and update our computer! You know to keep it safe and secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb7f4556-8d5f-4a44-84ad-c4cee3b7a03e.png)'
  prefs: []
  type: TYPE_IMG
- en: We click on the Download and Install Now button and we get a normal file download
    box offering an `update97543.exe` file. It even appears to be signed by `windowsupdate.microsoft.com`.
    Surely the file is legit?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click Run and get our update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4477fb6-8257-4591-b9b7-4acf1006936e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are logged in as rred and Randy Red is a peon user, so we are given a UAC
    login. We get the administrator and they log in to run the update. If the user
    already has admin rights, a UAC box will still appear but you can click OK as
    normal, and all is good. Makes you wonder about UAC security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a301b08c-26e3-4c2d-a8eb-154bbae9f5df.png)'
  prefs: []
  type: TYPE_IMG
- en: The file runs, and as with most updates, the system doesn't really do anything
    after installing the update. The user goes back to work thinking the world is
    good. Let's look at what is happening on our Kali box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hmm-it seems we have a session opened with fflintstone, the user with admin
    rights. We are under rred''s account, but we have the admin rights fflintstone.
    To interact with the session type, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d0a08e62-6d3f-400f-ad0e-c542bcafffb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of this, just like the message says here, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/833e721e-cf81-49eb-afc7-f5b5a226a539.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our running EvilGrade Terminal, we can see the interaction of the victim
    machine with our evil server. In the following screenshot, you can see the malicious
    web page being uploaded to the victim:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae8dd23e-d32a-47d0-be1a-3021ad98bf4c.png)'
  prefs: []
  type: TYPE_IMG
- en: So there you have it-updates may not be as safe as you think. Always update
    from a secured network. Again, take a look back at the list of systems and applications
    that can easily be attacked using this method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Windows security methods, such as the UAC, did nothing to stop this
    attack. To the system, it appeared that it called home and was talking to Momma,
    and Momma would never feed you anything bad.
  prefs: []
  type: TYPE_NORMAL
- en: With Linux systems, this attack will fail when using apt-get or yum on RedHat
    systems. Yes, you can spoof the repository site, but when the update (in reality,
    our payload) is downloaded, it will fail to install, because all repository packages
    are signed with a GPG key. Since our bogus update isn't signed, our attack fails
    epically. There's something to be said for using GPG and public/private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the workings of the NTLM and LLMR protocols
    and their inherent weaknesses. You have learned how to poison network traffic
    to capture user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned how to use many tools, such as Responder and Etthercap,
    in unison to exploit your target system. And finally, we learned how to spoof
    an update service, such as Windows Update, and exploit the system using this service.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub for Responder can be found here: [https://github.com/SpiderLabs/Responder](https://github.com/SpiderLabs/Responder)
  prefs: []
  type: TYPE_NORMAL
- en: The Ettecap project page can be found here: [https://www.ettercap-project.org/](https://www.ettercap-project.org/)
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on the MS17-010 (EternalBlue) Vulnerability can be found at
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0143/](https://cvedetails.com/cve/CVE-2017-0143/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0144/](https://cvedetails.com/cve/CVE-2017-0144/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0145/](https://cvedetails.com/cve/CVE-2017-0145/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0146/](https://cvedetails.com/cve/CVE-2017-0146/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0147/](https://cvedetails.com/cve/CVE-2017-0147/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cvedetails.com/cve/CVE-2017-0148/](https://cvedetails.com/cve/CVE-2017-0148/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://technet.microsoft.com/en-us/library/security/MS17-010](https://technet.microsoft.com/en-us/library/security/MS17-010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html](https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/countercept/doublepulsar-detection-script](https://github.com/countercept/doublepulsar-detection-script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://technet.microsoft.com/en-us/library/security/ms17-010.aspx](https://technet.microsoft.com/en-us/library/security/ms17-010.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information from the author on SMB spoofing and how to fix the problem
    can be found here: [http://www.boweaver.com/security/ntlm.php](http://www.boweaver.com/security/ntlm.php)
  prefs: []
  type: TYPE_NORMAL
