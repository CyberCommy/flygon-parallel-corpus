- en: '5: The Docker Engine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll take a quick look under the hood of the Docker Engine.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Docker without understanding any of the things we’ll cover in this
    chapter. So, feel free to skip it. However, to be a real master of anything, you
    need to understand what’s going on under the hood. So, to be a *real* Docker master,
    you need to know the stuff in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a theory-based chapter with no hands-on exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this chapter is part of the **Technical section** of the book, we’re going
    to employ the three-tiered approach where we split the chapter into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The TLDR:** Two or three quick paragraphs that you can read while standing
    in line for a coffee'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The deep dive:** The really long bit where we get into the detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The commands:** A quick recap of the commands we learned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go and learn about the Docker Engine!
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Docker engine* is the core software that runs and manages containers. We
    often refer to it simply as *Docker*, or *the Docker platform*. If you know a
    thing or two about VMware, it might be useful to think of it as being like ESXi.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker engine is modular in design with many swappable components. Where
    possible, these are based on open-standards outlined by the Open Container Initiative
    (OCI).
  prefs: []
  type: TYPE_NORMAL
- en: 'In many ways, the Docker Engine is like a car engine — both are modular and
    created by connecting many small specialized parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A car engine is made from many specialized parts that work together to make
    a car drive — intake manifolds, throttle body, cylinders, spark plugs, exhaust
    manifolds etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Engine is made from many specialized tools that work together to
    create and run containers — APIs, execution driver, runtime, shims etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the time of writing, the major components that make up the Docker engine
    are: the *Docker client*, the *Docker daemon*, *containerd*, and *runc*. Together,
    these create and run containers.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 shows a high-level view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1](images/figure5-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book we’ll refer to `runc` and `containerd` with lower-case “r”
    and “c”. This means sentences starting with either `____r____unc` `____c____ontainerd`
    will not start with a capital letter. This is intentional and not a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine - The Deep Dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When Docker was first released, the Docker engine had two major components:'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon (hereafter referred to as just “the daemon”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LXC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker daemon was a monolithic binary. It contained all of the code for
    the Docker client, the Docker API, the container runtime, image builds, and **much**
    more.
  prefs: []
  type: TYPE_NORMAL
- en: LXC provided the daemon with access to the fundamental building-blocks of containers
    that existed in the Linux kernel. Things like *namespaces* and *control groups
    (cgroups)*.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2\. shows how the daemon, LXC, and the OS, interacted in older versions
    of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 Previous Docker architecture](images/figure5-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 Previous Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of LXC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reliance on LXC was an issue from the start.
  prefs: []
  type: TYPE_NORMAL
- en: First up, LXC is Linux-specific. This was a problem for a project that had aspirations
    of being multi-platform.
  prefs: []
  type: TYPE_NORMAL
- en: Second up, being reliant on an external tool for something so core to the project
    was a huge risk that could hinder development.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Docker. Inc. developed their own tool called *libcontainer* as
    a replacement for LXC. The goal of *libcontainer* was to be a platform-agnostic
    tool that provided Docker with access to the fundamental container building-blocks
    that exist inside the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Libcontainer replaced LXC as the default *execution driver* in Docker 0.9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of the monolithic Docker daemon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Over time, the monolithic nature of the Docker daemon became more and more
    problematic:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to innovate on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It got slower.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It wasn’t what the ecosystem (or Docker, Inc.) wanted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker, Inc. was aware of these challenges, and began a huge effort to break
    apart the monolithic daemon and modularize it. The aim of this work was to break
    out as much of the functionality as possible from the daemon, and re-implement
    it in smaller specialized tools. These specialized tools can be swapped out, as
    well as easily re-used by third parties to build other tools. This plan follows
    the tried-and-tested Unix philosophy of building small specialized tools that
    can be pieced together into larger tools.
  prefs: []
  type: TYPE_NORMAL
- en: This work of breaking apart and re-factoring the Docker engine is an ongoing
    process. However, it has already seen **all of the *container execution* and container
    *runtime* code entirely removed from the daemon and refactored into small, specialized
    tools**.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 shows a high-level view of the current Docker engine architecture
    with brief descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3](images/figure5-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3
  prefs: []
  type: TYPE_NORMAL
- en: The influence of the Open Container Initiative (OCI)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While Docker, Inc. was breaking the daemon apart and refactoring code, the
    [OCI](https://www.opencontainers.org/) was in the process of defining two container-related
    specifications (a.k.a. standards):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Image spec](https://github.com/opencontainers/image-spec)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Container runtime spec](https://github.com/opencontainers/runtime-spec/blob/master/RELEASES.md)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both specifications were released as version 1.0 in July 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, Inc. was heavily involved in creating these specifications and contributed
    a lot of code to them.
  prefs: []
  type: TYPE_NORMAL
- en: As of Docker 1.11 (early 2016), the Docker engine implements the OCI specifications
    as closely as possible. For example, the Docker daemon no longer contains any
    container runtime code — all container runtime code is implemented in a separate
    OCI-compliant layer. By default, Docker uses a tool called *runc* for this. runc
    is the *reference implementation* of the OCI container-runtime-spec. This is the
    `runc` container runtime layer in Figure 5.3\. A goal of the runc project be in-line
    with the OCI spec. However, now that the OCI spec’s are both at 1.0, we shouldn’t
    expect them to iterate too much — stability is the name of the game here.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this, the *containerd* component of the Docker Engine makes sure
    Docker images are presented to *runc* as valid OCI bundles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The Docker engine implemented portions of the OCI specs before the
    specs were officially released as version 1.0.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: runc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As previously mentioned, *runc* is the reference implementation of the OCI container-runtime-spec.
    Docker, Inc. was heavily involved in defining the spec and developing runc.
  prefs: []
  type: TYPE_NORMAL
- en: If you strip everything else away, runc is a small, lightweight CLI wrapper
    for libcontainer (remember that libcontainer originally replaced LXC in the early
    Docker architecture).
  prefs: []
  type: TYPE_NORMAL
- en: runc has a single purpose in life — create containers. And it’s damn good at
    it. And fast! But as it’s a CLI wrapper, it’s effectively a standalone container
    runtime tool. This means you can download and build the binary, and you’ll have
    everything you need to build and play with runc (OCI) containers. But it’s bare
    bones, you’ll have none of the richness that you get with the full-blown Docker
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes call the layer that runc operates at, “the OCI layer”. See Figure
    5.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see runc release information at:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/opencontainers/runc/releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: containerd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the effort to strip functionality out of the Docker daemon, all of
    the container execution logic was ripped out and refactored into a new tool called
    containerd (pronounced container-dee). Its sole purpose in life was to manage
    container lifecycle operations — `start | stop | pause | rm...`.
  prefs: []
  type: TYPE_NORMAL
- en: containerd is available as a daemon for Linux and Windows, and Docker has been
    using it on Linux since the 1.11 release. In the Docker engine stack, containerd
    sits between the daemon and runc at the OCI layer. Kubernetes can also use containerd
    via cri-containerd.
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, containerd was originally intended to be small, lightweight,
    and designed for a single task in life — container lifecycle operations. However,
    over time it has branched out and taken on more functionality. Things like image
    management.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons for this, is to make it easier to use in other projects.
    For example, containerd is a popular container runtime in Kubernetes. However,
    in projects like Kubernetes, it was beneficial for containerd to be able to do
    additional things like push and pull images. For these reasons, containerd now
    does a lot more than simple container lifecycle management. However, all the extra
    functionality is modular and optional, meaning you can pick and choose which bits
    you want. So it’s possible to include containerd in projects such as Kubernetes,
    but only to take the pieces your project needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'containerd was developed by Docker, Inc. and donated to the Cloud Native Computing
    Foundation (CNCF). It released version 1.0 in December 2017\. You can see release
    information at:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/containerd/containerd/releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new container (example)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have a view of the big picture, and some of the history, let’s walk
    through the process of creating a new container.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way of starting containers is using the Docker CLI. The following
    `docker container run` command will start a simple new container based on the
    `alpine:latest` image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`When you type commands like this into the Docker CLI, the Docker client converts
    them into the appropriate API payload and POSTs them to the correct API endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: The API is implemented in the daemon. It is the same rich, versioned, REST API
    that has become a hallmark of Docker, and is accepted in the industry as the de
    facto container API.
  prefs: []
  type: TYPE_NORMAL
- en: Once the daemon receives the command to create a new container, it makes a call
    to containerd. Remember that the daemon no-longer contains any code to create
    containers!
  prefs: []
  type: TYPE_NORMAL
- en: The daemon communicates with containerd via a CRUD-style API over [gRPC](https://grpc.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Despite its name, *containerd* cannot actually create containers. It uses *runc*
    to do that. It converts the required Docker image into an OCI bundle and tells
    runc to use this to create a new container.
  prefs: []
  type: TYPE_NORMAL
- en: runc interfaces with the OS kernel to pull together all of the constructs necessary
    to create a container (namespaces, cgroups etc.). The container process is started
    as a child-process of runc, and as soon as it is started runc will exit.
  prefs: []
  type: TYPE_NORMAL
- en: Voila! The container is now started.
  prefs: []
  type: TYPE_NORMAL
- en: The process is summarized in Figure 5.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4](images/figure5-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4
  prefs: []
  type: TYPE_NORMAL
- en: One huge benefit of this model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having all of the logic and code to start and manage containers removed from
    the daemon means that the entire container runtime is decoupled from the Docker
    daemon. We sometimes call this “daemonless containers”, and it makes it possible
    to perform maintenance and upgrades on the Docker daemon without impacting running
    containers!
  prefs: []
  type: TYPE_NORMAL
- en: In the old model, where all of container runtime logic was implemented in the
    daemon, starting and stopping the daemon would kill all running containers on
    the host. This was a huge problem in production environments — especially when
    you consider how frequently new versions of Docker are released! Every daemon
    upgrade would kill all containers on that host — not good!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is no longer a problem.
  prefs: []
  type: TYPE_NORMAL
- en: What’s this shim all about?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of the diagrams in the chapter have shown a shim component.
  prefs: []
  type: TYPE_NORMAL
- en: The shim is integral to the implementation of daemonless containers (what we
    just mentioned about decoupling running containers from the daemon for things
    like daemon upgrades).
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that *containerd* uses runc to create new containers. In
    fact, it forks a new instance of runc for every container it creates. However,
    once each container is created, its parent runc process exits. This means we can
    run hundreds of containers without having to run hundreds of runc instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a container’s parent runc process exits, the associated containerd-shim
    process becomes the container’s parent. Some of the responsibilities the shim
    performs as a container’s parent include:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping any STDIN and STDOUT streams open so that when the daemon is restarted,
    the container doesn’t terminate due to pipes being closed etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reports the container’s exit status back to the daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it’s implemented on Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On a Linux system, the components we’ve discussed are implemented as separate
    binaries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dockerd` (the Docker daemon)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-containerd` (containerd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-containerd-shim` (shim)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-runc` (runc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see all of these on a Linux system by running a `ps` command on the
    Docker host. Obviously, some of them will only be present when the system has
    running containers.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s the point of the daemon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With all of the execution and runtime code stripped out of the daemon you might
    be asking the question: “what is left in the daemon?”.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the answer to this question will change over time as more and more
    functionality is stripped out and modularized. However, at the time of writing,
    some of the major functionality that still exists in the daemon includes; image
    management, image builds, the REST API, authentication, security, core networking,
    and orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker engine is modular in design and based heavily on open-standards from
    the OCI.
  prefs: []
  type: TYPE_NORMAL
- en: The *Docker daemon* implements the Docker API which is currently a rich, versioned,
    HTTP API that has developed alongside the rest of the Docker project.
  prefs: []
  type: TYPE_NORMAL
- en: Container execution is handled by *containerd*. containerd was written by Docker,
    Inc. and contributed to the CNCF. You can think of it as a container supervisor
    that handles container lifecycle operations. It is small and lightweight and can
    be used by other projects and third-party tools. For example, it’s poised to become
    the default, and most common, container runtime in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: containerd needs to talk to an OCI-compliant container runtime to actually create
    containers. By default, Docker uses *runc* as its default container runtime. runc
    is the de facto implementation of the OCI container-runtime-spec and expects to
    start containers from OCI-compliant bundles. containerd talks to runc and ensures
    Docker images are presented to runc as OCI-compliant bundles.
  prefs: []
  type: TYPE_NORMAL
- en: runc can be used as a standalone CLI tool to create containers. It’s based on
    code from libcontainer, and can also be used by other projects and third-party
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still a lot of functionality implemented in the Docker daemon. More
    of this may be broken out over time. Functionality currently still inside of the
    Docker daemon include, but is not limited to: the API, image management, authentication,
    security features, core networking, and volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: The work of modularizing the Docker engine is ongoing.`
  prefs: []
  type: TYPE_NORMAL
