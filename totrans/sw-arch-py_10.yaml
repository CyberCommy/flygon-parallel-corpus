- en: Chapter 10. Techniques for Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging a program can often be as hard, or sometimes, even more difficult
    than writing it. Quite often, programmers seem to spend an awful amount of time
    hunting for that elusive bug, the reason for which may be staring them in the
    face, yet not revealing itself.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers, even the good ones, find troubleshooting a difficult art. Most
    often, programmers resort to complicated debugging techniques when simple approaches
    such as properly placed print statements and strategically commented code would
    do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with its own set of problems when it comes to debugging code. Being
    a dynamically typed language, type-related exceptions, which happen due to the
    programmer assuming a type to be something (when it's something else), are pretty
    common in Python. Name errors and attribute errors fall in a similar category
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will exclusively focus on this lesser discussed aspect of
    software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a topic wise listing of what we are going to encounter in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maximum subarray problem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of "print"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis and rewrite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing and optimizing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple debugging tricks and techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program—debugging step 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program—debugging step 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program—final code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping blocks of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External dependencies—using wrappers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing functions with their return value/data (Mocking)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving to/loading data from files as cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving to/loading data from memory as cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning random/mock data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random patient data
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging as a debugging technique:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple application logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced logging—logger objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced logging—custom formatting and loggers
  prefs: []
  type: TYPE_NORMAL
- en: Advanced logging—writing to syslog
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging tools—using debuggers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugging session with pdb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pdb—similar tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPdb
  prefs: []
  type: TYPE_NORMAL
- en: Pdb++
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced debugging—tracing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trace module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lptrace program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System call tracing using strace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, so let's debug it!
  prefs: []
  type: TYPE_NORMAL
- en: Maximum subarray problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For starters, let us look at an interesting problem. In this problem, the goal
    is to find the maximum contiguous subarray of an array (sequence) of integers
    having mixed negative and positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is pretty obvious with a quick scan that the maximum sum is for the subarray
    `[20, -10, 30, 15]`, giving a sum of `55`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us say, as a first cut, you write this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This output seems clearly wrong, as any manual addition of any subarray in the
    array doesn't seem to yield a number more than 55\. We need to debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: The power of "print"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to debug the preceding example, a simple, strategically-placed **"print"**
    statement does the trick. Let''s print out the sub-sequences in the inner `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'max_subarray: v1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the code executes and prints this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The problem is clear now by looking at the output of the print statements.
  prefs: []
  type: TYPE_NORMAL
- en: There is a subarray `[20, 30, 15]` (highlighted in bold in the preceding output),
    which produces the sum *65*. However, this is *not a valid subarray*, as the elements
    are not contiguous in the original array.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the program is wrong and needs a fix.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis and rewrite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quick analysis tells us that the use of `itertools.combinations` is the culprit
    here. We used it as a way to quickly generate all the subarrays of different lengths
    from the array, but using combinations *does not* respect the order of items,
    and generates *all* combinations producing subarrays that are not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, we need to rewrite this. Here is a first attempt at the rewrite:'
  prefs: []
  type: TYPE_NORMAL
- en: 'max_subarray: v2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The answer is not correct again, as it gives the suboptimal answer *40*, not
    the correct one, which is, *55*. Again, the print statement comes to the rescue,
    as it tells us clearly that the main array itself is not being considered—we have
    an *off-by-one* bug.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An off-by-one or one-off error occurs in programming when an array index used
    to iterate over a sequence (array) is off either by *one less* or *one more* than
    the correct value. This is often found in languages where the index for sequences
    start from zero such as C/C++, Java, or Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the *off-by-one* error is in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct code should, instead, be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this fix, our code produces the output as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'max_subarray: v2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let us assume at this point that you consider the code to be complete.
  prefs: []
  type: TYPE_NORMAL
- en: You pass the code on to a reviewer, and they mention that your code, though
    called `max_subarray`, actually forgets to return the subarray itself, instead
    returning only the sum. There is also the feedback that you don't need to maintain
    an array of sums.
  prefs: []
  type: TYPE_NORMAL
- en: 'You combine this feedback and produce a version 3.0 of the code, which fixes
    both the issues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'max_subarray: v3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we removed the print statement in this last version, as the logic
    was already correct, and so, there was no need of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: All good.
  prefs: []
  type: TYPE_NORMAL
- en: Timing and optimizing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you analyze the code a bit, you'll find that the code performs two passes
    through the full sequence, one outer and one inner. So if the sequence contains
    *n* items, the code performs *n*n* passes.
  prefs: []
  type: TYPE_NORMAL
- en: We know from [Chapter 4](part0031.xhtml#aid-TI1E1 "Chapter 4. Good Performance
    is Rewarding!"), *Good Performance is Rewarding!*, on performance that such a
    piece of code performs at the order of *O(n2)*. We can measure the real time spent
    on the code by using a simple `context-manager` using the `with` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our context manager looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us modify the code to create an array of random numbers of different sizes
    to measure the time taken. We will write a function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us time our logic for various sizes of arrays, beginning with 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For an array of 1000, the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So this takes about 3.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: It can be shown that with an input size of 10000, the code will take around
    2 to 3 hours to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a way to optimize the code? Yes, there is an *O(n)* version of the
    same code, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this version, the time taken is much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For an array of 1000, the time taken is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For an array of 10000, the time is around 44 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Simple debugging tricks and techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw the power of the simple `print` statement in the previous example. In
    a similar way, other simple techniques can be used to debug programs without requiring
    to resort to a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging can be thought of as a step-wise process of exclusion until the programmer
    arrives at the truth—the cause of the bug. It essentially involves the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the code and come up with a set of probable assumptions (causes) that
    may be the source of the bug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test out each of the assumptions one by one by using appropriate debugging techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At every step of the test, you either arrive at the source of the bug—as the
    test succeeds telling you the problem was with the specific cause you were testing
    for; or the test fails and you move on to test the next assumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You repeat the last step until you either arrive at the cause or you discard
    the current set of probable assumptions. Then you restart the entire cycle until
    you (hopefully) find the cause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at some simple debugging techniques one by one
    using examples. We will start with the example of a word searcher program that
    looks for lines containing a specific word in a list of files—and appends and
    returns the lines in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the listing of the code for the word searcher program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed a subtle bug in the preceding code—it appends to the wrong
    list. It reads from the list "lines", and appends to the same list, which will
    cause the list to grow forever; the program will go into an infinite loop when
    it encounters even a single line containing the given word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the program on the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: On any day, you may find this bug easily. On a bad day you may be stuck on this
    for a while, not noticing that the same list being read from is being appended
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things that you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: As the code is hanging and there are two loops, find out the loop that causes
    the problem. To do this, either put a print statement between the two loops, or
    put a `sys.exit` function, which will cause the interpreter to exit at that point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A print statement can be missed by a developer, especially if the code has many
    other print statements, but a `sys.exit` can never be missed of course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word searcher program—debugging step 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code is rewritten as follows to insert a specific `sys.exit(…)` call between
    the two loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying it out a second time, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now it's pretty clear that the problem is not in the first loop. You can now
    proceed to debug the second loop (we are assuming that you are totally blind to
    the wrong variable usage, so you are figuring out the issue the hard way, by debugging).
  prefs: []
  type: TYPE_NORMAL
- en: Word searcher program—debugging step 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you suspect a block of code inside a loop to be causing a bug, there
    are a few tricks to debug this, and confirm your suspicion. These include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a strategic continue just preceding the block of code. If the problem disappears,
    then you've confirmed that the specific block or any next block that is the issue.
    You can continue to move down your `continue` statement until you identify the
    specific block of code that is causing the issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make Python skip the code block by prefixing it with an `if 0:`. This is more
    useful if the block is a line of code or a few lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a lot of code inside a loop, and the loop executes many times, print
    statements may not help you much, as a ton of data will be printed, and it would
    be difficult to sift and scan through it and find out where the problem is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, we will use the first trick to figure out the issue. Here is
    the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now the code executes, making it pretty clear that the problem is in the processing
    step. Hopefully, from there it is just one step to figure out the bug, as the
    programmer has finally got his eye on the line causing the issue by way of the
    process of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Word searcher program—final code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We spent some time figuring out issues in the program by a couple of debugging
    steps documented in the previous sections. With this our hypothetical programmer
    was able to find the issue in the code and solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final code with the bug fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let us summarize the simple debugging tricks that we've learned so far in this
    section, and also look at a few related tricks and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping blocks of code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A programmer can skip code blocks that they suspect of causing a bug during
    debugging. If the block is inside a loop, this can be done by skipping execution
    with a `continue` statement. We've seen an example of this already.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the block is outside of a loop, this can be done by using an `if 0`, and
    moving the suspect code to the dependent block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the bug disappears after this, then you're sure that the problem lies in
    the suspected blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: This trick has its own deficiency, in that it requires indenting large blocks
    of code to the right, which once the debugging is finished, should be indented
    back. Hence it is not advised for anything more than 5-6 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're in the middle of a hectic programming session, and you're trying to
    figure out an elusive bug, having already tried print statements, using the debugger,
    and other approaches, a rather drastic, but often fantastically useful, approach
    is to stop the execution just before or at the suspected code path using a function,
    `sys.exit` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `sys.exit(<strategic message>)` stops the program dead in its tracks, so
    this *can''t be missed* by the programmer. This is often very useful in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: A complex piece of code has an elusive bug depending upon specific values or
    ranges of input, which causes an exception that is caught and ignored, but later
    causes an issue in the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, checking for the specific value or range, and then exiting the
    code using the right message in the exception handler via `sys.exit` will allow
    you to pinpoint the problem. The programmer can then decide to fix the issue by
    correcting the input or variable processing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing concurrent programs, wrong usage of resource locking or other issues
    can make it difficult to track bugs like deadlocks, race conditions, and others.
    Since debugging multithreaded or multiple process programs via the debugger is
    very difficult, a simple technique is to put a `sys.exit` in the suspect function
    after implementing the correct exception-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: When your code has a serious memory leak or an infinite loop, then it becomes
    difficult to debug after a while, and you're not able to pinpoint the problem
    otherwise. Moving a `sys.exit(<message>)` line from one line of code to the next
    until you identify the problem can be used as a last resort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External dependencies—using wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cases where you suspect the problem is not inside your function, but in a
    function that you are calling from your code, this approach can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Since the function is outside of your control, you can try and replace it with
    a wrapper function in a module where you have control.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is generic code for processing serial JSON data.
    Let us assume that the programmer finds a bug with processing of certain data
    (maybe having a certain key-value pair), and suspects the external API to be the
    source of the bug. The bug may be that the API times out, returns a corrupt response,
    or in the worst case, causes a crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to verify this is to *dummy* or *fake* the API for the specific ranges
    or values of the data. In this case, it can be done by creating a wrapper function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If your suspicion is indeed correct, this will cause the problem to disappear.
    You can then use this as a test code, and communicate with the stakeholders of
    the external API to get the problem fixed, or write code to make sure that the
    problem key-value pair is skipped in data sent to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing functions with their return value/data (Mocking)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern web application programming, you are never too far away from a blocking
    I/O call in your program. This can be a simple URL request, a slightly involved
    external API request, or maybe a costly database query and such calls can be the
    sources of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find either of the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The return data from such a call could be the cause of an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call itself is the cause of an issue, such as I/O or network errors, timeouts,
    or resource contentions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you encounter problems with costly I/O, replicating them can often be
    a problem. This is because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The I/O calls take time, so debugging this costs you a lot of wasted time, not
    allowing you to focus on the real issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequent calls may not be repeatable with respect to the issue, as external
    requests may return slightly different data every time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using an external paid API, the calls may actually cost you money,
    so you cannot exhaust a lot of such calls on debugging and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common technique that is very useful in these cases is to save the return
    data of these APIs/functions, and then mock the functions by using their return
    data to replace the functions/APIs themselves. This is an approach similar to
    mock testing, but it is used in the context of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example of an API that returns *business listings* on websites,
    given a business address including details like its name, street address, city,
    and so on. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code makes a few assumptions, one of which is that every site has the same
    API URL and parameters. Note that this is only for illustration purposes. In reality,
    each site will have very different API formats including its URL and the parameters
    it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this last piece of code, the actual work is being done in the `process_listings`
    function, the code for which is not shown, as the example is illustrative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you are trying to debug this function. However, due to a delay or
    error in the API calls, you find you are wasting a lot of valuable time in fetching
    the listings themselves. What are some of the techniques that you can use to avoid
    this dependency? Here are a few things that you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of fetching listings via API, save them to files, to a database, or
    an in-memory store, and load them on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache the return value of the `api_search` function via a caching or memoize
    patterns so that further calls after the first call, return data from memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock the data, and return random data that has the same characteristics as the
    original data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Saving to / loading data from files as cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this technique, you construct a filename using unique keys from the input
    data. If a matching file exists on disk, it is opened and the data is returned,
    otherwise, the call is made and the data is written. This can be achieved by using
    a *file caching* decorator as the following code illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how this preceding code works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `api_search` function is decorated with `filecache` as a decorator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filecache` uses `unique_key` as the function to calculate the unique filename
    for storing the results of an API call. In this case, the `unique_key` function
    uses the hash of a combination of the business name, street, and city, plus the
    site queried for in order to build the unique value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time the function is called, the data is fetched via API and stored
    in the file. During further invocations, the data is returned directly from the
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This works pretty well in most cases. Most data is loaded just once, and on
    further calls, returned from the file cache. However, this suffers from the problem
    of *stale data*, as once the file is created, the data is always returned from
    it. Meanwhile, the data on the server may have changed.
  prefs: []
  type: TYPE_NORMAL
- en: This can be solved by using an in-memory key-value store and saving the data
    there instead of in files on disk. One can use well-known key-value stores such
    as **Memcached**, **MongoDB**, or **Redis** for this purpose. In the following
    example, we'll show you how to replace the `filecache` decorator with a *memorycache*
    decorator using Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Saving to / loading data from memory as cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this technique, a unique in-memory cache key is constructed using unique
    values from the input arguments. If the cache is found on the cache store by querying
    using the key, its value is returned from the store; or else the call is made
    and the cache is written. To ensure that data is not too stale, a fixed **time-to-live**
    (**TTL**) is used. We use Redis as the cache store engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are reusing the definition of `unique_key` from the previous code
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing that changes in the rest of the code is that we replace the
    `filecache` decorator with the `memoize` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages of this version over the previous one are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The cache is stored in memory. No additional files are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cache is created with a TTL, beyond which it expires. So the problem of
    stale data is circumvented. The TTL is customizable, and defaults to a day (86400
    seconds) in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few other techniques for mocking external API calls and similar
    dependencies. Some of these are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `StringIO` object in Python to read/write data, instead of using a file.
    For example, the `filecache` or `memoize` decorators can be easily modified to
    use a `StringIO` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a mutable default argument, such as a dictionary or a list, as a cache
    and writing results to it. Since a mutable argument in Python holds its state
    after repeated calls, it effectively works as an in-memory cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing an external API with a call to a replacement/dummy API call to a service
    on the local machine (`127.0.0.1` IP address) by editing the system host's file,
    adding an entry for the host in question, and putting its IP as `127.0.0.1`. The
    call to localhost can always return a standard (canned) response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, on Linux and other POSIX systems, you can add a line like this
    in the `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this technique is a very useful and clever approach as long as you
    remember to comment out such lines after testing!
  prefs: []
  type: TYPE_NORMAL
- en: Returning random/mock data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another technique, which is mostly useful for performance testing and debugging,
    is to feed functions with data that is *similar*, but *not the same* as the original
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Let us say, for example, that you are working on an application that works with
    patient/doctor data for patients under a specific insurance scheme (say Medicare/Medicaid
    in the US, ESI in India) to analyze and find out patterns such as common ailments,
    top 10 health issues in terms of government expenses, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let us say that your application is expected to load and analyze tens of thousands
    of rows of patient data from a database at one time, which is expected to scale
    to 1-2 million under peak load. You want to debug the application, and find out
    performance characteristics under such load, but you don't have any real data,
    as the data is in the collection stage.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, libraries or functions that generate and return mock data
    are very useful. In this section, we will use a third-party Python library to
    accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random patient data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let us assume that, for a patient, we need the following basic fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health Issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doctor's Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blood Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insured or Not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date of last visit to doctor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `schematics` library in Python provides a way to generate such data structures
    using simple types, which can then be validated, transformed, and also mocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `schematics` is a library installable via `pip` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a model of a person with just name and age, it''s as simple as
    writing a class in `schematics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate mock data, a mock object is returned, and a *primitive* is created
    using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: One can create custom types using Schematics. For the *Patient* model, for example,
    let us say that we are only interested in the age group 18—80, so we need to return
    age data in that range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following custom type does that for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since the names returned by the schematics library are just random strings,
    they have some room for improvement. The following `NameType` class improves upon
    it by returning names containing a clever mix of vowels and consonants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When combining both of these new types, our `Person` class looks much better
    when returning mock data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, it is rather easy to come up with a set of custom types and
    standard types to satisfy all the fields required for a *Patient* model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, combining all these with some standard types and default values into a
    Patient model, we get the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, creating random data of any size is as easy as invoking the `get_mock_object`
    method on the Patient class for any number *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to create 10,000 random patient data, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This data can be input to the processing functions as mock data until the real
    data is made available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: The Faker library in Python is also useful for generating a wide variety
    of fake data such as names, addresses, URIs, random text, and the like.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on from these simple tricks and techniques to something more
    involved, mainly configuring logging in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Logging as a debugging technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes with standard library support for logging via the aptly named
    `logging` module. Though print statements can be used as a quick and rudimentary
    tool for debugging, real-life debugging mostly requires that the system or application
    generate some logs. Logging is useful because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Logs are usually saved to specific log files, typically, with timestamps, and
    remain at the server for a while until they are rotated out. This makes debugging
    easy even if the programmer is debugging the issue some time after it happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging can be done at different levels—from the basic INFO to the verbose DEBUG
    levels—changing the amount of information output by the application. This allows
    the programmer to debug at different levels of logging to extract the information
    they want, and figure out the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom loggers can be written, which can perform logging to various outputs.
    At its most basic, logging is done to log files, but one can also write loggers
    that write to sockets, HTTP streams, databases, and the like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple application logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure simple logging in Python is rather easy and is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Nothing happens on executing the preceding code, because, by default, `logging`
    is configured at the **WARNING** level. However, it is pretty easy to configure
    logging to change its level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code changes logging to log at the `info` level, and also adds
    a target file to save the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect the `application.log` file, we will find that it contains the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add timestamps to the log lines, we need to configure the logging
    format. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining this, we get the final logging configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the contents of `application.log` looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Logging supports variable arguments, which are used to supply arguments to a
    template string supplied as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Direct logging of arguments separated by commas doesn''t work. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The earlier example works nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced logging—logger objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging using the `logging` module directly works in most simple situations.
    However, in order to extract the maximum value out of the `logging` module, we
    should work with logger objects. It also allows us to perform a lot of customizations
    such as custom formatters, custom handlers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us write a function that returns such a custom logger. It accepts the application
    name, the logging level, and two more options—the log filename, and whether to
    turn console logging on or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the function:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `logging` directly, it creates a `logger` object using the
    `logging.getLogger` factory function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the `logger` object is useless as it has not been configured with
    any handlers. Handlers are stream wrappers that take care of logging to a specific
    stream, such as the console, files, sockets, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration is done on this logger object, such as setting the level (via
    the `setLevel` method) and adding handlers such as the `FileHandler` for logging
    to a file and a `StreamHandler` for logging to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Formatting of the log message is done on the handlers, and not on the logger
    object per se. We use a standard format of `<timestamp>: <level>—<message>` using
    the date format for the timestamp of `YY-mm-dd HH:MM:SS`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the app.log file in the same directory reveals the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Advanced logging—custom formatting and loggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We looked at how we can create and configure logger objects according to our
    requirements. Sometimes, one needs to go over and above, and print extra data
    in the log lines, which helps debugging.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem that arises in debugging applications, especially those that
    are performance critical, is to find out how much time each function or method
    takes. Now, though this can be found out by methods such as profiling the application
    using profilers and by using some techniques discussed previously like timer context
    managers, quite often, a custom logger can be written to do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume that your application is a business listing API server, which
    responds to listing API requests like the one we discussed in an earlier section.
    When it starts off, it needs to initialize a number of objects and load some data
    from the DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that as part of performance optimization, you have tuned these routines,
    and would like to record how much time these take. We''ll see if we can write
    a custom logger to do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We have built a custom class named `LoggerWrapper`. Let us analyze the code
    and see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method of this class is very similar to our `create_logger` function
    written before. It takes the same argument, constructs handler objects, and configures
    the `logger`. However, this time, the `logger` object is part of the outer `LoggerWrapper`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The formatter takes an additional variable template named `timespent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No direct logging methods seem to be defined. However, using the partial functions
    technique, we wrap the `_dolog` method at the different levels of logging, and
    set them on the class as `logging` methods, dynamically, by using `setattr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_dolog` method calculates the time spent in each routine by using a marker
    timestamp—initialized the first time, and then reset in every call. The time spent
    is sent to the logging methods using a dictionary argument named extra.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how the application can use this logger wrapper to measure the time
    spent in critical routines. Here is an example that assumes a Flask web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the time spent is logged inside square brackets just after the timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that this last code produces an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: From the log lines, it's evident that the initialization took 14 seconds, whereas
    the loading of configuration and data took 1 min and 55 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: By adding similar log lines, you can get a quick and reasonably accurate estimate
    of the time spent on critical pieces of the application. Being saved in log files,
    another added advantage is that you don't need to specially calculate and save
    it anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using this custom logger, note that the time shown as time spent for a given
    log line is the time spent in the routine of the previous line.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced logging—writing to syslog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POSIX systems such as Linux and Mac OS X have a system log file, which the application
    can write to. Typically, this file is present as `/var/log/syslog`. Let us see
    how Python logging can be configured to write to the system log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main change that you need to make is to add a system log handler to the
    logger object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify our `create_logger` function to enable it to write to `syslog`,
    and see the complete code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us try to create a logger while logging to `syslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect syslog to see if it actually got logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that it did.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools—using debuggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programmers tend to think of *debugging* as something that they ought to
    do with a debugger. In this chapter, we have so far seen that more than an exact
    science, debugging is an art, which can be done using a lot of tricks and techniques
    rather than directly jumping to a debugger. However, sooner or later, we expected
    to encounter the debugger in this chapter—and here we are!
  prefs: []
  type: TYPE_NORMAL
- en: The Python Debugger, or pdb as it is known, is part of the Python runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pdb can be invoked when running a script from the beginning as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the most common way in which programmers invoke pdb is to insert the
    following line at a place in the code where you want to enter the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us use this, and try and debug an instance of the first example in this
    chapter, that is, the sum of the max subarray. We will debug the `O(n)` version
    of the code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: A debugging session with pdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The debugger is entered in the very first loop immediately after the program
    is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stop the execution using (*s*). Pdb will execute the current line,
    and stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can inspect the variables by simply typing them and pressing [*Enter*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The current stack trace can be printed using (*w*) or where. An arrow (→) indicates
    the current stack frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution can be continued until the next breakpoint by using (*c*) or
    continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we continued three iterations of the `for` loop until
    the max value changed from 20 to 35\. Let us inspect where we are in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one more item to go in the list, namely, the last one. Let us inspect
    the source code at this point using the (*l*) or the `list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'One can traverse up and down the stack frames by using the (*u*) or `up` and
    (*d*) or *down* commands, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now return from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The return value of the function is *45*.
  prefs: []
  type: TYPE_NORMAL
- en: Pdb has a lot of other commands than what we covered here. However, we don't
    intend for this session to be a fully-fledged pdb tutorial. Interested programmers
    can refer to the documentation on the Web to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Pdb—similar tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python community has built a number of useful tools that build on top of
    pdb, but add more useful functionality, developer's ease-of-use, or both.
  prefs: []
  type: TYPE_NORMAL
- en: iPdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iPdb is iPython-enabled pdb. It exports functions to access the iPython debugger.
    It also has tab completion, syntax highlighting, and better traceback, and introspection
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: iPdb can be installed with pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a session of debugging using iPdb, the same
    function as we did with pdb before. Observe the syntax highlighting that **iPdb**
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iPdb](../Images/image00523.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: iPdb in action, showing syntax highlighting
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that iPdb provides a fuller stack trace as opposed to pdb:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iPdb](../Images/image00524.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: iPdb in action, showing a fuller stack trace than pdb
  prefs: []
  type: TYPE_NORMAL
- en: Note that iPdb uses iPython as the default runtime instead of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Pdb++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pdb++ is a drop-in replacement for pdb with features similar to iPdb, but it
    works on the default Python runtime instead of requiring iPython. Pdb++ is also
    installable via pip.
  prefs: []
  type: TYPE_NORMAL
- en: Once pdb++ is installed, it takes over at all places that import pdb, so no
    code change is required at all.
  prefs: []
  type: TYPE_NORMAL
- en: Pdb++ does smart command parsing. For example, if there are variable names conflicting
    with the standard Pdb commands, pdb will give preference to the command over displaying
    the variable contents. Pdb++ figures this out intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot showing Pdb++ in action, including syntax highlighting,
    tab completion, and smart command parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pdb++](../Images/image00525.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pdb++ in action—Note the smart command parsing, where the variable c is interpreted
    correctly
  prefs: []
  type: TYPE_NORMAL
- en: Advanced debugging—tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracing of a program right from the beginning can often be used as an advanced
    debugging technique. Tracing allows a developer to trace program execution, find
    caller/callee relationships, and figure out all functions executed during the
    run of a program.
  prefs: []
  type: TYPE_NORMAL
- en: The trace module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python comes with a default `trace` module as part of its standard library.
  prefs: []
  type: TYPE_NORMAL
- en: The trace module takes one of the `–trace`, `--count`, or `–listfuncs` options.
    |The first option traces and prints all the source lines as they are executed.
    The second option produces an annotated list of files, which shows how many times
    a statement was executed. The latter simply displays all the functions executed
    by running of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the subarray problem being invoked by the
    `–trace` option of the `trace` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The trace module](../Images/image00526.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tracing program execution using the trace module by using its –trace option.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the *trace* module, traced the entire program execution, printing
    the lines of code one by one. Since most of this code is a `for` loop, you actually
    see the lines of code in the loop getting printed the number of times the loop
    was executed (five times).
  prefs: []
  type: TYPE_NORMAL
- en: The `–trackcalls` option traces and prints the relationships between the caller
    and callee functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other options to the trace module such as tracking calls, generating
    annotated file listings, reports, and so on. We won't be having an exhaustive
    discussion regarding these, as the reader can refer to the documentation of this
    module on the Web to read more about it.
  prefs: []
  type: TYPE_NORMAL
- en: The lptrace program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When debugging servers and trying to find out performance or other issues on
    production environments, what a programmer needs is not often the Python system
    or stack trace as given by the *trace* module, but to attach to a process in realtime
    and see what functions are getting executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: lptrace can be installed using pip. Note that it doesn't work with **Python3**.
  prefs: []
  type: TYPE_NORMAL
- en: The `lptrace` package allows you to do this. Instead of giving a script to run,
    it attaches to an existing process running a Python program via its process ID,
    such as running servers, applications, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the folllowing screenshot, you can see *lptrace* debugging the Twisted chat
    server that we developed in [Chapter 8](part0067.xhtml#aid-1VSLM2 "Chapter 8. Python
    – Architectural Patterns"), *Architectural Patterns—The Pythonic Approach* live.
    The session shows the activity when the client andy has connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The lptrace program](../Images/image00527.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: lptrace command debugging a chat server in Twisted
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of log lines, but you can observe how some well-known methods
    of the Twisted protocol are being logged such as **connectionMade** when the client
    has connected. Socket calls such as *accept* can also be seen as part of accepting
    the connection from the client.
  prefs: []
  type: TYPE_NORMAL
- en: System call tracing using strace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Strace` is a Linux command, which allows a user to trace system calls and
    signals invoked by a running program. It is not exclusive to Python, but it can
    be used to debug any program. Strace can be used in combination with lptrace to
    troubleshoot programs with respect to their system calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Strace` is similar to *lptrace* in that it can be made to attach to a running
    process. It can also be invoked to run a process from the command line, but it
    is more useful when running attached to a process such as a server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this screenshot shows the strace output when running attached
    to our chat server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![System call tracing using strace](../Images/image00528.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: strace command attached to the Twisted chat server
  prefs: []
  type: TYPE_NORMAL
- en: The *strace* command corroborates the conclusion of the `lptrace` command of
    the server waiting on an **epoll** handle for incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what happens when a client connects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![System call tracing using strace](../Images/image00529.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: strace command showing system calls for a client connecting to the Twisted chat
    server
  prefs: []
  type: TYPE_NORMAL
- en: Strace is a very powerful tool, which can be combined with tools specific for
    the runtime (such as lptrace for Python) in order to do advanced debugging in
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different debugging techniques with Python.
    We started with the simple *print* statement and followed it with simple tricks
    to debug a Python program such as using the *continue* statement in a loop, strategically
    placed `sys.exit` calls between code blocks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at debugging techniques in some detail, especially on mocking
    and randomizing data. Techniques such as caching in files and in-memory database
    such as Redis were discussed with examples.
  prefs: []
  type: TYPE_NORMAL
- en: An example using Python schematics library showed generating random data for
    a hypothetical application in the healthcare domain.
  prefs: []
  type: TYPE_NORMAL
- en: The next section was about logging and using it as a debugging technique. We
    discussed simple logging using the *logging* module, advanced logging using `logger`
    object, and wrapped up the discussion by creating a logger wrapper with its custom
    formatting for logging time taken inside functions. We also studied an example
    of writing to syslog.
  prefs: []
  type: TYPE_NORMAL
- en: The end of the chapter was devoted to a discussion on debugging tools. You learned
    the basic commands of pdb, the Python debugger, and took a quick look at similar
    tools that provide a better experience, namely, iPdb and Pdb++. We ended the chapter
    with a brief discussion on tracing tools such as lptrace and the ubiquitous *strace*
    program on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the conclusion of this chapter and the book.
  prefs: []
  type: TYPE_NORMAL
