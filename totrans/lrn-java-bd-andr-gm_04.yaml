- en: Chapter 4. Discovering Loops and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to repeatedly execute portions of our code
    in a controlled and precise way by looking at different types of loops in Java.
    These include `while` loops, `do-while` loops, and `for` loops. We will learn
    about the best occasions to use the different types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will briefly cover the topic of random numbers. We will also see how
    the Java `Random` class can be used. This will obviously be of great help in enhancing
    our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at **methods**. They allow us to compartmentalize our code
    into more manageable blocks. We will then see how to share data between methods
    and divide programming tasks to simplify problems.
  prefs: []
  type: TYPE_NORMAL
- en: We will then use all that we have learned about loops, random numbers and methods
    on our math game project. For example, we will make the game change the question
    after each time we attempt the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add question difficulty levels and random questions within a range
    appropriate for a given difficulty level. We will show and update our score. The
    score goes up faster depending upon the difficulty level of the question answered
    (correctly). Eventually, even the best mathematicians among us should be beaten
    by the game. Nevertheless, most of us will hopefully get a bit further than what
    is shown in the next screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero. This is what the game will look like when we are
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering Loops and Methods](img/8859OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about looping in multiple types of loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to generate random numbers in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn everything about Java methods, including how to write and call them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significantly enhance our math game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be completely reasonable to ask what loops have to do with programming,
    but they are exactly what the name implies. They are a way of performing the same
    part of the code more than once, or looping over the same part of code, but potentially
    for a different outcome each time.
  prefs: []
  type: TYPE_NORMAL
- en: This can simply mean doing the same thing until the code being looped over prompts
    the loop to end. It could prompt the loop after a predetermined number of times
    as specified by the loop code itself. It could also prompt the loop when a predetermined
    situation or **condition** is met. Or there could be a combination of more than
    one of these ways of prompting the loop to end. Along with `if`, `else`, and `switch`,
    loops are part of the Java **control flow statements**.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all the major types of loop that Java offers us to control our
    code, and after we have looked at methods, we will use some of them to implement
    the enhancements to our math game. Let's proceed to our first type of loop.
  prefs: []
  type: TYPE_NORMAL
- en: While loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `while` loop has the simplest syntax. Recollect the `if` statements in [Chapter
    3](ch03.xhtml "Chapter 3. Speaking Java – Your First Game"), *Speaking Java –
    Your First Game*. We can put virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluated
    to `true`, then the code in the body of the `if` block is executed. Similarly,
    in the `while` loop, we put an expression that can evaluate to `true` or `false`,
    as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here is that outside the `while` loop, an integer, `x`, is
    declared and initialized to `10`. Then the `while` loop begins. Its condition
    is `x > 0`, so it will continue looping through the code in its body until the
    condition evaluates to `false`. Hence, the code will execute 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: On the first pass, `x` is equal to `10`, then `9`, then `8`, and so on. But
    once `x` becomes equal to `0`, it is obviously no longer greater than `0`. So
    the program will exit the `while` loop and continue with the first line of code
    after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this example of a `while` loop that never executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, there is no limit to the complexity of the condition expression or
    the amount of code that can be written in the loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `while` loop would continue to execute until either `playerLive`s
    or `alienShips` becomes equal to or less than zero. As soon as one of these conditions
    occurs, the expression evaluates to `false` and the program continues to execute
    from the first line of code after the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to `false` somewhere in between,
    as the condition is not checked again until the code tries to start another pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever (which is unsurprisingly called an **infinite loop**),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Breaking out of a loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might use an infinite loop like the loop in the preceding example so that
    we can decide when to exit the loop from within its body. We would do this using
    the `break` keyword when we are ready to leave the loop body, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have been able to guess that we can combine any of the decision making
    tools like `if`, `else`, and `switch` within our `while` loops and the rest of
    the loops we will look at in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops, but at some point, we want to get back to doing some real programming.
    So here is one last concept, combined with `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The continue keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` keyword acts in a way similar to `break`—up to a point. The
    `continue` keyword will break out of the loop body but will also check the condition
    expression afterwards, so the loop *could* run again. The following example will
    show the use of `continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Do-while loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `do-while` loop is very much the same as a `while` loop with the exception
    that it evaluates its expression after the body. This means that a `do-while`
    loop will always execute at least once, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `break` and `continue` keywords can also be used in `do-while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `for` loop has a slightly more complicated syntax than a `while` and `do-while`
    loop as it take three parts to initialize. Take a look at the following `for`
    loop first. Then we will break it apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The apparently obscure form of the `for` loop is clearer when put like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To clarify further, we have the following in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaration and initialization**: We create a new `int` variable, `i`, and
    initialize it to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition**: Just like the other loops, this refers to the condition that
    must be evaluated to true for the loop to continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change after each pass through loop**: In the preceding example, `i++` means
    that 1 is added to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` on each pass, which is shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `break` and `continue` can also be used in `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop essentially takes control of initialization, condition evaluation,
    and the control variable on itself. We will be using a `for` loop to enhance our
    math game right after we take a look at random numbers and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into methods, we will first take a look at how we can create
    random numbers because this is how we will generate our random questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the hard work is done for us by the `Random` class. First we need to create
    an object of the `Random` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    within a certain range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The range for the number that we enter starts from zero. So the preceding line
    of code will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often in these early chapters, we need to accept there is a bit of magic going
    on in objects like Random. In [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*, we will be ripping
    open the black boxes and even making our own. We will be able to write our own
    classes and our own methods within those classes.
  prefs: []
  type: TYPE_NORMAL
- en: A good start is a look at regular vanilla methods, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Math game – asking a question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all that knowledge under our belts, we can use it to improve
    our math game. First, we will create a new Android activity to be the actual game
    screen as opposed to the start menu screen. We will then use the UI designer to
    lay out a simple game screen so that we can use our Java skills with variables,
    types, declaration, initialization, operators, and expressions to make our math
    game generate a question for the player. We can then link the start menu and game
    screens together with a push button.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save typing and just review the finished project, you can use
    the code downloaded from the Packt Publishing website. If you have any trouble
    getting any of the code to work, you can review, compare, or copy and paste the
    code from the already completed code provided in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed code is in the following files that correspond to the filenames
    we will be using in this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, I recommend following this tutorial to see how we can create all of
    the code for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new game activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first need to create a new Java file for the game activity code and
    a related layout file to hold the game activity UI.
  prefs: []
  type: TYPE_NORMAL
- en: Run Android Studio and select your `Math Game Chapter 2` project that we built
    in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*. It might have been opened by default. Now we will create
    the new Android activity that will contain the actual game screen, which will
    run when the player taps the **Play** button on our main menu screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new activity, we now need another layout file and another Java file.
    Fortunately Android Studio will help us do this. To get started with creating
    all the files we need for a new activity, right-click on the `src` folder in the
    Project Explorer and then go to **New** | **Activity**. Now click on **Blank Activity**
    and then on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to tell Android Studio a little bit about our new activity by entering
    information in the above dialog box. Change the **Activity Name** field to `GameActivity`.
    Notice how the **Layout Name** field is automatically changed for us to `activity_game`
    and the **Title** field is automatically changed to `GameActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**. Android Studio has created two files for us and has also
    registered our new activity in a manifest file, so we don't need to concern ourselves
    with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you look at the tabs at the top of the editor window, you will see that `GameActivity.java`
    has been opened up ready for us to edit, as shown in the following screenshot:![Creating
    the new game activity](img/8859OS_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that `GameActivity.java` is active in the editor window by clicking on
    the **GameActivity.java** tab shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, we talked about how Android overrides some methods for
    us by default, and that most of them were not necessary. Here again, we can see
    the code that is unnecessary. If we remove it, then it will make our working environment
    simpler and cleaner. You might also remember from [Chapter 2](ch02.xhtml "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*, that the process of deleting
    and amending sections of code, although not complex, is a fairly long process.
    To avoid this here, we will simply use the code from `MainActivity.java` as a
    template for `GameActivity.java`. We can then make some minor changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **MainActivity.java** tab in the editor window. Highlight all of
    the code in the editor window using *Ctrl* + *A* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy all of the code in the editor window using the *Ctrl* + *C* on the
    keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the **GameActivity.java** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight all of the code in the editor window using *Ctrl* + *A* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now paste the copied code and overwrite the currently highlighted code using
    *Ctrl* + *V* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that there is an error in our code denoted by the red underlining as
    shown in the following screenshot. This is because we pasted the code referring
    to `MainActivity` in our file that is called `GameActivity`.![Creating the new
    game activity](img/8859OS_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply change the text **MainActivity** to **GameActivity** and the error will
    disappear. Take a moment to see if you can work out what other minor change is
    necessary, before I tell you.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `setContentView` loads our UI design. Well what we need to do
    is change `setContentView` to load the new design (that we will build next) instead
    of the home screen design. Change `setContentView(R.layout.activity_main);` to
    `setContentView(R.layout.activity_game);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work and we are ready to move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the Project Explorer where Android Studio puts the two new files it created
    for us. I have highlighted two folders in the next screenshot. In future, I will
    simply refer to them as our `java` code folder or `layout` files folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the new game activity](img/8859OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder why we didn't simply copy and paste the `MainActivity.java`
    file to begin with and saved going through the process of creating a new activity?
    The reason is that Android Studio does things behind the scenes. Firstly, it makes
    the layout template for us. It also registers the new activity for use through
    a file we will see later, called `AndroidManifest.xml`. This is necessary for
    the new activity to be able to work in the first place. All things considered,
    the way we did it is probably the quickest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code at this stage is exactly the same as the code for the home menu screen.
    We state the package name and import some useful classes provided by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new activity, this time called `GameActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we override the `onCreate` method and use the `setContentView` method
    to set our UI design as the contents of the player''s screen. Currently, however,
    this UI is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can now think about the layout of our actual game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the game screen UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, our math game will ask questions and offer the player some multiple
    choices to choose answers from. There are lots of extra features we could add,
    such as difficulty levels, high scores, and much more. But for now, let's just
    stick to asking a simple, predefined question and offering a choice of three predefined
    possible answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the UI design to the bare minimum suggests a layout. Our target UI
    will look somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying out the game screen UI](img/8859OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout is hopefully self-explanatory, but let''s ensure that we are really
    clear; when we come to building this layout in Android Studio, the section in
    the mock-up that displays **2 x 2** is the question and will be made up of three
    text views (both numbers, and the **=** sign is also a separate view). Finally,
    the three options for the answer are made up of **Button** layout elements. We
    used all of these UI elements in the previous chapter, but this time, as we are
    going to be controlling them using our Java code, there are a few extra things
    we need to do to them. So let''s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file that will hold our game UI in the editor window. Do this by double-clicking
    on `activity_game.xml`. This is located in our UI `layout` folder, which can be
    found in the project explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Hello World** TextView, as it is not required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Large Text** element on the palette. It can be found under the **Widgets**
    section. Drag three elements onto the UI design area and arrange them near the
    top of the design as shown in the next screenshot. It does not have to be exact;
    just ensure that they are in a row and not overlapping, as shown in the following
    screenshot:![Laying out the game screen UI](img/8859OS_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice in the **Component Tree** window that each of the three TextViews has
    been assigned a name automatically by Android Studio. They are **textView** ,
    **textView2**, and **textView3**:![Laying out the game screen UI](img/8859OS_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android Studio refers to these element names as an **id**. This is an important
    concept that we will be making use of. So to confirm this, select any one of the
    textViews by clicking on its name (id), either in the component tree as shown
    in the preceding screenshot or directly on it in the UI designer shown previously.
    Now look at the **Properties** window and find the **id** property. You might
    need to scroll a little to do this:![Laying out the game screen UI](img/8859OS_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the value for the **id** property is **textView**. It is this `id`
    that we will use to interact with our UI from our Java code. So we want to change
    all the IDs of our TextViews to something useful and easy to remember.
  prefs: []
  type: TYPE_NORMAL
- en: If you look back at our design, you will see that the UI element with the **textView**
    id is going to hold the number for the first part of our math question. So change
    the id to `textPartA`. Notice the lowercase `t` in `text`, the uppercase `P` in
    `Part`, and the uppercase `A`. You can use any combination of cases and you can
    actually name the IDs anything you like. But just as with naming conventions with
    Java variables, sticking to conventions here will make things less error-prone
    as our program gets more complicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select **textView2** and change **id** to `textOperator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the element currently with id **textView3** and change it to `textPartB`.
    This TextView will hold the later part of our question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add another **Large Text** from the palette. Place it after the row of the
    three TextViews that we have just been editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This **Large Text** will simply hold our equals to sign and there is no plan
    to ever change it. So we don't need to interact with it in our Java code. We don't
    even need to concern ourselves with changing the ID or knowing what it is. If
    this situation changed, we could always come back at a later time and edit its
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: However, this new TextView currently displays **Large Text** and we want it
    to display an equals to sign. So in the **Properties** window, find the **text**
    property and enter the value **=**. We have changed the **text** property before
    in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, and you might also like to change the text property for
    `textPartA`, `textPartB`, and `textOperator`. This is not absolutely essential
    because we will soon see how we can change it via our Java code; however, if we
    change the **text** property to something more appropriate, then our UI designer
    will look more like it will when the game runs on a real device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So change the text property of **textPartA** to `2`, **textPartB** to `2`, and
    **textOperator** to `x`. Your UI design and Component tree should now look like
    this:![Laying out the game screen UI](img/8859OS_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the buttons to contain our multiple choice answers, drag three buttons in
    a row, below the **=** sign. Line them up neatly like our target design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just as we did for the TextViews, find the **id** properties of each button,
    and from left to right, change the **id** properties to `buttonChoice1`, `buttonChoice2`,
    and `buttonChoice3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why not enter some arbitrary numbers for the **text** property of each button
    so that the designer more accurately reflects what our game will look like, just
    as we did for our other TextViews? Again, this is not absolutely essential as
    our Java code will control the button appearance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now actually ready to move on. But you probably agree that the UI elements
    look a little lost. It would look better if the buttons and text were bigger.
    All we need to do is adjust the textSize property for each TextView and for each
    Button. Then, we just need to find the textSize property for each element and
    enter a number with the sp syntax. If you want your design to look just like our
    target design from earlier, enter `70sp` for each of the TextView textSize properties
    and `40sp` for each of the Buttons textSize properties. When you run the game
    on your real device, you might want to come back and adjust the sizes up or down
    a bit. But we have a bit more to do before we can actually try out our game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project and then we can move on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, we have built our UI. This time, however, we have given all the important
    parts of our UI a unique, useful, and easy to identify ID. As we will see we are
    now able to communicate with our UI through our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a question in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our current knowledge of Java, we are not yet able to complete our math
    game but we can make a significant start. We will look at how we can ask the player
    a question and offer them some multiple choice answers (one correct and two incorrect).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we know enough of Java to declare and initialize some variables
    that will hold the parts of our question. For example, if we want to ask the times
    tables question *2 x 2*, we could have the following variable initializations
    to hold the values for each part of the question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares and initializes two variables of the `int` type,
    each to the value of 2\. We use `int` because we will not be dealing with any
    decimal fractions. Remember that the variable names are arbitrary and were just
    chosen because they seemed appropriate. Clearly, any math game worth downloading
    is going to need to ask more varied and advanced questions than *2 x 2*, but it
    is a start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that our math game will offer multiple choices as answers. So,
    we need a variable for the correct answer and two variables for two incorrect
    answers. Take a look at these combined declarations and initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the initialization of the variables for the wrong answers depends
    on the value of the correct answer, and the variables for the wrong answers are
    initialized after initializing the `correctAnswer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to put these values, held in our variables, into the appropriate
    elements on our UI. The question variables (`partA` and `partB`) need to be displayed
    in our UI elements, `textPartA` and `textPartB`, and the answer variables (`correctAnswer`,
    `wrongAnswer1`, and `wrongAnswer2`) need to be displayed in our UI elements with
    the following IDs: `buttonChoice1`, `buttonChoice2`, and `buttonChoice3`. We will
    see how we do this in the next step-by-step tutorial. We will also implement the
    variable declaration and initialization code that we discussed a moment ago:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open `GameActivity.java` in the editor window. Remember that you can
    do this by double-clicking on **GameActivity** in our `java` folder or clicking
    on its tab above the editor window if `GameActivity.java` is already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of our code will go into the `onCreate` method. It will go after the `setContentView(R.layout.activity_game);`
    line but before the closing curly brace `}` of the `onCreate` method. Perhaps,
    it''s a good idea to leave a blank line for clarity and a nice explanatory comment
    as shown in the following code. We can see the entire `onCreate` method as it
    stands after the latest amendments. The parts in bold are what you need to add.
    Feel free to add helpful comments like mine if you wish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the values contained within the variables to the `TextView`
    and `Button` of our UI. But first, we need to get access to the UI elements we
    created. We do that by creating a variable of the appropriate class and linking
    it via the ID property of the appropriate UI element. We already know the class
    of our UI elements: `TextView` and `Button`. Here is the code that creates our
    special class variables for each of the necessary UI elements. Take a close look
    at the code, but don''t worry if you don''t understand all of it now. We will
    dissect the code in detail once everything is working. Enter the code immediately
    after the code entered in the previous step. You can leave a blank line for clarity
    if you wish. Just before you proceed, note that at two points while typing in
    this code, you will be prompted to import another class. Go ahead and do so on
    both occasions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, if you read the multiline comment, you will see that
    I used the term **object**. When we create a variable type based on a class, we
    call it an object. Once we have an object of a class, we can do anything that
    that class was designed to do. This is very powerful and is explored thoroughly
    in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP – Using Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have five new objects linked to the elements of our UI that we need
    to manipulate. What precisely are we going to do with them? We need to display
    the values of our variables in the text of the UI elements. We can use the objects
    we just created combined with a method provided by the class, and use our variables
    as values for that text. As usual, we will dissect this code further at the end
    of this tutorial. Here is the code to enter directly after the code in the previous
    step. Try and work out what is going on before we look at it together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play with the assignment values for `partA` and `partB`, you can make
    them whatever you like and the game adjusts the answers accordingly. Obviously,
    we shouldn't need to reprogram our game each time we want a new question and we
    will solve that problem soon. All we need to do now is link the game section we
    have just made to the start screen menu. We will do that in the next tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's explore the trickier and newer parts of our code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 2, we declared and initialized the variables required so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in step 3, we got a reference to our UI design through our Java code.
    For the TextViews, it was done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of the buttons, a reference to our UI design was obtained like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In step 4, we did something new. We used a the `setText` method to show the
    values of our variables on our UI elements (`TextView` and `Button`) to the player.
    Let's break down one line completely to see how it works. Here is the code that
    shows the `correctAnswer` variable being displayed on `buttonObjectChoice1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By typing `buttonObjectChoice1` and adding a period, as shown in the following
    line of code, we have access to all the preprogrammed methods of that object''s
    class type that are provided by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The power of Button and the Android API**'
  prefs: []
  type: TYPE_NORMAL
- en: There are actually lots of methods that we can perform on an object of the Button
    type. If you are feeling brave, try this to get a feeling of just how much functionality
    there is in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to type the period on the end. Android Studio will pop up a list of
    possible methods to use on this object. Scroll through the list and get a feel
    of the number and variety of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a question in Java](img/8859OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a mere button can do all of this, think of the possibilities for our games
    once we have mastered all the classes contained in Android. A collection of classes
    designed to be used by others is collectively known as an **Application Programmers
    Interface** (**API**). Welcome to the Android API!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we just want to set the button''s text. So, we use `setText`
    and concatenate the value stored in our `correctAnswer` variable to the end of
    an empty string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We do this for each of the UI elements we require to show our variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Playing with autocomplete**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tried the previous tip, *The power of Button and the Android API*, and
    explored the methods available for objects of the Button type, you will already
    have some insight into autocomplete. Note that as you type, Android Studio is
    constantly making suggestions for what you might like to type next. If you pay
    attention to this, you can save a lot of time. Simply select the correct code
    completion statement that is suggested and press *Enter*. You can even see how
    much time you saved by selecting **Help** | **Productivity Guide** from the menu
    bar. Here you will see statistics for every aspect of code completion and more.
    Here are a few entries from mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding a question in Java](img/8859OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, if you get used to using shortcuts early on, you can save a
    lot of time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Linking our game from the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment, if we run the app, we have no way for the player to actually
    arrive at our new game activity. We want the game activity to run when the player
    clicks on the **Play** button on the main `MainActivity` UI. Here is what we need
    to do to make that happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file `activity_main.xml`, either by double-clicking on it in the Project
    Explorer or by clicking on its tab in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just like we did when building the game UI, assign an ID to the **Play**
    button. As a reminder, click on the **Play** button either on the UI design or
    in the component tree. Find the **id** property in the **Properties** window.
    Assign the `buttonPlay` value to it. We can now make this button do stuff by referring
    to it in our Java code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file `MainActivity.java`, either by double-clicking on it in the Project
    Explorer or clicking on its tab in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `onCreate` method, just after the line where we `setContentView`, add
    the following highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will dissect this code in detail once we have got this working. Basically
    we are making a connection to the **Play** button by creating a reference variable
    to a `Button` object. Notice that both words are highlighted in red indicating
    an error. Just as before, we need to import the Button class to make this code
    work. Use the *Alt* + *Enter* keyboard combination. Now click on **Import class**
    from the popped-up list of options. This will automatically add the required import
    directive at the top of our `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now for something new. We will give the button the ability to *listen* to the
    user clicking on it. Type this immediately after the last line of code we entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. This
    introduces another Java feature that will be more thoroughly explored in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People''s Hard Work"),*OOP – Using
    Other People''s Hard Work*. Setting that aside, we need to make a modification
    to our code now in order to allow the use of an interface that is a special code
    element that allows us to add a functionality, such as listening for button clicks.
    Edit the line as follows. When prompted to import another class, click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the entire line underlined in red. This indicates an error but it's
    where we should be at this point. We mentioned that by adding `implements View.OnClickListener`,
    we have implemented an interface. We can think of this like a class that we can
    use but with extra rules. The rules of the `OnClickListener` interface state that
    we *must* implement/use one of its methods. Notice that until now, we have optionally
    overridden/used methods as and when they have suited us. If we wish to use the
    functionality this interface provides, namely listening for button presses, then
    we have to add/implement the `onClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we do it. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty and it doesn''t do anything, but an empty method is enough to
    comply with the rules of the `OnClickListener` interface, and the red line indicating
    that our code has an error has gone. The syntax of these methods we have been
    using, as promised, will be explained in the next chapter when we start to write
    our own methods. Make sure that you type the following code, outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have an empty line between `{` and `}` of the `onClick` method.
    We can now add code in here to make the button actually do something. Type the
    following highlighted code between `{` and `}` of `onClick`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: OK, so that code is a bit of a mouthful to comprehend all at once. See if you
    can guess what is happening. The clue is in the method named `startActivity` and
    the hopefully familiar term, `GameActivity`. Notice that we are assigning something
    to `i`. We will quickly get our app working and then diagnose the code in full.
    Its understanding will be complete when we explore how classes work in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we have an error: all instances of the word `Intent` are red. We
    can solve this by importing the classes required to make `Intent` work. As before
    press *Alt* + *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game in the emulator or on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our app will now work. This is what the new game screen looks like after pressing
    **Play** on the menu screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking our game from the main menu](img/8859OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Almost every part of our code has changed a little and we have added a lot
    to it as well. Let''s go over the contents of `MainActivity.java` and look at
    it line by line. For context, here it is in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen much of this code before, but let''s just go over it a chunk at
    a time before moving on so that it is absolutely clear. The code works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You would probably remember that this first block of code defines what our package
    is called and makes available all the Android API stuff we need for Button, TextView,
    and Activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our `MainActivity.java` file, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our `MainActivity` declaration with our new bit of code implements `View.OnClickListener`
    that gives us the ability to detect button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next in our code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This previous bit of code hasn't changed since [Chapter 2](ch02.xhtml "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*. It is at the start of
    our `onCreate` method where we first ask the hidden code of `onCreate` to do its
    stuff using `super.onCreate(savedInstanceState);`. Then we set our UI to the screen
    with `setContentView(R.layout.activity_main);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get a reference to our button with an ID of `buttonPlay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `onClick` method uses the `Intent` class to send the player to
    our `GameActivity` class and the related UI when the user clicks on the **Play**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app, you will notice that we can now click on the **Play** button
    and our math game will ask us a question. Of course, we can't answer it yet. Although
    we have very briefly looked at how to deal with button presses, we need to learn
    more of Java in order to intelligently react to them. We will also reveal how
    to write code to handle presses from several buttons. This will be necessary to
    receive input from our multiple-choice-centric `game_activity` UI.
  prefs: []
  type: TYPE_NORMAL
- en: Decisions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now summon enough of Java prowess to ask a question but a real math game
    must obviously do much more than this. We need to capture the player's answer,
    and we are nearly there with that—we can detect button presses. From there, we
    need to be able to **decide** whether their answer is right or wrong. Then, based
    on this decision, we have to **choose** an appropriate course of action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's leave the math game aside for now and look at how Java might help us by
    learning some more fundamentals and syntax of the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: More operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at some more operators: we can already add (+), take away (-),
    multiply (*), divide (/), assign (=), increment (++), compare (==), and decrement
    (--) with operators. Let''s introduce some more super-useful operators, and then
    we will go straight to actually understanding how to use them in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about memorizing every operator given here. Glance at them and their
    explanations and then move quickly on to the next section. There, we will put
    some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators plain from the start. The list will also be more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: '**==**: This is a comparison operator we saw this very briefly before. It tests
    for equality and is either true or false. An expression like `(10 == 9);`, for
    example, is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!**: The logical NOT operator. The expression, `! (2+2==5)`.`)`, is true
    because 2+2 is NOT 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!=**: This is another comparison operator, which tests if something is NOT
    equal. For example, the expression, `(10 != 9);)`, is true, that is, 10 is not
    equal to 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>**: This is another comparison operator, which tests if something is greater
    than something else. The expression, `(10 > 9);)`, is true. There are a few more
    comparison operators as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<**: You guessed it. This tests whether the value to the left is less than
    the value to the right or not. The expression, `(10 < 9);`, is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>=**: This operator tests whether one value is greater than or equal to the
    other, and if either is true, the result is true. For example, the expression,
    `(10 >= 9);`, is true. The expression, `(10 >= 10);`, is also true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<=**: Like the preceding operator, this operator tests for two conditions
    but this time, less than and equal to. The expression, `(10 <= 9);`, is false.
    The expression, `(10 <= 10);`, is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**&&**: This operator is known as logical AND. It tests two or more separate
    parts of an expression and all parts must be true in order for the result to be
    true. Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression, `((10 > 9) && (10 < 11));`, is true because
    both parts are true. The expression, `((10 > 9) && (10 < 9));`, is false because
    only one part of the expression is true and the other is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**||**: This operator is called logical OR. It is just like logical AND except
    that only one of two or more parts of an expression need to be true for the expression
    to be true. Let''s look at the last example we used but replace the && sign with
    ||. The expression, `((10 > 9) || (10 < 9));`, is now true because one part of
    the expression is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these operators are virtually useless without a way of properly using
    them to make real decisions that affect real variables and code. Let's look at
    how to make decisions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Decision 1 – If they come over the bridge, shoot them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw, operators serve hardly any purpose on their own but it was probably
    useful to see just a part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the previous examples less abstract using the Java `if` keyword and
    a few conditional operators with a fun story and some code.
  prefs: []
  type: TYPE_NORMAL
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command the captain wants to make sure his troops understand is this:
    If they come over the bridge, shoot them.'
  prefs: []
  type: TYPE_NORMAL
- en: So how do we simulate this situation in Java? We need a Boolean variable `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will run. If not, the program continues after the `if` block
    without running it.
  prefs: []
  type: TYPE_NORMAL
- en: Decision 2 – Else, do this
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The captain also wants to tell his troops what to do (stay put) if the enemy
    is not coming over the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something and the `if` block does not evaluate to true, we can use `else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we use `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge and has more troops? His squad will be
    overrun. So, he came up with this code (we''ll use some variables as well this
    time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The Java code needed was obvious. Using the `wavingWhiteFlag`
    Boolean variable he wrote this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changing the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create even deeper decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making more and more complicated decisions but what we have seen
    is more than sufficient as an introduction. Take the time to reread this if anything
    is unclear. Who knows, there might even be a tricky logic question in the self-test
    at the end of the chapter. It is also important to point out that very often,
    there are two or more ways to arrive at the solution. The *right* way will usually
    be the way that solves the problem in the clearest and simplest manner.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to make decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: When we have to make a decision based on a clear list of possibilities that
    doesn't involve complex combinations, then **switch** is usually the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start a `switch` decision like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, an argument could be an expression or a variable.
    Then within the curly braces, we can make decisions based on the argument with
    case and break elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the previous example, each case states a possible result
    and each break denotes the end of that case as well as the point at which no further
    case statements should be evaluated. The first break encountered takes us out
    of the switch block to proceed with the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use **default** without a value to run some code if none of the
    case statements evaluate to true, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposing we are writing an old-fashioned text adventure game—the kind of game
    where the player types commands such as `"Go East"`, `"Go West"`, `"Take Sword"`,
    and so on. In this case, switch could handle that situation like this example
    code and we could use `default` to handle the case of the player typing a command
    that is not specifically handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will use `switch` so that our `onClick` method can handle
    the different multiple-choice buttons of our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java has even more operators than we have covered here. We have looked at all
    the operators we are going to need in this book and probably the most used in
    general. If you want the complete lowdown on operators, take a look at the official
    Java documentation at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
  prefs: []
  type: TYPE_NORMAL
- en: Math game – getting and checking the answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will detect the right or wrong answer and provide a pop-up message to
    the player. Our Java is getting quite good now, so let's dive in and add these
    features. I will explain things as we go and then, as usual, dissect the code
    thoroughly at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The already completed code is in the download bundle, in the following files
    that correspond to the filenames we will create/autogenerate in Android Studio
    in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, I recommend following this tutorial step by step to see how we can
    create all of the code for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `GameActivity.java` file visible in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the click detection functionality to our `GameActivity`,
    just as we did for our `MainActivity`. However, we will go a little further than
    the last time. So let''s do it step by step as if it is totally new. Once again,
    we will give the buttons the ability to *listen* to the user clicking on them.
    Type this immediately after the last line of code we entered in the `onCreate`
    method but before the closing `}`. This time of course, we need to add some code
    to listen to three buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. Again,
    we need to make a modification to our code in order to allow the use of an interface,
    the special code element that allows us to add functionalities such as listening
    to button clicks. Edit the line as follows. When prompted to import another class,
    click on **OK**. Consider this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the entire preceding line underlined in red. This indicates an error
    but it is where we should be at this point. We mentioned that by adding `implements
    View.OnClickListener`, we have implemented an interface. We can think of this
    like a class that we can use, but with extra rules. One of the rules of the `OnClickListener`
    interface is that we must implement one of its methods, as you might remember.
    Now we will add the `onClick` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty; it doesn''t do anything but an empty method is enough to comply
    with the rules of the `OnClickListener` interface and the red line that indicated
    an error has gone. Make sure that you type the following code outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have an empty line between the `{` and `}` braces of our `onClick`
    method. We can now put some code in here to make the buttons actually do something.
    Type the following in between `{` and `}` of `onClick`. This is where things get
    different from our code in `MainActivity`. We need to differentiate between the
    three possible buttons that could be pressed. We will do this with the `switch`
    statement that we discussed earlier. Look at the `case` criteria; they should
    look familiar. Here is the code that uses the switch statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `case` element handles a different button. For each button case, we need
    to get the value stored in the button that was just pressed and see if it matches
    our `correctAnswer` variable. If it does, we must tell the player they got it
    right, and if not, we must tell them they got it wrong. However, there is still
    one problem we have to solve. The `onClick` method is separate from the `onCreate`
    method and the Button objects. In fact, all the variables are declared in the
    `onCreate` method. If you try typing the code from step 9 now, you will get lots
    of errors. We need to make all the variables that we need in `onClick` available
    in `onClick`. To do this, we will move their declarations from above the `onCreate`
    method to just below the opening `{` of `GameActivity`. This means that these
    variables become variables of the `GameActivity` class and can be seen anywhere
    within `GameActivity`. Declare the following variables like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change the initialization of these variables within `onCreate` as follows.
    The actual parts of code that need to be changed are highlighted. The rest is
    shown for context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the top of our `onClick` method as well as the first `case` statement
    for our `onClick` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the rest of the `case` statements that do the same steps as the code
    in the previous step except handling the last two buttons. Enter the following
    code after the code entered in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Run the program, and then we will look at the code carefully, especially that
    odd-looking `Toast` thing. Here is what happens when we click on the leftmost
    button:![Math game – getting and checking the answer](img/8859OS_03_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how we did it: In steps 1 through 6, we set up handling for our multi-choice
    buttons, including adding the ability to listen to clicks using the `onClick`
    method and a `switch` block to handle decisions depending on the button pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 8, we had to alter our code to make our variables available in
    the `onClick` method. We did this by making them member variables of our `GameActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we make a variable a member of a class, we call it a **field**. We will
    discuss exactly when a variable should be a field and when it shouldn't in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 9 and 10, we implemented the code that actually does the work in our
    switch statement in `onClick`. Let's take a line-by-line look at the code that
    runs when `button1` is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the `case` statement is true when the button with an id of `buttonChoice1`
    is pressed. Then the next line of code to execute is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line gets the value on the button using two methods. First, `getText`
    gets the number as a string and then `Integer.parseInt` converts it to an integer.
    The value is stored in our `answerGiven` variable. The following code executes
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement tests to see if the `answerGiven` variable is the same as
    `correctAnswer` using the `==` operator. If so, the `makeText` method of the `Toast`
    object is used to display a congratulatory message. If the values of the two variables
    are not the same, the message displayed is a bit more negative one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Toast` line of code is possibly the most evil thing we have seen thus
    far. It looks exceptionally complicated and it does need a greater knowledge of
    Java than we have at the moment to understand. All we need to know for now is
    that we can use the code as it is and just change the message, and it is a great
    tool to announce something to the player. By the end of [Chapter 6](ch06.xhtml
    "Chapter 6. OOP – Using Other People''s Hard Work"), *OOP – Using Other People''s
    Hard Work*, the code for `Toast` will be clear. If you really want an explanation
    now, you can think of it like this: when we made button objects, we got to use
    all the button methods. But with Toast, we used the class directly to access its
    `makeText` method without creating an object first. We can do this process when
    the class and its methods are designed to allow it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we break out of the whole `switch` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have improved the project as far as we can with what we learned
    in this chapter, why not test your understanding of everything you've learned
    so far?
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What does this code do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Q2) Which of these lines causes an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make the code look complicated. However, when looked at closely, they are not
    as tough as they seem. Usually, it is just a case of splitting the expressions
    into smaller pieces to work out what is going on. Here is an expression that is
    more convoluted than anything else you will ever see in this book. As a challenge,
    can you work out: what will `x` be?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this chapter. We went from knowing nothing about Java syntax
    to learning about comments, variables, operators, and decision making.
  prefs: []
  type: TYPE_NORMAL
- en: As with any language, mastery of Java can be achieved by simply practicing,
    learning, and increasing our vocabulary. At this point, the temptation might be
    to hold back until mastery of the current Java syntax has been achieved, but the
    best way is to move on to new syntax at the same time as revisiting what we have
    already begun to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally finish our math game by adding random questions
    of multiple difficulties as well as using more appropriate and random wrong answers
    for the multiple choice buttons.
  prefs: []
  type: TYPE_NORMAL
- en: To enable us to do this, we will first learn some more Java.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what exactly are Java methods? A method is a collection of variables, expressions,
    and control flow statements. We have already been using lots of methods; we just
    haven't looked inside any yet.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Java methods will be the last topic for this chapter before we
    get practical and use what we have learned to enhance our math game.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of a method that we write is called the **signature**. Here
    is a made-up example of a signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an opening and closing pair of curly braces with some code that the method
    performs, and we have a complete method, or a **definition**. Here is a made-up
    but syntactically correct method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use our new method from another part of our code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: At the point where we call `setCoordinates`, our program's execution would branch
    to the code contained within that method, which would run until it reaches its
    end or is told to return. Then the code would continue running from the first
    line after the method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a method, complete with the code to make the method
    return to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to use the preceding method could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the preceding example helps us see a little more of the working of methods.
    First, we pass the values `2` and `4`. In the signature of the method, the value,
    `2`, is assigned to `int a` and the value, `4`, is assigned to `int b`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method body, the `a` and `b` variables are added and used to initialize
    a new variable, which is the `int` answer. The `return answer` line does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value of `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is that the Java method signature is quite flexible,
    allowing us to build exactly the methods we require.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the method signature defines how the method must be called and how
    a method must return a value, if it must, deserves further discussion. Let's give
    each part of that signature a name so that we can break it into chunks and learn
    about the parts separately.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a method signature with its parts labeled and ready for discussion.
    You can also take a look at the following table to further identify which part
    of the signature is which. This will make the rest of our discussion on methods
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modifier** | **return type** | **name of the method** (**parameters**)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples that we have used so far so that you can clearly identify
    the part of the signature under discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Part of signature | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Modifier | `public`, `private`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Return type | `int`, `boolean`, `float`, and so on, or any Java type, expression,
    or object |'
  prefs: []
  type: TYPE_TB
- en: '| Name of the method | `shootLazers`, `setCoordinates`, `addAToB`, and so on
    |'
  prefs: []
  type: TYPE_TB
- en: '| Parameters | (`int number`, `string type`), (`int x`, `int y`), (`int a`,
    `int b`), and so on |'
  prefs: []
  type: TYPE_TB
- en: Modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our previous examples, we only used a modifier twice, partly because the
    method doesn''t have to use the modifier. The modifier is a way of specifying
    which code can use your method. Some of the types of modifiers are `public` and
    `private`. Actually, regular variables can have modifiers too, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Modifiers (for methods and variables) are an essential Java topic but they are
    best dealt with when we discuss the other vital Java topic we have skirted around
    a few times so far—objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously promised, these mysterious objects will be revealed in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*. However, as we can see from our example methods and
    from the fact that all the examples we have written so far work just fine, modifiers
    are not necessary to facilitate our learning so far.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next up is the `return` type. Like a modifier, a `return` type is also optional,
    although it is more immediately useful to us. So let''s look a bit closer. We
    have seen that our methods can get anything done. But what if we need the result
    from what they have done? The simplest example of a return type we have seen so
    far was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `return` type in the signature is highlighted. So the `return`
    type is `int`. The `addAToB` method sends back (returns) to the code that called
    it a value that will fit in an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `return` type can be any Java type we have seen so far. The method, however,
    does not have to return a value at all. In this case, the signature must use the
    `void` keyword as the `return` type. When the `void` keyword is used, the method
    body must not attempt to return a value as this will cause a compiler error. It
    can, however, use the `return` keyword without a value. Here are some combinations
    of return type and uses of the `return` keyword that are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Another combination of `return` and `void` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is yet another combination of `return` and `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call each of the preceding methods one by one, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code would execute all the code statements in each method one
    by one. If the method signature had parameters, the code that calls the method
    would look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: Name of a method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we design our own methods, the method name is arbitrary, but there is
    a convention to use verbs that clearly explain what the method will do. Another
    convention is of the first letter of the first word in the name being lower case,
    and the first letter of each of the subsequent words being uppercase. This is
    called **camel case** because the shape the name can form has a hump in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This name is perfectly legitimate and will work. However, let''s take a look
    at a much clearer example that uses the conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: These are much clearer method names.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know that a method can return a result to the calling code. What if we need
    to share some data values from the calling code with the method? Parameters allow
    us to share values with the method. We have already seen an example with parameters
    when looking at return types. We will look at the same example but a little more
    closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters in this code are highlighted. Notice that in the first line
    of the method body, we use `a + b` as if they are already declared and initialized.
    Well, that''s because they are. The parameters of the method signature is their
    declaration, and the code that calls the method initializes them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as we have partly seen in previous examples, we don''t have to use `int`
    in our parameters. We can use any Java type, including types we design ourselves.
    We can mix and match types as well. We can also use as many parameters as necessary
    to solve our problem. An example of mixed Java types might help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: It's now time to get serious about our body.
  prefs: []
  type: TYPE_NORMAL
- en: Getting things done in the method body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The body is the part we have been avoiding so far with comments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: But actually, we know exactly what to do here already. Any Java syntax we have
    learned so far will work in the body of a method. In fact, if we look back, all
    of the code we have written so far has been in a method, albeit somebody else's
    method. For example, we wrote code in the `onCreate` and `onClick` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing we can do next is write some methods that actually do something
    in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Using methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't have to mess around with our math game project. We will quickly create
    a new blank project for each of the next two explorations into methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also don't need to spend time making a UI. We will use the Android console
    to view the results and discuss the implications of our examples of methods. As
    we are using the Android console to view the results of our work with methods,
    we will need to run all of these examples on the Android emulator, not on a real
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to set up a real device to output to the console, but we have
    not covered that in this book. If you want to find out more about using your actual
    device for debugging, take a look at the article at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can open the already typed code files in the usual way. The next
    two examples on methods can be found in the Packt Publishing code download in
    the `Chapter4` folder and the `AWorkingMethod` and `ExploringMethodOverloading`
    subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a quick reminder on how to create a new blank project.
  prefs: []
  type: TYPE_NORMAL
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New Project...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com`, or you could use your
    own company website's name here instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the **Next** button. On the next screen, ensure that the **Phone
    and tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer cutting-edge Android
    features we can have in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements, but this is not necessary
    for the example to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  prefs: []
  type: TYPE_NORMAL
- en: A working method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's make ourselves a simple working method, complete with return types
    and a fully functioning body.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will take three numbers as parameters and return a `true` or `false`
    value to the calling code depending upon whether one of the three numbers was
    randomly generated within the method or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `A Working Method`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this method, we will use the `Random` class we saw earlier and its `randInt`
    method as a part of the demonstration. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we declare a Boolean variable called `found` and initialize it to `false`.
    We will change `found` to `true` if and when we guess the random number correctly.
    Next, we declare our random number and print some useful values to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The last portion of code in our method tests to see whether there is a match
    for any of our passed-in parameters, prints some output, and then returns `true`
    or `false` using the `found` variable to the calling code in the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the code and print some values to the Android console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Launch an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All our console messages have a tag called **info**. The console window will
    already have appeared underneath the editor window. We can filter its contents
    to only show our messages by typing `info` in the search box, as shown in the
    following screenshot:![A working method](img/8859OS_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the search filter and the console output.
    We will now run through the code and explain the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, here is the precise console output, without the extraneous date,
    time, and package name added to the beginning of each line. Remember that we are
    dealing with a random number, so your output may vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what is happening. In step 2, we started writing our first method.
    We called it `guessANumber`. It has three `int` parameters and will return a Boolean.
    Remember that these three `int` parameters become fully initialized variables.
    First of all, however, in our method, we simply output the values of the new variables
    passed in as parameters as well as a message confirming that the code in our method
    is currently being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 3, we added more code to our method. We declared and initialized a
    Boolean variable called `found`, which we will use to return a value to the calling
    code and let the calling code know whether one of the parameters passed in was
    the same as the random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next (still in step 3), we generated a random number in the same way as we
    did earlier in the chapter. We also used `Log` to output the random number so
    that we can examine what went on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'In step 4, we used an `if` statement with the logical OR operator to detect
    whether any of the passed-in parameters matches the random number we just generated,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is true, that is, if any of `try1`, `try2`, or `try3` equals
    `randNum`, then the following code is run. Our `found` Boolean value is set to
    `true` and a message is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is not true, the `else` statement is executed, a different
    message is printed, and the `found` variable is left the same as it was—`false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our method, we return the `found` variable, which will be either
    `true` or `false`, to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we look at step 5, which is the code in the `onCreate` method, which calls
    our `guessANumber` method in the first place. We start by simply printing a message
    saying that we are in `onCreate` at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we make the call to `guessANumber` with the three parameters. In this
    case, we use 1, 2, and 3, but any `int` values would have worked. However, we
    wrap the call in an `if` statement. This means that the `return` value from the
    method will be used to evaluate the `if` statement. Simply put, if `true` is returned,
    the `if` statement will be executed and "**Found It**!" will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'On the contrary, if `false` is returned, the `else` statement gets executed
    and "**Can''t find it**" is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we are dealing with random numbers, so you might need to run
    it a few times before you see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A working method](img/8859OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you should note that the guesses sent to the function as parameters
    are arbitrary. As long as all the numbers are between 0 and 5 and are not duplicated,
    they will together have a 50 percent chance of finding the random number.
  prefs: []
  type: TYPE_NORMAL
- en: On a closing note, if you've to read only one tip in this whole book, it should
    be this one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Printing variable values to the console is a great way to examine what is going
    on inside your game and to find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring method overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are learning, methods are really diverse and deep as a topic, but hopefully,
    taking a step at a time, we will see they are not daunting in any way. We will
    be using what we have learned about methods when we enhance our math game. We
    will be exploring methods even more deeply in [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. For
    now, however, it will serve us well to look at one more topic on methods. Let's
    create a new project to explore **method** **overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will now see, we can create more than one method with the same name,
    provided the parameters are different. The code in this project is vastly simpler
    than that of the last project. It is how this code works that might appear slightly
    curious until we analyze it later:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new blank project called `Exploring Method Overloading`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the first method, we will simply call it `printStuff` and pass an `int`
    variable via a parameter to be printed. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also call the second method `printStuff` but pass a `string` variable
    to be printed. Copy the code for this method after the closing bracket of `onCreate`
    but before the closing bracket of `MainActivity`. Again, when you are prompted
    to import any classes, simply click on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet again, we will call this third method `printStuff` but pass a `string`
    variable and an `int` variable to be printed. As before, copy the code for this
    method after the closing bracket of `onCreate` but before the closing bracket
    of `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the methods and print some values to the Android console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Launch an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Java has treated three methods with the same name as totally
    different methods. This, as we have just demonstrated, can be really useful. It
    is called **method overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Method overloading and overriding confusion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloading and overriding are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading occurs when we have more than one method with the same name but
    different parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding occurs when we essentially replace a method with the same name and
    the same parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know enough about overloading and overriding to complete this book, but if
    you are brave and your mind is wandering, you can override an overloaded method.
    However, that is something for another time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the preceding code works. In each of the three steps (2, 3, and
    4), we create a method called `printStuff`, but each `printStuff` method has different
    parameters, so each is a different method that can be called individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The body of each of the methods is simple. It just prints the passed-in parameters
    and confirms which version of the method is being called currently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important part of our code is when we make it plain which method we
    want to call, using the appropriate parameters. In step 5, we call each of them
    in turn, using the appropriate parameters so that Java knows the exact method
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Now we know more than enough about methods, loops, and random numbers to make
    some improvements to our math game.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our math game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add some features to our math game using what we have just learned
    about methods and loops.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the code is available for copying in the `Chapter4` folder of the
    code download. The project is in the `MathGameChapter4` subfolder and encompasses
    all the remaining phases of improvement covered in this chapter, including enhancing
    the UI, amending our game activity, `setQuestion`, `updateScoreAndLevel`, `isCorrect`,
    and calling our new methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will make the game change the question after each time we attempt the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add difficulty levels to questions and random questions but within
    a range appropriate for that difficulty level.
  prefs: []
  type: TYPE_NORMAL
- en: We will show and update our score. The score goes up faster depending on the
    difficulty level of the question answered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get on with modifying our math game UI to incorporate our new game features.
    We will be adding a TextView to display the score and another TextView to display
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_game.xml` file in the editor window. We will add a new TextView
    to the very bottom of our UI for our score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Large Text** element from **Palette** and place it to the left, below
    our three answer buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to change the **id** property so that we can access our new TextView
    from our Java code. Ensure that the new TextView is selected by clicking on it.
    Now, in the **Properties** window, change the **id** property to `textScore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sake of clarity (although this step serves no use in programming), change
    the **text** property to `Score:999`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now put another **Large Text** element to the right of the one we just configured
    and change the **id** property to `textLevel`. The lower part of our UI should
    now look like this:![Enhancing the UI](img/8859OS_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, for the sake of clarity (although this step serves no use in programming),
    change the **text** property to `Level:4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just added two new TextView elements and assigned them both an ID that
    we can refer to in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have probably realized by now that the precise layout and size of our UI
    elements are unimportant as far as getting the game to work is concerned. This
    gives us a lot of flexibility in designing layouts for different screen sizes.
    As long as each layout for each screen size contains the same element types with
    the same IDs, the same Java code will work for different layouts. If you want
    to know more about designing for multiple screen sizes, take a look at [http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our enhanced UI and an understanding of how the Java `Random`
    class works, we can add the Java code to implement our new features.
  prefs: []
  type: TYPE_NORMAL
- en: The new Java code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously explained, the project code is available in the `Chapter4` folder
    of the downloadable code. The project is called `MathGameChapter4` and encompasses
    all the improvements covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, we will be adding lots of new code, moving some existing code,
    and modifying some existing code too. As so much is changing, we are going to
    approach the code from the very beginning. The new code will be explained completely,
    the code that has moved will be pointed out with a reason, and the code that has
    stayed the same and in the same place will have the least explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We will first make some modifications and deletions to our existing code. We
    will then look at designing and implementing each of our new methods to improve
    our code and add our new features.
  prefs: []
  type: TYPE_NORMAL
- en: Amending GameActivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s perform the necessary amendments and deletions to our current
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `GameActivity.java` file in the editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to consider the scope of the objects that represent our UI elements.
    Both `textObjectPartA` and `textObjectPartB` need to be accessible from the methods
    we will be creating soon. So let''s move their declarations, as we did with the
    multi-choice buttons in the previous chapter, out of the `onCreate` method so
    that they are accessible everywhere in our `GameActivity` class. The following
    code shows all our declarations so far. They are present immediately after the
    start of the `GameActivity` class. The recently added (or moved) declarations
    are highlighted. Notice that we have also added declarations for our two new TextViews
    and for the score and level displays. In addition, there are two new `int` variables
    that we can manipulate for our score and to keep track of our level. They are
    `currentScore` and `currentLevel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the code that assigns text to our Buttons or TextViews objects, and
    the code that initializes the parts of our question and assigns the values for
    our wrong answers, are now going to change and move, so we need to delete it all.
    Everything shown in the following code is to be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet needs to be deleted too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity and context, here is the entire `onCreate` method as it currently
    stands. There is nothing new here, but you can see your code, which links our
    Button and TextView objects that we declared in step 2\. Again, this code includes
    our two new TextViews, which are highlighted, but everything else, which is described
    in steps 3 and 4, is deleted. As before, there is a piece of code that makes our
    game listen to button clicks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will delete some more code that we don''t need because we are going
    to make it more efficient by compartmentalizing it into our new methods and adding
    our new features at the same time. So in our `onClick` method, in each case of
    our `switch` statement, we want to delete the `if` and the `else` statements.
    We will be completely rewriting these, but we will leave in place the code that
    initializes our `answerGiven` variable. Our `onClick` method will now look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wow! That was a lot of code, but as we saw along the way, there were no new
    concepts. In step 2, we simply moved the initialization of our Button and TextView
    objects to a place where they will now be visible from anywhere within our class.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 3 and 4, we did a fair bit of deletion because we will no longer be
    making the question or populating the multi-choice buttons in `onCreate`, as this
    is not flexible enough. We will soon see how we improve on this.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we deleted the code that tested whether the answer was correct or
    incorrect. However, as we saw, we still initialized the `answerGiven` variable
    in the same way—in the appropriate case of our `switch` statement in the `onClick`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now we are ready to consider and design some new methods to compartmentalize
    our code, avoid repetitions in it, and add our extra features. Consider the following
    methods that we will soon implement.
  prefs: []
  type: TYPE_NORMAL
- en: The methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now walk through writing some methods. As we will see, the methods
    will compartmentalize our code and prevent the implementation of our new features
    from causing the code to become too long and sprawling:'
  prefs: []
  type: TYPE_NORMAL
- en: We will write a `setQuestion` method to prepare a question of appropriate difficulty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write an `updateScoreAndLevel` method that will do just that. We will
    also write an `isCorrect` method that one of our other methods will use to evaluate
    the correctness of the answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we will strategically place the code that calls our new methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will do each of these tasks one at a time and explain the code along the
    way, as leaving the explanation to the end will make referring to individual steps
    cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use many of the features of Java that we learned in this chapter and
    the previous chapter. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch control structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get started with our first method.
  prefs: []
  type: TYPE_NORMAL
- en: The setQuestion method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We determined that we needed a method to prepare a question for us; `setQuestion`
    seems like a decent name for such a method. Every time our player gives an answer
    by tapping one of the three multi-choice buttons, a new question will need to
    be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: This method will need to generate values for our `partA` and `partB` variables
    as well as show them in our TextViews referenced by the `textObjectPartA` and
    `textObjectPartB` objects. In addition, the method will need to assign the new
    correct answer to our `correctAnswer` variable, which will then be used to calculate
    some suitable incorrect answers. Finally, the method will show both the correct
    and incorrect answers on our multi-choice buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, our `setQuestion` method will need to take into account the level
    held in `currentLevel` to determine the range or difficulty of the question it
    will ask. Let''s go through the code. If you want to type this code as we go,
    then just make sure you place it after the closing bracket of `onClick` but before
    the closing bracket of our `GameActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have the method signature and the opening curly brace before
    the body of our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that the return type is `void`, so `setQuestion` will not return
    a value to the code that calls it. Also, there are no parameters here, so it does
    not need any value passed for it to work. Let''s see what it does. Now we enter
    the code to generate the two parts of the question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we declared a new `int` variable, `numberRange`, and
    initialized it by multiplying the player''s `currentLevel` value by `3`. Then
    we got a new `Random` object called `randInt` and used it to generate new values
    based on `numberRange`. We did this to the `partA` and `partB` variables. As the
    value of `currentLevel` increases, so potentially does the difficulty of the question.
    Now, just as we have written in the past, we write this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We assigned the answer of our new multiplication question to `correctAnswer`.
    Then we declared and assigned two incorrect answers to the new `int` variables,
    `wrongAnswer1` and `wrongAnswer2`. We also used the `setText` method of our TextView
    objects to display the question to the player. Notice that we have not yet displayed
    the correct and incorrect answers. Here it is. Try to work out what is happening
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used our `Rando`m object, `randInt`, to generate
    a number between 0 and 2, and assigned the value to a new `int` variable called
    `buttonLayou`t. We then used `buttonLayou`t to switch between all its possible
    values: 0, 1, or 2\. Each `case` statement sets the correct and incorrect answers
    to the multi-choice buttons in a slightly different order, so the player can''t
    just keep tapping the same button over and over to achieve a massive score. Notice
    the extra closing bracket after the closing bracket of the switch. This is the
    end of our `setQuestion` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We explained the code fairly thoroughly as we went through it but it might be
    worthwhile to just take a closer look at some parts again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we saw our method signature with a `void` return type and no parameters.
    In step 2, we generated some random numbers that will be within a certain range.
    This range isn''t as obvious as it might seem at first. First, we assigned, declared,
    and initialized `numberRange` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'So if the player is at the first question, then `currentLevel` will hold the
    value `1` and `numberRange` will be initialized as `3`. Then we made a new `Random`
    object as previously discussed and entered this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'What occurs here is that the `nextInt` method of the `Random` object, `randInt`,
    will return a value of either 0, 1, or 2 because we have given it a seed of 3\.
    We don''t want any zeros in our game because they result in very easy multiplication,
    so we enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator, which you probably remember from [Chapter 3](ch03.xhtml "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*, when we discussed
    operators, adds 1 to `partA`. We then do exactly the same to our `partB` variable,
    which means that assuming that the player is still on level 1, they will have
    a question that will be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 1, 1 x 2, 1 x 3, 2 x 1, 2 x 2, 2 x 3, 3 x 1, 3 x 2, or 3 x 3
  prefs: []
  type: TYPE_NORMAL
- en: As the level increases, the potential range of the question increases significantly.
    So at level 2, the options are that either part of the question could be from
    1 to 6; for level 3, from 1 to 9; and so on. It is still possible to get an easy
    question on a higher level but it becomes less likely as the levels advance. Finally
    in this step, we display the question to the player using the `setText` method.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we have seen before but this time we varied it slightly. We calculate
    and assign a value for `correctAnswer`, and declare and assign values to `wrongAnswer1`
    and `wrongAnswer2`, which will hold the wrong answer choices for our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 varies very slightly from what we did in `onCreate` in the previous chapter
    because we subtract and add 2 to `wrongAnswer1` and `wrongAnswer2`, respectively.
    This makes guessing the answer to multiplication questions a little harder because
    you can't eliminate answers based on whether they are odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 simply randomizes which buttons the correct and incorrect answers will
    be placed on. We don't need to keep track of this because when the time comes
    to compare the value on the button pressed with the correct answer, we can simply
    use our Java code to discover it as we did in [Chapter 3](ch03.xhtml "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*.
  prefs: []
  type: TYPE_NORMAL
- en: The updateScoreAndLevel method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of this method speaks for itself. Because the keeping of the score
    is not simple and because we want higher levels to yield higher scores, we will
    compartmentalize the code to keep our program readable. If we then want to make
    modifications to the scoring system, they can all take place in there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code can go anywhere within the opening and closing braces of `GameActivity
    {}`, but it is good practice to place them in the approximate order they will
    be used. So why not start adding your code after the closing brace of `setQuestion`
    but obviously before the closing brace of `GameActivity`? Here is the method signature
    with the opening brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that our method does not return a value but that it does receive
    an `int`, which it will require to do its stuff. The name of the parameter is
    a big clue to what we will be passing. We will see that in action in the body
    in a minute, but if passing the player''s answer to this method instead of the
    `isCorrect` method is a bit confusing, we will see things become clearer in the
    next chunk of code. Here is the next part of the code to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot happening here, so we will dissect it more once we have the
    method completed. Basically, it calls the `isCorrect` method (which we will write
    soon) and if the response is `true`, adds to the player''s score in a `for` loop.
    After that, the method adds 1 to `currentLevel`. Here comes the `else` part of
    the code in case the response from `isCorrect` is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If the response is `false`, that is, if the player got the answer wrong, the
    `currentScore` variable is set to `0` and the level back to `1`. Finally for this
    method, we type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: In the previous step, we updated the actual TextViews that the player sees with
    the newly determined score and level. The method then ended and the control of
    the program returned to the code that called `updateScoreAndLevel` to begin with.
    Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We explained most of the code as we went but it might be good to quickly review
    it and dig a bit deeper into certain parts, especially the call to `isCorrect`
    in that odd-looking `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 1, we began with the method signature. Then in step 2, we began with
    the aforementioned curious `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We have seen this type of statement before in the *A working method* example
    in the *Methods* section of this chapter. What is happening here is that the call
    to `isCorrect` is replacing the statement to be evaluated, or rather it *is* the
    statement to be evaluated. So `isCorrect` is called with the `answerGiven` variable.
    The `answerGiven` variable, as you might remember, was passed to `updateScoreAndLevel`.
    This time, it is passed to the `isCorrect` method, which will do some work with
    it and perhaps a few other things. Then it will return to the `if` statement a
    value of `true` or `false`. The value will be true if the question is answered
    correctly and false if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the `if` statement evaluates to true, the program runs this bit of
    code (also from step 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The code enters a `for` loop where the starting variable `i` is initialized
    to 1 like this: `int i = 1;`. Furthermore, the loop is instructed to continue
    as long as `i` is less than or equal to our `currentLevel` variable. Then within
    the `for` loop, we add `i` to the current score. As an example, let''s assume
    that the player has just got a question correct and we enter the `for` loop with
    `currentLevel` at 1\. The player''s score is still at 0 because this is their
    first correct answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At pass 1, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 1`, so it is equal to `currentLevel`, which is also 1\. So we enter the
    `for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 1`, so `currentScore` equals 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is `1`, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 2, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 2, so it is now greater than `currentLevel`, which is
    1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop condition evaluates to `false` and we continue with the code
    after the `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentLevel` is increased by 1 to 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at that `for` loop again assuming that the player gets the next
    question correct as well, and we are back in `updateScoreAndLevel`. This time,
    `isCorrect` has evaluated true and we enter the `for` loop but with a slightly
    different situation than the last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'At pass 1, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i = 1`, so `i` is less than `currentLevel` is 2 and we enter the `for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 1`, `currentScore` `= 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is equal to 1, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 2, we have the following steps happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 2 and it is now equal to `currentLevel`, which is also
    2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i = 2`, `currentScore = 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add `i`, which is now equal to 2, to `currentScore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `currentScore` variable is now equal to 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At pass 3, the following steps take place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is incremented to 3 and it is now greater than `currentLevel`, which is
    2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop condition evaluates to false and we continue with the code after
    the `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `currentLevel` is increased by 1 to 3\. So the next time, we will
    have an extra pass through our `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is happening is that with each level, the player is being rewarded with
    another pass through the `for` loop, and each pass through the `for` loop adds
    a greater value to their score. To summarize what happens in the `for` loop, here
    is a brief table of values showing how the player''s score is increased based
    on the `currentLevel` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| currentLevel | Added to currentScore | currentScore after for loop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 (1 + 2) | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 6 (1 + 2 + 3) | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we could have kept it really simple and not used a `for` loop. We
    could just use `currentScore = currentScore + level` perhaps, but that doesn't
    offer an ever increasing reward in the same way as our current solution does and
    we wouldn't have been able to practice our `for` loops either.
  prefs: []
  type: TYPE_NORMAL
- en: If `if(isCorrect(answerGiven))` evaluates to `false`, it simply resets the score
    to 0 and the level to 1 in step 3\. Step 4 then updates our TextViews for the
    score and the level using the variables we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have just one more method to write. Of course, this is the `isCorrect`
    method, which we just called.
  prefs: []
  type: TYPE_NORMAL
- en: The isCorrect method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is nice and simple because we have seen all of the relevant code
    before. It is just the method signature and the return value that we need to look
    at carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code just after the closing brace of the `updateScoreAndLevel` method
    but before the closing brace of the `GameActivity` class. Type the method signature
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that the method must return a Boolean value, `true` or `false`.
    If it doesn''t, then the program won''t compile. This guarantees that when we
    use this method as the evaluation expression in the `updateScoreAndLevel` method,
    we will definitely get a result. It can be true or false. The signature also shows
    us the `answerGiven` variable passed in, ready for us to use. Type this code,
    which will determine that result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen almost all of the preceding code before. The exception is that
    we declare a Boolean variable, `correctTrueOrFalse`, which we assign to `true`
    if the player answers correctly and to `false` if not. We know whether the player
    is correct or not because we compare `answerGiven` to `correctAnswer` in the `if`
    statement. Notice that we have also triggered the appropriate Android pop-up toast
    message as we did before. Finally, we do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We just returned whatever value is contained within `correctTrueOrFalse`. So
    the critical `if` statement in `updateScoreAndLevel`, which we discussed in detail,
    will know what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure we understand what is happening in `isCorrect`, let's go through
    the sequence of events in our code. In step 1 we have the method signature. We
    see that we will return a `true` or `false` value and receive `int`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we declare a Boolean variable called `correctTrueOrFalse` to hold
    the value we will soon return. Then we test for a right or wrong answer with `if(answerGiven
    == correctAnswer)`. If the two compared values match, a congratulatory message
    pops up and we assign `true` to our Boolean variable. Of course, if the `if` statement
    is `false`, we offer commiserations to the player and assign `false` to our important
    Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Finally in step 3, we send back `true` or `false` so that the `updateScoreAndLevel`
    method can proceed with its work.
  prefs: []
  type: TYPE_NORMAL
- en: We have now implemented all our methods. It's time to put them to work.
  prefs: []
  type: TYPE_NORMAL
- en: Calling our new methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, our shiny new methods won''t do anything until we call them. So
    here is the plan to call these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we want to set a new question for the player. Therefore,
    as the last line of code in our `onCreate` method, we can call our `setQuestion`
    method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we turn our attention to the `onClick` method, which already detects which
    button has been pressed and loads the player''s answer into our `answerGiven`
    variable. So at the end of the `onClick` method, after the closing brace of the
    `switch` statement, we just call this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'This sends our player''s attempted answer to `updateScoreAndLevel`, which evaluates
    the answer using `isCorrect`, adds points, and increments the score if the answer
    is correct or resets the score and level if not. All that we need now is another
    question. Add this line. It will ask another question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'So now what happens is that the player starts our math game by clicking on
    its icon on their Android device. Our `GameActivity` class declares a few variables
    that we need access to throughout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Then `onCreate` initializes some variables and gets our buttons ready to receive
    clicks from the player before asking the first question by calling `setQuestion`.
    The game then waits for the player to attempt an answer. When the player attempts
    an answer, it is dealt with by `onClick`, `updateScoreAndLevel`, and `isCorrect`.
    Then the program control comes back to `onClick` again, `setQuestion` is called
    again, and we wait for the player's answer once more.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our math game is coming along nicely. Unfortunately, we have to move on soon.
    The project has served its purpose to demonstrate some fundamentals of Java programming
    as well as some key Android features. Now we need to start introducing some more
    game-related topics.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on, there are two really easy things to make our game a bit more
    cool and complete. In case you are wondering about the High Scores button, we
    will see how that can be implemented when we look at our next game project in
    [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming and Java
    Essentials*. You will then have enough information to easily come back and implement
    high scores on your own.
  prefs: []
  type: TYPE_NORMAL
- en: The other feature that would really round off our game and make it more playable
    is an overall or per question time limit. Perhaps even increasing the score based
    on how quickly the correct answer is given will help. We need some new Java tricks
    up our sleeves before we can do that, but we will see how we can measure and respond
    to time in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming
    and Java Essentials*, when we talk about threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will quickly learn two improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Locking the screen orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the home screen image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going full screen and locking orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that if you rotate your device while the app is running,
    not only does your game UI get distorted but the game progress is also lost. What
    goes wrong is that when the device is rotated, the `onPause` and `onStop` methods
    are called. Then the app is restarted. We could handle this by overriding the
    `onPause` method and saving our data. We will do this later. For now we don't
    want the screen to rotate anyway, so if we stop it we solve two problems in one.
  prefs: []
  type: TYPE_NORMAL
- en: 'While adding code to this file, Android Studio may try to "help" by adding
    extra formatting. If you get red error indicators, you can compare your `AndroidManifest.xml`
    file with the one in the code download in the `Chapter4/MathGameChapter4` folder.
    Alternatively, you can simply replace the contents of your file with the contents
    of the file in the download. The step-by-step changes are detailed in this guide
    just to highlight what is changing:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the first step in locking the app to portrait. Open the `AndroidManifest.xml`
    file. It is located directly below the `res` folder in the Project Explorer. Find
    the first opening `<activity` in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a new line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Repeat step 2 after the second instance of `<activity`. We have now locked both
    the menu and game screens in portrait mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the game full screen, in the same file, find the following text and
    add the line in bold after it but before the closing `>` sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the same change to the `GameActivity` activity like this. Again, here
    is the code in context in order to avoid mistakes with these `>` signs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you rotate the device during gameplay, the portrait orientation will
    be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom image (instead of the Android icon)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We probably don''t want to have the Android image on our finished game home
    screen, so here is the procedure to change it. This quick guide relies on you
    having an image you would like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the required image to the layout folder. Copy your image
    file by clicking on it in **Windows Explorer** and using *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now find the `drawable-mdpi` folder in the Android Studio Project Explorer.
    Click on the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the image to the folder using *Ctrl* + *V*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the image is a part of our project. We simply need to choose it in the same
    way as we chose the image of the Android robot previously. Open `activity_main.xml`
    in the editor window and click on **ImageView** (currently an Android robot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** window, find the **src** property. Click on it and then
    on **...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for your image and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have the image of your choice on the home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q1) Guess what is wrong with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Q2) What will `x` be equal to at the end of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We came a really long way in this chapter. You got a serious handle on Java
    loops and took your first, fairly deep look into Java methods and how to use them.
    You learned how to generate random numbers and significantly enhanced your math
    game using all of the knowledge you gained.
  prefs: []
  type: TYPE_NORMAL
- en: As the chapters proceed, the games will get more and more real-game-like. In
    the next chapter, we will make a game to test the player's memory. It will have
    sound, animation and will actually save the player's high scores too.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on your progress so far but let's keep going.
  prefs: []
  type: TYPE_NORMAL
