- en: 3\. Character Class Components and Blueprint Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on the `Character` class in C++. You will be shown how
    to extend the `Character` class in C++ and then extend this newly created `Character`
    class further in Blueprints via inheritance. You will also work with player input
    and some movement logic.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand how class inheritance
    works in UE4 and how to utilize it to your advantage. You will also be able to
    work with Axis and Action Input Mappings, which are key in driving player-related
    input logic.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create empty projects and import
    files, which folder structure to use, and how to work with animations. In this
    chapter, we'll explore some other key tools and functionality that you will work
    with when using Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Game developers often need to use certain tools that save them time and energy
    when building game functionality. Unreal Engine's powerful object inheritance
    capabilities give developers the edge they need to be more efficient. Developers
    can also work with both C++ and Blueprints interchangeably and use them to their
    benefit when developing games.
  prefs: []
  type: TYPE_NORMAL
- en: Another value-added benefit developers gain is the ability to extend code for
    use later in a project. Let's say your client has new requirements that build
    upon the old ones (as is the case in most game studios). Now, to extend functionality,
    developers can just inherit a class and add more functionality to it to get results
    quickly. This is very powerful, and it comes in handy in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the Unreal `Character` class, create C++ code,
    and then extend it in Blueprints, before finally using it to create an in-game
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Character Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about the Unreal `Character` class, let's briefly touch on the
    concept of inheritance. If you're used to working with C++ or another similar
    language, you should already be familiar with this concept. Inheritance is the
    process whereby a class derives characteristics and behavior from another class.
    A C++ class can be extended to create a new class – the derived class – that retains
    properties of the base class and allows for these properties to be modified, or
    for new characteristics to be added. An example of this is the `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: A `Character` class is a special type of pawn and is a descendant of the Unreal
    `Pawn` class. Extending upon the `Pawn` class, the `Character` class has some
    movement capabilities by default, along with some inputs that add movement to
    the character. As standard, the `Character` class gives users the ability to get
    a character to walk, run, jump, fly, and swim within the created world.
  prefs: []
  type: TYPE_NORMAL
- en: Since a `Character` class is an extension of the `Pawn` class, it contains all
    the code/logic of the pawn, and developers can extend this class to add more functionality
    to it. When extending the `Character` class, its existing components get carried
    over to the extended class as inherited components. (In this case, the Capsule
    component, Arrow component, and Mesh).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inherited components cannot be removed. Their settings may be changed, but a
    component that's added to a base class will always be present in the extended
    class. In this case, the base class is the `Pawn` class, while the extended (or
    child) class is the `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Character` class provides the following inherited components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capsule component**: This is the root component that serves as the "origin"
    that other components get attached to within the hierarchy. This component can
    also be used for collisions and takes the form of a capsule that logically outlines
    many character forms (especially humanoid ones).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide` when the game starts, but it can be tweaked to be visible. This component
    can be useful for debugging and adjusting game logic if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Character` class. The Skeletal Mesh, which is the form the character will
    take, can be set up here along with all the relevant variables, including animations,
    collisions, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most developers usually prefer to code the game and character logic in C++ and
    extend that class to blueprints so that they can perform other simple tasks, such
    as connecting assets to the class. So, for example, a developer may create a C++
    class that inherits from the `Character` class, write all the movement and jumping
    logic within that class, and then extend this class with a Blueprint, in which
    the developer updates the components with the required assets (such as the Skeletal
    Mesh and animation blueprint), and optionally code additional functionality into
    blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Character Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Character` class is extended when it is inherited by either C++ or Blueprints.
    This extended `Character` class will be a child of the `Character` class (*which
    will be called its parent*). Class extension is a powerful part of object-oriented
    programming, and classes can be extended to great depths and hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Creating and Setting Up a Third-Person Character C++ Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a C++ class based on a `Character` class.
    You will also initialize the variables that will be set in the default values
    for the class that will extend this `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Unreal Engine, select the `Games` category, and click the `Next` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Blank` and click the `Next` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `C++` as the project type, set up the project name as `MyThirdPerson`,
    choose a suitable project directory, and click the `Create Project` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* in the `Content Browser` interface and click the `New C++ Class` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box that opens, select `Character` as the class type and click
    the `Next` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `MyThirdPersonChar` and click the `Create Class` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon doing so, Visual Studio will open the `MyThirdPersonChar.cpp` and `MyThirdPersonChar.h`
    tabs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On some systems, it might be required to run the Unreal Engine editor with administrator
    privileges to automatically open the Visual Studio solution with the newly created
    C++ files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MyThirdPersonChar.h` tab and add the following code under the `GENERATED_BODY()`
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''re declaring two components: the `Camera` itself
    and `Camera boom`, which acts as the placeholder for the camera at a certain distance
    from the player. These components will be initialized in the constructor in *Step
    11*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following in the includes section, under `#include "CoreMinimal.h"`,
    in the `MyThirdPersonChar.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head over to the `MyThirdPersonChar.cpp` tab and add the following includes
    after the `#include MyThirdPersonChar.h` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the code adds the relevant classes to the class,
    which means we now have access to its methods and definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AMyThirdPersonChar::AMyThirdPersonChar()` function, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the preceding code snipped will set up the camera to bind its
    rotation with the pawn's. This means that the camera should, in turn, rotate with
    rotation of the player controller associated with this pawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to the Unreal Engine project and click the `Compile` button in the top bar:![Figure
    3.1: Compile button on the Unreal Editor top bar'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Compile button on the Unreal Editor top bar'
  prefs: []
  type: TYPE_NORMAL
- en: A `Compile Complete!` message should appear on the bottom-right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can locate the completed exercise code files on GitHub, in the `Chapter03`
    -> `Exercise3.01` directory, at the following link: [https://packt.live/3khFrMt](https://packt.live/3khFrMt).'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you've learned how to extend the `Character` class.
    You also learned how to initialize the default components of the `Character` class
    and how to compile the updated code from within Unreal Editor. Next up, you will
    learn how to extend the C++ class you created in Blueprints and why that is feasible
    in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the C++ Class with Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, most developers extend the C++ code logic to blueprints
    in order to link this with the assets they will use. This is done to achieve easy
    asset assignment compared to finding and setting up the asset in code. Furthermore,
    it gives developers the ability to use powerful blueprint features such as Timelines,
    Events, and ready-to-use macros, in combination with their C++ code, to achieve
    the maximum benefit of developing with both C++ and Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have made a C++ `Character` class. In it, we have set up components
    and movement capabilities. Now, we want to specify the assets that are going to
    be used in our class, as well as add input and movement ability. For this, it
    is easier to extend with Blueprint and set up the options there. This is what
    we will be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Extending C++ with Blueprints'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will learn how to extend the C++ class you created with
    Blueprints to add Blueprint code on top of the pre-existing C++ code. You will
    also be adding input key bindings, which will be responsible for moving the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and extract all the contents of the `Chapter03` *|* `Exercise3.02`
    *|* `ExerciseFiles` directory, which can be found on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://packt.live/2GO0dG8](https://packt.live/2GO0dG8).'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the `Content` folder inside the `MyThirdPerson` project we created
    in *Exercise 3.01*, *Creating and Setting Up a Third-Person Character C++ Class*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the `MixamoAnimPack` folder we created in *Step 1* and paste it into the
    `Content` folder directory we opened in *Step 2*, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MixamoAnimPack` assets were obtained from the Epic marketplace via the
    following link: [https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack](https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: MixamoAnimPack placed in the project directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2: MixamoAnimPack placed in the project directory'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project. *Right-click* inside the `Content Browser` interface and click
    `Blueprint Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Search` dialogue, type `GameMode`, *right-click* the class matching
    the name, and click the `Select` button. Have a look at the following screenshot:![Figure
    3.3: Creating the GameMode class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Creating the GameMode class'
  prefs: []
  type: TYPE_NORMAL
- en: Name the blueprint we created in *Step 6* `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, repeat *Step 5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Search` box, type `MyThirdPersonChar`, select the class, and then *right-click*
    on the `Select` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the blueprint we created in *Step 9* `BP_MyTPC`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `World Settings` tab, click the `None` option next to `GameMode Override`
    and select `BP_GameMode`:![Figure 3.4: Specifying Game Mode in World Settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Specifying Game Mode in World Settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `Default Pawn Class` to `BP_MyTPC`:![Figure 3.5: Specifying Default Pawn
    Class in Game Mode'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: Specifying Default Pawn Class in Game Mode'
  prefs: []
  type: TYPE_NORMAL
- en: Open `BP_MyTPC` and click on the `Mesh (Inherited)` component in the hierarchy
    of the `Components` tab on the left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` tab, find the `Mesh` section and set `Skeletal Mesh` to `Maximo_Adam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Meshes and Animations will be covered in depth in *Chapter 13*, *Blend Spaces
    1D, Key Bindings, and State Machines*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Details` tab, find the `Animation` section and set `Anim Class` to
    `MixamoAnimBP_Adam_C`. You''ll note that this class name gets suffixed with `_C`
    when selected. This is basically the instance of the blueprint created by UE4\.
    Blueprints, in a working project/build, usually get suffixed this way to differentiate
    between a Blueprint Class and an instance of that class.![Figure 3.6: Setting
    up Anim Class and Skeletal Mesh'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: Setting up Anim Class and Skeletal Mesh'
  prefs: []
  type: TYPE_NORMAL
- en: From the top-most menu, go to the `Edit` drop-down and click `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `Input` section, which can be found in the `Engine` section:![Figure
    3.7: Input section of Project Settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: Input section of Project Settings'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Bindings` section, click the `+` icon next to `Axis Mappings` and expand
    the section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Action Mappings are single keypress actions that are performed such as jump,
    dash, or run, while Axis Mappings are float values that are assigned that will
    return a floating-point value based on the keypress of the user. This is more
    relevant in the case of gamepad controllers or VR controllers, where the analog
    thumb stick comes into play. In that case, it would return the floating value
    of the state of the thumb stick, which is very important for managing player movement
    or related functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Rename `NewAxisMapping_0` to `MoveForward`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MoveForward` section, click the drop-down menu and select `W`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `+` icon next to the `MoveForward` icon to add another field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the new field as `S`. Set its scale to `-1.0` (since we want to move backward
    with the `S` key).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another axis mapping by repeating *Step 18*, name it `MoveRight`, and
    add two fields – `A` with `-1.0` for the scale and `D` with `1.0` for the scale:![Figure
    3.8: Movement Axis Mappings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.8: Movement Axis Mappings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `BP_MyTPC` and click the `Event Graph` tab:![Figure 3.9: Event Graph tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: Event Graph tab'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* anywhere inside the graph, type `MoveForward`, and select the
    first node option:![Figure 3.10: MoveForward Axis Event'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.10: MoveForward Axis Event'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* inside the graph, search for `Get Control Rotation`, and select
    the first node option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the camera associated with a player can choose not to show the pawn's
    yaw, roll, or pitch, the `Get Control Rotation` gives the pawn full aim rotation.
    This is useful in many calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from `Return Value` of the `Get Control Rotation` node,
    search for `Break Rotator`, and select it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the graph, search for `Make Rotator`, and select the first
    node option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `Z` (*Yaw*) node from `Break Rotator` to the `Z` (*Yaw*) node of
    the `Make Rotator` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make `Rotator` create a rotator with the Pitch, Roll, and Yaw values, while
    the break rotator splits a rotator into its components (Roll, Pitch, and Yaw).
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from `Return Value` of the `Make Rotator` node, search
    for `Get` `Forward Vector`, and select it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag from `Return Value` of the `Get Forward Vector` node,
    search for `Add Movement Input`, and select it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `Axis Value` node from the `InputAxis MoveForward` node to the `Scale
    Value` node in the `Add Movement Input` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the white `Execution` pin from the `InputAxis MoveForward`
    node to the `Add Movement Input` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the graph, search for `InputAxis MoveRight`, and select
    the first node option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag from `Return Value` of the `Make Rotator` node, search
    for `Get Right Vector`, and select it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* and drag from `Return Value` of the `Get Right Vector` node, search
    for `Add Movement Input`, and select it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `Axis Value` pin from the `InputAxis MoveRight` node to the `Scale
    Value` pin in the `Add Movement Input` node we created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, connect the `white Execution` pin from the `InputAxis MoveRight` node
    to the `Add Movement Input` node we added in *Step 36*:![Figure 3.11: Movement
    logic'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: Movement logic'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head to the `Viewport` tab. Here, you will see that the character''s front
    is not pointing in the direction of the arrow and that the character is displaced
    above the capsule component. Click on the `Mesh` component and select the object
    translation node located at the top of the viewport. Then, drag the arrows on
    the Mesh to adjust it so that the feet align with the bottom of the capsule component
    and the Mesh is rotated to point toward the arrow:![Figure 3.12: Translation Rotation
    and Scale Selector section'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12: Translation Rotation and Scale Selector section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the character is aligned in the capsule, it will appear as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Mesh adjusted within the capsule component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: Mesh adjusted within the capsule component'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Toolbar` menu, press the `Compile` button and then `Save`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the map tab and press the `Play` button to view your character in-game.
    Use the *W*, *A*, *S*, and *D* keys to move around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can locate the completed exercise code files on GitHub, in the `Chapter03`
    -> `Exercise3.02` directory, at the following link: [https://packt.live/3keGxIU](https://packt.live/3keGxIU).'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the `.rar` file, double-click the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you are now able to understand how to extend C++
    code with Blueprints, and why that is favorable in many situations for the developer.
    You also learned how to add input mappings and how they are used to drive player-related
    input logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the activity for this chapter, you will be combining the skills you have
    gained from the previous exercises of this chapter and extending the project you
    completed in *Activity 2.01, Linking Animations to a Character* activity of *Chapter
    2*, *Working with Unreal Engine*. This will allow you to build on your own created
    Blueprint and see how that maps to real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Extending the C++ Character Class with Blueprint in the Animation
    Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've created a C++ class and extended it with Blueprints, it is time
    to bring both concepts together in a real-world scenario. In this activity, your
    aim is to make our character from *Activity 2.01*, *Mixamo Character Animation*,
    which can be found in *Chapter 2,* *Working with Unreal Engine,* to jump using
    the *spacebar* key on your keyboard. However, you need to create the `Character`
    class from scratch in C++ and then later extend it with Blueprint to reach the
    final goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project from *Activity 2.01*, *Mixamo Character Animation*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Character` class in C++ that will initialize the character variables,
    including the camera associated with the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the Jump input to the *spacebar* key in the project settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the created C++ class with a blueprint to add the associated assets and
    jump functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The character should be able to jump when you press the *spacebar* key. The
    level should use the Blueprint that extends the C++ `Character` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Ganfault jump activity expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.14: Ganfault jump activity expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you've understood scenarios where C++ code is extended
    in Blueprints to implement functionalities and logic. This combination of C++
    and Blueprints is the most powerful tool game developers possess to create masterful
    and unique games within Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a C++ `Character` class, add initializer
    code to it, and then use Blueprints to extend it to set up assets and add additional code.
  prefs: []
  type: TYPE_NORMAL
- en: The result obeys the C++ code, as well as the Blueprint code, and can be used
    in any purposeful scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to set up Axis Mappings mapped to the *W*, *A*, *S*, and
    *D* keys to move players (which is the default movement mapping in many games).
    You also learned how to make the character jump within the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore Input Mapping in-depth and how to use
    the Mobile Previewer within Unreal Editor. This will help you create games with
    solid inputs mapped to game and player logic. It will also allow you to quickly
    test what your game will look and feel like on a mobile, all within Unreal Editor.
  prefs: []
  type: TYPE_NORMAL
