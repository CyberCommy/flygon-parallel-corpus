- en: Chapter 6. Accessing and Using Web Services in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly touched on the OAuth 2.0 process and emulated
    this process within our own API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We're going to explore this process a bit further in this chapter by connecting
    our users to a few existing ubiquitous services that offer OAuth 2.0 connectivity
    and allowing actions in our application to create actions in their applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is when you post something on one social network and are
    given the option to similarly post or cross-post it on another one. This is precisely
    the type of flow with which we'll be experimenting here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In order to really wrap our heads around this, we'll connect existing users
    in our application to another one that utilizes OAuth 2.0 (such as Facebook, Google+,
    and LinkedIn) and then share resources between our system and the others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: While we can't make these systems return the favor, we'll continue down the
    road and simulate another application that is attempting to work within the infrastructure
    of our application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to other services via OAuth 2.0 as a client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting our users share information from our application to another web application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing our API consumers to make requests on behalf of our users
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that we are making safe connections outside of OAuth requests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, as a client, you should be comfortable using OAuth
    to connect user accounts to other services. You should also be comfortable at
    making secure requests, creating ways to allow other services to connect to your
    services, and making third-party requests on behalf of your users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our users to other services
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a better understanding of how the OAuth 2.0 process works in practice,
    let's connect to a few popular social networks, specifically Facebook and Google+.
    This isn't merely a project for experimentation; it's how a great deal of modern
    social networks operate by allowing intercommunication and sharing among services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this common, but it also tends to induce a higher degree of adoption
    when you allow seamless connections between dissonant applications. The ability
    to share from such sources on services such as Twitter and Facebook has helped
    to expedite their popularity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: As we explore the client side of things, we'll get a good grasp of how a web
    service like ours can allow third-party applications and vendors to work within
    our ecosystem and broaden the depth of our application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this process, we''re going to get an existing OAuth 2.0 client for
    Go. There are a few that are available, but to install Goauth2, run a `go get`
    command as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we want to compartmentalize this access to OAuth 2.0 services, we can create
    a standalone file in our imports directory that lets us create a connection to
    our OAuth provider and get the relevant details from it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In this brief example, we''ll connect a Facebook service and request an authentication
    token from Facebook. After this, we''ll return to our web service to grab and
    likely store the token:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is all we''ll need to create a standalone package that we can call from
    elsewhere. In this case, we have just one service; so, we''ll create the following
    variables as global variables:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will get these endpoints and variables from the provider, but they're obviously
    obscured here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redirectURL` variable represents a place where you''ll catch the sent
    token after a user logs in. We''ll look closely at the general flow shortly. The
    `main` function is written as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we take the URL that''s generated and visit it directly, it''ll take us
    to the login page that is similar to the rough version that we built on the last
    page. Here''s an authentication page that is presented by Facebook:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting our users to other services](img/1304OS_06_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'If the user (in this case, me) accepts this authentication and clicks on **Okay**,
    the page will redirect back to our URL and pass an OAuth code along with it, which
    will be something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.mastergoco.com/codepass?code=h9U1_YNL1paTy-IsvQIor6u2jONwtipxqSbFMCo3wzYsSK7BxEVLsJ7ujtoDc](http://www.mastergoco.com/codepass?code=h9U1_YNL1paTy-IsvQIor6u2jONwtipxqSbFMCo3wzYsSK7BxEVLsJ7ujtoDc)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We can use this code as a semipermanent user acceptance code for future requests.
    This will not work if a user rescinds access to our application or if we choose
    to change the permissions that our application wishes to use in a third-party
    service.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You can start to see the possibilities of a very connected application and why
    third-party authentication systems that has the ability to sign up and sign in
    via Twitter, Facebook, Google+, and so on, have become viable and appealing prospects
    in recent years.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do anything useful with this as a tie-on to our API (assuming that
    the terms of services of each social network allow it), we need to do three things:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make this less restrictive than just one service. To do this,
    we''ll create a map of the `OauthService` struct:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then add this as per our need:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next thing that we''ll need to do is make this an actual redirect instead
    of something that spits the code into our console. With this in mind, it''s time
    to integrate this code into the `api.go` file. This will allow our registered
    users to connect their user information on our social network to others, so that
    they can broadcast their activity on our app more globally. This brings us to
    our following last step, which is to accept the code that each respective web
    service returns:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll add two endpoint routes to our `Init()` function; one allows a service
    to authorize (that is, send off to that site''s OAuth authentication) and the
    other allows us to keep the resulting information as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we''ll set up a Google+ authentication conduit. It goes without saying,
    but don''t forget to replace your `clientID`, `clientSecret`, and `redirectURL`
    variables with your values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By visiting `http://localhost/authorize/google`, we''ll get kicked to the interstitial
    authentication page of Google+. Here''s an example that is fundamentally similar
    to the Facebook authentication that we saw earlier:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting our users to other services](img/1304OS_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: When a user clicks on **Accept**, we'll be returned to our redirect URL with
    the code that we're looking for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most OAuth providers, a client ID and a client secret will be provided from
    a dashboard.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'However, on Google+, you''ll retrieve your client ID from their Developers
    console, which allows you to sign up new apps and request access to different
    services. They don''t openly present a client secret though, so you''ll need to
    download a JSON file that contains not only the secret, but also other relevant
    data that you might need to access the service in a format similar to this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`{"web":{"auth_uri":"https://accounts.google.com/o/oauth2/auth","client_secret":"***","token_uri":"https://accounts.google.com/o/oauth2/token","client_email":"***@developer.gserviceaccount.com","client_x509_cert_url":"https://www.googleapis.com/robot/v1/metadata/x509/***@developer.gserviceaccount.com","client_id":"***.apps.googleusercontent.com","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs"}}`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You can grab the pertinent details directly from this file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to ensure that we know who made the request and how to store it,
    we'll need some sense of state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Saving the state with a web service
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are quite a few ways to save state within a single web request. However,
    things tend to get more complicated in a situation like this wherein our client
    makes one request, he or she is then redirected to another URL, and then comes
    back to our.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We can pass some information about the user in our redirect URL, for example,
    [http://mastergoco.com/connect/google?uid=1](http://mastergoco.com/connect/google?uid=1);
    but this is somewhat inelegant and opens a small security loophole wherein a man-in-the-middle
    attacker could find out about a user and an external OAuth code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The risk here is small but real enough; therefore, we should look elsewhere.
    Luckily, Gorilla also provides a nice library for secure sessions. We can use
    these whenever we've verified the identity of a user or client and store the information
    in a cookie store.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s create a `sessions` table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, include the `sessions` package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, move it into the `import` section of our `api.go` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Right now we''re not authenticating the service, so we''ll enforce that on
    our `ApplicationAuthorize` (`GET`) handler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, if a user attempts to connect to a service, we''ll check for an existing
    login and if it does not exist, redirect the user to our login page. Here''s the
    test code to check this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a pretty standard test that looks for a cookie. If it doesn't exist,
    create a `Session` struct and save a cookie, and return false. Otherwise, return
    true if the cookie has been saved in the database already after a successful login.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'This also relies on a new global variable, `Session`, which is of the new struct
    type `UserSession`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the moment, there is an issue with our login page and this exists only to
    allow a third-party application to allow our users to authorize its use. We can
    fix this by simply changing our authentication page to set an `auth_type` variable
    based on whether we see `consumer_key` or `redirect_url` in the URL. In our `authorize.html`
    file, make the following change:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And in our `ApplicationAuthenticate()` handler, make the following change:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This also requires a modification of our `Page{}` struct:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we receive an authorization request from a `Page` type of user, we'll know
    that this is just a login attempt. If, instead, it comes from a client, we'll
    know it's another application attempting to make a request for our user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In the former scenario, we'll utilize a redirect URL to pass the user back around
    after a successful authentication, assuming that the login is successful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Gorilla offers a flash message; this is essentially a single-use session variable
    that will be removed as soon as it's read. You can probably see how this is valuable
    here. We'll set the flash message before redirecting it to our connecting service
    and then read that value on return, at which point it will be disposed of. Within
    our `ApplicationAuthorize()` handler function, we delineate between client and
    user logins. If the user logs in, we'll set a flash variable that can be retrieved.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But this alone will not keep a persistent session, so we'll integrate this now.
    When a successful login happens in the `ApplicationAuthorize()` method, we'll
    save the session in our database and allow some persistent connection for our
    users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Using data from other OAuth services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having successfully connected to another service (or services, depending on
    which OAuth providers you've brought in), we can now cross-pollinate multiple
    services against ours.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: For example, posting a status update within our social network may also warrant
    posting a status update on, say, Facebook.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s first set up a table for statuses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our statuses will consist of the user's information, a timestamp, and the text
    of the status message. Nothing too fancy for now!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to add API endpoints for creating, reading, updating, and
    deleting the statuses. So, in our `api.go` file, let''s add these:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For now, we''ll create some dummy handlers for the `PUT`/`Update` and `DELETE`
    methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Remember, without these we''ll be unable to test without receiving compiler
    errors in the meantime. In the following code, you''ll find the `StatusCreate`
    method that allows us to make requests for users who have granted us a token.
    Since we already have one of the users, let''s create a status:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll use a test of the key and the token to get a valid user who is allowed
    to make these types of requests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If a user is confirmed as valid through the key and token, the status will be
    created.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Using data from other OAuth services](img/1304OS_06_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: With a knowledge of how OAuth works in general and by having an approximate,
    lower-barrier version baked into our API presently, we can start allowing external
    services to request access to our users' accounts to execute within our services
    on behalf of individual users.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We touched on this briefly in the last chapter, but let's do something usable
    with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We're going to allow another application from another domain make a request
    to our API that will create a status update for our user. If you use a separate
    HTML interface, either like the one that we used in earlier chapters or something
    else, you can avoid the cross-domain policy issues that you'll encounter when
    you return a cross-origin resource sharing header.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can return the `Access-Control-Allow-Origin` header with the
    domains that we wish to allow to access to our API. If, for example, we want to
    allow `http://www.example.com` to access our API directly through the client side,
    we can create a slice of allowed domains at the top of our `api.go` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can add these on the `Init()` function of our `api.go` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then, we can call them from our present version of the API, currently at
    `v1`. So, in `v1.go`, we need to invoke the list of domains when calling `api.Init()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And finally, within any handler where you wish to observe these domain rules,
    add a loop through those domains with the pertinent header set:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To start with, let''s create a new user, Bill Johnson, through either of the
    aforementioned methods. In this case, we''ll go back to Postman and just do a
    direct request to the API:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Using data from other OAuth services](img/1304OS_06_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: After the creation of the new user, we can follow our pseudo-OAuth process to
    allow Bill Johnson to give our application access and generate a status.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: First, we pass the user to `/authorize` with our `consumer_key` value. On successful
    login and after agreeing to allow the application to access the user's data, we'll
    create a `token_key` value and pass it to the redirect URL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: With this key, we can make a status request programmatically as before by posting
    to the `/api/statuses` endpoint with our key, the user, and the status.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Connecting securely as a client in Go
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may encounter situations when instead of using an OAuth client; you're forced
    to make requests securely on your own. Normally, the `http` package in Go will
    ensure that the certificates included are valid and it will prevent you from testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This allows us to inject a custom `Transport` client and thus override error
    handling; in the interactions with our (or any) API via the browser, this is not
    suggested beyond testing and it can introduce security issues with untrusted sources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then get a valid response (with header, in struct):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is something that is best employed solely in testing, as the security of
    the connection can clearly be a dubious matter when a certificate is ignored.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took our initial steps for third-party integration of our application in
    the last chapter. In this chapter, we looked a bit at the client side to see how
    we can incorporate a clean and simple flow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We authenticated our users with other OAuth 2.0 services, which allowed us to
    share information from our social network with others. This is the basis of what
    makes social networks so developer friendly. Permitting other services to play
    with the data of our users and other users also creates a more immersive experience
    for users in general.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其他OAuth 2.0服务对用户进行身份验证，这使我们能够与其他社交网络共享信息。这是使社交网络对开发人员友好的基础。允许其他服务使用我们用户和其他用户的数据也为用户创造了更沉浸式的体验。
- en: In the next chapter, we'll look at integrating Go with web servers and caching
    systems to construct a platform for a performant and scalable architecture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将Go与Web服务器和缓存系统集成，构建一个高性能和可扩展架构的平台。
- en: We'll also push the functionality of our API in the process, which will allow
    more connections and functionality.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还将推动API的功能，这将允许更多的连接和功能。
