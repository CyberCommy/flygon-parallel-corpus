- en: Chapter 1. Legacy Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its simplest definition, a legacy application is any application that you,
    as a developer, inherit from someone else. It was written before you arrived,
    and you had little or no decision-making authority in how it was built.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a lot more weight to the word legacy among developers. It
    carries with it connotations of poorly organized, difficult to maintain and improve,
    hard to understand, untested or untestable, and a series of similar negatives.
    The application works as a product in that it provides revenue, but as a program,
    it is brittle and sensitive to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a book specifically about PHP-based legacy applications, I
    am going to offer some PHP-specific characteristics that I have seen in the field.
    For our purposes, a legacy application in PHP is one that matches two or more
    of the following descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses page scripts placed directly in the document root of the web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has special index files in some directories to prevent access to those directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has special logic at the top of some files to `die()` or `exit()` if a certain
    value is not set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its architecture is include-oriented instead of class-oriented or object-oriented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has relatively few classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class structure that exists is disorganized, disjointed, and otherwise inconsistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It relies more heavily on functions than on class methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its page scripts, classes, and functions combine the concerns of model, view,
    and controller into the same scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It shows evidence of one or more incomplete attempts at a rewrite, sometimes
    as a failed framework integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no automated test suite for the developers to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These characteristics are probably familiar to anyone who has had to deal with
    a very old PHP application. They describe what I call a typical PHP application.
  prefs: []
  type: TYPE_NORMAL
- en: The typical PHP application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most PHP developers are not formally trained as programmers, or are almost entirely
    self-taught. They often come to the language from other, usually non-technical,
    professions. Somehow or another, they are tasked with the duty of creating webpages
    because they are seen as the most technically-savvy person in their organization.
    Since PHP is such a forgiving language and grants a lot of power without a lot
    of discipline, it is very easy to produce working web pages and even applications
    without a lot of training.
  prefs: []
  type: TYPE_NORMAL
- en: These and other factors strongly influence the underlying foundation of the
    typical PHP application. They are usually not written in a popular full-stack
    framework or even a micro-framework. Instead, they are often a series of page
    scripts, placed directly in the web server document root, to which clients can
    browse directly. Any functionality that needs to be reused has been collected
    into a series of `include` files. There are `include` files for common configurations
    and settings, headers and footers, common forms and content, function definitions,
    navigation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This reliance on `include` files in the typical PHP application is what makes
    me call them include-oriented architectures. The legacy application uses `include`
    calls everywhere to couple the pieces of the program into a single whole. This
    is in contrast to a class-oriented architecture, where even if the application
    does not adhere to good object-oriented programming principles, at least the behaviors
    are bundled into classes.
  prefs: []
  type: TYPE_NORMAL
- en: File Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The typical include-oriented PHP application generally looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The structure shown is a simplified example. There are many possible variations.
    In some legacy applications, I have seen literally hundreds of main-level page
    scripts and dozens of subdirectories with their own unique hierarchies for additional
    pages. The key is that the legacy application is usually in the document root,
    has page scripts that users browse to directly, and uses `include` files to manage
    most program behavior instead of classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Page Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Legacy applications will use individual page scripts as the access point for
    public behavior. Each page script is responsible for setting up the global environment,
    performing the requested logic, and then delivering output to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendix A](apa.xhtml "Appendix A. Typical Legacy Page Script"), *Typical
    Legacy Page Script* contains a sanitized, anonymized version of a typical legacy
    page script from a real application. I have taken the liberty of making the indentation
    consistent (originally, the indents were somewhat random) and wrapping it at 60
    characters so it fits better on e-reader screens. Go take a look at it now, but
    be careful. I won''t be held liable if you go blind or experience post-traumatic
    stress as a result! As we examine it, we find all manner of issues that make maintenance
    and improvement difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: The `include` statements to execute setup and presentation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inline function definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: model, view, and controller logic all combined in a single script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: trusting user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: possible SQL injection vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: possible cross-site scripting vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unquoted array keys generating notices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` blocks not wrapped in braces (adding a line in the block later will
    not actually be part of the block)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: copy-and-paste repetition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Appendix A](apa.xhtml "Appendix A. Typical Legacy Page Script"), *Typical
    Legacy Page Script* example is relatively tame as far as legacy page scripts go.
    I have seen other scripts where JavaScript and CSS code have been mixed in, along
    with remote-file inclusions and all sorts of security flaws. It is also only (`!`)
    about 400 lines long. I have seen page scripts that are thousands of lines long
    which generate several different page variations, all wrapped into a single `switch`
    statement with a dozen or more `case` conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite or Refactor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many developers, when presented with a typical PHP application, are able to
    live with it for only so long before they want to scrap it and rewrite it from
    scratch. Nuke it from orbit; it's the only way to be sure! is the rallying cry
    of these enthusiastic and energetic programmers. Other developers, their enthusiasm
    drained by their death march experience, feel cautious and wary at such a suggestion.
    They are fully aware that the codebase is bad, but the devil (or in our case,
    code) they know is better than the devil they don't.
  prefs: []
  type: TYPE_NORMAL
- en: The Pros and Cons of Rewriting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complete rewrite is a very tempting idea. Developers championing a rewrite
    feel like they will be able to do all the right things the first time through.
    They will be able to write unit tests, enforce best practices, separate concerns
    according to modern pattern definitions, and use the latest framework or even
    write their own framework (since they know best what their own needs are). Because
    the existing application can serve as a reference implementation, they feel confident
    that there will be little or no trial-and-error work in rewriting the application.
    The needed behaviors already exist; all the developers need to do is copy them
    to the new system. The behaviors that are difficult or impossible to implement
    in the existing system can be added on from the start as part of the rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: 'As tempting as a rewrite sounds, it is fraught with many dangers. Joel Spolsky
    had this to say regarding the old Netscape Navigator web browser rewrite in 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Netscape made the single worst strategic mistake that any software company
    can make by deciding to rewrite their code from scratch. Lou Montulli, one of
    the 5 programming superstars who did the original version of Navigator, emailed
    me to say, I agree completely, it''s one of the major reasons I resigned from
    Netscape. This one decision cost Netscape 3 years. That''s three years in which
    the company couldn''t add new features, couldn''t respond to the competitive threads
    from Internet Explorer, and had to sit on their hands while Microsoft completely
    ate their lunch.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Joel Spolsky, Netscape Goes Bonkers* |'
  prefs: []
  type: TYPE_TB
- en: Netscape went out of business as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Josh Kerr relates a similar story regarding TextMate:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Macromates, an indie company who had a very successful text editor called
    Textmate, decided to rewrite the code base for Textmate 2\. It took them 6 years
    to get a beta release out the door which is an eternity in today''s time and they
    lost a lot of market share. When they did release a beta, it was too late and
    6 months later they folded the project and pushed it on to Github as an open source
    project.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Josh Kerr, TextMate 2 And Why You Shouldn''t Rewrite Your Code* |'
  prefs: []
  type: TYPE_TB
- en: 'Fred Brooks calls the urge to do a complete rewrite the second-system effect.
    He wrote about this in 1975:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *The second is the most dangerous system a man ever designs. ... The
    general tendency is to over-design the second system, using all the ideas and
    frills that were cautiously sidetracked on the first one. ... The second-system
    effect has ... a tendency to refine techniques whose very existence has been made
    obsolete by changes in basic system assumptions. ... How does the project manager
    avoid the second-system effect? By insisting on a senior architect who has at
    least two systems under his belt.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Fred Brooks, The Mythical Man-Month*, pp. 53-58. |'
  prefs: []
  type: TYPE_TB
- en: Developers were the same forty years ago as they are today. I expect them to
    be the same over the next forty years as well; human beings remain human beings.
    Overconfidence, insufficient pessimism, ignorance of history, and the desire to
    be one's own customer all lead developers easily into rationalizations that this
    time will be different when they attempt a rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Why Don't Rewrites Work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are lots of reasons why a rewrite rarely works, but I will concentrate
    on only one general reason here: the intersection of resources, knowledge, communication,
    and productivity. (Be sure to read *The Mythical Man-Month* (pp. 13-26) for a
    great description of the problems associated with thinking of resources and scheduling
    as interchangeable elements.)'
  prefs: []
  type: TYPE_NORMAL
- en: As with all things, we have only limited resources to bring to bear against
    the rewrite project. There are only a certain number of developers in the organization.
    These are the developers who will have to do *both* maintenance on the existing
    program *and* write the completely new version of the program. Any developers
    working on the one project will not be able to work on the other.
  prefs: []
  type: TYPE_NORMAL
- en: The Context-switching problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One idea is to have the existing developers spend part of their time on the
    old application and part of their time on the new one. However, moving a developer
    between the two projects will not be an even split of productivity. Because of
    the cognitive load of context-switching, the developer will be less than half
    as productive on each.
  prefs: []
  type: TYPE_NORMAL
- en: The Knowledge problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid the productivity losses from switching developers between maintenance
    and the rewrite, the organization may try to hire more developers. Some can then
    be dedicated to the old project and others to the new project. Unfortunately,
    this approach reveals what F. A. Hayek calls the knowledge problem. Originally
    applied to the realm of economics, the knowledge problem applies equally as well
    to programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put the new developers on the rewrite project, they won''t know enough
    about the existing system, the existing problems, the business goals, and perhaps
    not even the best practices for doing the rewrite to be effective. They will have
    to be trained on these things, most likely by the existing developers. This means
    the existing developers, who have been relegated to maintaining the existing program,
    will have to spend a lot of time communicating knowledge to the new hires. The
    amount of time involved is non-trivial, and the communication of this knowledge
    will have to continue until the new developers are as well-versed as the existing
    developers. This means that the linear increase in resources results in a less-than-linear
    increase in productivity: a 100% increase in the number of programmers will result
    in a less than 50% increase in output, sometimes much less (cf. *The Miserable
    Mathematics of the Man-Month* – [http://paul-m-jones.com/archives/1591](http://paul-m-jones.com/archives/1591)).'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could put the existing developers on the rewrite project,
    and the new hires on maintenance of the existing program. This too reveals a knowledge
    problem because the new developers are completely unfamiliar with the system.
    Where will they get the knowledge they need to do their work? From the existing
    developers, of course, who will still need to spend valuable time communicating
    their knowledge to the new hires. Once again, we see that the linear increase
    in developers leads to a less-than-linear increase in productivity.
  prefs: []
  type: TYPE_NORMAL
- en: The Schedule Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To deal with the knowledge problem and the related communication costs, some
    may feel the best way to handle the project would be to dedicate all the existing
    developers on the rewrite, and delay maintenance and upgrades on the existing
    system until the rewrite is done. This is a great temptation because the developers
    will be all too eager to salve their own pains and become their own customers
    - becoming excited about what features they want to have and what fixes they want
    to make. These desires will lead them to overestimate their own ability to perform
    a full rewrite and underestimate the amount of time needed to complete it. The
    managers, for their part, will accept the optimism of the developers, perhaps
    adding some buffer in the schedule for good measure.
  prefs: []
  type: TYPE_NORMAL
- en: The overconfidence and optimism of the developers will morph into frustration
    and pain when they realize the task is actually much greater and more overwhelming
    than they first thought. The rewrite will go on much longer than anticipated,
    not by a little, but by an order of magnitude or more. For the duration of the
    rewrite, the existing program will languish - buggy and missing features - disappointing
    existing customers and failing to attract new ones. The rewrite project will,
    at the end, become a panicked death march to get it done at all costs, and the
    result will be a codebase that is just as bad as the first one, only in different
    ways. It will be merely a copy of the first system, because schedule pressures
    will have dictated that new features be delayed until after an initial release
    is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative Refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the risks associated with a complete rewrite, I recommend refactoring
    instead. Refactoring means that the *quality* of the program is improved in small
    steps, without changing the *functionality* of the program. A single, relatively
    small change is introduced across the entire system. The system is then tested
    to make sure it still works properly, and finally, the system is put into production.
    A second small change builds on the previous one, and so on. Over a period of
    time, the system becomes markedly easier to maintain and improve.
  prefs: []
  type: TYPE_NORMAL
- en: A refactoring approach is decidedly less appealing than a complete rewrite.
    It defies the core sensibilities of most developers. The developers have to continue
    working with the system as it is, warts and all, for long periods of time. They
    do not get to switch over to the latest, hottest framework. They do not get to
    become their own customers and indulge their desires to do things right the first
    time. Being a longer-term strategy, the refactoring approach does not appeal to
    a culture that values rapid development of new applications over patching existing
    ones. Developers usually prefer to start their own new projects, not maintain
    older projects developed by others.
  prefs: []
  type: TYPE_NORMAL
- en: However, as a risk-reducing strategy, using an iterative refactoring approach
    is undeniably superior to a rewrite. The individual refactorings themselves are
    small compared to any similar portion of a rewrite project. They can be applied
    in much shorter periods of time than a comparable feature would be in a rewrite,
    and they leave the existing codebase in a working state at the end of each iteration.
    At no point does the existing application stop operating or progressing. The iterative
    refactorings can be integrated into a larger process with scheduling that allows
    for cycles of bug fixes, feature additions, and refactorings to improve the next
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the goal of any single refactoring step is not perfection. The goal
    in each step is merely improvement. We are not trying to realize an impossible
    goal over a long period of time. We are taking small steps toward easily-visualized
    goals that can be accomplished in short timeframes. Each small refactoring win
    will both improve morale and drive enthusiasm for the next refactoring step. Over
    time, these many small wins accumulate into a single big win: a fully-modernized
    codebase that has never stopped generating revenue for the business.'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been discussing legacy applications as page-based, include-oriented
    systems. However, there is also a large base of legacy code out there using public
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Framework-based Legacy Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each different public framework in PHP land is its own unique hell. Applications
    written in *CakePHP* ([http://cakephp.org/](http://cakephp.org/)) suffer from
    different legacy issues than those written in CodeIgniter, Solar, Symfony 1, Zend
    Framework 1, and so on. Each of these different frameworks, and their varying
    work-alikes, encourage different kinds of tight-coupling in applications. Thus,
    the specific steps needed to refactor applications built using one of these frameworks
    are very different from the steps needed for a different framework.
  prefs: []
  type: TYPE_NORMAL
- en: As such, various parts of this book may be useful as a guide to refactoring
    different parts of a legacy application based on a public framework, but as a
    whole, the book is not targeted at refactoring applications based on these public
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In-house, private, or otherwise non-public frameworks under the direct control
    of their own architects within the organization likely to benefit from the refactorings
    included in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to a Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I sometimes hear about how developers wisely wish to avoid a complete rewrite
    and instead want to refactor or migrate to a public framework. This sounds like
    the best of both worlds, combining an iterative approach with the developers'
    desire to use the hottest new technology.
  prefs: []
  type: TYPE_NORMAL
- en: My experience with legacy PHP applications has been that they are almost as
    resistant to framework integration as they are to unit testing. If the application
    was already in a state where its logic could be ported to a framework, there would
    be little need to port it in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: However, by the time we have completed the refactorings in this book, the application
    is very likely to be in a state that will be much more amenable to a public framework
    migration. Whether the developers will still want to do so is another matter.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have realized that a rewrite, while appealing, is a dangerous
    approach. An iterative refactoring approach sounds a lot more like actual work,
    but has the benefit of being achievable and realistic.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to prepare ourselves for the refactoring approach by getting
    some prerequisites out of the way. After that, we will proceed toward modernizing
    our legacy application in a series of relatively small steps, one step per chapter
    with each step broken down into an easy-to-follow process with answers to common
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
