- en: Handling Authentication for Our REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore authentication patterns in Go. Those
    patterns are `session-based authentication`, `JSON Web Tokens (JWT)`, and `Open
    Authentication 2 (OAuth2)`. We will try to leverage the Gorilla package's sessions
    library to create basic sessions. Then, we will try to move onto advanced REST
    API authentication strategies such as using stateless JWT. Finally, we will see
    how to implement our own OAuth2 and also learn what packages are available to
    provide us out-of-box OAuth2 implementations. In the previous chapter, the API
    gateway implemented authentication (using plugins) for us. If the API gateway
    is not present in our architecture, how do we secure our API? You will find the
    answer in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How authentication works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Postman, a visual client for testing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session-based authentication in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Redis to store user sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to JSON Web Tokens (JWT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2 architecture and basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter12](https://github.com/narenaryan/gorestful/tree/master/chapter12).
    Since the example programs are not packages, the reader needs to create the project
    files by following the GOPATH way of writing projects.
  prefs: []
  type: TYPE_NORMAL
- en: How authentication works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, authentication or simple authentication works in a session-centric
    way. A client that is requesting resources from the server tries to prove that
    it is the right consumer for any given resource. The flow starts like this. A
    client sends an authentication request to the server using user credentials. The
    server takes those credentials and matches them with the credentials stored on
    the server. If a match is successful, it writes something called a cookie in the
    response. This cookie is a small piece of information that is transferred to and
    from subsequent requests. The modern **user interfaces** (**UI**) of websites
    are **single-page applications** (**SPAs**). There, the static web assets like
    HTML, JS are served from a CDN to render the web page initially. From next time,
    the communication between the web page and application server happens only through
    REST API/Web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A session is a nice way to record the user communication in a given period
    of time. The session is a concept that is usually stored in a cookie. The following
    diagram can sum up the entire process of authentication (simply auth):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a377d17c-27dc-4a16-b66c-fa5adbdbc5ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Now see the practical approach. A client (for example, a browser) sends a request
    to the **Login API** of the server. The server tries to check those credentials
    with the database and if credentials exist, writes a cookie back onto the response
    saying this user is authenticated. A cookie is a message to be consumed by the
    server at the later point of time. When the client receives the response, it stores
    that cookie locally. If the web browser is the client, it stores it in the cookie
    storage. From next time, the client can freely ask for resources from the server
    by showing the cookie as the key for passage. When a client decides to terminate
    the session, it calls the Logout API on the server. The server destroys the session
    in the response. This process continues. The server can also keep an expiration
    on cookies so that the authentication window is valid for a certain time if there
    is no activity. This is how all websites work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will try to implement one such system using the Gorilla kit''s `sessions`
    package. We already saw how the Gorilla kit provides an HTTP router in the initial
    chapters. This sessions package is one of them. We need to install the package
    first by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new session using this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That `secret_key` should be the key that Gorilla sessions use to encrypt the
    session cookies. If we add a session as a normal text, anyone can read it. So,
    the server needs to encrypt a message to a random string. For that, it asks to
    provide a secret key. This secret key can be any randomly generated string. Keeping
    secret keys in code is not a good idea, so we try to store it as an environment
    variable and read it in code on the fly. We will see how we can implement one
    such system.
  prefs: []
  type: TYPE_NORMAL
- en: Session-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a project called `simpleAuth` in GOPATH and add a `main.go` file,which
    holds the logic for our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we are going to see how we can create a session-based authentication
    using the Gorilla sessions package. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is a REST API that allows one to access the health condition (up or not)
    of the system. In order to authenticate, one needs to call the login endpoint
    first. The program imported two main packages called mux and sessions from the
    Gorilla kit. Mux is used to link the URL endpoints of HTTP requests to a function
    handler, and sessions is used to create new sessions and validate existing ones
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, we need to store sessions in the program memory. We can do that by creating
    `CookieStore.` This line explicitly tells the program to create one by picking
    the secret key from the environment variable called `SESSION_SECRET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`sessions` has a new function called `NewCookieStore`that returns a store.
    We need to use this store to manage cookies. We can get a cookie session with
    this statement. If the session doesn''t exist, it returns an empty one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`session.id` is a custom name that we gave to the session. With this name,
    a cookie will be sent back in the client response. `LoginHandler`tries to parse
    the form that was supplied by the client as multipart form data. This step is
    essential in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This fills the `r.PostForm`map with the parsed key-value pairs. That API requires
    both username and password for its authentication. So, we are interested in scraping `username`
    and `password`. Once `LoginHandler` receives the data, it tries to check it with
    the details in a map called **users**.In a practical scenario, we use the database
    to validate those details. For simplicity''s sake, we hardcoded values and tried
    to authenticate from it. If the username doesn''t exist, return an error saying
    resource not found. If the username exists and the password is incorrect, return
    an `UnAuthorized` error message. If everything goes well, return a 200 response
    by setting the cookie value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first statement sets the cookie key called `"authenticated"` to `true`.
    The second statement actually saves the session on the response. It takes request
    and response writers as the arguments. If we remove this statement, the cookie
    will not have any effect. Now, coming to the `HealthCheckHandler`, it does the
    same thing as `LoginHandler` initially, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, it checks whether a given request has a cookie that has the key called
    `"authenticated"`. If that key exists and is true, it means it is the user that
    the server authenticated previously. But, if that key does not exist or the `"authenticated"`
    value is `false`, then the session is not valid, hence it returns a `StatusForbidden`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There should be a way for the client to invalidate a login session. It can
    do that by calling the logout APIof the server. The API just sets the `"authenticated"`
    value to `false`. This tells the server that the client is not authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this way, a simple authentication can be implemented using the sessions in
    any programming language, including Go.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to add this statement, as it is the actual one that modifies and
    saves the cookie: `session.Save(r, w)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see the execution of this program. Instead of CURL, we can use a
    wonderful tool called Postman. The main benefit is that it runs on all platforms
    including Microsoft Window; no need for CURL anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The error codes can mean different things. For example, Forbidden (403) is issued
    when the user tries to access a resource without authentication, whereas Resource
    Not Found (404) is issued when the given resource does not exist on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Postman, a tool for testing REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postman is a wonderful tool that allows Windows, macOS X, and Linux users to
    make HTTP API requests. You can download it at [https://www.getpostman.com/](https://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Postman, enter a URL in the Enter request URLinput text. Select
    the type of request (`GET`, `POST`, and so on). For each request, we can have
    many settings such as headers, `POST` body, and other details. Please go through
    the Postman documentation for more details. The basic usage of Postman is straightforward.
    Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e02ffe3-9719-4ff1-9d82-832c209ba65d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The builder is the window where we can add/edit requests. The preceding screenshot
    shows the empty builder where we try to make requests. Run the `main.go` in the
    preceding `simpleAuth` project and try to call the health check API, like this.
    Click on the Send button and you will see the response is forbidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42a5cf72-dea0-41d6-b3a2-917401543995.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is because we didn''t log in yet. Postman automatically saves the cookie
    once authentication is successful. Now, call the login API by changing the method
    type from `GET` to POST and URL to `http://localhost:8000/login`. We should also
    pass the auth details as multipart form data. It looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb63a0a0-deb2-444c-a841-d642d390a511.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we hit send, it authenticates and receives the cookie. It returns a
    message saying Logged In successfully. We can also inspect the cookies by clicking
    on the Cookies link just below the Send and Save buttons on right-hand side. It
    shows the list of cookies saved and you will find a cookie called `session.id`
    there for localhost. The content will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to call the health check API again, and it returns us the system date and
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If a client makes a `GET` request to the logout API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The session will be invalidated and access to the resource will be forbidden
    until another login request is done.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting client sessions with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sessions we created until now are stored in the program memory. It means
    if the program crashes or restarts, all the logged sessions will be lost. It needs
    the client to re-authenticate once again to get a new session cookie. It can be
    an annoying thing sometimes. In order to save sessions in some place, we chose
    **Redis**. Redis is a key-value storage that is very fast because it lives in
    primary memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Redis server stores any key-value pairs we supply. It provides basic data
    types such as strings, lists, hashes, sets, and so on. For more details, visit [https://redis.io/topics/data-types](https://redis.io/topics/data-types). We
    can install Redis with the following command on Ubuntu 16.04:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS X, we can just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows too, binaries are available on the Redis website. Once Redis is
    installed, we can start the Redis server with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts the server on default port `6379`. Now, we can store anything in
    that using Redis CLI (command-line tool). Open a new terminal and type `redis-cli`.
    Once the shell is launched, we can perform Redis commands to store and retrieve
    data into the user-defined type variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can store a key value using the `SET` Redis command. It stores the value
    as a string. If we try to perform `GET`, it returns us the string. It is our responsibility
    to convert them to numbers. Redis provides us handy functions to operate on those
    keys. For example, we can increment a key like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Redis treats integers as integers internally. If you try to increment a non-number
    string, Redis throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Why are we discussing Redis here? Because we are showing how Redis works and
    introducing a few basic commands on the Redis server. We are going to modify our
    project from `simpleAuth` to `simpleAuthWithRedis`.
  prefs: []
  type: TYPE_NORMAL
- en: In that project, instead of storing sessions in program memory, we use Redis.
    Even though the program crashes, sessions are not lost since they are saved in
    the external server. Who writes the bridging logic for that? We should. Luckily,
    we have a package that takes care of that coordination between Redis and the Go
    sessions package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install that package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And create a new program with a few modifications. Here, instead of using the
    sessions library, we use the `redistore` package. `redistore` has a function called
    `NewRediStore` that takes Redis configuration as the arguments along with the
    secret key. All other functions remain same. Now, add a `main.go` file in the `simpleAuthWithRedis`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One interesting change is that we removed the session instead of setting its
    value to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This improved program works exactly the same as the previous one, except the
    session is saved in Redis. Open the Redis CLI and type this command to get all
    available keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That lengthy `"session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA"`
    is the key stored by the `redistore`. If we delete that key, the client will automatically
    be forbidden from accessing resources. Now, stop the running program and restart
    it. You will see the session is not lost. In this way, we can save the client
    session. We can also persist sessions on the SQLite database. Many third-party
    packages are written to make that much easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** can serve the purpose of caching for your web applications. It can
    store temporary data such as sessions, frequently requested user content, and
    so on. It is usually compared to **memcached**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JSON Web Tokens (JWT) and OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous style of authentication is a plain username/password and session-based.
    It has a limitation of managing sessions by saving them in the program memory
    or Redis/SQLite3\. The modern REST API implements token-based authentication.
    Here, tokens can be any strings generated by the server, which allows the client
    to access resources by showing the token. Here, the token is computed in such
    a way that the client and the server only know how to encode/decode the token.
    **JWT** tries to solve this problem by enabling us to create tokens that we can
    pass around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a client passes the authentication details to the server, the server
    generates a token and passes it back to the client. The client saves that in some
    kind of storage, such as a database or local storage (in case of browser). The
    client uses that token to ask for resources from any API defined by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/976d6e2e-da56-43e7-9c9c-ad288472b2ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps can be summarized more briefly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client passes the username/password in a `POST` request to the login API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server authenticates the details and if successful, it generates a JWT and
    returns it back instead of creating a cookie. It is the client's responsibility
    to store this token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the client has the JWT. It needs to add this in subsequent REST API calls
    such as `GET`, `POST`, `PUT`, and `DELETE` in the request headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, the server checks the JWT and if it is successfully decoded, the
    server sends the data back by looking at the username supplied as part of the
    token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JWT ensures that the data is sent from the correct client. The technique for
    creating a token takes cares of that logic. JWT leverages the secret key-based
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: JSON web token format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we discussed in the preceding section was circling around a JWT token.
    We are going to see here what it really looks like and how it is produced. JWT is
    a string that is generated after performing few a steps. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JWT header by doing **Base64Url** encoding on the header JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a JWT payload by doing **Base64Url** encoding on the payload JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a signature by encrypting the appended header and payload using a secret
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JWT string can be obtained by appending the header, payload, and signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A header is a simple JSON object. It looks like the following code snippet
    in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`"alg"` is a short form for the algorithm (HMAC with SHA-256) used for creating
    a signature. The message type is `"JWT"`. This will be common for all the headers.
    The algorithm may change depending on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A payload looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Keys in payload object are called claims. A claim is a key that specifies some
    special meaning to the server. There are three types of claims:'
  prefs: []
  type: TYPE_NORMAL
- en: Public claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private claims (more important)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reserved claims are the ones defined by the JWT standard. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: iat: issued at the time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iss: issuer name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sub: subject text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'aud: audience name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'exp: expiration time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the server, while generating a token, can set an `exp` claim in
    the payload. The client then uses that token to access API resources. The server
    validates the token each time. When the expiration time is passed, the server
    will no longer validate the token. The client needs to generate a new token by
    logging in again.
  prefs: []
  type: TYPE_NORMAL
- en: Private claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private claims are the names used to identify one token from another. It can
    be used for authorization. Authorization is a process of identifying which client
    made the request. Multi-tenancy is having multiple clients in a system. The server
    can set a private claim called `username` on the payload of the token. Next time,
    the server can read this payload back and get the username, and then use that
    username to authorize and customize the API response.
  prefs: []
  type: TYPE_NORMAL
- en: '`"username": "Indiana Jones"` is the private claim on the preceding sample
    payload. **Public claims** are the ones similar to private claims, but they should
    be registered with the IANA JSON Web Token Registry to make it as a standard.
    We limit the use of these.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A signature can be created by performing this (this is not code, just an illustration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is simply performing an encryption algorithm on the Base64URL encoded header
    and payload with a secret. This secret can be any string. It is exactly similar
    to the secret we used in the previous cookie session. This secret is usually saved
    in the environment variable and loaded into the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we append the encoded header, encoded payload, and signature to get our
    token string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a JWT token is generated. Are we going to do all this stuff manually
    in Go? No. In Go, or any other programming language, a few packages are available
    to wrap this manual creation of a token and verification. Go has a wonderful,
    popular package called `jwt-go`.We are going to create a project in the next section
    that uses `jwt-go` to sign a JWT and also validate them. One can install the package
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the official GitHub page for the project: [https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go). The
    package provides a few functions that allow us to create tokens. There are many
    other packages with different additional features. You can see all available packages
    and features supported at [https://jwt.io/#libraries-io](https://jwt.io/#libraries-io).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JWT in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jwt-go` package has a function called `NewWithClaims` that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Signing method such as HMAC256, RSA, and so on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Claims map
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, it looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`jwt.SigningMethodHS256`is an encryption algorithm that is available within
    the package. The second argument is a map with claims such as private (here username)
    and reserved (issued at). Now we can generate a `tokenString` using the `SignedString`
    function on a token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This `tokenString` then should be passed back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a JWT in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jwt-go` also gives us the API to parse a given JWT string. The `Parse`function
    takes a string and key function as arguments. The `key` function is a custom function
    that validates whether the algorithm is proper or not. Let us say this is a sample
    token string generated by the preceding encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse and get back the original JSON using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`token.Claims` is implemented by a map called `MapClaims`. We can get the original
    JSON key-value pairs from that map.'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 architecture and basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth 2 is an authentication framework that is used to create authentication
    pattern between different systems. In this, the client, instead of making a request
    to the resource server, makes an initial request for some entity called resource
    owner. This resource owner gives back the authentication grant for the client
    (if credentials are successful). The client now sends this authentication grant
    to another entity called an authentication server. This authentication server
    takes the grant and returns an access token. This token is the key thing for a
    client to access API resources. It needs to make an API request to the resource
    server with this access token and the response is served. In this entire flow,
    the second part can be done using JWT. Before that, let us learn the difference
    between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication versus authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** is the process of identifying whether a client is genuine
    or not. When a server authenticates a client, it checks the username/password
    pair and creates session cookie/JWT.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization **is the process of differentiating one client from another
    after a successful authentication. In cloud services, the resources requested
    by a client need to be served by checking that the resources belong to that client
    but not the other client. The permissions and access to resources vary for different
    clients. For example, the admin has the highest privileges of resources. A normal
    user''s access is limited.'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 is a protocol for authenticating multiple clients to a service, whereas
    the JWT is a token format. We need to encode/decode JWT tokens to implement the
    second stage (dashed lines in the following screenshot) of OAuth 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e52ff092-f411-4ce0-b04b-536942867fa2.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, we can implement the dashed section using JWT. Authentication
    is happening at the authentication server level and authorization happens at the
    resource server level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, let us write a program that does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticates the client and returns a JWT string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorizes client API requests by validating JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a directory called `jwtauth`and add `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a very lengthy program to digest. First, we are importing `jwt-go` and
    its subpackage called `request`. We are creating a REST API for two endpoints;
    one for getting the access token by providing authentication details, and another
    one for fetching the health check API that authorizes the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the **`getTokenHandler` **handler function, we are comparing the username
    and password with our custom defined user map. This can be a database too. If
    authentication is successful, we are generating a JWT string and sending it back
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `HealthcheckHandler`, we are taking the access token from a header called
    `access_token`and validating it by parsing the JWT string. Who is writing the
    logic of validating? The JWT package itself. When a new JWT string is created
    it should have a claim called `ExpiresAt`. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The program's internal validation logic looks at the `IssuedAt` and `ExpiresAt`
    claims and tries to compute and see whether the given token is expired or not.
    If it is fresh, then it means the token is validated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when a token is valid, we can read the payload in the `HealthCheckHandler`
    where we parse the `access_token`string that passed as part of the HTTP request
    headers. `username`is a custom private claim we inserted for authorization. Therefore,
    we know who is actually sending this request. For each and every request there
    is no need for the session to be passed. Each API call is independent and token
    based. Information is encoded in a token itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`token.Claims.(jwt.MapClaims)` returns a map whose values are interfaces, not
    strings. In order to convert the value to a string, we should do `claims["username"].(string)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how this program runs by making requests through the Postman tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41e2bbd3-3948-4935-856a-88236498565f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This returns a JSON string that has a JWT token. Copy it to the clipboard. If
    you try to make a request to the health check API without passing that JWT token
    as one of the headers, you will receive this error message instead of JSON :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy that token back and make a `GET` request, adding an `access_token`
    header with a token string as the value. In Postman, the headers section is available
    where we can add headers and key-value pairs. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76d0689e-288d-49e2-a116-ca6449a14e69.png)'
  prefs: []
  type: TYPE_IMG
- en: It returns the time properly as part of the API response. We can also see which
    user's JWT token this is. This confirms the authorization part of our REST API.
    Instead of having the token validation logic in each and every API handler, we
    can have it as a middleware and make it applicable to all handlers. Refer to [Chapter
    3](d4152cbc-41fa-414e-bd50-146e9549f41d.xhtml), *Working with Middleware and RPC*,
    and modify the preceding program to have a middleware that validates the JWT token.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authentication doesn't usually provide a log out API or API for
    deleting the tokens that are provided in session based authentication. The server
    gives the authorized resources to the client as long as JWT is not expired. Once
    it expires, the client needs to refresh the token—that is to say, ask the server
    for a new token.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced the process of authentication. We saw how authentication
    usually works. Authentication can be of two types: session-based or token-based.
    Session-based authentication is also called simple authentication, where a session
    is created when the client successfully logs in. That session is saved back in
    the client and supplied for each and every request. There are two possible cases
    here. In the first case, the session will be saved in the server''s program memory.
    This kind of session will be cleared when the application restarts. The second
    case is to save the session cookie in Redis. Redis is an in-memory database that
    can act as a cache for any web application. Redis supports storing a few data
    types such as string, list, hash, and so on. We explored a package called `redistore`
    that replaces the built-in sessions package for persisting the session cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saw about JWT. A JWT is a token string that is the output of performing
    a few steps. First, create a header, payload, and signature. A signature can be
    obtained by combining both header and payload with `base64URL` encoding and applying
    an encryption algorithm such as HMAC. In token-based authentication, a client needs
    a JWT token for accessing server resources. So, initially, it requests the server
    to provide the access token (JWT token). Once the client gets this token, next
    time it makes API calls with the JWT token in the HTTP header and the server returns
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced OAuth 2.0, an authentication framework. In OAuth 2, the client
    first requests for a grant from the resource owner. Once it gets the grant, it
    then requests an access token from the authentication server. The authentication
    server gives the access token, which client can use to request an API. We implemented
    the second step of OAuth 2 with JWT.
  prefs: []
  type: TYPE_NORMAL
- en: We tested all our APIs with a tool called Postman. Postman is a great tool that
    helps us to test our APIs quickly on any machine. CURL is limited to Linux and
    macOS X. Postman is a wise choice for Windows because it has all the features
    of CURL.
  prefs: []
  type: TYPE_NORMAL
- en: We came a long way from the first chapter by learning how to create HTTP routes,
    middlewares, and handlers. We then linked our applications with databases to store
    the resource data. After the basics, we explored the performance-tuning aspects
    such as microservices and RPC.  Finally, we saw how to deploy our web services
    and also secure them using authentication.
  prefs: []
  type: TYPE_NORMAL
