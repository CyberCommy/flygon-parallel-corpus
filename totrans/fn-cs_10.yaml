- en: Chapter 10. Taking an Action in C# Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most important chapter of this book since we will create a new application
    using a functional approach. We have already discussed functional programming
    in depth in the previous chapters, including functional programming concepts,
    **Language Integrated Query** ( **LINQ** ), recursion, optimizing, and patterns.
    What we are going to do now is develop an application with an imperative approach
    and then refactor it into a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a Windows forms application and explore how
    to create a form and then add the code to it. After finishing this chapter, we
    will be able to refactor the Windows form application from an imperative approach
    into a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Windows forms application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring how to create a form and then add the code to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating engine code in an imperative approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform the engine code from an imperative to a functional approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing functional programming in Windows forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to develop a calculator application in a Windows forms application.
    For this purpose, we have to create a new Windows forms project and a new form
    with several buttons to contain the numbers 0 to 9 and additional functionality,
    such as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing functional programming in Windows forms](img/Image00113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have 10 buttons that represent the numbers 0 to 9 and standard
    mathematical operators such as add ( **+** ), subtract ( **-** ), multiply ( *****
    ), and divide ( **/** ). We also have some additional function buttons; they are
    square root ( **sqrt** ), percent ( **%** ) and inverse ( **1/x** ). The rest
    includes these buttons: switch sign ( **+/-** ), decimal ( **.** ), Clear Entry
    ( **CE** ), Clear All ( **C** ), and Backspace ( **del** ). We also have a textbox
    to display the number we entered and set at the top of the form. Last but not
    least, there is always an equal button in all calculator applications. We give
    names to all these controls, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have all these controls, the following code snippet contains only
    the control''s name and click events, if any, that we have to set in order to
    ease the creation of this app since the control''s name is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additional settings, such as the control's axis location, font, or alignment,
    don't matter since the settings won't affect the entire code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the code behind a form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All controls in the form are set and we are now ready to add some code to it.
    As you can see in all the event clicks in the previous code snippet, there are
    five functions that will be called for a specific button when pressed: `btnNumber_Click()`
    , `btnFunction_Click()` , `btnEquals_Click()` , `btnClear_Click()` , and `btnOperator_Click()`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The `btnNumber_Click()` function is for the 0 to 9 button. The `btnFunction_Click()`
    function is for the `btnSwitchSign` , `btnDecimal` , `btnSqrt` , `btnPercent`
    , `btnInverse` , and `btnDelete` button. The `btnEquals_Click()` function is for
    the `btnEquals` buttons. The `btnClear_Click()` function is for the `btnClearAll`
    and `btnClearEntry` buttons. And `btnOperator_Click()` is for the `btnAdd` , `btnSubstract`
    , `btnDivide` , and `btnMultiply` buttons. Also, there will be some helper functions
    that we will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the following code snippet, which contains the implementation
    of the `btnNumber_Click()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, the `btnNumber_Click()` function
    will detect the pressed number button and then display it in the textbox. For
    now, let's skip the `CalcEngine.AppendNum()` and `UpdateScreen()` functions since
    we are going to discuss them later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the `btnFunction_Click()` function, which will take an action
    if one of the functional buttons is pressed. The implementation of the function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, `btnFunction_Click()` will take
    action when the `btnSqrt` , `btnPercent` , `btnInverse` , `btnDelete` , `btnSwitchSign`
    , or `btnDecimal` buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the function that is responsible when one of the operator buttons is pressed,
    here is the code snippet of the `btnOperator_Click()` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `btnOperator()` function will be used to run the operation of
    each operator: add, subtract, multiply, and divide. It then calls the `PrepareOperation()`
    method in the `CalcEngine` class, which we will discuss later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear an entry or all entries, we have two buttons: `btnClearEntry` and
    `btnClearAll` . These two buttons will call the `btnClear_Click()` method every
    time the press event is generated. The implementation of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two methods in the `CalcEngine` class, as well, which are called
    when these two clearing buttons are pressed: `CalcEngine.Clear()` for the `btnClearEntry`
    button and `CalcEngine.ClearAll()` for the `btnClearAll` button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last button we have is the `btnEquals` button, which will call the `btnClear_Click()`
    method every time it is pressed; the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, when the `btnEquals` button is pressed, it
    tries to calculate the operation the user has given before calling the `CalcEngine.Solve()`
    method and then updating the textbox. If the calculation fails, it will clear
    the entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the `UpdateScreen()` method, which is used to display the
    current digit to the `txtScreen` textbox. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `UpdateScreen()` method, the `FormatDisplay(` ) method is called
    to form the display on `txtScreen` . The implementation of the `FormatDisplay()`
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding `FormatDisplay()` function implementation, the first
    thing that happens is that the function checks whether it is a negative number.
    If it does, the negative will be removed first and then the `addNegative` flag
    will be `true` , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It then looks for the dot (`.` ) character to indicate that it''s a decimal
    number. If the dot is found, it will store the fraction in the `dec` variable
    and the rest in the `str` variable, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the function will make sure that the number is less than 10^(19) . If
    it is, the following code snippet will format the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from the preceding format will be joined with the `dec` variable.
    If there''s no fraction in the `dec` variable, the dot character will be added
    to the last position, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If only the fraction number is available, the `0` character will be added at
    the first position, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we check whether the `addNegative` flag is `true` . If it is, the negative
    mark (`-` ) will be added at the first position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating the engine code in an imperative approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created the code behind the form. Now let's create the
    engine code in a wrapped class named `CalcEngine` . We will design it in a `CalcEngine.cs`
    file in the `CalculatorImperative.csproj` project.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing class properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this calculator engine class, we need some properties to hold a particular
    value to be involved in the calculation process. The following code snippet is
    the class properties'' declaration we are going to use in the calculation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have eight properties that will be involved in the calculation
    process. The `m_input` property will hold all the values we have inputted and
    the formatting number `m_sign` will store whether the number is `+` or `-` . The
    `m_operator` property will store the operator, which is `+` for addition, `-`
    for subtraction, `*` for multiplication, and `/` for division. The `m_lastNum`
    property will hold the result of the calculation. The `m_lastInput` property will
    save the last number the user has inputted. The `m_wait` property is a flag that
    indicates that the number has been inputted and it's time to wait for the operator
    and the next number. The `m_decimal` property flag indicates whether or not it's
    a decimal number. And the `m_lastHitEquals` property flag indicates whether `btnEquals`
    has been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In every class, it''s best to have a constructor to prepare the properties
    of the class. It''s the same with this class as well. The following is the code
    snippet of the class constructor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, if we want to reset all the
    class properties we have to call the constructor, which is `CalcEngine()` . For
    `m_input` , we use the dot (`.` ) character to indicate that there is no user
    inputted. We also use the `static` modifier since the class will be called directly
    by stating the class name instead of the instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, we discussed that we have two clearing methods: `ClearAll()` and `Clear()`
    , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is extracted from the `btnClear_Click()` method.
    Here is the implementation of the `ClearAll()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ClearAll()` method will reset all properties the `CalcEngine` class has.
    This is similar to the class constructor implementation. So, we can modify the
    class constructor implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the `Clear()` method to clear the last entry only. For this purpose,
    we just need to reset `m_sign` , `m_input` , and `m_decimal` . The implementation
    of the `Clear()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Appending the number to the display box
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we know, we have a textbox to display the number we have inputted or to
    display the result of calculation. In the `btnNumber_Click()` method implementation,
    we call the `CalcEngine.AppendNum()` method, and here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we have to distinguish the number
    with a negative sign or a decimal number with a dot mark. For this purpose, we
    use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s a pure number without a negative number or decimal mark, we check
    whether `m_input` is empty or whether the `m_wait` flag is `true` . If it is,
    we can continue the process. If the decimal flag is on, we don''t need to insert
    the dot mark anymore; otherwise, we have to add the dot mark. The following code
    snippet will explain more about our explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we call the `IsEmpty()` function to check whether `m_input`
    is empty or the `m_wait` flag is true. The implementation of the function is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If `IsEmpty()` returns `true` , it will continue the process, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, first, we check whether the `m_lastHitEquals` flag
    is on. If it is, we reset all class properties and then set `m_lastHitEquals`
     to off. Then, we check whether the `m_decimal` flag is on. If it is, insert the
    dot mark in front of the number. If not, insert the dot mark behind the number.
    After that, turn off the `m_wait` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to make sure there are no unnecessary zeroes that have been inserted
    using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will handle the user input if it doesn''t contain a negative
    mark (`-` ) or dot mark. If it does, we have to check whether it has these marks
    or not using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before we perform the preceding process, we have to reset all the
    class properties and reformat the number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we remove unnecessary zeroes and turn off the `m_wait` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the mathematical operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we press one of the operator buttons, the `btnOperator_Click()` function
    will be fired; inside the function, there is a `CalcEngine.PrepareOperation()`
    function to prepare the calculation. The implementation of the `CalcEngine.PrepareOperation()`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the preceding code is straightforward. We just need to know
    which button is pressed, +, -, ***,** or /. Then, we check whether it is the first
    number that the user inputs by checking whether `m_lastNum` is null or not or
    whether `m_wait` is on. If it is, we solve the calculation after we make sure
    that `m_lastNum` is not null, `m_lastHitEquals` is off, `m_wait` is off, and the
    current `m_operator` is different from the operator, which was just pressed by
    a user. After this, we replace `m_operator` with the current operator that the
    user inputs and fill `m_lastNum` with `m_input` that has been formatted. Also,
    other settings will have to be applied. The following code snippet will explain
    this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if it''s not the first number the user inputs, we can perform the
    following process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Formatting the input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we go to the `Solve()` function implementation we discussed in the previous
    `PrepareOperation()` function, let''s discuss the `FormatInput()` function first.
    The following is the implementation of the `FormatInput()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `FormatInput()` method is used to form the number that will be shown in
    the `txtScreen` textbox.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we press the `btnEquals` button or the operator button that has the previous
    input, the `Solve()` method will be invoked to calculate the operation. The following
    is the implementation of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the additional operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have discussed, we have other functional buttons: the `btnSqrt` , `btnPercent`
    , `btnInverse` , `btnDelete` , `btnSwitchSign` , and `btnDecimal` buttons. Here
    is the method that will be invoked if one of these buttons is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating the engine code in the functional approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created the calculator application in the imperative approach.
    Now, it's time to refactor all the imperative code into the functional code. We
    are going to refactor the engine first and then the code behind the form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding several new properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will have exactly the same properties as with the imperative code, except
    that we add three new properties, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, `m_solve` , `m_answer` , and `m_funcSuccess`
    are the new properties we have just added. We will use these three additional
    properties in the `Solve()` function later.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discussed in Chapter 9, *Working with Pattern* , we will use the `Simplicity`
    class, which we can find in the `SimplicityLib.cs` file. The implementation of
    the class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To able to assign properties, we need to assign the properties'' extension
    method. The following code will explain this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Every time we invoke one of the preceding methods, the method will return the
    `Calc` class in which the target property has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the class by clearing the properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will not construct the class in this functional approach; we will clear
    properties to make all the properties ready to run the process. There are two
    clearing methods that we will use: the `Clear()` and `ClearAll()` methods. The
    following code snippet is the implementation of these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in the imperative approach, the `Clear(` ) method is for the
    `btnClearEntry` button and `ClearAll()` is for the `btnClearAll` button.
  prefs: []
  type: TYPE_NORMAL
- en: Appending the inputted number to the text box
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this functional approach, we will refactor the `AppendNum()` method in the
    imperative approach into the functional approach, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To prepare the operation just after we press the operator button, here is the
    code that has been refactored from the `PreparingOperation()` method in the imperative
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Formatting the input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To format the input that we use to form the input in `txtScreen` , we will
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we use the `ModifyStringWhen()` extension
    method, which has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Solving the calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solving calculation can be done using the `Solve()` method in the imperative
    approach. The following code is the refactoring `Solve()` method from the imperative
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the implementation of the `CleanUp()` , `Answer()` , and `UpdateAnswerToCalc()`
    methods, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create the extension method for the `string` data type to accommodate
    the addition, subtraction, multiplication, and division operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the additional operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the additional button, which will invoke the `FunctionButton()` method
    every time the additional button is pressed, here is the refactoring code from
    the imperative `FunctionButton()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We successfully built a calculator application in Windows forms. We also refactored
    the imperative code into a functional approach. We created some extension methods
    to solve all refactoring processes so they can be functional.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss code with best practices in the functional
    approach and perform a unit test for the application we built in this chapter.
  prefs: []
  type: TYPE_NORMAL
