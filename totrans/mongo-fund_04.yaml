- en: 4\. Querying Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to prepare and execute queries in MongoDB. You will
    learn how to find documents from a collection and limit the fields shown in the
    output. You will use various conditional and logical operators, as well as combinations
    of them, in a query and use regular expressions to find documents in a collection.
    By the end of this chapter, you will be able to run queries on arrays and nested
    objects, as well as limit, skip, and sort the records in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we covered the basics of MongoDB, its document-based
    data model, data types, clients, and the MongoDB server. We created an Atlas cluster
    on the cloud, loaded sample datasets, and connected using different clients. Now
    that we have the data, we can start writing queries to retrieve documents from
    the collections. Queries are used to retrieve meaningful data from the database.
    We will begin by learning about query syntax, how to use operators, and the techniques
    we can use to format the result sets. Practicing and mastering the query language
    will help you find any required document quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: For any database management system, having a powerful query language is as important
    as its storage model, or its scalability. Consider that you are working on a database
    platform that offers an excellent storage model or an extremely high-performance
    database engine. However, it has very poor query language support, because of
    which you cannot easily retrieve the required pieces of information. Clearly,
    such a database is not going to be very useful. One of the primary purposes of
    storing information in a database is to be able to retrieve it as and when required.
    MongoDB provides a lightweight query language, which is totally different from
    the SQL queries that are used in relational databases. Let's start by taking a
    look at its query structure.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Query Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB queries are based on JSON documents in which you write your criteria
    in the form of valid documents. With the data stored in the form of JSON-like
    documents, the queries seem more natural and readable. The following diagram is
    an example of a simple MongoDB query that finds all the documents where the `name`
    field contains the value `David`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: MongoDB Query Syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: MongoDB Query Syntax'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a comparison with SQL, let''s rewrite the same query in SQL format.
    This query finds all the rows from the `USERS` table that contain the `name` column
    where the value of `name` is `David`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The most notable difference between the preceding queries is that the MongoDB
    queries do not have keywords such as `SELECT`, `FROM`, and `WHERE`. Thus, you
    need not remember a lot of keywords and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: The absence of keywords makes the queries less wordy and hence more focused,
    and less error-prone. When you are reading or writing MongoDB queries, you can
    easily focus on the most important parts of the query; that is, the conditions
    and the logic. Also, because of fewer keywords, the chances of introducing syntactical
    errors are smaller.
  prefs: []
  type: TYPE_NORMAL
- en: As the queries are represented in a document format, they can be easily mapped
    with the object structure of the respective programming language. When you write
    the query in your application, the MongoDB driver maps the objects provided by
    the application's programming language into the MongoDB query. Hence, to build
    a MongoDB query, all you need to do is prepare an object that represents the query conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, SQL queries are written in the form of plain strings. To build
    a SQL query, you will have to join the keywords, field and table names. and variables
    together into a string. Such string concatenations are prone to errors. Even a
    missing space between two joining keywords can introduce syntactical errors. Now
    that we have explored the basic advantages of MongoDB's query structure, let's
    start writing and executing basic queries against a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Basic MongoDB Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the queries in this section are top-level queries; that is, they are based
    on the top-level (also known as root-level) fields in the documents. We will learn
    about the basic query operators by writing queries against the root fields.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic query in MongoDB is performed with the `find()` function on
    the collection. When this function is executed without any argument, it returns
    all the documents in a collection. For example, consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This query calls the `find()` function on the collection named `comments`. When
    executed on a mongo shell, it will return all the documents from the collection.
    To return only specific documents, a condition can be provided to the `find()`
    function. When this is done, the `find()` function evaluates it against each and
    every document in the collection and returns the documents that match the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider that instead of retrieving all the comments, we only
    want to find comments that have been added by a specific user, `Lauren Carr`.
    In short, we want to find all the documents in which the `name` field has the
    value `Lauren Carr`. We will connect to the MongoDB Atlas cluster and use the
    `sample_mflix` database. The query should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Resulting comments after using the find() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: Resulting comments after using the find() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query returned three comments that were added by `Lauren Carr`. However,
    the output is unformatted, which makes it difficult to read and interpret. To
    overcome this, the `pretty()` function can be used to print a well-formatted result,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When this query is executed on a mongo shell, the output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Structured result after using find() with pretty()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: Structured result after using find() with pretty()'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output is the same as in the previous example, but the documents
    are well formatted and easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: Using findOne()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB provides another function, called `findOne()`, that returns only one
    matching record. This function is very useful when you are looking to isolate
    a specific record. The syntax of this function is similar to the syntax of the
    `find()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This query is executed without any condition and matches all the documents
    in the `comments` collection, returning only the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Finding a single document with the findOne() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Finding a single document with the findOne() function'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output of `findOne()` is always well formatted because it
    returns a document. Compare this with the `find()` function, which is designed
    to return multiple documents. The results of `find()` are enclosed in a collection,
    and a cursor to that collection is returned from the function. A cursor is an
    iterator for a collection that is used to iterate or traverse through the collection's
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the `find()` query on the mongo shell, the shell automatically
    iterates through the cursor and shows the first 20 records. When you are using
    `find()` from a programming language, you will always have to iterate through
    the result set on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a mongo shell, you can capture the cursor returned by the `find()` function
    in a variable. By using the variable, we can iterate through the elements. In
    the following snippet, we are executing a `find()` query and capturing the resulting
    cursor in a variable named `comments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `next()` function on the cursor, which moves the cursor to
    the next index position and returns the document from there. By default, the cursor
    is set at the beginning of the collection. When called for the first time, the
    `next()` function moves the cursor to the first document in the collection, and
    that document is returned. When called again, the cursor will be moved to the
    second position and the second document will be returned. The following is the
    syntax for calling the `next()` function on our comments cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the cursor reaches the last document in the collection, calling `next()`
    will result in an error. To avoid this, the `hasNext()` function can be used before
    calling `next()`. The `hasNext()` function returns `true` if the collection has
    a document at the next index position, and false if not. The following snippet
    shows the syntax for calling the `hasNext()` function on the cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result of using this function on a mongo
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Iterating through a cursor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: Iterating through a cursor'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, first, we captured the cursor in a variable. Then, we verified
    whether the cursor had a document at the next position, which resulted in `true`.
    Finally, we printed the first document using the `next()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Using find() and findOne() Without a Condition'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use `find()` and `findOne()` without any conditions
    on a mongo shell by connecting to the `sample_mflix` database on MongoDB Atlas.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use `find()` without a condition. So, here, do not pass any document
    or pass an empty document to the `find()` function. We will also execute the `find()`
    function to query for a non-existent field in our documents. All the queries shown
    here have the same behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing any of these queries, all the documents are matched and returned
    in a cursor. The following screenshot shows the first 20 documents from the mongo
    shell, printed along with a `Type "it" for more` message at the end. Typing `it`
    every time will return the next set of 20 documents until the collection contains
    more elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: First 20 documents in the mongo shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: First 20 documents in the mongo shell'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you wonder why `{"a_non_existent_field" : null}` matches all documents?'
  prefs: []
  type: TYPE_NORMAL
- en: This is because, in MongoDB, a non-existent field is always considered to have
    a null value. The `"a_non_existent_field"` field does not exist in any document
    in our collection. Hence, the null check of the field stands true for all the
    documents and they are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the `findOne()` function without any document, with an empty document,
    and with a document querying on a non-existing field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous step, all the preceding queries will have the same effect,
    except `findOne()` will output only the first document from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how we can project only some fields in
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Fields for the Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have observed many queries and their outputs. You might have noticed
    that every time a document is returned, it contained all the fields by default.
    However, in most real-life applications, you may only want a few fields in the
    resulting documents. In MongoDB queries, you can either include or exclude specific
    fields from the result. This technique is called `find()` or `findOne()` functions.
    In the projection expression, you can explicitly exclude a field by setting it
    to `0` or include one by setting it to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the user `Lauren Carr` may only want to know the dates on which
    she posted comments and may not be interested in the comment text. The following
    query finds all the comments posted by the user and returns only the `name` and
    `date` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing the query, the following result can be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Output showing only the name and date fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Output showing only the name and date fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have only specific fields in the result. However, the `_id` field
    is still visible, even though it was not specified. That is because the `_id`
    field is included by default in the resulting documents. If you do not want it
    to be present in the result, you must exclude it explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query specifies that the `_id` field should be excluded from
    the result. When executed on a mongo shell, we get the following output, which
    shows that the `_id` field is absent from all documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: _id field excluded from the output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: _id field excluded from the output'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note the three behaviors of field projections, listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `_id` field will always be included, unless excluded explicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one or more fields are explicitly included, the other fields (except `_id)`
    get excluded automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly excluding one or more fields will automatically include the rest
    of the fields, along with `_id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Projection helps to compact the result set and focus on specific fields. The
    documents from the `sample_mflix` collections that we will query are quite big.
    Therefore, for most of our sample outputs, we will use projection to include only
    the specific fields of documents, which are required to demonstrate the query's
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Distinct Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `distinct()` function is used to get the distinct or unique values of a
    field with or without query criteria. For the purpose of this example, we will
    use the `movies` collection. Each movie is assigned an audience suitability rating
    that is based on the content and viewers'' age. Let''s find the unique ratings
    that exist in our collection with the help of the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding query gives us all the unique ratings from the `movies` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: List of all movie ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: List of all movie ratings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `distinct()` function can also be used along with a query condition. The
    following example finds all the unique ratings the films that were released in
    1994 have received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument to the function is the name of the required field, while
    the second is the query expressed in the document format. Upon executing the query,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the result of `distinct` is always returned as
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we may not be interested in the actual documents but just the
    number of documents in a collection, or documents that match some query criteria.
    MongoDB collections have three functions that return the count of documents in
    the collection. Let's take a look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: count()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function is used to return the count of the documents within a collection
    or a count of the documents that match the given query. When executed without
    any query argument, it returns the total count of documents in the collection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Without a query, this function will not physically count the documents. Instead,
    it will read through the collection's metadata and return the count. The MongoDB
    specification does not guarantee that the metadata count will always be accurate.
    Cases such as the abrupt shutdown of a database or an incomplete chunk migration
    in sharded collections can lead to such inaccuracy. A sharded collection in MongoDB
    is partitioned and distributed across the different nodes of a database. We will
    not be going into details here as this is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function is provided with a query, the count of documents that match
    the given query is returned. For example, the following query will return the
    count of movies that have exactly six comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Upon executing this query, the actual count of documents is internally calculated
    by executing an aggregation pipeline with the same query. You will learn more
    about aggregation pipelines in *Chapter 7*, *Aggregations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MongoDB v4.0, these two behaviors are separated into different functions:
    `countDocuments()` and `estimatedDocumentCount()`.'
  prefs: []
  type: TYPE_NORMAL
- en: countDocuments()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the count of documents that are matched by the given
    condition. The following is an example query that returns the count of movies
    released in 1999:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `count()` function, a query argument is mandatory for `countDocuments()`.
    Hence, the following query is invalid, and it will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To count all the documents in the collections, we can pass an empty query to
    the function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note about `countDocuments()` is that it never uses collection
    metadata to find the count. It executes the given query on the collection and
    calculates the count of matched documents. This provides accurate results but
    may take longer than the metadata-based counts. Even when an empty query is provided,
    it is matched against all documents.
  prefs: []
  type: TYPE_NORMAL
- en: estimatedDocumentCount()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the approximate or estimated count of documents in a
    collection. It does not accept any query and always returns the count of all documents
    in the collection. The count is always based on the collection''s metadata. The
    syntax for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As the count is based on metadata, the results are less accurate, but the performance
    is better. The function should be used when performance is more important than accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to query MongoDB collections, as well as how to
    use projection to return only specific fields in the output, it is time to learn
    more advanced ways of querying. So far, you've tried to query the `comments` collection
    using the value of a field. However, there are more ways to query documents. MongoDB
    provides conditional operators that can be used to represent various conditions,
    such as equality, and whether a value is less than or greater than some specified
    value. In this section, we will explore these operators and learn how to use them
    in queries.
  prefs: []
  type: TYPE_NORMAL
- en: Equals ($eq)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, you saw examples of equality checking where the queries
    used a key-value pair. However, queries can also use a dedicated operator (`$eq`)
    to find documents with fields that match a given value. For example, the following
    queries find and return movies that have exactly `5` comments. Both queries have
    the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Not Equal To ($ne)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This operator stands for **Not Equal To** and has the reverse effect of using
    an equality check. It selects all the documents where the value of the field doesn''t
    match with the given value. For example, the following query can be used to return
    movies whose count for comments is not equal to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Greater Than ($gt) and Greater Than or Equal To ($gte)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$gt` keyword can be used to find documents where the value of the field
    is greater than the value in the query. Similarly, the `$gte` keyword is used
    to find documents where the value of the field is the same as or greater than
    the given value. Let''s find the number of movies released after `2015`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the movies that had been released in or after `2015`, the following
    line of code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With these operators, we can also count movies that were released in the 21st
    century. For this query, we also want to include the movies that have been released
    since January 1, 2000, so we will use `$gte`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Less Than ($lt) and Less Than or Equal To ($lte)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$lt` operator matches the documents with the value of the field that's
    less than the given value. Similarly, the `$lte` operator selects the documents
    where the value of the field is the same as or less than the given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find how many movies have less than two comments, enter the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to find the number of movies that have a maximum of two comments,
    enter the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, to count the movies that were released in the previous century, simply
    use `$lt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In ($in) and Not In ($nin)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if a user wants a list of all movies that have been rated G, PG, or PG-13?
    In this case, we can use the `$in` operator, along with multiple values given
    in the form of an array. Such queries find all the documents where the value of
    the field matches at least one of the given values. Prepare a query that returns
    movies rated as either of G, PG, or PG-13 by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$nin` operator stands for **Not In** and matches all the documents where
    the value of the field does not match with any of the array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query returns movies that are not rated as `G`, `PG`, or `PG-13`,
    including the ones that do not have the `rated` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what happens when you use `$nin` with a non-existent field, first, find
    the total documents you have, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use `$nin` with some values, except null, on a non-existent object. This
    means that all the documents are matched, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, add a `null` value to the `$nin` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This time, it did not match any document. This is because, in MongoDB, a non-existent
    field always has a value of null, hence why the `$nin` condition did not stand
    true for any of the documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Querying for Movies of an Actor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you''re working for a popular entertainment magazine and their
    upcoming issue is dedicated to Leonardo DiCaprio. The issue will contain a special
    article, and you quickly need some data, such as the number of movies he has acted
    in, the genre of each, and more. In this exercise, you will write queries to count
    documents by given conditions, find distinct documents, and project different
    fields in the documents. Query on the `sample_mflix` movies collection for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of movies the actor has acted in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the genre of these movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movie titles and their respective years of release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of movies he has directed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find the movies in which Leonardo DiCaprio appears by using the `cast` field.
    Enter the following query to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output states that Leonardo has acted in 25 movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The genres of the movies in the collection are represented by the `genres`
    field. Use the `distinct()` function to find the unique genres:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing the preceding code, you will receive the following output. As
    we can see, he has acted in movies of 14 different genres:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Genres of movies Leonardo DiCaprio has starred in'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Genres of movies Leonardo DiCaprio has starred in'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using movie titles, you can now find the year of release for each of the actor''s
    movies. As you are only interested in the titles and release years of his movies,
    add a projection clause to the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Titles and release years of Leonardo DiCaprio’s movies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: Titles and release years of Leonardo DiCaprio''s movies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to find the number of movies Leonardo has directed. To gather
    this information, count the number of movies he directed once again, this time
    using the director''s field instead of the actor''s field. The query document
    for this question should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a query that counts the movies that match the preceding query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the query. This shows that Leonardo DiCaprio has directed `0` movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you found and counted documents based on some conditions,
    found distinct values of a field, and projected specific fields in the output.
    In the next section, we will learn about logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about various operators used for writing comparison-based
    queries. The queries we have written so far had only one criterion at a time.
    But in practical scenarios, you may need to write more complex queries. MongoDB
    provides four logical operators to help you build logical combinations of multiple
    criteria in the same query. Let's have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: $and operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `$and` operator, you can have any number of conditions wrapped in
    an array and the operator will return only the documents that satisfy all the
    conditions. When a document fails a condition check, the next conditions are skipped.
    That is why the operator is called a short-circuit operator. For example, say
    you want to determine the count of unrated movies that were released in 2008\.
    This query must have two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The field rated should have a value of `UNRATED`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field year must be equal to `2008`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the document format, both queries can be written as `{"rated" : "UNRATED"}`
    and `{"year" : 2008}`. Put them in an array using the `$and` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows that in 2008, there were 37 unrated movies. In MongoDB
    queries, the `$and` operator is implicit and included by default if a query document
    has more than one condition. For example, the following query can be rewritten
    without using the `$and` operator and gives the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output is exactly the same, so you do not have to use the `$and` operator
    explicitly, unless you want to make your code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: $or Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `$or` operator, you can pass multiple conditions wrapped in an array
    and the documents satisfying either of the conditions will be returned. This operator
    is used when we have multiple conditions and we want to find documents that match
    at least one condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example we used in the *In ($in) and Not In ($nin)* section, you wrote
    a query to count movies that are rated either G, PG, or PG-13\. With the `$or`
    operator, rewrite the same query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Both operators are different and are used in different scenarios. The `$in`
    operator is used to determine whether a given field has at least one of the values
    provided in an array, whereas the `$or` operator is not bound to any specific
    fields and accepts multiple expressions. To understand this better, write a query
    that will find movies that are either rated `G`, were released in `2005`, or have
    at least `5` comments. There are three conditions in this query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{"rated" : "G"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{"year" : 2005}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{"num_mflix_comments" : {$gte : 5}}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use these expressions in an `$or` query, combine these expressions in an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: $nor Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$nor` operator is syntactically like `$or` but behaves in the opposite
    way. The `$nor` operator accepts multiple conditional expressions in the form
    of an array and returns the documents that do not satisfy any of the given conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same query you wrote in the previous section, except that
    the `$or` operator is replaced with `$nor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This query will match and return all the movies that are not rated `G`, were
    not released in `2005`, and do not have more than `5` comments.
  prefs: []
  type: TYPE_NORMAL
- en: $not Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$not` operator represents the logical NOT operation that negates the given
    condition. Simply put, the `$not` operator accepts a conditional expression and
    matches all the documents that do not satisfy it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query finds movies with `5` or more comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `$not` operator in the same query and negate the given condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This query will return all the movies that do not have 5 or more comments and
    the movies that do not contain the `num_mflix_comments` field. You will now use
    the operators you have learned about so far in a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Combining Multiple Queries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The upcoming edition of the magazine has a special focus on Leonardo''s collaborations
    with director Martin Scorsese. Your task for this exercise is to find the titles
    and release years of drama or crime movies in the production of which Leonardo
    DiCaprio and Martin Scorsese have collaborated. To complete this exercise, you
    will need to use a combination of multiple queries, as detailed in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first condition is that Leonardo DiCaprio must be one of the actors and
    that Martin Scorsese must be the director. So, you have two conditions that need
    to have an *AND* relationship. As you have seen earlier, the *AND* relationship
    is the default relationship when two queries are combined. Enter the following
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is one more *AND* condition to be added, which is that the movies
    should be of the drama or crime genres. You can easily prepare two filters for
    the genre field: `{"genres" : "Drama"}` and `{"genres" : "Crime"}`. Bring them
    together in an *OR* relationship, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the genre filter to the main query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query contains all the expected conditions, but you are only
    interested in the title and release year. For this, add the projection part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the query on a mongo shell. The output should look as follows:![Figure
    4.12: Movies in which Leonardo DiCaprio and Martin Scorsese collaborated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: Movies in which Leonardo DiCaprio and Martin Scorsese collaborated'
  prefs: []
  type: TYPE_NORMAL
- en: This output provides the required information; there are four movies that match
    our criteria. The actor and the director last worked together in 2013 on the movie
    *The Wolf of Wall Street*. With that, you have practiced using multiple query
    conditions together with different logical relationships. In the next section,
    you will learn how to query text fields using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world movie service, you will want to provide auto-completion search
    boxes where, as soon as the user types in a few characters of the movie title,
    the search box suggests all the movies whose titles match the character sequence
    typed in. This is implemented using regular expressions. A regular expression
    is a special string that defines a character pattern. When such a regular expression
    is used to find string fields, all the strings that have the matching pattern
    are found and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MongoDB queries, regular expressions can be used with the `$regex` operator.
    Imagine you have typed the word `Opera` into the search box and want to find all
    the movies whose titles contain this character pattern. The regular expression
    query for this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing this query and using projection to print only the titles, the
    result will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Movies with titles containing the word “Opera”'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Movies with titles containing the word "Opera"'
  prefs: []
  type: TYPE_NORMAL
- en: The output from a mongo shell indicates that the regular expression correctly
    returned movies whose title contains the word `Opera`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the caret (^) operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example of regular expressions, the titles in the output contained
    the given word `Opera` at any position. To find only the strings that start with
    the given regular expression, the caret operator (`^`) can be used. In the following
    example, you are using it to find only those movies whose titles start with the
    word `Opera`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the preceding query and project the `title` field, you will
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Projecting only the title field for the preceding query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: Projecting only the title field for the preceding query'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output from a Mongo shell shows that only the movie titles that
    start with the word "Opera" are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dollar ($) operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the caret operator, you can also match the strings that end with
    the given regular expression. To do this, use a dollar operator (`$`). In the
    following example, you are trying to find movie titles that end with the word
    "Opera":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query uses the dollar (`$`) operator after the regular expression
    text. When you execute and project the title fields, you will receive the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Movies whose titles end with “Opera”'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Movies whose titles end with "Opera"'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, by using the dollar (`$`) operator, we have found all the movie titles
    that end with the word `Opera`.
  prefs: []
  type: TYPE_NORMAL
- en: Case-Insensitive Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Searching with regular expressions is case-sensitive by default. The casing
    of the characters in the provided search pattern is matched exactly. However,
    quite often, you will want to provide a word or pattern to the regular expression
    and find documents irrespective of their casing. MongoDB provides the `$options`
    operator for this, which can be used for case-insensitive regular expression searches.
    For example, say you want to find all the movies whose titles contain the word
    "the", first in a case-sensitive way and then in a case-insensitive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query retrieves the titles containing the word `the` in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output in mongo shell shows that this query returns the titles
    containing the word `the` in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Titles containing the word “the” in lowercase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: Titles containing the word "the" in lowercase'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try the same query with case-insensitive search. To do so, provide the
    `$options` argument with a value of `i`, where `i` stands for case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query uses the same regular expression pattern (`the`) but with
    an additional argument; that is, `$options`. Execute the query along with projection
    on the `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Querying for case-insensitive results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Querying for case-insensitive results'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the query and printing the titles shows that the regular expression
    is matched, irrespective of casing. So far, we have learned about querying on
    basic objects. In the next section, we will learn how to query arrays and embedded documents.
  prefs: []
  type: TYPE_NORMAL
- en: Query Arrays and Nested Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Documents and Data Types*, we learned that MongoDB documents
    support complex object structures such as arrays, nested objects, arrays of objects,
    and more. The arrays and nested documents help store self-contained information.
    It is extremely important to have a mechanism to easily search for and retrieve
    the information stored in such complex structures. The MongoDB query language
    allows us to query such complex structures in the most intuitive manner. First,
    we will learn how to run queries on the array elements, and then we will learn
    how to run them on nested object fields.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Array by an Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Querying over an array is similar to querying any other field. In the `movies`
    collection, there are several arrays, and the `cast` field is one of them. Consider
    that, in your movies service, the user wants to find movies starring the actor
    `Charles Chaplin`. To create the query for this search, use an equality check
    on the field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this query and project only the `cast` field, you''ll get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: Finding movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.18: Finding movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the user wants to search for movies with the actors `Charles Chaplin`
    and `Edna Purviance` together. For this query, you will use the `$and` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing and projecting only the array fields produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: Finding movies starring Charles Chaplin and Edna Purviance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: Finding movies starring Charles Chaplin and Edna Purviance'
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that when an array field is queried using a value, all those
    documents are returned where the array field contains at least one element that
    satisfies the query.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Array by an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, we were searching for arrays using the value of an
    element. Similarly, array fields can also be searched using array values. However,
    when you search an array field using an array value, the elements and their order
    must match. Let's try a few examples to demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documents in the `movies` collection have an array to indicate how many
    languages the movie is available in. Let''s assume that your user wants to find
    movies that are available in both `English` and `German`. Prepare an array of
    both values and query the `languages` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the results while projecting the `languages` and `_id` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: Movies available in English and German'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.20: Movies available in English and German'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that when we search by using an array, the value
    is matched exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change the order of the array elements and search again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this query is the same as the previous one except for the order of
    array elements, which is reversed. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Query to demonstrate the impact of the order of array elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.21: Query to demonstrate the impact of the order of array elements'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that by changing the order of the elements in the
    array, different records have been matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has happened because, when array fields are searched using an array value,
    the value is matched using an equality check. Any two arrays only pass the equality
    check if they have the same elements in the same order. Hence, the following two
    queries are not the same and will return different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between these two queries is that the second query doesn''t
    contain the last element; that is, `German`. Now, execute both queries in a mongo
    shell and view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Different queries to demonstrate that array values are matched
    exactly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.22: Different queries to demonstrate that array values are matched
    exactly'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows both queries executed one after the other and proves
    that the array values are matched exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an Array with the $all Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `$all` operator finds all those documents where the value of the field
    contains all the elements, irrespective of their order or size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query uses `$all` to find all the movies available in `English`,
    `French`, and `Cantonese`. You will execute this query, along with projection,
    to display only the `languages` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Query using the $all operator on the languages field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.23: Query using the $all operator on the languages field'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output indicates that the `$all` operator has matched arrays,
    irrespective of the order and size of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting Array Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen that whenever we search an array field, the output always
    contains the complete array. There are a few ways to limit how many elements of
    an array are returned in the query output. We have already practiced projecting
    fields in the resulting documents. Similar to this, elements in an array can also
    be projected. In this section, we will learn how to limit the result set when
    we search with an array field. After this, we will learn how to return specific
    elements from an array based on their index position.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting Matching Elements Using ($)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can search an array by an element value and use projection to exclude all
    but the first matching element of the array using the `$` operator. To do this,
    execute a query without the `$` operator first, and then execute it with this
    operator. Prepare a simple element search query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses element search on the `languages` array and projects the field
    to produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Movies available in the Syriac language'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.24: Movies available in the Syriac language'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the query is intended to find Syriac-language movies, the output array
    contains other languages as well. Now, see what happens when you use the `$` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You have modified the query to add the `$` operator in the projection part.
    Now, execute the query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: Movies available only in the Syriac language'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.25: Movies available only in the Syriac language'
  prefs: []
  type: TYPE_NORMAL
- en: The array field in the output only contains the matching element; the rest of
    the elements are skipped. Thus, the `languages` array in the output only contains
    the `Syriac` element. The most important thing to remember is that if more than
    one element is matched, the `$` operator projects only the first matching element.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting Matching Elements by their Index Position ($slice)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `$slice` operator is used to limit the array elements based on their index
    position. This operator can be used with any array field, irrespective of the
    field being queried or not. This means that you may query a different field and
    still use this operator to limit the elements of the array fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, we will use the movie `Youth Without Youth` as an example, which
    has 11 elements in the `languages` array. The following output from the mongo
    shell shows what the array field looks like in the movie record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26: List of languages for the movie Youth Without Youth'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.26: List of languages for the movie Youth Without Youth'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following query, use `$slice` to print only the first three elements
    of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding query shows that the `languages` field only contains
    the first three elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$slice` operator can be used in a few more ways. The following projection
    expression will return the last two elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that the array has been sliced down to the last
    two elements only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$slice` operator can also be passed with two arguments, where the first
    argument indicates the number of elements to be skipped and the second one indicates
    the number of elements to be returned. For example, the following projection expression
    will skip the first two elements of the array and return the next four elements
    after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this query, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The two-argument slice can also be used with a negative value for skip. For
    example, in the following projection expression, the first number is negative.
    If the value of skip is negative, the counting starts from the end. So, in the
    following expression, five elements counting from the last index will be skipped
    and four elements starting from that index will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that because of the negative skip value, the skip index will be calculated
    from the last index. Skipping five elements from the last index gives us `Romanian`
    and from this index position, the next four elements will be returned, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have covered how to query array fields and how to project
    the results in various ways. In the next section, we will learn how to query nested
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Nested Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to arrays, nested or embedded objects can also be represented as values
    of a field. Hence, fields that have other objects as their values can be searched
    using the complete object as a value. In the `movies` collection, there is a field
    named `awards` whose value is a nested object. The following snippet shows the
    `awards` object for a random movie in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query finds the `awards` object by providing the complete object
    as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that there are several movies whose `awards` field
    has an exact value of `{"wins": 1, "nominations": 0, "text": "1 win."}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27: List of movies without a nomination and one award'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.27: List of movies without a nomination and one award'
  prefs: []
  type: TYPE_NORMAL
- en: 'When nested object fields are searched with object values, there must be an
    exact match. This means that all the field-value pairs, along with the order of
    the fields, must match exactly. For example, consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This query has a change in order regarding the query object; hence, it will
    return an empty result.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Nested Object Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Chapter 2*, *Documents and Data Types*, we saw that fields of nested objects
    can be accessed using dot (`.`) notation. Similarly, dot notation can be used
    to search nested objects by providing the values of its fields. For example, to
    find movies that have won four awards, you can use dot notation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query uses dot (`.`) notation on the `awards` field and refers
    to the nested field named `wins`. When you execute the query and project only
    the `awards` field, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28: Projecting only the awards field for preceding snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.28: Projecting only the awards field for preceding snippet'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output indicates that the filter has been correctly applied to
    `wins` and that all the movies that have exactly four awards are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested field search is performed independently on the given fields, irrespective
    of the order of the elements. You can search by multiple fields and use any of
    the conditional or logical query operators. For example, refer to the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses a combination of two conditions on two different nested fields.
    Upon executing the query while excluding the rest of the fields, you should see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29: Movies with six nominations and a minimum of five awards'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.29: Movies with six nominations and a minimum of five awards'
  prefs: []
  type: TYPE_NORMAL
- en: This query performs a search on two fields using conditional operators and returns
    movies that have six nominations and have won at least five awards. Like array
    elements or any field in a document, nested object fields can also be projected
    as we want. We will explore this in detail in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Projecting Nested Object Fields'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to project only certain fields from nested
    objects. The following steps will help you implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a mongo shell and connect to the `sample_mflix` database on Mongo Atlas.
    Enter the following query to return all the records and project only the `awards`
    field, which is an embedded object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that only the `awards` field has been included in
    the result, while the rest of the fields (including `_id`) have been excluded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30: Projecting only the awards field for a query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.30: Projecting only the awards field for a query'
  prefs: []
  type: TYPE_NORMAL
- en: 'To project only specific fields from embedded objects, you can refer to a field
    of an embedded object using dot notation. Type in the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this query on a mongo shell, the output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31: Projecting only the awards object, without the text field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.31: Projecting only the awards object, without the text field'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that only two of the nested fields are included in
    the response. The `awards` object in the output is still a nested object, but
    the `text` field has been excluded.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how nested objects and their fields can be limited in the
    output. This concludes our discussion on querying arrays and nested objects in
    MongoDB. In the next section, we will learn how to skip, limit, and sort documents.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting, Skipping, and Sorting Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to write basic and complex queries and to project
    fields in the resulting documents. In this section, you will learn how to control
    the number and order of documents returned by a query.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about why the amount of data a query returns needs to be controlled.
    In most real-world cases, you won't be using all the documents your query matches
    to. Imagine that a user of our movie service is planning to watch a drama movie
    tonight. They will visit the movie store and search for drama movies and find
    that there are more than 13,000 of these in the collection. With such a large
    search result, they might spend the entire night just looking through the various
    movies and deciding which one to watch.
  prefs: []
  type: TYPE_NORMAL
- en: For a better user experience, you may want to show the 10 most popular movies
    in the drama category at a time, followed by the next 10 in the sequence, and
    so on. This technique of serving data is known as pagination. This is where a
    large result is divided into small chunks (also known as pages) and only one page
    is served at a time. Pagination not only improves the user experience, but also
    the overall performance of the system, and reduces the overhead on a database,
    network, or a user's browser or mobile application. To implement pagination, you
    must be able to limit the size of result, skip the already served records, and
    have them served in a definite order. In this section, we will practice all three
    of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To limit the number of records a query returns, the resulting cursor provides
    a function called `limit()`. This function accepts an integer and returns the
    same number of records, if available. MongoDB recommends the use of this function
    as it reduces the number of records that result from the cursor and improves the
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the titles of movies starring `Charles Chaplin`, enter the following
    query, which finds the actor''s name in the `cast` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The query is also adding a projection to the `title` field. When you execute
    the query, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32: Output showing movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.32: Output showing movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, there are a total of eight movies that `Charles Chaplin` has
    acted in. Next, you will use the limit function to restrict the result size to
    `3`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When this query is executed, only three records are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Using limit() to show only three movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.33: Using limit() to show only three movies starring Charles Chaplin'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the behavior of the `limit()` function when it's used with different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the limit size is larger than the actual records within the cursor, all
    the records will be returned, irrespective of the set limit. For example, the
    following query will return `8` records, even when the limit is set to `14`, as
    there are only `8` records present in the cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query results in the following output, which shows that the query
    has returned all eight records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34: Output when limit is set to 14'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.34: Output when limit is set to 14'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that setting the limit to zero is equivalent to not setting any limit
    at all. The following query will therefore return all eight records that match
    the criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35: Output when limit is set to 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.35: Output when limit is set to 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, are you wondering what will happen if the limit size is set to a negative
    number? For queries returning smaller records, as in our case, a negative size
    limit is considered equivalent to the limit of a positive number. The following
    query demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this query (which has a negative limit of -`2` on a mongo
    shell), you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36: Output when limit is -2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.36: Output when limit is -2'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that the query returned two documents and the behavior is equivalent
    to using `limit` of size `2`. However, the result set's batch size can affect
    this behavior. The next section will explore this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Limit and Batch Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a query is executed in MongoDB, the results are processed and returned
    in the form of one or more batches. The batches are allotted internally, and the
    results will be displayed all at once. One of the main purposes of batching is
    to avoid high resource utilization, which may happen while processing a large
    number of record sets.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it keeps the connection between the client and server active, because
    of which timeout errors are avoided. For large queries, when the database takes
    longer to find and return the result, the client just keeps on waiting. After
    a certain threshold value for waiting is reached, the connection between the client
    and server is broken and the query is failed with a timeout exception. Using batching
    avoids such timeouts as the server keeps retuning the individual batches continuously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different MongoDB drivers can have different batch sizes. However, for a single
    query, the batch size can be set, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses the `batchSize()` function on the cursor to provide a batch
    size of `5`. The output of executing this query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37: Output when batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.37: Output when batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: The query in the preceding output adds a batch size of `5`, but it has no effect
    on the output. However, there was a difference in how the results were prepared
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: Positive Limit with Batch Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the preceding query is executed, which specifies a batch size of `5`, the
    database starts finding the documents that match the given condition. As soon
    as the first five documents are found, they are returned to the client as the
    first batch. Next, the remaining three records are found and returned as the next
    batch. However, for the users, the results are printed at once and the change
    is unnoticeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing happens when a query is executed with a positive limit that
    is larger than the batch size and the records are internally fetched in multiple
    batches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses a limit of `7`, which is larger than the provided batch size
    of `5`. When the query is executed, we get the expected `7` records, without any
    noticeable changes. The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38: Output when limit is 7 and batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.38: Output when limit is 7 and batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to perform batching without specifying a limit,
    and then specifying a positive limit value. Now, we will see what happens when
    we use a negative limit value, whose positive equivalent is larger than the given
    batch size.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Limits and Batch Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned in the previous examples, MongoDB uses batches if the total number
    of records in the result exceeds the batch size. However, when we use a negative
    number to specify the limit size, only the first batch is returned and the next
    batch, even if it is required, will not be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will demonstrate this by using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses a limit of negative `7` and batch of `5`, which means it should
    take two batches to return the results. To observe this behavior, execute this
    query on a mongo shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39: Output when limit is -7 and batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.39: Output when limit is -7 and batch size is 5'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that the query returned only the first five records instead
    of the expected seven records. This is because the database returned only the
    first batch and the next batch was not processed.
  prefs: []
  type: TYPE_NORMAL
- en: This proves that the negative limit is not exactly equivalent to providing the
    number in positive form. The results will be the same if the number of records
    returned by the query is smaller than the specified batch size. In general, you
    should avoid using a negative limit, but if you do, make sure to use an appropriate
    batch size so that such scenarios can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Skipping is used to exclude some documents in the result set and return the
    rest. The MongoDB cursor provides the `skip()` function, which accepts an integer
    and skips the specified number of documents from the cursor, returning the rest.
    In the previous examples, you prepared queries to find the titles of movies starring
    Charles Chaplin. The following example uses the same query with the `skip()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `skip()` function has been provided with the value `2`, the first
    two documents will be excluded from the output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.40: Output with a skip value of 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.40: Output with a skip value of 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `limit()`, passing zero to `skip()` is equivalent to not calling
    the function at all, and the entire result set is returned. However, `skip()`
    has a different behavior for negative numbers; it does not allow the use of negative
    numbers. Thus, the following query is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this query, you''ll get an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41: Output with a skip value of -3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.41: Output with a skip value of -3'
  prefs: []
  type: TYPE_NORMAL
- en: The `skip()` operation does not make use of any indexes, so it performs nicely
    on a smaller collection but may lag noticeably on larger collections. We will
    cover the topic of indexing in detail in *Chapter 9*, *Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting is used to return documents in a specified order. Without using explicit
    sorting, MongoDB does not guarantee the order in which the documents will be returned,
    which may vary, even if the same query is executed twice. Having a specific sort
    order is important, especially during pagination. During pagination, we execute
    the query with a specified limit and serve. For the next query, the previous records
    are skipped, and the next limit is returned. During this process, if the order
    of the records changes, some movies may appear on multiple pages and some movies
    may not appear at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MongoDB cursor provides a `sort()` function that accepts an argument of
    the document type, where the document defines a sort order for specific fields.
    See the following query, which prints Charles Chaplin''s movie titles with a sort
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding query, you are calling the `sort()` function on the resulting
    cursor. The argument to the function is a document where the `title` field has
    a value of `1`. This specifies that the given field should be sorted in ascending
    order. When the query is executed after it''s been sorted, the results are evident,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42: Sorting in ascending order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.42: Sorting in ascending order'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, pass `-1` to the `sort` argument, which represents sorting in descending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43: Sorting in descending order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.43: Sorting in descending order'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting can be performed on multiple fields, and each field can have a different
    sorting order. Let''s look at an example that sorts the IMDb ratings of movies
    in descending order, and the year by ascending order. The query should return
    50 movies where the movie with the highest IMDb rating appearing at the top. If
    two movies have the same ratings, then the older movie should take precedence.
    The following query can be used to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we conclude this section, it is worth noting that any number other than
    a positive or negative integer, including zero, is considered invalid for sorting
    in MongoDB. If such a value is used, the query fails and we see the message `"bad
    sort specification error"`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In the next activity, we will use everything we've learned in this chapter to
    implement pagination for a genre-based movie search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Finding Movies by Genre and Paginating Results'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your organization is planning to provide a new feature to its users where they
    will be able to find movies in their favorite genre. Since the movies database
    is huge, there's a lot of movies from each genre, and returning all the matching
    movie titles is not very useful. The requirement is to serve the results in small
    chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task for this activity is to create a JavaScript function on the mongo
    shell. The function should accept a genre of the user''s choice and print all
    the matching titles, where the titles with the highest IMDb ratings should appear
    at the top. Along with the genre, the function will accept two more parameters
    for the page size and page number. The page size defines how many records need
    to be displayed on one page, while the page number indicates which page the user
    is currently on. The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a `findMoviesByGenre` function that accepts three arguments: `genre`,
    `pageNumber`, and `pageSize`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Write a query to filter the result based on `genre` and return the titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the results to show the highest rated movies at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the logic of skipping and limiting the results using the `pageNumber` and
    `pageSize` parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the result cursor into an array using the `toArray()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the resulting array and print all the titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the function in the mongo shell by copying and pasting it into the shell
    and executing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider that the genre provided by the user is `Action`. Here, as shown in
    the following output, the function is executed and shows the first page of results,
    showing the top five action movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44: First page showing the top five action movies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.44: First page showing the top five action movies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following output shows the function returning the second page
    of five action movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45: Second page of action movies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_04_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.45: Second page of action movies'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor467).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with a detailed study of the structure of MongoDB queries
    and how different they are from SQL queries. Then, we implemented these queries
    to find and count the documents and limit the number of fields returned in the
    result using various examples. We also learned about the various conditional and
    logical operators and practiced using them in combination to notice the difference
    in results.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to provide a text pattern using regular expressions to filter
    our search results, and covered how to query arrays and nested objects and include
    their specific fields in the results. Finally, we learned how to paginate large
    result sets by using limiting, sorting, and skipping on the documents in the result.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to insert, update, and delete documents
    from MongoDB collections.
  prefs: []
  type: TYPE_NORMAL
