- en: Implementation of OOP in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at classes, objects, and the four principles
    of OOP. In this chapter, we will learn about some C# language features that make
    the language an OOP language. Without knowing these concepts, writing object-oriented
    code with C# programming could be difficult, or will prevent you from using it
    to its full potential. In [Chapter 2](aa24810a-3609-442e-b26b-3b742d0ddc2f.xhtml),
    *Hello OOP - Classes and Objects,* we learned that abstraction, inheritance, encapsulation,
    and polymorphism are the four basic principles of OOP, but we haven't yet learned
    how the C# language can be used to fulfill these principles. We are going to discuss
    this topic in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The partial class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sealed class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access specifiers for classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a blueprint, which means it contains the members and methods that
    the instantiated objects will have. An **interface** can also be categorized as
    a blueprint, but unlike a class, an interface doesn't have any method implementation.
    Interfaces are more like a guideline for classes that implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of interfaces in C# are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can't have a method body; they can only have the method signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces can have methods, properties, events, and indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface can't be instantiated, so no object of an interface can be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One class can extend multiple interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the major uses of an interface is dependency injection. By using interfaces,
    you can reduce the dependencies in a system. Let''s look at an example of an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see that we have one interface, called `IBankAccount`, that
    has two members: `Debit` and `Credit`. Both of these methods have no implementations
    in the interface. In the interface, the method signatures are more like guidelines
    or requirements for the classes that will implement this interface. If any class
    implements this interface, then the class has to implement the method body. This
    is a great use of the OOP concept of inheritance. The class will have to give
    an implementation of the methods that are mentioned in the interface. If the class
    doesn''t implement any of the methods of the interface, the compiler will throw
    an error that the class has not implemented all the methods of the interface.
    By language design, if an interface is implemented by a class, all the members
    of the interface must be taken care of in the class. Consequently, in the preceding
    code, the `BankAccount` class has implemented the `IBankAccount` interface and
    this is why the two methods, `Debit` and `Credit`, have to be implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **abstract class** is a special kind of class that comes with the C# programming
    language. This class has similar functionalities to an interface. For example,
    an abstract class can have methods without implementation and with implementation.
    Consequently, when a class implements an abstract class, the class has to override
    the **abstract methods** of the abstract class. One of the main characteristics
    of an abstract class is that it can't be instantiated. An abstract class can only
    be used for inheritance. It might or might not have abstract methods and assessors.
    Sealed and abstract modifiers can't be placed in the same class, as they have
    completely separate meanings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we saw that the `Dog` class is implementing the `Animal`
    class, and as the `Animal` class has an abstract method called `Move()`, the `Dog`
    class must override it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to instantiate the abstract class, the compiler will throw an error,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The partial class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can split a class, a struct, or an interface into smaller portions that
    can be placed in different code files. If you want to do this, you have to use
    the keyword **partial**. Even though the code is in separate code files, when
    complied, they will be treated as one class altogether. There are many benefits
    of partial classes. One benefit is that different developers can work on different
    code files at a time. Another benefit is that if you are using autogenerated code
    and you want to extend some functionality of that autogenerated code, you can
    use a partial class in a separate file. Consequently, you are not directly touching
    the autogenerated code, but adding new functionality in the class.
  prefs: []
  type: TYPE_NORMAL
- en: The partial class has a few requirements, one of which is that all classes must
    have the keyword `partial` in their signatures. All the partial classes also have
    to have the same name, but the file names can be different. The partial classes
    also have to have the same accessibility, such as public, private, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a partial class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, you can create many partial classes of a class.
    This will increase the readability of your code, and your code organization will
    be more structured.
  prefs: []
  type: TYPE_NORMAL
- en: The sealed class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the principles of OOP is inheritance, but sometimes you may need to restrict
    inheritance in your code for the sake of your application's architecture. C# provides
    a keyword called `sealed`. If this keyword is placed before a class's signature,
    the class is considered a **sealed class**. If a class is sealed, that particular
    class can't be inherited by other classes. If any class tries to inherit a sealed
    class, the compiler will throw an error. Structs can also be sealed, and in that
    case, no class can inherit that struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a sealed class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see how we can create a sealed class. Just
    using the `sealed` keyword before the `class` keyword makes the class a sealed
    class. In the preceding example, we created an `Animal` sealed class, and in the
    `main` method, we instantiated the class and used it. This is now working fine.
    However, if we try to create a `Dog` class that will inherit the `Animal` class,
    as in the following code, then the compiler will throw an error, saying that the
    sealed `Animal` class can''t be inherited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of what the compiler will show:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f52ff92-f316-4553-b8e9-d224d8e367c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **tuple** is a data structure that holds a set of data. Tuples are mainly
    helpful when you want to group data and use it. Normally, a C# method can only
    return one value. By using a tuple, it is possible to return multiple values from
    a method. The `Tuple` class is available under the `System.Tuple` namespace. A
    tuple can be created using the `Tuple<>` constructor or by an abstract method
    named `Create` that comes with the `Tuple` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix any data type in a tuple and access it using `Item1`, `Item2`,
    and so on. Let''s look at an example to get a better idea of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at how to return a tuple from a method by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For security reasons, all the fields of a class shouldn''t be exposed to the
    outside world. Consequently, exposing private fields is done by properties in
    C#, which are members of that class. Underneath the properties are special methods
    that are called **accessors**. A property contains two accessors: `get` and `set`.
    The `get` accessor gets values from the field while the `set` accessor sets values
    to the field. There is a special keyword for a property, named `value`. This represents
    the value of a field.'
  prefs: []
  type: TYPE_NORMAL
- en: By using access modifiers, properties can have different access levels. A property
    can be `public`, `private`, `read only`, `open for read and write`, and `write
    only`. If only the `set` accessor is implemented, this means that the `only write`
    permission is given. If both `set` and `get` accessors are implemented, this means
    that both `read` and `write` permissions are open for that property.
  prefs: []
  type: TYPE_NORMAL
- en: C# provides a smart way of writing `setter` and `getter` methods. If you create
    a property in C#, you don't have to manually write `setter` and `getter` methods
    for a particular field. Consequently, the common practice in C# is to create properties
    in a class, rather than creating fields and `setter` and `getter` methods for
    those fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to create property in C#, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Animal` class has two properties: `Name` and `Age`. Both the properties
    have `Public` access modifiers as well as `setter` and `getter` methods. This
    means that both properties are open for `read` and `write` operations. The convention
    is that properties should be in camel case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to modify your `set` and `get` methods, you can do so in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are not using the shortcut of creating `setters`
    and `getters` for the `Name` property. We have extensively written what the `set`
    and `get` methods should do. If you look closely, you will see the `name` field
    in lowercase. This means that when you create a property in camel case, a field with
    the same name is created internally, but in Pascal case. The `value` is a special
    keyword that actually represents the value of that property.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are working behind the scenes in the background, which makes the
    code much cleaner and easier to use. It's very much recommended that you use properties
    instead of local fields.
  prefs: []
  type: TYPE_NORMAL
- en: Access specifiers for classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Access specifiers**, or **access modifiers**, are some reserved keywords
    that determine the accessibility of a class, method, property, or other entity.
    The object-oriented principle of encapsulation is achieved by using these access
    specifiers in C#. In total, there are five access specifiers. Let''s take a look
    at what these are and what the differences are between them.'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **p****ublic** access specifier means that there is no limitation to access
    the entity being modified. If a class or member is set as `public`, it can be
    accessed by other classes or programs in the same assembly, other assemblies,
    and even other programs that are installed in the operating system that the program
    is running in. Normally, the starting point of an application or main method is
    set as `public`, meaning that it can be accessed by others. To make a class `public`,
    you just need to put a `public` keyword before the keyword class, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Animal` class can be accessed by any other class, and as the
    member `Name` is also public, it can also be accessed from any location.
  prefs: []
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **private** specifier is the most secure access specifier available in the
    C# programming language. By setting a class or member of a class as `private`,
    you are determining that the class or the member won't be allowed to be accessed
    by other classes. The scope of a `private` member is within the class. For example,
    if you create a `private` field, that field can't be accessed outside the class.
    That `private` field can only be used internally in that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a class with a `private` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, as the `GetName()` method and the `private` field `name` are in the same
    class, the method can access the field. However, if another method outside of
    the `Animal` class tries to access the `name` field, it won't be able to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code, the `Main` method is trying to set the
    `private` field name, which is not permissible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Internal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you set `internal` as an access specifier, this means that the entity is
    only accessible within the same assembly. All the classes in the assembly can
    access this class or member. When you build a project in .NET, it creates an assembly
    file, either `dll` or `exe`. There could be many assemblies in one solution, and
    internal members are only accessible by the classes on those particular assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of this, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Protected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Protected** members are accessible by the class itself, as well as the child
    classes that inherit the class. Other than that, no other class can access a protected
    member. The protected access modifier is very useful when inheritance takes place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to use this by looking at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Protected internal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **protected internal **is a combination of a protected access modifier and
    an internal access modifier. A member whose access modifier is `protected internal`
    can be accessed by all classes in the same assembly, as well as by any class that
    inherits it, regardless of the assembly. For example, say that you have a class
    named `Animal` in an assembly called `Assembly1.dll`. In the `Animal` class, there
    is a protected internal method called `GetName`. Any other class in `Assembly1.dll`
    can access the `GetName` method. Now, suppose there is another assembly named
    `Assembly2.dll`. In `Assembly2.dll`, there is a class named `Dog` that extends
    the `Animal` class. As `GetName` is a protected internal, even though the `Dog`
    class is in a separate assembly, it can still access the `GetName` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to get a clearer understanding of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at class hierarchies and some other features that
    make the C# programming language an OOP language. Knowing these concepts is essential
    for a C# developer. By knowing class hierarchies, you can design your system so
    that it is decoupled and flexible. You need to know how to use inheritance in
    your application to get the best of OOP. The interface, abstract class, sealed
    class, and partial class will give you good control of your application. When
    working in a team, defining the class hierarchies properly will help you to maintain
    code quality and security.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about tuples and properties will improve your code cleanness and make
    your life much easier when developing the application. Access specifiers are implementations
    of the OOP concept of encapsulation. It is important to be familiar with these
    concepts. You need to know which piece of code should be available publicly, which
    should be private, and which should be protected. If you misuse these access specifiers,
    you might end up in a situation where your application will have security holes
    and code repetition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the important and interesting topic of
    object collaboration.
  prefs: []
  type: TYPE_NORMAL
