- en: Data Transfer Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to send and receive data in the React Native
    application. Firstly, we will make our application more dynamic and dependent
    on the backend servers. You will learn about the Thunk pattern, which fits into
    Flux really neatly. Then, we will dive into a more advanced library, redux-saga,
    which is based on an effect pattern. Both of the solutions will enable our application
    to seamlessly exchange data with the server. I will also give you a little introduction
    to more advanced communication patterns, such as `HATEOAS` and `GraphQL`. Although
    those two patterns are rarely crucial for a React Native developer, you will find
    it much easier to understand if, one day, those patterns become popular within
    the React Native world too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a fake API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch data from the backend and store it in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design action creators and decouple fetching logic from the containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Redux Thunk to conditionally dispatch actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your own iterators and generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefit from sagas that heavily rely on generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test various APIs without relying on external sources, we will create
    our own local API. You do not need to know any backend language, nor how to expose
    an API. In this chapter, we will use a special library that builds an API based
    on the JSON file that we provide.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have made a neat application displaying tasks. Now, instead of loading
    the local data file, let's use our own REST API. Clone the task application to
    start. (I will be using code from example two in the directory for [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml),
    *Store Patterns**.*)
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is a set of rules that put constraints
    on web services. One of the crucial requirements is statelessness, which guarantees
    the server will not store the client''s data, but instead rely only on the request
    data. This should be sufficient enough to send a reply to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a fake API, we will use the `json-server` library. The library
    expects a JSON file; most examples call it `db.json`. Based on the file, the library
    creates a static API that sends data on requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing the library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer to avoid `global`, please remember to provide a relative path
    to the `node_modules/json-server/bin` in the following scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON file for the library should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, our `tasks.json` file fits this requirement. We can now launch our
    local server. Open `package.json` and add a new script called `server`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now type `yarn run server` to launch it. The data will be exposed at `http://localhost:3000/tasks`.
    Simply access the URL with your browser to check if it works. A correctly set
    up server should print data like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed further to learn how to work with endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data with the built-in function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's start with something fairly basic. React Native implements the
    Fetch API, which is nowadays a standard for making REST API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to activity indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have a default task list being loaded from the file in `taskReducer.js`.
    To be honest, loading from either the file or API can be time consuming. It will
    be better initially to set the task list to empty the array and provide feedback
    to the user with a spinner or text message, informing them that the data is being
    loaded. We will implement this along with the change to the Fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, remove data import from the file in the reducer. Change the declaration
    from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace it with the code in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Loading data from a file is also a side effect and should undergo similarly
    restrictive patterns to data fetching. Don't be fooled by the previous implementation
    that we used to synchronously load data. This shortcut was taken only to concentrate
    on the specific learning material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the application to see an empty list. Let''s now add a loading indicator,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, where the loading is taking a long time, you will need to handle
    a more complex scenario: the data is loading, but the user may still add tasks
    in the meantime. In the previous implementation, the task would not be shown until
    the data is retrieved from the server. The easy fix for this is to always show
    tasks if we have any, regardless of the `isLoading` prop, which would mean that
    some other data is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we have a loading indicator that is shown based on the `isLoading` prop,
    we need to think about other states that our fetching process may produce.
  prefs: []
  type: TYPE_NORMAL
- en: Handling error scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetch, in most use cases, will require three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**START**: A fetch start, which should cause `isLoading` to be `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SUCCESS**: Data was fetched successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ERROR**: Fetch could not retrieve data; an appropriate error message should
    be shown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last state we need to handle is error. There are a few approaches to this
    with respect to user experience guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an error message within the list—this provides a clear message for
    those who care about the data in the table. It may include a clickable link or
    a button to retry. You may mix this approach with the ones that follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a floating notification about the failure—this shows the message
    about the error in one of the corners. The message may disappear after a few seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying an error modal—this stops the user to notify them about the error;
    it may contain actions such as retry, and dismiss.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The approach I would like to take here is the first one. It is fairly easy
    to implement—we need to add an `error` prop and, based on it, display a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Naive stateful component fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s fetch some data and make our markup fully usable. First, we will
    follow the approach for beginners in React: using `fetch` in one of the stateful
    components. In our case, it will be `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach has a number of disadvantages. First, it does not follow the
    Fetch API documentation. Let''s read this crucial quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Promise returned from fetch won’t reject on HTTP error status even if
    the response is an HTTP 404 or 500\. Instead, it will resolve normally (with ok status
    set to false), and it will only reject on network failure or if anything prevented
    the request from completing."'
  prefs: []
  type: TYPE_NORMAL
- en: '- *Fetch API documentation, available at:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the preceding implementation lacks HTTP error handling.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is state duplication, where we maintain a Redux state, but
    then copy tasks to the local component state, and even override it with what has
    been fetched. We could be more concerned about what we have in the tasks already
    by concatenating both arrays, and find a way to avoid storing the tasks again.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the Redux state changes, then the previous component will entirely
    neglect the update. This is too bad—let's find a way to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: The Thunk pattern and Redux Thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the **Thunk pattern** and how to use it
    with the **Redux Thunk** library. To begin, we will need to refactor our naive
    and faulty implementation from the previous section to one using Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Lifting the state to Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of relying on the component state, let''s lift it to a Redux store.
    Pay attention to the `Immutable.Map` we use here. Also, the `ADD_TASK` action
    is now using the `update` function from `Immutable.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have changed the reducer, we need to fix the stateful component. Instead
    of having its own state, it should delegate to the Redux store through actions.
    However, we will implement these actions later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is wise to move fetching logic to a separate service. This will enable other
    components to share the same function once they need to trigger fetch too. This
    is your homework.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `componentDidMount`, you could dispatch actions to a constructor.
    This, however, could create the temptation to refactor to the function component.
    This would be a disaster, as you would start fetching on every re-render. Also, `componentDidMount`
    is safer for us, as in case of any computations that could slow down the application
    in context of the actions, we are 100% sure that the user can already see `ActivityIndicator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, move to the actions implementation. You should be able to write them on
    your own. In case of any trouble, see  `src / Chapter 6 / Example 3 / src / data
    / TaskActions.js`. We will now focus on extending the reducer. This is quite some
    work, as we need to handle all three action types: `FETCH_START`, `FETCH_COMPLETE`,
    and `FETCH_ERROR`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is basically it. In the end, you will also need to update views to use
    a new structure, `Immutable.Map`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a few improvements to be made to this code. I will not touch on them
    right now, as those are advanced topics and involve more general JavaScript functional
    programming concepts. You will learn about lenses and selectors in [Chapter 8](c5f12b5a-17f8-4cfe-8e0b-5c54713c4288.xhtml),
    *JavaScript and ECMAScript Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of refactoring to Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may be tricky to see the benefits of the previous refactor. Some of these
    refactors shine only days after you make them. Take, for example, the need to
    re-fetch the tasks on a given event. This event happens in a completely different
    part of the app and is not connected to the task list. In the naive implementation,
    you would need to deal with the update process and keep everything up to date.
    You would also need to expose a `fetch` function to another component. This would
    tightly couple those two. Disaster. Instead, as you can see, you would likely
    prefer to duplicate fetching logic to the second separated component. Again, you
    would end up with code duplication. Therefore, you would create a parent service
    shared by those two components. Unfortunately, the fetching is tightly coupled
    with the state, hence you would move state to the service as well. Then, you would
    make some hacks, such as using closure to store the data within the service. As
    you can see, this is a smooth solution to these problems.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Redux store, however, you have one centralized state that is
    updated only through reducers. Fetching is sending data to the reducers using
    carefully designed actions. Fetch can be performed in a separated service that
    is shared by the components that need to fetch tasks. We will now introduce a
    library that makes all of these things cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux Thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In classic Redux, with no middleware, you cannot dispatch something that is
    not a pure object. With Redux Thunk, you can delay the dispatch by dispatching
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Redux Thunk middleware allows you to write action creators that return a function
    instead of an action. The thunk can be used to delay the dispatch of an action,
    or to dispatch only if a certain condition is met. The inner function receives
    the store methods dispatch and getState as parameters."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Redux Thunk official documentation, available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/reduxjs/redux-thunk](https://github.com/reduxjs/redux-thunk).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can dispatch a function. Such a function has two arguments:
    `dispatch` and `getState`. This function does not reach the Redux reducers yet.
    It only delays the old-fashioned Redux dispatch until necessary checks are performed,
    for instance, checks based on current state. Once we are ready to dispatch, we
    use the `dispatch` function provided as a `function` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous section, I pointed out that the `fetch` call could be a separate
    function. If you haven''t done the homework, here is an example refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our so-called `ActionCreators` are tightly coupled to `dispatch`,
    and therefore not only create actions, but also `dispatch`. Let''s loosen their
    responsibilities by removing dispatching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to make sure to dispatch the preceding actions to the relevant
    places. This can be achieved by passing to `dispatch`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For those experienced in programming, this step may look a little like we are
    repeating ourselves. We are duplicating function parameters and the only thing
    we gain is the invocation of dispatch. We can fix this with functional patterns.
    Such improvements will be made as part of [Chapter 8](c5f12b5a-17f8-4cfe-8e0b-5c54713c4288.xhtml), *JavaScript
    and ECMAScript Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, please note that in this book, I'm not writing many tests. Once
    you make writing tests a habit, you will quickly appreciate such easily testable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having done this, we can now adjust our container component, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Okay, this is a great refactor, but where is Redux Thunk? This is a very good
    question. I did prolong this example on purpose. In many React and React Native
    projects, I see overuse of Redux Thunk and other libraries. I don't want you to
    be another developer who does not understand the purpose of Redux Thunk and abuses
    the power that it gives.
  prefs: []
  type: TYPE_NORMAL
- en: Redux Thunk primarily lets you decide to dispatch conditionally. The access
    to `dispatch` through the Thunk function is not something extraordinary. The main
    benefit is the second argument, `getState`. This lets you access the current state
    and decide based on the values there.
  prefs: []
  type: TYPE_NORMAL
- en: Such powerful tools may lead you to create impure reducers. How? Instead of
    creating a real reducer, you would create a **setter reducer**, working similarly
    to the set function in classes. Such a reducer would be invoked only to set the
    value; however, the value would be computed in the Thunk function, using the `getState`
    function. This is completely anti-pattern and may lead to a serious breaking of
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the dangers, let's move on to the real usages of Thunks. Imagine
    a situation where you would like to make a decision conditionally. How would you
    access the state to make an `if` statement? This gets complicated once we use
    the `connect()` function in Redux. The `mapDispatchToProps` function that we pass
    to `connect` does not have access to the state. But we need it, so here comes
    a valid usage of Redux Thunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is good to know: how would we make an escape hatch if we could
    not use Redux Thunk? We could pass part of the state to the `render` function,
    and then invoke the original function with the expected state. The `if` statement
    could be done with a regular `if` in JSX. This could, however, lead to serious
    performance issues.'
  prefs: []
  type: TYPE_NORMAL
- en: It's time to use Redux Thunk in our case. You may have noticed that our dataset
    does not contain IDs. This is a huge problem if we fetch tasks two times, as we
    have no mechanism to tell which tasks have been added and which are already present
    in our UI. The current approach of adding all of the fetched tasks would lead
    to task duplication. The first prevention mechanism for our broken architecture
    is to stop the fetch if `isLoading` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life scenario would either use IDs or refresh all the tasks on fetch.
    If so, `ADD_TASK` would need to guarantee changes in the backend server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the era of Progressive Web Apps, we need to stress this problem even further.
    Take the case where a connection is lost before adding a new task. If your UI
    adds the task locally and schedules a backend update, once the network connection
    is resolved you may run into a race condition: this means that tasks are being
    refreshed before your `ADD_TASK` update is propagated in the backend system. As
    a result, you would end up with a task list that will not contain the added task
    until you refetch all tasks from the backend. This may be extremely misleading
    and should not happen in any financial institution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this naive prevention mechanism to illustrate the capabilities
    of Redux Thunk. First, install the library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to apply `thunk` middleware to Redux, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, we can dispatch functions. Let''s now fix our `fetch` function
    to avoid multiple requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite a simple use case. Please use Redux Thunk wisely
    and do not abuse the power that it gives you.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Thunk pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thunk is another pattern that isn't specific to React or Redux. Actually, it
    is used quite widely in many hardcore solutions, such as compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thunk is a pattern that delays evaluation until it cannot be avoided. One of
    the beginner examples that explains this is simple addition. An example is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Some more complex usages, for instance, in functional languages, may rely on
    this pattern throughout the entire language. Hence, computations are performed
    only when the end application layer needs them. Usually, no ahead-of-time computations
    are performed, as such optimizations are the responsibility of the developer.
  prefs: []
  type: TYPE_NORMAL
- en: The saga pattern and Redux Saga
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we can perform simple API calls using `fetch`, and we know how to organize
    our code to be reusable. In some areas, however, we could do better if our application
    required it. Before we dive in Redux Saga, I want to introduce two new patterns:
    iterator and generator.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Processing each of the items in a collection is a very common operation. JavaScript
    provides a number of ways of iterating over a collection, from simple for loops
    to map and filter. Iterators and Generators bring the concept of iteration directly
    into the core language and provide a mechanism for customizing the behavior of for...ofloops."'
  prefs: []
  type: TYPE_NORMAL
- en: '- JavaScript guide on MDN web docs at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators).
    [](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the iterator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterator, as the name suggests, lets you iterate over a collection. To be
    able to do so, the collection needs to implement an iterable interface. In JavaScript,
    there are no interfaces, hence the iterator simply implements a single function.
  prefs: []
  type: TYPE_NORMAL
- en: '"An object is an iterator when it knows how to access items from a collection
    one at a time, while keeping track of its current position within that sequence.
    In JavaScript an iterator is an object that provides a next method which returns
    the next item in the sequence. This method returns an object with two properties: done and value."'
  prefs: []
  type: TYPE_NORMAL
- en: '- JavaScript guide on MDN web docs'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of such a function from MDN web docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The generator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generators are similar to iterators; here, however, you iterate over carefully
    designed breakpoints within a function. A generator returns an iterator. The returned
    iterator iterates over the mentioned breakpoints and, each time, returns some
    value from the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To signal that the function is a generator, we use a special `*****` sign,
    for instance, `function* idGenerator()`. Please find an example generator function
    in the following snippet. Generators use the `yield` keyword to return the current
    iteration step value. The iterator will resume in the next line if its `next()`
    function is invoked, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `generator` function. The `Generator` function expects one
    argument. Based on the argument provided, the generator knows when to stop generating
    new numbers. After the function, we create an example number iterator and iterate
    over its values.
  prefs: []
  type: TYPE_NORMAL
- en: Redux Saga
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux Saga rely heavily on the generator pattern. Thanks to this approach, we
    can decouple side effects entirely into sagas that act as if they were a separate
    thread. It is convenient and provides a few advantages to Thunk functions in the
    long run. Some of those rely on composability, with sagas being easy to test and
    giving cleaner flows to execute asynchronous code. All of these may sound unclear
    right now, so let's dive in to get a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book does not touch much on React, Redux, and React Native testing. This
    topic would lengthen this book significantly and, I believe, deserves a  separate
    book. However, I will stress how important it is to test your code. This information
    box is to remind you about testing in Redux Sagas. In different places on the
    internet (GitHub, forums, Stack Overflow) I have seen this mentioned over and
    over again: sagas are much easier to test than Thunks. Check this on your own—you
    will not regret it.'
  prefs: []
  type: TYPE_NORMAL
- en: First, do the beginner steps of installing the library and applying the middleware.
    These steps can be found in the official Redux Saga README file, available at
    [https://redux-saga.js.org/](https://redux-saga.js.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the first saga and add it to our `rootSaga.` Do you remember
    the case with fetching tasks? They could be requested from many places (many decoupled
    widgets or features). The approach of saga is similar to our previous solutions,
    so let''s see how it can be implemented in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `fetchTasks` saga is really simple: first, it fetches tasks, then checks
    if an error happened, and either dispatches an error event or a successful event
    with the fetched data attached.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we trigger the `fetchTasks` saga? To convince you why sagas are powerful,
    let''s even push it further. Let''s say our code base is decoupled and a few features
    will request tasks at almost the same time. How do we prevent multiple fetch task
    jobs being triggered? Redux Saga library has a ready-made solution for this: the `throttle` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '"throttle(ms, pattern, saga, ...args) Spawns a saga on an action dispatched
    to the Store that matches pattern. After spawning a task it''s still accepting
    incoming actions into the underlaying buffer, keeping at most 1 (the most recent
    one), but in the same time holding up with spawning new task for ms milliseconds
    (hence its name - throttle). Purpose of this is to ignore incoming actions for
    a given period of time while processing a task."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Official Redux Saga documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux-saga.js.org/docs/api/](https://redux-saga.js.org/docs/api/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our use case will be very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchTasks` function will be executed on the `TASK_FETCH_START` event.
    For two seconds, the same event will not cause another `fetchTasks` function execution.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. One of the last few things is to add the preceding saga to `rootSaga`.
    This is not a very interesting part but, if you are curious, I recommend you check
    the full example in the code repository, available at [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
  prefs: []
  type: TYPE_NORMAL
- en: Redux Saga benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more complex applications with well defined routines, Redux Saga outshines
    Redux Thunk. Once you run into a need to cancel, rerun, or reply to part of the
    flow, it is not immediately obvious how these can be done using Thunks or plain
    Redux. With composable sagas and well-maintained iterators, you can do it with
    ease. Even the official documentation provides recipes for such problems. (See
    the *Further reading* section at the end of this chapter for reference.)
  prefs: []
  type: TYPE_NORMAL
- en: The dark side of such a powerful library is its problematic usage in brownfield
    applications. Such applications, with features possibly written in a promise-based
    or Thunk fashion, may require a significant refactor in order to be used with
    sagas with the ease found in greenfield apps. For instance, it is not so easy
    to call a saga from the Thunk function, nor you can wait on the dispatched function
    as you would on the promise within sagas. There are probably good hacks to connect
    both worlds, but is it really worth it?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused heavily on networking patterns and the side effects
    that come along with them. We went through simple patterns and then used the available
    tools on the market. You have learned about the Thunk pattern, along with iterator
    and generator patterns. All three of these patterns will be useful in your future
    programming career, whether it is in React Native or not.
  prefs: []
  type: TYPE_NORMAL
- en: As for the React ecosystem, you have learned the basics of the Redux Thunk and
    Redux Saga libraries. Both of them solve some of the challenges that come with
    large scale applications. Use them wisely and bear in mind all of the warnings
    I have placed within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to display data, style it, and fetch it, we are ready to
    learn some application building patterns. Namely, in the next chapter, you will
    learn navigational patterns. In React Native, there are plenty of solutions to
    these problems and I'm more than happy to teach you how to choose the one that
    matches your project's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing Tests—Redux Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/recipes/writing-tests](https://redux.js.org/recipes/writing-tests).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing Undo History—Redux Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/recipes/implementing-undo-history](https://redux.js.org/recipes/implementing-undo-history).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server rendering—Redux Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/recipes/server-rendering](https://redux.js.org/recipes/server-rendering).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normalizing state—Redux Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape).'
  prefs: []
  type: TYPE_NORMAL
- en: This is important in the context of networking patterns. Some of your data that
    is fetched from backend systems will need to be normalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Async actions—Redux Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux.js.org/advanced/async-actions](https://redux.js.org/advanced/async-actions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux Saga recipes—Redux Saga Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://redux-saga.js.org/docs/recipes/](https://redux-saga.js.org/docs/recipes/).'
  prefs: []
  type: TYPE_NORMAL
- en: This resource is particularly valuable for its recipes for throttling, debouncing,
    and undo using sagas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux Saga channels – Redux Saga Official Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Until now we''ve used the take and put effects to communicate with the Redux
    Store. Channels generalize those Effects to communicate with external event sources
    or between Sagas themselves. They can also be used to queue specific actions from
    the Store."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Redux Saga Official Documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux-saga.js.org/docs/advanced/Channels.html](https://redux-saga.js.org/docs/advanced/Channels.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Idiomatic redux thoughts on Thunks, sagas, abstraction, and reusability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/](https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resources library: React Redux Links/Redux Side effects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Saga on Sagas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"The term *saga* is commonly used in discussions of CQRS to refer to a piece
    of code that coordinates and routes messages between bounded contexts and aggregates.
    However, [...] we prefer to use the term *process manager* to refer to this type
    of code artifact."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Saga on Sagas - Microsoft Docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10)](https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591569(v=pandp.10)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL—another approach to side effects. GraphQL is a query language for your
    API, both on the frontend and backend side. Find out more here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://graphql.org/learn/](https://graphql.org/learn/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux Observable—a Thunk and sagas competitor. Introduces Reactive Programming
    patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/redux-observable/redux-observable](https://github.com/redux-observable/redux-observable).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also check out RxJS, a reactive programming library for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/reactivex/rxjs](https://github.com/reactivex/rxjs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representational State Transfer :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'HATEOAS (a component of the REST architecture):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/HATEOAS](https://en.wikipedia.org/wiki/HATEOAS).'
  prefs: []
  type: TYPE_NORMAL
