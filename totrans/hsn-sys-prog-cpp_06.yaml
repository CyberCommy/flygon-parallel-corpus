- en: Learning to Program Console Input/Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Console IO is essential for any program. It can be used to get user input, provide
    an output, and support debugging and diagnostics. A common cause of program instability
    also generally originates from poorly written IO, which is only exacerbated by
    the overuse of standard C `printf()`/`scanf()` IO functions. In this chapter,
    we will discuss the pros and cons of using C++ IO, commonly referred to as stream-based
    IO, compared to the standard C-style alternatives. In addition, we will provide
    a high-level introduction to C++ manipulators and how they can be used in place
    of standard C-style format strings. We will conclude this chapter with a set of
    examples designed to guide the reader through the use of both `std::cout` and
    `std::cin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter has the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about stream-based IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined type-manipulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of echoes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Serial Echo server example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples and code
    snippets, please see the following GitHub link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about stream-based IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about the basics and some advantages
    and disadvantages of stream-based IO.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike the C-style `printf()` and `scanf()` functions, C++ IO uses streams
    (`std::ostream` for output and `std::istream` for input) that leverage the `<<`
    and `>>` operators. For example, the following code outputs `Hello World` to `stdout`
    using a non-member `<<` overload of `basic_ostream` for `const char *` strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `std::cout` and `std::wcout` objects, which are instantiations
    of `std::ostream`, output data to the standard C `stdout`, with the only difference
    being that `std::wcout` provides support for Unicode, while `std::cout` provides
    support for ASCII. In addition to several non-member overloads, C++ provides the
    following arithmetic-style member overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These overloads can be used to stream numbers of various types to `stdout`
    or `stderr`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `stdin` by default, input is performed via `std::cin` and `std::wcin`.
    Unlike `std::cout`, `std::cin` uses the `>>` stream operator, instead of the `<<`
    stream operator. The following accepts input from `stdin` and outputs the result
    to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Advantages and disadvantages of C++ stream-based IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many pros and cons to using C++ for IO instead of standard C functions.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of  C++ stream-based IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ streams are generally preferred over the standard C functions that leverage
    format specifiers, because C++ streams are:'
  prefs: []
  type: TYPE_NORMAL
- en: Capable of handling user-defined types providing cleaner, type-safe IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safer, preventing a larger number of accidental-buffer overflow vulnerabilities
    as not all format-specifier bugs can be detected by the compiler or prevented
    using the `_s` C function variants added to C11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capable of providing implicit memory management, and do not require variadic
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, format specifiers are discouraged by the C++ Core Guidelines
    including functions such as `printf()`, `scanf()`, and others. Although there
    are many advantages to using C++ streams, there are some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of C++ stream-based IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two most common complaints about C++ streams are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard C functions (specifically `printf()`) often outperform C++ streams
    (an issue that largely depends on your operating system and C++ implementation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format specifiers are often more flexible than `#include <iomanip>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although these are typically valid complaints, there are ways to address these
    issues without having to sacrifice the advantages of C++ streams, which we will
    explain in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with user-defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ streams provide the ability to overload the `<<` and `>>` operators for
    user-defined types. This provides the ability to create custom, type-safe IO for
    any data type, including system-level data types, structures, and even more complicated
    types such as classes. For example, the following provides an overload for the
    `<<` stream operator to print an error code provided by a POSIX-style function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an empty class that provides us with a custom type
    and overload the `<<` operator for this custom type. We then use `strerror()`
    to output the error string for `errno` to the provided output stream. Although
    this could be achieved by directly outputting the result of `strerror()` to the
    stream, it demonstrates how user-defined types can be created and used with streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to more complicated types, user-defined types can also be leveraged
    by input streams. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a structure that stores two integers. We then overload
    both the `<<` and `>>` operators for this user-defined type, exercise these overloads
    by reading data into an instance of our type, and then output the results. With
    our overloads, we have instructed both `std::cin` and `std::cout` on how to handle
    the input and output of our user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: Safety and implicit memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although vulnerabilities are still possible with C++ streams, they are less
    likely compared to their standard C counterparts. The classic example of a buffer
    overflow using the standard C `scanf()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer being input by the user is larger than the space allocated for this
    buffer, resulting in a buffer overflow situation. Increasing the size of `buf`
    will not solve the problem in this example as the user can always input a string
    larger than the provided buffer. This issue can be addressed by specifying a length
    limit on `scanf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provide the size of `buf` to the `scanf()` function, preventing the
    buffer overflow. The problem with this approach is the size of `buf` is declared
    twice. If only one of these is changed, a buffer overflow could be reintroduced.
    C-style macros could be used to address this issue, but the decoupling of the
    buffer and its size is still present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are other ways to solve this using C, one way to address the
    preceding issues with C++ is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using a `*` char, we create a user-defined type that encapsulates
    a `*` char and its length. The total size of the buffer is coupled with the buffer
    itself, preventing accidental buffer overflows. Still, if memory-allocation is
    allowed (which is not always the case when programming systems, we can do better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `std::string` to store the input from `std::cin`. The
    difference here is that `std::string` dynamically allocates memory as needed to
    store the input, preventing a possible buffer overflow. If more memory is needed,
    more memory is allocated or `std::bad_alloc` is thrown and the program aborts.
    User-defined types with C++ streams provide safer mechanisms for handling IO.
  prefs: []
  type: TYPE_NORMAL
- en: Common debugging patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming systems, one of the main uses of console output is debugging.
    C++ streams provide two different global objects—`std::cout` and `std::cerr`.
    The first option, `std::cout`, is typically buffered, sent to `stdout`, and only
    flushed when either `std::flush` or `std::endl` is sent to the stream. The second
    option, `std::cerr`, provides the same functionality as `std::cout`, but is sent
    to `stderr` instead of `stdout`, and is flushed on every call to the global object.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, error logic is usually sent to `stderr` using `std::cerr` to
    ensure all error console output is received in the event of a catastrophic issue.
    Likewise, general output, including debug logic is sent to `stdout` using `std::cout`
    to take advantage of buffering to speed up console output, and `'\n'` is used
    to send a newline instead of `std::endl` unless an explicit flush is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a typical pattern in C for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If debugging is enabled, which usually means that `NDEBUG` is defined, the
    `DEBUG` macro can be used to send debug statements to the console. `NDEBUG` is
    used because this is the macro that is defined when most compilers are set to
    Release mode, disabling `assert()` in standard C. Another common debugging pattern
    is to provide the debug macro with a debug level that allows the developer to
    dial in how verbose the program is while debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this logic is the overuse of macros to achieve debugging,
    a pattern that is discouraged by the C++ Core Guidelines ([https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-macros2](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-macros2)).
    A simple approach to debugging with C++17 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with C++17, some macro logic is needed to handle the `NDEBUG` macro that
    is provided by the compiler when debugging is enabled. In this example, the `NDEBUG`
    macro is converted into `constexpr`, which is then used in the source code to
    handle debugging. A debug level can also be implemented using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since changing the debug level is a compile-time feature in this example, it
    would be passed to the compiler using `-DDEBUG_LEVEL=xxx`, and as such, still
    requires macro logic to convert the C macro into a C++ `constexpr`. As can be
    seen in this example, the C++ implementation is far more complicated than a simple
    `DEBUG` macro that leverages `fprintf()` and friends. To overcome this complexity,
    we will leverage encapsulation, without sacrificing compile-time optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the debug logic is encapsulated into a `constexpr` function
    that takes a Lambda. The debug level is defined using a template parameter to
    maintain constancy. Unlike the typical standard C debugging pattern, this implementation
    will accept any debug logic that can fit into a `void(*func)()` function or lambda
    and, like the standard C version, will be compiled out and removed when the compiler
    is set to Release mode (that is, when `NDEBUG` is defined, and typically optimizations
    are enabled). To show this, GCC 7.3 outputs the following when Release mode is
    enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'GCC 7.3 outputs the following when `#undef NDEBUG` is added to the source code
    (ensuring the only difference is the debug logic is disabled, but the compile
    flags remain the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The extra 288 bytes come from the debug logic that is completely removed by
    the compiler thanks to the constancy observed by the additions of `constexpr`
    to C++17, providing a cleaner approach to debugging, without the need for the
    extensive use of macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common debugging pattern is to include both the current line number
    and the filename into debugging statements for additional context. The `__LINE__` and
    `__FILE__` macros are used to provide this information. Sadly, without the Source
    Location TS ([http://en.cppreference.com/w/cpp/experimental/source_location](http://en.cppreference.com/w/cpp/experimental/source_location)),
    which was not included in C++17, there is no way to provide this information without
    these macros and the inclusion of something like the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `DEBUG` macro automatically inserts the file name and
    line number into the standard C-style `fprintf()` function. This works because
    wherever the compiler sees the `DEBUG` macro, it inserts `fprintf(stdout, "%s
    [%d]: " fmt, __FILE__, __LINE__, args);`, and then must evaluate the line and
    file macros, resulting in the expected output. One example of how to convert this
    same pattern to our existing C++ example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `std::cout` in our debug lambdas, we add a console macro that
    uses `std::cout`, but also adds the file name and line number to the debug statement
    to provide the same functionality as the standard C version. Unlike the standard
    C version, an additional C macro function is not needed as the console macro will
    properly provide the file name and line number where used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to complete our C++17 debugging patterns, we add a debug, warning,
    and fatal version of the preceding example with color, and an overload for the
    `fatal` function that defaults to exiting with `-1` on error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we leverage the same standard C macros as used in the preceding code
    snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These macros convert standard C-style macros, which are needed for command-line
    compatibility, to C++-style constant expressions. Next, we create a template function
    called `debug`, capable of accepting a lambda function. This `debug` function
    first outputs a green colored `debug` to `stdout`, and then executes the lambda
    function, if (and only if) debugging is enabled and the debugging level matches
    that which was provided to the `debug` function itself. If debugging is not enabled,
    the `debug` function is compiled without impacting the size of the program, or
    its performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This same `debug` function is repeated to provide a warning, and a fatal version
    of this function, with the only difference being color (which is platform-specific,
    and in this case is intended for UNIX operating systems), and the `fatal` function
    exits the program after the lambda function is executed with either a user-defined
    error code or `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, these debugging patterns are exercised in a `main()` function to demonstrate
    how they can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Performance of C++ streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common complaint about C++ streams is performance, a problem that has largely
    been mitigated over the years. To ensure C++ streams perform at their best, there
    are some optimizations that can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable std::ios::sync_with_stdio:** C++ streams by default synchronize themselves
    with standard C functions, such as `printf()` and others. If these functions are
    not being used, this synchronization feature should be disabled as it will result
    in a noticeable improvement in performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid flushing**: Where possible, avoid flushing C++ streams and let `libc++`
    and the OS handle flushing for you. This includes not using `std::flush`, and
    using `''\n''` instead of `std::endl`, which flushes after it outputs a newline.
    When flushing is avoided, all output is buffered for you, reducing the number
    of calls to the OS to deliver the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use std::cout and std::clog instead of std::cerr**: For the same reason,
    `std::cerr` will flush on destruction, increasing the number of times the OS is
    delivered output. When possible, `std::cout` should be used, with `std::cerr`
    only being used for fatal errors followed by control-flow changes, such as exits,
    exceptions, assertions, and possible crashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's impossible to provide a general answer to the question, *Which is faster,*
    `printf()` *or* `std::cout`*?*But in practice, if the preceding optimizations
    are used, `std::cout` can often outperform standard C `printf()`, but this is
    highly dependent on your environment and use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the preceding example, one way to avoid unwanted flushing to
    increase performance is to use `std::stringstream` instead of `std::cout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `std::stringstream`, all output is directed to your controlled buffer
    until you are ready to send the output to the OS via `std::cout` and manual flushing.
    This can also be used to buffer output to `std::cerr`, reducing the total number
    of flushes. Another way to avoid flushing is to use `std::clog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`std::clog` operates like `std::cout`, but instead of sending output to `stdout`,
    `std::clog` sends output to `stderr`.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about manipulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ streams have several different manipulators that may be used to control
    both input and output, some of which have already been discussed. The most common
    manipulator is `std::endl`, which outputs a newline and then flushes the output
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write this same logic is to use the `std::flush` manipulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Both are the same, although `''\n''` should always be used unless a flush is
    explicitly needed. For example, if multiple lines are needed, the following is
    preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to the preceding code, the following is not preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the trailing flush is not needed, as `::exit()` flushes
    `stdout` on exit for you, which is called when main completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common manipulator that is set at the beginning of any program is `std::boolalpha`,
    which causes Booleans to be outputted as `true` or `false` instead of `1` or `0`
    (with `std::noboolalpha` providing the inverse, which is also the default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common set of manipulators is numeric base manipulators—`std::hex`,
    `std::dec`, and `std::oct`. These manipulators are similar to `%d`, `%x`, and
    `%o` used by standard C-format specifiers (for example, those used by `printf()`).
    Unlike the standard C versions, these manipulators are global, and thus should
    be used with caution, especially in libraries. To use these manipulators, simply
    add them to the stream prior to adding a number for the desired base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first number, `42`, is printed as `42` as no numeric base-manipulators have
    been used yet. The second number is printed as `2a` as the `std::hex` manipulator
    was used resulting in `2a` as that is the hex value for `42`. The third number
    that is printed is also `2a` as numeric base manipulators are global and thus,
    even though `std::cout` is called a second time, the stream is still told to use
    hex values instead of decimal. This pattern continues for both `std::dec` (for
    example, decimal numbers) and `std::oct` (for example, octal numbers), resulting
    in `42`, `2a`, `2a`, `42`, `42`, and finally `52`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use the uppercase version of `std::hex` instead of the
    default, lowercase version seen in the previous example. To accomplish this, use `std::uppercase` and `std::nouppercase` (`std::uppercase` shows
    alphanumeric characters in uppercase while `std::nouppercase` does not, which
    is the default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, instead of `42` being outputted as `2a`, it was outputted as
    `2A`, with the alphanumeric characters being uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, especially with respect to programming systems, hexadecimal and
    octal numbers are printed with their base identifiers (for example, `0x` and `0`).
    To accomplish this, use the `std::showbase` and `std::noshowbase` manipulators
    (`std::showbase` shows the base while `std::noshowbase` does not, which is the
    default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen from this example, `std::hex` now outputs `0x2a` instead of `2a`, and
    `std::oct` outputs `052` instead of `52`, while `std::dec` continues to output
    `42` as expected (since decimal numbers do not have base identifiers). Unlike
    numbers, pointers always output in hexadecimal, lowercase, and with their base
    being shown, and `std::uppercase`, `std::noshowbase`, `std::dec`, and `std::oct`
    do not affect the output. One solution to this problem is to cast the pointer
    to a number, and then the preceding manipulators may be used as shown in the following
    example, but this type of logic is discouraged by the C++ Core Guidelines since `reinterpret_cast`
    is required, which is frowned upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One issue with outputting pointers is that their total length (that is, the
    total number of characters) changes from pointer to pointer. This can often be
    distracting when outputting several pointers at the same time, as their base modifiers
    are likely not to match up. To overcome this, `std::setw` and `std::setfill` may
    be used. `std::setw` sets the total width (that is, the total number of characters)
    in the next output. If the next output is not at least the size of the value passed
    to `std::setw`, the stream will automatically add spaces to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the width is set to `18`. Since the next addition to the stream
    is two characters (from the number `42`), `16` total spaces are added prior to
    adding `42` to the stream. To change the characters that are added to the stream
    by `std::setw`, use `std::setfill`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen, instead of spaces being added to the stream (which is the default),
    `''0''` characters are added to the stream. The direction of the characters being
    added to the stream can be controlled using `std::left`, `std::right`, and `std::internal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`std::left` first outputs to the stream, and then fills in the stream with
    the remaining characters, while `std::right` fills in the stream with unused characters,
    and then outputs to the stream. `std::internal` is specific to text that uses
    base identifiers such as `std::hex` and `std::oct` with `std::showbase` or pointers
    that automatically show the base identifier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, especially in libraries, it can be useful to set some manipulators,
    and then restore the stream to its original state. For example, if you''re writing
    a library and you want to output a number in `hex`, you would need to use the
    `std::hex` manipulator, but doing so would cause all of the numbers your user
    outputs from that point on to also be outputted in `hex`. The problem is, you
    cannot simply use `std::dec` to set the stream back to decimal because the user
    might actually be using `std::hex` in the first place. One way to deal with this
    issue is to use the `std::cout.flags()` function, which allows you to both get
    and set the stream''s internal flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, all of the manipulators that have been discussed, as well as some
    others, can be enabled/disabled using the `std::cout.flags()` function, and the
    manipulators discussed are simply wrappers around this function to reduce verbosity.
    Although this function can be used to configure the manipulators (which should
    be avoided), the `std::cout.flags()` function is a convenient way to restore the
    manipulators after the stream has been changed. It should also be noted that the
    preceding methods work for all of the streams, not just `std::cout`. One way to
    simplify restoring the manipulators is to use a little functional programming,
    and wrap a user function with the save/restore logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we wrap the use of `std::cout` in `cout_transation`. This wrapper
    stores the current state of the manipulators, calls the user-provided function
    (which changes the manipulators), and then restores the manipulators prior to
    completing. As a result, the manipulators are unaffected after the completion
    of the transaction, which means the second `std::cout` in this example outputs
    `42` instead of `0x2a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to simplify the use of manipulators, it can sometimes be useful to
    create your own user-defined manipulators that can encapsulate your custom logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from this example, by simply using `usr::hex` instead of `std::hex`,
    `42` is outputted using `std::hex`, `std::showbase`, `std::internal`, `std::setfill('0')`,
    and `std::setw(18)`, reducing verbosity and simplifying multiple uses of this
    same logic.
  prefs: []
  type: TYPE_NORMAL
- en: Recreating the echo program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this hands-on example, we will be recreating the popular echo program found
    on almost all `POSIX` systems. The echo program takes all of the input provided
    to the program and echoes it back to `stdout`. This program is very simple, with
    the following program options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-n`: Prevents echo from outputting a newline on exit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help`: Prints the Help menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--version`: Prints some version information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two other options, `-e` and `-E`; we have omitted them here to keep
    things simple, but, if desired, would serve as a unique exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: To see the full sources for this example, please see the following: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function presented here is a useful pattern to add to all programs
    and deviates slightly from the original echo program as exceptions (which are
    highly unlikely in this example) could generate error messages not seen in the
    original echo program; however, it is still useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this logic is to catch any exceptions prior to the program exiting
    and outputting the exception description to `stderr` before exiting with a failure
    status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code catches all `std::exceptions` and outputs a catch exception's
    description (that is, `e.what()`) to `stderr`. Note that `std::cerr` is used here (instead
    of `std::clog`) just in case the use of exceptions generates instability, ensuring
    a flush occurs. When using error-handling logic, it's always better to be on the
    safe side and ensure all debugging output is delivered with performance being
    a secondary concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code catches all unknown exceptions, which in this program should
    almost certainly never happen, and was added purely for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `try` block attempts to execute the `protected_main()` function, and if
    it fails with an exception, executes the `catch` blocks as described previously;
    otherwise, it returns from the `main` function, ultimately exiting the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the `protected_main()` function is to parse the arguments provided
    to the program, and handle each argument as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is used to control whether a newline is added to `stdout` on exit, just
    like the original echo program, and is controlled by the `-n` program argument.
    Here is the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code converts the standard C `argv` and `argc` arguments into
    a C++ GSL span, allowing us to safely process the program arguments in a C++-Core-Guideline-compliant
    fashion. The span is nothing more than a list (specifically, it is very similar
    to `std::array`), with the bounds of this list being checked each time we access
    the list (unlike `std::array`). If our code attempts to access an argument that
    doesn't exist, an exception will be thrown, and the program will safely exit with
    an error code, telling us via `stderr` that we attempted to access an element
    in the list that does not exist (via the `try`/`catch` logic in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It loops through each argument in the list. Normally, we would loop through
    each element in a list using the ranged `for` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: But this syntax cannot be used because the first argument in the argument list
    is always the program name, and in our case should be ignored. For this reason,
    we start from `1` (instead of `0`) as can be seen previously, and then we loop
    through the remaining elements in the list. The second line in this snippet creates
    `cstring_span{}` from each program argument in the list. `cstring_span{}` is nothing
    more than a standard C-style string wrapped in a GSL span to protect any accesses
    to the string to make C-style string access C++-Core-Guideline-compliant. This
    wrapper will later be used to compare the string to look for our program options,
    such as `-n`, `--help`, and `--version`, in a safe and compliant way. The `ensure_z()`
    function ensures that the string is complete, preventing possible unwanted corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to compare each argument to the list of arguments we plan
    to support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using `cstring_span{}` instead of a standard C-style string, we
    can directly compare the argument to the `"-n"` literal string safely without
    having to use an unsafe function such as `strcmp()`, or direct character comparisons,
    which is what the original echo implementation does (and since we only support
    one single character option, performance is the same). If the argument is `-n`,
    we instruct our implementation that no newline should be added to `stdout` when
    the program exits by setting `endl` to `false`, and then we continue looping through
    the arguments until they are all processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the next two blocks of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: They check whether the arguments are `--help` or `--version`. If either of these
    is provided by the user, a special `handle_help()` or `handle_version()` function
    is executed. It should be noted that `handle_xxx()` functions exit the program
    when they are done, so no further logic is needed and it should be assumed that
    these functions never return (as the program exits).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, all of the optional arguments have been processed. All other
    arguments should be outputted to `stdout`, just like the original echo program.
    The problem is that the user could provide more than one argument that they wish
    to be outputted to `stdout`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the user has provided two arguments—`Hello` and `World`. The
    expected output is `Hello World` (with a space), not `HelloWorld` (without a space),
    and some additional logic is needed to ensure that a space is outputted to `stdout`
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This outputs a space to `stdout` after the first argument has already been outputted,
    but right before the next argument is about to be outputted (and all remaining
    arguments). It does this because `num` starts as `0` (and `0` is equal to `0`,
    not greater than `0`, and thus the space is not outputted on the first argument),
    and then `num` is incremented. When the next argument is processed, `num` is `1`
    (or larger) which is greater than `0`, and thus the space is added to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the argument is added to `stdout` by providing `std::cout` with the
    argument''s data, which is nothing more than the unsafe, standard C version of
    the argument that `std::cout` can safely handle for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The last block in the `protected_main()` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `endl` is `true`, and thus a newline is added to `stdout` before
    the program exits. If, however, the user had provided `-n`, then `endl` would
    have been set to `false` by  the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the program would exit without adding the newline to
    `stdout`. If `--help` was provided by the user, the `handle_help()` function would
    be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This function outputs the Help menu to `stdout` using `std::cout`, and then
    exits the program successfully. The `handle_version()` function does the same
    thing if `--version` is provided by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile this example, we use CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the header portion of this `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This sets up CMake to require version 3.6 (since we use `GIT_SHALLOW`), gives
    the project a name, includes the `ExternalProject` module (which provided `ExternalProject_Add`),
    and sets the C++ standard to C++17.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It uses CMake's `ExternalProject_Add` to download and install the GSL from its
    Git repository at GitHub using a depth of 1 (that is, `GIT_SHALLOW 1`) to speed
    up the download process. The arguments provided to `ExternalProject_Add` (that
    is, `GSL_CMAKE_ARGS`) tell the GSL's build system to turn off unit testing (which
    our project does not need) and to install the resulting headers into our build
    directory (which places them in an `include` folder in our `build` directory).
    The remaining arguments provided to `ExternalProject_Add` are optional, simply
    serve to clean up the output of `ExternalProject_Add`, and can be ignored, or
    even removed if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the last block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It tells the build system where to find our newly-installed GSL headers, and
    then creates an executable called `example1` from the `example1.cpp` source code.
    To compile and run this example, simply execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the Serial Echo server example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this hands-on example, we will be creating a serial-based echo server. An
    echo server (regardless of the type) takes an input and echoes the input to the
    program's output (similar to the first example, but in this case using a server-style
    application over a serial port).
  prefs: []
  type: TYPE_NORMAL
- en: To see the full sources for this example, please see the following: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function is the same as the first example. Its sole purpose is to
    catch any exceptions that might fire, output the exception''s description to `stderr`,
    and safely exit the program with a failure status. For more information on how
    this works, please see the first example. The `protected_main()` function''s purpose
    is to open the serial port, read in an input, and echo the input to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It does the same thing the first example does, which wraps the `argc` and `argv`
    argument parameters in a GSL span, providing a safe mechanism for parsing the
    arguments provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It checks to make sure that one, and only one, argument was provided by the
    user. The reason the total number of arguments (`argc`) is `2` and not `1` is
    because the first argument is always the name of the program and in this case
    should be ignored, and thus `1` argument provided by the user is actually equal
    to an `argc` of `2`. Furthermore, we use `std::clog` instead of `std::cerr` as
    instability is unlikely in this case, and a flush will be performed for us by
    `libc` when `::exit()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'It opens the serial port and returns input and output streams that can be used
    by `std::cout` and `std::cin` to use the serial port instead of `stdout` and `stdin`.
    To do this, the `open_streams()` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This function takes in a `cstring_span{}` that stores the serial port to open
    (for example, `/dev/ttyS0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we move on the following streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code opens an input and output stream tied to this serial port.
    Both `ifstream{}` and `ofstream{}` are file streams, which are outside the scope
    of this chapter (they will be explained in later chapters), but in short, these
    open the serial device and provide a stream object that `std::cout` and `std::cin`
    can use as if they were using `stdout` and `stdin` (which are also technically
    file streams on a `POSIX` system).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It verifies that both the input stream and the output steam were successfully
    opened, which is important because this type of error could happen (for example,
    an invalid serial port is provided, or the user doesn't have access to the serial
    port). If an error occurs, the user is informed via a message outputted to `std::clog`,
    and the program exits with a failure status.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the input stream and output stream are successfully opened, they
    are returned in a pair, which is read by the `protected_main()` function using
    a structured binding syntax (a feature added in C++17).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next block in the `protected_main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It redirects `std::cout` and `std::cin` to the serial port, and then echos
    input into the program to the program''s output, in effect echoing the serial
    port provided by the user. To perform the redirection, the `redirect_output()`
    function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `redirect_output()` function takes an input and output stream as a parameter,
    as well as a function to execute and the final parameter. The first thing `redirect_function()`
    does is save the current buffers for `std::cin` and `std::cout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `std::cin` and `std::cout` are redirected to the provided input and output
    streams. Once this is done, the function that was provided is executed. Any use
    of `std::cin` and `std::cout` will be redirected to the provided serial port instead
    of the standard `stdout` and `stdin`. When the `f()` function is finished, `std::cin`
    and `std::cout` are restored to their original buffers, redirecting them back
    to `stdout` and `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the program exits with success. To compile this example, we use CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This `CMakeLists.txt` is identical to the `CMakeLists.txt` in the first example
    (minus the user of `example2` instead of `example1`). For a complete explanation
    of how this works, please see the first example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile and use this example, two computers are needed, one that acts as
    the echo server and a second one that acts as the client, with both computers''
    serial ports connected to each other. On the echo server computer, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that your serial port device might be different. On the client computer,
    open two terminals. In the first terminal, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This code waits for the serial device to output data. In the second terminal,
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This sends data through the serial port to the echo server. When you press
    *Enter*, you will see the `example2` program that we wrote on the echo server
    close successfully, and the first terminal on the client will show `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to perform console-based IO, a common system-programming
    requirement, using C++17\. Unlike standard C-style IO functions, such as `printf()`
    and `scanf()`, C++ uses stream-based IO functions, such as `std::cout` and `std::cin`.
    There are many advantages and some disadvantages to using stream-based IO. For
    example, stream-based IO provides a type-safe mechanism for performing IO, while
    raw, POSIX-style `write()` functions can often outperform stream-based IO due
    to a lack of calls to `malloc()` and `free()`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we looked at stream-based manipulators, which provide stream-based
    IO with a similar feature set to standard C-style format strings, but without
    the common instability issues found with the C equivalents. In addition to manipulating
    the format of numbers and Boolean values, we explored field properties, including
    width and justification.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished this chapter with two different examples. The first example
    showed how to implement the popular POSIX *echo* program in C++ rather than in
    C. The second created an *echo* server for the serial port that takes input from
    the serial port using `std::cin` and sends that input back over the serial port
    as an output using `std::cout`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will provide a comprehensive overview of the memory management
    facilities provided by C, C++, and POSIX including aligned memory and C++ smart
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does `std::cin` help to prevent buffer overflows compared to the standard
    C `scanf`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least one advantage from using C++ streams compared to the standard
    C-style `printf`/`scanf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least on disadvantage to using C++ streams compared to the standard
    C-style `printf`/`scanf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should `std::endl` be used instead of `\n`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `std::cerr` and `std::clog`, and when should
    `std::cerr` be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does one output extra characters between a base identifier and a hex value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does one output a number in octal and upper case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can standard C-style program arguments be safely parsed using C++ and the
    GSL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does one save/restore the read buffer for `std::cin`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
