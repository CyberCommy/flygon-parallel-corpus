- en: Kernel Synchronization and Locking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kernel address space is shared by all user-mode processes, which enables concurrent
    access to kernel services and data structures. For reliable functioning of the
    system, it is imperative that kernel services be implemented to be re-entrant.
    Kernel code paths accessing global data structures need to be synchronized to
    ensure consistency and validity of shared data. In this chapter, we will get into
    details of various resources at the disposal of kernel programmers for synchronization
    of kernel code paths and protection of shared data from concurrent access.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Atomic operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spinlocks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard mutexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait/wound mutex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphores
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence locks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic operations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A computation operation is considered to be **atomic** if it appears to the
    rest of the system to occur instantaneously. Atomicity guarantees indivisible
    and uninterruptible execution of the operation initiated. Most CPU instruction
    set architectures define instruction opcodes that can perform atomic read-modify-write
    operations on a memory location. These operations have a succeed-or-fail definition,
    that is, they either successfully change the state of the memory location or fail
    with no apparent effect. These operations are handy for manipulation of shared
    data atomically in a multi-threaded scenario. They also serve as foundational
    building blocks for implementation of exclusion locks, which are engaged to protect
    shared memory locations from concurrent access by parallel code paths.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel code uses atomic operations for various use cases, such as reference
    counters in shared data structures *(*which are used to track concurrent access
    to various kernel data structures), wait-notify flags, and for enabling exclusive
    ownership of data structures to a specific code path. To ensure portability of
    kernel services that directly deal with atomic operations, the kernel provides
    a rich library of architecture-neutral interface macros and inline functions that
    serve as abstractions to processor-dependent atomic instructions. Relevant CPU-specific
    atomic instructions under these neutral interfaces are implemented by the architecture
    branch of the kernel code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Atomic integer operations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic atomic operation interfaces include support for integer and bitwise
    operations. Integer operations are implemented to operate on special kernel-defined
    types called `atomic_t` (32-bit integer) and `atomic64_t` (64-bit integer). Definitions
    for these types can be found in the generic kernel header `<linux/types.h>`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation provides two groups of integer operations; one set applicable
    on 32 bit and the other group for 64 bit atomic variables. These interface operations
    are implemented as a set of macros and inline functions. Following is a summarized
    list of operations applicable on `atomic_t` type variables:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface macro/Inline function** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `ATOMIC_INIT(i)` | Macro to initialize an atomic counter |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `atomic_read(v)` | Read value of the atomic counter `v` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `atomic_set(v, i)` | Atomically set counter `v` to value specified in `i`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `atomic_add(int i, atomic_t *v)` | Atomically add `i` to counter `v` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| `atomic_sub(int i, atomic_t *v)` | Atomically subtract `i` from counter `v`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| `atomic_inc(atomic_t *v)` | Atomically increment counter `v` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| `atomic_dec(atomic_t *v)` | Atomically decrement counter `v` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: 'Following is a list of functions that perform relevant **read-modify-write**
    (**RMW**) operations and return the result (that is, they return the value that
    was written to the memory address after the modification):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Description** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| `bool atomic_sub_and_test(int i, atomic_t *v)` | Atomically subtracts `i`
    from `v` and returns `true` if the result is zero, or `false` otherwise |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| `bool atomic_dec_and_test(atomic_t *v)` | Atomically decrements `v` by 1
    and returns `true` if the result is 0, or `false` for all other cases |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| `bool atomic_inc_and_test(atomic_t *v)` | Atomically adds `i` to `v` and
    returns `true` if the result is 0, or `false` for all other cases |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `bool atomic_add_negative(int i, atomic_t *v)` | Atomically adds `i` to `v`
    and returns `true` if the result is negative, or `false` when result is greater
    than or equal to zero |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_add_return(int i, atomic_t *v)` | Atomically adds `i` to `v`
    and returns the result |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_sub_return(int i, atomic_t *v)` | Atomically subtracts `i` from
    `v` and returns the result |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_fetch_add(int i, atomic_t *v)` | Atomically adds `i` to `v` and
    return pre-addition value at `v` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_fetch_sub(int i, atomic_t *v)` | Atomically subtracts `i` from
    `v`, and return pre-subtract value at `v` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_cmpxchg(atomic_t *v, int old,` int new) | Reads the value at
    location `v`, and checks if it is equal to `old`*;* if `true`, swaps value at
    `v` with `*new*`, and always returns value read at `v` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `int atomic_xchg(atomic_t *v, int new)` | Swaps the old value stored at location
    `v` with `new`, and returns old value `v` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: For all of these operations, 64-bit variants exist for use with `atomic64_t`;
    these functions have the naming convention `atomic64_*()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Atomic bitwise operations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kernel-provided generic atomic operation interfaces also include bitwise operations.
    Unlike integer operations, which are implemented to operate on the `atomic(64)_t`
    type, these bit operations can be applied on any memory location. The arguments
    to these operations are the position of the bit or bit number, and a pointer with
    a valid address. The bit range is 0-31 for 32-bit machines and 0-63 for 64-bit
    machines. Following is a summarized list of bitwise operations available:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation interface** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `set_bit(int nr, volatile unsigned long *addr)` | Atomically set the bit
    `nr` in location starting from `addr` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `clear_bit(int nr, volatile unsigned long *addr)` | Atomically clear the
    bit `nr` in location starting from `addr` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `change_bit(int nr, volatile unsigned long *addr)` | Atomically flip the
    bit `nr` in the location starting from `addr` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `int test_and_set_bit(int nr, volatile unsigned long *addr)` | Atomically
    set the bit `nr` in the location starting from `addr`, and return old value at
    the `nr^(th)` bit |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `int test_and_clear_bit(int nr, volatile unsigned long *addr)` | Atomically
    clear the bit `nr` in the location starting from `addr`, and return old value
    at the `nr``^(th)` bit |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `int test_and_change_bit(int nr, volatile unsigned long *addr)` | Atomically
    flip the bit `nr` in the location starting from `addr`, and return old value at
    the `nr^(th)` bit |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: For all the operations with a return type, the value returned is the old state
    of the bit that was read out of the memory address before the specified modification
    happened. Non-atomic versions of these operations also exist; they are efficient
    and useful for cases that might need bit manipulations, initiated from code statements
    in a mutually exclusive critical block. These are declared in the kernel header
    `<linux/bitops/non-atomic.h>`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Introducing exclusion locks
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware-specific atomic instructions can operate only on CPU word- and doubleword-size
    data; they cannot be directly applied on shared data structures of custom size.
    For most multi-threaded scenarios, often it can be observed that shared data is
    of custom sizes, for example, a structure with *n* elements of various types.
    Concurrent code paths accessing such data usually comprise a bunch of instructions
    that are programmed to access and manipulate shared data; such access operations
    must be executed *atomically* to prevent races. To ensure atomicity of such code
    blocks, mutual exclusion locks are used. All multi-threading environments provide
    implementation of exclusion locks that are based on exclusion protocols. These
    locking implementations are built on top of hardware-specific atomic instructions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel implements operation interfaces for standard exclusion mechanisms
    such as mutual and reader-writer exclusions. It also contains support for various
    other contemporary lightweight and lock-free synchronization mechanisms. Most
    kernel data structures and other shared data elements such as shared buffers and
    device registers are protected from concurrent access through appropriate exclusion-locking
    interfaces offered by the kernel. In this section we will explore available exclusions
    and their implementation details.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Spinlocks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spinlocks** are one of the simplest and lightweight mutual exclusion mechanisms
    widely implemented by most concurrent programming environments. A spinlock implementation
    defines a lock structure and operations that manipulate the lock structure. The
    lock structure primarily hosts an atomic lock counter among other elements, and
    operations interfaces include:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: An **initializer routine**, that initializes a spinlock instance to the default
    (unlock) state
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **lock routine**, that attempts to acquire spinlock by altering the state
    of the lock counter atomically
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **unlock routine**, that releases the spinlock by altering counter into unlock
    state
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a caller context attempts to acquire spinlock while it is locked (or held
    by another context), the lock function iteratively polls or spins for the lock
    until available, causing the caller context to hog the CPU until lock is acquired.
    It is due to this fact that this exclusion mechanism is aptly named spinlock.
    It is therefore advised to ensure that code within critical sections is atomic
    or non-blocking, so that lock can be held for a short, deterministic duration,
    as it is apparent that holding a spinlock for a long duration could prove disastrous.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, spinlocks are built around processor-specific atomic operations;
    the architecture branch of the kernel implements core spinlock operations (assembly
    programmed). The kernel wraps the architecture-specific implementation through
    a generic platform-neutral interface that is directly usable by kernel service;
    this enables portability of the service code which engages spinlocks for protection
    of shared resources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic spinlock interfaces can be found in the kernel header `<linux/spinlock.h>`
    while architecture-specific definitions are part of `<asm/spinlock.h>`. The generic
    interface provides a bunch of `lock()` and `unlock()` operations, each implemented
    for a specific use case. We will discuss each of these interfaces in the sections
    to follow; for now, let''s begin our discussion with the standard and most basic
    variants of `lock()` and `unlock()` operations offered by the interface. The following
    code sample shows the usage of a basic spinlock interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s examine the implementation of these functions under the hood:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Kernel code implements two variants of spinlock operations; one suitable for
    SMP platforms and the other for uniprocessor platforms. Spinlock data structure
    and operations related to the architecture and type of build (SMP and UP) are
    defined in various headers of the kernel source tree. Let''s familiarize ourselves
    with the role and importance of these headers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`<include/linux/spinlock.h>` contains generic spinlock/rwlock declarations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following headers are related to SMP platform builds:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`<asm/spinlock_types.h>` contains `arch_spinlock_t/arch_rwlock_t` and initializers'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock_types.h>` defines the generic type and initializers'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<asm/spinlock.h>` contains the `arch_spin_*()` and similar low-level operation
    implementations'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock_api_smp.h>` contains the prototypes for the `_spin_*()` APIs'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock.h>` builds the final `spin_*()` APIs'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following headers are related to uniprocessor (UP) platform builds:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`<linux/spinlock_type_up.h>` contains the generic, simplified UP spinlock type'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock_types.h>` defines the generic type and initializers'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock_up.h>` contains the `arch_spin_*()` and similar version of
    UP builds (which are NOPs on non-debug, non-preempt builds)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock_api_up.h>` builds the `_spin_*()` APIs'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<linux/spinlock.h>` builds the final `spin_*()` APIs'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generic kernel header `<linux/spinlock.h>` contains a conditional directive
    to decide on the appropriate (SMP or UP) API to pull.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `raw_spin_lock()` and `raw_spin_unlock()` macros dynamically expand to
    the appropriate version of spinlock operations based on the type of platform (SMP
    or UP) chosen in the build configuration. For SMP platforms, `raw_spin_lock()`
    expands to the `__raw_spin_lock()` operation implemented in the kernel source
    file `kernel/locking/spinlock.c`. Following is the locking operation code defined
    with a macro:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This routine is composed of nested loop constructs, an outer `for` loop construct,
    and an inner `while` loop that spins until the specified condition is satisfied.
    The first block of code in the outer loop attempts to acquire lock atomically
    by invoking the architecture-specific `##_trylock()` routine. Notice that this
    function is invoked with kernel preemption disabled on the local processor. If
    lock is acquired successfully, it breaks out of the loop construct and the call
    returns with preemption turned off. This ensures that the caller context holding
    the lock is not preemptable during execution of a critical section. This approach
    also ensures that no other context can contend for the same lock on the local
    CPU until the current owner releases it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: However, if it fails to acquire lock, preemption is enabled through the `preempt_enable()`
    call, and the caller context enters the inner loop. This loop is implemented through
    a conditional `while` that spins until lock is found to be available. Each iteration
    of the loop checks for lock, and when it detects that the lock is not available
    yet, it invokes an architecture-specific relax routine (which executes a CPU-specific
    nop instruction) before spinning again to check for lock. Recall that during this
    time preemption is enabled; this ensures that the caller context is preemptable
    and does not hog CPU for long duration, which can happen especially when lock
    is highly contended. It also allows the possibility of two or more threads scheduled
    on the same CPU to contend for the same lock, possibly by preempting each other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'When a spinning context detects that lock is available through `raw_spin_can_lock()`,
    it breaks out of the `while` loop, causing the caller to iterate back to the beginning
    of the outer loop (`for` loop) where it again attempts to grab lock through `##_trylock()`
    by disabling preemption:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike the SMP variant, spinlock implementation for UP platforms is quite simple;
    in fact, the lock routine just disables kernel preemption and puts the caller
    into a critical section. This works since there is no possibility of another context
    to contend for the lock with preemption suspended.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Alternate spinlock APIs
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard spinlock operations that we discussed so far are suitable for the protection
    of shared resources that are accessed only from the process context kernel path.
    However, there might be scenarios where a specific shared resource or data might
    be accessed from both the process and interrupt context code of a kernel service.
    For instance, think of a device driver service that might contain both process
    context and interrupt context routines, both programmed to access the shared driver
    buffer for execution of appropriate I/O operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s presume that a spinlock was engaged to protect the driver''s shared
    resource from concurrent access, and all routines of the driver service (both
    process and interrupt context) seeking access to the shared resource are programmed
    with appropriate critical sections using standard `spin_lock()` and `spin_unlock()`
    operations. This strategy would ensure protection of the shared resource by enforcing
    exclusion, but can cause a *hard lock condition* on the CPU at random times, due
    to *lock* contention by the interrupt path code on the same CPU where the *lock*
    was held by a process context path. To further understand this, let''s assume
    the following events occur in the same order:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Process context routine of the driver acquires *lock (*using the standard `spin_lock()`
    call).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the critical section is in execution, an interrupt occurs and is driven
    to the local CPU, causing the process context routine to preempt and give away
    the CPU for interrupt handlers.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interrupt context path of the driver (ISR) starts and tries to acquire *lock
    (*using the standard `spin_lock()` call*),* which then starts to spin for *lock*
    to be available.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the duration of the ISR, the process context is preempted and can never
    resume execution, resulting in a *lock* that can never be released, and the CPU
    is hard locked with a spinning interrupt handler that never yields.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent such occurrences, the process context code needs to disable interrupts
    on the current processor while it takes the *lock.* This will ensure that an interrupt
    can never preempt the current context until the completion of the critical section
    and lock release*.* Note that interrupts can still occur but are routed to other
    available CPUs, on which the interrupt handler can spin until *lock* becomes available.
    The spinlock interface provides an alternate locking routine `spin_lock_irqsave()`,
    which disables interrupts on the current processor along with kernel preemption.
    The following snippet shows the routine''s underlying code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`local_irq_save()` is invoked to disable hard interrupts for the current processor;
    notice how on failure to acquire the lock, interrupts are enabled by calling `local_irq_restore()`.
    Note that a `lock` taken by the caller using `spin_lock_irqsave()` needs to be
    unlocked using `spin_lock_irqrestore()`, which enables both kernel preemption
    and interrupts for the current processor before releasing lock.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Similar to hard interrupt handlers, it is also possible for soft interrupt context
    routines such as *softirqs, tasklets,* and other such *bottom halves* to contend
    for a *lock* held by the process context code on the same processor. This can
    be prevented by disabling the execution of *bottom halves* while acquiring *lock*
    in the process context. `spin_lock_bh()` is another variant of the locking routine
    that takes care of suspending the execution of interrupt context bottom halves
    on the local CPU.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`local_bh_disable()` suspends bottom half execution for the local CPU. To release
    a *lock* acquired by `spin_lock_bh()`, the caller context will need to invoke
    `spin_unlock_bh()`, which releases spinlock and BH lock for the local CPU.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a summarized list of the kernel spinlock API interface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `spin_lock_init()` | Initialize spinlock |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `spin_lock()` | Acquire lock, spins on contention |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `spin_trylock()` | Attempt to acquire lock, returns error on contention |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `spin_lock_bh()` | Acquire lock by suspending BH routines on the local processor,
    spins on contention |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `spin_lock_irqsave()` | Acquire lock by suspending interrupts on the local
    processor by saving current interrupt state, spins on contention |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `spin_lock_irq()` | Acquire lock by suspending interrupts on the local processor,
    spins on contention |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `spin_unlock()` | Release the lock |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `spin_unlock_bh()` | Release lock and enable bottom half for the local processor
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `spin_unlock_irqrestore()` | Release lock and restore local interrupts to
    previous state |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`spin_unlock_irqrestore()` | 释放锁并将本地中断恢复到先前的状态'
- en: '| `spin_unlock_irq()` | Release lock and restore interrupts for the local processor
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`spin_unlock_irq()` | 释放锁并恢复本地处理器的中断'
- en: '| `spin_is_locked()` | Return state of the lock, nonzero if lock is held or
    zero if lock is available |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '`spin_is_locked()` | 返回锁的状态，如果锁被持有则返回非零，如果锁可用则返回零'
- en: Reader-writer spinlocks
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写器自旋锁
- en: Spinlock implementation discussed until now protects shared data by enforcing
    standard mutual exclusion between concurrent code paths racing for shared data
    access. This form of exclusion is not suitable for the protection of shared data
    which is often read by concurrent code paths, with infrequent writers or updates.
    Reader-writer locks enforce exclusion between reader and writer paths; this allows
    concurrent readers to share lock and a reader task will need to wait for the lock
    while a writer owns the lock. Rw-locks enforce standard exclusion between concurrent
    writers, which is desired.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的自旋锁实现通过强制并发代码路径之间的标准互斥来保护共享数据的访问。这种形式的排斥不适合保护经常被并发代码路径读取的共享数据，而写入或更新很少。读写锁强制在读取器和写入器路径之间进行排斥；这允许并发读取器共享锁，而读取任务将需要等待锁，而写入器拥有锁。Rw-locks强制在并发写入器之间进行标准排斥，这是期望的。
- en: 'Rw-locks are represented by `struct rwlock_t` declared in kernel header `<linux/rwlock_types.h>`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Rw-locks由在内核头文件`<linux/rwlock_types.h>`中声明的`struct rwlock_t`表示：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: rwlocks can be initialized statically through the macro `DEFINE_RWLOCK(v_rwlock)`
    or dynamically at runtime through `rwlock_init(v_rwlock)`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: rwlocks可以通过宏`DEFINE_RWLOCK(v_rwlock)`静态初始化，也可以通过`rwlock_init(v_rwlock)`在运行时动态初始化。
- en: Reader code paths will need to invoke the `read_lock` routine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器代码路径将需要调用`read_lock`例程。
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Writer code paths use the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器代码路径使用以下内容：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both read and write lock routines spin when lock is contended. The interface
    also offers non-spinning versions of lock functions called `read_trylock()` and
    `write_trylock()`. It also offers interrupt-disabling versions of the locking
    calls, which are handy when either the read or write path happens to execute in
    interrupt or bottom-half context.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当锁有争用时，读取和写入锁例程都会自旋。该接口还提供了称为`read_trylock()`和`write_trylock()`的非自旋版本的锁函数。它还提供了锁定调用的中断禁用版本，当读取或写入路径恰好在中断或底半部上下文中执行时非常方便。
- en: 'Following is a summarized list of interface operations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是接口操作的摘要列表：
- en: '| **Function** | **Description** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '**函数** | **描述**'
- en: '| `read_lock()` | Standard read lock interface, spins on contention |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '`read_lock()` | 标准读锁接口，当有争用时会自旋'
- en: '| `read_trylock()` | Attempts to acquire lock, returns error if lock is unavailable
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '`read_trylock()` | 尝试获取锁，如果锁不可用则返回错误'
- en: '| `read_lock_bh()` | Attempts to acquire lock by suspending BH execution for
    the local CPU, spins on contention |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '`read_lock_bh()` | 通过挂起本地CPU的BH执行来尝试获取锁，当有争用时会自旋'
- en: '| `read_lock_irqsave()` | Attempts to acquire lock by suspending interrupts
    for the current CPU by saving current state of local interrupts, spins on contention
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '`read_lock_irqsave()` | 通过保存本地中断的当前状态来尝试通过挂起当前CPU的中断来获取锁，当有争用时会自旋'
- en: '| `read_unlock()` | Releases read lock |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '`read_unlock()` | 释放读锁'
- en: '| `read_unlock_irqrestore()` | Releases lock held and restores local interrupts
    to the previous state |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '`read_unlock_irqrestore()` | 释放持有的锁并将本地中断恢复到先前的状态'
- en: '| `read_unlock_bh()` | Releases read lock and enables BH on the local processor
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '`read_unlock_bh()` | 释放读锁并在本地处理器上启用BH'
- en: '| `write_lock()` | Standard write lock interface, spins on contention |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '`write_lock()` | 标准写锁接口，当有争用时会自旋'
- en: '| `write_trylock()` | Attempts to acquire lock, returns error on contention
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '`write_trylock()` | 尝试获取锁，如果有争用则返回错误'
- en: '| `write_lock_bh()` | Attempts to acquire write lock by suspending bottom halves
    for the local CPU, spins on contention |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '`write_lock_bh()` | 尝试通过挂起本地CPU的底半部来获取写锁，当有争用时会自旋'
- en: '| `wrtie_lock_irqsave()` | Attempts to acquire write lock by suspending interrupts
    for the local CPU by saving current state of local interrupts,. spins on contention
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '`wrtie_lock_irqsave()` | 通过保存本地中断的当前状态来尝试通过挂起本地CPU的中断来获取写锁，当有争用时会自旋'
- en: '| `write_unlock()` | Releases write lock |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '`write_unlock()` | 释放写锁'
- en: '| `write_unlock_irqrestore()` | Releases lock and restores local interrupts
    to the previous state |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '`write_unlock_irqrestore()` | 释放锁并将本地中断恢复到先前的状态'
- en: '| `write_unlock_bh()` | Releases write lock and enables BH on the local processor
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`write_unlock_bh()` | 释放写锁并在本地处理器上启用BH'
- en: Underlying calls for all of these operations are similar to that of spinlock
    implementations and can be found in headers specified in the aforementioned spinlock
    section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作的底层调用与自旋锁实现的类似，并且可以在前面提到的自旋锁部分指定的头文件中找到。
- en: Mutex locks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'Spinlocks by design are better suited for scenarios where *lock* is held for
    short, fixed intervals of time, since *busy-waiting* for an indefinite duration
    would have a dire impact on performance of the system. However, there are ample
    situations where a *lock* is held for longer, non-deterministic durations; **sleeping
    locks** are precisely designed to be engaged for such situations. Kernel mutexes
    are an implementation of sleeping locks: when a caller task attempts to acquire
    a mutex that is unavailable (already owned by another context), it is put into
    sleep and moved out into a wait queue, forcing a context switch allowing the CPU
    to run other productive tasks. When the mutex becomes available, the task in the
    wait queue is woken up and moved by the unlock path of the mutex, which can then
    attempt to *lock* the mutex.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutexes are represented by `struct mutex`, defined in `include/linux/mutex.h`
    and corresponding operations implemented in the source file `kernel/locking/mutex.c`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In its basic form, each mutex contains a 64-bit `atomic_long_t` counter (`owner`),
    which is used both for holding lock state, and to store a reference to the task
    structure of the current task owning the lock. Each mutex contains a wait-queue
    (`wait_list`), and a spin lock(`wait_lock`) that serializes access to `wait_list`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The mutex API interface provides a set of macros and functions for initialization,
    lock, unlock, and to access the status of the mutex. These operation interfaces
    are defined in `<include/linux/mutex.h>`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A mutex can be declared and initialized with the macro `DEFINE_MUTEX(name)`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: There is also an option of initializing a valid mutex dynamically through `mutex_init(mutex)`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed earlier, on contention, lock operations put the caller thread
    into sleep, which requires the caller thread to be put into `TASK_INTERRUPTIBLE`,
    `TASK_UNINTERRUPTIBLE`, or `TASK_KILLABLE` states, before moving it into the mutex
    wait list. To support this, the mutex implementation offers two variants of lock
    operations, one for **uninterruptible** and other for **interruptible** sleep.
    Following is a list of standard mutex operations with a short description for
    each:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Despite being possible blocking calls, mutex locking functions have been greatly
    optimized for performance. They are programmed to engage fast and slow path approaches
    while attempting lock acquisition. Let''s explore the code under the hood of the
    locking calls to better understand fast path and slow path. The following code
    excerpt is of the `mutex_lock()` routine from `<kernel/locking/mutex.c>`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lock acquisition is first attempted by invoking a non-blocking fast path call
    `__mutex_trylock_fast()`. If it fails to acquire lock through due to contention,
    it enters slow path by invoking `__mutex_lock_slowpath()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is programmed to acquire lock atomically if available. It invokes
    the `atomic_long_cmpxchg_acquire()` macro, which attempts to assign the current
    thread as the owner of the mutex; this operation will succeed if the mutex is
    available, in which case the function returns `true`. Should some other thread
    own the mutex, this function will fail and return `false`. On failure, the caller
    thread will enter the slow path routine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, the concept of slow path has always been to put the caller task
    into sleep while waiting for the lock to become available. However, with the advent
    of many-core CPUs, there is a growing need for scalability and improved performance,
    so with an objective to achieve scalability, the mutex slow path implementation
    has been reworked with an optimization called **optimistic spinning**, a.k.a.
    **midpath**, which can improve performance considerably*.*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The core idea of optimistic spinning is to push contending tasks into poll
    or spin instead of sleep when the mutex owner is found to be running. Once the
    mutex becomes available (which is expected to be sooner, since the owner is found
    to be running) it is assumed that a spinning task could always acquire it quicker
    as compared to a suspended or sleeping task in the mutex wait list. However, such
    spinning is only a possibility when there are no other higher-priority tasks in
    ready state. With this feature, spinning tasks are more likely to be cache-hot,
    resulting in deterministic execution that yields noticeable performance improvement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `__mutex_lock_common()` function contains a slow path implementation with
    optimistic spinning; this routine is invoked by all sleep variants of mutex locking
    functions with appropriate flags as argument. This function first attempts to
    acquire mutex through optimistic spinning implemented through cancellable mcs
    spinlocks (`osq` field in mutex structure) associated with the mutex. When the
    caller task fails to acquire mutex with optimistic spinning, as a last resort
    this function switches to conventional slow path, resulting in the caller task
    to be put into sleep and queued into the mutex `wait_list` until woken up by the
    unlock path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Debug checks and validations
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorrect use of mutex operations can cause deadlocks, failure of exclusion,
    and so on. To detect and prevent such possible occurrences, the mutex subsystem
    is equipped with appropriate checks or validations instrumented into mutex operations.
    These checks are by default disabled, and can be enabled by choosing the configuration
    option `CONFIG_DEBUG_MUTEXES=y` during kernel build.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a list of checks enforced by instrumented debug code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Mutex can be owned by one task at a given point in time
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex can be released (unlocked) only by the valid owner, and an attempt to
    release mutex by a context that does not own the lock will fail
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive locking or unlocking attempts will fail
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mutex can only be initialized via the initializer call, and any attempt to
    *memset* mutex will never succeed
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A caller task may not exit with a mutex lock held
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory areas where held locks reside must not be freed
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mutex can be initialized once, and any attempt to re-initialize an already
    initialized mutex will fail
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutexes may not be used in hard/soft interrupt context routines
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlocks can trigger due to many reasons, such as the execution pattern of
    the kernel code and careless usage of locking calls. For instance, let's consider
    a situation where concurrent code paths need to take ownership of *L[1]* and *L[2]*
    locks by nesting the locking functions. It must be ensured that all the kernel
    functions that require these locks are programmed to acquire them in the same
    order. When such ordering is not strictly imposed, there is always a possibility
    of two different functions trying to lock *L1* and *L2* in opposite order, which
    could trigger lock inversion deadlock, when these functions execute concurrently.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel lock validator infrastructure has been implemented to check and
    prove that none of the locking patterns observed during kernel runtime could ever
    cause deadlock. This infrastructure prints data pertaining to locking pattern
    such as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Point-of-acquire tracking, symbolic lookup of function names, and list of all
    locks held in the system
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Owner tracking
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of self-recursing locks and printing out all relevant info
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of lock inversion deadlocks and printing out all affected locks and
    tasks
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lock validator can be enabled by choosing `CONFIG_PROVE_LOCKING=y` during
    kernel build.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Wait/wound mutexes
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the earlier section, unordered nested locking in the kernel
    functions could pose a risk of lock-inversion deadlocks, and kernel developers
    avoid this by defining rules for nested lock ordering and perform runtime checks
    through the lock validator infrastructure. Yet, there are situations where lock
    ordering is dynamic, and nested locking calls cannot be hardcoded or imposed as
    per preconceived rules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: One such use case is to do with GPU buffers; these buffers are to be owned and
    accessed by various system entities such as GPU hardware, GPU driver, user-mode
    applications, and other video-related drivers. User mode contexts can submit the
    dma buffers for processing in an arbitrary order, and the GPU hardware may process
    them at arbitrary times. If locking is used to control the ownership of the buffers,
    and if multiple buffers must be manipulated at the same time, deadlocks cannot
    be avoided. Wait/wound mutexes are designed to facilitate dynamic ordering of
    nested locks, without causing lock-inversion deadlocks. This is achieved by forcing
    the context in contention to *wound*, meaning forcing it to release the holding
    lock.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s presume two buffers, each protected with a lock, and further
    consider two threads, say `T[1]` and `T`[`2`,] seek ownership of the buffers by
    attempting locks in opposite order:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Execution of `T[1]` and `T[2]` concurrently might result in each thread waiting
    for the lock held by the other, causing deadlock. Wait/wound mutex prevents this
    by letting the *thread that grabbed the lock first* to remain in sleep, waiting
    for nested lock to be available. The other thread is *wound*, causing it to release
    its holding lock and start over again. Suppose `T[1]` got to lock on `bufA` before
    `T[2]` could acquire lock on `bufB`. `T[1]` would be considered as the thread
    that *got there first* and is put to sleep for lock on `bufB`, and `T[2]` would
    be wound, causing it to release lock on `bufB` and start all over. This avoids
    deadlock and `T[2]` would start all over when `T[1]` releases locks held.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation interfaces:'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wait/wound mutexes are represented through `struct ww_mutex` defined in the
    header `<linux/ww_mutex.h>`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first step to use wait/wound mutex is to define a *class,* which is a mechanism
    to represent a group of locks. When concurrent tasks contend for the same locks,
    they must do so by specifying this class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can be defined using a macro:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each class declared is an instance of type `struct ww_class` and contains an
    atomic counter `stamp`, which is used to hold a sequence number that records which
    one of the contending tasks *got there first*. Other fields are used by the kernel's
    lock validator to verify correct usage of the wait/wound mechanism.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each contending thread must invoke `ww_acquire_init()` before attempting nested
    locking calls. This sets up the context by assigning a sequence number to track
    locks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the context is set up and initialized, tasks can begin acquiring locks
    with either `ww_mutex_lock()` or `ww_mutex_lock_interruptible()` calls:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When a task grabs all nested locks (using any of these locking routines) associated
    with a class, it needs to notify acquisition of ownership using the function `ww_acquire_done()`.
    This call marks the end of the acquisition phase, and the task can proceed to
    process shared data:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When a task completes its processing of shared data, it can begin releasing
    all of the locks held, with calls to the `ww_mutex_unlock(`) routine. Once all
    of the locks are released, the *context* must be released with a call to `ww_acquire_fini()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Semaphores
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until early versions of 2.6 kernel releases, semaphores were the primary form
    of sleep locks. A typical semaphore implementation comprises a counter, wait queue,
    and set of operations that can increment/decrement the counter atomically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: When a semaphore is used to protect a shared resource, its counter is initialized
    to a number greater than zero, which is considered to be unlocked state. A task
    seeking access to a shared resource begins by invoking the decrement operation
    on the semaphore. This call checks the semaphore counter; if it is found to be
    greater than zero, the counter is decremented and the function returns success.
    However, if the counter is found to be zero, the decrement operation puts the
    caller task to sleep until the counter is found to have increased to a number
    greater than zero.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This simple design offers great flexibility, which allows adaptability and application
    of semaphores for different situations. For instance, for cases where a resource
    needs to be accessible to a specific number of tasks at any point in time, the
    semaphore count can be initialized to the number of tasks that require access,
    say 10, which allows a maximum of 10 tasks access to shared resource at any time.
    For yet other cases, such as a number of tasks that require mutually exclusive
    access to a shared resource, the semaphore count can be initialized to 1, resulting
    in a maximum of one task to access the resource at any given point in time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Semaphore structure and its interface operations are declared in the kernel
    header `<include/linux/semaphore.h>`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Spinlock (the `lock` field) serves as a protection for `count`, that is, semaphore
    operations (inc/dec) are programmed to acquire `lock` before manipulating `count`.
    `wait_list` is used to queue tasks to sleep while they wait for the semaphore
    count to increase beyond zero.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Semaphores can be declared and initialized to 1 through a macro: `DEFINE_SEMAPHORE(s)`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'A semaphore can also be initialized dynamically to any positive number through
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Following is a list of operation interfaces with a brief description of each.
    Routines with naming convention `down_xxx()` attempt to decrement the semaphore,
    and are possible blocking calls (except `down_trylock()`), while routine `up()`
    increments the semaphore and always succeeds:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unlike mutex implementation, semaphore operations do not support debug checks
    or validations; this constraint is due to their inherent generic design which
    allows them to be used as exclusion locks, event notification counters, and so
    on. Ever since mutexes made their way into the kernel (2.6.16), semaphores are
    no longer the preferred choice for exclusion, and the use of semaphores as locks
    has considerably reduced, and for other purposes, the kernel has alternate interfaces.
    Most of the kernel code using semaphores has be converted into mutexes with a
    few minor exceptions. Yet semaphores still exist and are likely to remain at least
    until all of the kernel code using them is converted to mutex or other suitable
    interfaces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Reader-writer semaphores
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This interface is an implementation of sleeping reader-writer exclusion, which
    serves as an alternative for spinning ones. Reader-writer semaphores are represented
    by `struct rw_semaphore`, declared in the kernel header `<linux/rwsem.h>`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This structure is identical to that of a mutex, and is designed to support optimistic
    spinning with `osq`; it also includes debug support through the kernel's *lockdep*.
    `Count` serves as an exclusion counter, which is set to 1, allowing a maximum
    of one writer to own the lock at a point in time. This works since mutual exclusion
    is only enforced between contending writers, and any number of readers can concurrently
    share the read lock. `wait_lock` is a spinlock which protects the semaphore `wait_list`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: An `rw_semaphore` can be instantiated and initialized statically through `DECLARE_RWSEM(name)`,
    and alternatively, it can be dynamically initialized through `init_rwsem(sem)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the case of rw-spinlocks, this interface too offers distinct routines
    for lock acquisition in reader and writer paths. Following is a list of interface
    operations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These operations are implemented in the source file `<kernel/locking/rwsem.c>`;
    the code is quite self explanatory and we will not discuss it any further.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Sequence locks
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventional reader-writer locks are designed with reader priority, and they
    might cause a writer task to wait for a non-deterministic duration, which might
    not be suitable on shared data with time-sensitive updates. This is where sequential
    lock comes in handy, as it aims at providing a quick and lock-free access to shared
    resources. Sequential locks are best when the resource that needs to be protected
    is small and simple, with write access being quick and non-frequent, as internally
    sequential locks fall back on the spinlock primitive.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequential locks introduce a special counter that is incremented every time
    a writer acquires a sequential lock along with a spinlock. After the writer completes,
    it releases the spinlock and increments the counter again and opens the access
    for other writers. For read, there are two types of readers: sequence readers
    and locking readers. The **sequence reader** checks for the counter before it
    enters the critical section and then checks again at the end of it without blocking
    any writer. If the counter remains the same, it implies that no writer had accessed
    the section during read, but if there is an increment of the counter at the end
    of the section, it is an indication that a writer had accessed, which calls for
    the reader to re-read the critical section for updated data. A **locking reader**,
    as the name implies, will get a lock and block other readers and writers when
    it is in progress; it will also wait when another locking reader or writer is
    in progress.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence lock is represented by the following type:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can initialize a sequence lock statically using the following macro:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Actual initialization is done using the `__SEQLOCK_UNLOCKED(x)`, which is defined
    here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To dynamically initialize sequence lock, we need to use the `seqlock_init`
    macro, which is defined as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: API
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux provides many APIs for using sequence locks, which are defined in `</linux/seqlock.h>`.
    Some of the important ones are listed here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following two functions are used for reading by starting and finalizing
    a read section:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Completion locks
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Completion locks** are an efficient way to achieve code synchronization if
    you need one or multiple threads of execution to wait for completion of some event,
    such as waiting for another process to reach a point or state. Completion locks
    may be preferred over a semaphore for a couple of reasons: multiple threads of
    execution can wait for a completion, and using `complete_all()`, they can all
    be released at once. This is way better than a semaphore waking up to multiple
    threads. Secondly, semaphores can lead to race conditions if a waiting thread
    deallocates the synchronization object; this problem doesn’t exist when using
    completion.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Completion can be used by including `<linux/completion.h>` and by creating
    a variable of type `struct completion`, which is an opaque structure for maintaining
    the state of completion. It uses a FIFO to queue the threads waiting for the completion
    event:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Completion basically consists of initializing the completion structure, waiting
    through any of the variants of `wait_for_completion()` call, and finally signalling
    the completion through `complete()` or the `complete_all()` call. There are also
    functions to check the state of completions during its lifetime.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following macro can be used for static declaration and initialization of
    a completion structure:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following inline function will initialize a dynamically created completion
    structure:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following inline function will be used to reinitialize a completion structure
    if you need to reuse it. This can be used after `complete_all()`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Waiting for completion
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If any thread needs to wait for a task to complete, it will call `wait_for_completion()`
    on the initialized completion structure. If the `wait_for_completion` operation
    happens after the call to `complete()` or `complete_all()`, the thread simply
    continues, as the reason it wanted to wait for has been satisfied; else, it waits
    till `complete()` is signalled. There are variants available for the `wait_for_completion()`
    calls:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Signalling completion
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The execution thread that wants to signal the completion of the intended task
    calls `complete()` to a waiting thread so that it can continue. Threads will be
    awakened in the same order in which they were queued. In the case of multiple
    waiters, it calls `complete_all()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we not only understood the various protection and synchronization
    mechanisms provided by the kernel, but also made an underlying attempt at appreciating
    the effectiveness of these options, with their varied functionalities and shortcomings.
    Our takeaway from this chapter has to be the tenacity with which the kernel addresses
    these varying complexities for providing protection and synchronization of data.
    Another notable fact remains in the way the kernel maintains ease of coding along
    with design panache when tackling these issues.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will look at another crucial aspect of how interrupts
    are handled by the kernel.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
