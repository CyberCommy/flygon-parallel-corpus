- en: Building a Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about what a blockchain is and how it functions.
    In addition, we learned how to set up a project to build our blockchain. In this
    chapter, you will begin building the blockchain and all of its functionalities.
    First, let's create the blockchain data structure using a constructor function,
    and then we'll add a lot of different types of functionalities to our blockchain
    by adding different methods to its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: We're then going to give the blockchain certain functionalities, such as creating
    new blocks and transactions, as well as the ability to hash data and blocks. We'll
    also give it the ability to do a proof of work and many other functionalities
    that a blockchain should be able to do. We'll then make sure that the blockchain
    is fully functional by testing the added functionalities as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: By building each piece of the blockchain step by step, you will gain a better
    understanding of how blockchain actually works under the hood. You may also realize
    that once you dive into it, creating a blockchain is not as complicated as it
    sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to create a Blockchain constructor function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and testing various methods such as `createNewBlock`, `createNewTransaction`,
    and `hashBlock` to add functionalities to the blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what proof of work is and learning how to implement it for our
    blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and testing a genesis block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Before we get building...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into building the blockchain, there are two crucial concepts
    that we need to familiarize ourselves with. These important concepts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript constructor function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of the JavaScript constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Becoming familiar with the constructor function is important as we'll be using
    it to build our blockchain data structure. By now, you must be wondering what
    a constructor function is and what it actually does.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor function is simply a function that creates an object class and
    allows you to easily create multiple instances of that particular class. What
    this actually means is that the constructor function allows you to create a lot
    of objects very quickly. All of these objects that are created will have the same
    properties and functionalities because they are all part of the same class. Now,
    all of this might seem a little bit confusing when you hear it for the first time,
    but don't worry — we'll try to understand what a constructor function is with
    the help of an example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take Facebook, for example. Facebook has over one-and-a half billion users,
    which are all objects of the same class and have similar properties such as name,
    email, password, birthday, and so on. For our example, let's assume that we are
    building the Facebook website and want to create a bunch of different users for
    it. Let's do this by creating a `User` constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn and explore the constructor functions, let''s use the Google Chrome
    console. We can access the console by going to Google Chrome and simply pressing
    *command* + *option* + *J* for Mac users and *Ctrl* + *Shift* + *I* for Windows
    users. Alternatively, we can simply go to the menu option, go to More Tools, and
    then select the Developer Tools option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdd62f3b-e3ef-4f56-a595-2c1f57330fbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the aforementioned steps will open the console for you, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/172ac298-046d-45f0-9bdc-79c5baaa110d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The constructor function that we''ll be coding in this example will allow us
    to create multiple users or multiple user objects that will have the same properties
    and functionalities. The code to create this `User` constructor function begins
    by defining it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inside of the parentheses, `()`, let's pass the properties that we want each
    of our `User` objects to have. We're going to pass properties such as `firstName`,
    `lastName`, `age`, and `gender` because we want all of our user objects to have
    these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assign these parameters to our `User` objects by using the `this` keyword,
    as shown in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ddd09c9-3fe2-485d-9a6a-c9457654c039.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we define the constructor function in JavaScript. Now, reading through
    the preceding code block, you might be wondering what we did and what the `this`
    keyword is all about.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use this constructor function to create a lot of user objects.
    The `this` keyword is simply referring to each of the user objects that we're
    going to create. This might all seem a bit overwhelming right now, but let's run
    through a couple of examples and try to gain more clarity on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin using our `User` constructor function. To make some `User` objects,
    also known as `User` instances, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first user that we are going to create – let''s call it `user1` – will
    be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you may have noticed that we used the `new` keyword to
    invoke our constructor function and make a user object, which is how we get our
    constructor function to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then press *Enter,* and `user1` is in the system. Now, if we type `user1` 
    in the console, we''ll be able to see what we just created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d44eaca9-749c-471a-8d79-efead9ca8491.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output screenshot, we can see that `user1` is an object of
    the `User` class. We can also see that `user1` has a `firstName` of `John`, a
    `lastName` of `Smith`, an `age` of `26`, and `gender` of `male` because these
    are the parameters that we passed into the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, try adding one more user. This time, we''ll create another user
    called `user200` and pass in into the `new User ( )` function with the user''s
    properties, such as a first name of `Jill`, a last name of `Robinson`, an age
    of `25`, and a `female` gender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By pressing *Enter*, our new `user200` will be in the system. Now, if we type
    `user200` into the console and press *Enter*, we''ll see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/902899d7-1de6-4a56-b8af-ffc15758e7fe.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we can see that `user200` is an object of the `User` class,
    just like `user1`, and that she has a first name of `Jill`, a last name of `Robinson`,
    an age of `25`, and a `female` gender because these were the parameters that we
    passed into our constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be wondering how all of these properties that we mentioned got
    assigned correctly. This was all due to the `this` keyword that we mentioned earlier.
    When we create our constructor function, we use the `this` keyword to assign properties.
    When it comes to a constructor function, the `this` keyword does not refer to
    the function that it is in – in our case, the `User` function. Instead, `this`
    refers to the object that will be created by the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: This signifies that if we use the constructor function to create an object,
    we must make sure that the property and their objects are first name, last name,
    age, and gender, or whenever you make your constructor function, set the `firstName`
    property as equal to the `firstName` parameter that is passed in, and do the same
    for the rest of the properties.
  prefs: []
  type: TYPE_NORMAL
- en: This is how a constructor function works and how the `this` keyword plays an
    important role in the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation of the prototype object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important concept that we need to discuss before getting into coding
    our blockchain data structure is the prototype object. The **prototype object**
    is simply an object that multiple other objects can refer to in order to get any
    information or functionality that they need. For our example, which we discussed
    in the previous section, each of our constructor functions will have a prototype
    that all of their instances will be able to refer to. Let's try to understand
    what a prototype object means by exploring a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we take our `User` constructor function that we created in
    the previous section, we can put those properties onto its prototype. Then, all
    of our user instances like `user1` and `user200` will have access to and be able
    to use that prototype. Let''s add a property on our `User` prototype and see what
    happens. To add a property on the user prototype, we will type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s add the name of the property to the preceding code. For example,
    let''s say we want a property email domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, assume that Facebook wants every user to have an `@facebook.com`
    email address, so we''ll set the email domain property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check out our `user1` object again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12909ac8-5180-4732-9a08-be947497cc3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we can see that `user1` does not have the email
    domain property that we just added to it. However, we can expand the `user1` object,
    as well as its dunder proto, as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbf3d80b-4db6-45bc-8621-12d5e3ead677.png)'
  prefs: []
  type: TYPE_IMG
- en: When we do this, we can observe the `emailDomain` property that we just added,
    which is set to `@facebook.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Just to clarify, the dunder proto and the prototype object that we actually
    put the `emailDomain` property on are actually not exactly the same, but are very
    similar. Basically, anything that we put on the constructor function prototype
    will have access to the dunder proto of any of the objects that we create with
    the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we put `emailDomain` on the constructor function prototype, we'll have
    access to it on the `user1` dunder proto, the `user200` dunder proto, and the
    dunder protos of any other user instance that we've created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to the `emailDomain` property. We put the `emailDomain`
    property and the user prototype. We can see that we don''t have the property on
    the actual `user200` object, but we have that property under the `user200` dunder
    proto. So, if we type the following command, we will still have access to that
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should then see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4732f7-2141-488c-bb2a-a583599f70ec.png)'
  prefs: []
  type: TYPE_IMG
- en: So, this is how the prototype object works. If we put a property on the constructor
    function's prototype, all of the instances of the constructor function will have
    access to that property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing applies for any methods or functions that we might want all
    of our instances to have. Let''s take a look at another example, assuming that
    we want all of our user instances to have a `getEmailAddress` method. We can put
    this on the prototype of the constructor function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have this `getEmailAddress` method return some specific properties,
    as follows (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now both `user1` and `user200` should have this method under their dunder proto,
    so let''s check it out. Type in our users, and under their dunder proto you will
    get to observe the preceding function, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ba858a-1e99-4237-99ab-ce881768de47.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can observe that both `user1` and `user200`
    have the `getEmailAddress` method under their dunder proto.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we type `user200.getEmailAddress` and then invoke it, the method will
    then create user200''s Facebook email address for us, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf1af2a5-d453-4cc1-b182-f30a7f095b92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A similar thing will happen if we invoke the method for `user1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27d5b431-3bee-4bef-a976-634e3cb30c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, this is how we use the prototype object with a constructor function. If
    we want our constructor function instances to all have the properties that are
    the same for all of them, or all have a method that is the same for all of them,
    we will put it on the prototype instead of the constructor function itself. This
    will help in keeping the instances more lean and cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the background information that we need to know in order to start
    coding our blockchain data structure. In the following section, we will start
    building our blockchain by using a constructor function and the prototype object.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with building our blockchain data structure. We'll start by
    opening all of the files that we have in our blockchain directory by using the
    Sublime editor. If you are comfortable using any other editor, you can use that
    too. Open our entire blockchain directory in whichever editor you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be building our entire blockchain data structure in the `dev/blockchain.js`
    file that we created in [Chapter 1](cd35f368-cf70-4065-8bd8-ed8347b1878a.xhtml),
    *Setting up the Project*. Let''s build this blockchain data structure by using
    a constructor function that we learned about in the previous section.  So, let''s
    begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the constructor by type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For now, the `Blockchain ()` function is not going to take any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside of our constructor function, we are going to add the following
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, `[]` defines an array, and the `this.chain = [];` is
    where the meat of our blockchain will be stored. All of the blocks that we mine
    will be stored in this particular array as a chain, while `this.newTransactions
    = [];`  is where we will hold all of the new transactions that are created before
    they are placed into a block.
  prefs: []
  type: TYPE_NORMAL
- en: All of this might seem a little bit confusing and overwhelming right now, but
    don't worry about it. Let's dive deeper into this in future sections.
  prefs: []
  type: TYPE_NORMAL
- en: When defining the preceding function, we have initiated the process of creating
    the blockchain data structure. Now, you might be wondering why we are using a
    constructor function to build our blockchain data structure instead of a class;
    the answer to this is that this is simply a preference. We prefer to create constructor
    functions over classes in JavaScript because in JavaScript there really are no
    classes. Classes in JavaScript are simply a kind of a sugar coating on top of
    constructor functions and the object prototype. So, we simply prefer to just stick
    with constructor functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you want to create a blockchain by using a class, you could do
    something such as in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, either way, if you prefer using a constructor function or using a class,
    it would work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: This is it – with defining our function, we've began the process of building
    our blockchain data structure. In further sections, we'll continue to build on
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Building the createNewBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue with building our blockchain data structure. After defining
    our constructor function in the previous section, the next thing that we want
    to do with our constructor function is to place a method in our `Blockchain` function.
    This method that we are going to create will be called `createNewBlock`. As its
    name suggests, this method will create a new block for us. Let''s follow the below
    mentioned steps to build the method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createNewBlock` method will be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ve got this `createNewBlock ` method on our blockchain `prototype`
    object. This method will take the three parameters, as highlighted in the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn in depth about these three parameters in further sections, so don't
    worry if you're not familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next thing that we want to do inside of our `createNewBlock` method
    is to create a `newBlock` object. Let''s define this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This `newBlock` object is going to be a new block inside of our `BlockChain`,
    so all of the data is going to be stored inside of this block. This `newBlock` object
    is a pretty important part of our blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on the `newBlock` object, we''re going to have an `index` property. This
    `index` value will basically be the block number. It will describe what number
    of block the `newBlock` is in our chain (for example, it may be the first block):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next property is going to be a `timestamp`, because we want to know when
    the block was created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the next property we will add will be for the `transactions`. When we
    create a new block, we''ll want to put all of the new transactions or the pending
    transactions that have just been created into the new block so that they''re inside
    of our blockchain and can never be changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding highlighted line of code states that all of the transactions in
    the block should be the new transactions that are waiting to be placed into a
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next property that we are going to have on our block is a `nonce`, and
    this will be equal to the `nonce` parameter that we passed into our function earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, you might be wondering what a `nonce` is. Basically, a nonce comes from
    a proof of work. In our case, this is simply any number; it doesn't matter which.
    This nonce is pretty much proof that we've created this new block in a legitimate
    way by using a `proofOfWork` method.
  prefs: []
  type: TYPE_NORMAL
- en: All of this might seem a little bit confusing right now, but don't worry — once
    we build more on our blockchain data structure, it will be much easier to understand
    how everything works together to create a functional blockchain. So, if you don't
    understand what a nonce is right now, don't worry about it. We're going to deal
    with this property in further sections, and it will become clearer as we move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next property is going to be a `hash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this `hash` will be the data from our `newBlock`. What's going to
    happen is we're going to pass our transactions or our `newTransactions` into a
    hashing function. What this means is that all of our transactions are going to
    be compressed into a single string of code, which will be our `hash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our last property on our `newBlock` will be our `previousBlockHash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `previousBlockHash` property is very similar to our `hash` property, except
    our `hash` property deals with the data from our current block hashed into a string,
    and the `previousBlockHash` property deals with the data from our previous block
    or the previous block to the current block hashed into a string.
  prefs: []
  type: TYPE_NORMAL
- en: So, `hash` and `previousBlockHash` are both hashes. The only difference is that
    the `hash` property deals with the data of the current block, and, the `previousBlockHash` property
    deals with the hashing of the data of the previous block.  This is how you create
    a new block, and this is what every block in our blockchain will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our `createNewBlock` method, the next thing that we want to
    do is set `this.newTransaction` as equal to an empty array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We do this because, once we create our new block, we are putting all of the
    new transactions into the `newBlock`. Therefore, we want to clear out the entire
    new transactions array so that we can start over for the next block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, what we simply want to do is take the new block that we''ve created and
    push it into our chain, and then we''re going to return the `newBlock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By adding these last two lines of code, our `createNewBlock` method is ready.
    Basically, what this method does on a high level is it creates a new block. Inside
    of this block, we have our transactions and the new transactions that have been
    created since our last block was mined. After we've created a new block, let's
    clear out the new transactions, push the new block into our chain, and simply
    return our new block.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the createNewBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now lets test the `createNewBlock` method that we created in the preceding
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is export our `Blockchain` constructor function
    because we are going to use this function in our `test.js` file. So, to export
    the constructor function, we will go to the bottom of the `blockchain.js` file,
    type the following line of code, and then save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go to the `dev/test.js` file, as this is where we will be testing our
    `createNewBlock` method. Now, the first thing that we want to do in our `dev/test.js`
    file is import our `Blockchain` constructor function, so type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This preceding line of code simply requires or calls the `blockchain.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Blockchain constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test the Blockchain constructor function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets make an instance of our `Blockchain` constructor function, so we will
    add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bitcoin` variable in the preceding line of code is just used for the purpose
    of an example. Then we add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding line of code, `bitcoin` should be our blockchain. There is
    currently no data or blocks in this, but it should log out as a blockchain. Let's
    save the `test.js` file and run the test to observe the output on the terminal
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to our terminal window. In here, we''re currently in the `blockchain`
    directory, and our `test.js` file is in our `dev` folder, so type the following
    command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This preceding line of code will allow us to run the test that we have written
    to test our `Blockchain` constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now press *Enter*, and we''ll get to observe the `Blockchain` on the terminal
    window, as highlighted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23de40f9-44af-44a7-891e-a3e534e61291.png)'
  prefs: []
  type: TYPE_IMG
- en: From the output in the preceding screenshot, we can observe that `Blockchain`
    has an empty chain and an empty transactions array. This is exactly what we expected
    the output to be.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the createNewBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps to test the createNewBlock method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, underneath where we created our `bitcoin` variable, type in the following
    highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This `createNewBlock()` method requires three parameters, such as `nonce`,
    `previousBlockHash`, and a `hash`. For test purposes, we can just pass in whatever
    we want for now. Here, the nonce will just be a number. Then we will create a
    dummy hash for our `previousBlockHash`, followed by another hash for our `hash`
    parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Right now, we are creating our `bitcoin` blockchain, followed by a new block
    in our bitcoin blockchain. When we log out of our bitcoin blockchain, we should
    have one block in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file and run our `test.js` file again in the terminal. You''ll then
    get to observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0dae3277-99de-4416-985e-14a3168953f9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can observe the entire blockchain data structure
    in the `chain` array. This has one block in it, or one object in it. This block
    also has the `hash`, `nonce`, and `previousBlockHash` parameters that we had passed.
    It also has the `timestamp` and the `index` of `1`. It has no transactions because
    we haven't created any transactions yet. Consequently, we can conclude that the
    `createNewBlock` method works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s test our method even further by creating a couple more blocks in
    our chain. Let''s duplicate the following lines of code  multiple times and then
    try to change the values in it as we wish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After duplicating the code and changing the value, save the file. Now, when
    we run our `test.js` file, we should have three blocks in our chain, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8eb516d6-29bd-48e1-b177-dd2895418bfc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you may have observed the three blocks inside of
    the `chain` array. These are all of the blocks that we've created with our `createNewBlock`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Building the getLastBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the next method that we are going to add to our `Blockchain` constructor
    function will be the `getLastBlock`. This method will simply return the last block
    in our blockchain to us. Follow the below mentioned steps to build the method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to our `dev/blockchain.js` file, and after our `createNewBlock` method,
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of this `getLastBlock` method, we will type the following highlighted
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `[this.chain.length - 1];` in this preceding code defines the position of
    the block in the chain, which, in our case, is the previous block, therefore negated
    by `1`. This method is simple and straightforward, and we'll use it in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the createNewTransaction method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next method that we are going to add to our blockchain constructor function
    is called `createNewTransaction`. This method will create a new transaction for
    us. Let''s follow the below mentioned steps to create the method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start building up this method by adding the following line of code after our
    `getLastBlock` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `function ()` will take three parameters, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What these three parameters will do is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`amount`: This parameter will take in the amount of the transaction or how
    much is being sent in this transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sender`: This will take in the sender''s address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recipient`: This will take in the recipient''s address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next thing that we want to do inside of our `createNewTransaction` method
    is create a transaction object. So, add the following line of code to our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This object will have three properties in it. It will have an `amount`, a `sender`,
    and the `recipient`. These are the same three parameters that we passed into our
    `function()`. So, type in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is what our transaction object will look like. All of the transactions
    that we record on our `Blockchain` are going to look just like this. They all
    are going to have an amount, a sender, and the recipient, which is pretty straightforward
    and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that we want to do now is push this `newTransaction` data into
    our `newTransactions` array. Let''s do this by adding the following code after
    our `newTransaction` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, the new transaction that we just created will now be pushed into our `newTransactions`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's just try to understand what this `newTransactions` array actually
    is. Basically, what is happening here with this `newTransactions` array is that
    on our blockchain there are going to be a lot of people who will be making a lot
    of different transactions. They will be sending money from one person to another
    and this will be happening repetitively. Every time a new transaction is created,
    it's going to be pushed into our `newTransactions` array.
  prefs: []
  type: TYPE_NORMAL
- en: However, all of the transactions in this array are not really set in stone.
    They're not really recorded in our blockchain yet. They will get recorded in our
    blockchain when a new block is mined, which is when a new block is created. All
    of these new transactions are pretty much just pending transactions, and they
    have not been validated yet. They get validated, set in stone, and recorded in
    our blockchain when we create a new block with the help of the `createNewBlock`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `createNewBlock` method, you can observe in `transactions: this.newTransactions` that
    we set the transactions on a new block equal to the `newTransactions` or the pending
    transactions in our blockchain. You can think of this `newTransactions` property
    on our blockchain as a pending transactions property.'
  prefs: []
  type: TYPE_NORMAL
- en: For easy reference,  let's actually change all of the `newTransactions` properties
    in our code to `pendingTransactions` properties. Overall, when a new transaction
    is created, it is pushed into our `pendingTransactions` array. Then, when a new
    block is mined or when a new block is created, that's when all of our pending
    transactions become recorded on our blockchain, and they are then set in stone
    and can never be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of all this is that before our method ends, we want to return in
    which block we will be able to find the new transaction because our new transaction
    will be in the next block when it is mined. Consequently, we''ll simply type the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `this.getlastBlock()` returns a block object for us.
    We want to get the index property of this block – adding `['index']` will provide
    us with the index of the last block in our chain, and adding `+ 1` will provide
    us with the number of the block our transaction was pushed to.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a quick recap,  the `createNewTransaction` method simply creates
    a `newTransaction` object, and then we push that `newTransaction` into our `pendingTransactions`
    array. Finally, we return the number of the block that the `newTransaction` will
    be added to.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the createNewTransaction method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test the `createNewTransaction` method that we created in the previous
    section. Just as a heads up: this section is going to be a lot of fun, as here
    you will really start to understand how powerful a blockchain can be and how blocks
    and transactions work with each other. You''ll also get to learn how the transactions
    are recorded in the blockchain. So let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to test our `createNewTransaction` method in our `test.js` file.
    In this file, we''ve already required our `blockchain.js` file and have made a
    new instance of our `Blockchain` called `bitcoin`, which we are logging out at
    the end of our file. Take a look at the following screenshot for a quick review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/841dc351-8c46-47a1-b1ac-276b187e57eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the first thing that we''re going to do in our `test.js` file is create
    a new block using our `createNewBlock` method, similarly to what we did in the *Testing
    the createNewBlock method* section. Type in the following into your `test.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, what we want to do is create some new transactions to test our `createNewTransaction`
    method. This `createNewTransaction` method takes in three parameters, such as `amount`,
    a `sender`, and the `recipient`. Let''s add this transaction data to our test
    case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we've set the amount of the transaction to `100 `and
    the sender and recipient's address to some random hash numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed the names `ALEX` and `JEN` in the addresses. We've added
    those just to simplify the identification of who the sender and recipient is.
    In reality, you would more than likely not have this kind of name appear at the
    beginning of an address. We've done this to make it easier for us to reference
    these addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s just quickly summarize what we have done so far in our test case.
    Take a look at the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first required the bitcoin blockchain, and then we
    created a new block. After that, we created a new transaction, and then we logged
    out the bitcoin blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this `test.js` file, we should expect to see our bitcoin blockchain,
    which should have one block in the chain as well as one transaction in the `pendingTransactions`
    array because we have not mined or created a new block after creating the transaction.
    Let's save this file and run it to see what we get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to your terminal window, type in the following command, and then press
    *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We get to observe the bitcoin blockchain on the terminal window, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8384e707-7642-4498-8e43-335168607f06.png)'
  prefs: []
  type: TYPE_IMG
- en: In the output on your window and in the preceding screenshot, you can observe
    our chain, which has the one block that we created.  In our `pendingTransactions` array,
    we have one pending transaction, which is the transaction we created in the test
    case. Looking at the output of the test, we can conclude that, so far, our `createNewTransaction`
    method works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pending transaction to our blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s try to understand how we can get the `pendingTransaction` into our
    actual `chain` up here. The way we do that is by mining a new block or by creating
    a new block. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we create the `newTransaction`, let''s create a new block using the `createNewBlock`
    method, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is created a block, created a transaction, and then mined
    a new block. Now the transaction that we created should show up in our second
    block because we mined a block after we created a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now save the file and run the test again. Let''s see what we get from this.
    Go to your terminal and again type in the `node dev/test.js` command and press
    *Enter*. You will get to observe the output that is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9ef7fc6-b02d-4298-a717-ff658920faad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have our entire blockchain again, which has two blocks in it because
    we mined two blocks. The chain has our first block (index: 1), which has no transactions
    and has our second block (index: 2),  in which, if you look at our transactions,
    it says that there is an Array that has items in it versus a first block''s transaction
    array, which has no items in it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a closer look at the second block''s transaction array. We should
    expect to see the transaction that we had created previously. Let''s make the
    following highlighted modification to our test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this modification, we just log out of the second block in our chain. `[1]`
    in the code defines the position of the second block.  Save this file and run
    it. In the output, you can observe that we are simply logging out of the second
    block in our chain and you can see that, for transactions, it has an array with
    one object in it. Check out the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f82129a-ed23-4cb4-852e-effb7e1052b5.png)'
  prefs: []
  type: TYPE_IMG
- en: This object is the transaction that we created in our test. What we did here
    was just create a transaction and then mine it by creating a new block or mining
    a new block, which now has our transaction in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's carry out a couple more examples to help clarify what is happening
    here. Let's take the `createNewTransaction` method and duplicate it three more
    times after our `createNewBlock` method. Make the modifications to the amounts
    as you wish to.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s happening over here is that, from the top, we are first creating a
    block and then creating a transaction. We are then creating or mining a new block,
    so we should have one block with no transactions and another block with one transaction
    in it. After we create our second block, we are creating three more new transactions.
    At this point, all three of these new transactions should be in our `pendingTransactions`
    array because we are not creating a new block after we create these three transactions.
    Lastly, we log out of our bitcoin blockchain again. Your test should now look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we save the file and run it, we should have two blocks in our chain,
    and we should also have three transactions in the `pendingTransactions` array.
    Let''s see what we get here. You will get to observe the following output on your
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30c69a57-08f5-4a1f-ab4c-f47ba6c35ce0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can observe that we have our blockchain. In
    this chain, we have two blocks, just like we expected to have, and in our `pendingTransactions`
    array, we have three transactions, which are the three transactions that we had
    created in our test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have to do next is get these pending transactions into our chain. For
    that, let''s mine another block. Just copy and paste the `creatNewBlock` method
    after the three transactions that we created and make modifications to its parameters
    as you wish to. When we run the test now, the three transactions that are pending
    should appear in our new block. Let''s save the file and run the test. You will
    get to observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b8768ca-64a2-493a-ae89-f895e71c5a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we have our blockchain, which has three blocks in it. Our `pendingTransactions`
    array is currently empty, but where did those three transactions go? As it turns
    out, they should be in the last block that we created, which is the index: 3 block.
    Inside of this third block we have our transactions, which should be the three
    transactions we just created. Let''s take a deeper look at this by making a tiny
    modification to the last line of our test code, which is `console.log(bitcoin.chain[2]); `.
    The value `2` here specifies the third block in the chain. Let''s save this modification
    and run the test again.  You will get to see the third block in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d4a892c-7972-4159-ad4b-b929943e13fc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the transaction's array, you can see that we have all three of the transactions
    that we created. So, this is how our `createNewTransaction` and `createNewBlock`
    methods work with each other.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having trouble understanding how both of these methods work or how
    they work together, we encourage you to mess around with your `test.js` file and
    create some new blocks, create some new transactions, log some different information
    out, and get a good idea of how these things work.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next method that we are going to look at and add into our blockchain data
    structure is called `hashBlock`. What this `hashBlock` method will do is take
    in a block from our blockchain and hash its data into a fixed length string. This
    hashed data will appear randomly.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, what we're going to do is pass some blocks of data into this hash
    method, and in return we'll get a fixed-length string, which will simply be a
    hash data that is generated from the data that we passed in or from the block
    that we passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `hashBlock` method to our blockchain data structure, type the following
    line of code after our `createNewTransaction` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In our `hashBlock` method, `blockdata` will be the input data of our block from
    which we want to generate the hash.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we take a block or blocks of data and get a hashed string in return? For
    generating hash data, we're going to use a hashing function called **SHA256**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the SHA256 hashing function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **SHA256** hashing function takes in any string of text, hashes that text,
    and returns a fixed-length hashed string.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better understanding of what hash data looks like, visit [https://passwordsgenerator.net/sha256-hash-generator/](https://passwordsgenerator.net/sha256-hash-generator/).
    This is a hash generator. If you input any text into the text box, you will get
    hash data as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we put `CodingJavaScript` into the textbox, the hash that is
    returned to us will look like the one highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0859648-a484-478f-a7e0-75ce71d7340a.png)'
  prefs: []
  type: TYPE_IMG
- en: The output hash that we can observe in the preceding screenshot seems arbitrary,
    and thus helps in keeping the data safe. This is one of the reasons why SHA256
    hashing is so secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we add another character to our input string or if we change our input
    string in any way, the entire output hash will change completely. For example,
    if we add an exclamation mark at the end of our input string, the output hash
    will entirely change. You can observe that in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35373ad6-ebe7-411b-83cb-56ae2ac854d0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can try experimenting by adding new characters at the end of the input string.
    You'll observe that as we add more or remove the characters, the entire output
    hash will change drastically every time, thus generating the new random patterns.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing that you may want to observe related to SHA256 hashing is that
    with any given input, the output will always be the same. For example, for our
    input string, `codingJavaScript!`, you will always get the same hash output that
    was shown in the previous screenshot. This is another very important feature of
    SHA256 hashing. With any given input, the output or the hash that is returned
    from that input will always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is how SHA256 hashing works. In the next section, we'll implement the
    SHA256 hashing function inside of our `hashBlock` method.
  prefs: []
  type: TYPE_NORMAL
- en: The hashBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build up our `hashBlock` method. Inside of this method, we want to use
    SHA256 hashing to hash our block data. Follow the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an SHA256 hashing function, import it as an npm library. To do that,
    go to Google and type SHA256 into the search bar, or visit [https://www.npmjs.com/package/sha256](https://www.npmjs.com/package/sha256).
    On this website, you will get to see the command that we need to type into our
    terminal to install SHA256\. We''ll have to type in the following command in our
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, press *Enter*. The `--save`  in the following command will
    save this library as a dependency for us. Now, inside of our blockchain file structure,
    you may see that the `node_modules` folder has appeared. Inside of this folder
    is where our SHA256 library and all other dependencies have been downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use this SHA256 library, we will have to import the library to our code
    so that we can use it. At the very start of our code, type the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code specifies that we have an SHA256 hashing function
    stored as the variable SHA256 in the `blockchain.js` file. By importing it, we
    can use that inside of our `hashBlock` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the first thing that we want to do in our `hashBlock` method is to change
    the parameters that it takes. We''re going replace the `blockData` parameter with 
    `previousBlockHash`, `currentBlockData`, and `nonce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These three parameters will be the data that we are going to be hashing inside
    of our `hashBlock` method. All of this data will come from a single block in our
    chain and we're going to hash this data, which is essentially hashing a block.
    We are then going to get a hashed string in return.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we want to do is change all of these pieces of data into
    a single string, so add the following line of code to our `hashBlock` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `previousBlockHash` is already a string. Our nonce is
    a number, so we're going to change that to a string with `toString`. Furthermore,
    our `currentBlockData` is going to be an object, an array of our transactions,
    or some kind of JSON data. It will either be an array or an object, and `JSON.stringify`
    will simply turn that data (as well as any object or array) into a string. Once
    this whole line is run, we will simply have all of the data that we passed to
    be concatenated into a single string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next thing that we want to do is create our hash, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is how we create a hash from our block or all of the block data that we
    have passed into our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we want to do is simply return the hash, so before we complete
    this method, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is how our `hashBlock` method will work. In the following section, we will
    test this method to see if it works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the hashBlock method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our `hashBlock` method in the `test.js` file. Similar to what we
    did in the previous sections, in our `test.js` file, we should be importing our
    blockchain data structure, creating a new instance of our blockchain, and naming
    it `bitcoin`. Now, let''s test our `hashBlock` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, type in the following highlighted line of code into our `test.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `hashBlock` method requires three parameters:  a `previousBlockHash`, `currentBlockData`,
    and the `nonce`. Let''s define these variables above the part where we''re calling
    our `hashBlock` method. We''ll begin by defining the `previousBlockHash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For now, this random string/hash data will act as input for our `previousBlockHash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `currentBlockData` variable. This `currentBlockData` will
    simply be an array of all of the transactions that will be present in this block.
    We''re simply going to use the transactions in this block as our `currentBlockData`,
    so in this array, we will have to make a couple of transaction objects, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next, duplicate this transaction object at least three times to make a couple
    more transaction objects in the array and then make modifications to the data
    as you wish, aiming to change the amount and the sender's and recipient's addresses.
    This will make our `currentBlockData` an array that holds three transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have to assign the `nonce` value in our `hashBlock` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining these variables, we call the `hashBlock` method and pass the
    `previousBlockHash` and `currentBlockData` parameters, as well as the `nonce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, let''s try to push the results onto the terminal window so that
    we can observe it. To do this, we''ll have to make a tiny modification to our
    preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this test case, we are calling our `hashBlock` method with all of the correct
    parameters. When we run this file, we should get to observe the hash on the terminal
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Now save this `test.js` file and run it to check whether or not we get the output
    that we expect it to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to your terminal window and type in the `node dev/test.js` command, and
    let''s observe what results we get. You will get to observe the similar resulting
    hash as output of our `hashBlock` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/34c4b7d1-ad74-482c-b25e-d190cf2d079e.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like our `hashBlock` method is working pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: Try to explore this `hashBlock` method a little more. As explained in the previous
    section, if we change some of the data that we are passing into the `hashBlock`
    method, it will result in completely changing the hash that we returned as output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now try to test this feature of hashing data by changing a letter in any of
    the sender''s or recipient''s address. Then save the file and run it by using
    `node dev/test.js` again. You will get to observe a totally different hash data
    as output, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b78757c-e711-4dce-93a8-0aa93d024e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can observe both the hash data and the differences
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we revert the change that we made to the sender's or recipient's address
    and run our hash method again, we'll get to observe the same hash that we originally
    got. This is because we're passing in the same data that we did the first time
    around. You can try experimenting with the data and try observing the output to
    explore the `hashBlock` method further.
  prefs: []
  type: TYPE_NORMAL
- en: After this test, we can thus conclude that our `hashBlock` method works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Proof of Work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next method that we are going to add to our blockchain data structure is
    the `proofOfWork` method. This method is very important and essential to the blockchain
    technology. It is because of this method that Bitcoin and many other blockchains
    are so secure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you must be getting curious about what a **Proof of Work** (**PoW**) actually is. Well,
    if we take a look at our blockchain, every blockchain is pretty much a list of
    blocks. Every single block has to be created and added to the chain. However,
    we don't just want any block to be created and added to the chain. We want to
    make sure that every block that is added to the chain is legitimate, has the correct transactions,
    and has the correct data inside of it. This is because if it doesn't have the
    correct transactions or the correct data, then people could fake how much Bitcoin
    they have and essentially cause fraud and steal money from other people. So, every
    time a new block is created, we first have to make sure that it is a legitimate
    block by mining it through PoW.
  prefs: []
  type: TYPE_NORMAL
- en: A `proofOfWork` method will take in the `currentBlockData` and the `previousBlockHash`.
    From this data that we supply, the `proofOfWork` method will try to generate a
    specific hash. This specific hash in our example is going to be a hash that starts
    with four zeros. So, with the given `currentBlockData` and the `previousBlockHash`,
    the method will somehow generate a resulting hash that begins with four zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try to understand how we can do this. As we learned in the previous
    sections, the hash that is generated from SHA256 is pretty much random. So, if
    the resulting hash is pretty much random, then how can we generate a hash from
    our current block that starts with four zeros? The only way this can be done is
    by trial and error, or by guessing and checking. So, what we will have to do is
    run our `hashBlock` method many times until we end up getting lucky one time by
    generating a hash that has four zeros at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be wondering that the input to our `hashBlock` method are the `previousBlockHash`,
    `currentBlockData`, and `nonce` parameters. How will these three parameters that
    have been passed in once and possibly generate multiple different hashes, when,
    in actual fact, we're always passing exactly the same data? Furthermore, as we
    know from the previous section that whenever we pass in a specific piece of data,
    we are always going to get the same resulting hash generated from that data.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we alter this data in a way that does not change our `currentBlockData`
    or the `previousBlockHash`, but we still get a resulting hash that has four zeros
    at the beginning of it?  The answer to this question is that we are going to constantly
    change the nonce value.
  prefs: []
  type: TYPE_NORMAL
- en: This might all seem a bit confusing right now, so let's try to clarify it by
    knowing what actually happens in a `proofOfWork` by breaking it down a little
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what is happening in our `proofOfWork` is that we're going to repeatedly
    hash our block until we find the correct hash, which will be any hash that starts
    with four zeros. We'll be changing the input to our `hashBlock` method by constantly
    incrementing the nonce value. The first time that we run our `hashBlock` method,
    we are going to start with a nonce value of 0. Then, if that resulting hash does
    not have four zeros at the beginning of it, we are going to run our `hashBlock`
    method again, except this time we are going to increment our nonce value by 1\.
    If we do not get the correct hash value again, we're going to increment the nonce
    value and try it again. If that doesn't work, we'll again increment the nonce
    value and try again. Then we'll continually run this `hashBlock` method until
    we find a hash that begins with four zeros. That is how our `proofOfWork` method
    will function.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how this `proofOfWork` method actually secures the blockchain.
    The reason for this is because in order to generate the correct hash, we're going
    to have to run our `hashBlock` method many times, and this is going to use up
    a lot of energy and computing power.
  prefs: []
  type: TYPE_NORMAL
- en: So, if somebody wanted to go back into the blockchain and try to change a block
    or the data in that block – perhaps to give themselves more Bitcoin – they would
    have to do a ton of calculations and use a lot of energy to create the correct
    hash. In most cases, going back and trying to recreate an already existing block
    or trying to re-mine an already existing block with your own fake data is not
    feasible. On top of that, not only does our `hashBlock` method take in the `currentBlockData`,
    it also takes in the previous `BlockHash`. This means that all of the blocks in
    the blockchain are linked together by their data.
  prefs: []
  type: TYPE_NORMAL
- en: If somebody tries to go back and re-mine or recreate a block that already exists,
    they would also have to re-mine and recreate every single block that comes after
    the first one that they recreated. This would take an incredible amount of calculation
    and energy, and is just not feasible for a well-developed blockchain. A person
    would have to go in, recreate a block by using a proof of work, and then recreate
    every block after that by doing a new proof of work for each block. This is just
    not feasible for any well-produced blockchain, and this is the reason why blockchain
    technology is so secure.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this section, what our `proofOfWork` method will basically do is
    repeatedly hash our `previousBlockHash`, our `currentBlockData`, and a nonce until
    we get an acceptable generated hash that starts with four zeros.
  prefs: []
  type: TYPE_NORMAL
- en: This might all seem overwhelming and a little bit confusing right now, but don't
    worry – we are going to build the `proofOfWork` method in the following section,
    and then we're going to test it with many different types of data. This will help
    you to become much more familiar with how the `proofOfWork` method functions and
    how it is securing the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the proofOfWork method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build out the `proofOfWork` method, which we discussed in the preceding
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `hashBlock` method, define the `proofOfWork` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes in two parameters: `previousBlockHash` and `currentBlockData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we want to do inside of our method is define a nonce:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to hash all of our data for the first time, so type in the following
    highlighted line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you may notice that we used the term `let` because both
    our nonce and hash will be changing as we move through the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step that we want to do is constantly run the `hashBlock` method over
    and over again until we get a hash that starts with four zeros. We''re going to
    do this repeated operation with the help of a `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If the hash that we created does not start with four zeros, we''ll want to
    run our hash again, except this time with the different value of nonce. Consequently,
    inside of the `while` loop, add the following highlighted lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Inside of the `while` loop, we are running our `hashBlock` method again with
    all the same data, except this time our nonce is incremented and equal to 1 instead
    of 0\. This will be the first iteration of our while loop. Now, after the first
    iteration, the new hash that is generated doesn't have the first four characters
    equal to 0000\. In this case, we'll want to generate a new hash. So, our while
    loop will run again, the nonce value will be incremented to 2 and a new hash will
    be created. If that hash also does not start with four zeros then the `while`
    loop will run again, the nonce value will be incremented again, and the hash will
    be generated again.
  prefs: []
  type: TYPE_NORMAL
- en: Our loop will continue doing this until it winds up with a hash that starts
    with four zeros. This might take many iterations. This could happen 10 times,
    10,000 times, or 100,000 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop is where all of the calculations will take place, and this is the
    reason why the `proofOfWork` method uses so much energy – there are a lot of calculations
    being made. We''ll continue going through the `while` loop until we generate a
    suitable hash that starts with four zeros. When we finally have the correct hash,
    our `while` loop will stop running, and at the end of our proofOfWork, it will
    simply return the nonce value that gave us the valid hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So, this is how our `proofOfWork` method will work and validate the hash.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll test our `proofOfWork` method to make sure that
    it works properly. We'll also study why we return a nonce value instead of returning
    the hash.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the proofOfWork method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our `proofOfWork` method to make sure that it works properly. We''ll
    be testing the method in our `test.js` file. So, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `test.js` file. You might observe the data in a similar way to
    the following screenshot, which is present in the file from the previous section, *Testing
    the hashBlock method*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*![](img/bba3d0e1-4701-4b4d-9edc-4dab25d74b65.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have any data in the `test.js` file, add this to your `test.js`
    file, as shown in the preceding screenshot, and then you can begin testing the
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test our `proofOfWork` method, we need the `previousBlockHash` and `currentBlockData`.
    So, in our test case, get rid of the nonce value and add the following lines of
    code to our file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, what we should get as a result from this `proofOfWork` method is a nonce
    value. What our `proofOfWork` method essentially does is test to see what the
    correct nonce value is to hash with our block data and our `previousBlockHash`
    to generate a resulting block hash that starts with four zeros. Here, `proofOfWork` finds
    the correct nonce for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file and run our test by typing the `node dev/test.js` command in
    our terminal window. After the test is run, you will observe that a number pops
    up as an output on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4890a799-e9e5-4e2f-9b82-52ea58c75933.png)'
  prefs: []
  type: TYPE_IMG
- en: What this number signifies is that it took 27,470 iterations for our `proofOfWork`
    method to find a hash that starts with four zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to understand this whole process in-depth, what we can do is, inside of
    our `while` loop, log out of every hash that we try. We will have to make minor
    modifications to our `while` loop, as highlighted in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When we run our test file now, what's going to happen is we should actually
    get to see 27,000 different hashes logged out inside of our terminal. None of
    these hashes will start with four zeros, except for the last one. Only the last
    hash that gets logged out should start with four zeros because after our method,
    this will terminate and return the nonce value for which the valid hash was obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s save our `test.js` file again. You can now observe on your screen
    that we have a whole bunch of different hashes being logged out to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b29a624-1279-4b4b-b0a9-d0c8be618fc4.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also observe that for every single hash that has been logged out, the
    beginning is never four zeros in a row until we obtain our final value.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, what is happening over here is that we are generating the hash from
    our `currentBlockData`, `previousBlockHash`, and `nonce` of value 0\. Then, for
    the next hash, we are incrementing the nonce by 1. So, it's all the same input
    data, but the nonce value is incremented until the valid hash is obtained. Finally,
    at 27,470, with the value of a nonce, the valid hash is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try using our `hashBlock` method. In our `dev/test.js` file, delete
    the `proofOfWork` method and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, for the nonce let's input the value 27,470\. This value
    we obtained from our `proofOfWork` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we would observe as output is running the single hash with the correct
    nonce value that we obtained by running the `proofOfWork` method. By doing this,
    we should generate a hash that starts with four zeros on the first try. Let''s
    save it and run it. Once the test is run, you will get to observe the single hash
    that starts with four zeros, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd81285c-c159-4a11-a439-8c12ae5f37ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The `proofOfWork` is a very important part of blockchain technology. It is very
    difficult to calculate, as you can observe from the test results – it took us
    more than 27,000 iterations to generate the correct hash. Consequently, a `proofOfWork`
    takes in a lot of energy and many calculations, and is very difficult to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the correct proof or the nonce value at which the desired hash
    is generated, it should be very easy for us to verify that we have the correct
    nonce value. We can verify this by simply passing it into our `hashBlock` method –
    we would obtain the hash that starts with four zeros.
  prefs: []
  type: TYPE_NORMAL
- en: It takes a lot of work to generate a proof of work, but it is very easy to verify
    that it is correct. So, if we ever want to go back into our blockchain and check
    to make sure that a block is valid, all you have to do is hash that block's data
    with the previous block's hash and the nonce that was generated from the `proofOfWork`
    when that block was mined. If this returns a valid hash to us that starts with
    four zeros, then we already know that the block is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, from our test, we can conclude that the `proofOfWork` method works as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more thing that we would have to add to our blockchain data structure is
    the genesis block. But what is a genesis block? Well, a genesis block is simply
    the first block in any blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our genesis block, we are going to use the `createNewBlock` method
    inside of the `Blockchain()` constructor function. Go to the `dev/blockchain.js`
    file, and inside of the blockchain constructor function type in the following
    highlighted lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As we observed in the previous section, the `createNewBlock` method takes in
    the value of a nonce, a `previousBlockHash`, and a hash as parameters. Since we''re
    using the `createNewBlock` method over here to create the genesis block, we are
    not going to have any of those mentioned parameters. Instead, we''re simply going
    to pass in some arbitrary parameters, as highlighted in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we passed the nonce value as `100`, `previousBlockHash`
    as `0`, and the hash value as `0`. These are all just arbitrary values; you can
    add whatever value you wish to add.
  prefs: []
  type: TYPE_NORMAL
- en: Just be aware that it is okay to pass in such arbitrary parameters while creating
    our genesis block, but when we use the `createNewBlock` method to create new blocks,
    we'll have to pass the legitimate values for the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now save the file, and let's test the genesis block in the `test.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the genesis block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `dev/test.js` file, we will begin by importing our blockchain data structure
    or Blockchain constructor function, and then making a new instance of our blockchain
    as `bitcoin`. We''re then going to log out of the bitcoin blockchain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Save this file and run the test by typing `node dev/test.js` into the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the test, we can observe the genesis block, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90baad26-9808-4f2d-b0b3-d502b17bcc25.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, for the chain array, you can see that we have one
    block inside of the chain. This block is our genesis block and it has a nonce
    of 100, a hash of 0, and a `previousBlockHash` of `0`. Henceforth, all of our
    blockchains will have a genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began by building the constructor function and then moved 
    on to create some amazing methods such as `createNewBlock`, `creatNewTransaction`,
    `getLastBlock`, and so on. We then learned about the hashing method, SHA256 hashing,
    and created a method to generate a hash for our block data. We also learned what
    a proof of work is and how this works. In this chapter, you also got to learn
    how to test the various methods that we created and check whether they are working
    as expected. The methods that we have learned about in this chapter will be very
    useful for us in further chapters when we interact more with the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get more familiar with the blockchain data structure, it is recommended
    that you open up the `test.js` file, test all of the methods, try to play around
    with those, observe how they work together, and have fun with it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be building an API to interact with and use our blockchain.
    That's where the real fun begins.
  prefs: []
  type: TYPE_NORMAL
