- en: Chapter 6.  Angular 2 Directives in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。深入了解Angular 2指令
- en: '**Directives** are everywhere. They are the fundamental building blocks of
    Angular 2\. Each extension to the application has resulted in us creating new
    **component directives**. These component directives have further consumed **attribute
    directives** (such as `NgClass` and `NgStyle`) and **structural directives** (such
    as `NgIf` and `NgFor`) to extend their behavior.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 指令随处可见。它们是Angular 2的基本构建块。应用程序的每个扩展都导致我们创建新的**组件指令**。这些组件指令进一步使用了**属性指令**（如`NgClass`和`NgStyle`）和**结构指令**（如`NgIf`和`NgFor`）来扩展它们的行为。
- en: While we have built a number of component directives and a lone attribute directive,
    there are still some concepts of directive building that are worth exploring.
    This is especially true for attribute and structural directives, which we are
    yet to cover in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经构建了许多组件指令和一个孤立的属性指令，但仍有一些指令构建的概念值得探索。这对于属性和结构指令尤为重要，我们尚未详细介绍。
- en: 'The topics we will cover in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Building directives**: We build multiple directives and learn where directives
    are useful, how they differ from components, and how directives communicate with
    each other and/or their host component. We explore all directive types, including
    *component directives*, *attribute directives*, and *structural directives*.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建指令：我们构建多个指令，并学习指令的用途，它们与组件的区别，以及指令如何相互通信和/或与它们的宿主组件通信。我们探索所有指令类型，包括*组件指令*、*属性指令*和*结构指令*。
- en: '**Asynchronous validation**: Angular makes it easy to validate rules that require
    server interaction and hence are async in nature. We build our first async validator
    in this chapter.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步验证：Angular使得验证需要与服务器交互并且是异步的规则变得容易。我们将在本章中构建我们的第一个异步验证器。
- en: '**Using renderer for view manipulation**: Renderer allows view manipulation
    in a platform-agnostic way. We utilize renderer for the busy indicator directive
    and learn about its API.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染器进行视图操作：渲染器允许以平台无关的方式进行视图操作。我们利用渲染器来处理繁忙指示器指令，并学习其API。
- en: '**Host binding**: Host binding allows directives to communicate with their
    *host element*. This chapter covers how to utilize such bindings for directives.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宿主绑定：宿主绑定允许指令与它们的*宿主元素*进行通信。本章涵盖了如何利用这样的绑定来指令。
- en: '**Directive injection**: The Angular DI framework allows directive injection
    based on where in the HTML hierarchy the directives are declared. We will cover
    multiple scenarios pertaining to such injections.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令注入：Angular DI框架允许基于指令在HTML层次结构中声明的位置进行指令注入。我们将涵盖与此类注入相关的多种情景。
- en: '**Working with view children and content children**: Components have the capability
    to include external view templates into their own view. How to work with the injected
    content is something we will cover here.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图子组件和内容子组件一起工作：组件有能力将外部视图模板包含到它们自己的视图中。我们将在这里讨论如何处理注入的内容。
- en: '**Understanding the NgIf platform directive**: We will look under the hood
    of the `NgIf` platform directive, and try to comprehend the working of *structural
    directives* such as `NgIf`.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解NgIf平台指令：我们将深入了解`NgIf`平台指令，并尝试理解*结构指令*（如`NgIf`）的工作原理。
- en: '**View encapsulation of Angular components**: We will learn how Angular uses
    concepts derived from *web components* to support view and style encapsulation.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular组件的视图封装：我们将学习Angular如何使用从*web组件*派生的概念来支持视图和样式封装。
- en: Let's start the chapter by reiterating the basic classification of directives.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重申指令的基本分类来开始本章。
- en: Classifying directives
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令分类
- en: Angular directives integrate the HTML view with the application state. Directives
    help us manipulate views on application state changes and respond to view updates
    with little or no manual interaction with the actual DOM.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular指令将HTML视图与应用程序状态集成。指令帮助我们在应用程序状态更改时操纵视图，并在几乎没有或没有与实际DOM的手动交互的情况下响应视图更新。
- en: Depending upon how they affect the view, these directives are further classified
    into three types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们对视图的影响方式，这些指令进一步分为三种类型。
- en: Components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: '**Component directives** or **components** are directives with an encapsulated
    view. In Angular, when we build UI widgets, we are building components. We have
    already built a lot of them, such as `WorkoutRunner`, `WorkoutAudio`, `WorkoutBuilder`,
    and many more!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 组件指令或组件是具有封装视图的指令。在Angular中，当我们构建UI小部件时，我们正在构建组件。我们已经构建了很多，比如`WorkoutRunner`，`WorkoutAudio`，`WorkoutBuilder`等等！
- en: An important point to realize here is that the view is bound to the *component*
    implementation and can only work with properties and events defined on the backing
    component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要意识到的一个重要点是，视图绑定到*组件*实现，并且只能使用在支持组件上定义的属性和事件。
- en: Attribute directives
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性指令
- en: '**Attribute directives**, on the other hand, extend an existing component or
    HTML element. Consider them as behavioral extensions to these components/elements.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令，另一方面，扩展了现有组件或HTML元素。将它们视为这些组件/元素的行为扩展。
- en: Since directives are behavioral extensions for predefined elements, every directive
    building exercise involves manipulating the state of the components/elements on
    which these directives are applied. The `MyAudioDirective` built in [Chapter 3](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth"), *More Angular
    2 –€“ SPA, Routing, and Data Flows in Depth*, does the same. The directive wraps
    the HTML 5 *audio* element (`HTMLAudioElement`) for easy usage. Platform directives
    such as `ngStyle` and `ngClass` also function in a similar manner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令是预定义元素的行为扩展，每个指令构建练习都涉及操纵应用这些指令的组件/元素的状态。在[第3章](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "第3章。更多Angular 2-SPA，路由和深入数据流")中构建的`MyAudioDirective`，*更多Angular 2-SPA，路由和深入数据流*，也是如此。该指令包装了HTML
    5 *audio*元素（`HTMLAudioElement`）以便于使用。平台指令如`ngStyle`和`ngClass`也以类似的方式工作。
- en: Structural directives
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构指令
- en: '**Structural directives**, like attribute directives, do not define their own
    view. Instead, they work on the *view template* (HTML fragment) provided to them
    as part of their usage. More often than not, the purpose of a structural directive
    is to show/hide or clone the template view provided to it. Platform directives
    such as `NgFor`, `NgIf`, and `NgSwitch` are the prime examples in this category.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令，像属性指令一样，不定义自己的视图。相反，它们在作为其一部分提供的*视图模板*（HTML片段）上工作。往往，结构指令的目的是显示/隐藏或克隆提供给它的模板视图。平台指令如`NgFor`，`NgIf`和`NgSwitch`就是这一类别中的主要例子。
- en: Hope this quick refresher on directives is enough to get us started. We'll begin
    our pursuit by extending the workout builder validations and build an async validator
    directive.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个关于指令的快速复习足以让我们开始。我们将通过扩展锻炼构建器验证并构建一个异步验证器指令来开始我们的追求。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are starting from where we left off in [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*.
    The Git branch `checkpoint5.4` can serve as the base for this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们在[第5章](part0056.xhtml#aid-1LCVG2 "第5章。支持服务器数据持久性")中停下的地方开始，*支持服务器数据持久性*。Git分支`checkpoint5.4`可以作为本章的基础。
- en: The code is also available on GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint2.4` (a zip file) from
    the GitHub location [http://bit.ly/ng2be-checkpoint5-4](http://bit.ly/ng2be-checkpoint5-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可以在GitHub上找到（[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)），供所有人下载。检查点在GitHub中作为分支实现。如果您不使用Git，请从GitHub位置[http://bit.ly/ng2be-checkpoint5-4](http://bit.ly/ng2be-checkpoint5-4)下载`checkpoint2.4`的快照（一个zip文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Also remember to update the API key in `services/workout-service.ts` with your
    own API key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在`services/workout-service.ts`中更新API密钥为您自己的API密钥。
- en: Building a remote validator directive
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个远程验证器指令
- en: We ended [Chapter 5](part0056.xhtml#aid-1LCVG2 "Chapter 5.  Supporting Server
    Data Persistence"), *Supporting Server Data Persistence*, with *Workout Runner* capable of
    managing workouts in the MongoDB store. Since each workout should have a unique
    name, we need to enforce the uniqueness constraint. Therefore, while creating/editing
    a workout, every time the user changes the workout name, we can query MongoDB
    to verify that the name already exists.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](part0056.xhtml#aid-1LCVG2 "Chapter 5.  Supporting Server Data Persistence")结束了*支持服务器数据持久性*，*Workout
    Runner*能够在MongoDB存储中管理训练。由于每个训练应该有一个唯一的名称，我们需要强制执行唯一性约束。因此，在创建/编辑训练时，每当用户更改训练名称时，我们可以查询MongoDB来验证该名称是否已经存在。
- en: As is the case with any remote invocation, this check too is asynchronous, and
    hence it requires a *remote validator*. We are going to build this remote validator
    using Angular's *async validator support*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何远程调用一样，这个检查也是异步的，因此它需要一个*远程验证器*。我们将使用Angular的*异步验证器支持*来构建这个远程验证器。
- en: '**Async validators** are similar to standard custom validators, except that
    instead of returning a key-value object map or null, the return value of a validation
    check is a **promise**. This promise is eventually resolved with the validation
    state being set (if there is an error), or null otherwise (on validation success).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步验证器**与标准自定义验证器类似，只是返回值不是键值对象映射或null，而是验证检查的返回值是一个**promise**。这个promise最终会解析为设置的验证状态（如果有错误），否则为null（验证成功时）。'
- en: 'We are going to create a validation directive that does workout name checks.
    There are two possible implementation approaches for such a directive:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个验证指令，用于进行训练名称检查。对于这样的指令，有两种可能的实现方法：
- en: We can create a directive specifically for unique name validation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个专门用于唯一名称验证的指令
- en: We can create a generic directive that can perform any remote validation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个通用指令，可以执行任何远程验证
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Validation directives** While we are building a validation directive here,
    we could have built a standard custom validator class. The advantage of creating
    a directive is that it allows us to incorporate the directive in a template-driven
    form approach, where the directive can be embedded in the view HTML. Or, if the
    form has been generated using a model (model-driven approach), we can directly
    use the validator class while creating the `Control` objects.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证指令**虽然我们在这里构建了一个验证指令，但我们也可以构建一个标准的自定义验证器类。创建指令的优势在于它允许我们将指令纳入模板驱动的表单方法中，在那里指令可以嵌入到视图HTML中。或者，如果表单是使用模型生成的（模型驱动方法），我们可以在创建`Control`对象时直接使用验证器类。'
- en: At first, the requirement of checking duplicate names against a data source
    (the mLab database) seems to be too a specific requirement and cannot be handled
    by a generic validator. But with some sensible assumptions and design choices,
    we can still implement a validator that can handle all types of remote validation,
    including workout name validation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，检查重复名称是否来自数据源（mLab数据库）似乎是一个太具体的要求，不能由通用验证器处理。但通过一些明智的假设和设计选择，我们仍然可以实现一个可以处理所有类型的远程验证的验证器，包括锻炼名称验证。
- en: The plan is to create a validator that externalizes the actual validation logic.
    The directive will take the validation function as input. This implies that the
    actual validation logic is not a part of the validator but a part of the component
    that actually needs to validate input data. The job of the directive is just to
    call the function and return the appropriate error keys based on the function's
    return value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是创建一个将实际验证逻辑外部化的验证器。指令将接受验证函数作为输入。这意味着实际验证逻辑不是验证器的一部分，而是实际需要验证输入数据的组件的一部分。指令的工作只是调用函数并根据函数的返回值返回适当的错误键。
- en: Let's put this theory into practice and build our remote validation directive,
    aptly named `RemoteValidatorDirective`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个理论付诸实践，构建我们的远程验证指令，恰当地命名为`RemoteValidatorDirective`。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The companion code base for the following section is Git branch `checkpoint6.1`.
    You can work along with us or check out the implementation available in the aforementioned
    folder. Or if you are not using Git, download the snapshot of `checkpoint6.1`
    (a zip file) from GitHub location [http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分的伴随代码基于Git分支`checkpoint6.1`。您可以与我们一起工作，或者查看前述文件夹中可用的实现。或者，如果您不使用Git，请从GitHub位置[http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1)下载`checkpoint6.1`的快照（zip文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Validating workout names using async validator
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步验证器验证锻炼名称
- en: Like custom validators, async validators too inherit from the same `Validator`
    class; but this time, instead of returning an object map, async validators return
    a `Promise`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义验证器一样，异步验证器也继承自相同的`Validator`类；但这次，异步验证器返回一个`Promise`而不是返回对象映射。
- en: 'Let''s look at the definition of the validator. Create a file, `remote-validator.directive.ts`,
    in the `workout-builder/shared` folder and add this `RemoteValidatorDirective`
    implementation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下验证器的定义。在`workout-builder/shared`文件夹中创建一个文件`remote-validator.directive.ts`，并添加这个`RemoteValidatorDirective`实现：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we are registering the validator as a directive instead of registering
    using a `FormControl` instance (generally used when building forms with a *model-driven
    approach*), we need the extra provider configuration setting (added in the preceding
    `@Directive` metadata) by using this syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将验证器注册为指令，而不是使用`FormControl`实例进行注册（通常在使用*模型驱动方法*构建表单时使用），因此我们需要额外的提供者配置设置（在前述`@Directive`元数据中添加）。使用这种语法：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This statement registers the validator with the existing async validators.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句注册了验证器与现有的异步验证器。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The strange directive selector, `selector: `[a2beRemoteValidator][ngModel]``
    used in the preceding code will be covered in the next section, where we will
    build a busy indicator directive.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中使用的奇怪指令选择器`selector: `[a2beRemoteValidator][ngModel]``将在下一节中进行讨论，我们将构建一个繁忙指示器指令。'
- en: Before we dig into the validator implementation, let's add it to the workout
    name input. This will help us correlate the behavior of the validator with its
    usage.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入验证器的实现之前，让我们将其添加到锻炼名称输入中。这将帮助我们将验证器的行为与其使用相关联。
- en: 'Update the workout name input (`workout.component.html`) with the validator
    declaration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用验证声明更新训练名称输入（`workout.component.html`）：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And add the customary declaration for the validation directive to the workout
    builder module (`workout-builder.module.ts`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并在训练构建器模块（`workout-builder.module.ts`）中添加验证指令的习惯声明：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The remote validator is referenced in the view as `a2beRemoteValidator`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 远程验证器在视图中被引用为`a2beRemoteValidator`。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Prefixing the directive selector**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**为指令选择器添加前缀**'
- en: Always prefix your directives with an identifier (`a2be` as you just saw) that
    distinguishes them from framework directives and other third-party directives.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用标识符（如你刚才看到的`a2be`）为你的指令添加前缀，以将它们与框架指令和其他第三方指令区分开来。
- en: 'The directive implementation takes two inputs: the validation key (`validationKey`)
    used to set the *error key*, and the validation function called to validate the
    value of the control. Both inputs are annotated with the `@Input` decorator.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指令实现接受两个输入：用于设置*error key*的验证键（`validationKey`）和用于验证控件值的验证函数。这两个输入都使用`@Input`装饰器进行了注释。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The input parameter `@Input("validateFunction") execute: (value: string) =>
    Promise<boolean>;`, binds to a function, not a standard component property. We
    are allowed to treat the function as a property due to the nature of the underlying
    language, TypeScript (as well as JavaScript).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '输入参数`@Input("validateFunction") execute: (value: string) => Promise<boolean>;`，绑定到一个函数，而不是一个标准的组件属性。由于底层语言
    TypeScript（以及 JavaScript）的特性，我们可以将函数视为属性。'
- en: 'When the async validation fires (on a change of `input`), Angular invokes the
    `validate` function, passing in the underlying `control`. As the first step, we
    pull the current input value and then invoke the `execute` function with this
    input. The `execute` function returns a promise, which should eventually resolve
    to `true` or `false`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步验证触发时（在`input`的更改上），Angular调用`validate`函数，传入底层的`control`。作为第一步，我们提取当前的输入值，然后使用这个输入调用`execute`函数。`execute`函数返回一个promise，最终应该解析为`true`或`false`：
- en: If it is `true`, the validation is successful, the promise callback function
    returns `null`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`true`，则验证成功，promise回调函数返回`null`。
- en: If it is `false`, the validation has failed, and an error key-value map is returned.
    The *key* here is the string literal that we set when using the validator (`a2beRemoteValidator="workoutname"`).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`false`，则验证失败，并返回一个错误的键值映射。这里的*key*是我们在使用验证器时设置的字符串字面量（`a2beRemoteValidator="workoutname"`）。
- en: This *key* comes in handy when there are multiple validators declared on the
    input, allowing us to identify validations that have failed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入上声明了多个验证器时，这个*key*就派上了用场，允许我们识别哪些验证失败了。
- en: 'Let''s add a validation message for this failure too. Add this label declaration
    after the existing validation `label` for *workout name*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为这个失败添加一个验证消息。在*workout name*的现有验证`label`之后添加这个标签声明：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And then wrap these two labels inside a `div`, as we do for *workout title*
    error labels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这两个标签包裹在一个`div`中，就像我们为*workout title*的错误标签所做的那样。
- en: The `hasError` function checks whether the `'workoutname'` validation key is
    present.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasError`函数检查`''workoutname''`验证键是否存在。'
- en: The last missing piece of this implementation is the actual validation function
    we assigned when applying the directive (`[validateFunction]="validateWorkoutName"`)
    but never implemented.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的最后一个缺失的部分是我们在应用指令时分配的实际验证函数(`[validateFunction]="validateWorkoutName"`)，但从未实现过。
- en: 'Add the `validateWorkoutName` function to `workout.component.ts`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将`validateWorkoutName`函数添加到`workout.component.ts`中：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we explore what the preceding function does, we need to do some more
    fixes on `WorkoutComponent` class. The `validateWorkoutName` function is dependent
    on `WorkoutService` to get a workout with a specific name. Let''s inject the service
    in the constructor and add the necessary import in the imports section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索前面的函数所做的事情之前，我们需要在`WorkoutComponent`类上进行一些修复。`validateWorkoutName`函数依赖于`WorkoutService`来获取特定名称的锻炼。让我们在构造函数中注入该服务，并在导入部分添加必要的导入：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s also update the `ngOnInit` function and convert the local variable `workoutName`
    into a *class member*. Declare `workoutName` with other class members:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还更新`ngOnInit`函数，并将本地变量`workoutName`转换为*类成员*。在其他类成员中声明`workoutName`：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the first statement inside the `else` statement to:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将`else`语句内的第一条语句更改为：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And use the same variable later during the `startBuildingExisting` function
    call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`startBuildingExisting`函数调用期间使用相同的变量。
- en: The first `if` condition in `validateWorkoutName` is for the update scenario.
    We obviously do not want to validate the existing workout name. The `return Promise.resolve(true);`
    statement returns a promise that always resolves to `true`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateWorkoutName`中的第一个`if`条件是用于更新场景。显然，我们不希望验证现有的锻炼名称。`return Promise.resolve(true);`语句返回一个始终解析为`true`的promise。'
- en: The reason for defining the `validateWorkoutName` function as an *instance function*
    (the use of the *arrow operator*) instead of defining it as a standard function
    (which declares the function on the *prototype*) is the '`this'` scoping issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将`validateWorkoutName`函数定义为*实例函数*（使用*箭头运算符*）而不是定义为标准函数（在*原型*上声明函数）的原因是`this`作用域问题。
- en: 'Look at the validator function invocation inside `RemoteValidatorDirective`
    (declared using `@Input("validateFunction") execute;`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`RemoteValidatorDirective`内部的验证函数调用（使用`@Input("validateFunction") execute;`声明）：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the function (named `execute`) is invoked, the `this` reference is bound
    to `RemoteValidatorDirective` instead of the `WorkoutComponent`. Since `execute`
    is referencing the `validateWorkoutName` function in the preceding setup, any
    access to `this` inside `validateWorkoutName` is problematic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数（名为`execute`）时，`this`引用绑定到`RemoteValidatorDirective`而不是`WorkoutComponent`。由于`execute`引用了前面设置中的`validateWorkoutName`函数，所以在`validateWorkoutName`内部访问`this`是有问题的。
- en: This causes the `if (this.workoutName === name)` statement inside `validateWorkoutName`
    to fail, as `RemoteValiatorDirective` does not have a `workoutName` instance member.
    By defining `validateWorkoutName` as an instance function, the *TypeScript* compiler
    *creates a closure* around the value of `this` when the function is defined.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致`validateWorkoutName`内部的`if (this.workoutName === name)`语句失败，因为`RemoteValiatorDirective`没有`workoutName`实例成员。通过将`validateWorkoutName`定义为实例函数，*TypeScript*编译器在函数定义时*创建了一个闭包*，围绕`this`的值。
- en: With the new declaration, the `this` inside `validateWorkoutName` always points
    to the `WorkoutComponent` irrespective of how the function gets invoked.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新的声明，`validateWorkoutName`内部的`this`始终指向`WorkoutComponent`，无论函数如何被调用。
- en: 'We can also look at the compiled JavaScript for `WorkoutComponent` to know
    how the closure works with respect to `validateWorkoutName`. The parts of the
    generated code that interest us are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看`WorkoutComponent`的编译JavaScript，以了解闭包如何与`validateWorkoutName`相关。我们感兴趣的生成代码部分如下：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we look at the validation function implementation, we see that it involves
    querying *mLab* for a specific workout name. The `validateWorkoutName` function
    returns `true` when a workout with the same name is not found and `false` when
    a workout with the same name is found (actually a *promise* is returned).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getWorkout` function on `WorkoutService` returns an *observable* but we
    convert it into a *promise* by calling the `toPromise` function on the observable.
    We need a promise object as `RemoteValidatorDirective` requires a promise to be
    returned from the validator function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation directive can now be tested. Create a new workout and enter
    an existing workout name such as `7minworkout`. See how the validation error message
    shows up eventually:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating workout names using async validator](../Images/image00390.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Excellent! It looks great, but there is still something missing. The user is
    not informed that we are validating the workout name. We can improve this experience.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Building a busy indicator directive
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the workout name is being validated remotely, we want the user to be aware
    of the activity in the background. A visual clue around the input box while the
    remote validation happens should serve the purpose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully; there is an input box with an asynchronous validator (which
    does remote validation) and we want to adorn the input box with a visual clue
    during validation. Seems like a common pattern to solve? Indeed it is, so let's
    create another directive!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we start, it is imperative to understand that we are not into it
    alone. The busy indicator directive requires the help of another directive, `NgModel`.
    We have already used the `NgModel` directive on `input` elements in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*. `NgModel` helps
    us track the input element state. The following example taken from [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*, highlights how `NgModel`
    helps us validate inputs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even the error label for the unique workout name validation done in the previous section
    employs the same technique of using `NgModel` to check the validation state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with defining the outline of the directive, along with the decorator
    metadata. Create a `busy-indicator.directive.ts` file in the `workout-builder/shared`
    folder, and add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义指令的大纲和装饰器元数据开始。在`workout-builder/shared`文件夹中创建一个`busy-indicator.directive.ts`文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The directive selector metadata specifies that the busy indicator will be applied
    to elements/components having the `a2beBusyIndicator` attribute.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 指令选择器元数据指定繁忙指示器将应用于具有`a2beBusyIndicator`属性的元素/组件。
- en: Add this directive to the declaration section of the workout builder module
    (`workout-builder.module.ts`) before proceeding any further.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，将此指令添加到锻炼构建器模块（`workout-builder.module.ts`）的声明部分。
- en: 'The only point of interest in the preceding code is Angular DI injecting the
    `NgModel` directive associated with the `input` element. Remember that the `NgModel`
    directive is already present on `input` (`workoutname`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中唯一值得关注的是Angular DI注入与`input`元素关联的`NgModel`指令。请记住，`NgModel`指令已经存在于`input`（`workoutname`）上：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is enough to integrate our new directive in the workout view, so let's
    do it quickly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以将我们的新指令集成到锻炼视图中，所以让我们快速做一下。
- en: 'Open `workout.component.html` from `workout-builder` and add the busy indicator
    directive to the workout name `input`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从`workout-builder`中打开`workout.component.html`并将繁忙指示器指令添加到锻炼名称`input`中：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a new workout or open an existing one to see whether the `BusyIndicatorDirective`
    is loaded and the `NgModel` injection worked fine. This can be easily verified
    by putting a breakpoint inside the `BusyIndicatorDirective` constructor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的锻炼或打开一个现有的锻炼，看看`BusyIndicatorDirective`是否被加载，并且`NgModel`注入是否正常工作。这可以通过在`BusyIndicatorDirective`构造函数内设置断点来轻松验证。
- en: Angular injects the same `NgModel` instance into `BusyIndicatorDirective` that
    it created when it encountered `ngModel` on the input HTML.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将相同的`NgModel`实例注入到`BusyIndicatorDirective`中，当它遇到输入HTML上的`ngModel`时创建了它。
- en: 'You may be wondering what happens if we apply this directive on an input element
    that does not have the `ngModel` attribute, or as a matter of fact on any HTML
    element/component, such as this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，如果我们在没有`ngModel`属性的输入元素上应用此指令，或者实际上在任何HTML元素/组件上应用此指令，会发生什么，比如这样：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Will the injection work?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注入会起作用吗？
- en: 'Of course not! We can try it on the create workout view. Open `workout.component.html`
    and add the following `input` above the workout name `input`. Refresh the app:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不是！我们可以在创建锻炼视图上尝试。打开`workout.component.html`并在锻炼名称`input`上方添加以下`input`。刷新应用程序：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Angular throws an exception, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Angular抛出异常，如下所示：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to avoid this? Well, Angular's DI can rescue us here as it allows us to
    declare an optional dependency.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免这种情况？嗯，Angular的DI可以在这里拯救我们，因为它允许我们声明一个可选的依赖项。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remove the `input` control you just added before proceeding further.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前删除您刚刚添加的`input`控件。
- en: Injecting optional dependencies with the @Optional decorator
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@Optional装饰器注入可选依赖项
- en: Angular has an `@Optional` decorator, which when applied to a constructor argument
    instructs the Angular *injector* to inject `null` if the dependency is not found.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有一个`@Optional`装饰器，当应用到构造函数参数时，指示Angular *注入器*在找不到依赖项时注入`null`。
- en: 'Hence, the busy indicator constructor can be written as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，繁忙指示器构造函数可以编写如下：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Problem solved? Not really; as stated previously, we require the `NgModel` directive
    for `BusyIndicatorDirective` to work. So, while we have learned something new,
    it is not very useful in the current scenario.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决了吗？实际上并没有；如先前所述，我们需要`NgModel`指令才能使`BusyIndicatorDirective`正常工作。因此，虽然我们学到了一些新东西，但在当前情况下并不是非常有用。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding further, remember to revert the `workoutnameinput` to its
    original state, with `a2beBusyIndicator` applied.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住将`workoutnameinput`恢复到原始状态，应用`a2beBusyIndicator`。
- en: '`BusyIndicatorDirective` should only to be applied if there is an `NgModel`
    directive already present on the element.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusyIndicatorDirective`只有在元素上已经存在`NgModel`指令时才能应用。'
- en: 'The `selector` directive is going to save our day this time. Update the `BusyIndicatorDirective`
    selector to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这次`selector`指令将拯救我们。将`BusyIndicatorDirective`的选择器更新为：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This selector creates the `BusyIndicatorDirective` only if the combination of
    `a2beBusyIndicator` with the `ngModel` attribute is present on the element. Problem
    solved!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此选择器仅在元素上同时存在`a2beBusyIndicator`和`ngModel`属性的组合时才创建`BusyIndicatorDirective`。问题解决了！
- en: It's now time to add the actual implementation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加实际的实现了。
- en: Implementation 1 - using renderer
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现1-使用渲染器
- en: 'For `BusyIndicatorDirective` to work, it needs to know when the async validation
    on the `input` fires and when it is over. This information is only available with
    the `NgModel` directive. `NgModel` has a property, `control`, which is an instance
    of the `Control` class. It is this `Control` class that tracks the current state
    of the input, including the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`BusyIndicatorDirective`起作用，它需要知道`input`上的异步验证何时触发以及何时结束。这些信息只能通过`NgModel`指令获得。`NgModel`有一个属性`control`，它是`Control`类的一个实例。正是这个`Control`类跟踪输入的当前状态，包括以下内容：
- en: Currently assigned validators (sync and async)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前分配的验证器（同步和异步）
- en: The current value
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前值
- en: The input element state, such as `pristine`, `dirty`, and `touched`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入元素状态，如`pristine`、`dirty`和`touched`
- en: The input validation state, which could be any one of `valid`, `invalid`, or
    `pending` in the case of validation being performed asynchronously
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证状态，可能是`valid`、`invalid`或在异步执行验证时是`pending`
- en: Events that track when the value changes or the validation state changes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪值更改或验证状态更改的事件。
- en: '`Control` seems to be a useful class, and it''s the `pending` state that interests
    us!'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control`类似乎是一个有用的类，我们感兴趣的是`pending`状态！'
- en: 'Let''s add our first implement for `BusyIndicatorDirective` class. Update the
    class with this code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`BusyIndicatorDirective`类添加第一个实现。使用以下代码更新类：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Two new dependencies need to be added to the constructor, as we use them in
    the `ngAfterViewInit` function. Update the `BusyIndicatorDirective` constructor
    to look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中需要添加两个新的依赖项，因为我们在`ngAfterViewInit`函数中使用它们。将`BusyIndicatorDirective`的构造函数更新为以下内容：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And also add imports for `ElementRef` and `Renderer` in `'@angular/core'`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在`'@angular/core'`中为`ElementRef`和`Renderer`添加导入。
- en: '`ElementRef` is a wrapper object over the underlying HTML element (`input`
    in this case). The `MyAudioDirective` directive built in [Chapter 3](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth"), *More Angular
    2 – SPA, Routing, and Data Flows in Depth*, used `ElementRef` to get hold of the
    underlying `Audio` element.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementRef`是对底层HTML元素（在本例中为`input`）的包装对象。[第3章](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "第3章。更多Angular 2-SPA，路由和深入数据流")中构建的`MyAudioDirective`指令，*更多Angular 2-SPA，路由和深入数据流*，使用`ElementRef`来获取底层的`Audio`元素。'
- en: The `Renderer` injection deserves a bit of attention. Calling `setElementStyle`
    is a dead giveaway that `Renderer` is responsible for managing the DOM. But before
    we delve more deeply into the role of `Renderer`, let's try to understand what
    the preceding code is doing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer`注入值值得一提。调用`setElementStyle`是`Renderer`负责管理DOM的明显迹象。但在更深入地探讨`Renderer`的角色之前，让我们试着理解前面的代码在做什么。'
- en: In the preceding code, the `control` property on the model (the `NgModel` instance)
    defines an event (an `Observable`), `statusChanges`, which we can subscribe to
    in order to know when the control validation state changes. The available validation
    states are `valid`, `invalid`, and `pending`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，模型（`NgModel`实例）上的`control`属性定义了一个事件（一个`Observable`），`statusChanges`，我们可以订阅它以了解控件验证状态何时更改。可用的验证状态是`valid`，`invalid`和`pending`。
- en: The subscription checks whether the control state is `pending` or not, and accordingly
    adorns the underlying element using the `Renderer` API function, `setElementStyle`.
    We set the `border-width` and `border-color` of the input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅检查控件状态是否为`pending`，并相应地使用`Renderer` API函数`setElementStyle`装饰底层元素。我们设置输入的`border-width`和`border-color`。
- en: The preceding implementation is added to the `ngAfterViewInit` directive lifecycle
    hook, which is called after the view has initialized.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现添加到`ngAfterViewInit`指令生命周期钩子中，在视图初始化后调用。
- en: Let's try it out. Open the create workout page or the existing *7 Minute Workout*.
    As soon as you start typing/editing the workout name, the `input` style changes
    and reverts once the remote validation of the workout name is complete. Nice!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下。打开创建锻炼页面或现有的*7分钟锻炼*。一旦开始输入/编辑锻炼名称，`input`样式就会更改，并在锻炼名称的远程验证完成后恢复。不错！
- en: '![Implementation 1 - using renderer](../Images/image00391.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![实现1-使用渲染器](../Images/image00391.jpeg)'
- en: 'Before moving forward, also add the un-subscription code to the `BusyIndicatorDirective`
    to avoid memory leak. Add this function to `BusyIndicatorDirective`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还要将取消订阅代码添加到`BusyIndicatorDirective`中，以避免内存泄漏。将此函数添加到`BusyIndicatorDirective`中：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Always unsubscribe from observables**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终取消订阅可观察对象**'
- en: Always remember to unsubscribe from any `Observable`/`EventEmitter` subscription
    done in the code to avoid memory leak.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得取消对代码中已完成的任何`Observable`/`EventEmitter`订阅，以避免内存泄漏。
- en: The implementation looks good. The `Renderer` is doing its job. But there are
    some unanswered questions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来不错。`Renderer`正在发挥作用。但还有一些未解答的问题。
- en: Why not just get hold of the underlying DOM object and use the standard DOM
    API to manipulate the input styles? Why do we need the *renderer*?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接获取底层DOM对象并使用标准DOM API来操作输入样式？为什么我们需要*渲染器*？
- en: Angular renderer, the translation layer
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular渲染器，翻译层
- en: One of the primary design goals of Angular 2 was to make it run across environments,
    frameworks, and devices. Angular enabled this by dividing the core framework implementation
    into an application layer and a rendering layer. The application layer has the
    API we interact with, whereas the rendering layer provides an abstraction that
    the application layer can use without worrying about how and where the actual
    view is being rendered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2的主要设计目标之一是使其在各种环境、框架和设备上运行。Angular通过将核心框架实现分为应用程序层和渲染层来实现这一点。应用程序层具有我们与之交互的API，而渲染层提供了一个抽象，应用程序层可以使用它而不必担心实际视图是如何以及在哪里被渲染的。
- en: 'By separating the rendering layer, Angular can theoretically run in various
    setups. These include (but are not limited to):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离渲染层，Angular理论上可以在各种设置中运行。这些包括（但不限于）：
- en: Browser
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: Browser main thread and web worker thread, for obvious performance reasons
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器主线程和Web Worker线程，出于明显的性能原因
- en: Server-side rendering
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Native app frameworks; efforts are underway to integrate Angular 2 with `NativeScript`
    with `ReactNative`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生应用程序框架；正在努力将Angular 2与`NativeScript`和`ReactNative`集成
- en: Testing, allowing us to test the app UI outside the web browser
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，允许我们在Web浏览器之外测试应用程序UI
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Renderer` implementation that Angular uses inside our browser is `DOMRenderer`.
    It is responsible for translating our API calls into browser DOM updates. In fact,
    we can verify the renderer type by adding a breakpoint in the `BusyIndicatorDirective`'s
    constructor and seeing the value of `renderer`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在浏览器内部使用的`Renderer`实现是`DOMRenderer`。它负责将我们的API调用转换为浏览器DOM更新。事实上，我们可以通过在`BusyIndicatorDirective`的构造函数中添加断点并查看`renderer`的值来验证渲染器类型。
- en: 'For this precise reason, we avoid direct manipulation of DOM elements inside
    `BusyIndicatorDirective`. You never know where the code will end up running. We
    could have easily done this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个确切的原因，我们避免在`BusyIndicatorDirective`内部直接操作DOM元素。你永远不知道代码最终会在哪里运行。我们本来可以轻松地这样做：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead, we used the `Renderer` to do the same in a platform-agnostic way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用`Renderer`以一种与平台无关的方式来做同样的事情。
- en: 'Look at the `Renderer` API function `setElementStyle`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`Renderer` API函数`setElementStyle`：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It takes the element on which the style has to be set, the style property to
    update, and the value to set. The `element` references the `input` element injected
    into `BusyIndicatorDirective`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要设置样式的元素，要更新的样式属性和要设置的值。`element`引用了注入到`BusyIndicatorDirective`中的`input`元素。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Resetting styles**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**重置样式**'
- en: Styles set by calling `setElementStyle` can be reset by passing a `null` value
    in the third argument. Check out the `else` condition in the preceding code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`setElementStyle`设置的样式可以通过在第三个参数中传递`null`值来重置。查看前面代码中的`else`条件。
- en: The `Renderer` API has a number of other methods that can be used to set attributes,
    set properties, listen to events, and even create new views. Whenever you build
    a new directive, remember to evaluate the `Renderer` API for DOM manipulation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer` API还有许多其他方法，可以用来设置属性，设置属性，监听事件，甚至创建新视图。每当你构建一个新的指令时，记得评估`Renderer`
    API来进行DOM操作。'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A more detailed explanation of `Renderer` and its application is available
    as part of Angular''s design documents here: [http://bit.ly/ng2-render](http://bit.ly/ng2-render)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Renderer`及其应用的更详细解释，请参阅Angular设计文档的一部分：[http://bit.ly/ng2-render](http://bit.ly/ng2-render)
- en: We are not done yet! With Angular's awesomeness, we can improve the implementation.
    Angular allows us to do *host binding* in directive implementation, helping us
    avoid a lot of boilerplate code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！借助Angular的强大功能，我们可以改进实现。Angular允许我们在指令实现中进行*宿主绑定*，帮助我们避免大量的样板代码。
- en: Host binding in directives
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令中的宿主绑定
- en: 'In the Angular realm, the component/element that a directive gets attached
    to is termed the **host element**: a container that hosts our directive/component.
    For the `BusyIndicatorDirective`, the `input` element is the *host*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular领域，指令附加到的组件/元素被称为**宿主元素**：承载我们的指令/组件的容器。对于`BusyIndicatorDirective`，`input`元素是*宿主*。
- en: While we can use the `Renderer` to manipulate the host (and we did too), the
    Angular data binding infrastructure can reduce the boilerplate code further. It
    provides a declarative way to manage directive-host interaction. Using the host
    binding concepts, we can manipulate an element's *properties* and *attributes*
    and subscribe to its *events*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`Renderer`来操作宿主（我们也这样做了），但是Angular数据绑定基础设施可以进一步减少样板代码。它提供了一种声明性的方式来管理指令-宿主交互。使用宿主绑定概念，我们可以操作元素的*属性*和*属性*，并订阅其*事件*。
- en: Let's understand each of the host binding capabilities, and at the end, we will
    fix our `BusyIndicatorDirective` implementation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个宿主绑定的能力，最后，我们将修复我们的`BusyIndicatorDirective`实现。
- en: Property binding using @HostBinding
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@HostBinding进行属性绑定
- en: Use **host property binding** to bind a *directive property* to a *host element
    property*. Any changes to the directive property will be synced with the linked
    host property during the change detection phase.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to use the `@HostBinding` decorator on the directive property
    that we want to sync with. For example, consider this binding:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When applied to `input`, it will set the `inputreadOnly` property to `true`
    when the `isbusy` directive property is `true`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `readonly` is also an attribute on `input`. What we are referring
    to here is the input property `readOnly`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Attribute binding** binds a directive property to a host component attribute.
    For example, consider a directive with binding like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If applied to input, it will add the `disabled` attribute on `input` when the
    `isAdmin` flag is `false`, and clear it otherwise. We follow the same attribute
    binding notation used in the HTML template here too. The attribute name is prefixed
    with string literal `attr`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do something similar with *class* and *style binding* too. Consider
    the following line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This line sets up a class binding, and the following line creates a style binding:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Event binding
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lastly, **event binding** is used to subscribe to the events raised by the
    host component/element. Consider this example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sets up a listener on the host event `click`. Angular will instantiate
    the preceding directive for every *button*, *div*, *span*, and *input* on the
    view and set up the host binding with the `onClick` function. The `$event` variable
    contains the event data for the event raised, and `target` refers to the element/component
    that was clicked on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bindings work for components too. Consider the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this directive, we track the `workoutStarted` event defined on the `WorkoutRunner`
    component. The `onWorkoutStarted` function is called when the workout starts,
    with the details of the started workout.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how these bindings work, we can improve our `BusyIndicatorDirective`
    implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Implementation 2 - BusyIndicatorDirective with host bindings
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have already guessed it! We will use *host property binding* instead
    of `Renderer` to set styles. Want to give it a try? Go ahead! Clear the existing
    implementation and try to set up a host binding for the `borderWidth` and `borderColor`
    style attributes without looking at the following implementation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the directive will look after the host binding implementation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have moved the `pending` state check into a directive property called `validating`
    and then used the `controlBorderWidth` and `controlBorderColor` properties for
    style binding. This is definitely more succint than our earlier approach! Go test
    it out.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we tell you that this can be done without the need for a custom directive,
    don''t be surprised. This is how we do it, just by using style bindings on the
    workout name `input`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We get the same effect!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: No, our effort did not go to waste. We did learn about **renderer** and **host
    binding**. These concepts will come in handy while building directives that provide
    complex behavior extension instead of just setting element styles.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint6.1`
    for a working version of what we have done thus far. Or if you are not using Git,
    download the snapshot of `checkpoint6.1` (a zip file) from [http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The next topic that we are going to take up is *directive injection*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Directive injection
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go back a few pages and look at the `BusyIndicatorDirective` implementation
    that uses the renderer, specifically the constructor:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Angular automatically locates the `NgModel` directive created for the current
    element and injects it into `BusyIndicatorDirective`. This is possible because
    both directives are declared on the same *host element*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that we can influence this behavior. Directives created on
    a parent HTML tree or child tree can also be injected. The next few sections talk
    about how to inject directives across the component tree, a very handy feature
    that allows cross-directive communication for directives that have a *common lineage*
    (in a view).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We will use Plunker ([http://bit.ly/ng2be-directive-tree](http://bit.ly/ng2be-directive-tree))
    to demonstrate these concepts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, look at the Plunker file `app.component.ts`. It has three directives:
    `Relation`, `Acquaintance`,and `Consumer` €”and this view hierarchy is defined:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next few sections, we describe the various ways in which we can inject
    the different `relation` and `Acquaintance` directives into the `consumer` directive.
    Check out the browser console for the injected dependencies that we log during
    the `ngAfterViewInit` lifecycle hook.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Injecting directives defined on the same element
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructor injection by default supports injecting directives defined on the
    same element. The constructor function just needs to declare the directive type
    variable that we want to inject:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `NgModel` injection we did in `BusyIndicatorDirective` falls under this
    category. If the directive is not found on the current element, the Angular DI
    will throw an error, unless we mark the dependency `@Optional`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional dependency**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The `@Optional` decorator is not limited to directive injection. It's there
    to mark any type of dependency optional.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'From the plunk example, the first injection injects the `Relation` directive
    with the me attribute (`relation="me"`) into the consumer directive:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Injecting directive dependency from the parent
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prefixing a constructor argument with the `@Host` decorator instructs Angular
    to search for the dependency on the *current element*, *its parent*, or its *parents*
    until it reaches the component boundaries (a component with the directive present
    somewhere in its view hierarchy). Check the second `consumer` injection:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This statement injects the `Acquaintance` directive instance declared two levels
    up the hierarchy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `@Option` decorator described previously, the usage of `@Host()` too
    is not limited to directives. Angular service injection also follows the same
    pattern. If a service is marked with `@Host`, the search stops at the host component.
    It does not continue further up the component tree.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The `@Skipself` decorator can be used to skip the current element for a directive
    search.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'From the plunk example, this injection injects the `Relation` directive with
    the parent attribute (`relation="parent"`) into consumer:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Injecting a child directive (or directives)
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there is a need to inject directive(s) defined on nested HTML into a parent
    directive/ component, there are four decorators that can help us:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`@ViewChild`/`@ViewChildren`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ContentChild`/`@ContentChildren`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As these naming conventions suggest, there are decorators to inject a single
    child directive or multiple children directives:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: To understand the significance of `@ViewChild/@ViewChildren` versus `@ContentChild/@ContentChildren`,
    we need look at the what view and content children are, a topic that we will take
    up soon. But for now, it's enough to understand that view children are part of
    a component's own view and content children are external HTML injected into the
    component's view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Look how, in Plunket, the `ContentChildren` decorator is used to inject the
    child `Relation` directive into `Consumer`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Surprisingly, the data type of the variable `children` is not an array but a
    custom class-`QueryList`. The `QueryList` class is not a typical array but a collection
    that is kept up to date by Angular whenever dependencies are added or removed.
    This can happen if the DOM tree is created/destroyed when using structural directives
    such as `NgIf` or `NgFor`. We will also talk more about `QueryList` in the coming
    sections.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: You may have observed that the preceding injection is not a constructor injection
    as were the earlier two examples. This is for a reason. The injected directive(s)
    will not be available until the underlying component/element's content has initialized.
    For this precise reason, we have the console.log statements inside the `ngAfterViewInit`
    lifecycle hook. We should only access the content children post this lifecycle
    hook execution.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sample code injects in all three child `relation` objects into
    the `consumer` directive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Injecting descendant directive(s)
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard `@ContentChildren` decorator (or as a matter of fact `@ViewChildren`
    too) only injects the immediate children of a directive/component and not its
    descendants. To include all its descendants, we need to provide an argument to
    `Query`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Passing the `descendants: true` parameter will instruct Angular to search for
    all descendants.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the plunker log, the preceding statement injects in all four
    descendants.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI, while it seems simple to use, packs a lot of functionality.
    It manages our services, components, and directives and provides us with the right
    stuff in the right place at the right time. Directive injection in components
    and other directives provides a mechanism for directives to communicate with each
    other. Such injections allow one directive to access the public API (public functions/properties)
    of another directive.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to explore something new. We are going to build an Ajax button
    component that allows us to inject an external view into the component, a process
    also known as **content ** **transclusion**.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ajax button component
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we save/update an exercise or workout, there is always the possibility
    of duplicate submission (or duplicate `POST` requests). The current implementation
    does not provide any feedback as to when the save/update operation started and
    when it completed. The user of an app can knowingly or unknowingly click on the
    **Save** button multiple times due to the lack of visual clues.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to solve this problem by creating a specialized button—€”an *Ajax
    button* that gives some visual clues when clicked on and also stops duplicate
    Ajax submissions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The button component will work on these lines. It takes a function as input.
    This input function (input parameter) should return a promise pertaining to the
    remote request. On clicking on the button, the button internally makes the remote
    call (using the input function), tracks the underlying promise, waits for it to
    complete, and shows some busy clues during this activity. Also, the button remains
    disabled until the remote invocation completes to avoid duplicate submission.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The companion code base for the following section is git branch `checkpoint6.2`.
    You can work along with us, or check out the implementation available in the branch.
    Or if you are not using Git, download the snapshot of `checkpoint6.2` (a zip file)
    from the GitHub location [http://bit.ly/ng2be-checkpoint6-2](http://bit.ly/ng2be-checkpoint6-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the component outline to make things clearer. Create a file,
    `ajax-button.component.ts`, inside the `workout-builder/shared` folder and add
    the following component outline:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The component (`AjaxButtonComponent`) takes two property bindings, `execute`
    and `parameter`. The `execute` property points to the function that is invoked
    on the Ajax button click. The `parameter` is the data that can be passed to this
    function.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the usage of the `busy` flag in the view. We disable the button and
    show the spinner when the `busy` flag is set. Let''s add the implementation that
    makes everything work. Add this code to the `AjaxButtonComponent` class:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We set up a *host event binding* to the click event on `AjaxButtonComponent`.
    Anytime the `AjaxButtonComponent` component is clicked on, the `onClick` function
    is invoked.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The `HostListener` import needs to be added to the `'@angular/core'` module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` implementation calls the input function with a lone parameter
    as `parameter`. The result of the invocation is stored in the `result` variable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition checks whether the `result` is a `Promise` object. If yes,
    the `busy` indicator is set to `true`. The button then waits for the promise to
    get resolved, using the `then` function. Irrespective of whether the promise is
    resolved with *success* or *error*, the busy flag is set to `null`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason the busy flag is set to `null` and not `false` is due to this attribute
    binding `[attr.disabled]="busy"`. The `disabled` attribute will not be removed
    unless `busy` is `null`. Remember that in HTML, `disabled="false"` does not enable
    the button. The attribute needs to be removed before the button becomes clickable
    again.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose there is still confusion about this line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you need to look at how the component is used. Open `workout.component.html`
    and replace the `Save` button HTML with the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We pass the `Workout.save` function binds to `execute` and `parameter`; it takes
    the `FormControl` object `f`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We need to change the `save` function in the `Workout` class to return a promise
    for `AjaxButtonComponent` to work. But before proceeding, open `workout.component.ts`,
    add `AjaxButtonComponent`, import it, and reference it in the `directives` array.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Then change the `save` function implementation to the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `save` function now returns a *promise* that we build by calling the `toPromise`
    function on the *observable* returned from the call to `workoutBuilderService.save()`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Also add `AjaxButtonComponent` to the workout builder module's (`workout-builder.module.ts`)
    declarations section.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make note of how we define the `save` function as an *instance function* (with
    the use of the arrow operator) to create a closure over *this*. It's something
    we did earlier too while building the *remote validator directive*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to test our implementation! Refresh the application and open the create/edit
    workout view. Click on the **Save** button and see the Ajax button in action:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an Ajax button component](../Images/image00392.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: We started this section with the aim of highlighting how external elements/components
    can be transcluded into a component. Let's do it now!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Transcluding external components/elements into a component
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the very start, we need to understand what **transclusion** means. And
    the best way to understand this concept would be to look at an example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: No component that we have built thus far has borrowed content from outside.
    Not sure what this means?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the preceding `AjaxButtonComponent` example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What if we change the `ajax-button` usage to the following?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Will the `Save Me!` text show up on the button? It will not, try it!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The `AjaxButtonComponent` component already has a template, and it rejects the
    content we provide in the preceding declaration. What if we can somehow make the
    content (`Save Me!` in the preceding example) load inside the `AjaxButtonComponent`?
    This act of injecting an external view fragment into the component's view is what
    we call **transclusion**, and the framework provides the necessary constructs
    to enable transclusions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: It's time to introduce two new concepts, *content children* and *view children*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Content children and view children
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To define it succinctly, the HTML structure that a component defines internally
    (using `template/templateUrl`) is the **view children** of the component. However, the
    HTML view provided as part of the component usage added to the host element (like
    `<ajax-button>`), defines the **content children** of the component.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Angular does not allow *content children* to be embedded as we
    saw before. The `Save Me!` text was never emitted. We need to explicitly tell
    Angular where to emit the *content children* inside the *component view template*.
    To understand this concept, let''s fix the `AjaxButtonComponent` view. Open `ajax-button.component.ts`
    and update the view template definition to:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The two `ng-content` elements in the preceding view define the *content injection
    locations*, where the content children can be injected/transcluded. The `selector`
    property defines the *CSS selector* that should be used to locate the content
    children.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts to make more sense as soon as we fix the `AjaxButtonComponent` usage
    in `workout.component.html`. Change it to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `span` with `data-animator` is injected into the `ng-content` with the `select=[data-animator]`
    property and the other `span` (with the `data-content` attribute) is injected
    into the second `ng-content` declaration.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the application again and try to save a workout. While the end result
    is the same, the resultant view is a combination of multiple view fragments: one
    part for component definition (*view children*) and another part for component
    usage (*content children*).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram highlights this difference for the rendered `AjaxButtonComponent`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Content children and view children](../Images/image00393.jpeg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ng-content` can be declared without the `selector` attribute. In such a
    scenario, the complete content defined inside the component tag is injected.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '*Content injection* into an existing component view is a very powerful concept.
    It allows the component developer to provide extension points that the component
    consumer can readily consume and customize the behavior of the component, that
    too in a controlled manner.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The content injections that we defined for the `AjaxButtonComponent` allow the
    consumer to change the busy indicator animation and the button content, keeping
    the behavior of the button intact.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Angular's advantages do not end here. It has the capability to inject *content
    children* and *view children* into the *component code/implementation*. This allows
    the component to interact with its content/view children and control their behavior
    too.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Injecting view children using @ViewChild and @ViewChildren
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3 "Chapter 3. 
    More Angular 2 – SPA, Routing, and Data Flows in Depth"), *More Angular 2 –€“
    SPA, Routing, and Data Flows in Depth*, we made use of something similar, *view
    children injection*. To refresh what we did, let's look at the relevant parts
    of the `WorkoutAudioComponent` implementation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The view definition looked like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And the injection looked like the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The directive (`MyAudioDirective`) associated with the `audio` tag was injected
    into the `WorkoutAudio` implementation using the `@ViewChild` decorator. The parameters
    passed to `@ViewChild` are the *template variable* names (such as `tick`) used
    to locate the element in the view definition. The `WorkoutAudio` component then
    used these audio directives to control the audio playback for *7 Minute Workout*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding implementation injects `MyAudioDirective`, even child components
    can be injected. For example, instead of using the `MyAudioDirective`, suppose
    we build a `MyAudioComponent`, €”something like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can then use it instead of the `audio` tag:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The injection would still work.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if there is more than one directive/component of the same type
    defined on the component view? Use the `@ViewChildren` decorator. It allows you
    to query injections of one type. The syntax for the use of `@ViewChildren` is
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This injects all the view children of type `directiveType`. For the `WorkoutAudio`
    component example stated previously, we can use the following statement to get
    hold of all `MyAudioDirective`''s:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `ViewChildren` decorator can also take a list of comma-separated selectors
    (*template variable names*) instead of type. For example, to select multiple `MyAudioDirective `instances in
    the `WorkoutAudio` component, we can use this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `QueryList` class is a special class provided by Angular. We introduced
    `QueryList` in the *Injecting descendant directive(s)* section earlier in the
    chapter. Let's explore `QueryList` further.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Tracking injected dependencies with QueryList
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For components that require multiple components/directives to be injected (using
    either `@ViewChildren` or `@ContentChildren`), the dependency injected is a `QueryList`
    object.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The `QueryList` class is a *read-only * *collection* of injected components/directives.
    Angular keeps this collection in sync based on the current state of the user interface.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the `WorkoutAudio` directive view. It has five instances
    of `MyAudioDirective`. Hence, for the following statement, `all.length` will be
    *five*:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While the preceding example does not highlight the syncing part, Angular can
    track components/directives being added or removed for the view. This happens
    when we use content generation directives such as `ngFor`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this hypothetical template for example:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The number of `MyAudioDirective` directives injected here equals the size of
    the `allAudios` array. During the program's execution, if elements are added to
    or removed from the `allAudios` array, the directive collection is also kept in
    sync by the framework.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: While the `QueryList` class is not an array, it can be iterated over (as it
    implements the **ES6 iterable interface**) using the `for (var item in queryListObject)`
    syntax. It also has some other useful properties, such as `length`, `first`, and
    `last`, that can come in handy. Check out the framework documentation ([http://bit.ly/ng2-querylist-class](http://bit.ly/ng2-querylist-class))
    for more details.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding discussion, we can conclude that `QueryList` saves the component
    developer a lot of boilerplate code that would be required if tracking had to
    be done manually.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**View children access timing**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: View children injections are not available when the component/directive initializes.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Angular makes sure that the view children injections are available to the component
    no later than the `ngAfterViewInit` lifecycle event. Make sure you access the
    injected components/directives only when (or after) the `ngAfterViewInit` event
    has fired.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at content children injection, which is almost similar, except
    for a few minor differences.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Injecting content children using @ContentChild and @ContentChildren
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular allows us to inject *content children* too, using a parallel set of
    attributes: `@ContentChild` to inject a specific content child and `@ContentChildren`
    to inject content children of a specific type.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the usage of `AjaxButtonComponent`, its content children
    spans can be injected into `AjaxButtonComponent` by doing this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This can also be done by adding template variables onto the corresponding spans
    in `workout.component.html`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'While the preceding injection is `ElementRef`, it could have been a component
    too. Had we defined a component for spinner such as:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We could have injected it too using:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The same holds good for directives too. Any directive declared on `AjaxButtonComponent`
    can be injected into the `AjaxButtonComponent` implementation. For the preceding
    case, since it is standard HTML, we injected `ElementRef`, a wrapper that Angular
    creates for any HTML element.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like *view children*, Angular makes sure that the content children references
    are bound to the variables injected before the `ngAfterContentInit` lifecycle
    event.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: While we are on the subject of injecting dependencies, let's talk about some
    variations around *injecting services into * *components*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection using viewProvider
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are already familiar with the mechanism of DI registration in Angular, where
    we register a dependency at the global level by adding it to any module declaration:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can do it at a component level using the `providers` property on the
    `@Component` decorator:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to avoid confusion, we are now talking about injecting dependencies other
    than directive/component objects. Directives/components are registered in the
    `declarations` array of a module before they can be injected using decorator hints
    such as `@Query`, `@ViewChild`, `@ViewChildren`, and a few others.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies registered at the component level are available for its *view children*
    and *content children* and their descendants.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we proceed, we hope that the distinction between *view* and *content *
    *children* is crystal clear to everyone. If in doubt, refer to the *Content children
    and view children* section again.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example from [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*. The `WorkoutBuilderService`
    service was registered at the app level in the workout builder module (`WorkoutBuilderModule`):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This allows us to inject `WorkoutBuilderService` across the app in order to build
    workouts and while running workouts. Instead, we could have registered the service
    at the `WorkoutBuilderComponent` level since it is the parent of all workout/exercise
    creation components, €”something like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This change would disallow injecting `WorkoutBuilder` in `WorkoutRunner` or
    any component related to workout execution.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if the `WorkoutBuilderService` service is registered at the app level as
    well as at the component level (as shown in the preceding example)? How does the
    injection happen? From our experience, we know that Angular will inject a different
    instance of the `WorkoutBuilderService` service into `WorkoutBuilderComponent`
    (and its descendants), while other parts of the application (*Workout runner*)
    will get the global dependency. Remember **hierarchical injectors**!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not stop here. It provides some further scoping of dependencies
    using the `viewProviders` property. The `viewProviders` property, available on
    the `@Component` decorator, allows the registering of dependencies that can be
    injected only in the view children.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `AjaxButtonComponent` example again, and a simple directive
    implementation called `MyDirective`, to elaborate on our discussion:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `MyDirective` class depends upon a service, `MyService`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this directive to the *button element* in the `AjaxButtonComponent`
    template, we need to register the `MyService` dependency too (assuming that `MyService`
    has not been registered globally):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since `MyService` is registered with `AjaxButtonComponent`, `MyDirective` can
    be added to its content children too. Hence the `myDirective` application on *spinner
    HTML* will also work (the code in `workout.component.html`):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'But changing the `providers` property to `viewProviders` :'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Will fail the `MyService` injection for the `AjaxButtonComponent`'s content
    children (the `span` in the preceding code), with a DI error in the console.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependencies registered with `viewProviders` are invisible to its content children.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: This dependency scoping for *view* and *content children* may not seem useful
    at first sight, but it does have its benefits. Imagine we are building a reusable
    component that we want to package and deliver to developers for consumption. If
    the component has a service dependency that it prepackages too, we need to be
    extra cautious. If such a component allows *content injection* (content children),
    the dependent service is widely exposed if *provider-based* registration is used
    on the component. Any content children can get hold of the service dependency
    and use it, leading to undesirable consequences. By registering the dependency
    using `viewProvider`, only the component implementation and its child views have
    access to the dependency, providing the necessary layer of encapsulation.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, we are amazed by the flexibility and level of customization the DI
    framework provides. While it may be intimidating for starters, once we start building
    more and more components/directives with Angular, we will always find areas where
    these concepts make our implementation simpler.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Let's shift our focus to the third classification of directives: *structural
    directives*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structural directives
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we will often be using structural directives, such as `NgIf` and `NgFor`,
    there is seldom a need to creating a structural directive. Think carefully. If
    we need a new view, we create a *component*. If we need to extend an existing
    element/component, we use a *directive*. Whereas the most common use of structural
    directives is to clone a piece of a view (also called a *template view*) and then,
    based on some conditions:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Either inject/destroy these templates (`NgIf` and `NgSwitch`)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or duplicate these templates (`NgFor`)
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any behavior implemented using structure directives will inadvertently fall
    into either of these two categories.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Given this fact, instead of building our own structural directive, let's look
    at the source code of the `NgIf` implementation.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the complete implementation for `NgIf`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: No magic here, just simple structural directive that checks a boolean condition
    to create/destroy the view!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '`prevCondition` is tracking the last value of the `ngIf` expression. The extra
    checks with `prevCondition` are there to make sure that the template add/remove
    logic runs only when the expression being watched (`newCondition`) actually flips.
    Nothing happens when both `newCondition` and `prevCondition` are either `true`
    or `false`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: It's not difficult to understand how the directive works. What needs to be detailed
    are the two new injections, `ViewContainerRef (_viewContainer)` and `TemplateRef
    (_TemplateRef)`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: TemplateRef
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TemplateRef` class (`_templateRef`) stores the reference to the template
    the structural directive is referring to. Remember the discussion on structural
    directives from [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), *Building Our First
    App - 7 Minute Workout*? All structural directives take a template HTML that they
    work on. When we use a directive such as `NgIf`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Angular internally translates this declaration to the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is the template that structural directives work with, and `_templateRef`
    points to this template.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `template` is an HTML5 tag used to hold content that we do not want to be
    rendered in the browser. The default style set for the `template` tag is `display:none`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: If we manually add template tags in an Angular view, the Angular templating
    engine will replace them with empty `<script></script>` tags.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The other injection is `ViewContainerRef`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: ViewContainerRef
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ViewContainerRef` class points to the container where templates are rendered.
    This class has a number of handy methods for managing views. The two functions
    that `NgIf` implementation uses, `createEmbeddedView` and `clear`, are there to
    add and remove the template HTML.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The `createEmbeddedView` function takes the template reference (again injected
    into the directive) and renders the view.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `clear` function destroys the element/component already injected and clears
    the view container. Since every component and its children referenced inside the
    template (`TemplateRef`) are destroyed, all the associated bindings also cease
    to exist.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives have a very specific area of application. Still, we can
    do a lot of nifty tricks using the `TemplateRef` and `ViewContainerRef` classes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a structural directive that, depending on the user role, shows/hides
    the view template.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of a hypothetical structural directive, `forRoles`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `forRoles` directive will not render the button if the user does not belong
    to the *admin* role. The core logic would look something like the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The directive implementation will need some sort of service that returns the
    logged-in user's details. We will leave the implementation for such a directive
    to the readers.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'What the `forRoles` directive does can also be done using `NgIf`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: But the `forRoles` directive just adds to the template's readability with clear
    intentions.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'A fun application of structural directives may involve creating a directive
    that just duplicates the template passed to it. It would be quite easy to build
    one; we just need to call `createEmbeddedView` twice:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Another fun exercise!
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewContainerRef` class also has some other functions that allow us to
    inject *components*, get the number of embedded views, reorder the view, and so
    on and so forth. Look at the framework documentation for `ViewContainerRef` ([http://bit.ly/view-container-ref](http://bit.ly/view-container-ref))
    for more details.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on structural directives and it's time to start
    something new!
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: The components that we have built thus far derive their styles (CSS) from the
    common *bootstrap style sheet* and some custom styles defined in `app.css`. Angular
    has much more to offer in this area. A truly reusable component should be completely
    self-contained, in terms of both behavior and user interface.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Component styling and view encapsulation
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A longstanding problem with web app development is the lack of encapsulation
    when it comes to DOM element behavior and styles. We cannot segregate one part
    of the application HTML from another through any mechanism.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we have too much power at our disposal. With libraries like jQuery
    and powerful *CSS selectors*, we can get hold of any DOM element and change its
    behavior. There is no distinction between our code and any external library code
    in terms of what it can access. Every single piece of code can manipulate any
    part of the rendered DOM. Hence, the encapsulation layer is broken. A badly written
    library can cause some nasty issues that are hard to debug.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The same holds true for CSS styling too. Any UI library implementation can override
    global styles if the library implementation wants to do so.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: These are genuine challenges that any library developer faces when building
    reusable libraries. Some emerging web standards have tried to address this issue
    by coming up with concepts such as **web components**.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**Web components**, in simple terms, are reusable user interface widgets that
    encapsulate their *state*, *style*, *user interface*, and *behavior*. Functionality
    is exposed through well-defined APIs, and the user interface parts are encapsulated
    too.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'The *web component* concept is enabled through four standards:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom elements
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML imports
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this discussion, the technology standard we are interested in is **Shadow
    DOM.**
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Shadow DOM
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Shadow DOM** is like a parallel DOM tree hosted inside a component (*an HTML
    element, * *not to be confused with Angular components*), hidden away from the
    main DOM tree. No part of the application has access to this shadow DOM other
    than the component itself.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: It is the implementation of the Shadow DOM standard that allows view, style,
    and behavior encapsulation. The best way to understand Shadow DOM is to look at
    HTML5 `video` and `audio` tags.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever wondered how this `audio` declaration:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Produces the following?
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of Shadow DOM](../Images/image00394.jpeg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: 'It is the browser that generates the underlying Shadow DOM to render the audio
    player. Surprisingly, we can even look at the generated DOM! Here is how we do
    it:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Take the preceding HTML, create a dummy HTML page, and open it in Chrome.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then open the developer tools window (**F12**). Click on the **Setting** icon
    in the top left.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the **General** settings, click on the checkbox, as highlighted in the following
    screenshot, to enable the inspection of Shadow DOM:'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Overview of Shadow DOM](../Images/image00395.jpeg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
- en: 'Refresh the page, and if we now inspect the generated `audio` HTML, the Shadow
    DOM shows up:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of Shadow DOM](../Images/image00396.jpeg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
- en: Under `shadow-root`, there is a whole new world that the other part of the page
    and script do not have access to.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Shadow DOM realm, **shadow-root** (`#shadow-root` in the preceding code)
    is the root node for the generated DOM, hosted inside a **shadow host** (in this
    case the `audio` tag).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: When the browser renders this element/component, what gets rendered is the content
    from the *shadow root* and not the *shadow host*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: From this discussion, we can conclude that Shadow DOM is a parallel DOM created
    by the browser that encapsulates the *markup*, *style*, and *behavior* (DOM manipulation)
    of an HTML element.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This was a gentle introduction to Shadow DOM. To learn more about how Shadow
    DOM works, we recommend this series by Rob Dodson: [http://bit.ly/shadow-dom-intro](http://bit.ly/shadow-dom-intro)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: But what has all this got to do with Angular? As it turns out, Angular components
    too support some sort of view encapsulation! This allows us to isolate styles
    for Angular components too.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM and Angular components
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how Angular employs the concept of Shadow DOM, we will first have
    to learn about styling Angular components.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to styling the apps built as part of this book, we have taken
    a conservative approach. Be it *Workout Builder* or the *Workout Runner* (*7 Minute
    Workout*) app, all the components that we built derive their style from *bootstrap
    CSS* and from custom styles defined in `app.css`. No component has defined its
    own style.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: While this adheres to the standard practices of web app development, sometimes
    we do need to deviate. This is especially true when we are building self-contained,
    packaged, and reusable components.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Angular allows us to define styles specific to a component by using the `style`
    (for inline style) and `styleUrl` (external style sheet) properties on the `@Component`
    decorator. Let's play around with the `style` property and see what Angular does.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `AjaxButtonComponent` implementation as our playground for
    the next exercise. But before doing that, let''s look at the `AjaxButtonComponent`
    HTML as it stands now. The HTML tree for `AjaxButtonComponent` looks like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM and Angular components](../Images/image00397.jpeg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: 'Let''s override some styles using the `styles` property:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding *CSS selector* sets the `background` property to `green` for
    all HTML buttons. Save the above style and refresh the work builder page. The
    button style has been updated. No surprises here? Not true, there are some! Look
    at the generated HTML:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM and Angular components](../Images/image00398.jpeg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
- en: 'There are some new attributes added to a number of HTML elements. And where
    have the recently defined styles landed? At the very top, inside the `head` tag:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM and Angular components](../Images/image00399.jpeg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
- en: The style defined in the `head` section has an extra scope with the `_ngcontent-eaq-14`
    attribute (the attribute name may differ in your case). This scoping allows us
    to style `AjaxButtonComponent` independently and it cannot override any global
    styles.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: The styles that, by definition, should have affected the appearance of all the
    buttons in the application have had no effect. Angular has scoped these styles.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This scoping makes sure that the component styles do not mess with the already
    defined style, but the reverse is not true. Global styles will still affect the
    component unless overridden in the component itself. Angular does the same even
    if we use the `styleUrls` property. Suppose we had embedded the same CSS in an
    external CSS file and used this: `styleUrls:[''static/css/ajax-button.css'']`
    Angular would have still in-lined the styles into the `head` section, by fetching
    the CSS, parsing it, and then injecting it.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: This scoped style is the result of Angular trying to emulate the Shadow DOM
    paradigm. The styles defined on the component never leak into the global styles.
    All this awesomeness without any effort!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are building components that define their own styles and want a degree
    of isolation, use the component's `style`/`styleUrl` property instead of using
    the old-school approach of having a common CSS file for all styles.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further control this behavior by using a `@Component` decorator property
    called **encapsulation**. The API documentation on this property mentions:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '**encapsulation : ViewEncapsulation**'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Specify how the template and the styles should be encapsulated. The default
    is **ViewEncapsulation.Emulated** if the view has styles, otherwise **ViewEncapsulation.None**.
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we can see, as soon as we set the style on the component, the encapsulation
    effect is `Emulated`. Otherwise, it is `None`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we explicitly set `encapsulation` to `ViewEncapsulation.None`, the scoping
    attributes are removed and the styles are embedded in the head section as normal
    styles.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'And then there is a third option, `ViewEncapsulation.Native`, in which Angular
    actually creates Shadow DOM for the components view. Set the `encapsulation` property
    on the `AjaxButtonComponent` implementation to `ViewEncapsulation.Native`, and
    now look at the rendered DOM:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM and Angular components](../Images/image00400.jpeg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
- en: The `AjaxButtonComponent` now has a shadow DOM! This also implies that the complete
    styling of the button is lost (style derived from bootstrap CSS) and the button
    needs to now define its own style.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Angular goes to great lengths to make sure that the components we develop can
    work independently and are reusable. Each component already has its own template
    and behavior. In addition to that, we can also encapsulate component styles, allowing
    us to create robust, standalone components.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter, and it's time to wrap up the chapter
    with what we've learned.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter, we now have a better understanding of how directives
    work and how to use them effectively.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by building a `RemoteValidatorDirective`, and learned
    a lot about Angular's support for *asynchronous validations*.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Next in line was `BusyIndicatorDirective`, again an excellent learning ground.
    We explored the **renderer** service, which allows component view manipulation
    in a platform-agnostic way. We also learned about **host bindings**, which let
    us bind to a host element's *events*, *attributes*, and *properties*.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Angular allows directives declared across the view lineage to be injected within
    the lineage. We dedicated a few sections to understanding this behavior.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The third directive (component) that we created was `AjaxButtonComponent`. It
    helped us understand the critical difference between *content children* and *view
    children* for a component.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: We also touched upon structural directives, where we explored the `NgIf` platform
    directive.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at Angular's capabilities in terms of view encapsulation.
    We explored the basics of Shadow DOM and learned how the framework employs the
    Shadow DOM paradigm to provide view plus style encapsulation.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about testing Angular apps, a critical piece in the
    complete framework offering. The Angular framework was built with testability
    in mind. The framework constructs and the tooling support make automated testing
    in Angular easy. More about this in the next chapter....
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
