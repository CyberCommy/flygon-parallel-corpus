- en: Chapter 7. Dinnerly – Recipe Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore modern methods of the so-called social login,
    where we allow a user to authenticate with our application using derived credentials
    from another web application. Currently, the most widespread third-party applications
    that support this mechanism are, somewhat unsurprisingly, Twitter and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: While there exist several other widespread web applications that support this
    type of integration (for example, LinkedIn, Dropbox, Foursquare, Google, and GitHub
    to name a few), the majority of your potential users will be in possession of
    at least one account on either Twitter or Facebook, the two major social networks
    of this time.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will be adding, configuring, and deploying the Flask-OAuthlib
    extension. This extension abstracts out some of the usual difficulties and roadblocks
    that are often experienced when dealing with an OAuth-based authorization flow
    (which we will explain shortly) and includes functionalities to quickly set up
    the defaults required to negotiate the provider / consumer / resource owner token
    exchange. As a bonus, the extension will provide us with the ability to interact
    with the authenticated APIs of these remote services on behalf of the user.
  prefs: []
  type: TYPE_NORMAL
- en: First OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get this out of the way: OAuth can be somewhat difficult to grasp. Adding
    to this fire is the fact that the OAuth framework/protocol has gone through a
    major revision in the last few years. Version 2 was published in 2012, but due
    to a variety of factors, there are some web applications that continue to implement
    the OAuth v1 protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth 2.0 is not backwards compatible with OAuth 1.0\. Moreover, OAuth 2.0 is
    less of a formal protocol specification and more of an authorization framework
    specification. Most OAuth 2.0 implementations across modern web applications are
    not interoperable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we''ll view a high-level overview of the general
    terms, vocabulary, and functionalities of the OAuth 2.0 authorization framework.
    Version 2 is the simpler of the two specifications and with good reason: one of
    the design goals of the latter was to make client implementations simpler and
    less prone to error. Much of the terminology is similar, if not identical, across
    the two versions.'
  prefs: []
  type: TYPE_NORMAL
- en: While the intricacies of the OAuth authorization exchanges will mostly be abstracted
    away from us thanks to the Flask-OAuthlib extension and underlying Python packages
    that handle the real grunt work, a cursory level of knowledge regarding the OAuth
    authorization framework (specifically the most common authorization grant flows)
    for web applications and the typical implementations will be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Why use OAuth?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great sins of proper online personal security is the reuse of access
    credentials across different services. This opens you up to a variety of security-related
    issues if the credentials you use for one application are compromised. You now
    have the possibility of being compromised on all the applications where this same
    set of credentials are used and the only way to fix this post facto would be to
    go and change your credentials everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse than reusing the credentials across the different services is having
    a user willingly turn over their credentials for a third-party service, say Twitter,
    to some other service, say Foursquare, so that the latter can make requests to
    Twitter on behalf of the user (for example, posting check-ins to their Twitter
    timeline). While not immediately obvious, one of the problems with this approach
    is that the credentials must be stored in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: This situation is not ideal for a variety of reasons, and some of these reasons
    are not things that you, as an application developer, can control.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth, in both version 1 and version 2 of the framework, attempt to solve the
    problem of cross-application shared credentials by creating an open standard for
    API access delegation. The principle goal of OAuth's original design was to ensure
    that a user of application A could delegate access to application B on their behalf
    and also ensure that application B was never in possession of the credentials
    that could compromise the user account on application A.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While an application in possession of delegated credentials can abuse these
    credentials to perform some unsavory actions, the root credentials have never
    been shared and thus the owner of the account can simply invalidate the delegated
    credentials that have been abused. If the root account credentials had simply
    been given to the third-party application, then this latter could have taken complete
    control of the account by changing all of the primary authentication information
    (username, e-mail, password, and so on), which would effectively hijack the account.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the confusion about OAuth usage and implementation stems from a misunderstanding
    of the essential vocabulary and terminology that is used to describe the basic
    authorization flow. Even worse, there are several popular web applications that
    have implemented OAuth (in some form or another) and decided to use their own
    vocabulary for portions of the protocol/framework instead of those that have been
    decided upon in the official RFC.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An RFC, or a Request For Comments, is a memorandum-style publication of a document
    or set of documents from the **Internet Engineering Task Force** (**IETF**), which
    is the principal body that governs the open standards on which most of the Internet
    is built upon. RFCs are usually denoted by a numeric code, which uniquely identifies
    them in the IETF. For example, the OAuth 2.0 authorization framework RFC is number
    6749 and can be found in its entirety on the IETF website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help alleviate some of this confusion, here''s a simplified description
    of what most of the essential components of an OAuth implementation mean in plain
    English:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumer**: This is the application that is making the request on behalf
    of the user. In our particular case, the Dinnerly application is considered the
    consumer. Confusingly enough, the official OAuth specification refers to the client
    instead of the consumer. Even more confusingly, some applications use the consumer
    *and* client terms. Usually, a consumer is represented by a key and secret that
    must be kept in your application configuration, and they must be well-guarded.
    If a malicious entity were to gain access to your consumer key and secret, they
    could then pretend to be your application when making authorized requests with
    the third-party provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provider**: This is the third-party service that the consumer is attempting
    to access on behalf of a user. In our case, Twitter and Facebook are the providers
    that we will be using for our application signing in. Other examples of providers
    could be GitHub, LinkedIn, Google, and any other service that offers a grant-based
    OAuth authorization flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource owner**: This is the entity that is capable of consenting to the
    delegated resource access. In most cases, the resource owner is an end user of
    both the applications (for example, Twitter and Dinnerly) in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access token(s)**: This is a credential that the client uses to make requests
    to the provider on behalf of a user in order to access the protected resources.
    The token can be linked with a particular permission scope, which limits what
    resources it can access. Additionally, the access token may expire after a certain
    amount of time determined by the provider; at which point the use of a refresh
    token is required to obtain a new, valid access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: This is the server (usually represented by a URI
    endpoint) that is responsible for issuing access tokens to the consumer application
    after the resource owner has consented to delegating their access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow type**: The OAuth 2.0 framework provides outlines of several different
    flows for authorization. Some are best suited for command-line applications where
    no web browser is present, others are better suited for native mobile applications,
    and some have also been created to connect devices that have very limited access
    capabilities (for example, if you want to delegate your Twitter account privileges
    to your Internet-enabled toaster). The authorization flow that we are most interested
    in, unsurprisingly, is the one designed for basic web browser-based access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding list of vocabulary, you should now be able to comprehend
    the official abstract protocol flow that is listed in the official OAuth 2.0 RFC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following description of the steps listed in the flow diagram has been
    taken from RFC 6749 and made a bit more relevant for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The client (or consumer) requests the resource owner to grant an authorization.
    This is usually where the user is redirected to a login screen on the remote provider,
    say Twitter, where it is explained that the client application wishes to access
    the protected resources that you control. On agreeing to this, we enter the next
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives an authorization grant from the resource owner (user), which
    is a temporary credential representing the resource owner's authorization for
    the particular type of authorization flow that the provider has implemented. This
    is typically an authorization code grant flow for most web applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the client has received the grant credentials, it sends them to the authorization
    server to request an authentication token on behalf of the resource owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server validates the grant credentials and authenticates the
    client making the request. Upon fulfilling these two requirements, the server
    returns a valid authentication token to the client that can then be used to make
    authenticated requests to the provider on behalf of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So what's wrong with OAuth 1.0?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In theory: not much. In practice: it''s somewhat difficult and extremely error
    prone to be implemented correctly for the consumer.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary difficulties in implementing and using an OAuth 1.0 provider revolve
    around consumer applications not performing the required cryptographic request
    signing properly. The arguments and parameters had to be collected from the query
    string in addition to the request body and various OAuth parameters (for example,
    `oauth_nonce`, `oauth_signature_method`, `oauth_timestamp`, and so on) and then
    URL-encoded (meaning that non-URL safe values are specially encoded to ensure
    they are transmitted correctly). Once the key/value pairs have been encoded, they
    must then be sorted lexicographically by key (remember, the encoded key and not
    the raw key value) and then concatenated to a single string using typical URL
    parameter separators. Additionally, the HTTP verb that is to be used to submit
    the request (for example, `GET` or `POST`) must be prepended to the string that
    we just created and then followed by the URL that the request will be sent to.
    Finally, the signing key is to be constructed from the consumer secret key and
    an OAuth token secret and then passed to an implementation of the HMAC-SHA1 hashing
    algorithm along with the payload that we constructed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you got all this correct (and it's incredibly easy to make a simple
    mistake such as sorting your keys alphabetically instead of lexicographically),
    only then would the request be considered valid. Moreover, in the event of a miscalculated
    signature, there's no simple way to determine where the mistake was made.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons that this rather complex process is required for OAuth 1.0
    is that a design goal of this protocol was that it should function across insecure
    protocols such as HTTP, but still ensure that the request has not been modified
    by a malicious party along the way.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0, while not universally accepted as a worthy successor to OAuth 1.0,
    has greatly simplified the implementation by simply requiring that all the communication
    occur over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Three-legged authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the so-called three-legged authorization flow for the OAuth framework, an
    application (`consumer`) makes requests on behalf of a user (`resource owner`)
    in order to access the resources present on a remote service (`provider`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There also exists a two-legged authorization flow, which is primarily used for
    application-to-application access where a resource owner is not required to consent
    to delegated access to the protected resources. Twitter, for example, implements
    both two-legged and three-legged authorization flows, but the former does not
    have the same access scope as the latter in terms of resource access and imposed
    API rate limits.
  prefs: []
  type: TYPE_NORMAL
- en: This is what Flask-Social will allow us to implement for Twitter and Facebook,
    the two providers that we have chosen, where our application will act as the consumer.
    The end result will be that our Dinnerly application will be in possession of
    access tokens for both the providers that will allow us to make authenticated
    API requests on behalf of our users (the resource owners), which is necessary
    to implement any sort of cross-social network posting functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once again, let''s set up a barebones folder for our project along with the
    associated virtual environment in order to isolate our application dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, let''s install the basic packages that we will require including
    Flask itself along with the Flask-OAuthlib extension, our trusty friend Flask-SQLAlchemy,
    and Flask-Login, which we used in a previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll utilize our trusty Blueprint-based application structure that has served
    us so well in the past chapters to ensure a solid foundation. For now, we''ll
    have a single users Blueprint where the OAuth handling will be taken care of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the very basic folder and file structure has been established, let''s
    use an application factory to create our main application object. For now, all
    we''re going to do is instantiate a very simple application with a Flask-SQLAlchemy
    database connection in `application/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that we can actually run the application and create the database,
    let''s use the simple `run.py` and `database.py` scripts that we will place sibling
    to the `application` folder. The contents of `run.py` are similar to what we used
    in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later on in this chapter, we will explore alternative methods of running the
    Dinnerly application, most of which are more well-suited to production deployments.
    The Werkzeug development server that is invoked on `app.run()` is highly unsuitable
    for anything other than local development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `database.py` is, quite similarly, simple and to the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to create the relevant schema in our database based on our
    model definitions, which have not yet been declared; running the script right
    now will essentially be a no op. This is okay! We have much to do before this
    becomes useful.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring our models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is the case with most applications, we begin by declaring our data models
    and any relationships that they require. We will, of course, require a `User`
    model, which will be the centerpiece of the OAuth authorization and token exchange.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from our brief overview of the OAuth terminology and the basic
    three-legged authorization grant flow, the access tokens are what allow a client
    (our Dinnerly application) to query resources on a remote service provider (for
    example, Twitter or Facebook). As we need these tokens to make requests to the
    listed service providers, we're going to want to store them somewhere so that
    we can use them without having the user reauthenticate for every action; this
    would be quite tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `User` model will be quite similar to the `User` models that we have used
    previously (although we removed a few attributes to simplify things a bit), and
    we''ll place it in the obvious location of `application/users/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have not included anything regarding a password. As the intent
    of this application is to require either Facebook or Twitter to create an account
    and log in, we've eschewed the typical username/password credentials combination
    in favor of delegating authentication to one of these third-party services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with our user session management, we''re going to reuse the Flask-Login
    extension that we explored in a previous chapter. In case you''ve forgotten, one
    of the basic requirements of the extension is to have four methods declared on
    whatever model you are using to represent an authenticated user: `is_authenticated`,
    `is_active`, `is_anonymous`, and `get_id`. Let''s append the most basic versions
    of these methods to our already declared `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, you may have noticed that there are no declared attributes on the `User`
    model for our Twitter or Facebook access tokens. Adding these attributes are an
    option, of course, but we're going to use a slightly different approach that requires
    more up-front complexity and will allow more providers to be added without polluting
    our `User` model more than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our approach will center on the idea of creating multiple one-to-one data relationships
    between a user and the various provider types that will be represented by their
    own models. Let''s add our first provider model in `application/users/models.py`
    to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding model declares a foreign key relationship to the `User` model
    via the `user_id` attribute, and the additional fields (other than the primary
    key) store the requisite OAuth token and secret to make authenticated requests
    to the Twitter API on behalf of the user. Additionally, we store the Twitter `screen_name`
    and `twitter_user_id` to give us the option of using this value as username for
    the related user. Keeping the Twitter user ID around helps us match users on Twitter
    with local Dinnerly users (as `screen_name` can be changed but the IDs are immutable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `TwitterConnection` model is defined, let''s add the relationship
    to the `User` model so that we can access the associated credentials via the `twitter`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This establishes a very simple one-to-one relationship between `User` and `TwitterConnection`.
    The `uselist=False` argument ensures that the configured attribute will refer
    to a scalar value instead of a list, which would be the default for a one-to-many
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, once we''ve obtained a user object instance, we can access the
    associated `TwitterConnection` model data via `user.twitter`. If no credentials
    have been attached, then this will return `None`; if there are attached credentials,
    we can access the subattributes just as you expect: `user.twitter.oauth_token`,
    `user.twitter.screen_name`, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for the equivalent `FacebookConnection` model, which has
    similar attributes. The difference from the `TwitterConnection` model is that
    Facebook OAuth only requires a single token (instead of a combination token and
    secret), and we can choose to store the Facebook-specific ID and name (whereas
    in the other model, we stored the Twitter `screen_name`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve established this model, we''ll want to introduce the relationship
    to our `User` model as we did for the `TwitterConnection` model previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The functionality and usage of the preceding `facebook` attribute of a `user`
    instance is identical to that of the `twitter` attribute that we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: Handling OAuth in our views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our basic user and OAuth connection models established, let''s start constructing
    the required Flask-OAuthlib objects to handle the authorization grant flows. The
    first step is to initialize the extension in the usual way for our application
    factory. While we''re at it, let''s also initialize the Flask-Login extension,
    which we will use to manage authenticated sessions for our logged-in users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an `oauth` object available to us, we can instantiate separate
    OAuth remote application clients for each service provider. Let''s place these
    in our `application/users/views.py module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there seems to be quite a lot going on during the instantiation of these
    OAuth objects, but most of it is simply telling the generic OAuth connection library
    where the service provider URI endpoints exist for various portions of the three-legged
    OAuth authorization grant flow. There are, however, a few argument values that
    you''ll need to fill in yourself: the consumer keys (for Twitter) and the application
    keys (for Facebook). To obtain these, you must register a new OAuth client application
    on the respective services, and you can do so here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Twitter: [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new),
    and then navigate to the **Keys** and **Access Tokens** tab to obtain the consumer
    key and consumer secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Facebook: [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    and agree to the terms of service and register your account for application development.
    Once there, select the website type of application to add and follow the instructions
    to generate the required application ID and application secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of Facebook, we requested the ability to publish to the wall of
    the user in question via the `publish_actions` value of the scope key in the `request_token_params`
    argument of the `remote_app` method of the OAuth object that we've created. This
    is enough for our purposes, but if you want to interact with the Facebook API
    more than simply pushing status updates, you'll need to request the correct set
    of permissions. The Facebook documentation has additional information and guidelines
    on how third-party application developers should use the permission scope values
    to perform different actions.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've obtained the requisite keys and secrets, insert them where we left
    placeholders in the preceding `oauth` remote application client configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to have our application handle the various portions of the authorization
    flow that require users to request a grant token from the service provider. We
    also need our application to handle the callback routes that the service provider
    will redirect to with the various OAuth tokens and secrets once the process is
    completed so that we can persist these values to our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s whip up a users Blueprint to namespace the various routes in `application/users/views.py`,
    and while we''re at it, import a few utilities from Flask and Flask-Login to help
    our integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the requirements of Flask-Login, we need to define a `user_loader` function
    that will fetch a user from our database by the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In a very similar fashion, Flask-OAuthlib requires us to define a method (per
    service, of course) that will act as a token getter; while Flask-Login needs `user_loader`
    to fetch users from our database by the ID. The OAuthlib needs to have a function
    that fetches the OAuth token(s) of the currently logged-in user. If no user is
    currently logged in, then the method should return `None`, indicating that we
    should probably start an authorization grant flow to obtain the required tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we used the `current_user` proxy object that Flask-Login provides
    us with in order to access the object of the currently authenticated user, and
    then we call the `is_authenticated` method that we defined in our `User` model
    earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we need to define the routes and handlers to kick off the three-legged
    authorization grant. Our first users Blueprint route will handle attempted logins
    using Twitter as the third-party provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding route first determines if the current user is already authenticated
    and redirects them to the main `recipes.index` route handler if they are.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've set up some redirects for the `recipes.index` route, which we have yet
    to define. If you intend on testing out this part of the application before we
    set these up, you'll have to either add a stub page to that Blueprint route or
    change it to something else.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not already authenticated, we initiate the authorization grant
    via the `twitter.authorize` method invocation. This will initiate the OAuth flow,
    and upon successful completion of the grant (assuming that the user consents to
    allow our application to access to their third-party protected resources), Twitter
    will invoke a GET request to the callback URL that we provided as the first argument.
    This request will contain the OAuth tokens and any additional information that
    they have deemed useful (such as `screen_name`) in the query arguments, and it's
    then up to us to handle the request as we would any other and extract out the
    information that we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, we define a `twitter_authorized` route handler whose sole purpose
    is to extract out OAuth tokens and secrets so that we can persist them in our
    database and then use the `login_user` function from Flask-Login to create an
    authenticated user session for our Dinnerly application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding route handler, we first attempt to extract the OAuth data from
    the grant flow, which is made available to us in `twitter.authorized_response()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the user decided to decline the authorization grant request, then `twitter.authorized_response()`
    will return `None`. Handling this error scenario is left as an exercise for the
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: A Flash message and redirect to a page describing what happened are probably
    a good start!'
  prefs: []
  type: TYPE_NORMAL
- en: Once the OAuth tokens have been extracted from the OAuth data response of the
    grant flow, we check the database to see if a user with this token already exists.
    If this is the case, then the user has already created an account on Dinnerly
    and simply wishes to reauthenticate. (Perhaps as they are using a different browser,
    thus they do not have the previously generated session cookie available.)
  prefs: []
  type: TYPE_NORMAL
- en: If no user in our system has the OAuth token assigned to them, then we create
    a new `User` record with the data that we've just received. Once this is persisted
    to the SQLAlchemy session, we log them in using the `login_user` function from
    Flask-Login.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we focused on the route handlers and Twitter OAuth authorization grant
    flow here, the process for Facebook is very similar. Our users Blueprint gets
    two more routes attached, which will handle the logins that want to use Facebook
    as the third-party service provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the `facebook_authorized` handler, which will receive the OAuth
    token parameters via the query arguments, in a very similar manner to the `twitter_authorized`
    route handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: One nontrivial difference between this handler and the one that we previously
    defined for Twitter is the invocation of the `facebook.get('/me')` method. Once
    we've performed the authorization grant exchange, the facebook OAuth object is
    able to make authenticated requests to the Facebook API on behalf of the user.
    We will use this newfound ability to query for some basic details regarding the
    user who delegated the authorization credentials, such as the Facebook ID and
    name of the user in question. Once obtained, we store this information along with
    the OAuth credentials for the newly created user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve allowed users to create authenticated accounts on Dinnerly
    with Twitter or Facebook, we need to create something worth sharing on these social
    networks! We''ll keep things very simple with a `Recipe` model, which we''ll create
    in the `application/recipes/models.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing incredibly special about the `Recipe` model that we''ve just
    defined; it has a title, ingredients, and instructions. Each recipe is owned by
    a single user, and we''ve created the requisite relationship-based field and our
    `ForeignKey` entry in the model so that our data is properly linked together in
    the usual relational database way. There are a few fields to store the typical
    things that you''d expect in any recipe: `title`, `ingredients`, and `instructions`.
    As the point of Dinnerly is to share snippets of recipes on various social networks,
    we should add a method that will help generate a short summary of a recipe and
    limit it to fewer than 140 characters (to appease the Twitter API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `summarize` method will return the title of `Recipe` if the title
    contains fewer than 140 characters. If it contains more than 140 characters, we
    will split the string into a list using a space as the delimiter, use `rsplit`
    (which starts at the end of the string instead of the beginning as `str.split`
    does), and then append the ellipsis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `summarize` method that we just defined will only reliably work for ASCII
    text. There exist Unicode characters that may resemble a space as represented
    in the ASCII character set, but our method will not split on these correctly as
    it's expecting a different character.
  prefs: []
  type: TYPE_NORMAL
- en: Posting recipes to Twitter and Facebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upon posting a new recipe, we''d like to automatically post the summary to
    the services that have been connected for the user in question. There are, of
    course, many ways to go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: In our yet-to-be defined recipe view handlers, we could call the respective
    OAuth connection object methods after the successful creation/committing of a
    `Recipe` object instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user could be required to visit a particular URI (or submit a form with
    particular data), which would trigger the cross-posting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `Recipe` object is committed to the database, we could listen for the
    `after_insert` event emitted by SQLAlchemy and push out our summary to the connected
    social networks then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the first two options are relatively simple, somewhat boring, and we haven't
    explored SQLAlchemy events at all in this book so far, the third option is the
    one that we'll implement.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the less well-known features of SQLAlchemy is the event API, which publishes
    several core and ORM-level hooks that will allow us to attach to and execute arbitrary
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The event system is very similar in spirit (if not in implementation) to the
    Blinker dispatching system that we saw in a previous chapter. Instead of creating,
    publishing, and consuming blinker-based signals, we are simply going to listen
    for events published by the SQLAlchemy subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Most applications will never need to implement handlers for the various events
    that are published. They are usually the purview of plugins and extensions to
    SQLAlchemy, which allow the developer to augment the functionality of their application
    without requiring them to write large amounts of boilerplate connector / adapter
    / interface logic to interact with these plugins or extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy events that we are interested in are categorized under ORM Events.
    Even in this restricted umbrella of events (there are a plethora of additional
    published core events that we won''t even discuss here), there are still quite
    a few events. What most developers are interested in, generally, are the mapper-level
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before_insert`: This receives an object instance before an `INSERT` statement
    is emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_insert`: This receives an object instance after an `INSERT` statement
    is emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before_update`: This receives an object instance before an `UPDATE` statement
    is emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_update`: This receives an object instance after an `UPDATE` statement
    is emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before_delete`: This receives an object instance before a `DELETE` statement
    is emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_delete`: This receives an object instance after a `DELETE` statement
    has been emitted corresponding to that instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each named event is emitted along with the SQLAlchemy `Mapper` object (which
    defines the correlation of `class` attributes to database columns), Connection
    object that was/will be used to execute the query, and target object instance
    that was being acted on.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the idea is that the developer would use the raw connection object
    to execute simple SQL statements (for example, increment a counter, add a row
    to a logging table, and so on). We, however, will use the `after_insert` event
    to publish a summary of our recipe to both Twitter and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a bit simpler from an organizational standpoint, let''s move
    the Twitter and Facebook OAuth client object instantiations to their own module
    in `application/users/services.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In moving this functionality to a separate module, we can avoid some of the
    more nasty possibilities for circular imports. Now, in the `application/recipes/models.py`
    module, we will add the following function that will be invoked when the `after_insert`
    event is emitted and identified by the `listens_for` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our listener function only requires a target (the recipe instance that was acted
    on) for our purposes. We get the recipe summary thanks to our previously written
    `Recipe.summarize()` method, and then use the post method of both OAuth client
    objects (accounting for the different endpoint URIs and expected payload formats
    for each service) to create a status update across whichever services the user
    who posted the recipe has connected to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The error-handling code for the function that we defined here is somewhat inefficient;
    each API may return different HTTP error codes, and it's quite possible that one
    service may accept the post while the other would refuse it for some as yet unknown
    reason. Handling the various failure modes that may arise when interacting with
    multiple remote third-party APIs is complex and could be the subject of a book
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Finding common friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very typical feature of most modern, socially-oriented web applications is
    the ability to find users on an application that you are already familiar with
    on some other application social network. This helps you to bootstrap any sort
    of friendship/follower model that you may want to implement for your application.
    Nobody likes to have zero friends on a new platform, so why not connect with the
    friends that you've already made in other places?
  prefs: []
  type: TYPE_NORMAL
- en: This is relatively easy to accomplish by finding the intersection of accounts
    that the user is following on Twitter and users that currently exist in the Dinnerly
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An intersection C of two sets, A and B, is the set of common elements that exist
    in A and B and no other elements.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't already understand the basic concepts of mathematical sets and
    the operations that can be performed on them, a primer on the naïve set theory
    should be on your reading list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding a route handler that an authenticated user can query to
    find their list of common friends in our `application/users.views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used simple `abort()` calls in the preceding method, but there's nothing
    stopping you from creating templates that are rendered with additional information
    to help the end user understand why a certain operation failed.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding view function is wrapped with the `login_required` decorator from
    our trusty Flask-Login extension to ensure that any request to this route is made
    by an authenticated user. An unauthenticated user would not be able to find common
    friends on Dinnerly for somewhat obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: We then ensure that the authenticated user has connected a set of Twitter OAuth
    credentials and pluck out the `twitter_user_id` value so that we can properly
    construct the Twitter API request, which requires either the ID or `screen_name`
    of the user in question.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While `screen_name` might seem slightly easier to debug and reason about than
    a long numeric identifier, remember that it is possible for a person to update
    `screen_name` on Twitter at any time. If you wanted to rely on this value, you
    would need to write some code to verify and update the locally stored `screen_name`
    value if and when it does change on the remote service.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `GET` request is made for the Twitter IDs of the people that the account
    follows on the remote service, we parse this result and construct a list of integers
    that we can then pass to a SQLAlchemy query on the User-mapped class. Now that
    we've obtained a list of users, we can pass these to our view (which we will not
    provide an implementation of—this is left as an exercise for the reader).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, finding common friends is only half of the equation. Once we've found
    users that are our friends on Twitter, the next step is to follow them on Dinnerly
    as well. For this, we need to add a (minimal!) social component to our application,
    similar to what we implemented in a previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This will require adding a few database-related entities, which we can do using
    our normal procedure of updating/adding the relevant models and then recreating
    the database schema, but we'll take this opportunity to explore a more formalized
    method of tracking schema-related changes.
  prefs: []
  type: TYPE_NORMAL
- en: Interlude – database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For quite some time in the world of application development, we used a variety
    of tools to track and record code-related changes over time. Generally, these
    fall under the umbrella of version control systems, or VCS, and there are many
    of them to choose from: Git, Mercurial, Subversion, Perforce, Darcs, and several
    others. Each system functions in a slightly (or not so slightly) different manner,
    but they all have the same goal of preserving point-in-time snapshots of a codebase
    (or portions of a codebase, depending on the tool being used) so that it can be
    recreated at a later time.'
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of web applications that is generally difficult to capture and track
    is the current state of the database. In the past, we made do by storing entire
    SQL snapshots along with the application code and would instruct developers to
    drop and recreate their database. The next level of improvement on this would
    be the creation of small SQL-based scripts that should be run in a particular
    order to gradually build up the underlying schema progressively in such a way
    that when modifications are required, another small SQL-based script is added
    to the list.
  prefs: []
  type: TYPE_NORMAL
- en: While this latter method is quite flexible (it can work for almost any type
    of application that depends on a relational database), a slight abstraction that
    could leverage the functionality of the SQLAlchemy object-relational model that
    we already use would be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Alembic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Such an abstraction already exists, and it's called Alembic. This library, by
    the same author of SQLAlchemy, allows us to create and manage the changesets that
    correspond to the schema modifications that are required to accommodate the modifications
    that are made to our SQLAlchemy data models.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most of the libraries that we''ve discussed over the course of this
    book, it has been wrapped in a Flask extension as Flask-Alembic. Let''s install
    it in our current virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As most of Flask-Alembic''s functionalities can and should be controlled via
    CLI scripts, the package includes hooks to enable a Flask-Script command. So let''s
    install this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create our `manage.py` Python script to control our CLI commands as
    sibling to our `application/ package` and ensure that it includes the db hooks
    to integrate Flask-Alembic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both of these extensions installed, we need to configure the
    Flask-Alembic extension so that it''s aware of our application object. We will
    do this in the usual way in our application factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s capture the current database schema that is described by the SQLAlchemy
    models that we defined in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will create two new files in the `migrations/ folder` (which was created
    the first time this command was run), one of which will be named with a bunch
    of random characters followed by `_initial_schema.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The random-looking characters are actually not so random: they are hash-based
    identifiers that help the migration system behave in a more predictable manner
    when there can be multiple developers working on migrations for different portions
    of the application all at the same time, which is somewhat typical these days.'
  prefs: []
  type: TYPE_NORMAL
- en: The other file, `script.py.mako`, is the template that Alembic will utilize
    to generate these automatic revision summaries when the command is invoked. This
    script can be edited to suit your needs, but don't remove any of the template
    `(${foo})` variables!
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated migration file includes two function definitions: `upgrade()`
    and `downgrade()`. The upgrade function is run when Alembic takes the current
    database revision (which is `None` at this point) and attempts to bring it to
    the target (often the latest) revision. The `downgrade()` function does the same
    but for the opposite direction. Having both is very convenient for rollback-type
    situations, when switching between code branches that contain different sets of
    migrations, and several other edge cases. Many developers ignore the generation
    and testing of downgrade migrations and then sorely regret it at a later date
    in the lifetime of the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your exact migration may look a little bit different based on what relational
    database you''re using, but it should look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, there's quite a lot going on in this script, or at least it seems so. What's
    happening in the `upgrade()` function is the creation of the tables that correspond
    to the model metadata that we've defined in the application and the fields that
    belong to them. Alembic was able to infer what needed to be generated by comparing
    the current model definitions with the currently active database schema and outputting
    the list of commands that are required to synchronize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the syntax elements should be relatively self-explanatory if you are
    familiar with relational database terminology (columns, primary keys, constraints,
    and so on), and you can read about what they all mean in the Alembic operation
    reference: [http://alembic.readthedocs.org/en/latest/ops.html](http://alembic.readthedocs.org/en/latest/ops.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the initial schema migration generated, now it''s time to apply it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will emit the necessary SQL (based on the generated migration) to the RDBMS
    that you configured in the Flask-SQLAlchemy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this rather lengthy and content-filled chapter, you should feel more at
    ease with OAuth and OAuth-related implementations and general terminology, and
    additionally, the usefulness of database migrations, especially the style of migrations
    produced by Alembic that are synchronized to the table and the constraint metadata
    declared in the application models.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter started out with an in-depth exploration of the OAuth authorization
    grant flow and terminology—no small feat considering the complex nature of OAuth!
    Once we established a bit of a knowledge baseline, we implemented an application
    that leveraged Flask-OAuthlib to provide users with the ability to create accounts
    and sign in with third-party services such as Twitter and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: After fleshing out the data handling portions of the example application, we
    then turned our attention to Alembic, the SQLAlchemy data migration toolkit, to
    synchronize the changes in our models with our relational database.
  prefs: []
  type: TYPE_NORMAL
- en: The project that we started in this final chapter is a great kick-off point
    for most socially-aware web applications. You are highly encouraged to use the
    knowledge gained in this and the previous chapters to create a modern, highly-tested,
    functional web application.
  prefs: []
  type: TYPE_NORMAL
