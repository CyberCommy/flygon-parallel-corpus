- en: Creating Schema-Driven Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms come in different shapes, sizes, and levels of complexity. It is relatively
    simple to quickly scaffold a login form or a contact form with a few fields, but
    what happens when you have to take it to the next level and create a completely
    dynamic form that is driven by an API or schema?
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, we have worked with a relatively simple form that only asks the
    user for some basic data but everything is hardcoded as a static form. If our
    mock website wanted to add or remove some fields from the form, we would have
    to manually make the changes, deploy them to our server, and possibly even adjust
    the backend to handle the different fields. But what if we wanted to automate
    this whole process?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build an example dynamic form that will be completely
    powered by an API endpoint. Schema-driven forms are very powerful, as they can
    be controlled and modified directly by your application's API. That means when
    something changes in your backend, your form will automatically adjust itself
    not only on the frontend but also into a self-aware understanding of how to send
    the dynamic data back to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the starter kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the schema and creating a `Renderer` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically binding user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mock API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the new API into the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating the API into a working schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will assume that you have either read or understand the concepts viewed in
    the previous chapters, such as using Axios for HTTP calls and component creation,
    and have installed on your system as a mock API provider. You can refer to this
    link for more information: [https://mockoon.com/](https://mockoon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To expedite the scaffolding of our app, I have set us up with a starter Vue
    CLI-3-powered repository with a couple of custom components and a sample static
    form. You can clone or download it from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2VMe3eU](http://bit.ly/2VMe3eU)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the starter kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you clone or download the starter repository, you will find yourself with
    a Vue CLI 3 project. The first thing to do is to take a look at what we are going
    to be working with! The repository contains a very simple form with some input
    fields and a select box. You can find the structure for the form in `App.vue`.
    As you can see, we are using two different custom components, `BaseInput` and
    `BaseSelect`. Both of these can be found inside the `src/components` folder. They
    both wrap an `input` and `select` tag, respectively, and expose some properties
    that we can use to inject the necessary data into each of them, such as `labels`
    and `options`.
  prefs: []
  type: TYPE_NORMAL
- en: I have taken the liberty of already adding Axios to the project dependencies;
    you can check out `package.json` to corroborate. Bootstrap's CSS file for some
    base classes has been imported inside `main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a good overview of the project structure, let''s go ahead
    and install the dependencies and run them on our browser. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the Terminal and run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, check out the form on your browser and play around with the
    fields. There's nothing fancy going on except for the fields being `v-model` bound
    to the local state in `App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Submit button will only log a message to the console—if you want a refresher
    on how to send form data to your server, check out [Chapter 2](2f5516c2-6f66-4945-b340-645775373cea.xhtml), *A
    Form in its Simplest Form*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of the starting point of our application,
    we are going to prepare the demo schema in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our form (as previously stated) is hardcoded. The first step that
    is required to start making it a dynamic form is to remove the need to add `BaseInput`
    or `BaseSelect` directly to our `App.vue` file every time we need to add a new
    field. This implies that we are going to need to have some sort of organized structure,
    or schema, to represent what we are trying to accomplish for our form. Since we
    are using JavaScript, the most logical way to do this is with a JSON object format.
    This will make it easier later on when we want to take it a step further and have
    our mock API feed the information directly to our form.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will use a static schema. Let's create a data folder inside `src`,
    and inside of it, make a new `schema.json` file. We are going to populate our
    JSON file with some dummy data. I have chosen, for the sake of an example, to
    make the top element an object, and each property inside of it will represent
    one of the fields in our form. Each element will consist of at least a `component`
    property and a `label` property. In the case of drop-down menus, however, we will
    also include `options` to populate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the demo schema, add the following data to `schema.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a structured schema as a demo of what we want our dynamic form
    to understand, we can proceed to the next section—where we will load this schema
    into our application with the help of a `Renderer` component.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the schema and creating a Renderer component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic schema set up to work with, let's go ahead and load
    into the application so that we can use it. Later on in this chapter, we are going
    to create a dummy API that will feed us the data in a slightly different way,
    and we will transform it on our end to fit our app's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s go to `App.vue` and import the JSON. We will start by adding
    the following `import` statement to the top near the other import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our data available to our application, we need some components
    to be able to parse this information into the `BaseInput` and `BaseSelect` components.
    Let''s go ahead and create a new file inside the `components` folder, and name
    it `Renderer.vue`. This component will have a single purpose: to understand our
    schema and render the correct component to the screen. It will currently have
    a single property, `element`, which represents each of the elements in our schema.
    To do so, add the following code to `Renderer.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a couple of important things to note in this component. They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `element` prop is an object and will be required. This component will not
    work at all without it. We have two computed properties. The first component takes
    care of dynamically loading whichever element we need. First, we create a `componentName`
    constant and assign it to the value of `element.component`, which is where the
    string name of our component is stored in the schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to mention that we are not just adding this `const` for clarity
    purposes. The way that computed properties work regarding caching *requires* that
    this `const` exists here since we are returning a function, which will not be
    inspected for dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When this computed property is called by the `<component>` tag for the `:`
    is an attribute—it will load the component and pass it over. Note that this will
    only work if the component is globally registered; in any other case, a computed
    property that requires the correct component would be needed. For further information
    on dynamic components, check out the official documentation: [https://vuejs.org/v2/guide/components-dynamic-async.html](https://vuejs.org/v2/guide/components-dynamic-async.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second computed property, `props`, will simply pass down the whole element
    with its properties as `props` to whatever component we are loading using the
    `v-on` binding. For example, on the `BaseSelect` component, it will pass down
    the `options` property in our schema to the component so that it can render the
    correct options. If you are wondering why we are using a computed property instead
    of just passing the element directly to the `v-on` directive, you are on the right
    track. Right now, it is definitely not needed, but having it set up in this way
    to begin with allows us to, later on, add another level of logic or parsing that
    could be needed for a particular component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's head back to `App.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to import our `Renderer` component and add it to the `template`. We
    also need to clean up a bit; we no longer need to manually import `BaseInput`
    or `BaseSelect`, and our form local state will be soon dynamic—so, there''s no
    need to declare it statically, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and run it in the browser and you should see the three inputs that
    the schema declared in `schema.json`, and the `<select>` should have our three
    options inside of it. You are going to get a couple of console errors at this
    point because we haven't worked on our two-way value bindings for our components,
    and they're set as required. But don't worry, we'll get back to that soon!
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically binding the user's data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What good is any form if we can't use the data that the user inputs? As cool
    as it is that we can generate these forms dynamically based entirely on a schema,
    we still need to be able to store these values somehow so that we can later process
    them as we need. The first step for our form to be able to create two-way bindings
    is to tell `Renderer.vue` how to handle input events from the dynamic components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into `Renderer.vue` and add a `:value` binding, as well as an `@input`
    listener to the `<component>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, in order to `v-model` or two-way bind into a custom component,
    we usually need to pass in a value and listen to input events. In this case, we
    are going to explicitly listen to input events since our custom components all
    fire this type of event for two-way bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add the new `value` prop to our `Renderer` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to implement the `handleComponentInput` method. Keep in mind
    that I have chosen to make it a method instead of just firing the `$emit` directly
    into the `template` for two reasons. The first one is that I have found it to
    be a nice practice to more easily write unit tests later on, and second, it allows
    for more flexibility if we need to write an `if` statement or conditional for
    a particular component that has specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new `handleComponentInput` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that the renderer is ready to two-way bind with `v-model`, let's go back
    to `App.vue`, where we are implementing it and add the actual binding. We are
    going to add the `v-model` attribute to `<Renderer>`, and the trick here is that
    we are going to bind it to `form[name]`. Remember that our schema has a structure
    where the name of the property is the unique identifier for that field. Open `schema.json`
    to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the first field, `firstName` is the name of the property that
    holds the first space in the schema object. This property is what we are going
    to use to bind to so that we can, later on, know which field it represents in
    our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `v-model` to `<Renderer>` in `App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open up your browser and check out your form; if you start filling out the fields
    and look at your `Vue` development tools, you will see that the bindings are all
    working correctly. What renderer is doing through the dynamic `v-model` is tying
    each one of the properties to a property on the form of local data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a quicker way to see this in action without resorting to using
    the `dev` tools, add this following bit of code to your `<Renderer>` component
    in `App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are simply going to dump the form into the screen, and use the HTML `<pre>`
    tag to get some easy formatting. Try going into `schema.json` and adding some
    new fields. You will see the results on your browser immediately, as renderer
    will pick up on the changes of the schema and the page will reload by itself (hot
    reload). With the new schema in place, you will see all of your new fields in
    place.
  prefs: []
  type: TYPE_NORMAL
- en: We're getting places and fast! In the following section, we're going to prepare
    yet again for a demo API. In a real application, you are not going to be serving
    the schema from a file—but probably from a server. Fire up Mockoon, and let's
    do this!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mock API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our demo is to create an actual mock API, which we will then
    translate into a structure that our renderer understands. Why are we approaching
    the problem this way? In real work scenarios, it is not uncommon that the backend
    will not match completely the necessities of the frontend. Perhaps the API was
    built first, or was made with an earlier version of the frontend in mind that
    worked in a wildly different way; there are many possibilities, and in this case,
    we will adjust to an incompatible API to learn how to guard against this.
  prefs: []
  type: TYPE_NORMAL
- en: This approach also ensures that we have a middleman that is going to *translate* and
    understand the API for our app. If the API were to change for whatever reason,
    we could safely just change this middleman to adjust for the changes and, in most
    cases, not even have to touch any of the internal components of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up Mockoon, the app we've been using throughout this book for our dummy
    API calls. If you haven't yet installed it, you can find the download link here: [https://mockoon.com/](https://mockoon.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the environment is running by clicking on the green play button, and
    click on the Add route button on the top of the second column. On the right-hand
    screen, we will add some data. Let's start with the path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Route settings, leave GET as the default verb for the route, and go ahead
    and name the path `/schema`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and navigate to the second tab, Headers, and set a single header to
    Content-Type: `application-json`. On the plus side, this will give us some nice
    color coding on the next part.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the first tab, Response & Body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the Body section, go ahead and copy the following structure. Note that
    it is not what we had before in our `schema.json` file, but a similar structure
    that we are going to have to interpret later on. We will even ignore some of the
    data in there since it won''t be of use for our current form—it is not uncommon
    for APIs to sometimes return data that we don''t really use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Take a good look at the structure of the JSON that is being returned by the
    API in this case. You will start to see some similarities in how the backend is
    trying to describe what it needs, and what the renderer on the frontend is expecting
    to get.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are faced with this type of choice in your day-to-day life, you will
    realize there are two ways we can go about it:'
  prefs: []
  type: TYPE_NORMAL
- en: We can either change the frontend implementation on a component level to adjust
    to the new API, which in some instances could be what we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, we can make a small library or file that will interpret the API for our
    backend. We are going for this choice for the reasons I have described earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our dummy API, we can teach our application how to *translate* this
    new API format into something that it understands. This part of the process is
    very important, as you don't want to have to modify your whole application every
    time there's a change in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the new API into the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, if you head into `App.vue`, you will notice we are loading the static
    schema through an `import` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This worked very well for us before, as it was a static file, but this time
    around, we need to make a call to our API endpoint to get the schema for our form.
    Let''s start by removing the import statement; we don''t need it anymore and can
    safely delete it. You can also go into the `data()` properties and set `schema`
    to a default, which will be an empty object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I think that a good place to load our form's schema will be on the created hook
    for our `App.vue` file. We want to get this done as soon as possible, and we don't
    really need to manipulate any DOM when it loads, just set the result of the call
    to the schema's internal property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import Axios to the top of our `App.vue` file, near the `Renderer` import,
    since we are going to use it shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and add a newly created hook to our `App.vue` component; inside of
    it, we will make a simple Axios call to our mock API endpoint. Remember to check
    on Mockoon to see that it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are making a call to our new endpoint, `http://localhost:3000/schema`, with
    the Axios `GET` method. Make sure you check that Mockoon is using the port `3000`
    for your mock API, or feel free to adjust the URL as needed. Axios calls return
    a promise—if it fails, we are going to log the error. If the call is successful
    however, we want to make sure that we capture the whole response and pass down
    the `data` property of this response to the schema's internal data. It's important
    to keep in mind that, in this particular case, the response the API is giving
    us should be the direct JSON schema object. If your API returns a different structure,
    such as a nested object or array, you will have to adjust accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your browser and reload the page if needed. It looks like we managed
    to break the application completely, as was expected. When we assigned the new
    APIs response to our schema's `data` property, the application tried to load each
    of the items into the renderer, but it is not prepared to understand this new
    format of schema that our backend is serving us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how to build a very lean utility
    library that will allow us to parse this new structure into what the renderer
    can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Translating the API into a working schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our mock API running, the next step is to create a way for
    our application to parse or translate this API structure into the schema structure
    that we had before, and that it understands. If you are curious enough to try
    to run the application at this point, you will encounter a ton of console errors
    that yell at you about prop: type check failed and `v-model` failing to bind.
    This is expected at this point.'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a new folder inside `src`; we are going to call it `libraries`.
    This is not a strict naming convention, so feel free to name it whatever makes
    more sense to you or your team. Inside this folder, we are going to make a new
    file called `Api.js`. Our goal for this file is to put all of the code that handles
    the parsing of the API schema into the app's schema here. This way, we can import
    whatever we need into our components, and we have a single source of truth regarding
    the translation of API to schema—if either of these ends change for any reason,
    we only have to update it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding an entry point; it will be a function called `parse`
    and will take a single argument: the response from the APIs `schema` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Right now, we are just going to return the `schema` as is, so we can start with
    small steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and import this function into `App.vue` at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the created hook, update the `then` block to use the function
    before we assign it to the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can go back to `Api.js` now, and we're going to do a basic implementation
    of this parser. In reality, the complexity of the code here will depend on how
    much disparity there is between your app's requirements and the APIs structure.
    Thankfully for us, it only implies a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Api.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down what is happening here into small chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a constant field, which will just extract the `fields` property
    out of our API data since it is nested there—we don't really care about the other
    data it sends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new object, `parsedSchema`, where we will add a property for each
    of the fields of our form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We loop through each of the items inside of `fields` and create a property for
    it. In our API schema, the `id` property holds the unique name of the field, so
    we are going to use that for our property name, `parsedSchema[field.id]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign an inside object to the component property, which is the result of
    our new `componentForField` function, in which we figure out which component we
    have to use for each case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `options` property, we check whether the `opts` property exists in the
    API schema or set it as null. It is important to keep in mind that, even if the
    `BaseInput` component isn't expecting this property, for example, it will not
    care whether it is there and set to null or undefined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we return the parsed version of the schema, which our app can use to
    render the form into its working state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and run it in your browser and behold your schema-driven, API-driven
    dynamic form!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a moment to give yourself a huge pat on the back. You've made it not only
    to the end of this chapter but to the end of this book! In this chapter, you have
    acquired the knowledge and skills to understand the use cases of schema-driven
    forms, and the ability to create a `Renderer` component to accommodate these cases.
    You know how to create a library to parse the output from the backend into your
    own form and how to feed back the form data to the API when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go out, make some dynamic forms, and eat lots of avocados!
  prefs: []
  type: TYPE_NORMAL
