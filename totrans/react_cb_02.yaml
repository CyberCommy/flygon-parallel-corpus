- en: Conquering Components and JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 征服组件和JSX
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下内容：
- en: Creating our first React component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个React组件
- en: Organizing our React application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的React应用程序
- en: Styling a component with CSS classes and inline styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS类和内联样式为组件设置样式
- en: Passing props to a component and validating them with PropTypes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将props传递给组件并使用PropTypes进行验证
- en: Using local state in a component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中使用本地状态
- en: Making a functional or stateless component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数式或无状态组件
- en: Understanding React lifecycle methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React生命周期方法
- en: Understanding React Pure Components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React纯组件
- en: Preventing XSS vulnerabilities in React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中防止XSS漏洞
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter contains recipes related to how to create components in React.
    We are going to learn how to create React components (class components, pure components,
    and functional components) and organize our project structure. We'll also learn
    how to use React local state, implement all the React lifecycle methods, and finally,
    we'll see how to prevent XSS vulnerabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含与在React中创建组件相关的内容。我们将学习如何创建React组件（类组件、纯组件和函数组件）并组织我们的项目结构。我们还将学习如何使用React本地状态，实现所有React生命周期方法，最后，我们将看到如何防止XSS漏洞。
- en: Creating our first React component
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个React组件
- en: The component is the essential part of React. With React you can build interactive
    and reusable components. In this recipe, you will create your first React component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是React的重要部分。使用React，您可以构建交互式和可重用的组件。在这个配方中，您将创建您的第一个React组件。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we need to create our React application using `create-react-app`. Once
    that is done, you can proceed to create your first React component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`create-react-app`创建我们的React应用程序。完成后，您可以继续创建您的第一个React组件。
- en: Before you install `create-react-app`, remember that you need to download and
    install Node from [www.nodejs.org](http://www.nodejs.org). You can install it
    for Mac, Linux, and Windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装`create-react-app`之前，请记住您需要从[www.nodejs.org](http://www.nodejs.org)下载并安装Node。您可以为Mac、Linux和Windows安装它。
- en: 'Install `create-react-app` globally by typing this command in your Terminal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下命令全局安装`create-react-app`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or you can use a shortcut:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用快捷方式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s build our first React application by following these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤构建我们的第一个React应用程序：
- en: 'Create our React application with the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建我们的React应用程序：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Go to the new application with `cd my-first-react-app` and start it with `npm
    start`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到新应用程序，使用`cd my-first-react-app`进入，并使用`npm start`启动它。
- en: The application should now be running at `http://localhost:3000`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序现在应该在`http://localhost:3000`上运行。
- en: 'Create a new file called `Home.js` inside your `src` folder:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`src`文件夹中创建一个名为`Home.js`的新文件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'File: src/Home.js'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/Home.js
- en: 'You may have noticed that we are exporting our class component at the end of
    the file, but it''s fine to export it directly on the class declaration, like
    this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在文件末尾导出了我们的类组件，但直接在类声明上导出也是可以的，就像这样：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'File: src/Home.js'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/Home.js
- en: I prefer to export it at the end of the file, but some people like to do it
    in this way, so it depends on your preferences.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在文件末尾导出它，但有些人喜欢以这种方式做，所以这取决于您的偏好。
- en: 'Now that we have created the first component, we need to render it. So we need
    to open the `App.js` file, import the `Home` component, and then add it to the
    render method of the `App` component. If we are opening this file for the first
    time, we will probably see a code like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个组件，我们需要渲染它。因此，我们需要打开`App.js`文件，导入`Home`组件，然后将其添加到`App`组件的渲染方法中。如果我们是第一次打开这个文件，我们可能会看到类似这样的代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'File: src/App.js'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/App.js
- en: 'Let''s change this code a little bit. As I said before, we need to import our
    `Home` component and then add it to the JSX. We also need to replace the `<p>`
    element with our component, like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下这段代码。正如我之前所说，我们需要导入我们的`Home`组件，然后将其添加到JSX中。我们还需要用我们的组件替换`<p>`元素，就像这样：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'File: src/App.js'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/App.js
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, we imported `React` and `Component` from the React library.
    You probably noticed that we are not using the `React` object directly. To write
    code in JSX, you need to import `React`. JSX is similar to HTML, but with a few
    differences. In the following recipes, you will learn more about JSX.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们从React库中导入了`React`和`Component`。你可能注意到我们并没有直接使用`React`对象。要在JSX中编写代码，你需要导入`React`。JSX类似于HTML，但有一些不同之处。在接下来的示例中，你将学习更多关于JSX的知识。
- en: 'This component is called a `class` component (`React.Component`), and there
    are different types: pure components (`React.PureComponent`) and functional components,
    also known as stateless components, which we will cover in the following recipes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件被称为`class`组件（`React.Component`），有不同的类型：纯组件（`React.PureComponent`）和功能组件，也被称为无状态组件，我们将在接下来的示例中介绍。
- en: 'If you run the application, you should see something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你应该会看到类似这样的东西：
- en: '![](assets/37d1b4cf-d6b1-4f07-abbf-904a802e686a.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37d1b4cf-d6b1-4f07-abbf-904a802e686a.png)'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In our example, we created the `Home.js` file, and our component's name is `Home`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了`Home.js`文件，我们组件的名称是`Home`。
- en: All React component names should start with the first letter capitalized in
    both the file and the class name. To begin with, it might feel uncomfortable for
    you to see this, but this is the best practice in React.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有React组件的名称都应该以文件和类名的首字母大写开头。一开始，你可能会感到不舒服，但这是React中的最佳实践。
- en: Some of the main differences between JSX and HTML are the attributes names.
    You may have noticed that we are using `className` instead of `class`. This is
    the only special attribute name. Others that are two words separated by a dash
    need to be converted to camelCase, for example, `onClick`, **`srcSet`**, and `tabIndex`.
    The `aria-*` and `data-*` attributes still uses the same nomenclature (`data-something` and `aria-label`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JSX和HTML之间的一些主要区别是属性名称。你可能已经注意到，我们使用`className`而不是`class`。这是唯一的特殊属性名称。其他由破折号分隔的两个单词需要转换为驼峰命名法，例如，`onClick`，**`srcSet`**和`tabIndex`。`aria-*`和`data-*`属性仍然使用相同的命名法（`data-something`和`aria-label`）。
- en: Organizing our React application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的React应用程序
- en: In this recipe, we will learn how to structure our project in a better way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何更好地组织我们的项目。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We can create React components with the default structure that `create-react-app`
    provides, but in this recipe, I'll show you a better way to organize the project
    so that we are ready when for when the application grows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`create-react-app`提供的默认结构创建React组件，但在这个示例中，我将向你展示更好的组织项目的方法，以便在应用程序增长时做好准备。
- en: We need to create a new React app (check the last recipe if you haven't created
    a React app yet)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的React应用程序（如果你还没有创建React应用程序，请查看上一个示例）
- en: 'Currently, our React application directory tree looks like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的React应用程序目录树看起来像这样：
- en: '![](assets/92e8684d-42cf-416f-a60a-5afcff61c84b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92e8684d-42cf-416f-a60a-5afcff61c84b.png)'
- en: We need to create `src/components` and `src/shared` directories
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建`src/components`和`src/shared`目录
- en: After this, we need to create the `src/components/Home` directory for our component and
    move **`Home.js`** into this folder
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要为我们的组件创建`src/components/Home`目录，并将**`Home.js`**移动到这个文件夹中
- en: The `App.js` file stays at the `src/components` level
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.js`文件保持在`src/components`级别'
- en: Also, `App.css` and `App.test.js` will stay at `src/components` level
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`App.css`和`App.test.js`将保持在`src/components`级别
- en: Move the `logo.svg` file to `src/shared/images`
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`logo.svg`文件移动到`src/shared/images`
- en: Our `index.js` will stay at the `src/` level
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`index.js`将保持在`src/`级别
- en: 'Now your directory tree should look like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的目录树应该是这样的：
- en: '![](assets/3ba9e4f5-31dd-4ec2-b313-a65fc5056d59.png)I highly recommend that
    you create another directory for shared components, `src/shared/components.`I''ll
    explain more about this in the next recipes.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3ba9e4f5-31dd-4ec2-b313-a65fc5056d59.png)我强烈建议你为共享组件创建另一个目录，`src/shared/components`。我将在下一个教程中详细解释这一点。'
- en: 'In the `App.js` file, change the `logo` and `Home` imports:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，更改`logo`和`Home`的引入：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'File: src/components/App.js'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: 'After you changed that, we need to open the `index.js` and fix the import path
    for the `App` component:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你改变了那个之后，我们需要打开`index.js`并修复`App`组件的导入路径：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'File: src/index.js'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/index.js
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This new structure will give us more flexibility to group our React components
    smartly. With this new structure, we are going to be able to create sub-components,
    if we need them, and that is very important when developing complex applications
    with React.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的结构将使我们更灵活地智能地分组我们的React组件。有了这种新的结构，我们将能够创建子组件，如果我们需要的话，这在使用React开发复杂应用程序时非常重要。
- en: In the next recipes, we will see how to share components in our application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个教程中，我们将看到如何在我们的应用程序中共享组件。
- en: Styling a component with CSS classes and inline styles
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS类和内联样式来为组件添加样式
- en: In the last recipe, we learned how to create a class component. Now let's add
    some CSS to our `Home` component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们学会了如何创建一个类组件。现在让我们为`Home`组件添加一些CSS。
- en: 'In React, one of the best practices is to have the style file in the same directory
    as the component. If you have worked with PHP, Node, or any other server language,
    you probably write your styles in a `style.css` file, and you include it using
    a `link` tag in your template. React uses Webpack, which is the most popular module
    bundler at the moment. With Webpack, we can configure the way that we want to
    handle our styles (using CSS directly or by using a CSS preprocessor such as Sass,
    Stylus, or Less CSS), and with Webpack we can implement CSS modules. This is a
    powerful way to avoid the three main issues of CSS:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，最佳实践之一是将样式文件放在与组件相同的目录中。如果你曾经使用过PHP、Node或任何其他服务器语言，你可能会将样式写在一个`style.css`文件中，并在模板中使用`link`标签进行引入。React使用的是目前最流行的模块打包工具Webpack。通过Webpack，我们可以配置处理样式的方式（直接使用CSS或使用CSS预处理器如Sass、Stylus或Less
    CSS），并且我们可以实现CSS模块化。这是一个强大的方式来避免CSS的三个主要问题：
- en: No more conflicts (unintentional CSS overwrites)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再有冲突（意外的CSS覆盖）
- en: Explicit dependencies (styles per component)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式依赖（每个组件的样式）
- en: No global scope
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全局作用域
- en: In [Chapter 10](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*, Mastering Webpack
    4.x*, we will cover Webpack, and we'll be able to implement CSS modules using Sass or Stylus in
    our project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*，《掌握Webpack 4.x*》，我们将介绍Webpack，并且我们将能够在项目中使用Sass或Stylus来实现CSS模块。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We will now go about adding CSS to our `Home` component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`Home`组件添加CSS：
- en: Create a new application, or use the previous one (`my-first-react-app`).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序，或者使用之前的一个（`my-first-react-app`）。
- en: 'Then create a new CSS file for our `Home` component. Let''s reuse the `Home`
    component we created in the last recipe. Now you need to create a `Home.css` file
    at the same level as your `Home.js` file (inside the `components` folder). Before
    you create this file, let''s modify our `Home` component a little bit:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为我们的`Home`组件创建一个新的CSS文件。让我们重用上一个示例中创建的`Home`组件。现在，您需要在与您的`Home.js`文件相同级别的位置（在`components`文件夹内）创建一个`Home.css`文件。在创建此文件之前，让我们稍微修改我们的`Home`组件：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'We''ll now add styles to our `Home.css`**.** Basically, we wrapped our component
    into a `div` with a `className` of Home, and inside we have an `<h1>` tag with
    the text `Welcome to Codejobs`, and then a `<p>` tag with a message. We need to
    import our `Home.css` file directly, and then our CSS file will look like this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们给我们的`Home.css`**添加样式**。基本上，我们将我们的组件包装在一个`className`为Home的`div`中，里面有一个文本为`Welcome
    to Codejobs`的`<h1>`标签，然后是一个消息的`<p>`标签。我们需要直接导入我们的`Home.css`文件，然后我们的CSS文件将如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'File: src/components/Home/Home.css'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.css
- en: 'Now let''s suppose you need to add an inline style. We do this with the style
    property, and the CSS properties need to be written in camelCase and between `{{
    }}`, like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设您需要添加内联样式。我们可以使用style属性来实现这一点，CSS属性需要以驼峰命名法写在`{{ }}`之间，就像这样：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'You also can pass an object to the `style` property like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以像这样将对象传递给`style`属性：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you can see, it is straightforward to connect a CSS file to our component,
    and if you followed all the steps correctly, your site should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将CSS文件连接到我们的组件非常简单，如果您正确地按照所有步骤进行操作，您的网站应该看起来像这样：
- en: '![](assets/a94c164c-7ab3-4d97-a5f2-7a46f396c26f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a94c164c-7ab3-4d97-a5f2-7a46f396c26f.png)'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You''re probably curious about how the CSS code is added to the browser since
    we haven''t imported a CSS file to our project directly (by using a `<link>` tag,
    for example). Well, you will be surprised to see that the CSS code is being injected
    into our `<head>` tag using the `<style>` tag for each imported stylesheet. If
    you inspect your project with Chrome DevTools you will see something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能好奇CSS代码是如何添加到浏览器中的，因为我们没有直接向项目导入CSS文件（例如使用`<link>`标签）。好吧，您会惊讶地发现，CSS代码是通过使用`<style>`标签将其注入到我们的`<head>`标签中的每个导入样式表中的。如果您使用Chrome
    DevTools检查您的项目，您会看到类似于这样的内容：
- en: '![](assets/737dff60-3cf8-44ac-8d83-b3734177d630.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/737dff60-3cf8-44ac-8d83-b3734177d630.png)'
- en: 'This behavior is because the `style-loader` is a Webpack loader that is being
    used by default in our application when we create it with `create-react-app`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们使用`create-react-app`创建应用程序时，默认使用了名为`style-loader`的Webpack加载器：
- en: '![](assets/26c0d48b-1281-498b-a93c-ef8424d21f29.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26c0d48b-1281-498b-a93c-ef8424d21f29.png)'
- en: There is no way to modify the Webpack configuration directly when we use `create-react-app`
    because it is using a package called `react-scripts`, but in [Chapter 10](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*,
    Mastering Webpack*, we will see how to configure our Webpack without using a starting
    kit such as `create-react-app`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`create-react-app`时，没有直接修改Webpack配置的方法，因为它使用一个名为`react-scripts`的包，但是在[第10章](e95b58ed-e32c-4488-ab8e-b332e235bda8.xhtml)*，掌握Webpack*中，我们将看到如何配置我们的Webpack，而不使用`create-react-app`这样的起始工具包。
- en: There are more Webpack loaders that do different things, such as `css-loader` for
    CSS modules, `sass-loader` to implement Sass, `stylus-loader` to implement Stylus,
    and `extract-text-plugin` to move the CSS code to a `.css` file instead of injecting
    it to the DOM (usually, this is only used in production).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的Webpack加载程序可以执行不同的操作，例如`css-loader`用于CSS模块，`sass-loader`用于实现Sass，`stylus-loader`用于实现Stylus，以及`extract-text-plugin`用于将CSS代码移动到`.css`文件中，而不是将其注入到DOM中（通常，这仅在生产中使用）。
- en: Passing props to a component and validating them with PropTypes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将props传递给组件并使用PropTypes进行验证
- en: So far, you are getting familiar with React components, but there is more to
    it than rendering static HTML. Like any application, we need to be able to send
    information (via props) to different elements. In this recipe, we are going to
    create new components: `Header`, `Content`, and `Footer` (we will group these
    components into a folder called `layout`), and we will send some props (as attributes
    and as children) and validate them with `PropTypes`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经熟悉了React组件，但它不仅仅是渲染静态HTML。像任何应用程序一样，我们需要能够将信息（通过props）发送到不同的元素。在这个示例中，我们将创建新的组件：`Header`，`Content`和`Footer`（我们将把这些组件分组到一个名为`layout`的文件夹中），并且我们将发送一些props（作为属性和子元素）并使用`PropTypes`进行验证。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Taking the same of the React application we created before, let's create first
    our `Header` component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以前创建的React应用程序的名称相同，让我们首先创建我们的`Header`组件。
- en: 'At this point, our current header is placed on `App.js`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们当前的`header`放置在`App.js`中。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'File: src/components/App.js'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: Let's move that header to our new `Header` component and then import it into
    the `App` component. Because the layout components are global or shared, we need
    to create a layout directory in our shared components directory (`src/shared/components/layout`).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将该标题移动到我们的新`Header`组件中，然后将其导入到`App`组件中。因为`layout components`是全局或共享的，所以我们需要在我们的`shared
    components`目录（`src/shared/components/layout`）中创建一个`layout directory`。
- en: 'Before you continue, you must install a package called `prop-types` to use
    the `PropTypes` validation:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，您必须安装一个名为`prop-types`的软件包，以使用`PropTypes`验证：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`PropTypes` was initially released as part of the React core module and is
    commonly used with React components. `PropTypes` is used to document the intended
    types of properties passed to components. React will check the props passed to
    your components against those definitions, and it will send a warning in development
    if they don''t match:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PropTypes`最初作为React核心模块的一部分发布，并且通常与React组件一起使用。`PropTypes`用于记录传递给组件的属性的预期类型。React将检查传递给组件的props与这些定义是否匹配，并且如果不匹配，它将在开发中发送警告：'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'File: src/shared/components/layout/Header.js'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Header.js
- en: The `static` PropTypes property is basically an object where you need to define
    the types of prop you will pass. `array`, `bool`, `func`, `number`, `object`,
    `string`, and `symbol` are primitive types, but there are also particular types,
    such as `node`, `element`, `instanceOf`, `oneOf`, `oneOfType`, `arrayOf`, `objectOf`,
    `shape and any`. There is an optional property called `isRequired` that can be
    added to any type if the prop must be required and will produce a React warning
    if is not defined.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static`的`PropTypes`属性基本上是一个对象，在其中您需要定义将传递的prop的类型。`array`，`bool`，`func`，`number`，`object`，`string`和`symbol`是原始类型，但也有特定的类型，例如`node`，`element`，`instanceOf`，`oneOf`，`oneOfType`，`arrayOf`，`objectOf`，`shape`和`any`。还有一个可选属性叫做`isRequired`，如果prop是必需的，将其添加到任何类型中，如果未定义，将产生React警告。'
- en: 'Import and render our `Header` component:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并渲染我们的`Header`组件：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'File: src/components/App.jsDon''t get confused with the `<Header/>` component, it
    is not the same as the `<header>` tag from HTML5, that''s why in React is recommended
    to use capital letters in the class names.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js不要与`<Header/>`组件混淆，它与HTML5中的`<header>`标签不同，这就是为什么在React中建议在类名中使用大写字母。
- en: 'All the properties passed to our components are contained in this props. You
    may have noticed that we are only sending the `title` prop because it is the only
    one that is required. The `url` prop is optional and also has a default value
    in the destructuring (`http://localhost:3000`). If we don''t pass the title prop,
    even if we have a default value Welcome to React in the destructuring we are going
    to get a warning like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给我们组件的所有属性都包含在这个props中。您可能已经注意到，我们只发送了`title`属性，因为它是唯一必需的属性。`url`属性是可选的，并且在解构中也有一个默认值（`http://localhost:3000`）。如果我们不传递title属性，即使在解构中有一个默认值Welcome
    to React，我们也会收到警告，如下所示：
- en: '![](assets/8eca84f1-f852-4e7e-8dc5-e9714dbcb28d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8eca84f1-f852-4e7e-8dc5-e9714dbcb28d.png)'
- en: 'Create our `Footer` component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`Footer`组件：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'File: src/shared/components/layout/Footer.js'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Footer.js
- en: 'So far, we only have passed props as attributes (with self-closed components
    `<Component />`), but there is another way to pass props as children (`<Component>Children
    Content</Component>`). Let''s create a `Content` component and send our `Home`
    component as a child of content:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将props作为属性传递（使用自关闭组件`<Component />`），但还有另一种将props作为子元素传递的方式（`<Component>Children
    Content</Component>`）。让我们创建一个`Content`组件，并将我们的`Home`组件作为内容的子组件发送：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'File: src/shared/components/layout/Content.js'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Content.js
- en: 'With those changes, our `App.js` file should now look like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们的`App.js`文件现在应该是这样的：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'File: src/components/App.js'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/App.js
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: PropTypes validations are very important for developers because they force us
    to define which type of prop we are going to receive in our components and validate
    whether some of them are required or not.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: PropTypes验证对开发人员非常重要，因为它们强制我们定义我们将在组件中接收哪种类型的属性，并验证其中一些是否是必需的。
- en: 'If you followed all the steps correctly, you should see something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地按照所有步骤进行了操作，您应该会看到类似于这样的东西：
- en: '![](assets/bce4d668-5bad-4606-ab16-94f1e06ea367.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bce4d668-5bad-4606-ab16-94f1e06ea367.png)'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, there are many ways to send props to components. There are more
    ways to receive props, such as using Redux (through a container) or React Router,
    but those are topics that we are going to cover in the next chapters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多将props发送到组件的方法。还有更多接收props的方法，例如使用Redux（通过容器）或React Router，但这些是我们将在下一章中涵盖的主题。
- en: Using local state in a component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件中使用本地状态
- en: The local state is a fundamental feature of React for creating dynamic components. Local
    state is only available on class components, and each component manages its state.
    You can define the initial value of the state on the component's constructor,
    and when you update the value of the state, the component will be re-render itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态是React创建动态组件的基本功能。本地状态仅在类组件上可用，并且每个组件都管理其状态。您可以在组件的构造函数中定义状态的初始值，并且当您更新状态的值时，组件将重新渲染自身。
- en: Local state is helpful with toggles, for handling forms, and is used to manage
    information within the same component. It is not recommended to use local state
    if we need to share data between different components. In that scenario, we need
    to implement Redux state, which we will cover in [Ch](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)[apter](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml)
    [5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml), *Mastering Redux*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态对于切换、处理表单非常有帮助，并且用于在同一组件内管理信息。如果我们需要在不同组件之间共享数据，不建议使用本地状态。在这种情况下，我们需要实现Redux状态，我们将在第5章*精通Redux*中介绍。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s define our initial state.Let''s see how it works the component''s `render` method when
    the local state is updated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的初始状态。让我们看看当本地状态更新时组件的`render`方法是如何工作的：
- en: 'Using our `Home` component, we are going to add a constructor and define our initial
    state:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的`Home`组件，我们将添加一个构造函数并定义我们的初始状态：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'In this example, we are defining our local state in the constructor as an object,
    and in the render, we are printing the value directly. We are using `super()` at
    the beginning of the constructor. This is used to call the parent constructor, `(React.Component)`. If
    we don''t include it, we will get an error like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在构造函数中将本地状态定义为一个对象，并在渲染时直接打印值。我们在构造函数的开头使用`super()`。这是用来调用父构造函数`(React.Component)`的。如果我们不包括它，我们会得到这样的错误：
- en: '![](assets/e13d8fc3-393a-4ead-89d0-a24cf1c86db7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e13d8fc3-393a-4ead-89d0-a24cf1c86db7.png)'
- en: 'After we added `super()`, we need to define our initial state as a regular
    object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们添加了`super()`之后，我们需要将我们的初始状态定义为一个普通对象：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Updating our local state with** `this.setState()`:Right now, this is just
    a state that is not being updated. That means that the component will never re-render
    again. To update the state, we need to use the `this.setState()` method and pass
    the new value of the state. We can add a `setTimeout` to update the name state
    after 1 second (1,000 milliseconds), so we need to modify our `render` method
    like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用`this.setState()`更新我们的本地状态**：现在，这只是一个没有被更新的状态。这意味着组件将永远不会再次重新渲染。要更新状态，我们需要使用`this.setState()`方法并传递状态的新值。我们可以添加一个`setTimeout`来在1秒后（1,000毫秒）更新名称状态，所以我们需要修改我们的`render`方法如下：'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you run this in your browser, you will see the first value of the state
    is Carlos, and 1 second after this it will change to Cristina. I have added a `console.log` to
    log the value of the state name. If you open your browser console, you will see
    this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在浏览器中运行这个，你会看到状态的第一个值是Carlos，1秒后它会变成Cristina。我已经添加了一个`console.log`来记录状态名称的值。如果你打开浏览器控制台，你会看到这个：
- en: '![](assets/c13cfaec-5e84-41ba-833c-6489ab557835.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c13cfaec-5e84-41ba-833c-6489ab557835.png)'
- en: '**Updating our local state in the** `componentDidMount` **lifecycle method**:
    You''re probably wondering why is repeated so many times. It is simple; this is
    the way React works. Every time we update a state the method render is fired,
    and in this code, we added a `setTimeout` which updates the state after a second.
    That means that the `render` method is being called every second, causing an infinitive
    loop. This will affect the performance of our application, and that''s why you
    need to be careful when you update a state. As you can see updating it in the
    render method is not a good idea. So, where should I update the state? Well, it
    depends on your application, but for now, I''ll show you a method that is part
    of the React lifecycle called `componentDidMount()`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在**`componentDidMount`**生命周期方法中更新我们的本地状态**：您可能想知道为什么重复这么多次。很简单；这是React的工作方式。每次更新状态时，都会触发render方法，在这段代码中，我们添加了一个`setTimeout`，它在一秒后更新状态。这意味着`render`方法每秒都会被调用，导致无限循环。这将影响我们应用的性能，这就是为什么在更新状态时需要小心。正如您所看到的，在render方法中更新它不是一个好主意。那么，我应该在哪里更新状态呢？嗯，这取决于您的应用，但现在，我将向您展示一种属于React生命周期的方法，称为`componentDidMount()`：'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'File: src/components/Home/Home.js'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/components/Home/Home.js
- en: 'If you run this code and you see the console, now you will see this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行此代码并查看控制台，现在您将看到这个：
- en: '![](assets/f08c1634-0c26-487d-808e-aebd5beba711.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f08c1634-0c26-487d-808e-aebd5beba711.png)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With `componentDidMount`, we avoided the infinite loop. The reason why this
    is a better approach is that `componentDidMount` is being executed just once when
    the component is already mounted, and in that method, we are executing our `setTimeout` and
    updating the name state only once. In the following recipes, we are going to learn
    more about React lifecycle methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`componentDidMount`，我们避免了无限循环。这种方法更好的原因是，`componentDidMount`在组件已经挂载时只执行一次，并且在该方法中，我们只执行一次`setTimeout`并更新名称状态。在接下来的示例中，我们将学习更多关于React生命周期方法的知识。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Local state is also used to handle forms, but we will cover forms in [Chapter
    6](69fdac67-4387-49ad-89bb-b3407133caaf.xhtml)*, Creating Forms with Redux Form.*
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本地状态也用于处理表单，但我们将在[第6章](69fdac67-4387-49ad-89bb-b3407133caaf.xhtml)*使用Redux Form创建表单*中进行介绍。
- en: Making a functional or stateless component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数式或无状态组件
- en: So far, we have only learned how to create *class components* in React. These
    components are useful when you need to handle local state, but in some cases,
    we will need to render static markup. For static components, we need to use functional
    components*,* also known as stateless components*.* This will improve the performance
    of our application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只学习了如何在React中创建*类组件*。当您需要处理本地状态时，这些组件非常有用，但在某些情况下，我们需要渲染静态标记。对于静态组件，我们需要使用*函数组件*，也称为*无状态组件*。这将提高我们应用的性能。
- en: In the *Passing props to a component and validating them with PropTypes *recipe, we
    created some layout components (`Header`, `Content`, and `Footer`). These components,
    as you may imagine, are frequently not dynamic (unless you want to have a toggle
    menu or some user information in the header), so in this case, we can convert
    them into functional components.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将props传递给组件并使用PropTypes进行验证*示例中，我们创建了一些布局组件（`Header`，`Content`和`Footer`）。这些组件通常不是动态的（除非您想在标题中添加切换菜单或一些用户信息），所以在这种情况下，我们可以将它们转换为函数组件。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It''s now time to convert our `Header` component to a functional component:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的`Header`组件转换为函数组件了：
- en: 'First, let''s see what the current `Header` component looks like:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看当前的`Header`组件是什么样子的：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'File: src/shared/components/layout/Header.js'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：src/shared/components/layout/Header.js
- en: 'The first thing to do is to convert our class component into an arrow function,
    and with this change, we don''t need to import  `React.Component` anymore. The
    second part of the migration is to pass the props as parameter in the function
    instead of getting them from `this.props`, and the last step is to move our static `propTypes` as
    a node of the function. After those changes, our code should look like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'File: src/shared/components/layout/Header.jsA functional component is an equivalent
    to just having the render method. That''s why we only need to return the JSX directly.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'After we migrated our `Header` component, we will migrate the `Footer` component;
    this is easier because it does not have props. First, let''s see what our `Footer` component
    looks like:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'File: src/shared/components/layout/Footer.js'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as a functional component, it should look like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'File: src/shared/components/layout/Footer.jsIn this case, as you can see, we
    need to create an arrow function without parameters (because we don''t have any
    props) and directly return the JSX we need to render.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting the `Content` component to a functional component:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'File: src/shared/components/layout/Content.js'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'This component is similar to our `Header` component. We need to pass the props
    as parameters and keep our `propTypes`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: File***:*** src/shared/components/layout/Content.js
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with functional components, we can validate our `PropTypes`. Remember,
    if you don't need any dynamic data or local state then you should consider using
    a stateless component. This will improve the performance of your application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A functional component not only does not have a state but also does not have the
    React lifecycle methods either.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React lifecycle methods
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React provides methods to handle the data during the lifecycle of a component.
    This is very useful when we need to update our application at particular times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explain each example independently.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Todo list – implementing ComponentWillMount
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn about the lifecycle methods in React. We will
    see how the information flows through the methods since the component is pre-mounted,
    mounted, and unmounted. The Todo list that we will develop in this recipe will
    look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7b3d85d6-75af-4b01-bfb2-b80d34257fa2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'For this Todo list, we need to create a new folder called `Todo` into our `components`
    directory, and you also need to create files called `Todo.js `and `Todo.css`.
    This is the skeleton of the `Todo` component:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'File: src/components/Todo/Todo.js'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructo****r: **A constructor is a unique method that is executed before
    the object is initialized. A constructor can use the `super` keyword to call the
    constructor of the super class (parent class). This method is used to initialize
    our local state or to bind our methods. For the Todo list, we need to initialize
    the local state in the constructor with some values in the task and `items` array:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `componentWillMount` method is executed once before the component is mounted.
    In this case, before our component is mounted we need to update our `items` state
    with the default tasks:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are using `uuidv4` to generate random IDs. To install this package, you
    need to run the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And then you need to import it like this:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After we defined our default tasks, let''s see how we need to render the Todo list:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our JSX is divided into two parts. The first one is a form with an input that
    is connected to our local state (`this.state.task`), and we will save the task when
    the user submits the form (`onSubmit`). The second part is the component list where
    we are going to display our Todo list (or tasks list), passing the items array
    and the `markAsCompleted` (to mark a task as a completed) and `removeTask` (to
    remove the task from the list) functions.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `handleOnChange` method is for connecting our input value with our state
    task:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `handleOnSubmit` method is for updating the `items` state and pushing the
    new task to the array:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `markAsCompleted` function is going to be called from our `List` component
    and needs to receive the `id` of the task we want to mark as completed. With this,
    we can find the specific task in our items array, modify the node as completed,
    and then update the local state:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `removeTask` function is also being called from the `List` component, and
    like `markAsCompleted`, we need to receive the `id` to remove the specific task:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s put all the pieces together. Our `Todo` component should look like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'File: src/components/Todo/Todo.js'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed our `Todo` component, let''s see what our `List` component
    looks like:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'File: src/components/Todo/List.js'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we use a `.map` function to render multiple React elements from
    an array, we must add the key prop to each item we created. Otherwise, we will
    get a React warning like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/31fa593a-8e11-43ac-901e-f9038e1be126.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'You have probably noticed that we also included some Font Awesome icons, and
    to make it work we need to add the Font Awesome CDN into the main `index.html`
    file:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'File: public/index.html'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the CSS for the Todo list (you''re free to change the styles
    if you prefer):'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'File: src/components/Todo/Todo.css'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to import the `Todo` component into your `App` component. Otherwise,
    the component won''t render:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'File: src/components/App.js'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'If you followed all the instructions correctly you should see the Todo List like
    this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial state with default tasks:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/b11119df-92bf-45bf-b33d-534c8d80c369.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Adding a new task:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/c219e590-ec67-4d43-803a-9edab71965e3.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Write the task title and then press *Enter*:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/a1c1f936-b61e-4798-8d92-16a1a794248c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Mark a task as complete:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/f0129857-e44e-42ec-b668-eeb1d7d14a59.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'Removing a task:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/ccb14d7c-04a6-4f45-8cf2-1b18023052bf.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: I challenge you to save the tasks using `localStorage` instead of defining the
    default tasks with `componentWillMount`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Pomodoro timer – implementing the constructor and componentDidMount
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand `componentDidMount`, we are going to create a Pomodoro Timer (if
    you don't know what it is you can read this: [https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique))[.](https://en.wikipedia.org/wiki/Pomodoro_Technique)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Pomodoro timerwill look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3474db4-b21d-4fb6-81ea-7f2d9b3c16ec.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Creating our Pomodoro Timer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to create a new folder called `Pomodoro` in
    our `components` directory, as well as a file called `Timer.js` and the CSS file, `Timer.css`. This
    is the skeleton of the class component we will use for this component:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File: src/components/Pomodoro/Timer.js'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Pomodoro timer, we need to initialize our local state in the constructor with
    some values for the time and for the alert (when the time is over):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `componentDidMount` method is called once the component is mounted and
    is executed just once. In this case, once our component is mounted we need to
    update our time state with the default time (25 min), and to do this, we need
    to create a new method called `setDefaultTime` and then execute it in our `componentDidMount` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After we defined our default time to our time state, let''s see how we need
    to render the Pomodoro Timer. Our `render` method should look like this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, our JSX is very simple. We are getting the values from the local
    state (`message`, `type`, and `time`) and displaying a div to show our alert when
    the user receives an alert message. We have another div to show our timer, and
    here we are passing our current time (expressed in seconds) to the `displayTimer` method,
    which will convert those seconds into `mm:ss`format. The last piece of the layout
    are the buttons to select the type of timer (start working for 25 min, short break
    for 5 min, or long break for 15 min), and you may have noticed that we are executing
    different methods on the `onClick` event for each type of timer.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setTimeForWork`, `setTimeForShortBreak`, and `setTimeForLongBreak`:The purpose
    of these three functions is to update the alert message depending on the type
    of the timer and then call a common function called `setTime`, passing as a parameter
    the specific time for each option. Let''s first see what these three functions
    should look like:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we learned in the previous recipes when we specify our methods with arrow
    functions in our class they are automatically bound (they have access to the "`this`" object).
    That means we don''t need to bind them on the constructor.Now let''s create our `setTime` method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, we executed a new method called `restartInterval()`, and we
    updated our local state with the `newTime` variable, which we passed as a parameter
    (it can be 1,500 seconds = 25 min, 300 seconds = 5 min or 900 seconds = 15 min).
    You probably noticed, from the name of the function, that we are going to use
    a `setInterval` function, which is used to call a function every X milliseconds.
    Our `restartInterval` function should be like this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this case, we first cleared our interval with `clearInterval(this.interval)`.
    This is because the user can switch between the different types of the timer,
    so we need to clear the interval each time we set a new timer*. *After we cleared
    the interval, then we call the `countDown` function every second using `setInterval`.
    The `countDown` function is as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The last piece of this puzzle is the `displayTimer` function, which will convert
    the time into an `mm:ss`format and display it in our component:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s put it all together:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'File: src/components/Pomodoro/Timer.js'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have completed our component, the last step is to add our styles.
    This is the CSS used for the Pomodoro timer. Of course, you can change it if you
    prefer:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'File: src/components/Pomodoro/Timer.css'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to import the `<Timer />` component into `App.js`. If you follow
    everything correctly, you should see the Pomodoro timerworking like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Working:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/81c80738-f47f-401e-bc31-4b466d615a82.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: 'Taking a short break:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/c83b17af-37eb-471d-b357-ec59075cf219.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Taking a long break:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/1199ed97-04e1-4fa4-bb9f-35d879943f67.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: 'Buzzzz - time over!:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/065a22f1-9ada-4ee5-92ae-55e7af538040.png)I challenge you to add
    a Play, Pause, and Reset buttons to control the timer.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Crypto coins exchanger – implementing shouldComponentUpdate
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, everyone is talking about Bitcoin, Ethereum, Ripple, and other cryptocurrencies.
    Let's create our own Crypto Coins Exchanger to learn how `shouldComponentUpdate` works.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Our exchanger will look like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea808246-e7f9-4527-8ae4-85f573f40fe3.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: 'We''ll sell entire coins. That means we won''t trade with decimals; everything
    should be an integer, and each currency costs $10 dollars**. **Our code is simple,
    so let''s take a look:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'File: src/components/Coins/Coins.js'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We are updating our dollars state every time the user writes something in the
    input and converting the value to a number, but if you run this code, you will
    probably notice that when you put in a number under 10, the message **You can
    buy 0 coins** doesn't change until you write 10, 20, 30, 40, and so on.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate`:This method is one of the most important methods that
    improve the performance of our application. It receives two parameters (props,
    state) every time we update a local state, and when a prop is updated this method
    is executed. The returned value must be boolean, which means that if you intentionally
    write the following, your component will never update because this method will
    block it from updating:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But, on the other hand, if you return true or even if you don't define this
    method at all, the default behavior of React is always to update the component, which
    in some cases can cause a performance issue when we are rendering vast views and
    handling a lot of data that changes regularly.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, we are returning true only when the number of dollars that
    the user enters is a multiple of 10\. That''s why you only see the component updating
    in this case:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8c2d7386-d2d6-4ec5-be6b-e781097a21b6.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'But it is not going to work for numbers that are not multiples of 10:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/49507625-ed20-4e88-95cd-0d662fd310f5.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we remove the `shouldComponentUpdate` method from our component or
    we directly return a `true` value, the component will update every time we write
    a number, and this will be the result:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/75f61086-21c6-4837-bd44-6c5a57ff487b.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, with `shouldComponentUpdate`, we can control the updates of
    our component, and this improves the performance of the application significantly.The
    last piece of our example is the CSS:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'File: src/components/Coins/Coins.css'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Notes – implementing componentWillReceiveProps and componentWillUnmount
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are going to create a simple list of notes where, every
    10 seconds, we will simulate that we receive an update from the service with new
    data, and with `componentWillReceiveProps`, we will register the last time we
    got an update from the server:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The `componentWillReceiveProps` method is called right before rendering. Like `shouldComponentUpdate`, it is
    called whenever new props are passed to the component, or the state has changed.
    In this example, we need to create fake data, but data normally needs to come
    from an actual service:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'File: src/components/Notes/data.js'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve created our fake data, let''s create our component:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'File: src/components/Notes/Notes.js'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are using the `moment.js`library. To install it, you need
    to run the following command:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, in our `App.js` file, we are going to simulate that after 10 seconds of
    the first render, we will receive a new update from the service and render the
    new notes:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'File: src/components/App.js'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the CSS file:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'File: src/components/Notes/Notes.css'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application, you will see something like this:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d7508b74-c308-4345-aee1-68778a10ed3f.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'After 10 seconds you will see this:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/be3a42cb-a6ae-4dee-9e16-8dd99516de82.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Last Update date has changed from 2018-02-20 00:07:28 to
    2018-02-20 00:07:**38** (10 seconds later).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentWillUnmount`:This is the last method to be called immediately before
    the component is removed from the DOM. Generally, is used to perform a clean-up for
    any DOM elements or timers created by the `componentWillMount` method. Let''s
    modify our code a little bit to be able to call this method. In our `Notes` component,
    you can add this code after the `render` method:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to modify our `index.html` file to manually include a button that won''t
    be part of React:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'File: public/index.html'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, in our `index.js` file, where we are rendering our `<App />` component,
    let''s add some extra code (we need actually to remove the element from the DOM):'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'File: src/index.js'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we will have a hideous red button at the bottom of our page, and
    when we click it, we are going to unmount our component. The background will go
    black, and we will display the text "There is no mounted component!", and the
    console will display Hasta la vista baby!:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ae76a546-97bb-4c7f-9e59-11b66531863a.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'After you click the button, you will see this:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e1a1ace9-acbc-49ed-a93c-bcc20d31817f.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: C3.js chart – implementing componentDidUpdate
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C3.js is a third-party library that makes it easy to generate D3-based charts
    by wrapping the code required to construct the entire chart. That means you don''t
    need to write any D3 code anymore:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`componentDidUpdate`:This React method is normally used to manage third-party
    UI elements and interact with the native UI. When we use a third-party library
    such as C3.js, we need to update the UI library with the new data. Install C3.js
    with npm:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After we install C3.js, we need to add the C3 CSS file to our `index.html`.
    For now, we can use the CDN they provide:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'File: public/index.html'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create our `Chart` component:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'File: src/components/Chart/Chart.js'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are executing the `updateChart` method on `componentDidUpdate`,
    which is executed every time the user receives a new prop from `App.js`.Let''s
    add some logic that we need in our `App.js` file:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'File: src/components/App.js'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some basic styles to our `Chart` component:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'File: src/components/Chart.css'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are creating some charts to display information about the
    most important cryptocurrencies today (BTC - Bitcoin, ETH - Ethereum and XRP -
    Ripple). This is how it should look:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1174221c-8d3f-44bf-92b7-6b22e5155778.png)This image gives you an
    idea of how the line charts look like'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two buttons to switch between chart types (bar or line). If we click
    on BAR, we should see this chart:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/881f0098-b76d-4104-a56a-90d2e4f69b10.png)This image gives you an
    idea of how the bar charts look like.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: If you remove the `componentDidUpdate` method from the `Chart` component, then
    when you press the buttons the chart is not going to update. This is because every
    time we need to refresh the data, we need to call the `c3.generate` method, and
    in this case, React's `componentDidUpdate` method is very useful.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic animation – implementing componentWillUpdate
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are going to learn how to use `componentWillUpdate`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillUpdate` allows you to manipulate a component just before it receives
    new props or a new state. It is typically used for animations. Let''s create a
    basic animation (fade in/fade out) to see how to use it:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'File: src/components/Animation/Animation.js'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are validating the show state with `newState` and observe
    that it is true. Then we add `opacity 0`, and if it is false, we add `opacity
    1`. An important thing I want to mention about `componentWillUpdate` is that you
    can''t update the state (which means you are not able to use `this.setState`)
    in this method because it will cause another call to the same method, creating
    an infinite loop. Let''s add some styles:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'File: src/components/Animation/Animation.css'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application, you will see this view:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/167ba80f-84d3-4d4e-b5ec-62a8a1fca076.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'After you click on the button, you will see an animation with the text fading
    out, and the red div will be expanded, giving you this result:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c1e8a457-1fe6-4bb7-92d1-7bfd9669db4e.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see with all those examples, React lifecycle methods are used to
    handle different scenarios in our application. In *[Chapter 5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml),
    Mastering Redux*, we are going to see how to implement Redux and how the lifecycle
    methods can work with Redux states.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React Pure Components
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many people get confused by the difference between a Functional Component and
    a Pure Component. Most of them think they are the same, but this is not true.
    When we use a Pure Component, we need to import `PureComponent` from React:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If your React component's render method is "pure" (that means it renders the
    same result, given the same props and state), you can use this function to improve
    the performance of your application. A Pure Component performs a shallow comparison
    for the props and nextProps objects as well as the state and nextState objects.
    Pure components do not include the `shouldComponentUpdate(nextProps, nextState)`
    method, and if we try to add it, we will get a warning from React.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ac0abe9f-9602-4501-85c5-cabaff680fa4.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we will create a basic example to understand how Pure Components
    works.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we need to install the Chrome extension React Developer Tools
    to do a simple debug in our application. In [Chapter 12](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml),
    Testing and Debugging, we will delve into this topic.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: You can download React Developer Tools from [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a component where we will sum all the numbers entered in an
    input. We can take some of the last recipes to start from there:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is to modify our `App.js` and include the Numbers
    component:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'File: src/components/App.js'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create the Numbers component:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'File: src/components/Numbers/Numbers.js'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s create the Result component (as a Class Component):'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the styles:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'File: src/components/Numbers/Numbers.css'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the application, you will see this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da16b38c-61c7-4f56-bb6e-6e4e5b79dbc4.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are using an input with type number, which means we will
    only accept numbers if you start writing numbers (1, then 2, then 3, and such),
    you will see the results of the sum on each row (0 + 1 = **1**, 1 + 2 = **3**,
    3 + 3 = **6**).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97ddc724-b477-4d01-a79e-52f3782eff44.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
- en: Probably this looks very simple to you, but if let's inspect the application
    using React Developer Tools, we need to enable the Highlight Updates option.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/49a2ab49-32a0-40ba-9de3-bb72d58e19ee.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: After this, start writing multiple numbers in the input (quickly), and you will
    see all the renders that React is performing.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de4fb8e3-93b4-409a-98cd-31234874ff9c.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, React is doing a lot of renderings. When the highlights are
    red, it means the performance of that component is not good. Here''s when Pure
    Components will help us; let''s migrate our Result component to be a Pure Component:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Now if we try to do the same with the numbers, let's see the difference.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79143d3f-f02c-4263-849d-5c76f3f97b30.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, with the Pure Component React, do less renders in comparison
    to a Class Component. Probably now you think that if we use a Stateless component
    instead of a Pure Component, the result will be the same. Unfortunately, this
    won''t happen; if you want to verify this, let''s change the Result component
    again and convert it into a Functional Component.:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'File: src/components/Numbers/Result.js'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Even the code is less, but let's see what happen with the renders.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/087b2535-7c5f-4639-8494-e7c20374a4b7.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: As you can see, the result is the same as the Class Component, which means not
    all the time using a Stateless component necessary will help us improve the performance
    of our application. If you have components that you consider are pure, consider
    converting them into Pure components.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Preventing XSS vulnerabilities in React
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn about cross-site scripting (XSS) vulnerabilities
    in React. XSS attacks are widespread in web applications, and some developers
    are still not aware of this. XSS attacks are malicious scripts that are injected
    into the DOM of unprotected web applications. The risks can vary with each application.
    It could just be an innocent alert script injection or, worse, someone can get
    access to your cookies and steal your private credentials (passwords), for example.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an XSS component to start playing around a little bit with some
    XSS attacks. We are going to have a response variable that is simulating a response
    from a real server, and we will simulate that we are using Redux's initial state (we
    are going to see Redux in *[Chapter 5](dafa4ab9-3353-4faf-8af0-f3739c6d5e78.xhtml),
    Mastering Redux*).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now see how to create our XSS component:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an XSS component:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'If you render this component, you will see something like this:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5237a4d6-1d66-4b9e-bcf8-005a133c9ada.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: As you can see, by default, React prevents us from injecting HTML code directly
    into our components. It is rendering the HTML as a string. This is good, but sometimes
    we need to insert HTML code in our components.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implementing `dangerouslySetInnerHTML`*:*This prop probably scares you a little
    bit (maybe because it explicitly says the word danger!). I''m going to show you
    that this prop is not too bad if we know how to use it securely.Let''s modify
    our previous code, and we are going to add this prop to see how the HTML is rendering
    it now:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Our site should now look like this:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8b877eca-d229-4b4e-801b-5a191683871b.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
- en: It is interesting, probably you thought that the content of "My blog post 2"
    will fire an alert in the browser but does not. If we inspect the code the alert
    script is there.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2a74381f-e333-4620-913b-70446e824d4e.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: 'Even if we use `dangerouslySetInnerHTML`,React protects us from malicious scripts
    injections, but it is not secure enough for us to relax on the security aspect
    of our site. Now let''s see the issue with My blog post 3 content. The code **`<img onmouseover="alert(''This
    site is not secure'');" src="attack.jpg" />`** is not directly using a `<script>`
    tag to inject a malicious code, but is using an `img` tag with an event (`onmouseover`).
    So, if you were happy about React''s protection, we can see that this XSS attack
    will be executed if we move the mouse over the image:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ff3f07da-b726-4e70-be35-06d32a7a9192.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: '**Removing XSS attacks**:This is kind of scary, right? But as I said at the
    beginning of this recipe, there is a secure way to use dangerouslySetInnerHTMLand,
    yes, as you may be thinking right now, we need to clean our code of malicious
    scripts before we render it with dangerouslySetInnerHTML. The next script will
    take care of removing `<script>` tags and events from tags, but of course, you
    can modify this depending on the security level you want to have:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the code now, we will see that now our render is more secure:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4cf149d2-6a90-40ea-9cc1-0a1364ae1612.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: '**The problem with JSON.stringify**:So far, we have learned how to inject HTML
    code into a React component with `dangerouslySetInnerHTML`, but there is another
    potential security issue using JSON.stringify. If we have an XSS attack (`<script>`
    tag inside the content) in our response and then we use JSON.stringify to convert
    the object to a string, the HTML tags are not encoded. That means that if we inject
    the string into our HTML (like Redux does with the initial state), we will have
    a potential security issue*.*The output of `JSON.stringify(response)` is this:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As you can see, all the HTML is exposed without any encoding characters, and
    that is a problem. But how we can fix this? We need to install a package called `serialize-javascript`:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Instead of using `JSON.stringify`, we need to serialize the code like this:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output of the console is as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now that we have our code with HTML entities (encoded) instead of directly
    having HTML tags, and the good news is that we can use `JSON.parse` to convert
    this string again into our original object. Our component should look like this:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'File: src/components/Xss/Xss.js'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, XSS attacks are widespread, and many websites suffer from this
    problem without knowing it. There are other injections attacks, such as SQL injections,
    that could happen in an API if we don't take minimal security precautions.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some security recommendations:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Always sanitize users' content that comes from forms.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use `serialize` instead of `JSON.stringify`.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `dangerouslySetInnerHTML` only when absolutely necessary.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do unit tests for your components, and try to cover all the possible XSS attacks
    (we are going to see unit tests in [Chapter 12](1daa68c4-442d-479f-b1b6-3efa80592901.xhtml)*,
    Testing and Debugging*).
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always encrypt passwords with `sha1` and `md5`, and do not forget to add a salt
    value (for example, if the password is `abc123`, then your salt can be encrypted
    like this: `sha1(md5('$4ltT3xt_abc123'))`.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use cookies to store sensitive information (personal information and
    passwords mainly), you can save the cookie with Base64 to obfuscate the data.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add some protection to your API (security tokens) unless you need to be public.
    There is a recipe about security tokens in [Chapter 8](41637135-a49d-409a-bbbe-2928609e749b.xhtml)*,
    Creating an API with Node.js Using MongoDB and MySQL*.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
