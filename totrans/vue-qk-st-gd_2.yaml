- en: Basic Concepts of Vue 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 2的基本概念
- en: In this chapter, we will discuss data-driven views in Vue. We will also examine
    how DOM is manipulated with the help of directives. Next, we'll learn what components
    are and how to create them, and we'll cover concepts related to templates, methods,
    data, computed properties, and watchers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Vue中的数据驱动视图。我们还将研究如何使用指令来操作DOM。接下来，我们将学习组件是什么以及如何创建它们，并涵盖与模板、方法、数据、计算属性和观察者相关的概念。
- en: All components have a life cycle, and we have special methods to access a component
    at certain points of its life. These methods are called **lifecycle hooks**, and
    we'll examine them in this chapter too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都有一个生命周期，并且我们有特殊的方法在其生命周期的某些时刻访问组件。这些方法被称为**生命周期钩子**，我们也将在本章中对它们进行讨论。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Data-driven views in Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图
- en: Computed properties and methods and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性和方法以及如何使用它们
- en: Understanding components, templates, and props
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件、模板和属性
- en: Ways of building component templates in Vue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中构建组件模板的方式
- en: Quickly prototyping websites with the help of Vue components and `v-*` directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue组件和`v-*`指令快速原型网站
- en: Utilizing watchers in Vue
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中利用观察者
- en: The importance of lifecycle hooks and how to plug into this functionality in
    Vue
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期钩子的重要性以及如何在Vue中插入这种功能
- en: Data-driven views in Vue
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图
- en: Data-driven views in Vue are achieved with the help of reactivity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中的数据驱动视图是通过响应性来实现的。
- en: What is reactivity?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应性？
- en: To grasp the concept better, let's look at an example code in which there is
    no reactivity. We will use an example that is very similar to the one we had in
    the previous chapter, when we were comparing Vue and vanilla JS. In the original
    example, using JavaScript, we created an unordered list and three list items inside
    of it. The values of the three list items were added from an array we declared,
    and the unordered list was populated with these list items using a for loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，让我们看一个例子代码，其中没有响应性。我们将使用一个非常类似于我们在上一章中比较Vue和原生JS时的例子。在原始的例子中，使用JavaScript，我们创建了一个无序列表，里面有三个列表项。三个列表项的值是从我们声明的数组中添加的，并且使用for循环将无序列表填充了这些列表项。
- en: This time, we will do something slightly different. To see the example as a
    pen, visit [https://codepen.io/AjdinImsirovic/pen/JZOZdR](https://codepen.io/AjdinImsirovic/pen/JZOZdR).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将做一些稍微不同的事情。要将示例作为一个pen查看，请访问[https://codepen.io/AjdinImsirovic/pen/JZOZdR](https://codepen.io/AjdinImsirovic/pen/JZOZdR)。
- en: 'In this non-reactive example, we are predefining the members of the array as
    variables. Then we populate the array with those variables and print them to the
    screen as list items of an unordered list that gets appended to the document:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非响应式的例子中，我们预先定义了数组的成员作为变量。然后我们用这些变量填充数组，并将它们作为无序列表的列表项打印到屏幕上，这个无序列表被附加到文档中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, what happens when we change a member of the array and repeat the for
    loop a second time? As we can see in the pen, the first and the fourth list items
    are different. The first value is `1`, and the second value is `2`. To make it
    more obvious, these items are in bold red text and have a gray background. The
    first value is the initial value of `var a`. The second value is the value of `var
    a`, updated with this line of code: `arr1[0] = 2`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们改变数组的一个成员并再次重复for循环时会发生什么？正如我们在代码中所看到的，第一个和第四个列表项是不同的。第一个值是`1`，第二个值是`2`。为了更明显，这些项目是以粗体红色文本和灰色背景显示的。第一个值是`var
    a`的初始值。第二个值是使用这行代码更新的`var a`的值：`arr1[0] = 2`。
- en: However, the values of variables `b` and `c` are not updated in the second for
    loop, even though we defined variables `b` and `c` in terms of variable `a` increased
    by `1` and `2`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，变量`b`和`c`的值在第二个for循环中没有更新，尽管我们已经分别定义了变量`b`和`c`，它们分别是变量`a`增加1和2。
- en: So, we can see that there is no reactivity in JavaScript out of the box.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到JavaScript本身并没有响应性。
- en: As far as Vue is concerned, reactivity is the term that is used to refer to
    the way in which Vue tracks changes. In other words, reactivity is the way in
    which changes in state are reflected in the DOM. Practically, this means that
    when a change is made to `data`, that change will be propagated to the page so
    that the user can see it. Therefore, saying that *Vue is reactive* is the same
    as saying *Vue tracks changes*. As a concept, it's as simple as that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就Vue而言，响应性是指Vue跟踪变化的方式。换句话说，响应性是指状态变化如何在DOM中反映出来。实际上，这意味着当对`data`进行更改时，该更改将传播到页面，以便用户可以看到它。因此，说*Vue是响应式*就等同于说*Vue跟踪变化*。作为一个概念，就是这么简单。
- en: How does Vue achieve this?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue是如何实现这一点的呢？
- en: 'Vue stores its data in the `data` option, which is either a function or an
    object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vue将其数据存储在`data`选项中，这可以是一个函数或一个对象：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any change in the `data` model is reflected in the view (on the screen). Vue
    achieves this reactivity with the help of getters and setters. When the `data` object
    is received by the Vue instance, all the properties of the `data` object will
    be updated as getters and setters. This is done with the help of the `Object.defineProperty` API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`模型的任何变化都会反映在视图（屏幕）上。Vue通过getter和setter实现了这种响应性。当`data`对象被Vue实例接收时，`data`对象的所有属性都将被更新为getter和setter。这是通过`Object.defineProperty`API来实现的。'
- en: Computed properties and methods
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和方法
- en: The usefulness of reactivity in Vue can be described in terms of the difference
    between computed properties and methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Vue中响应性的实用性可以用计算属性和方法之间的区别来描述。
- en: As we mentioned earlier, a Vue instance can have either computed properties,
    methods, or both computed properties and methods. So, what is the difference between
    the two?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Vue实例可以有计算属性、方法，或者计算属性和方法两者兼有。那么，这两者之间有什么区别呢？
- en: Methods are simply run every time they are called. On the other hand, computed
    properties are cached, meaning they are only run when the underlying data model
    changes. This is often described in terms of computed property dependencies. Also,
    methods can have parameters, whereas computed properties cannot.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是在被调用时运行。另一方面，计算属性是被缓存的，这意味着它们只在基础数据模型发生变化时才会运行。这通常是以计算属性的依赖关系来描述的。此外，方法可以有参数，而计算属性则不行。
- en: What exactly are these dependencies?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些依赖关系到底是什么？
- en: Consider this simple Vue app, available as a pen at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的Vue应用程序，可以在这个链接中找到：[https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry)。
- en: 'This is the code of the simple app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个简单应用程序的代码：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code will result in this output on the screen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在屏幕上产生这样的输出：
- en: '![](assets/63e6e381-cd03-4ea3-a4d6-3225799a5d85.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63e6e381-cd03-4ea3-a4d6-3225799a5d85.png)'
- en: 'First off, we can see that there is this weird has a line of text in the view.
    This problem here is that we have not used our `ownerHasThing` computed property.
    In other words, these three lines in HTML are completely redundant:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到视图中有这样一个奇怪的“has a”文本行。问题在于我们没有使用我们的`ownerHasThing`计算属性。换句话说，HTML中的这三行是完全多余的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, what if we wanted to run a computed property only after both the input
    fields have been filled out and the focus has been moved out of the inputs or
    the *Enter* key was pressed?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like a relatively complex thing to achieve. Luckily, in Vue
    it is very easy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the updated code (also available as a pen here: [https://codepen.io/AjdinImsirovic/pen/aKVjqj](https://codepen.io/AjdinImsirovic/pen/aKVjqj)):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The JavaScript code is only slightly different:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can conclude from this that computed properties are simply data dependencies
    that have some computations performed on them. In other words, `ownerHasThing` is
    a computed property, and its dependencies are `ownerName` and `thing`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Whenever `ownerName` or `thing` are changed, the `ownerHasThing` computed property will
    update as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: However, the `ownerHasThing` will not update always, since it is cached. Contrary
    to this, a method will always update; that is, it will always be run, regardless
    of whether the data model has changed or not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: This might not seem like a very important difference, but consider a situation
    in which your method needs to fetch data from a third-party API or it has a lot
    of code to run. This might slow things down, and that's why in such cases, using
    computed properties is the way to go.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this section, let's quickly go over the code in the previous
    example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In HTML, we are using `v-model.lazy`. The `lazy` modifier waits for the user
    to either click outside of the input or press the *Enter* key on their keyboard,
    or otherwise leave the input field (such as by pressing the *Tab* key).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Still in HTML, we are also using the `v-if` directive, and we give it `ownerName
    && thing`. Then, we add mustache templates: `{{ ownerHasThing }}` . The `v-if` directive
    will wait until both `ownerName` and `thing` are updated in the data object. So,
    once that both inputs are filled out and no longer in focus, does the computed
    property update the underlying data model, and only then is the `{{ ownerHasThing
    }}` message printed on the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how we can work with templates and components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components, templates, and props
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s look at how to make a component in Vue. First, we specify
    the component, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A component is a block of code that we give a custom name. This custom name
    can be anything we come up with, and it's *a single label for that entire block
    of code* in the form of a custom HTML tag. In the previous example, we grouped
    the `article` and `span` tags and gave that custom tag the name of `custom-article`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Components are named using kebab-case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The code for this component is available as a Codepen at [https://codepen.io/AjdinImsirovic/pen/xzpOaJ](https://codepen.io/AjdinImsirovic/pen/xzpOaJ).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create an instance of our component, we simply use our `<custom-article>` opening
    and closing tags in our HTML, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our custom-article component is referred to as the *child* component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The parent is the actual Vue instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can use string templates even without a component. You simply
    add the template option to your Vue instance, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The example code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/RJxMae](https://codepen.io/AjdinImsirovic/pen/RJxMae).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how we can improve our component with the help of the `props` and `data` options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Adding props and data for better components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our `custom-article` component more useful, we''ll add a `props` option
    to it, like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Props are a way to pass the data from the parent to the child. They are one-way
    flows of data between the parent and the child. Props are always defined as an
    array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/KeZNPr](https://codepen.io/AjdinImsirovic/pen/KeZNPr).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We have registered a prop in our component, and now we can use it in HTML as
    an attribute named just like our prop:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Props are used when we need to make smaller changes to our components without
    having to make a whole new component. They help us reuse what we already have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll use the Vue instance's `data` object to add content
    to our `custom-article` component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Adding content to our components with the help of the data object
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code pen for this example can be found at [https://codepen.io/AjdinImsirovic/pen/QxadmE](https://codepen.io/AjdinImsirovic/pen/QxadmE).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTML, we''ll change the code to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our JS, we''ll update our Vue code to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous example, we are using the `v-bind` directive to bind the `content` prop
    in our `custom-article` component to the `datacontent` property of our `data` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: If you think through this code, you will see that props are almost like named
    variables (with the prop's variable `name` being `content` in the example). Props
    simply pass to the child component whatever data they receive from the parent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way we can do this. Instead of using data inside our
    Vue instance, we can give it to our component; only this time it has to be a data
    function. Here is the full code for this implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To view the pen for the previous example, visit [https://codepen.io/AjdinImsirovic/pen/VdyQzW](https://codepen.io/AjdinImsirovic/pen/VdyQzW).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If we used data as an object instead of as a function, then reactivity would
    apply to all instances of our component. Since the main purpose of components
    is to be reusable, it is important to remember that in this case data must be
    a function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Props can also be defined as objects, which allows us to give them a lot more
    information: validate incoming data, set default values in case no data comes
    through, and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are stating that our `custom-article` component
    is expecting the parent to pass it a prop named `message`, or type string, which
    is required:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example is available at [https://codepen.io/AjdinImsirovic/pen/mKpxGZ](https://codepen.io/AjdinImsirovic/pen/mKpxGZ).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we commented out the `datacontent` property of the Vue instance's `data` function.
    Can you guess what would happen?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In other words, what would happen if `datacontent` is not providing the correct
    data? The child component will simply revert to its `default` property in the `props` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, visit this link: [https://codepen.io/AjdinImsirovic/pen/BVJxKL](https://codepen.io/AjdinImsirovic/pen/BVJxKL).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Other ways of building component templates in Vue
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at defining templates as strings (using single or double
    quotes) and as template literals (using backticks). There are also many other
    ways to work with component templates:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Inline templates
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-templates
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render functions
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single file components
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of them have their pros and cons. For example, using JSX in Vue is possible
    but generally frowned upon, as it in not the Vue way of doing things. Inline templates
    are made using the `inline-template` attribute in your HTML.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add `type=''''text/x-template''''` to an HTML script tag, you will make
    a Vue x-template. Here''s an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code pen for this example is available here: [https://codepen.io/AjdinImsirovic/pen/NzXyem](https://codepen.io/AjdinImsirovic/pen/NzXyem).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Single-file templates are probably the most practical way of creating templates
    in Vue. You keep all your HTML, JS, and styling in a single file (with a `.vue`
    file extension), and you compile this file with a build process, such as Webpack.
    We will look into this in later chapters when we cover the use of Webpack in Vue
    (with the help of Vue-cli).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple web page out of components
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous section, there are many ways to build a component
    in Vue, which might make things look more complex than they have to be. While
    it is important to be aware of the versatility that Vue brings to the various
    ways we can build components, in this section we will look at a simple way to
    use components to build a web page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin building out our page, one thing should be clear to us: each
    component in Vue is also just another Vue instance. This means that each component
    takes an options object, which has the same key value pairs as any other Vue instance.
    The only difference to this rule is that the root Vue instance has some additional
    options that can only be used in it.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: After these introductory clarifications, let's see how a component can be added
    to a Vue instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Adding simple components to a Vue instance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off this example, we'll begin with a simple Vue instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JavaScript file, let''s make the simplest possible Vue instance, with
    the `#app` element as its entry point:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s add just one div in our HTML, so that our Vue instance has an
    element in our page to get access to its DOM:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we will add another component to our JavaScript file. Let''s extend our
    existing JS file by adding the following code to the very top:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can simply add the custom `the-header` component inside our HTML:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Doing this will render Our example header text on the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen just how easy it is to add one simple component to our
    Vue apps, let's add another one to drive the point home.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by extending our JS file with another component, `the-footer`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Of course, we need to update our HTML in order to make this work:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When naming custom components, we need to use hyphens. This is done to make
    sure there are no naming collisions with regular HTML elements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section is available at [https://codepen.io/AjdinImsirovic/pen/qypBbz](https://codepen.io/AjdinImsirovic/pen/qypBbz).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to add a simple component to our Vue instance, let's
    practice by adding a more complex example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Creating a more complex page out of components in Vue
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's add a single component to our new Vue instance. This time, we
    will employ the data option inside our custom component's options object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code we start with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we have added mustache syntax to our template. Then we have utilized
    the data option to return the text, which will be interpolated in the template.
    The mustache syntax tells our component to look for the `header` inside our data
    option.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example is available here: [https://codepen.io/AjdinImsirovic/pen/wxpvxy](https://codepen.io/AjdinImsirovic/pen/wxpvxy).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Next, under our header, we'll add some Bootstrap cards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity''s sake, we''ll use an existing example from the official Bootstrap
    documentation, which is available at the following URL: [https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup](https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The example provides the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although the Bootstrap framework is not the subject of this book, it will be
    useful for us to give a real-world example of using Vue components in practice.
    Since Bootstrap has basically become the industry standard for frontend frameworks,
    it is the perfect candidate for showing not only how Vue components are used in
    general, but also how they can be incorporated with other frontend technologies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can add a single card to our example Vue webpage. This
    is the code to add to our JS:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code for this stage of the development of our code is available here: [https://codepen.io/AjdinImsirovic/pen/VByYeW](https://codepen.io/AjdinImsirovic/pen/VByYeW).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add our card component to our HTML. The full updated code will
    look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Adding the previous code to our HTML, with the JS updates already in place
    as described earlier, we will get the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/063612e2-9c2b-4121-8243-2e3a46dac0d3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: We have added a single card component in our JS; however, as we can see in the
    previous example, we can now reuse it in our HTML as many times as needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: This gives us an excellent opportunity to quickly prototype complete web pages
    with the help of Vue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We can take it even one step further, as we'll see in the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Vue-based layouts with v-for
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will improve our existing web page with the help of Vue
    directives.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Our specific goal is to try to use the data option in our component instance
    and combine it with the powers of Vue directives to further improve our Vue apps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is available at [https://codepen.io/AjdinImsirovic/pen/Epoamy](https://codepen.io/AjdinImsirovic/pen/Epoamy).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our JS a bit easier to read with the help of the backtick ES6 JS
    syntax. This syntax allows us to write JavaScript strings which span multiple
    lines:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s add the `data` option to the `the-card` Vue component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see in the preceding code, we are returning a `customCard` array of
    objects, with each object holding a specific `heading` and `text`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use the `v-for` directive in our template, like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We introduce the `v-for` directive in the `div` that has the class of `card-body`.
    We loop through each `customCard` in our collection of `customCards`, and we interpolate
    the `h5` text's content with `customCard.heading` for each object of our `customCard`
    array.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's add a Bootstrap class to our HTML so that the `h1` tag of our
    web page is not glued to the very top of the viewport. For that, we will use Bootstrap's
    spacing utilities. You can read about them here: [https://getbootstrap.com/docs/4.0/utilities/spacing/](https://getbootstrap.com/docs/4.0/utilities/spacing/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The change in our HTML will be minimal, with just an addition of another CSS
    class: `mt-5`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, what follows is the complete JS code for the improved page. First,
    we register the main title component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we register the `list group` component:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, we register the `card` component:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also add the `root instance`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And here is the HTML:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result of adding the previous code can be seen in this screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe9ea47d-d62d-4da1-88a5-c7a3f0c12356.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: In this section, we have looked at components and how to get started with using
    them. Next, we'll discuss watchers in Vue.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Watchers in Vue
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every component in Vue has a watcher.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, let's begin with an earlier example from this
    chapter. The example is from the *Computed properties* section, at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
    That is our starting code. As we know from the previous section, we have two input
    fields here and we are printing out the values entered into these input fields
    in some span tags under the form.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our example. The initial code is the same; we will only be adding
    a watcher to it. The updated code can be found at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprwKe](https://codepen.io/AjdinImsirovic/pen/jprwKe).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be observed, the only update we made to the original pen is the addition
    of the watchers option, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How does the previous watcher work? It allows us to use a method that must
    have the same name as the computed property we are watching in our HTML. The watcher
    has optional parameters we can pass to it to be worked with in the body of the
    method; in this case, we gave our optional parameters some nice and descriptive
    names: `previousValue` and `currentValue`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the `watch` method, we are logging out changes to input values
    to the JavaScript console. An elegant way of testing how this works is to, for
    example, highlight the *for example* section of the initial value of the first
    input field and simply erase it, leaving only the value of *Old McDonald* in the
    input.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this would result in the following sentence being logged to the console:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we will be looking at how to hook into various stages of
    a component's life and alter its behavior at that specific point with custom code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle hooks are methods that let us alter the behavior of components at
    various stages of their life cycle.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What is a component's lifecycle?
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's just the natural progression of the *life* of a component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can say that lifecycle hooks are *points* along this journey that each
    component needs to go through. At these specific *points* in a component's life,
    we can use these methods to alter a component's behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vue team has chosen very descriptive names for these lifecycle methods.
    What follows is the list of lifecycle hooks organized in the order of the natural
    progression of a component''s life:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeCreate`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeMount`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mounted`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeUpdate`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activated`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deactivated`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeDestroy`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroyed`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This visual representation of a component''s lifecycle is available at this
    address: [https://vuejs.org/images/life cycle.png](https://vuejs.org/images/lifecycle.png).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Note that it would be beneficial that you print this image out and keep it with
    you until you fully understand the information it conveys. This will be of great
    help for getting a deeper understanding of Vue in general, and its component lifecycle
    in particular.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are five distinct stages of a component's life, and each
    stage has a lifecycle hook before a specific stage begins, and another lifecycle
    hook for after it is completed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a component can be mounted several times, based
    on the changes in the data model. This is verifiable in the lifecycle diagram
    referenced in the previous tip box. However, it is also crucial to understand
    that the DOM re-rendering that takes place when the underlying data is changed
    can result in a component being effectively *unmounted,* even though this is not
    explicitly mentioned anywhere in the lifecycle diagram.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How do we use lifecycle hooks?
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example, available at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprmoa](https://codepen.io/AjdinImsirovic/pen/jprmoa).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s add the HTML:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let''s add the CSS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And finally, the JS:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As can be seen in the Codepen provided, it is really easy to hook into life
    cycle methods in Vue. It's just a matter of providing the desired code (functionality)
    to the life cycle hook method name in the Vue instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we are showing an alert for the `beforeCreate()` method,
    and we are showing another alert 5 seconds after the `created()` method has been
    run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: There are many more useful things to do with life cycle hooks, which will be
    covered in the chapters which follow.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some basic concepts in Vue. We described why these
    concepts are important and how they can be used. We also looked at several simple
    examples of using these concepts in practice.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We learned about data-driven views in Vue and reactivity as a way to keep track
    of the changes to the data model. We looked at using computed properties and methods,
    directives, and their modifiers. We have seen some practical examples of components,
    templates, and props, as well as different approaches to building component templates
    in Vue.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to prototype websites using Vue components and directives, and
    we wrapped up the chapter with a look at watchers and lifecycle hooks as a powerful
    way to alter the behavior of components at any point of their lifecycle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further delve into reactive programming in Vue
    with a focus on components, props, and slots.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
