- en: Basic Concepts of Vue 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss data-driven views in Vue. We will also examine
    how DOM is manipulated with the help of directives. Next, we'll learn what components
    are and how to create them, and we'll cover concepts related to templates, methods,
    data, computed properties, and watchers.
  prefs: []
  type: TYPE_NORMAL
- en: All components have a life cycle, and we have special methods to access a component
    at certain points of its life. These methods are called **lifecycle hooks**, and
    we'll examine them in this chapter too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven views in Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed properties and methods and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding components, templates, and props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways of building component templates in Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly prototyping websites with the help of Vue components and `v-*` directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing watchers in Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of lifecycle hooks and how to plug into this functionality in
    Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-driven views in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data-driven views in Vue are achieved with the help of reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: What is reactivity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To grasp the concept better, let's look at an example code in which there is
    no reactivity. We will use an example that is very similar to the one we had in
    the previous chapter, when we were comparing Vue and vanilla JS. In the original
    example, using JavaScript, we created an unordered list and three list items inside
    of it. The values of the three list items were added from an array we declared,
    and the unordered list was populated with these list items using a for loop.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we will do something slightly different. To see the example as a
    pen, visit [https://codepen.io/AjdinImsirovic/pen/JZOZdR](https://codepen.io/AjdinImsirovic/pen/JZOZdR).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this non-reactive example, we are predefining the members of the array as
    variables. Then we populate the array with those variables and print them to the
    screen as list items of an unordered list that gets appended to the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, what happens when we change a member of the array and repeat the for
    loop a second time? As we can see in the pen, the first and the fourth list items
    are different. The first value is `1`, and the second value is `2`. To make it
    more obvious, these items are in bold red text and have a gray background. The
    first value is the initial value of `var a`. The second value is the value of `var
    a`, updated with this line of code: `arr1[0] = 2`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the values of variables `b` and `c` are not updated in the second for
    loop, even though we defined variables `b` and `c` in terms of variable `a` increased
    by `1` and `2`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can see that there is no reactivity in JavaScript out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: As far as Vue is concerned, reactivity is the term that is used to refer to
    the way in which Vue tracks changes. In other words, reactivity is the way in
    which changes in state are reflected in the DOM. Practically, this means that
    when a change is made to `data`, that change will be propagated to the page so
    that the user can see it. Therefore, saying that *Vue is reactive* is the same
    as saying *Vue tracks changes*. As a concept, it's as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: How does Vue achieve this?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue stores its data in the `data` option, which is either a function or an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Any change in the `data` model is reflected in the view (on the screen). Vue
    achieves this reactivity with the help of getters and setters. When the `data` object
    is received by the Vue instance, all the properties of the `data` object will
    be updated as getters and setters. This is done with the help of the `Object.defineProperty` API.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usefulness of reactivity in Vue can be described in terms of the difference
    between computed properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, a Vue instance can have either computed properties,
    methods, or both computed properties and methods. So, what is the difference between
    the two?
  prefs: []
  type: TYPE_NORMAL
- en: Methods are simply run every time they are called. On the other hand, computed
    properties are cached, meaning they are only run when the underlying data model
    changes. This is often described in terms of computed property dependencies. Also,
    methods can have parameters, whereas computed properties cannot.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly are these dependencies?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider this simple Vue app, available as a pen at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code of the simple app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will result in this output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/63e6e381-cd03-4ea3-a4d6-3225799a5d85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First off, we can see that there is this weird has a line of text in the view.
    This problem here is that we have not used our `ownerHasThing` computed property.
    In other words, these three lines in HTML are completely redundant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, what if we wanted to run a computed property only after both the input
    fields have been filled out and the focus has been moved out of the inputs or
    the *Enter* key was pressed?
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like a relatively complex thing to achieve. Luckily, in Vue
    it is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the updated code (also available as a pen here: [https://codepen.io/AjdinImsirovic/pen/aKVjqj](https://codepen.io/AjdinImsirovic/pen/aKVjqj)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is only slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can conclude from this that computed properties are simply data dependencies
    that have some computations performed on them. In other words, `ownerHasThing` is
    a computed property, and its dependencies are `ownerName` and `thing`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever `ownerName` or `thing` are changed, the `ownerHasThing` computed property will
    update as well.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `ownerHasThing` will not update always, since it is cached. Contrary
    to this, a method will always update; that is, it will always be run, regardless
    of whether the data model has changed or not.
  prefs: []
  type: TYPE_NORMAL
- en: This might not seem like a very important difference, but consider a situation
    in which your method needs to fetch data from a third-party API or it has a lot
    of code to run. This might slow things down, and that's why in such cases, using
    computed properties is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this section, let's quickly go over the code in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: In HTML, we are using `v-model.lazy`. The `lazy` modifier waits for the user
    to either click outside of the input or press the *Enter* key on their keyboard,
    or otherwise leave the input field (such as by pressing the *Tab* key).
  prefs: []
  type: TYPE_NORMAL
- en: Still in HTML, we are also using the `v-if` directive, and we give it `ownerName
    && thing`. Then, we add mustache templates: `{{ ownerHasThing }}` . The `v-if` directive
    will wait until both `ownerName` and `thing` are updated in the data object. So,
    once that both inputs are filled out and no longer in focus, does the computed
    property update the underlying data model, and only then is the `{{ ownerHasThing
    }}` message printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how we can work with templates and components.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components, templates, and props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s look at how to make a component in Vue. First, we specify
    the component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A component is a block of code that we give a custom name. This custom name
    can be anything we come up with, and it's *a single label for that entire block
    of code* in the form of a custom HTML tag. In the previous example, we grouped
    the `article` and `span` tags and gave that custom tag the name of `custom-article`.
  prefs: []
  type: TYPE_NORMAL
- en: Components are named using kebab-case.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this component is available as a Codepen at [https://codepen.io/AjdinImsirovic/pen/xzpOaJ](https://codepen.io/AjdinImsirovic/pen/xzpOaJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create an instance of our component, we simply use our `<custom-article>` opening
    and closing tags in our HTML, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our custom-article component is referred to as the *child* component.
  prefs: []
  type: TYPE_NORMAL
- en: The parent is the actual Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can use string templates even without a component. You simply
    add the template option to your Vue instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The example code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/RJxMae](https://codepen.io/AjdinImsirovic/pen/RJxMae).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how we can improve our component with the help of the `props` and `data` options.
  prefs: []
  type: TYPE_NORMAL
- en: Adding props and data for better components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our `custom-article` component more useful, we''ll add a `props` option
    to it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Props are a way to pass the data from the parent to the child. They are one-way
    flows of data between the parent and the child. Props are always defined as an
    array.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the previous example is available here: [https://codepen.io/AjdinImsirovic/pen/KeZNPr](https://codepen.io/AjdinImsirovic/pen/KeZNPr).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have registered a prop in our component, and now we can use it in HTML as
    an attribute named just like our prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Props are used when we need to make smaller changes to our components without
    having to make a whole new component. They help us reuse what we already have.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll use the Vue instance's `data` object to add content
    to our `custom-article` component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding content to our components with the help of the data object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code pen for this example can be found at [https://codepen.io/AjdinImsirovic/pen/QxadmE](https://codepen.io/AjdinImsirovic/pen/QxadmE).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTML, we''ll change the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In our JS, we''ll update our Vue code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we are using the `v-bind` directive to bind the `content` prop
    in our `custom-article` component to the `datacontent` property of our `data` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you think through this code, you will see that props are almost like named
    variables (with the prop's variable `name` being `content` in the example). Props
    simply pass to the child component whatever data they receive from the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way we can do this. Instead of using data inside our
    Vue instance, we can give it to our component; only this time it has to be a data
    function. Here is the full code for this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To view the pen for the previous example, visit [https://codepen.io/AjdinImsirovic/pen/VdyQzW](https://codepen.io/AjdinImsirovic/pen/VdyQzW).
  prefs: []
  type: TYPE_NORMAL
- en: If we used data as an object instead of as a function, then reactivity would
    apply to all instances of our component. Since the main purpose of components
    is to be reusable, it is important to remember that in this case data must be
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Props can also be defined as objects, which allows us to give them a lot more
    information: validate incoming data, set default values in case no data comes
    through, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are stating that our `custom-article` component
    is expecting the parent to pass it a prop named `message`, or type string, which
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example is available at [https://codepen.io/AjdinImsirovic/pen/mKpxGZ](https://codepen.io/AjdinImsirovic/pen/mKpxGZ).
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we commented out the `datacontent` property of the Vue instance's `data` function.
    Can you guess what would happen?
  prefs: []
  type: TYPE_NORMAL
- en: In other words, what would happen if `datacontent` is not providing the correct
    data? The child component will simply revert to its `default` property in the `props` object.
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, visit this link: [https://codepen.io/AjdinImsirovic/pen/BVJxKL](https://codepen.io/AjdinImsirovic/pen/BVJxKL).
  prefs: []
  type: TYPE_NORMAL
- en: Other ways of building component templates in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at defining templates as strings (using single or double
    quotes) and as template literals (using backticks). There are also many other
    ways to work with component templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single file components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of them have their pros and cons. For example, using JSX in Vue is possible
    but generally frowned upon, as it in not the Vue way of doing things. Inline templates
    are made using the `inline-template` attribute in your HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add `type=''''text/x-template''''` to an HTML script tag, you will make
    a Vue x-template. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code pen for this example is available here: [https://codepen.io/AjdinImsirovic/pen/NzXyem](https://codepen.io/AjdinImsirovic/pen/NzXyem).
  prefs: []
  type: TYPE_NORMAL
- en: Single-file templates are probably the most practical way of creating templates
    in Vue. You keep all your HTML, JS, and styling in a single file (with a `.vue`
    file extension), and you compile this file with a build process, such as Webpack.
    We will look into this in later chapters when we cover the use of Webpack in Vue
    (with the help of Vue-cli).
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple web page out of components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous section, there are many ways to build a component
    in Vue, which might make things look more complex than they have to be. While
    it is important to be aware of the versatility that Vue brings to the various
    ways we can build components, in this section we will look at a simple way to
    use components to build a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin building out our page, one thing should be clear to us: each
    component in Vue is also just another Vue instance. This means that each component
    takes an options object, which has the same key value pairs as any other Vue instance.
    The only difference to this rule is that the root Vue instance has some additional
    options that can only be used in it.'
  prefs: []
  type: TYPE_NORMAL
- en: After these introductory clarifications, let's see how a component can be added
    to a Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding simple components to a Vue instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off this example, we'll begin with a simple Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JavaScript file, let''s make the simplest possible Vue instance, with
    the `#app` element as its entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add just one div in our HTML, so that our Vue instance has an
    element in our page to get access to its DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add another component to our JavaScript file. Let''s extend our
    existing JS file by adding the following code to the very top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simply add the custom `the-header` component inside our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Doing this will render Our example header text on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen just how easy it is to add one simple component to our
    Vue apps, let's add another one to drive the point home.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by extending our JS file with another component, `the-footer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to update our HTML in order to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When naming custom components, we need to use hyphens. This is done to make
    sure there are no naming collisions with regular HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section is available at [https://codepen.io/AjdinImsirovic/pen/qypBbz](https://codepen.io/AjdinImsirovic/pen/qypBbz).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to add a simple component to our Vue instance, let's
    practice by adding a more complex example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a more complex page out of components in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's add a single component to our new Vue instance. This time, we
    will employ the data option inside our custom component's options object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code we start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have added mustache syntax to our template. Then we have utilized
    the data option to return the text, which will be interpolated in the template.
    The mustache syntax tells our component to look for the `header` inside our data
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example is available here: [https://codepen.io/AjdinImsirovic/pen/wxpvxy](https://codepen.io/AjdinImsirovic/pen/wxpvxy).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, under our header, we'll add some Bootstrap cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity''s sake, we''ll use an existing example from the official Bootstrap
    documentation, which is available at the following URL: [https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup](https://getbootstrap.com/docs/4.0/components/card/#using-grid-markup).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example provides the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Although the Bootstrap framework is not the subject of this book, it will be
    useful for us to give a real-world example of using Vue components in practice.
    Since Bootstrap has basically become the industry standard for frontend frameworks,
    it is the perfect candidate for showing not only how Vue components are used in
    general, but also how they can be incorporated with other frontend technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can add a single card to our example Vue webpage. This
    is the code to add to our JS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this stage of the development of our code is available here: [https://codepen.io/AjdinImsirovic/pen/VByYeW](https://codepen.io/AjdinImsirovic/pen/VByYeW).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add our card component to our HTML. The full updated code will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the previous code to our HTML, with the JS updates already in place
    as described earlier, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/063612e2-9c2b-4121-8243-2e3a46dac0d3.png)'
  prefs: []
  type: TYPE_IMG
- en: We have added a single card component in our JS; however, as we can see in the
    previous example, we can now reuse it in our HTML as many times as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us an excellent opportunity to quickly prototype complete web pages
    with the help of Vue.
  prefs: []
  type: TYPE_NORMAL
- en: We can take it even one step further, as we'll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Vue-based layouts with v-for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will improve our existing web page with the help of Vue
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: Our specific goal is to try to use the data option in our component instance
    and combine it with the powers of Vue directives to further improve our Vue apps.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is available at [https://codepen.io/AjdinImsirovic/pen/Epoamy](https://codepen.io/AjdinImsirovic/pen/Epoamy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our JS a bit easier to read with the help of the backtick ES6 JS
    syntax. This syntax allows us to write JavaScript strings which span multiple
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the `data` option to the `the-card` Vue component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we are returning a `customCard` array of
    objects, with each object holding a specific `heading` and `text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use the `v-for` directive in our template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We introduce the `v-for` directive in the `div` that has the class of `card-body`.
    We loop through each `customCard` in our collection of `customCards`, and we interpolate
    the `h5` text's content with `customCard.heading` for each object of our `customCard`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's add a Bootstrap class to our HTML so that the `h1` tag of our
    web page is not glued to the very top of the viewport. For that, we will use Bootstrap's
    spacing utilities. You can read about them here: [https://getbootstrap.com/docs/4.0/utilities/spacing/](https://getbootstrap.com/docs/4.0/utilities/spacing/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The change in our HTML will be minimal, with just an addition of another CSS
    class: `mt-5`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, what follows is the complete JS code for the improved page. First,
    we register the main title component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we register the `list group` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we register the `card` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add the `root instance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of adding the previous code can be seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe9ea47d-d62d-4da1-88a5-c7a3f0c12356.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have looked at components and how to get started with using
    them. Next, we'll discuss watchers in Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every component in Vue has a watcher.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, let's begin with an earlier example from this
    chapter. The example is from the *Computed properties* section, at this link: [https://codepen.io/AjdinImsirovic/pen/qKVyry](https://codepen.io/AjdinImsirovic/pen/qKVyry).
    That is our starting code. As we know from the previous section, we have two input
    fields here and we are printing out the values entered into these input fields
    in some span tags under the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our example. The initial code is the same; we will only be adding
    a watcher to it. The updated code can be found at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprwKe](https://codepen.io/AjdinImsirovic/pen/jprwKe).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be observed, the only update we made to the original pen is the addition
    of the watchers option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'How does the previous watcher work? It allows us to use a method that must
    have the same name as the computed property we are watching in our HTML. The watcher
    has optional parameters we can pass to it to be worked with in the body of the
    method; in this case, we gave our optional parameters some nice and descriptive
    names: `previousValue` and `currentValue`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the `watch` method, we are logging out changes to input values
    to the JavaScript console. An elegant way of testing how this works is to, for
    example, highlight the *for example* section of the initial value of the first
    input field and simply erase it, leaving only the value of *Old McDonald* in the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this would result in the following sentence being logged to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will be looking at how to hook into various stages of
    a component's life and alter its behavior at that specific point with custom code.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle hooks are methods that let us alter the behavior of components at
    various stages of their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: What is a component's lifecycle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's just the natural progression of the *life* of a component.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can say that lifecycle hooks are *points* along this journey that each
    component needs to go through. At these specific *points* in a component's life,
    we can use these methods to alter a component's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Vue team has chosen very descriptive names for these lifecycle methods.
    What follows is the list of lifecycle hooks organized in the order of the natural
    progression of a component''s life:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeCreate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mounted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deactivated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeDestroy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroyed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This visual representation of a component''s lifecycle is available at this
    address: [https://vuejs.org/images/life cycle.png](https://vuejs.org/images/lifecycle.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that it would be beneficial that you print this image out and keep it with
    you until you fully understand the information it conveys. This will be of great
    help for getting a deeper understanding of Vue in general, and its component lifecycle
    in particular.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are five distinct stages of a component's life, and each
    stage has a lifecycle hook before a specific stage begins, and another lifecycle
    hook for after it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a component can be mounted several times, based
    on the changes in the data model. This is verifiable in the lifecycle diagram
    referenced in the previous tip box. However, it is also crucial to understand
    that the DOM re-rendering that takes place when the underlying data is changed
    can result in a component being effectively *unmounted,* even though this is not
    explicitly mentioned anywhere in the lifecycle diagram.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use lifecycle hooks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example, available at this Codepen URL: [https://codepen.io/AjdinImsirovic/pen/jprmoa](https://codepen.io/AjdinImsirovic/pen/jprmoa).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s add the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the JS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the Codepen provided, it is really easy to hook into life
    cycle methods in Vue. It's just a matter of providing the desired code (functionality)
    to the life cycle hook method name in the Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we are showing an alert for the `beforeCreate()` method,
    and we are showing another alert 5 seconds after the `created()` method has been
    run.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more useful things to do with life cycle hooks, which will be
    covered in the chapters which follow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some basic concepts in Vue. We described why these
    concepts are important and how they can be used. We also looked at several simple
    examples of using these concepts in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about data-driven views in Vue and reactivity as a way to keep track
    of the changes to the data model. We looked at using computed properties and methods,
    directives, and their modifiers. We have seen some practical examples of components,
    templates, and props, as well as different approaches to building component templates
    in Vue.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to prototype websites using Vue components and directives, and
    we wrapped up the chapter with a look at watchers and lifecycle hooks as a powerful
    way to alter the behavior of components at any point of their lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further delve into reactive programming in Vue
    with a focus on components, props, and slots.
  prefs: []
  type: TYPE_NORMAL
