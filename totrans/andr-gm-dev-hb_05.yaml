- en: Chapter 5. Understanding the Game Loop and Frame Rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game loop is the operational body of a game, and the frame rate is the consequence.
    A game cannot be made without a defined game loop, and the performance cannot
    be judged without measuring the frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: These two aspects of game development are common throughout any game development
    project. However, the scalability and nature of the game loop vary across different
    devices, and there might be different scales to measure frame rates across different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For native development, the game loop is created and maintained by developers
    only. However, in most game engines, the loop is already defined with all the
    necessary controls and scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a detailed look at these two most important parts of game development
    through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample game loop using the Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game update and user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General idea of a game state machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FPS system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balance between performance and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling FPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game loop is the core cycle in which user input, game update, and rendering
    are executed sequentially. This loop ideally runs once per frame. So, the game
    loop is the most important part of running a game with frame rate control.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical game loop has three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: User input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Game update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rendering![Introduction to the game loop](img/B05069_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple game loop
  prefs: []
  type: TYPE_NORMAL
- en: User input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section checks the UI system of the game for any external input that has
    been given to the game. It sets the required changes to be made in the game for
    the next update. On a different hardware platform, this portion of the game loop
    varies the most. It is always a best practice to create common functionality for
    different input types to make a standard.
  prefs: []
  type: TYPE_NORMAL
- en: The input system is not considered as part of the game loop; however, user-given
    input detection is part of the game loop. This system continuously monitors the
    input system, whether an event has occurred or not.
  prefs: []
  type: TYPE_NORMAL
- en: A user can trigger any event at any point of time during gameplay when an active
    game loop is running. Normally, there are queues maintained by the input system.
    Each queue represents different types of possible input events, such as touch,
    key press, sensor reading, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user input monitor checks those queues at a particular interval following
    the loop sequence. If it finds any event in the queue, it makes the required changes
    that will have an impact on the next update call in the game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User input](img/B05069_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User input working principle
  prefs: []
  type: TYPE_NORMAL
- en: Game update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete game state is managed and maintained by the game update section
    of the game loop. This section is also responsible for running the game logic,
    changes in game states, loading/unloading assets, and setting the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The game control is usually managed by the game update section. Usually, the
    main game manager works at the top level of this game update section. We discussed
    game program structure in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Any game runs a particular state at a time. The state can be updated by either
    user input or any automated AI algorithm. All AI algorithms work on the game update
    cycle frame by frame.
  prefs: []
  type: TYPE_NORMAL
- en: State update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, the state can be updated from game update. The state is also
    initiated and destroyed by the game update. Initialization and destruction happens
    once per state, and state update can be called once per game cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![State update](img/B05069_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: State update call flow
  prefs: []
  type: TYPE_NORMAL
- en: Rendering frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rendering section inside a game loop is responsible for setting the rendering
    pipeline. No update or AI algorithm runs on this section of the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: There was time when a developer had full control over the rendering pipeline.
    The developer could manipulate and set each and every vertex. The modern age game
    development system has not much to do with this rendering system. The graphics
    library takes care of all the control of the rendering system. However, at a very
    high level, a developer can only set the order and quantity of rendering vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering is one of the most important roles when it comes to frame rate control,
    keeping other continuous processes constant. Display and memory operations take
    the most time to execute from the processing point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical Android graphics rendering follows the OpenGL pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering frames](img/B05069_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a sample game loop using the Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android SDK development starts with an activity, and the game runs on single
    or multiple views. Most of the time, it is considered to have a single view to
    run gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Android SDK does not provide a predefined game loop. However,
    the loop can be created in many ways, but the basic mechanism remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the Android SDK library, the `View` class contains an abstract method `OnDraw()`
    in which every possible rendering call is queued. This method is called upon any
    change in the drawing, which invalidates the previous rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a sample game loop using the Android SDK](img/B05069_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at a basic game loop created with Android `View`. Here,
    a custom view is extended from the Android `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the current age of Android game development, developers use `SurfaceView`
    instead of `View`. `SurfaceView` is inherited from `View` and more optimized for
    games made with Canvas. In this case, a customized view is extended from `SurfaceView`
    and implements the `SurfaceHolder.Callback` interface. In this scenario, three
    methods are overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While developing a game, the developer need not change the surface each time.
    That's the reason the `surfaceChanged` method should have an empty body to function
    as a basic game loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a customized game thread and override the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are set to start the newly created game loop from the customized `SurfaceView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There can be many approaches to implementing a game loop. However, the basic
    approach follows either of the two ways mentioned here. Some developers prefer
    to implement the game thread inside the game view. Handling input is another important
    part of the game loop. We will discuss this topic later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another part of this game loop is **frames per second** (**FPS**) management.
    One of the most common mechanisms is to use `Thread.sleep()` for such a calculated
    time that the loop executes at a fixed rate. Some developers create two types
    of update mechanism: one based on FPS and another based on per frame without delay.'
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, physics-based games need an update mechanism that follows a real-time
    interval to function uniformly across all devices.
  prefs: []
  type: TYPE_NORMAL
- en: For small-scale development, few developers in the industry follow the first
    approach but do not follow typical looping. This system invalidates the current
    draw based on the required action. In this scenario, the game loop is not dependent
    on fixed FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Game life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android game life cycle is almost similar to any other application's life
    cycle, other than the game loop mechanism. Mostly, the application state changes
    with external interference. States can be manipulated otherwise, where games have
    algorithms or artificial intelligence that is capable of interfering with the
    main game cycle.
  prefs: []
  type: TYPE_NORMAL
- en: An Android game is initialized with an activity. The `onCreate()` method is
    used for initialization. Then, the game thread starts and enters the game loop.
    The game loop can then be interrupted by an external interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of game development, it is always a good practice to save the current
    game state and pause the loop and threads properly. On resuming the game, it should
    be easy to return to the last state.
  prefs: []
  type: TYPE_NORMAL
- en: Game update and user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered a few update and interface mechanisms previously. A
    running game state can be changed by user input or internal AI algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game update and user interface](img/B05069_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mostly, game update is called once per frame or once after a fixed time interval.
    Either way, an algorithm does its job to change the game state. You have learned
    about user input queues. On each game loop cycle, the input queues are being checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a mobile game loop with a touch interface works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the input queue system with the same approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The same process can be repeated for the `SurfaceView` game loop approach as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game loop is a continuous process. Whenever an interrupt occurs, it is necessary
    to pause every running thread and save the current state of the game to ensure
    that it resumes properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, any interrupt triggers from `onPause()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to change the class where the actual game loop is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, declare a Boolean to indicate whether the game is paused or not. Then,
    put a check in the game loop. After that, create a static method to deal with
    this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: General idea of a game state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game state machine runs within the update cycle of the game loop. A game state
    machine is the mechanism of binding all the game states together. In old techniques,
    this was a typical linear control flow. However, in modern development processes,
    it can be parallel control running in multiple threads. In the old architecture
    of game development, it was encouraged to have only one game thread. Developers
    used to avoid parallel processing as it was vulnerable to game loop and timer
    management. However, even in modern development, many developers still prefer
    to use a single thread for game development whenever possible. With the help of
    various tools and advanced scripting language, most game developers now use a
    virtual parallel processing system.
  prefs: []
  type: TYPE_NORMAL
- en: One of the processes of a simple game state machine is to create a common state
    interface and override it for each game state. In this way, it becomes easy to
    manage the state inside the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a loop of a simple game state machine manager. This manager should
    conduct four main functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example implementation might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, developers pass the input signal to a particular state through
    the state manager as well.
  prefs: []
  type: TYPE_NORMAL
- en: The FPS system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of game development and gaming industry, FPS matters a lot. The
    game quality measurement depends heavily on the FPS count. In simple words, the
    higher the FPS of the game, the better. The FPS of a game is dependent on the
    processing time for instructions and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes some time to execute the game loop once. Let''s have a look at a sample
    implementation of FPS management inside a game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first noted the time before execution (`startTime`)
    of the loop and then noted down the time after the execution (`endTime`). We then
    calculated the time taken for execution (`delta`). We already know the amount
    of time (`interval`) it should take to maintain a maximum frame rate. So, for
    the remaining time, we put the game thread to sleep before it executes again.
    This can be applied to a different game loop system as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using `SurfaceView`, we can declare the FPS system inside the game loop
    in the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this process, we capped the FPS count and tried to execute the game loop
    on the predefined FPS. A major drawback in this system is this mechanism massively
    depends on hardware configuration. For a slow hardware system, which is incapable
    of running the loop on the predefined FPS, this system has no effect. This is
    because the interval time is mostly zero or less than zero, so there is no per
    frame cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed earlier that hardware configuration plays a major role in
    the FPS system. If the hardware is not capable of running a certain set of instructions
    with a certain frequency, then it is not possible for any developer to run a game
    on the target FPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the tasks that take most of the processing time for a game:'
  prefs: []
  type: TYPE_NORMAL
- en: Display or rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory load/unload operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display or rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Display processing depends mostly on the graphics processor and what all needs
    to be displayed. When it comes to interaction with the hardware, the process becomes
    slow. Rendering each and every pixel with shader manipulation and mapping takes
    time.
  prefs: []
  type: TYPE_NORMAL
- en: There were times when running a game with a frame rate of 12 was difficult.
    However, in the modern world, a superb display quality game needs to be run on
    a frame rate of 60\. It is only a matter of hardware quality.
  prefs: []
  type: TYPE_NORMAL
- en: A large display requires a good amount of cache memory. So, for example, hardware
    with a large and dense display and with low cache memory is incapable of maintaining
    a good display quality.
  prefs: []
  type: TYPE_NORMAL
- en: Memory load/unload operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory is a hardware component of a system. Again, it takes more time to interact
    with the memory component. From a developer's perspective, it takes time when
    we allocate memory, deallocate memory, and read or write an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the game development perspective, four types of memory are the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Heap memory is user-defined manually managed memory. This memory has to be allocated
    manually and freed manually as well. In the case of Android, the garbage collector
    is responsible for freeing memory, which is flagged as non-referenced. This memory
    location is the slowest in the random access memory category.
  prefs: []
  type: TYPE_NORMAL
- en: Stack memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This segment of memory is used for elements that are declared inside a method.
    Allocation and deallocation of this memory segment is automatically done by the
    program interpreter. This memory segment works only for local members.
  prefs: []
  type: TYPE_NORMAL
- en: Register memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Register memory is the fastest of all. Register memory is used to store data
    for the current process and frequently used data. Game developers can achieve
    a higher frame rate in the case of devices where the register memory is better
    and faster.
  prefs: []
  type: TYPE_NORMAL
- en: ROM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Read-only memory** (**ROM**) is permanent memory. Especially in game development,
    a huge chunk of assets is stored in the ROM. It takes maximum time during the
    load/unload operation of those assets. A program needs to load the necessary data
    onto the RAM from the ROM. So, having faster ROM helps achieve better FPS during
    the load/unload operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers should define the instructions in such a way that they can use hardware
    in the most efficient way. In technical terms, each and every instruction goes
    in stacks in a binary instruction form. The processor executes one instruction
    in one clock cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s have a look at a badly constructed logical instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `length` and using a post increment operator every time increases the
    instructions to the processor, which eventually increases the execution time.
    Now, look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code executed the same task; however, the processing overhead is reduced
    a lot in this approach. The only compromise this code made is blocking memory
    for one integer variable and saving a lot of nested tasks related to `length`.
  prefs: []
  type: TYPE_NORMAL
- en: Processors with a better clock speed can execute the task faster, which directly
    implies better FPS. However, managing the task amount depends on the developer,
    as is shown in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Every processor has a mathematical processing unit. The power of the processor
    varies from one processor to another. So, developers always need to check the
    mathematical expression to know whether it can be simplified or not.
  prefs: []
  type: TYPE_NORMAL
- en: Balance between performance and memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned earlier, memory operation takes a lot time. However, developers
    always have a limited memory. So, it is extremely necessary to have a balance
    between performance and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Loading or unloading any asset from ROM to RAM takes time, so it is recommended
    that you do not do such operations for games that depend on FPS. This operation
    affects FPS significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a game requires a lot of assets while running one game state and the
    target device has a limited heap available. In such a case, the developer should
    group assets. Small assets can be loaded in the game running the state only in
    required cases.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, many developers preload all the assets and use it from cache. This
    approach makes the gameplay smoother and faster. However, loading assets in a
    cache that is not required for that particular game state may crash the game if
    an interrupt occurs. The Android OS is fully authorized to clear memory occupied
    by inactive or minimized applications. When an interrupt occurs, the game goes
    to the minimized state. If a new application requires memory and free memory is
    not available, then the Android OS kills inactive apps and frees the memory for
    a new application.
  prefs: []
  type: TYPE_NORMAL
- en: So, it is always a good practice to break the set of assets into parts according
    to game states.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen some ways of defining the FPS system. We have already
    discussed the major drawback of the system as well. So, we can manipulate the
    game loop according to the real-time FPS generated in the current game loop cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the hybrid FPS system where we cap the maximum FPS
    to 60\. Otherwise, the game can be manipulated through actual FPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game loop is mainly a logical approach for game development. In many cases,
    developers do not opt for such a mechanism. Some games may be typically interactive
    and have no algorithm that runs continuously. In such cases, the game loop may
    not be needed. Game states can be updated as per input given to the gaming system.
  prefs: []
  type: TYPE_NORMAL
- en: However, an exception cannot be an example. That is why it is an industrial
    approach to follow a game loop to maintain a development standard irrespective
    of game design.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the game loop and game state management here. Developers are
    free to invent and execute game loops in different ways. There are many game engines
    that have different ways to control game loop and manage game states. The idea
    and concept of game loop and state management may change as per the game requirement.
  prefs: []
  type: TYPE_NORMAL
- en: However, developers should always keep in mind that the technique they are using
    should not affect the game performance and FPS. Besides that, developers need
    to maintain the readability and flexibility of code. Some approaches may consume
    more memory and run faster and vice versa. Android has various sets of hardware
    configuration, so there might not be the same processing and memory support on
    all hardware. Finally, balancing between memory and performance is the key to
    creating better games.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a deep look at performance and memory management in later chapters.
    We will try to look at these segments of game development from different perspectives,
    such as 2D/3D games, VR games, optimization techniques, and more.
  prefs: []
  type: TYPE_NORMAL
