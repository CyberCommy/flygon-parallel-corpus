- en: '*Chapter 12*: Building the React Client for Our Online Forum Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way. In this chapter, we'll start coding our application,
    starting with the React client. We will take everything we learned about in the
    previous chapters and build our React app using the new Hooks API. We will also
    use Responsive techniques to build a mobile client that will adapt its views to
    handle both mobile and desktop devices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a good understanding of web development using React, Node,
    Express, and GraphQL. You should also be familiar with CSS. We will once again
    be using Node and Visual Studio Code to write our code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 12*](B15508_12_Final_JC_ePub.xhtml#_idTextAnchor179)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap12`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the initial version of our React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be building out our React client. We won't be able
    to complete the client entirely since it will need our backend features, such
    as our GraphQL API, the ability to authenticate, post threads, and so on. However,
    we'll begin creating our main screens and set up Redux and React Router.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a very large amount of code in this section. Please take frequent
    breaks and pace yourself. The code will evolve and get iterated and refactored
    numerous times during our build. Sometimes, it will be for better code reuse.
    Sometimes, it will be to improve our design and its readability. So, if you get
    stuck, please refer to the source code. This will be the most challenging section
    of this book so far.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will not be showing every line of code as that would be redundant. Please
    download and open the source code in your editor to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: React project setup and dependency configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling and layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core component and feature creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Having everything compile and work from the beginning is actually not of any
    benefit to your learning. Do not focus on getting stuff to simply compile and
    run the first time you do this. Instead, try experimenting and making changes.
    In other words, break the code so that it does not compile and then fix it. This
    is the only way to ensure you understand what you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating our base project by using `create-react-app`. Then,
    we will add Redux and React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `Chap12` folder from your Terminal and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, cd into the new `super-forum-client` folder and run the `start` command
    to make sure it''s working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s install Redux and React Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, now, we have our core packages installed. Before we start coding, we need
    to discuss how we will lay out our application. In our case, we want our application
    to work on both mobile devices and desktops. This way, we can have a single application
    that runs on phones, desktops, and laptops.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways of approaching this goal. We can use a library such
    as **Bootstrap** or a UI framework such as **Ionic** to help us build out a UI
    and layout. These frameworks are great and work well, but they also hide some
    of the details about how layout and styling work on the web. You can also lose
    some control when using frameworks and end up with a site that looks similar to
    other sites that use the same framework.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we will use Responsive Web Design. Responsive Web Design
    is simply the intent that our web application adapts to different devices and
    screen dimensions. There are many ways, when using web technologies, that we can
    do this. One of them is CSS Grid. With this system, we can structure our application
    screen to make optimal use of desktop space, while at the same time automatically
    reconfigure it for mobile devices. Due to this, we will be using CSS Grid, as
    well as other web technologies, to create our layout.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Grid gives us most of the capabilities that programs such as Bootstrap could
    accomplish. However, CSS Grid is part of the CSS web standard, instead of being
    part of a third-party library. So, we know that our layout will always work with
    the web and will never suddenly become unsupported.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is CSS Grid? CSS Grid is a layout method built into standard CSS that
    allows us to create flexible layouts using rows and columns. It was created to
    replace the use of tables for layouts. CSS Grid is very capable and there are
    numerous ways of doing the same thing. To keep things simple, I will show you
    one specific way to do this, though you can explore more options later if you
    think you''ll find that useful. Let''s get started using CSS Grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go back to our project, open `App.tsx`, and remove the contents of the
    `App` object. Do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've gotten rid of most of the contents and replaced it with
    layout placeholders. Of course, we will make components out of these elements
    eventually, but for now, we'll focus on getting our `Grid` layout working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s replace the contents of the `App.css` file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, there''s a `:root` pseudoclass, which we will use as a container for
    the CSS Variables for our app theme. To make styling and theming more consistent
    and easier, we will use variables instead of hardcoding values. As we build out
    our app, you will see more and more variables being added here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following margin settings centers our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a rundown of the Grid-related attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display`: Here, we declare that our element will be of the `grid` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid-template-columns`: This attribute tells our app the width of our columns
    in a relative way. In our setup, it indicates we have four columns. The `fr` value
    indicates that some portion of the available width should be given to the column.
    So, for example, in our case, we have four columns, so if each column had exactly
    equal amounts of the available width, each column''s value would be `1fr`. But
    in our case, each column will be using a different amount of width smaller or
    greater than the equal distribution, which is why we have the varying values.
    Possible values can be specific, such as `100px` or `2rem`, percentages, such
    as example `20%`, or implicit, such as .`25fr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid-template-rows`: Indicates the number and size of rows. Possible values
    are the same as columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid-template-areas`: Every Grid can have labeled sections called areas. As
    this example shows, you simply add the labels for each area in Grid form to the
    columns and rows that you want them to be in. So, in our case, `"nav nav nav nav"`
    represents the first of our two rows with four columns, while `"sidebar leftmenu
    content rightmenu"` represents our second row and each of its columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gap`: This is a way of adding padding in-between columns and rows. The first
    entry indicates the row, while the second indicates the column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve explained the basic features of CSS Grid, let''s look at the
    styling for the related sections of the Grid. The remaining styles are for the
    Grid content areas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, they have a `grid-area` attribute, which indicates which area
    of the Grid the element belongs to. The `nav` area will be for navigation. `sidebar`
    will show a menu of user-specific settings and will only appear for desktops and
    laptops; it will be hidden for mobile devices. `leftmenu` will be used to store
    our Thread categories list. `content` will house our main list of Threads, filtered
    by category. Finally, `rightmenu` will show a list of popular or otherwise relevant
    Threads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I am using these awkward `background-color` settings temporarily, only to distinguish
    between each area clearly. Eventually, we will remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a basic layout for our app that works for desktop and laptop devices.
    But how can we make this auto reconfigure itself for smaller screens, such as
    phones and tablets? There is a CSS technology called **Media Queries** that could
    be of help in situations like this. However, for our needs, it alone is insufficient.
  prefs: []
  type: TYPE_NORMAL
- en: We are building our app dynamically, using React driven by state changes. This
    means that certain screen components should not be drawn if they are not needed
    or cannot be displayed on smaller devices. So, although we could use Media Queries
    to hide elements when smaller screens are detected, it would be an inefficient
    use of resources to have React render something that is never going to be seen
    or directly used by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s see what we can do in code using event handling and React Hooks
    to take care of this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to do is convert our elements into React components.
    Let's create a new folder inside the `src` folder called `components`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, inside that folder, create a container component for each of the elements
    that were inside the root `div` of our `App` component. Your `src` folder and
    the `App.tsx` file should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Refactored App.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Refactored App.tsx file
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to brevity, I won''t review every single file we need to create here since
    it is highly repetitive code, but here''s a sample of the updated `Main` component
    (the source code will, of course, contain the complete application code for all
    components):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just moved our code from `App.tsx` into the component''s
    `Main.tsx` file. This means you''ll need to create the remaining components; that
    is, `Nav`, `SideBar`, `LeftMenu`, and `RightMenu`. Here''s a screenshot of the
    React Developer Tools screen showing our component hierarchy so far. React Developer
    Tools was discussed in *Chapter 6, Setting Up Our Project Using create-react-app
    and Testing with Jest*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Component hierarchy view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Component hierarchy view
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have the **Nav**, **SideBar**, **LeftMenu**, **Main**, and **RightMenu**
    components here. Each component represents the areas of our app on the root of
    our website. Note that we will have more screens than this as we build out our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: We had to do this componentization anyway because we are building a React application.
    But how does this help us with our desire to make our web app responsive so that
    it auto-configures to different device screens? By separating out each area of
    the Grid into its own component, we can allow each component to use a React Hook
    that looks for screen size information. Due to this, if the component is not appropriate
    for a certain screen size, it will not render or render differently.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this responsive system work, we'll need two main features.
    First, we'll need some additional CSS styles that use Media Queries to lay out
    our Grid differently when smaller devices are detected. Additionally, we'll need
    to have our components become aware when certain screen sizes are being used and
    either not render the component or render it differently. Let's see what that
    code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create our media queries for mobile devices. Open your `App.css`
    file and add the following Media Query to the bottom of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are overriding the original `App` class definition whenever the device''s
    `orientation` is in `portrait` mode and the resolution is `768px` or less. If
    you run the app using Chrome Developer Tools in mobile mode as an iPhone X, you
    should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Chrome Developer Tools view of our app in mobile mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Chrome Developer Tools view of our app in mobile mode
  prefs: []
  type: TYPE_NORMAL
- en: 'The app has a white right-hand side because we are still rendering the elements
    that existed in the original desktop mode. We''ll fix this soon. Now, let''s create
    our **Hook**, which helps handle device size-based rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder inside the `src` folder called `hooks`. Then, add a file called
    `useWindowDimensions.ts`. Notice that it is not a component since it has a `ts`
    extension. Copy the source code from this book's GitHub repository and let's go
    through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we create an interface called `WindowDimension` so that we can type in
    what is returned by our Hook, which in this case is the browser's `window` object
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on *line 8*, we name our `useWindowDimensions` Hook. Then, on the next
    line, we create a state object called `dimension` and give it a value of `0` for
    `height` and `0` for `width`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our handler function, `handleResize`, which will use the state
    update method, `setDimension`, to set our dimension values. The `window` object
    of our browser provides the dimension values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, starting no *line 21*, we use the `useEffect` Hook to handle the window's
    `resize` event. Note that an empty array, `[]`, means that this will run only
    once on first load. Also, note that when we add an event handler, we must also
    return an event remover (this prevents memory leaks and redundant event handlers
    from being added).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to update our `SideBar`, `LeftMenu`, and `RightMenu` components
    so that they will use our `useWindowDimensions` Hook and know not to render when
    a device has a width of less than or equal to `768` (the same as our media query).
    The code to use with the Hook is identical across each of these components, so
    I will only show the `SideBar` component here. Please update the other components
    yourself in a similar manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `useWindowDimensions` Hook to get the `width` dimension.
    We then check if it is `768` or lower and if it is, we return `null`; otherwise,
    we return the normal JSX. The other components will have the same code for the
    `useWindowDimensions` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the app, you will see that the white gap is now gone and that these
    components are not rendered in the HTML. Note that to save time, we will only
    support desktop and mobile portrait mode for iPhone X. Supporting every possible
    device configuration is beyond the scope of this book. Here is a good link on
    the topic of supporting multiple device screens from Google: [https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site](https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site).'
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, let's flesh out our client base configurations, such as
    Redux and React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Update your `index.tsx` file so that it includes Redux and React Router. We
    covered Redux and React Router in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*. As always, the source code is available if you
    get stuck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create a folder inside the `src` folder called `store` and add our
    Redux files there. Create the `AppState.ts` and `configureStore.ts` files and
    enter the code as shown in the source files. We are not ready for `UserProfileReducer`
    yet, so you can leave it out for now. We won't be using Redux middleware since
    I showed this in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, before we continue and start creating components, let's add a newer React
    feature to our app that will help us add more polish.
  prefs: []
  type: TYPE_NORMAL
- en: Error Boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Error Boundaries is a lot like exception handling for React Components. In
    a large app, it is not always possible to prevent all errors that may occur. So,
    by using Error Boundaries with our components, we can "catch" unanticipated errors
    and provide a better user experience to our users. When errors occur, we''ll display
    an error screen that we pre-create rather than some ominous looking technical
    error message. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create our Error Boundary file. Inside of the `components` folder,
    create a file called `ErrorBoundary.tsx` and add the source code from this book's
    GitHub repository to it. Note that Error Boundaries still uses the older class
    style because we need the `getDerivedStateFromError` and `componentDidCatch` life
    cycle event handlers to catch errors. The React team does plan to add a Hooks
    equivalent eventually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the file, notice that we also have a matching CSS style file.
    It's trivial, so I won't show it here, but you can find it in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a type for our Error Boundary's props called `ErrorBoundaryProps`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must create another type for our Error Boundary's local state called
    `ErrorBoundaryState`. At the beginning of the `ErrorBoundary` class definition,
    we will see some boilerplate with the constructor for setting up the state. Immediately
    following this, we will use the `getDerivedStateFromError` function to tell React
    to show the error UI if `hasError` is true.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 31*, it is in our `componentDidCatch` function that our component realizes
    an error of some kind occurred and sets our `hasError` state variable to true.
    We can also run our own code here to log errors and notify support if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if `hasError` is true, we render our message so that users do not have
    to see strange technical messages that can be confusing. You can, of course, write
    your own custom message.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Error Boundaries do not catch errors that are occurring inside event handlers,
    asynchronous code, or server-side rendered React, as well as errors thrown by
    Error Boundaries themselves. You must deal with those yourself generally using
    `try catch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test our Error Boundary by throwing an error inside one of our
    components. Update the `Main.tsx` file''s `Main` function, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we deliberately throw an `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: Try running the app now. You should see the type of screen we were trying to
    avoid. Why is this happening? This is happening because we are currently in development
    mode and React deliberately shows all errors in this mode. If we were in production
    mode, by running `npm run build`, we would see the Error Boundary message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, we can still view our Error Boundary screen while in development mode
    if we click on the **x** button on the Chrome browser''s upper right-hand corner.
    If you do this, you should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Error Boundary message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Error Boundary message
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our normal error message now appears. And again, feel free to
    style this message as you see fit. To save time, we will leave it as-is.
  prefs: []
  type: TYPE_NORMAL
- en: Data Service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our application, we will be making calls to either a GraphQL API or a Web
    API, or fetching network calls. However, none of these backend services are ready
    yet. For now, we''ll create a file that will contain fake network calls to simulate
    a real backend. Once our real backend arrives, we will remove this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a folder called `services` inside `src` and then create the `DataService.ts`
    file inside it. Since this is code we will soon discard, I won't show it here,
    but you can grab the code from the source files. Note that some references to
    Model types will be in this service, so you'll need to add those and we'll cover
    them as this chapter progresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a way of getting data, let's update our `LeftMenu` component
    so that it uses it. But first, we need to create our `Category` type since we
    are using TypeScript. Create a new folder called `model` inside `src`. Then, create
    the `Category.ts` file and add the source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, update the `LeftMenu.tsx` file. First, we will update the imports by adding
    the model type called `Category` and then the `LeftMenu.css` file. We'll be using
    these later in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, on *line 9*, create our state object called `categories` that contains
    our list of categories. Before we can load `Category` data, we need some default
    text, `Left Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, on *line 13*, we have `useEffect`, where we make a call to our `getCategories`
    function and get our `Categories`. Then, we use the ES6 `map` function to convert
    our objects into JSX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the returned JSX, we use the `Categories` state object in our UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you reload your browser, you will see a 2-second delay due to the timers
    in our fake `DataService`, and then the list of categories, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Loaded categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Loaded categories
  prefs: []
  type: TYPE_NORMAL
- en: Again, we'll remove `DataService` once our real server calls are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a base configuration and layout, we can start creating our
    SideBar menu. The interesting thing about our SideBar menu items is that they
    will be used on both the SideBar and as a drop-down modal for mobile devices.
    This way, we can write less code by having only a single component for both display
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to create the SideBar with a correct set of links, we need to
    know if the user is logged in. If they are not logged in, we will show them login
    and register menus. If they are logged in, we will show them logout and UserProfile
    menus. The UserProfile menu screen will show the user''s settings, as well as
    a list of posts that they have made. Since the login state of our user will be
    shared across the application, let''s put this data into our Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the existence of a `UserProfile` object instance, or lack thereof,
    as an indication that a user is logged in. First, let's add a new reducer to our
    currently empty reducers set. Create a new folder inside `store` called `user`.
    Now, create a file called `Reducer.ts` and add the required source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create an action type called `UserProfileSetType` so that our `UserProfileReducer`
    can be distinguished from other reducers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we must create a payload type called `UserProfilePayload`. This is the
    data that will be in our actions when they are dispatched later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we must create the `UserProfileAction` interface, which is of the `action`
    type. This is used to distinguish an action for UserProfiles from some other action
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have our actual reducer, `UserProfileReducer`, which performs filtering
    based on our desired `UserProfileSetType`. Again, Redux was covered in [*Chapter
    7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*, Learning Redux and React
    Router.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to help us style our components, we''ll need to use icons to provide
    a better visual presentation. Let''s install Font Awesome as it is a free and
    provides an attractive kit of styles and icons that are very popular for web development.
    Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve added our icons, let''s create a new folder inside `src/components`
    called `sidebar` and move our existing `SideBar.tsx` file into it. Now, create
    a new file called `SideBarMenus.tsx` and add the following code to it. Make sure
    you''ve added the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `useSelector` and `useDispatch` Hooks to access Redux''s capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use a `useEffect` Hook to call, dispatch, and update our `UserProfile`
    object. Notice that it is now hardcoded, but we will use a GraphQL call later
    when our backend is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must add a `FontAwesome` font for the UserProfile and then show the
    current `username`. This menu item will eventually be clickable so that our user''s
    profile screen appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we build out our screens to log in, log out, register, and so on, we will
    add these menu items to this JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'I personally find bullet points distracting, so let''s remove all the bullets
    from all the app''s unordered lists by adding the following style to the `index.css`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to update `SideBar.tsx` so that it uses `SideBarMenus.tsx`. Update
    `SideBar` like this. First, add the appropriate imports, such as `SideBarMenus`,
    first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can update the JSX to include it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we will eventually write some code so that the `UserProfile` icon
    and `userName` will only appear when our user is actually logged in. We will also
    click enable it so that clicking on it opens our user's UserProfile screen. However,
    we cannot do this without our backend. For now, we will have it as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue and reuse our `SideBarMenus` component for mobile display.
    Update the `Nav.tsx` file inside the `components` folder. Add the appropriate
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have used our `useWindowDimensions` Hook to determine if we are on
    a mobile device. However, this time, we have created a function called `getMobileMenu`
    to handle the logic of deciding what JSX to return. If we are not running a mobile
    device, it returns nothing; otherwise, it returns the `FontAwesome` icon for the
    hamburger menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen, when viewed on a mobile device, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Nav menu in mobile mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Nav menu in mobile mode
  prefs: []
  type: TYPE_NORMAL
- en: 'As we build out our app, we need to be able to display modals. So, before we
    continue, we need to install `react-modal`. This package will allow us to make
    some components modal popups. This makes them more flexible in terms of when we
    can display them. Install `react-modal` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order to use this modal and have it be responsive and adapt to different
    device screens, we need to update our styles. In our `App.css` file, you will
    see a class called `modal-menu` that has been applied to all our modals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the default style for modals that our non-mobile devices will get. The
    main thing to note here is that the modal starts its `left` position at 50% of
    the screen. Then, we use `transform` to pull it back halfway (50% of itself).
    This should center our modal so that it's in the middle of the screen. Notice
    that `z-index` is set high to ensure this modal always appears on top.
  prefs: []
  type: TYPE_NORMAL
- en: For mobile devices, we use our `App.css` file's existing Media Query to hold
    an updated `modal-menu`. Basically, we are overriding the same attributes that
    were in the desktop styles with styles for the mobile Media Query. In this case,
    we are using `left`, `right`, and `top` to stretch out the modal to the ends of
    the available screen. This is why our transform is now 0, since it's not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we will add our click handler to the hamburger icon and then show
    our `SideBarMenus` component when the icon is clicked. So, we'll need to update
    our `Nav.tsx` file again so that it includes our modal, which displays `SideBarMenus`.
    Let's update `Nav.tsx`. Add the appropriate imports first. Then, add the code
    from the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we start by looking on *line 10*, we will see we have a new local state called
    `showMenu`. We'll use this to control whether we show or hide our modal menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onClickToggle` handler is used in `FontAwesomeIcon`, inside the `getMobileMenu`
    function, to toggle the `showMenu` local state, which shows or hides the modal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a `ReactModal`, when any request to close comes into the component, we need
    to set the state controlling display so that it can be explicitly set to false;
    otherwise, the modal will not go away. This is what `onRequestClose` does. The
    `shouldCloseOnOverlayClick` property allows us to close the modal, even when we
    click anywhere outside it. This is a commonly expected behavior by users, so it's
    good to have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the JSX has been updated so that we can add our `ReactModal`, which
    includes our `SideBarMenus` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the modal is called `ReactModal` and that among its properties,
    there's the prop called `isOpen`. This determines whether the modal is shown or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the code and then click on the hamburger icon, you will see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – ReactModel with SideBarMenus'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – ReactModel with SideBarMenus
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will be building out this menu as we add more features.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our SideBar set up, let''s start building our authentication
    components. We''ll start by building our register, login, and logout screens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the registration modal first. In order to do this, we''ll need
    to add a link for registration inside our `SideBarMenus` component. Open the `SideBarMenus.tsx`
    file and update it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we create our Registration component, let''s create a helper service
    that validates our passwords for us. We want to make sure users enter sufficiently
    long and complex passwords, so we need a `src` called `common` and then another
    folder called `validators`. In the `validators` folder, create a file called `PasswordValidator.ts`
    and add the following code to it. The code is pretty simple, so I won''t show
    all of it here, but do notice the password strength and the Regular Expression.
    A Regular Expression is just a programmatic way of searching for patterns in a
    string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve used a Regular Expression to check for proper complexity by ensuring
    that we have both letters, numbers, and symbols in our password. Parantheses represent
    a set of related expressions. So, first, we have lowercase letters, then uppercase
    letters, then numbers, then symbols, and finally an expected length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code isn't particularly complicated, but since we are going to need this
    across several components, such as registration and on the server, having it in
    a separate file is better for code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In SPA web development, validations are generally done twice – once on the client
    and again on the server. Doing this twice may seem redundant, but it's necessary
    for added security. Once we start building out our server code, we'll learn how
    to share dependencies like this across projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re creating multiple authentication-related components, let''s create
    a folder inside `components` called `auth` and then place our authentication-related
    files there. Once you''ve created the `auth` folder, add a file called `Registration.tsx`
    in there. Add the following code to the file. If you look at the source code,
    you will be able to see the necessary imports. Make sure your `App.css` file is
    updated as well. Note that eventually, we''ll move some of this code into a shared
    location, but for now, we''ll use it directly in our `Registration` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating our reducer, which has many related fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a modal component, we are allowing our parent components to control
    how this component is viewed by passing props. The `isOpen` prop controls how
    the modal is displayed, while the `onClickToggle` function controls hiding and
    showing the modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the `isRegisterDisabled` local state value, which disables the
    register button if the given values are not correct, and, of course, our local
    reducer, `userReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`allowRegister` is just a helper function for setting the register button to
    disabled and showing a message if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a series of `onChange` event handlers for each field, such as
    the `userName` field. They each do validation as needed, as well as update the
    typed-in text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onChangeUserName` function is used to set a `userName` and validate whether
    registration is allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onChangeEmail` function is used to set the email and validate whether
    registration is allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onChangePassword` function is used to set the password and validate whether
    registration is allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onChangedPasswordConfirm` function is used to set `passwordConfirm` and
    validate whether registration is allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, since this is a registration component, we use `passwordsSame` to check
    whether the password and the confirmation password are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have `onClickRegister` and `onClickCancel`. The `onClickRegister`
    button click handler will submit the attempted registration. Currently, since
    we have no backend, it does no actual submission, but we''ll fill it in once we
    have the server up. On the other hand, the `onClickCancel` handler exits the `Registration`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `e.preventDefault` function simply prevents the standard behavior,
    which is different depending on the context. In the case of forms, our `onClickRegister`
    handler is associated with a button inside a form tag, so the default behavior
    is to submit and cause a page refresh. A page refresh is `preventDefault`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the event handlers have been set up we return the JSX that is tied
    to those handlers. First, we start with the `ReactModal` wrapper component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, our modal is controlled externally by a parent component via the `isOpen`
    and `onClickToggle` props.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our email field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is our password field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is our password confirmation field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our button to register.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here is our button to cancel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, note that we have a message section that's using the `resultMsg` reducer
    field. This will show errors if something has gone wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run the app in desktop mode, you should see something this:![Figure
    12.8 – Desktop registration modal view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Desktop registration modal view
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your Chrome debugger and switch to mobile mode, you will see the
    following screen after clicking on your hamburger icon and then the register label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Mobile registration modal view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Mobile registration modal view
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we were able to effectively get two screens with only a single
    component by using CSS responsive capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the login modal. If we take a look at the existing `Registration`
    component, we will see that it contains some code that we could also use in our
    `Login` component. We really should refactor the code so that it can be reused.
    For example, `Registration`, `Login`, and `Logout` will all use `ReactModal` and
    therefore receive props to control the modal's display. So, let's see what we
    can do to reuse our existing code. First, let's extract the `RegistrationProps`
    interface from the `Registration.tsx` file and place it in its own file. Create
    a folder called `types` inside `components`. Then, create a file called `ModalProps.ts`
    and add the `RegistrationProps` interface. Rename it `ModalProps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it's the same as `RegistrationProps` except for the name change.
    Now, open the `Registration.tsx` file, remove `RegistrationProps`, and import
    `ModalProps`. Then, replace `RegistrationProps` with `ModalProps`. Check that
    everything still runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We refactored `ModalProps` so that it can be reused across components. Now,
    let''s pull out `UserReducer` since `Login` uses some of its fields. Create a
    new folder called `common` inside the existing `auth` folder and create the `UserReducer.ts`
    file. Place the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do one more refactor. The `allowRegister` function in `Registration`
    disables a button and updates the status message. This can also clearly be reused.
    Let''s create a new file called `Helpers.ts` inside the common folder and add
    the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we changed the function name to `allowSubmit` and we are now
    taking `dispatch` as a parameter. Now, remove `allowRegister` from `Registration`
    and import the new `allowSubmit` function and update the `allowRegister` calls
    to `allowSubmit` calls. Check the code of your `Registration.tsx` file against
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll leave the two `onClick` calls as-is, even though `Login` will also have
    similar calls, as we'll probably have to do some component-specific things for
    these calls later once our backend is ready.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to run this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the newly extracted code in our new `Login` component. In the
    `auth` folder, create a new file called `Login.tsx` and add the relevant code
    from the source code. I''ll highlight a few items here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since our `Login` component has different needs than our `Registration` component,
    we are only using a subset of the fields from our `userReducer` by using object
    destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: In the JSX, notice that we've updated some of the CSS classes in order to align
    the buttons better. These new classes are in the `App.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to add a link for logging in. Update the `SideBarMenu.tsx`
    file, as shown in the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since `Logout` is very similar, I've added the component but will not cover
    it here. We'll add code to control which menu links are shown depending on user
    login status later as the backend gets more fleshed out. We'll also add additional
    validation. However, we have a lot more work to do before that, so let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and screens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s continue by creating the routes that our application will need.
    Up to this point, we have had only a single URL for our app. The root URL is `http://localhost:3000`.
    We now want to divide our application so that it has distinct routes for specific
    sections of our application. We''ll start by taking our existing code, modifying
    it, and making that into our first root React Route. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's move our Grid area-related components into distinct folders. First,
    create a folder called `areas` inside the `components` folder. Then, move the
    `Nav.tsx`, `Nav.css`, `RightMenu.tsx`, `Main.tsx`, `LeftMenu.tsx`, and `LeftMenu.css`
    files, as well as the entire `sidebar` folder, into the new `areas` folder. Your
    file path imports will need to be updated, including the `App.tsx` file. Take
    a look at the source code to learn how to do that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done that, create a new folder inside `areas` called `main` and
    move the `Main.tsx` file inside it. Make sure to update your paths. We'll be adding
    all our main area-related components into this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first new component we'll create in this folder is a `MainHeader` component.
    As the name implies, it will be used as a header for the main section. It will
    show what category of thread items we are currently looking at. Create the `MainHeader.tsx`
    file inside the `main` folder and add the code from the source into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This control's only purpose is to display the current `Category` name.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that we have some new CSS classes in the `MainHeader.css` and `App.css`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Home screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we continue, let''s perform some basic setup for our new route. Here,
    we''ll create our new screen component, `Home`, and update any related files,
    such as `App.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: When we first created our `App.tsx` file, we did so as if our application will
    have only one screen. Obviously, this is not true. Now that we have fleshed out
    our layout, let's begin adding our distinct screens and routes. Open the `App.tsx`
    file and update it like this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we have added a new import called `Home` that represents the main page
    route. We will build this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We are defining a function here to send to our route''s `render` property.
    This function allows all the route''s props, as well as any custom props we would
    like to send, to be included in the initialization of our `Home` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: So, the previous code that showed our Grid areas will now be in the `Home` component,
    which again, we will build shortly.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*, our `Switch` component allows React Router to
    change the rendering of route screens based on the URL provided. For now, we will
    have two routes pointing to the same `Home` screen, but we will add more later.
    The root path will show Threads for a default category, while the `categorythreads`
    route will show Threads for a specific category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we create our new `Home` component, let''s refactor our CSS a bit and
    make it more reusable. First, update the `App.css` file by adding the following
    class above the `App` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will now become the root class for any components that represent route
    screens in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file called `Home.css` inside the `components/routes` folder.
    Now, cut this entire set of CSS styles from `App.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Create a folder inside the `components` folder called `routes` and add a new
    file called `Home.tsx` inside it. The code is short and simple, so you can just
    copy it from the source. It's mostly the old code from the previous version of
    `App.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've updated our root CSS `App` class so that it's now `screen-root-container
    home-container`. Using two classes in one class attribute simply means to first
    apply the first class style and then apply the next, which will override any settings
    from the prior. Also, we will now be able to use `screen-root-container` in the
    other screens.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully moved our original `App.tsx` code into the `Home.tsx` file.
    Notice that we also placed our `Nav` component inside a `div` tag. We're doing
    this so that we can reuse the `Nav` component later in other screens. You should
    now remove the `className="navigation"` attribute from your `Nav.tsx` component
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have updated our `Home` screen, we need to update our `Main` component
    so that it lists the threads within the given category. In order to do this, we
    actually need to do quite a few updates. First, we need to create two new models
    called `Thread` and `ThreadItem`. `Thread` is the initial post, while `ThreadItem`
    is a response. Let's start with our models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, create `Thread.ts` in the `models` folder, as shown in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: There's not much to explain here as it's fairly obvious. However, note that
    `points` indicates the total number of likes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's do `ThreadItem.ts`. Create the required file and add the source
    code to it. It's pretty similar to `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create the thread card file component. This component will represent
    a single Thread record and will show things such as its title, body, and points.
    Create a file called `ThreadCard.tsx` inside the `components/areas/main` folder.
    Then, add the code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have various imports, including the `Link` object and the `useHistory`
    Hook from React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'const ThreadCard: FC<ThreadCardProps> = ({ thread }) => {'
  prefs: []
  type: TYPE_NORMAL
- en: const history = useHistory();
  prefs: []
  type: TYPE_NORMAL
- en: const { width } = useWindowDimensions();
  prefs: []
  type: TYPE_NORMAL
- en: 'const onClickShowThread = (e: React.  MouseEvent<HTMLDivElement>) => {'
  prefs: []
  type: TYPE_NORMAL
- en: history.push("/thread/" + thread.id);
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'const getPoints = (thread: Thread) => {'
  prefs: []
  type: TYPE_NORMAL
- en: if (width <= 768) {
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <label
  prefs: []
  type: TYPE_NORMAL
- en: style={{
  prefs: []
  type: TYPE_NORMAL
- en: 'marginRight: ".75em",'
  prefs: []
  type: TYPE_NORMAL
- en: 'marginTop: ".25em",'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '{thread.points || 0}'
  prefs: []
  type: TYPE_NORMAL
- en: <FontAwesomeIcon
  prefs: []
  type: TYPE_NORMAL
- en: icon={faHeart}
  prefs: []
  type: TYPE_NORMAL
- en: className="points-icon"
  prefs: []
  type: TYPE_NORMAL
- en: style={{
  prefs: []
  type: TYPE_NORMAL
- en: 'marginLeft: ".2em",'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </label>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'const getResponses = (thread: Thread) => {'
  prefs: []
  type: TYPE_NORMAL
- en: if (width <= 768) {
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <label
  prefs: []
  type: TYPE_NORMAL
- en: style={{
  prefs: []
  type: TYPE_NORMAL
- en: 'marginRight: ".5em",'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '{thread && thread.threadItems && thread.           threadItems.length}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: <FontAwesomeIcon
  prefs: []
  type: TYPE_NORMAL
- en: icon={faReplyAll}
  prefs: []
  type: TYPE_NORMAL
- en: className="points-icon"
  prefs: []
  type: TYPE_NORMAL
- en: style={{
  prefs: []
  type: TYPE_NORMAL
- en: 'marginLeft: ".25em",'
  prefs: []
  type: TYPE_NORMAL
- en: 'marginTop: "-.25em",'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </label>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: const getPointsNonMobile = () => {
  prefs: []
  type: TYPE_NORMAL
- en: if (width > 768) {
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div className="threadcard-points">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="threadcard-points-item">
  prefs: []
  type: TYPE_NORMAL
- en: '{thread.points || 0}'
  prefs: []
  type: TYPE_NORMAL
- en: <br />
  prefs: []
  type: TYPE_NORMAL
- en: <FontAwesomeIcon icon={faHeart}              className="points-icon" />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div
  prefs: []
  type: TYPE_NORMAL
- en: className="threadcard-points-item"
  prefs: []
  type: TYPE_NORMAL
- en: 'style={{ marginBottom: ".75em" }}'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '{thread && thread.threadItems && thread.             threadItems.length}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: <br />
  prefs: []
  type: TYPE_NORMAL
- en: <FontAwesomeIcon icon={faReplyAll}              className="points-icon" />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <section className="panel threadcard-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="threadcard-txt-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="content-header">
  prefs: []
  type: TYPE_NORMAL
- en: <Link
  prefs: []
  type: TYPE_NORMAL
- en: to={`/categorythreads/${thread.category.id}`}
  prefs: []
  type: TYPE_NORMAL
- en: className="link-txt"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <strong>{thread.category.name}</strong>
  prefs: []
  type: TYPE_NORMAL
- en: </Link>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '<span className="username-header" style={{            marginLeft: ".5em" }}>'
  prefs: []
  type: TYPE_NORMAL
- en: '{thread.userName}'
  prefs: []
  type: TYPE_NORMAL
- en: </span>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="question">
  prefs: []
  type: TYPE_NORMAL
- en: <div
  prefs: []
  type: TYPE_NORMAL
- en: onClick={onClickShowThread}
  prefs: []
  type: TYPE_NORMAL
- en: data-thread-id={thread.id}
  prefs: []
  type: TYPE_NORMAL
- en: 'style={{ marginBottom: ".4em" }}'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <strong>{thread.title}</strong>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div
  prefs: []
  type: TYPE_NORMAL
- en: className="threadcard-body"
  prefs: []
  type: TYPE_NORMAL
- en: onClick={onClickShowThread}
  prefs: []
  type: TYPE_NORMAL
- en: data-thread-id={thread.id}
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <div>{thread.body}</div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: <div className="threadcard-footer">
  prefs: []
  type: TYPE_NORMAL
- en: <span
  prefs: []
  type: TYPE_NORMAL
- en: style={{
  prefs: []
  type: TYPE_NORMAL
- en: 'marginRight: ".5em",'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <label>
  prefs: []
  type: TYPE_NORMAL
- en: '{thread.views}'
  prefs: []
  type: TYPE_NORMAL
- en: <FontAwesomeIcon icon={faEye}                  className="icon-lg" />
  prefs: []
  type: TYPE_NORMAL
- en: </label>
  prefs: []
  type: TYPE_NORMAL
- en: </span>
  prefs: []
  type: TYPE_NORMAL
- en: <span>
  prefs: []
  type: TYPE_NORMAL
- en: '{getPoints(thread)}'
  prefs: []
  type: TYPE_NORMAL
- en: '{getResponses(thread)}'
  prefs: []
  type: TYPE_NORMAL
- en: </span>          </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '{getPointsNonMobile()}    </section>'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: export default ThreadCard;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: .threadcard-txt-container {
  prefs: []
  type: TYPE_NORMAL
- en: 'display: flex;'
  prefs: []
  type: TYPE_NORMAL
- en: 'flex-direction: column;'
  prefs: []
  type: TYPE_NORMAL
- en: 'width: 92%;'
  prefs: []
  type: TYPE_NORMAL
- en: 'margin: 0.75em 1em 0.75em 1.2em;'
  prefs: []
  type: TYPE_NORMAL
- en: 'border-right: solid 1px var(--border-color);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created our Thread container, `ThreadCard`, let's update our
    `Main.tsx` file so that we can use it. Add the code from the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if you look on *line 8*, you will see the `useParams` function being used. Previously,
    we created two routes for React Router in the `App.tsx` file. One of the routes,
    `categorythreads`, accepted a URL parameter. By using the `useParams` Hook, we
    can get route parameters – in this case, `categoryId` – so that we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on *line 9*, we have the `category` state. Once we've retrieved our category
    from the list of threads, we will update this state.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 10*, we have a state object, which is a list of our `ThreadCards`,
    called `threadCards`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in `useEffect`, we are updating our list of `ThreadCards` if we get a
    new `categoryId`. When we get a valid `categoryId`, we use our `DataService` to
    query for a list of threads that are specific to that category and then build
    out a list of `ThreadCards`. We also take the first thread to get the name of
    the category, since they all have the same category.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will see warnings about missing dependencies on the array of
    the `useEffect` Hook. These are what I consider opinionated warnings and with
    experience, you will be able to judge which of them can be safely ignored. For
    example, in `useEffect` for `Main.tsx`, I am deliberately ignoring this warning
    about the `category` state object, because including the object in the array would
    trigger an unnecessary double run of `useEffect` (because `useEffect` runs whenever
    something in its array list has changed) and possibly a double render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try running in desktop mode. Go to `http://localhost:3000/categorythreads/1`.
    You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Desktop view of the categorythreads URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Desktop view of the categorythreads URL
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like on mobile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Mobile view of the categorythreads URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Mobile view of the categorythreads URL
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in mobile mode, we don't have the right column of points. Instead,
    those points are in the bottom of the main text section. The icons show that,
    for the first post, two people have seen it. 55 people liked it, and one person
    responded.
  prefs: []
  type: TYPE_NORMAL
- en: Wow – that was a lot of code we just went through! However, we're not done yet!
    Let's continue by building our `RightMenu` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our `RightMenu`, we want to show a list of the top three categories with
    the most thread postings. In each category, we''ll show the topmost viewed threads.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a folder for `RightMenu` inside the `areas` folder called `rightMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a new file inside that folder called `TopCategory.tsx`. This component
    will represent a single top category and its threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new model that will represent the data coming from the server. Let's
    call it `CategoryThread`. Create a file called `CategoryThread.ts` inside the
    `models` folder and enter the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to update our existing `RightMenu` component and create a new component
    that will display our `CategoryThread` items. To group and organize our `CategoryThread`
    items, we need to use a tool called Lodash to help us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lodash is a dependency that provides an enormous library of JavaScript helper
    functions. It would be impossible to go through all its capabilities here. However,
    Lodash is particularly useful for managing arrays and collections. You will see
    it''s pretty straightforward to use, but if you would like more details, here''s
    a link to their documentation: `https://lodash.com/docs/`. Install Lodash like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to build our `TopCategory` component. Create the file called `TopCategory.tsx`
    in the same folder as `RightMenu` and add the relevant source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top, notice that we have a complementary CSS file called `TopCategory.css`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a new interface called `TopCategoryProps` for receiving props.
    On *line 10*, the threads state object will store our JSX element when it's ready.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on *line 12*, we have `useEffect`, which we will use to build our UI elements
    based on the passed in prop; that is, `topCategories`.
  prefs: []
  type: TYPE_NORMAL
- en: The returned JSX has a `strong` header, which is the name of the first category
    element that was found, since the array of top categories is always from one category.
    Then, we included our list of threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this `RightMenu` does not render for mobile devices, let''s see what
    it looks like on desktop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.12 – RightMenu with top categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – RightMenu with top categories
  prefs: []
  type: TYPE_NORMAL
- en: OK – we're getting there! We've completed most of what we need for our main
    screen, but now, we need our application to show an individual **Thread posting**.
  prefs: []
  type: TYPE_NORMAL
- en: Thread posts screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This screen will be multi-use. Using this screen, we will be able to create
    a new posting or display an existing one. We will also show Thread responses on
    the same screen. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create our new route component. We'll call it `Thread.tsx`
    and place it inside a new folder called `thread`, which should be placed inside
    the `routes` folder. However, our `Thread` component will be complex, so we should
    split it into modular pieces known as child components. In this case, doing this
    will not give us code reuse benefits. However, it will make the code easier to
    read and refactor since it will be distributed in chunks instead of a single very
    large monolith. Let's create a new component file called `ThreadHeader.tsx` and
    add the source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, notice the new function we are importing, `getTimePastIfLessThanDay`.
    This function will look at a passed-in date and format it appropriately for ease
    of readability.
  prefs: []
  type: TYPE_NORMAL
- en: This component will take the fields in as parameters and not have a state of
    its own. `ThreadHeader` is acting as a display-only component. It shows the thread's
    `title`, `userName`, and `lastModifiedOn` time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the `Thread.tsx` file and add the source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we are importing a new `Thread.css` file and our new `ThreadHeader`
    component. Also, notice that since our component is also called `Thread`, as is
    our model, I am importing our model as `ThreadModel`. This type of issue can occur
    somewhat frequently in large projects, so you should be aware that you can import
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must create our local `thread` state object, which is of the `ThreadModel`
    type. Then, we must use the `useParams` Hook once again to get the route parameter's
    `id`, which is the ID of the thread for this route.
  prefs: []
  type: TYPE_NORMAL
- en: In `useEffect`, if the `id` route parameter exists and it is greater than `0`,
    we attempt to get our `thread`. Later, once our backend is ready, we'll write
    some code so that new threads can be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return our UI, which includes `ThreadHeader`. Notice that the `lastModifiedOn`
    field is non-nullable, so we are using a ternary check for a null `thread` and
    returning the current date if it is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a new route for our `Thread` screen component. Open
    `App.tsx` again and update the code, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve added the `renderThread` function for our `Thread` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our route for `Thread` is `"/thread/:id"`, which means that after
    the thread path, it expects a parameter. Internally, React Router will label it
    `id`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll add the next section of our Thread screen. On this screen, we will
    be displaying the Thread's category via a drop-down menu. However, since the standard
    dropdown in HTML, called a `select` element, is ugly and does not integrate well
    with React, we'll use an NPM package called `react-dropdown` to help us get a
    more attractive and React integrated control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `react-dropdown` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create our `Title` component. We'll call it `ThreadTitle`. Create
    a file called `ThreadTitle.tsx` inside the `thread` folder and add the source
    code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just a simple renderer, so I won't explain it here. However, notice
    that, at the moment, our `onChangeTitle` handler is blank. Again, once our backend
    is ready, we will distinguish between read and write states and implement the
    `onChangeTitle` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's update our `Thread.tsx` file and take a look at what we have so far.
    Update `Thread.tsx` like this. Note that as we've been adding these Thread-related
    components, we've been updating the `Thread.css` file, so keep your CSS file updated
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The state and `useEffect` code is basically the same, so I won''t show it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added our new components to our returned JSX. As you can see,
    our code is a lot shorter and easier to read than if we had the individual elements
    and event handlers all in the `Thread.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the app via `http://localhost:` `3000/thread/1`, you should see
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Thread screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Thread screen
  prefs: []
  type: TYPE_NORMAL
- en: Note that the gap on the right is where we will add likes and response count
    information for the Thread.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're not reviewing every single CSS file here because we want to focus
    on the code, but since this is a major screen and route destination, let's review
    the CSS to see how we laid this out. This is what we have thus far. Update your
    `Thread.css` file so that we can take a look together.
  prefs: []
  type: TYPE_NORMAL
- en: As we did previously with the Home screen, we placed our nav control inside
    its own div container called `thread-nav-container`.
  prefs: []
  type: TYPE_NORMAL
- en: This `thread-content-container` class is where the actual Thread content is
    being laid out. As you can see, the layout is a Grid with two columns and an undefined
    indeterminate number of rows.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the content is being added to the first column using the `grid-column`
    attribute. We will add the second column to hold our Thread's points (likes) later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add a section for the body of our Thread posting. The body entry
    is a bit more complicated because we will need to add a Rich Text entry formatter.
    This control will allow users to format their text and do more sophisticated editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create our body, let''s install an NPM package called Slate.js. This will
    be our Rich Text editor and formatter. We''ll also need to install several dependencies,
    including something called Emotion. Emotion is a library that allows us to use
    CSS directly inside JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create the `RichEditor.tsx` file in the same `editor` folder
    and add this code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of our imports section, we can see the usual React-related imports,
    but also two Slate.js imports. These are there to help us create our editor UI.
    I'll explain these in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The `isHotKey` import is a tool that helps us build keyboard shortcuts for our
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: The `withHistory` import allows the editor to save the edits that have occurred,
    in their correct order, so that they can be undone if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`Button` and `Toolbar` are controls that can be used to build our editor UI.
    We''ll create the `RichTextControls` file in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can import our icons and CSS stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HOTKEYS` variable is a dictionary that contains the various shortcut keys
    to formatting pairings. `[keyName: string]` on the left represents the dictionary
    key; the right-hand side shows the value.'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 26*, we have the `initialValue` variable. Our editor uses objects for
    its value, not strings. So, the `initialValue` variable represents the starting
    value object of the editor. The type is a `Node` array that comes from the Slate.js
    editor. In Slate.js, text is represented as hierarchical trees of nodes. This
    is to make sure that the structure of the text is kept intact, but also to allow
    formatting information to live alongside the text. You can think of it as text
    and metadata together.
  prefs: []
  type: TYPE_NORMAL
- en: The `LIST_TYPES` array is used to distinguish between whether an entry is a
    paragraph or a list of text.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 38*, we start creating our `RichEditor` component. As we mentioned
    previously, in Slate.js, the value or content of the text inside the editor is
    not plain text. It is a JSON object and its root type is `Node`. So, our main
    text value, called `value`, is a state object of the Node array type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `renderElement` function, which is used internally to render
    larger text pieces. An `Element` is a multi-line set of text. We'll build the
    `Element` component in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `renderLeaf` function, which is used to render smaller bits
    of text. A `Leaf` is a small snippet of text. We will create this component a
    bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we covered Hooks, such as `useCallback` and `useMemo`, in [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)*, React Development with Hooks*.
  prefs: []
  type: TYPE_NORMAL
- en: We then have the editor variable. The editor is the React component that accepts
    and displays text, as opposed to the `Slate`, `Toolbar`, and `Editable` components,
    which act as wrappers around the editor and inject or modify text formatting for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` function is used to grab the `existingBody` prop and make it
    the local state value, assuming `existingBody` was passed in. Again, an `existingBody`
    is passed in only during view mode, not create mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `onChangeEditorValue` event handler sets the local `value` state when it
    is changed in the UI. Again, notice how the value type is not text, but a `Node`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Starting on *line 59*, we start our JSX definition. We initialize our Slate
    wrapper component with our `editor` instance, local `value` state, and the `onChange`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `Toolbar`, which is from the `RichTextControls.tsx` file, represents
    a layout container and contains our buttons for formatting. They look like this.
    I will explain `MarkButton` and `BlockButton` later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Slate.js Toolbar buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Slate.js Toolbar buttons
  prefs: []
  type: TYPE_NORMAL
- en: The Editable control contains the main formatters, shortcut keys, and base settings
    for our editor.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I've moved out most of the functions outside the main component
    for readability.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 92*, we have our `MarkButton` control. `MarkButton` is a function that
    generates the button UI and also associates the actual formatter that triggers
    when that specific button is clicked. Generally, marks are used for words or characters,
    as opposed to blocks, which are usually multi-line statements. `Button` is from
    our `RichTextControls.tsx` file. It represents a styled button on our Toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `isMarkActive` function. The `isMarkActive` function determines
    if a formatter has been applied already.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `toggleMark` function will toggle the formatting based on whether
    it has been applied or not. It associates the editor with the format.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockButton` sets the formatting for a block of text and creates its button.
    Usually, a block contains multiple `Nodes`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `isBlockActive` function determines if formatting was applied.
  prefs: []
  type: TYPE_NORMAL
- en: '`ToggleBlock` toggles the applied formatting.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `Element` component determines which type of HTML to use. `Elements`
    are used quite frequently in Slate.js.
  prefs: []
  type: TYPE_NORMAL
- en: We use `Leafs` to determine smaller HTML to return. `Leafs` are frequently used
    in Slate.js.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a reusable Rich Text editor. We will certainly use this component
    in our Thread display. Now, since it is its own component, we can reuse this code
    wherever we like.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add our new `RichEditor` to our `ThreadBody.tsx` file. It is
    a small component, so just add the code from the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to reference our `ThreadBody` from our `Thread` component,
    like this. Make sure you have all the necessary imports. Then, in the JSX, just
    below `ThreadTitle`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice how easy it is to read and understand this JSX now that we have
    put it into components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Thread entry screen and its editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – Thread entry screen and its editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Rich Text editor provides the following options: bold, italic, underline,
    show as code, make header, wrap in quotes, number list, and bullet list. As you
    can see, all our formatters work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Slate.js, you might be wondering why the bullets appear, even though
    we added the CSS to remove `ul` styling to our `index.css` file earlier. In order
    to get proper styling in our editor, I updated that style like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is a CSS selector that says "do not apply this style if the element has
    a custom attribute on it called `data-slate-node`". This is what Slate.js uses
    to distinguish its own elements from other standard HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wow, that was a lot of code! However, we''re not done yet. We still have to
    create our points column on the right, add our response capability, and allow
    `ThreadItems` to be added. Let''s leave the points column for a little later and
    work on our response system next:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to do is some refactoring. In our `ThreadHeader` component,
    we displayed `userName` and `lastModifiedOn` to let users know who created the
    post and when. We can use this display for our responses as well. So, let's pull
    out this bit of code and put into a separate component so that we can reuse it.
    Create a file called `UserNameAndTime.tsx` in the `routes/thread` folder and add
    the source code to it. Since we're basically copying over the `ThreadHeader` code,
    I won't review it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can use this by updating our `ThreadHeader` component code. Update
    it by replacing the JSX under the `h3` tags for `title` with the following code.
    Don''t forget to add the import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we can start building our `ThreadItems` component. But this time,
    we'll do things a little differently. In the case of Thread responses, it is possible
    that we might have more than one response. So, this scenario is somewhat analogous
    to a machine in a widget factory. There is only one machine but potentially many
    widgets that need to be created. This sort of situation in programming design
    would usually entail using something called a factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we''re going to make is actually two components. One component will
    act as the factory "building" Thread responses. The other component will define
    what a response actually looks like. So, together these two components can churn
    out any number of responses. Note that we''re not using the formal design pattern
    for the factory, just a rough conceptual model. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create our `ThreadResponse` component, which will define what
    our `ThreadItem` UI and behavior look like. Create a `ThreadResponse.tsx` file
    inside `routes`/`thread` and add the relevant source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, notice we are importing and reusing the `RichEditor` and `UserNameAndTime`
    components we created earlier. Can you imagine how much work it would take to
    have to recreate them again if we had not componentized them? Thank goodness we
    put them into their own components!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our `ThreadResponseProps` interface. Notice that all our props
    are optional. This is in preparation for when we refactor this component and make
    it capable of creating new response entries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the returned JSX. This is a pretty simple UI – we just display
    our `UserNameAndTime` and `RichEditor`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create our `ThreadResponse` factory. Create a file called `ThreadResponseBuilder.tsx`
    in the same folder and add the relevant source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we have the `ThreadResponsesBuilderProps` interface. This component will
    receive a `props` that contains a list of `ThreadItems`. We'll have to update
    our `Thread` parent component so that it passes the list down.
  prefs: []
  type: TYPE_NORMAL
- en: Starting on *line 12*, since our builder is churning out multiple responses,
    our only state, `responseElements`, is a JSX element that's used to contain them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `useEffect` to create our list of response elements. Each `ThreadResponse`
    instance has a unique key, which prevents rendering issues. Whenever our `threadItems`
    props change, we will create a `ul` of `ThreadResponses`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return our JSX, which is a list of `TheadResponse` elements.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done. Let's update our `Thread.tsx` file so that it now uses our
    `ThreadResponsesBuilder` component. Note that the styling has been updated in
    the `App.css` and `Thread.css` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the JSX just below `ThreadBody`, add the highlighted tags shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.16 – A Thread and its responses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – A Thread and its responses
  prefs: []
  type: TYPE_NORMAL
- en: We now have an almost complete `Thread` posting and viewing UI. But again, we're
    not done yet. We still have to build our points viewer and enable `Thread` and
    `ThreadItem` posting. We'll build the points viewing component here, but let's
    leave the posting capability for later chapters, when we have our backend ready
    to tie it together. Also, when our backend is ready, it will become clearer as
    to why we did certain things the way we did them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `categorythreads` route, you saw that we had a vertical bar showing
    our likes and response count. If you take a look at how we created that section,
    you''ll see we put that code into a function called `getPointsNonMobile`. We could
    extract this feature into its own React component. Obviously, this will allow
    us to use it in both our `ThreadCard` component and our `Thread` component, as
    well as anywhere else we may need it later. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `ThreadPointsBar.tsx` and place it inside the root
    of the `components` folder. We'll take the `getPointsNonMobile` function from
    the `ThreadCard` component and add it inside this new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On *line 6*, we use `ThreadPointsBarProps` as our props type. You may be wondering
    why I didn't just pass the entire Thread object in. Adding only the member data
    that's needed allows us to keep better separation of concerns. If we passed the
    entire Thread, not only would we be telling our `ThreadPointsBar` about what model
    types we are dealing with, but we would be giving it information it does not actually
    use or need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the returned JSX is basically the same as the original function as it
    does the same thing. Now, try updating the `ThreadCard` component so that the
    `getPointsNonMobile` function gets removed. In its place, we will add our new
    `ThreadPointsBar` component. Note that our `ThreadCard.css` file was updated slightly,
    so you should refresh it. The screen should look identical to our original screen
    since we only moved things around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add our new `ThreadPointsBar` component to our `Thread` route component.
    The JSX changes are small but significant, so let''s go over them here and then
    look at our updated `Thread.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve moved the order of some of our elements around. Now, the main
    Thread post-related elements are under this `div` in the `thread-content-post-container`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a brand new `div` with a `thread-content-points-container` class
    that contains our new `ThreadPointsBar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want to give our points totals for our responses. However, because we
    could end up having many responses, it might not look that great to have 20 or
    30 little vertical points bars for each response. So, to make things look cleaner,
    let's just put these points on the same line as our `userName` and `createdOn`
    dates. Luckily for us, we've already created most of the code to show these points
    in our `ThreadCard` component with the `getPoints` function. So, let's convert
    that into a component too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file called `ThreadPointsInline.tsx` and add the relevant source
    code to it. We've basically just copied and pasted our `getPoints` code into here,
    so there's not much to explain. However, notice that we reused the `ThreadPointsBarProps`
    interface from the `ThreadPointsBar` component. So, we need to make this type
    exportable.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll assume you know how to update the `ThreadCard.tsx` file since we did
    this earlier with `ThreadPointsBar`. Now, let''s update the `ThreadResponse.tsx`
    file so that it uses our new `ThreadPointsInline` component. Try and do this on
    your own; only look at the code if you get stuck. So, here''s what we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Displaying thread points'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.17_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.17 – Displaying thread points
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both our points systems can be seen. Now, there's one final
    small trick we need to implement to get this screen showing up properly on mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Thread.css` file and make sure it contains the same Media Query as
    the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the `Thread` component's code so that we can go through it.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 32*, you will see that our Thread post-related items all live inside
    `thread-content-container`. The CSS class, via the Media Query, has been set so
    that it only has a `ThreadPointsBar` component from that area, we don't end up
    with an empty space, because we had two columns previously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see that our `ThreadPointsBar` actually lives inside `thread-content-points-container`.
    In the Media Query, we are making that element invisible. This is still efficient
    because, as you may recall, internally, `ThreadPointsBar` is using our `useWindowDimensions`
    Hook to determine if it should render itself or not. It will not do this for mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! Let''s take a look our screen now on mobile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Mobile view of the Thread screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.18_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Mobile view of the Thread screen
  prefs: []
  type: TYPE_NORMAL
- en: Terrific! Now, we have one code base and two screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final item in this chapter, we will build out our `UserProfile` screen.
    We want to do a few things with this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow users to reset their passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show all user-generated Thread posts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show all user-generated responses (`ThreadItems`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: The very first thing we have to do is actually make a change to the `SideBarMenus`
    component. We need to move out the `useEffect` call in order to send our user
    to Redux, and then to the `Login` component. We're doing this so that when the
    user successfully logs in, the new user object will be sent to Redux. By now,
    you should be comfortable with making this kind of change. So, go ahead and remove
    this code from `SideBarMenu` and add it to `Login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that when you put the code into `Login`, you change the name of `dispatch`
    to something else, as there is already a `dispatch` in the `Login` component.
  prefs: []
  type: TYPE_NORMAL
- en: This new screen will include a password reset feature, but you may recall we
    already have a lot of code for doing password confirmations in our `Register`
    component. Let's try to extract that code into its own component so that we can
    reuse it in both the `Register` component and our new `UserProfile` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `PasswordComparison.tsx` inside the `components/auth/common`
    folder. Add the relevant source code to it.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly straightforward copy and paste, but there's a couple of things
    to note. Notice that this component does not use `userReducer`, instead taking
    props for its values. In particular, notice that one of them is the `dispatch`
    function. `dispatch` call belongs to the parent. Everything else is basically
    a copy and paste.
  prefs: []
  type: TYPE_NORMAL
- en: Try removing this code yourself from the original `Register` component. Ensure
    that you remove all the unnecessary imports.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a new `userProfile` folder inside the `routes` folder so that
    we can create our new `UserProfile.tsx` file and add the relevant source code
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting on *line 14*, we use our `userReducer` since we need some of its properties,
    such as `userName`. We also get the Redux user reducer and set some local state
    for the user's Threads and `ThreadItems`.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 28*, the `useEffect` function is using the`getUserThreads` function
    of `DataService`, which gets the user's Threads. We don't need another call to
    get `ThreadItems` because Threads contains related `ThreadItems`. However, I did
    update the `ThreadItem` class so that it includes its parent `ThreadId`. Take
    a look at those files for that code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, starting on *line 38*, we map each Thread in the query results to an `li`.
    We also add all `ThreadItems` to a single array so that we can use them later.
  prefs: []
  type: TYPE_NORMAL
- en: Then, starting on *line 53*, we've taken our `ThreadItems` and mapped them to
    a set of `li` as well.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 77*, we use the `PasswordComparison` component that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 82*, notice we have our button using `isSubmitDisabled`. Can you guess
    how this disabling is working, even though `UserProfile` does not contain any
    code to change it? That's right – `PasswordComparison` is doing it internally
    using our UserProfile's `dispatch` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have our Threads and `ThreadItems` rendered off our local state
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: For the final change, let's update our `App.tsx` file so that it includes our
    new route for `UserProfile`. Note that we also need to temporarily add the `userName`
    Redux call until the same call, inside `Login.tsx`, is completely working (we'll
    finish the call in `Login.tsx` once our backend is ready). This is because when
    we load our `UserProfile`, there is no guarantee that the user has already loaded
    their `Login` screen. However, we know that if they've loaded any screen in the
    app, they must have loaded the `App.tsx` component. Update `App.tsx` from the
    source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, first, we have a `useEffect` with a hardcoded `userName` being sent to the
    Redux store. Again, this is only temporary until our backend is ready.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 26*, `renderUserProfile` is the function that returns our `UserProfile`
    component. That function is then used on *line 33* as the destination for the
    new route; that is, `"/userprofile/:id"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more tiny change we need to make. In our `SideBarMenus` component,
    let''s update our `userName` label so that it''s a link to our new `UserProfile`
    screen. You can find this JSX in the `SideBarMenus.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the app, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – UserProfile screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.19_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – UserProfile screen
  prefs: []
  type: TYPE_NORMAL
- en: If you click on any of the Thread links, you'll see that they take us to the
    thread route.
  prefs: []
  type: TYPE_NORMAL
- en: That was amazing! We've gone through so much React code in this chapter. We
    learned about the layout, folder structure, component creation, code reuse, code
    refactoring, styling, and more. Code refactoring in particular can be very time-consuming
    and even stressful. However, the reality is that most of the time, we will not
    be writing new code but refactoring existing code. So, this was a good way to
    build our skills.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we will be building out our backend and tying it together
    with our client side. You should now feel very confident – you've made a huge
    effort in getting through this complex chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began our journey of building our full stack application
    by creating our React client. We used Hooks to create our components, implemented
    component hierarchies, and designed layouts using CSS Grid. We then refactored
    a ton of code, and we tried to reuse as much code as possible. Even though we're
    not done yet, we've built out a large important piece of our final application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn about the session state on our backend server,
    what the session state is, how to use it, and the most popular tool for creating
    and managing session data: Redis.'
  prefs: []
  type: TYPE_NORMAL
