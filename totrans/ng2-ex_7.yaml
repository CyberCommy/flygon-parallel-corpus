- en: Chapter 7.  Testing Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you are a superhero who codes perfectly, you need to test what you build.
    Also, unless you have loads of free time to test your application again and again,
    you need some test automation.
  prefs: []
  type: TYPE_NORMAL
- en: When we say Angular was built with testability in mind, we really mean it. It
    has a strong **Dependency Injection** (**DI**) framework, some good mock constructs,
    and awesome tools that make testing in an Angular app a fruitful endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about testing and is dedicated to testing what we have built
    over the course of this book. We test everything from components to pipes, services,
    and our app directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the big picture**: We will try to understand how testing fits
    into the overall context of Angular app development. We will also discuss the
    types of testing Angular supports, including unit and **end-to-end** (**E2E**)
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview of tools and frameworks**: We cover the tools and frameworks that
    help in both unit and end-to-end testing with Angular. These include **Karma**
    and **Protractor**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing unit tests**: You will learn how to do unit testing with Angular
    using Jasmine and Karma inside a browser. We will unit-test what we have built
    in the last few chapters. This section also teaches us how to unit-test various
    Angular constructs, including pipes, components, services, and directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating end-to-end tests**: Automated end-to-end tests work by mimicking
    the behavior of the actual user through browser automation. You will learn how
    to use Protractor combined with WebDriver to perform end-to-end testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the testing begin!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for this chapter can be found at `checkpoint7.1`. It is available on
    GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not using Git, download the snapshot of `checkpoint7.1` (a ZIP file)
    from this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: The need for automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The size and complexity of apps being built for the Web are growing with each
    passing day. The plethora of options that we now have to build web apps is just
    mind-boggling. Add to this the fact that the release cycles for products/apps
    have shrunk drastically from months to days, or even multiple releases per day!
    This puts a lot of burden on software testing. There is too much to be tested.
    Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple
    resolution, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To be effective in such a diverse landscape, automation is the key. *Automate
    everything that can be automated* should be our mantra.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular team realized the importance of testability and hence created a
    framework that allowed easy testing (automated) for apps built on it. The design
    choice of using DI constructs to inject dependencies everywhere helped. This will
    become clear as the chapter progresses and we build a number of tests for our
    apps. However, before that, let's understand the types of testing that we target
    when building apps on this platform.
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are broadly two forms of testing that we do for a typical Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing is all about testing a component in isolation
    to verify the correctness of its behavior. Most of the dependencies of the component
    under test need to be replaced with mock implementations to make sure that the
    unit tests do not fail due to failure in a dependent component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end testing**: This type of testing is all about executing the application
    like a real end user and verifying the behavior of the application. Unlike unit
    testing, components are not tested in isolation. Tests are done against a running
    system in real browsers, and assertions are done based on the state of the user
    interface and the content displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is the first line of defense against bugs, and we should be able
    to iron out most issues with code during unit testing. But unless E2E is done,
    we cannot confirm that the software is working correctly. Only when all the components
    within a system interact in the desired manner can we confirm that the software
    works; hence, E2E testing becomes a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: Who writes unit and E2E tests and when are they written are important questions
    to answer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing - who does it and when?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, E2E testing was done by the **Quality Assurance** (**QA**) team
    and developers were responsible for unit-testing their code before submitting.
    Developers too did some amount of E2E testing but the overall the E2E testing
    process was manual.
  prefs: []
  type: TYPE_NORMAL
- en: With the changing landscape, modern testing tools, especially on the web front,
    have allowed developers to write automated E2E tests themselves and execute them
    against any deployment setup (such as development/stage/production). Tools such
    as Selenium, together with WebDrivers, allow easy browser automation, thus making
    it easy to write and execute E2E tests against real web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: A good time to write E2E scenario tests is when the development is complete
    and ready to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to unit testing, there are different schools of thought around
    when a test should be written. A *TDDer* writes tests before the functionality
    is implemented. Others write tests when the implementation is complete to confirm
    the behavior. Some write while developing the component itself. Choose a style
    that suits you, keeping in mind that the earlier you write your tests, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to give any recommendations, nor are we going to get into an
    argument over which one is better. Any amount of unit tests is better than nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Our personal preference is to use the *middle approach*. With TDD, we feel that
    the test creation effort at times is lost as the specifications/requirements change.
    Tests written at the start are prone to constant fixes as the requirement changes.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with writing unit tests at the end is that our target is to create
    tests that pass according to the current implementation. The tests that are written
    are retrofitted to test the implementation whereas they should test the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tests somewhere in the middle works best for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now try to understand the tooling and technology landscape available for
    Angular testing.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular testing ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the following diagram to understand the tools and frameworks that support
    Angular testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Angular testing ecosystem](../Images/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we write our tests using unit testing libraries such as Jasmine
    or Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, the Angular testing library works by default with Jasmine. However,
    the Angular team has indicated that they have made the framework more generic
    so that you can use other testing libraries such as Mocha with it. The Angular
    documentation has not yet been updated to include how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: These tests are executed by either Karma or Protractor depending on whether
    we are writing unit or integration tests. These test runners in turn run our tests
    in a browser such as Chrome, Firefox, or IE, or headless browsers such as PhantomJS.
    It is important to highlight that not only E2E but also unit tests are executed
    in a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Except for browsers, the complete Angular testing setup is supported by the
    awesome libraries and framework made available through the **Node.js** ecosystem.
    Some libraries such as Jasmine have standalone versions too, but we will stick
    to Node.js packages.
  prefs: []
  type: TYPE_NORMAL
- en: All the tests in this chapter are written using Jasmine (both unit and integration
    tests). Karma will be our test runner for unit tests and Protractor for E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate aim of unit testing is to test a specific piece of code/component
    in isolation to make sure that the components work according to the specification.
    This reduces the chances of failures/bugs in the component when integrated with
    other parts of the software. Before we start writing tests, there are some guidelines
    that can help us write good and maintainable tests:'
  prefs: []
  type: TYPE_NORMAL
- en: One unit should test one behavior. For obvious reasons, testing one behavior
    per unit test makes sense. A failing unit test should clearly highlight the problem
    area. If multiple behaviors are tested together, a failed test requires more probing
    to assert what behavior was violated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies in a unit test should be mocked away. Unit testing, as the name
    suggests, should test the unit and not its dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should not change the state of the component being tested permanently.
    If it does happen, other tests may get affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of execution of unit tests should be immaterial. One unit test should
    not be dependent on another unit test to execute before it. This is a sign of
    a brittle unit test. It may also mean that the dependencies are not mocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should be fast. If they are not fast enough, developers will not
    run them. This is a good reason to mock all dependencies such as database access,
    remote web service call, and others in a unit test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unit tests should try to cover all code paths. Code coverage is a metric that
    can help us assess the effectiveness of unit tests. If we have covered all positive
    and negative scenarios during testing, the coverage will indeed be higher. A word
    of caution here: high code coverage does not imply that the code is bug-free,
    but low coverage clearly highlights a lack of areas covered in unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should test both positive and negative scenarios. Just don't concentrate
    on positive test cases; all software can fail, and hence unit testing failure
    scenarios are as important to test as success scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These guidelines are not framework-specific but give us enough ammunition for
    writing good tests. Let's begin the process of unit testing by setting up the
    components required for it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Karma for unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the complete test automation infrastructure is supported using Node, this
    needs to be installed first. Follow the instructions on the Node website ([https://nodejs.org](https://nodejs.org))
    and get Node installed locally.
  prefs: []
  type: TYPE_NORMAL
- en: Node comes with a package manager called **Node Package Manager** (**NPM**)
    that is used to install all other components (**packages** in the Node world)
    required for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing Karma from the command line. Navigate to the root of your
    application code base (in the `trainer` folder) and install Karma using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Karma from the command line, we need to install its command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Karma version against which the code was tested is 0.13.22\. The **karma-cli**
    version was 1.0.1 .
  prefs: []
  type: TYPE_NORMAL
- en: To install a specific version of a package, suffix the package name with `@version`,
    for example, `npm install karma@0.13.22 --save-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the Karma installation and it''s now time to configure the test
    runner. Configuring Karma is all about setting up its configuration file so that
    it contains enough details for it to run our scripts and test them. Create a `tests`
    folder in the root (in the `trainer` folder), navigate to it, and start the Karma
    configuration setup with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This starts a command-line wizard that guides us through the options available,
    including the test framework, folders to watch, and other such settings. Once
    the wizard is complete, it generates a `karma.conf.js` file. Instead of using
    the generated configuration file, copy the `karma.conf.js` file from the companion
    code base at `checkpoint7.1/tests` to your local `tests` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `karma init` wizard installs some packages based on our selection. If we
    skip the wizard, the `karma-chromelauncher` and `karma-jasmine` packages need
    to be installed manually for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will install Jasmine. So execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Karma configuration files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open `karma.conf.js` in the `tests` directory. It contains settings that affect
    the tests we run. We will not be covering each and every configuration supported
    by Karma here, but will focus on configurations that are unique and/or required
    for our test setup. Refer to the Karma documentation ([http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html))
    to understand more about the various Karma configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to set the base path for resolving file locations. In our
    case, because we have put Karma in a `tests` folder just below the root of the
    application, we will use a relative URL that will point to that location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set our framework to Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next Karma configuration is the `files` array. Files can be referenced either
    by their file path or by using patterns. In our case, we are referencing the first
    ten files using file paths. These are the files for the polyfills, SystemJS and
    zone.js. When Karma first starts it will load all these files in the browser using
    a `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest, we are using patterns because this approach allows us to set the
    `included` and `watched` properties. The `included` property determines whether
    Karma will initially load the file. If set to `true`, Karma will load these files
    in a `<script>` tag. If not, Karma will not load the file, so that some other
    mechanism must be found to do that. The `watched` property indicates whether a
    file will be watched for changes.
  prefs: []
  type: TYPE_NORMAL
- en: As you look through the file patterns in our configuration, you will notice
    files you have seen before that are used for building our application such as
    RxJS, and Angular itself. We have set the `included` property for all but one
    of these files to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one file pattern where the `included` property has been set to `true` is
    one we have not seen before: `karma-test-shim.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This pattern references an additional file that we have added to the testing
    folder to handle the special requirements for running Angular tests in Karma and
    it will be loaded by Karma when it first starts. We will discuss that file shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `watched` property in all our files (except for RxJS and the files that
    support debugging) is set to true, which means that Karma will watch these files
    and rerun our tests if any of them are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file pattern in the array after `karma-test-shim.js` is a little different
    from the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This pattern contains a path to our application files (the code that we have
    been building throughout the earlier chapters), as well as a path to the test
    files we will create.
  prefs: []
  type: TYPE_NORMAL
- en: But note that it is pointing to the `dist` directory that holds the JavaScript
    files that have been generated by the TypeScript transpiler and not the TypeScript
    files themselves. This stands to reason because Karma, of course, is a JavaScript
    test runner (and will not itself transpile our TypeScript files). This in turn
    means we will need an initial transpilation step in order to get our tests running.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the files where we have set the `included` property to false,
    how do we load them if we do not use Karma? As you know, we are using SystemJS
    to load our modules and Karma does not know anything about SystemJS. If Karma
    were to run our test files before the related modules are loaded, our tests would
    fail. This means that for these files, we need to run SystemJS and load our modules
    before Karma runs. Setting the `included` property to false means that Karma will
    not run these files automatically.
  prefs: []
  type: TYPE_NORMAL
- en: But if the config file sets the `included` property for these files to `false`,
    how and when will we run the tests in these files? The answer to that question
    brings us to the Karma test shim file.
  prefs: []
  type: TYPE_NORMAL
- en: The Karma test shim file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open `karma-test-shim.js` in the `tests` directory. This file addresses the
    challenges of using Karma with Angular and SystemJS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Karma test shim file currently uses the SystemJS loader but according to
    the Angular team it could be adapted for something else such as Web Pack.
  prefs: []
  type: TYPE_NORMAL
- en: The Karma test shim file does three things, which we'll discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it cancels Karma''s synchronous start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it adds the configuration for SystemJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This should already be familiar. After all, we are already doing this kind of
    configuration for SystemJS in the `system.js.config` file in the root of our application.
    What this configuration does is set up the path mapping for the modules that will
    be used by Karma including the Angular testing modules. We have modified the file
    so that it points to the right locations in our application for this mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to understand that this configuration is for using SystemJS with
    our test runner and not for use with our underlying application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it uses SystemJS with a promise to import our modules. If the promise
    resolves successfully, it starts up Karma, and if not, throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are importing `@angular/platform-browser-dynamic/testing` and passing
    parameters that are specific to testing browser-based applications to the `initTestEnvironment` method
    of `TestBed`. We will be discussing `TestBed` in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With this file in place, we are now ready to begin using Karma for Angular testing.
    While this configuration has been somewhat tedious, the good news is that once
    we have completed configuring Karma, Angular makes it easy to create and run unit
    tests, as we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: Organization and naming of our test files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To unit-test our app, the plan is to create one test (such as `workout-runner.spec.ts`)
    file for each TypeScript file that we have in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naming the test files with the name of the file under test plus `.spec` is a
    convention that is used by developers who test with Jasmine. It is also used to
    facilitate the mapping of files to tests in the configuration steps we outlined
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test file will contain the unit test specification for the corresponding
    component, as shown in the following screenshot (taken in the Karma debugger when
    running our unit tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organization and naming of our test files](../Images/image00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unit-testing Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the course of this book, we have built components that cover every construct
    available in Angular. We have built components, pipes, a few services, and finally
    some directives too. All of these are testable in unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to get the hang of unit testing with Jasmine, let''s test the smallest
    and easiest component first: the pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pipes are the easiest to test as they have minimum or zero dependencies on other
    constructs. The `SecondsToTimePipe` that we created for *Workout Runner* (the
    *7 Minute Workout* app) has no dependencies and can be easily unit-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the Jasmine framework documentation to understand how to write unit
    tests using Jasmine. We are using Jasmine 2.0 for our unit tests ([http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine has some of the best documentations available and the overall framework
    is very intuitive to use. We strongly recommend that you head over to the Jasmine
    site and get yourself familiar with the framework before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `seconds-to-time.pipe.spec.ts` file to the `trainer`/`src/components/shared`
    folder and add this unit test to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at what we are doing here in our test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not surprisingly, we import the `SecondsToTimePipe`, which we are going to
    test. This is just like the imports we have used elsewhere in our TypeScript classes.
    Notice that we use a relative path to the file in which it is located `''./seconds-to-time.pipe''`.
    In Angular, this means to look for the component to test in the same directory
    as the test itself. As you recall, this is the way we set up our file structure:
    putting our tests in the same directory as the file under test.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we start using Jasmine syntax. First, we wrap the test in
    a `describe` function that identifies the test. The first parameter of this function
    is a user-friendly description of the test; in this case, it is the `SecondsToTime
    pipe`. For the second parameter, we pass a lambda (fat arrow) function that will
    contain our test. After setting up a local variable to hold the pipe, we call
    Jasmine's `beforeEach` function and use this to inject an instance of our pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `beforeEach` function runs before every test that is in our `describe` function,
    we can use it for common code that will run in each of our tests. In this case,
    it is not strictly necessary since there is only one test in our `describe` function.
    But it is a good idea to get into the habit of using it for common setup scenarios,
    as we will see going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call Jasmine's `it` function and pass it a title, along with three
    calls to Jasmine's `expect` function (Jasmine's name for assertions). These are
    all self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not necessary to explicitly import these Jasmine functions in our test.
  prefs: []
  type: TYPE_NORMAL
- en: Running our test files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it''s time to run our tests using Karma. As you recall, in order to do
    that, we first have to transpile our files from TypeScript to JavaScript. To do
    this, we will simply start up our application itself in a terminal window by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The gulp file for the application will transpile our TypeScript files to JavaScript
    and then watch for changes in these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to run Karma and we do that by executing the following command
    in a separate terminal window in the `trainer` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We should then see this output in the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test files](../Images/image00403.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last line shows that our test passed successfully. To make sure that it
    is reporting the correct pass/fail results, let''s make a change in the test to
    cause one of the expectations to fail. Change the time in the first expectation
    to 6 seconds rather than 5, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test files](../Images/image00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What's nice about this error message is that it combines the `describe` and
    `it` descriptions into a complete sentence that provides a clear summary of the
    error. This shows how Jasmine allows us to write readable tests so that someone
    who is new to our code can quickly understand any problems that may arise in it.
    The next line shows us which expectation was not met, what was expected, and what
    the actual results were that did not meet this expectation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also get a lengthy stack trace below this message and a final line that
    shows the overall results of our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test files](../Images/image00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One thing you'll notice is that when we make the change to our test, we do not
    have to rerun Karma. Instead, it watches for any changes in our files and related
    tests and immediately reports success or failure whenever we make a change.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool! Let's undo the last change that we made and put the test back into
    a passing state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, we''ll be taking the following multi-step approach to executing
    all our tests. First, we use our gulp script to convert the TypeScript files to
    JavaScript. Then we call Karma to run our tests against those JavaScript files.
    The following diagram sets forth these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test files](../Images/image00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will not be repeating the description of these steps in the tests we cover
    moving forward. So, be sure to follow them with every test we are exploring in
    this section. Now let's move on to unit-testing components.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing Angular components is more complicated than testing simple pipes or
    services. That is because Angular components are associated with views and also
    usually have more dependencies than services, filters, or directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of their complexity, Angular has introduced utilities that enable us
    to test our components more easily. These testing utilities include the `TestBed`
    class (which we previously used to initialize our tests) and several helper functions
    in `@angular/core/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` has a `createComponent` method that returns a `ComponentFixture`
    containing several members and methods, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debugElement`: For debugging a component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentInstance`: For accessing the component properties and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nativeElement`: For accessing the view''s markup and other DOM elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detectChanges`: For triggering the component''s change detection cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComnponentFixture` also contains methods for overriding the view, directives,
    bindings, and providers of a component. Going forward, we will be using `TestBed`
    throughout the rest of our tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` has a method called `configureTestingModule` that we can use to set
    up our testing as its own module. This means we can bypass the initial bootstrap
    process and compile our components under test within out test files. We can also
    use `TestBed` to specify additional dependencies and identify the providers that
    we will need.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the Angular documentation, `TestBed` has a base state that is reset
    before each spec file runs. This base state includes *the declarables (components,
    directives, and pipes) and providers (some of them mocked)* that almost every
    component needs to run. See [https://angular.io/docs/ts/latest/guide/testing.html#!#atu-intro](http://bit.ly/2eufBGN).
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies in our tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Components in Angular integrate the view with everything else. Due to this,
    components normally have more dependencies compared to any of the services, filters,
    or directives.
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding the fact that our unit tests focus on the code within the component
    itself, we still need to account for these dependencies in our tests or else the
    tests will fail (we skipped the dependency setup for pipe testing as it did not
    have external dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two approaches exist for handling these dependencies: inject them into our
    component or create a mock or fake for them that we can use in our tests. If a
    dependency is simple enough, we can just inject an instance of it into our test
    class. However, if the dependency is significantly complicated, especially if
    it has dependencies of its own and/or makes remote server calls, then we should
    be mocking it. The Angular testing library provides the tools for us to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: The component that we plan to test in this section is the `WorkoutRunner` component.
    Located inside `trainer/src/components/workout-runner/`, this is the component
    that runs a specific workout.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing WorkoutRunnerComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this background, let's get started unit testing `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new file, `workout-runner-component.spec.ts`, with the following
    imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These imports identify the test utilities (and things such as `Router` and `Observable`
    from `RxJS)` that we will be using in our tests along with the types and dependencies
    our component requires. We'll discuss these dependencies in a moment. One import
    that looks different from the others is the one that imports `NO_ERRORS_SCHEMA`
    from `@angular/core`. We will use this import to ignore elements in the component
    that we will not be testing. Again, we will discuss that further in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing to note with the imports is that `@angular/core/testing` is a
    part of the core module and not in a separate testing module. This is a common
    pattern with imports for Angular testing. For example, when we get to testing
    HTTP, you will see that we are importing from `@angular/http/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up component dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to establish our component''s dependencies and determine whether
    we need to inject or mock them. If we look at the code for the `WorkoutRunner`
    component, we see that there are three dependencies being injected into our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTracker`: This is a component that has some behavior attached
    to it. So we definitely want to mock it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Router`: We''ll have to mock this too in order to isolate `WorkoutRunner`
    from the rest of the application and prevent our test from trying to navigate
    away from the `WorkoutRunner` view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkoutService:` This is a service that we will use to make an HTTP call to
    retrieve our workouts. We will mock this service as well since we don''t want
    to be making a call to an external system within our test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies - workout history tracker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular allows us to mock our dependencies in a straightforward manner using
    simple classes. Let''s start with mocking `WorkoutHistoryTracker`. To do that,
    add the following class just after the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to mock the entire `WorkoutHistoryTracker` class but only the
    methods that `WorkoutRunner` will be calling. In this case, those methods are
    `startTracking()`, `endTracking()`, and `exerciseComplete()`. We have made these
    methods empty because we do not need anything returned from them in order to test
    `WorkoutRunner`. Now we can inject this dummy implementation into `WorkoutRunner` wherever
    it is looking for `WorkoutHistoryTracker`.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies - workout service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0056.xhtml#aid-1LCVG2 "Chapter 5.  Supporting Server Data
    Persistence"), *Supporting Server Data Persistence*, we extended the workout service
    to make a remote call to retrieve the data that populates a workout. For unit-testing
    the workout runner, we will want to replace that call with a mock implementation
    that returns some static data that we can use to run the test. So we will add
    a third mock class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getWorkout` method is returning an `Observable`. Otherwise
    the class is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies - router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `WorkoutHistoryTracker` and `WorkoutService,` we also will be using
    mocking to handle the dependency that we have on the Angular router. But here
    we will be taking a slightly different approach. We will assign a jasmine spy
    to a navigate method on our mock. This will be sufficient for our purposes because
    we only want to make sure that the router's navigate method is being called with
    the appropriate route (`finished`) as a parameter. The jasmine spy will allow
    us to do that as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our test using TestBed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our imports and dependencies out of the way, let''s get started
    with the tests themselves. We begin by adding a Jasmine `Describe` function that
    will wrap our tests, followed by setting two local variable using `let`: one for
    `fixture` and the other for `runner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll add a `beforeEach` function that sets up our test configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` method executes before each test, which means that we will
    only have to set this up once in our test file. Inside `beforeEach`, we add an
    `async` call. This is required because of the asynchronous `compileComponents`
    method we are calling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Angular documentation indicates that the `async` function *arranges for
    the tester's code to run in a special `async` test zone that hides the mechanics
    of asynchronous execution, just as it does when passed to an `it` test*. For more
    information refer to [https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each](http://bit.ly/2etY1me).
    We'll discuss this in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each method call in the order they are executed. The first
    method, `configureTestingModule`, allows us to build on the base configuration
    of the testing module and add things such as imports, declarations (of the components,
    directives, and pipes we will be using in our test), and providers. In the case
    of our test, we are first adding declarations for the workout runner, our component
    under test, and the `SecondsToTimePipe:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then we add three providers for our `Router`, `WorkoutHistoryTracker,` and `WorkoutService:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For each of these providers, we set the `useClass` property to our mocks instead
    of the actual components. Now, anywhere in our test, when the `WorkoutRunner`
    requires any of these components, the mock will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next configuration may seem a bit mysterious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This setting allows us to bypass the errors we would otherwise get regarding
    the custom elements associated with two components that we are using in the component's
    template: `ExerciseDescriptionComponent` and `VideoPlayerComponent`. At this point,
    we don't want to be testing these components within the test for the `WorkoutRunnerComponent`.
    Instead, we should be testing them separately. One thing to be aware of, however,
    when you use this setting is that it will suppress all schema errors related to
    elements and attributes in the template of the component under test; so it may
    hide other errors that you do want to see.
  prefs: []
  type: TYPE_NORMAL
- en: When you set up a test using `NO_ERRORS_SCHEMA`, you are creating what is called
    a shallow test, one that does not go deeper than the component you are testing.
    Shallow tests allow you to reduce complexities in the templates within the component
    you are testing and reduce the need for mocking dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final steps in the configuration of our test are to compile and instantiate
    our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we are using an `async` function in our `beforeEach`
    method because this is required when we call the `compileComponents` method. This
    method call is asynchronous and we need to use it here because our component has
    an external template that is specified in a `templateUrl`. This method compiles
    that external template and then inlines it so that it can be used by the `createComponent`
    method (which is synchronous) to create our component fixture. This component
    fixture in turn contains a `componentInstance`-`WorkoutRunner`. We then assign
    both the `fixture` and the `componentInstance` to local variables.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the `async` function we are using creates a special
    `async` test zone in which our tests will run. You'll notice that this function
    is simplified from normal `async` programming and lets us do things such as using
    the `.then` operator without returning a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also compile and instantiate test components inside individual test
    methods. But the `beforeEach` method allows us to do it once for all our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured our test, let's move on to unit-testing `WorkoutRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from the loading of workout data to transitioning of exercises, pausing
    workouts, and running exercise videos, there are number of aspects of the `WorkoutRunner`
    that we can test. The `workout.spec.ts` file (available in the `components/workout-runner`
    folder under `trainer/src`) contains a number of unit tests that cover the preceding
    scenarios. We will pick up some of those tests and work through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s add a test case that verifies that the workout starts
    running once the component is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This test asserts that the total duration of the workout is correct and the
    workout is in the running state (that is, not paused).
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the `autoWatch` property of `karma.conf.js` is true, saving this
    test automatically triggers the test execution. But this test fails (check the
    Karma console). Strange! All the dependencies have been set up correctly but still
    the second expect function of the `it` block fails as it is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: We need to debug this test.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma is easy as the tests are run in the browser. We
    debug tests as we debug the standard JavaScript code. And since our Karma configuration
    has added mappings from our TypeScript files to our JavaScript files, we can debug
    directly in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: When Karma starts, it opens a specific browser window to run the tests. To debug
    any test in Karma, we just need to click on the **Debug** button available at
    the top of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one window opened by Karma and one when we click on **Debug**; we can
    use the original window too for testing, but the original window is connected
    to Karma and does a live reload. Also, the script files in the original window
    are timestamped, which changes whenever we update the test and hence requires
    us to put in a breakpoint again to test.
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on **Debug**, a new tab/window opens with all the tests and other
    app scripts loaded for testing. These are scripts that were defined during the
    Karma configuration setup in the `karma.conf.js` files section.
  prefs: []
  type: TYPE_NORMAL
- en: To debug the preceding failure, we need to add breakpoints at two locations.
    One should be added inside the test itself and the second one inside `Workoutcomponent`,
    where it loads the workout and assigns the data to the appropriate local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a breakpoint in Google Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Karma debug window/tab by clicking on the **Debug** button on the window
    loaded by Karma when it started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **F12** key to open the developer console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Sources** tab and the TypeScript files for your application will
    be located in the `source` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now put breakpoints at the required locations just by clicking on the
    line number. This is the standard mechanism to debug any script. Add breakpoints
    at the locations highlighted here:![Debugging unit tests in Karma](../Images/image00407.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We refresh the **Debug** page (the one we opened when we clicked on the **Debug**
    button). The breakpoint in `workout-runner.ts` is never hit, causing the test
    to fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we overlooked is that the code that we were trying to reach is within
    the `start` method of `workout-runner`, and the `start` method is not being called
    in the constructor. Instead it is called in `ngDoCheck` after the data for the
    workout has been loaded through a call to the `getWorkout` method in `ngOnInit`.
    Add calls to `ngOnInit` and `ngDoCheck` in your test, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Save the change and Karma will run the test again. This time it will pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the number of tests grows, unit testing may require us to concentrate on
    a specific test or a specific suite of tests. Karma allows us to target one or
    more tests by prepending `f` to the existing `it` block; that is, `it` becomes
    `fit`. If Karma finds tests with `fit`, it only executes those tests. Similarly,
    a specific test suite can be targeted by prepending `f` to the existing `describe`
    block: `fdescribe`. Also, if you prepend `x` to an `it` block, making it `xit`,
    then that block will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue unit-testing the component!
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing WorkoutRunner continued...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What other interesting things can we test? We can test whether the first exercise
    has started. We add this test to `workout.spec.ts` after the one we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `expect` function in this test is interesting. It uses a Jasmine
    feature: spies. Spies can be used to verify method invocations and dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify method invocations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A spy is an object that intercepts every call to the function it is spying on.
    Once the call is intercepted, it can either return fixed data or pass the call
    to the actual function being invoked. It also records the call invocation details
    that can be used later in `expect` as we did in the preceding test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spies are very powerful and can be used in a number of ways during unit testing.
    Look at the documentation on spies at [http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)
    to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: The second `expect` function verifies that the `startExercise` method was called
    when the workout started (`toHaveBeenCalledWith`). It is also asserting the correctness
    of the parameters passed to the function. The second `expect` statement asserts
    the behavior using a spy, but we first need to set up the spy to make this assert
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the spy to mock a call to the `startExercise` method.
    We can use the spy to determine whether the method has been called and with what
    parameters, using Jasmine's `toHaveBeenCalledWith` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the Jasmine documentation for the `toHaveBeenCalled` and `toHaveBeenCalledWith`
    functions to learn more about these assert functions.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the method is being called with the current `Exercise` as a parameter.
    Since the previous `expect` confirms that this is the first exercise, this `expect`
    confirms that a call to start that first exercise was executed.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to note here. First, you have to be careful to
    put the setup for `spyOn` prior to calling `ngOnInit`. Otherwise, the spy will
    not be *spying* when the `startExercise` method is called and the method invocation
    will not be captured.
  prefs: []
  type: TYPE_NORMAL
- en: Second, since the spy is a mock, we will normally not be able to verify anything
    within the `startExercise` method. This is because the method itself is being
    mocked. This means that we cannot actually verify that the `currentExercise` property
    has been set, since that is being done inside the mocked method. However, Jasmine
    allows us to chain the spy with .`and.callThrough`, which will mean that in addition
    to tracking the calls to the method, it will delegate to the actual implementation.
    This then allows us to test that the `currentExercise` has also been set correctly
    inside the `startExercise` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we just used a spy to verify the call to a method within our class, Jasmine
    spies are also useful in mocking calls to external dependencies. But why test
    calls to our external dependencies at all? After all, we are trying to limit our
    testing to the component itself!
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we mock a dependency to make sure that the dependency does
    not adversely affect the component under test. From a unit testing perspective,
    we still need to make sure that these dependencies are called by the component
    being tested at the right time with the correct input. In the Jasmine world, spies
    help us assert whether dependencies were invoked correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the `WorkoutRunner` implementation, we emit a message with the
    details of the workout whenever the workout starts. An external dependency, `WorkoutHistoryTracker`,
    subscribes to this message/event. So let's create a spy and confirm that `WorkoutHistoryTracker`
    started when the workout started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this `it` block after the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Within the `it` block, we add a spy on the `tracker`, a local instance of the
    `WorkoutHistoryTracker`. Then we use the spy to verify that the `startTracking`
    method of that dependency has been called. Simple and expressive!
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that we are using `MockHistoryWorkoutTracker` here; it contains
    a mock, a `startTracking` method that is empty and returns nothing. That is fine
    because we are not testing the `WorkoutHistoryTracker` itself but just the method
    invocation on it being made by the `WorkoutRunner`. This test shows how useful
    it is to be able to combine mocks with spies to fully test the inner workings
    of the `WorkoutRunner`, separately and apart from its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing event emitters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Examining the code for the `WorkoutRunner`, we see that it sets up several
    event emitters that look like the following one for `workoutStarted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The Angular documentation describes an event emitter as *an output property
    that fires events to which we can subscribe with an event binding*. In [Chapter
    2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2.  Building
    Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute Workout*,
    we described in detail how event emitters are used in WorkoutRunner. So we have
    a good understanding of what they do. But how do we unit-test our event emitters
    and determine that they are firing events in the way we expect?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually pretty easy to do. If we remember that an event emitter is an
    `Observable Subject` to which we can subscribe, we realize that we can simply
    subscribe to it in our unit test. Let''s revisit our test that verifies that a
    workout is starting and add the highlighted code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We injected the `WorkoutService` and added a subscription to the `WorkoutStarted`
    event emitter and an expectation that checks to see whether the property is emitting
    a `WorkoutPlan` when the event is triggered. The subscription is placed before
    `ngOnInit` because that is the method that results in the `workoutStarted` event
    being triggered, and we need to have our subscription in place before that happens.
  prefs: []
  type: TYPE_NORMAL
- en: Testing interval and timeout implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the interesting challenges for us is to verify that the workout progresses
    as time elapses. The `Workout` component uses `setInterval` to move things forward
    with time. How can we simulate time without actually waiting?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the Angular testing library's `fakeAsync` function, which allows
    us to run otherwise asynchronous code synchronously. It does this by wrapping
    the function to be executed in a `fakeAsync` zone. It then supports using synchronous
    timers within that zone and also allows us to simulate the asynchronous passage
    of time with `tick()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about `fakeAsync`, see the Angular documentation at [https://angular.io/docs/ts/latest/guide/testing.html#!#async](http://bit.ly/2eFYf7g),
    under the heading *The fakeAsync function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the `fakeAsync` function to test the timeout and
    interval implementations in our code. Add the following test to `workout-runner.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In addition to injecting `WorkoutRunner`, we first wrap the test in `fakeAsync`.
    Then we add a call to the `WorkoutRunner`'s `ngOnit()` method. This kicks off
    the timers for the exercises within `WorkoutRunner`. Then within the test, we
    use the `tick()` function set at various durations to test the operation of the
    timer for an exercise, and make sure that it continues running for the duration
    that we expected it to run. Using `tick()` allows us to *fast forward* through
    the code and avoid having to wait for the exercise to complete over several seconds
    as it would if we ran the code asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll notice that there is a helper method, `advanceWorkout`, being used here.
    This takes care of an anomaly that seemed to exist if the parameter passed to
    tick was anything other than `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we call the `WorkoutRunner`'s `ngOnDestroy()` method to clear any
    pending timers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another similar test. We want to make sure that the WorkoutRunner
    is correctly transitioning from one exercise to the next. Add the following test
    to `workout-runner.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again we wrap the test in `fakeAsync` and call `runner.ngOnInit` to start the
    timer. Then we grab the duration of the first exercise and use the `tick()` function
    to advance the timer 1 second beyond the duration of that exercise. Next, we test
    the expectation that we are now in the rest exercise and thus have transitioned
    from the first exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Testing workout pause and resume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we pause a workout, it should stop and the time counter should not lapse.
    To check this, add the following time test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The test starts with verifying the state of the workout as not paused, advances
    the time for 1 second, pauses it, and then verifies that the time of `workoutTimeRemaining`
    does not change after the pause.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing of services is not much different from unit-testing components.
    Once we get the hang of how to set up a component and its dependencies (mostly
    using mocks), it becomes a routine affair to apply that learning to testing services.
    More often than not, the challenge is to set up the dependencies for the services
    so that testing can be done effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Things are a little different for services that make remote requests (using
    either `http` or `jsonp`). There is some setup required before we can test such
    services in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: We will target `WorkoutService` and write some unit tests for it. Since this
    service makes remote requests to load workout data, we will explore how to test
    such a service with a mock HTTP backend. Angular provides us with a `MockBackend`
    and `MockConnection` for doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP request/response with MockBackend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When testing services (or, as a matter of fact, any other Angular construct)
    that make remote requests, we obviously do not want to make actual requests to
    a backend to check the behavior. That does not even qualify for a unit test. The
    backend interaction just needs to be mocked away. Angular provides a service for
    precisely that: `MockBackend`! Using `MockBackend`, we intercept HTTP requests,
    mock actual responses from the server, and assert endpoints invocation too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `workout-service.spec.ts` and add the following import
    statements at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the imports from the `testing` module, we are importing both
    the `http` module and the `MockBackend` and `MockConnection` from the `http/testing` module.
    We are also importing the `WorkoutService` and `WorkoutPlan` that we will be testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the imports in place, we will begin creating the test with the
    Jasmine `describe` statement that wraps our tests, and will set several local
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In addition to creating local variables for `WorkoutService` and `MockBackend`,
    you'll also notice that we are setting local variables for our Mongo connection.
    To be clear, we are not setting these variables in order to make a remote call
    to Mongo but instead to test that the connection properties are being set properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is set up the providers and dependency injection for our tests.
    To handle the providers, add the following to the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Not surprisingly, we are adding `MockBackEnd` and `WorkoutService` as providers.
    At the same time, we are also adding `BaseRequestOptions` from the http module.
    And then we are adding a provider for HTTP that uses a factory with the `MockEnd`
    and `BaseRequestOptions`. This factory will then return an `Http` service that
    is using the `MockBackend`. So now we can make an HTTP call from our tests that
    will not be a remote call, but instead will use the `MockBackEnd` to fake that
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the setup for our tests, we add the following to inject dependencies
    into each of our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup in place, we are now in a position to create tests for the
    workout-service that avoid our making a remote call. We''ll start with a simple
    test that makes sure that the `workoutService` loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: While this test may seem trivial, it is important to place it here because it
    acts as a check to make sure that we have set up our configuration correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll move to testing several of the methods in the workout-service.
    First, we will make sure that it returns all workouts when the get Workouts method
    is called. To do that, add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using `fakeAsync` to synchronously run what would otherwise
    be an asynchronous HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there would be a problem with this approach if we were making a true
    HTTP call using XHR. See [https://github.com/angular/angular/issues/8280](https://github.com/angular/angular/issues/8280).
    But here, we are not making a real XHR call in our mock.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Http` module returns `RxJS` observables, we are also using the
    pattern of subscribing to those observables. You should be used to seeing this
    pattern from our coverage of observables in [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*.
    Specifically, we are subscribing to the `connections` property of the `mockBackEnd` and
    passing in a `MockConnection` as our connection. After confirming that our connection
    has been set properly, we construct a `response` containing two `workouts`. Then
    we call the `mockRespond` method on our `connection` and return the `response`
    that we have constructed. The net result is that we have been able to construct
    a testable response for our service that avoids making a remote call.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the process is to set the workout's `getWorkouts` method to
    subscribe to that `response`, and then add the appropriate `expect` statements
    to confirm that we are getting back the correct number of `workouts` in the `response`
    and that the first `workout` is of type `WorkoutPlan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll follow the same pattern of using `fakeAsync` with our `mockBackend`
    to build additional tests that confirm that we are able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a `workout` plan with a specific name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map `exercises` correctly within the `getWorkout` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can review these tests in the code for checkpoint 7.1\. But one thing to
    note is that in both these tests we have the following conditional logic within
    the `connections.subscribe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem a little confusing at first until we realize that with the `getWorkout`
    method we are actually making two `Http` calls: one to retrieve  `workout` and
    one to retrieve all  `exercises`. As you recall from [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*,
    we are doing that in order to create a fuller description of each `exercise` that
    is included within  `workout`. So what we are doing here is checking to make sure
    that we construct a `response` made up of a `workout` for the call that is retrieving
    a `workout` and a `response` made up of an `exercise` for the other call.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are finished with testing our service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to learn how to test directives. The next section is dedicated
    to understanding the challenges in directive testing and how to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No other Angular constructs that we have tested so far do not involve any UI
    interaction. But directives, as we know, are a different beast. Directives are
    all about enhancing a component's view and extending the behavior of HTML elements.
    While testing directives, we cannot ignore the UI connections, and hence directive
    testing may not strictly qualify as unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing about directive testing is that its setup process is not as
    elaborate as that for services or components. The pattern to follow while unit-testing
    directives is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take an HTML fragment containing the directive markup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and link it to a mock component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the generated HTML has the required attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the changes if the directive created changes the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TestBed class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, Angular provides the `TestBed` class to facilitate
    this kind of UI testing. We can use it to dig into the markup in a component's
    view and check for DOM changes that are triggered by events. Armed with this tool,
    let's get started with the testing of our directives. In this section, we are
    going to test `remoteValidator`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will be a good time to revisit the directives that we built in the previous
    chapter. Also, keep the code handy for the tests we will create in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Testing remote validator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with unit-testing the `remoteValidatorDirective`. Just to refresh
    our memory, `remoteValidatorDirective` validates an input against remote rules.
    It does so by calling a component method that returns a promise. If the promise
    is resolved with success, the validation passes; otherwise, the validation fails.
    The `[validateFunction]` attribute provides the link between the DOM and the component's
    method that checks for the duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our other test files, we add a `remote-validator.directive.spec.ts`
    file in the workout builder folder. Refer to the file in checkpoint 7.1 for the
    imports, which we will not cover at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the import statements, add the following component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This component looks a lot like the components we set up in our other tests
    to mock dependencies. Here, however, it is serving a slightly different purpose;
    it is acting as a host container for the directive that we will be testing. Using
    this minimal component, lets us avoid having to load the actual host for this
    directive, which is the `Workout` component.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice here is that we have set up a method for `validateWorkoutName`
    that will be called by our directive. It is essentially a stub that just returns
    a resolved `Promise` of `false`. Remember we are not concerned with how this method
    handles its validation but with verifying that the directive calls it and returns
    the correct result, either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up the describe statement for our test suite by adding the following
    code, which injects  `RemoteValidatorDirective` into our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting up local variables for  `fixture`, its `componentInstance`,
    and `debugElement`. We are also using `by.css` (which we will see more of in our
    end-to-end tests) along with the query method on  `debugElement` to extract the
    `workoutName` input from our component. We'll be using these to delve into the
    rendered HTML in our directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to write our individual tests. First, we''ll write a test
    to confirm that we have been able to load  `RemoteValidatorDirective`. So add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s interesting about this test is that using the `debugElement`, we have
    been able to drill-down into the attributes of the input tag in our host component
    and find our validator, confirming that it has indeed been loaded. Also notice
    the use of `fakeAsync`, which we discussed in connection with unit testing. Using
    it makes it possible for us to write our tests in a synchronous fashion and avoid
    the complications that would otherwise exist with trying to manage the asynchronous
    rendering of our host component. Next, we''ll write two tests to confirm that
    our validator is working properly. The first test will make sure that an error
    is created if remote validation fails (that is, a workout with the same name as
    the one we are using is found). Add the following code for that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we are using `fakeAsync` to eliminate the challenges we would otherwise
    have with the async behavior associated with the rendering and execution of our
    `remoteValidatorDirective`. Next, we add a spy to track the invocation of the
    `validateWorkoutName` method. We also set the spy to call through to our method
    because in this case, we are expecting it to return false. The spy is being used
    to verify that our method has indeed been invoked. Next, we set `fixture.detectChanges`,
    which triggers a change detection cycle. We then set the value of our input and
    call tick, which will, we hope, trigger the response we are expecting from our
    remote validator. We then grab the form encapsulating our input tag using the
    injector that is available from the child element array of the debug element.
    From there, we extract the form control for our input box. Then we run several
    expectations that confirm that an error has been added both to our control and
    to the form and that both are now in an invalid state. The next test is the mirror
    opposite of this test and checks for a positive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Other than changing the expectations, the only change we are making from the
    previous test is setting up our spy to return a value of true. Unit-testing our
    `remoteValidatorDirective` shows how powerful the `TestBed` utilities are in testing
    our UI and the elements and behaviors associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated **E2E** testing is an invaluable asset if the underlying framework
    supports it. As the size of an app grows, automated E2E testing can save a lot
    of manual effort.
  prefs: []
  type: TYPE_NORMAL
- en: Without automation, it's just a never-ending battle to make sure that the app
    is functional. However, remember that in an E2E setup, not everything can be automated;
    automation may require a lot of effort. With due diligence, we can offload a sizable
    amount of manual effort but not everything.
  prefs: []
  type: TYPE_NORMAL
- en: The process of E2E testing of a web-based application is about running the application
    in a real browser and asserting the behavior of the application based on the user
    interface state. This is how an actual user does testing.
  prefs: []
  type: TYPE_NORMAL
- en: Browser automation holds the key here, and modern browsers have become smarter
    and more capable in terms of supporting automation. Selenium tools for browser
    automation are the most popular option out there. Selenium has the WebDriver ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/))
    API that allows us to control the browser through the automation API that modern
    browsers natively support.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind bringing up Selenium WebDriver is that the Angular E2E testing
    framework/runner **Protractor** also uses **WebDriverJS**, which is a JavaScript
    binding of WebDriver on Node. These language bindings (like the preceding JavaScript
    binding) allow us to use the automation API in the language of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss Protractor before we start writing some integration tests for
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Introducting Protractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protractor is the de facto test runner for E2E testing in Angular. Protractor
    uses Selenium WebDriver to control a browser and simulate user actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor supersedes an earlier E2E framework known as **AngularJS Scenario
    Runner**. Karma had a plugin that allowed Karma to execute E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Protractor setup has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A test runner (Protractor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Selenium server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We write our test in Jasmine and use some objects exposed by Protractors (which
    is a wrapper over WebDriverJS) to control the browser.
  prefs: []
  type: TYPE_NORMAL
- en: When these tests run, Protractor sends commands to the Selenium server. This
    interaction happens mostly over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium server, in turn, communicates with the browser using the *WebDriver
    Wire Protocol*, and internally the browser interprets the action commands using
    the browser driver (such as *ChromeDriver* in the case of Chrome).
  prefs: []
  type: TYPE_NORMAL
- en: It is not that important to understand the technicalities of this communication,
    but we should be aware of the E2E testing setup. Check out the article from the
    Protractor documentation at [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    to learn more about this flow.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to realize when using Protractor is that the overall
    interaction with the browser or the browser control flow is asynchronous in nature
    and promise-based. Any HTML element action, whether `sendKeys`, `getText`, `click`,
    `submit`, or any other, does not execute at the time of invocation; instead the
    action is queued up in a control flow queue. For this precise reason, the return
    value of every action statement is a promise that gets resolved when the action
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this *asynchronicity* in Jasmine tests, Protractor patches Jasmine,
    and therefore assertions like these work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: They work despite the `getText` function returning a promise and not the element
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, Protractor supports Jasmine version 2.5.2.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how Protractor works, let's set up Protractor
    for end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Protractor for E2E testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Protractor globally, run this command in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs two command-line tools: Protractor and webdriver-manager. Run
    the following command to make sure that Protractor is set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All E2E tests have been verified against Protractor 4.0.9.web.
  prefs: []
  type: TYPE_NORMAL
- en: 'webdriver-manager is a helper tool to easily get an instance of a running Selenium
    server. Before we start the Selenium server, we need to update the driver binaries
    with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run this command to start the Selenium server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor tests send requests to this server to control a local browser. E2E
    testing can be verified by checking the status of the server at `http://localhost:4444/wd/hub`
    (the default location).
  prefs: []
  type: TYPE_NORMAL
- en: Protractor also needs to be configured, like Karma, and has a configuration
    file. We copy the `protractor.config.js` file from the `tests` folder under `chapter7/
    checkpoint1/` to our local `tests` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Protractor configuration file we just added contains four settings that
    we want to make sure are configured according to our local app setup, and these
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Specs` | The location of the specification files (the E2E test files). The
    current assigned value `[''e2e/*.js'']` should work. |'
  prefs: []
  type: TYPE_TB
- en: '| `baseUrl` | The base URL where the app is running. Change the server name
    and port to match your local setup. Navigate to the URL to make sure that the
    app is running. |'
  prefs: []
  type: TYPE_TB
- en: '| `seleniumAddress` | The base URL where the Selenium server is running. Unless
    you have reconfigured the Selenium server settings, the default value should work.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `useAllAngular2AppRoots` | Set this to `true`. This lets Protractor know
    that we are no longer using earlier versions of Angular. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The configuration file documentation on the Protractor website ([https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts))
    contains details on other supported configurations.
  prefs: []
  type: TYPE_NORMAL
- en: That is enough to start testing with Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the other examples in this book, we will be writing our tests in
    TypeScript. This requires a couple more configuration steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the `tsconfig.json` file from checkpoint 7.1 into the `trainer`
    folder. You''ll notice that this file now has some additional global dependencies
    for WebDriver and angular-protractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, from the command line in the `trainer` folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will install the type definitions for Protractor and web driver that we
    will be using when in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's begin writing and executing some tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests for the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start in a simple manner and test our app start page (**#/start**). This
    page has some static content, a workout listing section with search capabilities,
    and the ability to start a workout by clicking on any workout tile.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All our E2E tests will be added to the `e2e` folder under `tests`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file called `workout-runner.spec.ts` to the `e2e` folder under `tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file add the following reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings in the type definitions we just installed. Next add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are writing this test in TypeScript, we have to introduce a transpilation
    step here. Therefore, in a new command window, navigate to the to the `e2e` folder
    under `tests` and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `-w` switch means that TypeScript will recompile the tests in this file
    as we change them. So we will not need to run this command again.
  prefs: []
  type: TYPE_NORMAL
- en: Executing our E2E tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we execute our first test, we have to make sure that the Selenium server
    is running (`webdriver-manager start`) and the app is running (run `gulp play`
    from the command line in the `trainer` folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now from the command line in the `trainer` folder, run the following and see
    the browser dance to your tune:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Protractor will open the browser. It will then navigate to the start page; wait
    for the page, the scripts, and the framework to load; and then perform the test.
    It finally logs the results of the test in the console. That is pretty awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through this simple test.
  prefs: []
  type: TYPE_NORMAL
- en: The first interesting piece is inside the `beforeEach` block. The browser object
    is a global object exposed by Protractor and is used to control the browser-level
    actions. Underneath, it is just a wrapper around WebDriver. The `browser.get(`""`)`
    method navigates the browser to start the app page, every time, before the start
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: The actual test verifies that the title of the page is correct. It also checks
    whether some random content is present on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding test employs two new globals, `element` and `by`, that are made
    available by Protractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: This function returns an `ElementFinder` object. The primary job
    of `ElementFinder` is to interact with the selected element. We will be using
    the `element` function to select `ElementFinder` extensively in our tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the documentation at [http://www.protractortest.org/#/locators#actions](http://bit.ly/2ekp2VQ)
    to learn more about element manipulation API support. Functions such as `getText()`
    are actually defined on `WebElement` but are always accessed using `ElementFinder`.
    As the documentation suggests, `ElementFinder` can be treated as `WebElement`
    for most purposes. For more information, you can refer to [http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements](http://bit.ly/2fnOzhC).
  prefs: []
  type: TYPE_NORMAL
- en: '`by`: This object is there to locate elements. It has functions that create
    `locators`. In the preceding test, a locator is created to search for elements
    with `id=start`. There are a number of locators that can be used to search for
    a specific element. These include by class, by ID, and by css. (At this time by
    model and by binding are not yet supported.) Refer to the Protractor documentation
    on locators at [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    to learn about the supported locators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to reiterate what we discussed earlier, `getTitle()` and `getText()` in
    the preceding test do not return the actual text but a Promise; we can still assert
    on the text value.
  prefs: []
  type: TYPE_NORMAL
- en: This simple test highlights another salient feature of Protractor. It automatically
    detects when the Angular app is loaded and when data is available for testing.
    There are no ugly hacks to delay testing (using `timeouts`) that may otherwise
    be required in standard E2E testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this is an *SPA*; full-page browser refresh does not happen, so it
    is not that simple to determine when the page is loaded and when the data that
    is rendered for AJAX calls is available. Protractor makes it all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor may still timeout while trying to assess whether the page is available
    for testing. If you are hitting timeout errors with Protractor, this article from
    the Protractor documentation can be really helpful ([http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts))
    for debugging such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing is a challenge, irrespective of the
    E2E framework we employ for testing. The ultimate aim is to assert the behavior
    of an application against some data, and unless the data is fixed, we cannot verify
    the behavior that involves getting or setting data.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to setting up data for E2E tests is to create a test data store
    specifically for E2E tests with some seed data. Once the E2E tests are over, the
    data store can be reset to its original state for future testing. For *Personal
    Trainer*, we can create a new database in MongoLab dedicated exclusively to E2E
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem a lot of effort, but it is necessary. Who said E2E testing is
    easy! In fact, this challenge is there even if we do manual testing. For a real
    app, we always have to set up data stores/databases for every environment, whether *dev*,
    *test*, or *production*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will continue to use our existing backend but go ahead and
    add another workout that we will use for testing. Name this workout `1minworkout`
    and give it a title of `1 Minute Workout`. Add two exercises to the workout: Jumping
    Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest
    time to 1 second.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have deliberately kept our new workout short so that we can complete our
    end-to-end testing of this workout within the normal timeouts provided by Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: More E2E tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get back to testing the workout search features on the start page. With
    the addition of 1 Minute Workout, we now have two workouts and we can assert search
    behaviors against these.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have added other workouts to the backend, just adjust the numbers in
    this test accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this test after the existing test in `workout-runner.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The test uses `ElementFinder` and `Locator API` to look for elements on the
    page. Check the second line of the test. We are using the `element.all` function
    together with the `by.css` locator to do a multi-element match on all elements
    on the screen that are using the `.workout.tile` CSS class. This gives us a list
    of workouts against which the next line asserts the element count of 3.
  prefs: []
  type: TYPE_NORMAL
- en: The test then gets hold of the search input using the `element` function along
    with the `by.css` locator to do a single element match for an element using the
    `.form-contol` CSS class. We then use the `sendKeys` function to simulate data
    entry in the search input.
  prefs: []
  type: TYPE_NORMAL
- en: The last two expect operations check for the count of elements in our list,
    which after the search should be 1\. Also, they check whether the correct workout
    is filtered based on a div tag using the `title` CSS class that is a child of
    the element that contains our workout. This last expect statement highlights how
    we can chain element filtering and get hold of child elements in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more test associated with the start page that we should add. It
    tests the navigation from the start page to the workout runner screen. Add this
    code for that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This test uses the `click` function to simulate clicking on a workout tile,
    and then we use the `browser.getCurrentUrl` function to confirm that the navigation
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Run the test again (`protractor tests/protractor.conf.js`) and once again observe
    the magic of browser automation as the tests run one after another.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate E2E testing for *Workout Runner*? Well, we can try.
  prefs: []
  type: TYPE_NORMAL
- en: Testing WorkoutRunner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the major challenges with testing WorkoutRunner is that everything is
    time-dependent. With unit testing, at least we were able to mock the interval,
    but not anymore. Testing exercise transitions and workout completion is definitely
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we tackle this problem or try to find an acceptable workaround,
    let''s digress and learn about an important technique to manage E2E testing: page
    objects!'
  prefs: []
  type: TYPE_NORMAL
- en: Using page objects to manage E2E testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of page objects is simple. We encapsulate the representation of
    page elements into an object so that we do not have to litter our E2E test code
    with `ElementFinder` and `locators`. If any page element moves, we just need to
    fix the page object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can represent our Workout Runner page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This page object now encapsulates many of the elements that we want to test.
    By organizing the element selection code in one place, we increase the readability
    and hence the maintainability of E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the Workout Runner page object to the top of the test file. We''ll
    use it in a test for the workout runner. Add the following new describe block
    containing the first of our workout runner tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The test verifies that the workout is loaded and the correct data is shown.
    We make full use of the page object that we defined earlier. Run the test and
    verify that it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to the challenge of testing code based on `interval` or `timeout`.
    First, we''ll add a test that confirms a click event on the screen, when the pause
    button is pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting here is that we use the `browser.sleep` function within
    a promise to verify that the exercise time remaining is the same before and after
    the button is clicked. We are again using our `WorkoutRunner` page object to make
    the test more readable and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following test to the current test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This test checks whether the exercise transition happened. It does so by adding
    a `browser.sleep` function for 15 seconds and then checking from the UI state
    whether the exercise-related content of `Rest` is visible. The problem with this
    test is that it is not very accurate. It can confirm that the transition is happening
    but cannot confirm that it happened at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: A plausible explanation for this behavior is in the way Protractor works. Before
    Protractor can start a test, it first waits for the page to load. If the test
    involves any action (such as `getText`), it again waits till Angular synchronizes
    the page. During page synchronization, Angular waits for any pending HTTP requests
    or any timeout-based operations to complete before it starts the test. As a result,
    when the `browser. sleep` function is invoked and when the browser actually goes
    to sleep cannot be predicted with great accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can disable this synchronization behavior by setting `browser. ignoreSynchronization`
    to `true`, but we should avoid this as much as possible. If we set it to `true`,
    the onus is on us to determine when the page content is available for making assertions.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the *Workout Runner* app workflow is indeed difficult
    to test. Compared to *Workflow Runner*, other things are far easier to test as
    we saw with the start page testing.
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter and summarize our learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not need to reiterate how important unit- and E2E-testing are for any
    application. The way the Angular framework has been designed makes testing the
    Angular app easy. In this chapter, we covered how to write unit tests and E2E
    tests using libraries and frameworks that target Angular.
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing, we used Jasmine to write our tests and Karma to execute them.
    We tested a number of filters, components, services, and directives from *Personal
    Trainer*. In the process, you learned about the challenges and the techniques
    used to effectively test these types.
  prefs: []
  type: TYPE_NORMAL
- en: For E2E testing, the framework of choice was Protractor. We still wrote out
    tests in Jasmine but the test runner this time was Protractor. You learned how
    Protractor automates E2E testing using Selenium WebDriver, as we did some scenario
    testing for the *Start* and *Workout Runner* pages.
  prefs: []
  type: TYPE_NORMAL
- en: If you have reached this point, you are getting closer to becoming a proficient
    Angular developer. The next chapter reinforces this with more practical scenarios
    and implementations built using Angular. We will touch upon important concepts
    in the last chapter of this book; these include multilingual support, authentication
    and authorization, communication patterns, performance optimizations, and a few
    others. You certainly do not want to miss them!
  prefs: []
  type: TYPE_NORMAL
