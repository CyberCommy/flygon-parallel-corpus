- en: Layer 2 Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: ARP Watcher
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP cache poisoning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC flooder
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VLAN hopping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP spoofing over VLAN hopping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP starvation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layer 2 is the data link layer responsible for addressing packets in an Ethernet
    with MAC addresses. Layer 2 is used to transfer data between adjacent network
    nodes in a wide area network, or between nodes on the same LAN. In this chapter,
    we will go through some of the common attacks at the second layer of TCP/IP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: ARP Watcher
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With **Address Resolution Protocol** (**ARP**), we can find live internal hosts.
    We can write a script to scan for hosts in a given network with Scapy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write a ARP Watcher with the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Create an `arp-scanner.py` file and open it in your editor.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then have to import the required modules:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now declare the variables for the script:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can send ARP packets to all the IPs in the IP range, and get answered
    and unanswered packets.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the ARP packet as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The structure of the packet will be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Then, send the packet with `srp()` and receive the response:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, iterate through all the answered packets and print their MAC and IPs:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, run the script with required permission:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print the MAC and IPs of all active systems in the network range
    provided. Output will be as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Now we can convert this to an ARP monitor, that has the ability to monitor the
    network for changes. For that, create another `arp-monitor.py` file and import
    the `scapy` module.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a function to parse the packets and sniff the interface:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, start sniffing and call the `parsePacket()` method to parse the ARP packets:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the script with required permission to start the monitoring:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ARP cache poisoning
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, systems on a TCP/IP LAN identify and communicate with each other
    via the MAC addresses of their network adapters. Each system keeps a list of systems
    and their MAC addresses for reference, known as the ARP cache. If possible, we
    need to spoof the cache of a machine with a wrong MAC address for another machine.
    All communication to that machine with the spoofed MAC address from the machine
    will be directed to the attached machine. So, ARP cache poisoning is the method
    of tricking a machine to save the wrong data about an IP address in its ARP table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are performing a type of man-in-the-middle attack (getting the data from
    another device connected to the same network), we have to turn on the IP forwarding
    to make sure that the connection on the victim's machine is not affected or interrupted.
    For performing IP forwarding, we have different methods for Linux and macOS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can check the status of IP forwarding by checking the content in the following
    file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the output is `1`, IP forwarding is enabled; and if it''s `0`, IP forwarding
    is disabled. If it''s disabled, enable it as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: macOS
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can enable IP forwarding in macOS with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Disable it with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a script to poison ARP cache in a victim system:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `arp-cache-poisoning.py` file and open in your editor.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `scapy` module:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare the variables. We could also get these from arguments, or as: `raw_input()`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now define a function to get the MAC IDs from the IP provided:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now get the MAC address of the target and gateway with the `getMac()` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the function to poison the ARP cache of the target:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are sending two types of packets--one to the target machine, and one
    to the gateway. The first two blocks define these packets. The target packet will
    be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'The `gateway` packet will be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Now create a function to reset the poisoned cache back to the normal state:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can start sending the packets:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the script with required permission:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MAC flooder
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can fill the MAC address store of a router by sending random Ethernet traffic
    over the network. This may lead to the malfunction of the switch, and may start
    sending all the network traffic to everyone connected to the router, or it may
    fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在网络上传送随机的以太网流量来填充路由器的MAC地址存储。这可能导致交换机故障，并可能开始将所有网络流量发送给连接到路由器的所有人，或者可能失败。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to flood MAC address store in a router:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是淹没路由器MAC地址存储的步骤：
- en: Create a `mac-flooder.py` file and open in your editor.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`mac-flooder.py`文件并在您的编辑器中打开。
- en: 'Import the required modules:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the `interface` to flood. We could also get it from the arguments:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要淹没的`interface`。我们也可以从参数中获取它：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the packets with random MAC IDs and random IPs:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有随机MAC ID和随机IP的数据包：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The packet structure will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包结构将如下所示：
- en: '![](img/00057.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: 'Finally, send the packets in an infinite loop:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在无限循环中发送数据包：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now run the file with required permission:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以所需的权限运行文件：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: VLAN hopping
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VLAN跳跃
- en: 'VLAN hopping is the type of attack in which the attacker is able to send traffic
    from one VLAN into another. We can do this with two methods: double tags and switch
    spoofing.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: VLAN跳跃是一种攻击类型，攻击者能够将一个VLAN的流量发送到另一个VLAN。我们可以用两种方法实现这一点：双标签和交换机欺骗。
- en: To create a double tag attack, the attacker sends a packet with two **802.1Q**
    tags--the inner VLAN tag is the VLAN that we are planning to reach, and the outer
    layer is the current VLAN.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建双标签攻击，攻击者发送一个带有两个**802.1Q**标签的数据包--内部VLAN标签是我们计划到达的VLAN，外层是当前的VLAN。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to simulate a simple VLAN hopping attack:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟简单的VLAN跳跃攻击的步骤：
- en: Create a `vlan-hopping.py` file and open in your editor.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`vlan-hopping.py`文件并在您的编辑器中打开。
- en: 'Import the modules and set the variables:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块并设置变量：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Craft the packet with two 802.1Q tags:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个802.1Q标签制作数据包：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The packet will be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包将如下所示：
- en: '![](img/00058.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: 'Now, send these packets in an infinite loop:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在无限循环中发送这些数据包：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the script with required permission:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ARP spoofing over VLAN hopping
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP欺骗跨VLAN跳跃
- en: As VLANs limit broadcast traffic to the same VLAN, here we tag every packet
    with our VLAN tag, and an extra with the destination VLAN.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于VLAN限制广播流量到相同的VLAN，因此我们为每个数据包打上我们的VLAN标记，并额外添加目标VLAN的标记。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to simulate ARP spoofing attack over VLAN hopping:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟ARP欺骗攻击跨VLAN跳跃的步骤：
- en: Create a new `arp-spoofing-over-vlan.py` file and open in your editor.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`arp-spoofing-over-vlan.py`文件并在您的编辑器中打开。
- en: 'Import modules and set variables:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块并设置变量：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create ARP packets with two 802.1Q tags:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有两个802.1Q标签的ARP数据包：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the packet with two 802.1Q tags and an ARP layer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有两个802.1Q标签和ARP层的数据包：
- en: '![](img/00059.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: 'Send the packets in an infinite loop:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环中发送数据包：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the script with required permission:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以所需的权限运行脚本：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: DHCP starvation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DHCP饥饿
- en: DHCP is the protocol that helps to assign clients' IP addresses to the LAN.
    The process of assigning DHCP consists of four steps--DHCPDiscover, DHCPOffer,
    DHCPRequest, and DHCP ACK.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP是帮助为LAN分配客户端IP地址的协议。分配DHCP的过程包括四个步骤--DHCPDiscover、DHCPOffer、DHCPRequest和DHCP
    ACK。
- en: 'DHCPDiscover is the first step where the client broadcasts in the LAN to find
    a DHCP server that can provide an IP for the client. Then the server will respond
    with a unicast DHCPOffer, where it offers a possible IP. Then, the client will
    broadcast the DHCPRequest with the IP to all networks, and finally the server
    will respond with a DHCP ACK or DHCP NAK. ACK represents a successful DHCP process,
    while NAK represents when the IP is not available:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: DHCPDiscover是客户端在LAN中广播以查找可以为客户端提供IP的DHCP服务器的第一步。然后服务器将以单播DHCPOffer响应，其中提供可能的IP。然后，客户端将向所有网络广播DHCPRequest与IP，最后服务器将以DHCP
    ACK或DHCP NAK响应。ACK表示成功的DHCP过程，而NAK表示IP不可用：
- en: '![](img/00060.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: The DHCP server stores the IP information to MAC bindings. If we ask for too
    many IPs from the DHCP server, other legitimate clients will not get an IP to
    connect. This is known as a **DHCP starvation attack**. In this recipe, we will
    be attacking the third step of this process. After sending the DHCP request, the
    server will assign the requested IP for the client. This can be used to attack
    a specific range of IPs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP服务器将IP信息存储到MAC绑定。如果我们从DHCP服务器请求太多IP，其他合法客户端将无法获得IP连接。这被称为**DHCP饥饿攻击**。在这个示例中，我们将攻击这个过程的第三步。发送DHCP请求后，服务器将为客户端分配请求的IP。这可以用来攻击特定范围的IP。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try writing a script to starve the DHCP in the network:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个脚本来使网络中的DHCP饥饿：
- en: Create a `dhcp-starvation.py` file and open in your editor.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`dhcp-starvation.py`文件并在您的编辑器中打开。
- en: 'Import the required modules:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We require `Scapy` for crafting the packets, and a `threading` module for threaded
    execution of the script
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`Scapy`来制作数据包，并且需要`threading`模块来执行脚本的线程化
- en: 'Now, define the variables:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义变量：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can define the callback function to handle the captured DHCP packets:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义回调函数来处理捕获的DHCP数据包：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function is called to process each packet received by the sniffer
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被调用来处理嗅探器接收到的每个数据包
- en: 'Now we have to create another function to configure the sniffer. This function
    is called by the threads:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建另一个函数来配置嗅探器。这个函数被线程调用：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will start sniffing the UDP packets to the ports `67` and `68`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始嗅探到端口`67`和`68`的UDP数据包
- en: 'Now we can create a DHCPRequest packet and send it to the DHCP server that
    we are planning to starve:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个DHCPRequest数据包并将其发送到我们计划饥饿的DHCP服务器：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will first generate an IP within the specified range. Also, it will create
    a random MAC address for the packet. This will then craft a DHCPRequest packet
    with the generated IP addresses and MAC. Then, it will send the packet. The packet
    generated will be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先在指定范围内生成一个IP地址。此外，它将为数据包创建一个随机的MAC地址。然后，它将使用生成的IP地址和MAC地址来创建一个DHCP请求数据包。然后，它将发送数据包。生成的数据包将如下所示：
- en: '![](img/00061.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: 'Now we can start threads and try to occupy the IP address in the DHCP server:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动线程，尝试在DHCP服务器中占用IP地址：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, run the script with required permission.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以所需的权限运行脚本。
