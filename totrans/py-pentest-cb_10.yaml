- en: Layer 2 Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: ARP Watcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP cache poisoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC flooder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VLAN hopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP spoofing over VLAN hopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP starvation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layer 2 is the data link layer responsible for addressing packets in an Ethernet
    with MAC addresses. Layer 2 is used to transfer data between adjacent network
    nodes in a wide area network, or between nodes on the same LAN. In this chapter,
    we will go through some of the common attacks at the second layer of TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: ARP Watcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With **Address Resolution Protocol** (**ARP**), we can find live internal hosts.
    We can write a script to scan for hosts in a given network with Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write a ARP Watcher with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `arp-scanner.py` file and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then have to import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now declare the variables for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we can send ARP packets to all the IPs in the IP range, and get answered
    and unanswered packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the ARP packet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the packet will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, send the packet with `srp()` and receive the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, iterate through all the answered packets and print their MAC and IPs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the MAC and IPs of all active systems in the network range
    provided. Output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can convert this to an ARP monitor, that has the ability to monitor the
    network for changes. For that, create another `arp-monitor.py` file and import
    the `scapy` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a function to parse the packets and sniff the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start sniffing and call the `parsePacket()` method to parse the ARP packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with required permission to start the monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ARP cache poisoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, systems on a TCP/IP LAN identify and communicate with each other
    via the MAC addresses of their network adapters. Each system keeps a list of systems
    and their MAC addresses for reference, known as the ARP cache. If possible, we
    need to spoof the cache of a machine with a wrong MAC address for another machine.
    All communication to that machine with the spoofed MAC address from the machine
    will be directed to the attached machine. So, ARP cache poisoning is the method
    of tricking a machine to save the wrong data about an IP address in its ARP table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are performing a type of man-in-the-middle attack (getting the data from
    another device connected to the same network), we have to turn on the IP forwarding
    to make sure that the connection on the victim's machine is not affected or interrupted.
    For performing IP forwarding, we have different methods for Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can check the status of IP forwarding by checking the content in the following
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the output is `1`, IP forwarding is enabled; and if it''s `0`, IP forwarding
    is disabled. If it''s disabled, enable it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can enable IP forwarding in macOS with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a script to poison ARP cache in a victim system:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `arp-cache-poisoning.py` file and open in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `scapy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the variables. We could also get these from arguments, or as: `raw_input()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now define a function to get the MAC IDs from the IP provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now get the MAC address of the target and gateway with the `getMac()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the function to poison the ARP cache of the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are sending two types of packets--one to the target machine, and one
    to the gateway. The first two blocks define these packets. The target packet will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `gateway` packet will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now create a function to reset the poisoned cache back to the normal state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can start sending the packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: MAC flooder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can fill the MAC address store of a router by sending random Ethernet traffic
    over the network. This may lead to the malfunction of the switch, and may start
    sending all the network traffic to everyone connected to the router, or it may
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to flood MAC address store in a router:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mac-flooder.py` file and open in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `interface` to flood. We could also get it from the arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the packets with random MAC IDs and random IPs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, send the packets in an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the file with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: VLAN hopping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VLAN hopping is the type of attack in which the attacker is able to send traffic
    from one VLAN into another. We can do this with two methods: double tags and switch
    spoofing.'
  prefs: []
  type: TYPE_NORMAL
- en: To create a double tag attack, the attacker sends a packet with two **802.1Q**
    tags--the inner VLAN tag is the VLAN that we are planning to reach, and the outer
    layer is the current VLAN.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to simulate a simple VLAN hopping attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `vlan-hopping.py` file and open in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the modules and set the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Craft the packet with two 802.1Q tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, send these packets in an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ARP spoofing over VLAN hopping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As VLANs limit broadcast traffic to the same VLAN, here we tag every packet
    with our VLAN tag, and an extra with the destination VLAN.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to simulate ARP spoofing attack over VLAN hopping:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `arp-spoofing-over-vlan.py` file and open in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import modules and set variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create ARP packets with two 802.1Q tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the packet with two 802.1Q tags and an ARP layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Send the packets in an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with required permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: DHCP starvation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DHCP is the protocol that helps to assign clients' IP addresses to the LAN.
    The process of assigning DHCP consists of four steps--DHCPDiscover, DHCPOffer,
    DHCPRequest, and DHCP ACK.
  prefs: []
  type: TYPE_NORMAL
- en: 'DHCPDiscover is the first step where the client broadcasts in the LAN to find
    a DHCP server that can provide an IP for the client. Then the server will respond
    with a unicast DHCPOffer, where it offers a possible IP. Then, the client will
    broadcast the DHCPRequest with the IP to all networks, and finally the server
    will respond with a DHCP ACK or DHCP NAK. ACK represents a successful DHCP process,
    while NAK represents when the IP is not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The DHCP server stores the IP information to MAC bindings. If we ask for too
    many IPs from the DHCP server, other legitimate clients will not get an IP to
    connect. This is known as a **DHCP starvation attack**. In this recipe, we will
    be attacking the third step of this process. After sending the DHCP request, the
    server will assign the requested IP for the client. This can be used to attack
    a specific range of IPs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try writing a script to starve the DHCP in the network:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `dhcp-starvation.py` file and open in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We require `Scapy` for crafting the packets, and a `threading` module for threaded
    execution of the script
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, define the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the callback function to handle the captured DHCP packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function is called to process each packet received by the sniffer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to create another function to configure the sniffer. This function
    is called by the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will start sniffing the UDP packets to the ports `67` and `68`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a DHCPRequest packet and send it to the DHCP server that
    we are planning to starve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will first generate an IP within the specified range. Also, it will create
    a random MAC address for the packet. This will then craft a DHCPRequest packet
    with the generated IP addresses and MAC. Then, it will send the packet. The packet
    generated will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can start threads and try to occupy the IP address in the DHCP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the script with required permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
