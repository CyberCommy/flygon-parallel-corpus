- en: Chapter 6. Functional Reactive Programming – The Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I might begin here by somewhat awkwardly mentioning that I have a Master''s
    degree in math and lots of math awards, but I find some of the mathematical concepts
    associated with basic functional programming to be a tad slippery. One wouldn''t
    discourage someone strong in the relevant math and computer science fields from
    tackling the full mathematical rigor of, for example, the foundational functional
    reactive programming papers linked to in the Wikipedia article on functional reactive
    programming. However, the intent here is slightly different: to learn something
    from functional reactive programming that is useful to professional developers
    who do not have, or do not remember, the level of mathematical formation that
    informs those seminal works.'
  prefs: []
  type: TYPE_NORMAL
- en: StackOverflow comments repeatedly ask, "Can you explain it in a way that doesn't
    assume a PhD in computational mathematics?" The intent here is not to provide
    the whole of those mathematical articles together, but a subset that can be practical
    and is useful to real professional software developers who do not dream in Scheme
    or Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: A trip down computer folklore's memory lane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you learn just one thing…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what you can about functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The future of frontend web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dig in. The folklore-laden trip down memory lane may be fairly long, but
    it is not, in any sense, dull.
  prefs: []
  type: TYPE_NORMAL
- en: A trip down computer folklore's memory lane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a scathingly insulting checklist that has been floating around to apply
    to pet (or other) programming languages. One of the put-downs is, "Programmers
    should not have to understand category theory to write, *Hello, World!*" It reflects,
    in part, an irritation of mistakes that wet-behind-the-ears juniors keep making
    when they propose the best programming language yet. In that, it might be compared
    to the viral evil overlord list of stupid things that keep happening in adventure
    movies. Learning from the mistakes of countless movie villains, the author declares
    that "Shooting is not too good for my enemies" and "I will not include a self-destruct
    mechanism unless absolutely necessary…" The put-downs come from frustration at
    seeing the same mistakes again and again.
  prefs: []
  type: TYPE_NORMAL
- en: There are other points that show programming wit and wisdom. For one example,
    there are orders of magnitude more pet or toy languages than successful languages,
    where success can either be in academic computer science circles or business information
    technology. One widely recognized turning point in the development of any language
    is when it works at a level where one could *dogfood* it by using it to write
    its own compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is not an insignificant point; when Java was first announced, it was
    declared that the Java compiler was written in Java itself, with the implication
    that a system that could run the Java runtime environment should be able to compile
    software written in Java. In relation to this, a standard question to insult someone''s
    enthusiastically gushed-about pet language is, "Has it been used to write anything
    besides its own compiler?" And this particular node of computer wisdom and folklore
    is baked into the checklist: two of the entries are, in quick succession, "The
    most significant program written in this language is its own compiler" and then,
    even more insultingly, "The most significant program written in this language
    isn''t even its own compiler".'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the philosophical objection of, "Programmers should not need to understand
    category theory to write, *Hello, World!*" is not simply making things up to sound
    insulting. There is a tradition started by the 1978 first edition of Kernigan
    and Ritchie''s classic *The C Programming Language*, where the first program developed
    before diving into intricacies was a minimal C program, on the thought of "Let''s
    crawl before we try to walk," to print out *Hello, World!*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: People introducing new programming languages overwhelmingly follow in the tradition
    of using `Hello, World!` as their first sample program. That's one end of "Programmers
    should not need to understand category theory to write, *Hello, World!*" So what
    is the other end of the spectrum?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of academic mathematics, whether pure or applied, mathematics
    as a sign of success has become very specialized (like almost any domain that''s
    had enough work). It has been commented that it''s a rare beast of a mathematician
    who can understand more than 13 of 50 papers presented at a math conference. Mathematics
    has become specialized enough that most math PhDs, however competent, cannot understand
    the work of most other math PhDs. In that case this doesn''t make sense, the hope
    of being able to understand all of mathematics is like the hope of being able
    to speak all human languages: a bit naïve. The point of a math PhD program is
    perhaps not to develop you to the point of being able to follow the whole breadth
    of the discipline of mathematics, but to understand some narrow area deeply enough
    that, by the time your PhD is complete, you understand that highly focused area
    better than anyone else in the world.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two exceptions of a sort, disciplines that connect all of mathematics,
    but from completely opposite directions. On one hand, there is logic and the foundations
    of mathematics, which looks at the bedrock that all other areas of mathematics
    is founded on. Now there are some questions about whether logic belongs to math
    or philosophy, and one hears of people asked to decide whether they want to be
    logicians or mathematicians. But setting aside some of these questions, it would
    not be too controversial to say that logic connects to all of mathematics by digging
    into the bedrock that the rest of mathematics rests on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then there''s the other option: *category theory*. A Barbie doll once said,
    "Math is hard", but the mathematical community understands that very well without
    Barbie''s help. Albert Einstein said, "Do not worry about your difficulties with
    mathematics. I can assure you that mine are greater still." But the branch of
    mathematics called category theory is particularly and obnoxiously harder.'
  prefs: []
  type: TYPE_NORMAL
- en: If logic can study the bedrock that the great edifice of mathematics is built
    on, category theory looks at the already built city and explores architectural
    themes and similarities running through all kinds of mathematical neighborhoods.
    Category theory is a discipline a bit like the academic discipline of comparative
    in that practitioners are expected to be able to cope with comparative literature
    in not just one, but several languages. It could be argued that category theory
    is the most difficult place under the whole mathematical umbrella. You need to
    do something most math PhDs are never taught.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is perhaps a tribute that my thesis advisor, who was a category theorist,
    was able to effectively supervise a thesis in the obscure branch of point-set
    topology even though he did not show any particular specialization in point-set
    topology. So saying that a programmer using your language needs to understand
    category theory to write *Hello, world!* is quite the scathing insult.
  prefs: []
  type: TYPE_NORMAL
- en: So what does this have to do with functional or functional reactive programming?
    Glad you asked!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sources linked to in the Wikipedia article for functional reactive programming,
    Haskell (or something built on it) is the dominant language. There are a couple
    of other players, such as a dialect of Scheme, but people seem to keep coming
    back to Haskell. There are a number of Haskell resources out there; one of the
    most respected is *Learn You a Haskell for Great Good*, [http://tinyurl.com/reactjs-learn-haskell](http://tinyurl.com/reactjs-learn-haskell).
    It has a *Hello, World!* program that mysteriously appears in the ninth chapter
    instead of the first. Why the ninth? Well, as explained, input and output are
    built on top of monads. But does it really take that much explanation to get to
    monads? Yes; monads are built on top of the concept of applicative functors, which
    are built on the basic concept of functors, which ring a bell as the name of something
    met in math grad school and not really understood. Let''s visit the Wikipedia
    page for functors. The Wikipedia is known for being something that is clear and
    easy to read. And there are a couple of things in the Wikipedia page for functors.
    One is that the language is awfully esoteric for the Wikipedia. The other point
    is that functors are in fact something acquired from category theory:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In mathematics, a functor is a type of mapping between categories, which is
    applied in category theory. Functors can be thought of as homomorphisms between
    categories. In the category of small categories, functors can be thought of more
    generally as morphisms.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Functors were first considered in algebraic topology, where algebraic objects
    (such as the fundamental group) are associated with topological spaces, and algebraic
    homomorphisms are associated with continuous maps. Nowadays, functors are used
    throughout modern mathematics to relate to various categories. Thus, functors
    are generally applicable in areas within mathematics that category theory can
    make an abstraction of.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced prerequisites for Hello, World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want a challenge, read the Wikipedia article on functors. But if you
    find yourself skimming because it''s mostly over your head, you''re in good company:
    possibly a lot of math Ph.D.''s tend to skim the same way you would, for much
    the same reason.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more that can be said at this point, but I'll limit myself to one further
    remark after commenting on the intent of this chapter. This leads into the central
    difficulty of this chapter. This is a text on information technology rather than
    computer science, and while one may check in with computer scientists, this text
    is intended to be written from the perspective of one programmer who doesn't follow
    all the layers of math to another. The equivalent of the goal in Haskell, would
    be to say on a *monkey see, monkey do* basis, "This is an example of a pure function;
    that is an example of an input and output monad. Try to do as much of your heavy
    lifting as possible from the pure portion of your program and confine input and
    output to as small a quarantined space as possible."
  prefs: []
  type: TYPE_NORMAL
- en: 'And there is one point where one would contrast Haskell with Python, starting
    again with XKCD—note what is given as the first example of everything being simple
    in Python. One''s first encounter with Python leads to the feeling of being head
    over heels in love with programming again. The same is entirely true of ReactJS,
    which is like discovering the web for the first time all over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced prerequisites for Hello, World!](img/B04108_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Python and Haskell are similar in at least one respect: they both allow rapid
    software development. Haskell boasts a similar feature to what one would expect
    of Python: an undergraduate spent a few months and implemented a good deal of
    the Quake 3 engine in Haskell. There may be other strengths to Haskell, such as
    its rock solid type system, and by the time something compiles, it already stands
    a good chance of working. However, the question pursued here is, "Does it make
    programmers highly productive?" This screen shot is from a Quake 3 level implemented
    in a few months for a one student''s undergraduate project. There are things Haskell
    has that Python doesn''t: a rock-solid type system, for instance. However, Haskell
    and Python are similar at least in this: in the hands of a proficient developer,
    they allow productivity and pace of development that needs to be seen before it
    can believed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced prerequisites for Hello, World!](img/B04108_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But, while seasoned programmers may try Python and find themselves flying, if
    they can't handle the math, they won't have the same experience using Haskell.
    Haskell offers rapid development super powers to people who can handle a good
    deal of computational math. Python offers such powers to a much wider group of
    programmers, whether or not they have a heavy math background.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is an attempt, rightly or wrongly, to explain things so that workers
    in information technology, rather than computer science specifically, can have
    a seasoned programmer's good Python experience with functional reactive programming
    and ReactJS, instead of a seasoned programmer's bad Haskell experience that leads
    so many developers to keep on making comments that become very sad after a while,
    depressing comments such as "I might understand this if I just knew more math."
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of our writing this book is to make a book useful for programmers
    in the field, not just computer science students who know a lot of math. But an
    easier approach is at least hinted at, along with seasoned programmers saying
    "I might get this if I knew more math." Taken directly from the page [http://tinyurl.com/reactjs-learn-monads](http://tinyurl.com/reactjs-learn-monads).
    Now, here are some steps on how to learn Monads:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a PhD in computer science.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw it away because you don't need it for this section!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Perhaps ordinary developers can, after all, profit from (reactive) functional
    programming!)
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing the features of functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the leading lights of functional reactive programming, and arguably
    a grandfather to functional reactive programming, Conal Elliott, looked back on
    the term "functional reactive programming," and a leading light''s second thoughts
    about a name can be very interesting. Elliott expressed a reservation about the
    term *functional*, suggesting that the word means so many things now that it means
    very little, and expressed a regret about a word that the term didn''t include:
    time. He suggested an alternative name of denotative continuous-time programming,
    which is significant even if we use the more standard term of "functional reactive
    programming" here. By *denotative*, we mean, as we discussed earlier about ReactJS,
    that you specify only what needs to be accomplished, not every step of how to
    accomplish it. Continuous-time did not merely mean that it should be called such,
    but that continuous time was important enough that it should be baked into the
    name for what is now called functional reactive programming.'
  prefs: []
  type: TYPE_NORMAL
- en: The continuous time element comes up in the sources and may seem surprising
    to some, since computers only measure time discretely, but the distinction is
    a distinction in a conceptual model rather than a feature observed in implementations.
    The comparison is made to infinite lists as they exist in functional languages,
    where one may take as much or as little from a list without running out of precomputed
    entries, or perhaps more saliently to the difference between raster graphics (GIF,
    JPEG, PNG), which have a certain fixed number of pixels represented, and vector
    graphics (SVG, some PDF) where admittedly, an image is rendered to be displayed
    on something with a concrete number of fixed pixels, but an SVG logo can be rendered
    in accordance with a classic advertising executive's quote that a company logo
    should look as good one sixteenth of an inch high on letterhead as it does eight
    feet tall on top of corporate headquarters.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous time means that time is handled like SVG or other vector graphics,
    not raster GIF/JPEG/PNG, which is stored at a fixed resolution and not a pixel
    more. One of the suggestions made for functional reactive programming is that
    continuous-time events and probably continuous-valued behaviors or streams of
    events have a first-class entity status as one of the defining features (though,
    some might point out, perhaps not the only one) is that functions are first-class
    entities that can be passed as arguments, as one does in JavaScript and other
    languages with anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be immediately obvious how ReactJS relates to this; I've watched
    over a dozen ReactJS videos, usually from Facebook developers. There is emphatic
    mention of *denotational symantics*, a formal term to describe only what needs
    to be accomplished and not every step of how to accomplish it. And there is consistent
    discussion of the virtual DOM, which amounts to "You can learn more if you want,
    but all you need to do is tell how to `render()`, and trust the system to do all
    the rest." But in fact, continuous time semantics are baked into how ReactJS works
    at a very basic level. Part of the developer's responsibility is to write a `render()`
    method that specifies what should appear on the page at the time it is called
    (and, perhaps, to call `render()` appropriately; `render()` doesn't run by itself).
  prefs: []
  type: TYPE_NORMAL
- en: This does not have every feature of continuous time; one instructional video
    hints at a system that does not just work in real time, but allows VCR-style "rewind"
    and "fast forward" functionality to step through time, and one of Pete Hunt's
    ReactJS videos hints that Facebook, through ReactJS technology, might take a bug
    report and be able to replay, detail by detail, what went wrong before someone
    gave a bug report with no written description of what went wrong beyond "a profanity."
    However, the front and center use case is one where continuous time is assumed
    and it is the developer's responsibility to make a `render()` function that can
    correctly say what to render the instance it is called, and (incidentally) to
    call that function appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: If you learn just one thing...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Richard P. Feynman''s classic "Feynman lectures," held as an exemplar of clear
    explanation of technical topics, opens with a very simple question: if all else
    of science were forgotten and only one sentence''s worth of information survived,
    what would that ideally be? Feynman gave a succinct answer that actually says
    quite a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If, in some cataclysm, all of scientific knowledge were to be destroyed,
    and only one sentence passed on to the next generation of creatures, what statement
    would contain the most information in the fewest words? I believe it is the atomic
    hypothesis that **all things are made of atoms — little particles that move around
    in perpetual motion, attracting each other when they are a little distance apart,
    but repelling upon being squeezed into one another.** In that one sentence, you
    will see, there is an enormous amount of information about the world, if just
    a little imagination and thinking are applied."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And this serves as the springboard, in the Feynman lectures, to say a lot about
    physics as we know it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest learning point from functional reactive programming that can be
    put into a single sentence is a lesson associated with the functional programming
    itself, that functional reactive programming further refines: *Spend as much time
    writing pure functions, math-style, as you can, and as little time as possible
    writing or following recipes*.'
  prefs: []
  type: TYPE_NORMAL
- en: A recipe says such things as "Preheat your oven to 350 °F. Mix the leaves, ghee,
    and salt together in a large bowl. Line two large baking trays with parchment.
    Divide the leaves evenly in a single layer on each tray..." Now this is not taking
    a dig at home economics and people who cook. (A purely functional approach to
    cooking would never produce anything edible, a minor drawback if you want to get
    anything done.) Recipes are equally to be found in the many, many YouTube videos
    detailing how to replace, for example, a broken wiper blade on a 2004 Ford Escort,
    and they power traditional hacker-written How-to's, which are less prominent today
    than they were earlier, not because the hacker community has realized that using
    a How-to is not an appropriate way to resolve a difficulty when following your
    nose is getting you nowhere, but because the general usability of almost everything
    has improved enough that you don't need a How-to that mentions the moon phase
    if you want to burn a CD; How-tos are much less likely to be the only game in
    town (which is really their best use case).
  prefs: []
  type: TYPE_NORMAL
- en: 'I am somewhat concerned with what theoretical contortions Haskell went through
    (read: *needed* to go through) to include input and output with minimal compromise
    to its functional status. But all the same, even if purely functional JavaScript
    may or may not be possible, we would do well to grow the portion of our software
    that is purely functional and minimize what gets work done by specifying how to
    do things. Functions here should not mean, as in structured programming, "a subroutine
    that returns a value." A function is not doing something plus returning something
    interesting when it is done. It rather has the mathematical sense of "something
    that takes zero or more arguments and does neither more nor less than return a
    value that is arrived at based on that value."'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of pure functions from basic mathematics used by computer people include
    arithmetic functions such as addition, subtraction, multiplication, division,
    exponentiation, factorial (4 factorial, for instance, is 4 * 3 * 2 * 1), Fibonacci
    numbers, trigonometric functions such as sine and cosine, hyperbolic functions,
    integral, derivative, Euclidean division to calculate the greatest common divisor
    between two positive integers, and so on. Without exception, these take zero or
    more (or, as the case may be for these, one or more) inputs, and yield something
    calculated from them without making any external changes; none of them update
    a database or output something to the console. They just take their inputs and
    deterministically calculate an output, no more, no less. That is of the essence
    of a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: A **sesquipedalian** term is "a word that is a foot and a half long." Some of
    them float around, including in videos on ReactJS and functional reactive programming,
    such as idempotent and **referential transparency**. But the meanings are simple
    and straightforward in relation to pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An idempotent function is the one that returns the same result whether you
    call it once or a hundred times. In mathematics, addition and factorial, for instance,
    always give the same result. RESTful web services offer a less mathematical example
    of idempotence: requesting the same URL means getting the same HTML or other data,
    every single time. Getting static content is idempotent; a version of a library
    pulled from CDN should result in the same download no matter who requests it,
    where, or when.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching, such as one aims for with Steve Souder's classic far-future *Expires*
    headers for Yslow, is a useful thing to do precisely where there is idempotence
    between downloads. (If a download is idempotent, a document is the same document
    regardless of whether one downloaded a fresh copy or supplied it from your browser's
    cache.) Dynamic content, whether old-fashioned CGI scripts or dynamic Django applications,
    is not idempotent. If a page says, even in an HTML comment, "This page downloaded
    at such-and-such time," it is not idempotent. The Web was designed from the beginning
    to be idempotent; later on people started to realize that dynamic content could
    be highly desirable and worked on how to overcome the stateless, idempotent design
    of HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The nice eight syllables of referential transparency mean that a function call
    can equivalently be replaced with the value it returns. Because 4! is 24, it should
    be equivalent to include 4! in your code and just include 24 instead. If you have
    the cosine of a value, it should be equivalent to use a stored value of the result
    of that call to `cos()`, or to recompute. Impure behavior that would break referential
    transparency would be to have `cos()` log a string each time it was called, which
    is a classic example of a *side effect*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term side effect is unfortunate and probably intended to be loaded language;
    in a medical context, all drugs produce multiple effects, some of which are the
    point of taking the medication and some of which are tolerated as a necessary
    evil that comes with getting the desired effects. A side effect medically is a
    medication effect that is tolerated but not why the medication is taken. Saying
    that logging a message in a program is a side effect is a bit like saying that
    taking a pain reliever, and experiencing consequent reduction in one''s physical
    pain, is experiencing a side effect: that is the entire point of taking the medication,
    not any other effects the drug may have, and it''s an odd thing to call this a
    side effect.'
  prefs: []
  type: TYPE_NORMAL
- en: Preceding are some stock examples of functions from basic math, and perhaps
    that is easy, because in certain areas of math, everything is a pure function,
    perhaps built from pure functions, and the setting precludes impure functions
    or side effects. One could also give polynomials as an example of pure functions
    built up from pure functions, which is a really nice approach if you are equipped
    to use it, but feels foreign and confusing if one is used to framing everything
    in informative assumptions. Between functional and imperative functions, for programmers
    with an imperative-based formation, imperative function is the approach that is
    easiest in the short term but harder in the long term. For programmers with a
    functionally-based formation, functional programming is easy, both in the short
    term and the long term. But for an example of these concerns playing out in practical
    information technology, we need look no further than ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook's learning from prolonged pain essentially led to a realization that
    the way out of the morass was through idempotency and referential transparency,
    and that is what ReactJS was written to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Learn what you can!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wise master in the Orthodox spiritual tradition boiled many things down into
    55 maxims ([http://tinyurl.com/reactjs-55-maxims](http://tinyurl.com/reactjs-55-maxims)),
    the second of which was, *Pray as you can, not as you think you must*, and these
    are wise words for much of programming too. And there is a suggestion here, but
    not so non-mathematicians will be daunted. Follow this one suggestion as you can,
    not as you think you must. Learn as much functional programming as you can. Write
    JavaScript in as purely a functional fashion as you can.
  prefs: []
  type: TYPE_NORMAL
- en: I have wrapped my head around functors now, as I failed to do so as a graduate
    student in math. I haven't conceptually wrapped my head around applicative functors
    and monads from a theory perspective, but the idea of writing pure functions as
    much as possible and making minimal use of input and output monads is something
    that appears doable on a *monkey see, monkey do* basis, which is much less taxing
    than having to trace a monad's conceptual genealogy. And this falls into the category
    of using functional programming as you can, not as you think you must.
  prefs: []
  type: TYPE_NORMAL
- en: The Wikipedia article on functional reactive programming links to nine major
    works in the field, and if you want to wrestle with a good mathematical challenge,
    all of them are worth a good wrestle. The mathematical symbols can be as dense
    as they are on the Wikipedia article on functors, which is quite dense.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we look at languages, there''s a clue here. There are a few interesting
    possibilities, all functional, that are mentioned in the literature: a Scheme
    dialect, DDD, and Elm (which is its own language compiling, comparably to DDD,
    to its own JavaScript / HTML / CSS). But the strongest attraction of functional
    reactive programming authors seems to be by far Haskell. This offers us a free
    clue that, at least in its origins, Haskell is a center of gravity to pretty much
    all the seminal papers on functional reactive programming. Any language, including
    Haskell, has flaws, but it would be silly to simply ignore the fact that seminal
    works in functional reactive programming gravitate towards Haskell.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming is reactive programming built out of the building
    blocks of functional programming. Some aspects of this are taken care of for us
    when developing in JavaScript with ReactJS. We only need to specify declaratively
    what the UI should look like when rendered, and ReactJS will handle all necessary
    compilation so a declarative `render()` method will be translated into optimized
    imperative manipulations on the DOM. But at least at first glance, it would make
    sense, if you want to understand functional reactive programming, to learn a technique
    closely tied to Haskell from the outset and only later, after you've walked a
    mile in Haskell's shoes and then know if they pinch you, write your "declaration
    of independence" from Haskell's lead.
  prefs: []
  type: TYPE_NORMAL
- en: There is criticism of *Learn You a Haskell for Great Good*, but the book was
    deliberately chosen as an excellent text to teach a top-notch functional language.
    Pointing out that a Haskell text covers eight chapters of theory and some category
    theory concepts before allowing the reader to see the traditional *Hello, world!*
    program, makes a much stronger point by picking on a strong text than picking
    on an introduction that is mediocre and invites of an obvious response of but
    there are much better examples that don't have that problem. A companion text
    that is more focused on practical applications for real-world information technology
    needs is Real World Haskell ([http://book.realworldhaskell.org/read/](http://book.realworldhaskell.org/read/)).
    These aren't the only books out there, but they offer at least a good pairing
    and a starting point, and are often recommended together.
  prefs: []
  type: TYPE_NORMAL
- en: 'More to the point, don''t try to snarf these two books and expect that after
    a day''s study, or even a month, it will be easier to get things done in Haskell
    than whatever favorite language you''ve given years of use. Instead play around,
    and tinker with these things. Treat the Glasgow Haskell Compiler as a nice set
    of virtual Lego that a loved one gave you for Christmas. *Learn You a Haskell
    for Great Good* nowhere dives into how you can write a web server, and that is
    one of the book''s strengths. It builds core strengths that are only to your benefit
    and should put you in a better position to appreciate and exploit opportunities
    for functional programming in JavaScript. G.K. Chesterton said:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"…to understand everything a strain. The poet only desires exaltation and
    expansion, a world to stretch himself in. The poet only asks to get his head into
    the heavens. It is the logician who seeks to get the heavens into his head. And
    it is his head that splits." Try to get your head into the Heavens, not the Heavens
    immediately into your head. If you are an adept programmer now, perhaps in an
    imperative paradigm, chances are good that when you were in school and exploring
    things, you sought to get your head into Heavens with programming. You wrote games;
    you played around, and acquired a foundation you would later use for professional
    work. If you want to learn Haskell, don''t cram it. Become like a little child
    again and play. And read Learn You a Haskell for Great Good, with its deliberate
    avoidance of how to get something slammed out for a deadline, until you have an
    actual foundation before reading Real World Haskell, and please do not take Real
    World Haskell to be justification to "cut to the chase" and just try to release
    commercial-style functionality on deadline-style timing.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Douglas Crockford, in his South American presentation on *The Better Parts*,
    gives an increasingly strong functional focus to functional programming when he
    describes good JavaScript. All of the earlier Crockford videos I've seen, from
    when there was just *The Good Parts* and no *The Better Parts* even on the horizon,
    seem to associate JavaScript's better parts with its functional side. But *The
    Better Parts* is even more explicit in saying that one of JavaScript harmony's
    improvements is that you can apply tail recursion, and use functional styles of
    flow control that make some kinds of flow control, such as looping almost or completely
    unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Even apart from functional reactive programming, better JavaScript seems to
    increasingly mean functional JavaScript. And this is a very good thing. Scheme,
    as mentioned earlier, has been called "the best language you'll never use," and
    the set of generally functional languages that computer scientists consistently
    choose on their merits for computer science usage are a little paradise that one
    must leave to enter professional programming.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript changed that, and not only by making anonymous functions mainstream.
    JavaScript, especially when used with ReactJS, provides one of the greatest opportunities
    to enjoy the goodness of functional programming in mainstream software development.
    And as long as you understand what you are doing, the more you can write JavaScript
    in a functional paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, reactive or otherwise, may come more easily if you're
    introduced to it in schooling that covers the more mathematical side of functional
    programming. But it is possible to teach a programmer how to write *Hello, world!*
    in Haskell while leaving the most incomprehensible mathematics of category theory
    out of sight and under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computational mathematical foundations of functional programming are something
    that should be like a machine or assembler in a higher-level language: present
    under the hood and making language capabilities possible, but out of sight with
    minimally leaky abstractions that *just work*, regardless of whether one is a
    mechanic competent to make adjustments under the hood.'
  prefs: []
  type: TYPE_NORMAL
- en: In some sense, for seasoned programmers who have been out of school for a while,
    what is needed is *The Good Parts* of learning functional programming. Now in
    this case the good parts may vary from programmer to programmer depending on their
    comfort level for functional programming. The criterion is "Do what you can, not
    what you think you must." Getting your head around the difference between declarative/denotative
    programming and imperative programming, is perhaps difficult, but not too difficult.
    The closely connected concept of writing pure functions as much as reasonably
    possible and quarantining code that must have side effects even if you're trying
    to avoid them, is a shift in thinking but not too slippery.
  prefs: []
  type: TYPE_NORMAL
- en: Learning functors, for instance, is actually a bit easier in Haskell than in
    category theory, even if the Wikipedia page does not reflect this. It shouldn't
    take most programmers too long to write a first Haskell program that is mostly
    pure functions and input and output handled by a minimal quarantine of monads.
    But using features such as monads is much easier than understanding the contorted
    steps one uses to work with pure functions and build up to monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'And it is worth repeating: if functional (reactive) programming is appropriate
    for mainstream use, the heavily mathematical theory used to get from a function
    to a monad should no more be forced on average Joe professional developers than
    even a C programmer should be forced to work with the assembler or machine instructions
    generated by his software. One wag said that "C is a language that combines the
    power of assembler with the ease of using assembler," but C never forces most
    programmers to micromanage how the compiler renders the C source.'
  prefs: []
  type: TYPE_NORMAL
- en: Many mainstream languages now, in particular multi-paradigm languages, have
    incorporated some elements of functional programming strengths. All the same,
    one might suggest that JavaScript, of all mainstream languages, directly offers
    the best set of functional programming strengths bar none. Not necessarily the
    best functional programming among the languages favored by computer scientists
    such as Haskell or Lisp/Scheme; it's hard to find a mainstream programming job
    where management will allow a solution in Haskell or Scheme. But among mainstream
    languages, JavaScript is still the juiciest. Computer scientists have long been
    fond of functional programming, and at least one programmer who studied math in
    school commented, "Functional programming is the first programming paradigm I've
    seen that makes sense." And for excellence that computer scientists have almost
    universally favored for (mumble) years or decades, JavaScript isn't just the language
    browsers will execute, important as that may be. It also offers the best opportunity
    for functional programming goodness in a language frequently encountered on job
    descriptions for employers who want to hire you.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as the new bare metal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Douglas Crockford, in *The Better Parts* mentioned earlier, tries to make the
    point that programmers are just as emotional as everyone else. He backs up this
    point in a way that would not be a surprise to a Kuhn scholar: fundamental improvements
    in software engineering win by the attrition of programmers holding the earlier
    approach. He gives an example of six or so "it took a generation" remarks: "it
    took a generation" for software engineers to recognize that high-level languages
    were a good idea, or that the F-bomb of all programming language statements, the
    G-bomb or goto statement, was not a good idea. And although Crockford gives several
    examples, his efforts do not seem to have pretensions of including all the significant
    examples: although I''m not completely sure of the dates, it seems to have taken
    about a generation between the 1960s, when Smalltalk recognized that references
    were better than pointers (pointers have been called "the goto of data structures"),
    and the 1990s when a mainstream language that was "front and center," like Java,
    superceded pointers with references.'
  prefs: []
  type: TYPE_NORMAL
- en: Crockford made a few remarks about programmers invoking freedom of self-expression
    to do all programming on bare metal or routinely use goto statements to handle
    flow control. But when all is said and done, including that it took two generations
    for anonymous functions to be used in a mainstream language, JavaScript being
    the first, improvements in software development do not take root because existing
    programmers embrace better ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'They take root because new programmers embrace better ways, while the majority
    of older, unconvinced programmers die. (Even if they could learn. But in some
    sense there is an option to opt-out of becoming obsolete, by embracing new changes.
    It''s just that many people say, "If it was good enough for me at 20, it''s good
    enough for me at 40." There is no iron determinism grasping every individual:
    only a "default setting" on /programmers/ that ages poorly as a default setting.)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is *lingua franca* on the web, and even if you object to it because
    it's not your favorite language (indeed, why should it be just like Perl, Python,
    Java or C++?), it is here to stay and is perhaps the best bet around for what
    will be the most important language, and will be for quite a while. But what may
    "take a generation" in this context is the realization that web programming in
    non-JavaScript languages is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alan Perlis said, "A programming language is low level when its programs require
    attention to the irrelevant," and if programming well in JavaScript requires avoiding
    large minefields of languages for reasons that are far from obvious to casual
    inspection, JavaScript requires attention to the irrelevant: JavaScript is low
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: One encouraging sign in newer web development, in ReactJS videos, is not only
    that another non-JavaScript language or syntactic sugar, CoffeeScript, is used,
    but that its introduction was presented smoothly and casually, and entirely without
    apology, defense, or explanation. The fact that they used CoffeeScript at all
    is significant, and the fact that they did so without any trace of defensiveness
    is even more significant. Now CoffeeScript might not be any kind of be-all, end-all
    among languages that can or should be able to be compiled to JavaScript. But it
    is encouraging to see something other than JavaScript "bare metal."
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that there is no place for that "bare metal" programming.
    Amateur game developers or programmers from mega-corporations trying to squeeze
    the last ounce of performance out of either bare metal for standalone applications
    and games, will legitimately want to squeeze the last ounce of performance out
    of their user's computer, whether working on the "bare metal" of application programming
    or JavaScript on the web. But just as one ordinarily does not write web applications
    in C or assembler (and didn't do so even when CGI scripts were the primary means
    of delivering dynamic content), for most uses of web programming, a good smartphone
    (a slightly old iPhone 5 is roughly 100 times as fast as a top-of-the-line computer
    from when the web was new) really is fast enough to run code generated by compiling
    other languages to JavaScript. And JavaScript is, after all, so much more impressive
    when one understands how it is developed. It is a computer language that was designed
    in 10 days, something that one ordinarily greets not with, "That's an impressive
    feat!" but also, "Dude, ease up a bit! If you keep abusing stimulants like that,
    you'll kill yourself!"
  prefs: []
  type: TYPE_NORMAL
- en: The essential reason why using a high-level language is desirable is something
    painfully obvious that programmers learn to shut out so they can get any work
    done in JavaScript. Douglas Crockford's *The Good Parts*, and with it the idea
    that JavaScript has both treasures and land mines and a good part of navigating
    JavaScript well is avoiding minefields altogether, has taken such deep root that
    this title's brief summary may be entirely superfluous for most programmers reading
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: That, even by itself, is serious reason to consider alternatives to programming
    on JavaScript "bare metal" if one has the option. And in fact, there are many
    alternatives to JavaScript "bare metal" for frontend web development. [http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)
    has a long list of other languages, including family and friends intended to offer
    an enhanced JavaScript in some aspect or other, and compilers for other languages
    to JavaScript, including (often) multiple options for Basic, C/C++, C#/F#/.NET,
    Erlang, Go, Haskell, Java/JVM, Lisp, OCAML, Pascal, PHP, Python, Ruby, Scheme,
    Smalltalk, and SQL. Presumably not every single one of the compilers and implementations
    is particularly good, but like every other serious computer language, JavaScript
    is Turing-complete, and not only is it theoretically possible to compile other
    complete languages to JavaScript as well as "bare metal", but it is practically
    possible and makes plenty of sense. JavaScript may become the most important compilation
    target, eclipsing even x86_64 machine code. Or it may not, but JavaScript's desirability
    and capabilities mean that the phenomenon of writing in languages compiled to
    JavaScript—meaning most other languages—might only grow in the foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter may be an early attempt at the kind of endeavor where early attempts
    often do not succeed. There are seminal documents easily available on the web,
    but they assume you can not only program but handle a particular kind of math
    that most professional developers cannot and perhaps have never achieved proficiency.
    The goal here is not to provide another highly mathematical explanation, but to
    produce a document that would be useful, perhaps on a less highly exalted plane,
    to the majority of frontend developers who naturally think of imperative solutions.
    The goal here is to move towards more functional and less imperative programming,
    but also to produce a text appropriate to the level of mathematical skill that
    professional programmers actually have, not the level of math skills some authority
    might wish them to have. Consequently, the prerequisites are meant not to assume
    an understanding of category theory itself before programmers are allowed to write,
    *Hello, world!*
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took a trip down computer folklore's memory lane. This trip
    looked at a scathing computer checklist, simple *Hello, world!* program, and category
    theory—and how functional reactive programming's preferred language, Haskell,
    may want you to use category theory if you're allowed to write, *Hello, world!*
    This is a major problem.
  prefs: []
  type: TYPE_NORMAL
- en: We've also had a look at the distinguishing features of functional reactive
    programming including how time is treated. Also a serious answer to the question,
    "If you learn just one thing from functional reactive programming, what would
    be the best thing to learn?" is covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learning what you can about pure functional development, not what you think
    you must learn about it, is also covered here. It's easy to paralyze yourself
    by trying to learn too much functional programming, and honestly, functional programming
    (which requires that you shift how you look at the world) is not the easiest thing
    for seasoned imperative programmers to learn. This is an attempt to offer a sane
    measure of profiting from what functional programming one can without getting
    completely lost in the almost infinite trackless wastes of grappling with functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the future of web development, where JavaScript is viewed
    as the new "bare metal."
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will explore tools to support functional reactive programming.
    Let's begin!
  prefs: []
  type: TYPE_NORMAL
