- en: '*Chapter 8*: Creating Your Own Custom Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After getting through all these lessons, we're now ready for more practical
    challenges, which are going to get us ready for creating fully-fledged React Native
    applications. We've touched upon all the basic and a bit more advanced information,
    so we're prepared to take on more difficult challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going through four different exercises. The first one
    is going to be a simple exercise where we're going to use Galio's components to
    create new ones that'll fit our imaginary app. Doing this will once again prove
    to us how helpful Galio can be for almost all of our programming needs.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we're going to create our own profile card. This exercise will mostly
    focus on layout and styling, as I feel this is a really important part of any
    app creation. Learning this will get us one step closer to creating the app of
    our dreams because nowadays, almost every app has a profile screen or card included
    somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The next exercise will deal with controlled inputs. On top of creating a simple
    registration form and styling it to the best of our abilities, we'll also understand
    how state is necessary when working with inputs or forms in general.
  prefs: []
  type: TYPE_NORMAL
- en: The final challenge for us will be creating an e-commerce card. This will serve
    as proof of the fact that almost anything can be created by figuring out how it's
    similar to something you've already created. This is the moment where we can understand
    that having experience in a field will definitely help in another field. No experience
    is useless; everything helps us grow as a better human being overall.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own component!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own profile card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own register form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your e-commerce cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 08` that contains all the code we've written
    inside this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own component!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've gotten through all the basic knowledge about how React and React
    Native work, it's time to put our skills to the test by creating a lot of different
    components. Worry not—we're also going to create a bigger and more complex app.
    But as you know, a React application is formed from lots of different components,
    so by creating components, we're actually getting ready to create apps.
  prefs: []
  type: TYPE_NORMAL
- en: I was thinking that for our first component, we should start with a news card.
    This would usually go straight to the news feed—we'd use multiple components like
    this with different text if we were to create a news app. So, how do we start?
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we usually do, create an app with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're going to use the same app for all our exercises in this chapter because
    it's a lot easier than creating a project for each of them. So, right after the
    project has been created, let's open it up and then open our `App.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to create a new `components` folder inside our root folder.
    Here, we're going to start developing our own components. At the end of this chapter,
    you should have four files inside this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re going to use Galio for creating our component''s layout, we
    should install it now via the terminal. Remember the command we''re using for
    installing external packages? We''re going to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create a new file called `NewsCard.js` inside our `components` folder.
    Because we're creating a news feed type of component, we need to think of what
    exactly we would need to use inside this component.
  prefs: []
  type: TYPE_NORMAL
- en: We know for sure that we need `StyleSheet` for the styles and the `Block` component
    from **Galio**. But we also need a `Text` component for rendering the text and
    an `Icon` component, so that we'll be able to have some sort of icon. I feel that
    every post should also have an avatar, so an `Image` component is also required.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our imports should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Imports used for our NewsCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.01_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Imports used for our NewsCard component
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what we're going to use inside our component, let's start building
    it piece by piece. We'll start by creating a functional component named `NewsCard`.
    This function is going to return, for now, just a `Block` element and a `Text`
    element in order to have something to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also create a `styles` object at the end of the file. Remember how we
    were supposed to do that? Nice! Let''s create a style called `card` for our main
    `Block` component. For the styling, I was thinking of adding something new that
    we haven''t discussed until now: shadows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shadows are really not that hard to use but I feel that some people might not
    really understand how those work. After adding the style, let''s take a look at
    what our component looks like up to now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The beginning of our first component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.02_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The beginning of our first component
  prefs: []
  type: TYPE_NORMAL
- en: 'So, everything should look fairly simple to understand at this point. The shadows
    here are the only topic we haven''t really explored, but the styling should be
    self-explanatory. First, we have `shadowColor`, to which we''ve assigned `#000`,
    which is black. Then we have `shadowOffset`, which is telling our shadow how to
    fall down from the object we''ve been assigning it to. If things still seem a
    bit confusing, we should think about `width` and `height` values like this: `width`
    is the *x* axis and `height` is the *y* axis. Saying `width: 0` means that our
    shadow is expected to fall down straight to the ground underneath the object,
    but combining it with `height: 2` will tell our shadow to drop down 2 **pixels**
    (**px**) from the center. Then, we have `shadowOpacity`, which does what you''d
    expect it to do: it calculates the opacity of our shadow. You''ve probably noticed
    `elevation`; this is what you''re using to set the shadow for Android devices,
    and it only is supported on Android 5.0+.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set the basis of our new component, let's import it to `App.js`
    so that we can see our changes in real time. So, let's open up the file and delete
    everything inside the `main` function besides the main `View` component. Keep
    the styles—I love having everything centered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s import our newly created component and render it on the screen.
    We''ll go right below our main imports and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve imported the component, place it inside the `View` component
    like this: `<NewsCard />`. Start up the Expo server, open the simulator, and you
    should be able to see the card with the text **News Card** on it. Great! Now,
    we can work on it—save the file and see the changes in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, we'll add each component we're creating in our `App.js` file. This
    should be a pretty easy workflow to test our components visually.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to our `NewsCard.js` file and start creating the basic layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by arranging the layout with `Block` components, so we''ll use
    two of these. The first one is for the header of our card, which will contain
    the `bookmark` icon to the far right of the card, and to the left side, we''ll
    have the avatar and information about the author. The second one is for the title
    of the news article and a summary of the text. Let''s see how that looks right
    now by putting it into practice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Coding the basic layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.03_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Coding the basic layout
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as far as you can see, for `title`, `summary`, `author`, and `date`, we''ll
    be using `props`. As for `Avatar`, right now we''ll be using a `Text` component
    as a placeholder. So, let''s save and move to our `App.js` file to finish sending
    all the props back to our `NewsCard` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – App.js file with props completed for our NewsCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.04_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – App.js file with props completed for our NewsCard component
  prefs: []
  type: TYPE_NORMAL
- en: Right—now, we're going to save the `App.js` file and switch to our simulator.
    We should be able to see our `NewsCard` component taking form. There's a title,
    a summary, a date, and even an author. Yeah—I've used `lorem ipsum` for the summary
    because it's easier and quicker than actually creating a summary text for our
    dummy component. We could even start a news feed with our components. But right
    now, let's go back to our `NewsCard` component and add the stuff that we're still
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For sure, there''s a need for us to replace the placeholder we''ve been using
    with an actual `Image` component. So, let''s replace that text with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might remember that an image needs to have some styling attributed to it
    in order to render. Let's go to the `styles` object and do all the styling we
    need for our image. I was thinking of having a `width` and `height` value of `30px`
    and a `borderRadius` value of `15px`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the only thing we're missing is going back to our `App.js` file and adding
    the `avatar` prop to our component. Search an image online and paste the link
    in there. Now, refresh everything, and congratulations—we have an image rendered!
  prefs: []
  type: TYPE_NORMAL
- en: I'd say that right now, the only thing we're missing is to add some colors to
    the text, but I'll let you do that on your own. If you haven't coded this at the
    same time as me, worry not—just go to GitHub and search for the `Chapter 08` folder.
    This is going to have all the code we've done until now, and you'll also see how
    I've colored the text. I've also destructured the `props` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how this looks on my simulator so that you can make sure that
    once you clone the repository on GitHub, things look the same way we''ve been
    describing them. You can see the result here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Simulator displaying our finished component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.05_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Simulator displaying our finished component
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty good, right? I'll let you use this component as much as you
    want in your future apps, so don't shy away from reusing your components. The
    next one should be cooler, so let's move on and start building our first profile
    card.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own profile card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A profile card is something any user needs to see inside an app with a user
    system. So, I was thinking of creating a simple profile card that is going to
    display some basic information for our users. The main elements that I feel should
    be displayed are a profile picture and the user's name, email, and phone number.
  prefs: []
  type: TYPE_NORMAL
- en: This will serve us great purpose in an app where maybe we have a list of phone
    contacts and we want to see each contact separately. Now, let's start creating
    our profile card component.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a new file in our `components` folder called `ProfileCard.js`.
    Now, as you read earlier, I've stated which elements this component will be composed
    of. Based on that, let's think of what type of imports we need.
  prefs: []
  type: TYPE_NORMAL
- en: You guessed it! The same imports we've been using in our last component. Now
    that we're sure of what type of imports we need to have, let's write a basic function
    so that we can get something on the screen to see while we start working on the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the component's filename, our main `Block` component should
    be a card, so let's apply the same styling that we applied to our last component.
    We'll change the background color and some values, but this `style` object should
    be mostly the same as the last one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we''ve been writing until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The start of our ProfileCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.06_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – The start of our ProfileCard component
  prefs: []
  type: TYPE_NORMAL
- en: Things look really similar, right? There are some values changed, but this is
    because I feel different colors might suit this card better. It should be of the
    same width as our previous component based on the `"80%"` value we've assigned
    to the `width` property.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go to our `App.js` file and comment out our `<NewsCard />` component
    and import our new component, just like we've done before.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be able to see this small card with no content on our simulator's
    screen. Let's go back to our card and continue adding the rest of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: We should have an icon on the left side of our component, something that the
    user might want to press in order to modify the contents of our component. We'll
    not create the functionality yet, but having an icon there pointing to this functionality
    should be good enough for us.
  prefs: []
  type: TYPE_NORMAL
- en: Below this icon, I feel we should have an avatar and the contact's name centered
    on the card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right below these, the phone number and email should be available for us to
    see. Between those two, I was thinking of having a line dividing the information.
    Why? It just looks better, in my opinion. So, let''s move on to the next step
    and add all the basic components we need for this type of layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Basic layout for our ProfileCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.07_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Basic layout for our ProfileCard component
  prefs: []
  type: TYPE_NORMAL
- en: This sort of layout is really easy to prototype with Galio. As you can see,
    all we're using are `Block` components and we can already center, create rows,
    and define the spaces that each component needs. Again, we're using `props` because
    your job right now is to go back to `App.js` and pass down the `props` to our
    component so that it can render with more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Done? Great! You might be wondering now what''s up with that `<Block />` component
    between the two rows we''ve created. Well, that''ll act as a divider. So, let''s
    write the styling for it and for our `avatar` image. At this point, you can even
    go ahead and add colors for each `Text` component so that you can make this look
    a lot more interesting. I''d probably use white for the text, but any color would
    work as long as you''re happy with it. Let''s check out how our styling looks,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Styling for our divider and avatar'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.08_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Styling for our divider and avatar
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created the styling, let's dive in for a second. The divider
    should be a sort of white line between our `Email` and `Phone` number. So, we've
    used a `Block` component to create a straight line. This should make you realize
    in how many ways you can use a `Block` component. What's up with `hairlineWidth`,
    though? This is defined by React Native as the width of a thin line on the specific
    platform. It is mostly used for creating a division between two elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s save everything and see how it looks on the simulator. The output
    should be similar to what I have right here. Maybe you''ve changed some colors,
    but the layout should look identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Final render of our component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.09_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Final render of our component
  prefs: []
  type: TYPE_NORMAL
- en: This has been a real adventure! We've already created two different components
    and we're not stopping here. I hope you're having fun and following closely with
    some code in front of you. It's always a good idea to recreate everything from
    memory in 2-3 days. Just a cool little exercise you can do to make sure you're
    learning everything that you're reading. Now, let's move forward because the next
    one is going to be really cool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own register form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Register forms are used almost in every app you can think of. You might need
    one, so let's see what's going on when creating a register form. This is pretty
    cool because, on top of creating a nice little register card, we're also going
    to learn something new about inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start how we always start—comment out the previous components from `App.js`
    and create a new file in our `components` folder called `RegisterForm.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We've already created two components, so let's see whether you can start creating
    this on your own. The form in the following screenshot will be the final rendered
    version of our register form. I've chosen to let you look at it before you actually
    start creating it because I think you should be able to achieve a similar result
    on your own without my help. Of course, I'll still help you, but this is a good
    chance to take your time, close the book, and start creating this on your own.
    Check out the following screenshot and start creating on your own!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Final rendered version of our register card'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.10_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Final rendered version of our register card
  prefs: []
  type: TYPE_NORMAL
- en: Looks pretty neat, right? This isn't really hard to create based on what we've
    done until now. So, now that you've taken a look at it, maybe you're already thinking
    about how to start working on this component. That's great! If you're still reading,
    that's also fine because we'll go right ahead and start creating this component.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we've done up to now, we're going to start thinking of what types of
    imports we need to have. We don't need an image anymore, but we do need an `Input`
    and a `Button component`. Worry not about the icons placed inside the inputs—you
    can do that directly from the `Input` component. Galio makes it really easy to
    style and add icons inside your input.
  prefs: []
  type: TYPE_NORMAL
- en: 'I feel that our inputs should look something like this for this specific component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Imports used for our register form'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.11_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Imports used for our register form
  prefs: []
  type: TYPE_NORMAL
- en: Can you already think of how we should be creating the layout for this one?
    We don't need any rows here because all the elements are coming straight down
    in a column. The only `Block` element we'll be using is the one used for creating
    the card itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing our main function, just like we did before. We need
    a `Block` component with the card styling applied to it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The beginning of our RegisterForm component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.12_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – The beginning of our RegisterForm component
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go into our `App.js` file and comment out our previous components
    so that we can import our newly created component. We've done this multiple times
    by now, so this should be easy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's continue with our component and quickly go through the layout. As
    we've already done this multiple times, this shouldn't be hard to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We obviously start with a `Text` component, followed by three `Input` components
    and one `Button` component. So, let''s write that down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Our almost completed component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.13_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Our almost completed component
  prefs: []
  type: TYPE_NORMAL
- en: 'OK—so, everything is pretty much what we''ve always done up to now. Let''s
    tackle the new things found here. So, on our third `Input` component, we can see
    two props: `password` and `viewPass`. The first one is for making sure you cannot
    see the password as you write; it transforms your writing into those dots we so
    often see whenever we''re typing out our password somewhere. The second one is
    there to display that icon on the right, which the user can press in order to
    see whether there''s something wrong with the password they just typed, basically
    transforming the dots into letters and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Button` component also has that `shadowless` prop, which does exactly
    what you''d think: it makes the button shadowless.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, here comes the interesting part. Of course, we'd like to know what the
    user is typing; how else are we going to verify that the information is correct
    or even typed the way we want it to be typed? Maybe you asked for the user's email,
    but what if the typed words are some random words just to break into the app without
    actually registering? So, there must be some way we can make sure that we know
    what the user has typed and verify that text once the user presses the **Register
    now** or **Submit** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is called **controlled components**. A controlled component takes
    its current value through props and sends any changes through callbacks. A parent
    component "controls" it by handling the callback and managing its own state and
    then passing the new state values as props to the controlled component.
  prefs: []
  type: TYPE_NORMAL
- en: In most—or even all—cases, you should use controlled components when we're dealing
    with forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re in a functional component, we''ll be using **hooks** for our
    states. Don''t forget to import the `useState` hook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Hooks used inside our functional component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.14_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Hooks used inside our functional component
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty easy as we''ve already learned about hooks and a component''s
    state. Now, let''s apply our states to our `Input` components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – State applied to our Input components'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.15_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – State applied to our Input components
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly happens here? Once the user presses on an **input** and starts
    writing their name or email, for example, our `onChangeText` prop triggers our
    `setName` prop, which sets the `name` state variable to the current value of our
    input. This way, we're making sure that our `RegisterForm` component is *controlling*
    the *inputs* and is constantly updated with information about our input's state.
  prefs: []
  type: TYPE_NORMAL
- en: It might be somewhat hard for some people to grasp why we need it. The truth
    is this is how React is making sure that there won't be any errors related to
    our input's state, while also giving us full control and knowledge of our input's
    current state at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's write a simple verification for our form. We need to at least have
    a message for our users popping up in case there's nothing written there and the
    user presses the **Register now** button.
  prefs: []
  type: TYPE_NORMAL
- en: So, we'll create a function called `registerButton`. You can name it however
    you want, but I called it this because it made sense to me. This function will
    verify the length of our input's value. Now, if we weren't having this controlled
    component, we wouldn't have been able to access those values via normal variables.
    We might have to use something called `refs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is mostly beside the point as we''re not going to learn about `refs`,
    but it''s important to know that there is something called `refs`. Let''s take
    a look at this `registerButton` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Our form verification function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.16_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Our form verification function
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this function, we just have to call it whenever the user presses
    the **Register now** button, so we''re going to use the `onPress` prop on our
    `Button` component. Go ahead and apply this prop to our `Button` component, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, save and refresh the app and try it out! Pretty cool, right? There's a
    message popping up whenever you try to press the button with no text inside the
    inputs, while there's also another cool message where we're using the values written
    in our inputs.
  prefs: []
  type: TYPE_NORMAL
- en: This wasn't a hard component to be created but we've learned about something
    really cool, and that's *controlled components*. I hope this little exercise managed
    to successfully teach you something new that you'll be using quite often from
    now on whenever working with forms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished with this component, let's move ahead and start working
    on a different component involved with e-commerce mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building your e-commerce cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, whenever you buy something online, there's always a basket full
    of the products you've chosen. Each item in that basket is usually a card with
    information about the price, the item's name, a picture, and the possibility to
    increase or decrease the number of items of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is what we''re going to create as well. Let''s take a look at it here,
    as we''ve already become so advanced that we should now be able to think of ways
    of creating the functionality with only those things that we''ve learned up to
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Final rendered version of our e-commerce card'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.17_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Final rendered version of our e-commerce card
  prefs: []
  type: TYPE_NORMAL
- en: Looks pretty good, right? Honestly, it isn't even that hard to build, so we'll
    be moving quickly through the layout. Let's create a new file called `CommerceCard.js`
    inside the `components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s think about which types of imports we''d need for this one—obviously,
    a `Block` and `Text` component. We''ll also need to import the `Icon` component
    because, as we can see in *Figure 8.17*, we have a minus button and a plus button
    there. To make those buttons clickable, we''ll be using a `react-native` component
    called `TouchableOpacity`, so let''s import that as well. On top of that, as we
    can all see, we also have an `Image` component. Let''s see what all of our imports
    look like, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – The imports we''ll be using for creating a CommerceCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.18_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – The imports we'll be using for creating a CommerceCard component
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also imported `useState` because the number will change based on which
    icon we''re pressing. So, let''s start creating our functional component now,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Our component''s layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.19_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Our component's layout
  prefs: []
  type: TYPE_NORMAL
- en: That doesn't look that hard to read, right? Let's explain some of it because
    we've moved a bit faster right now. But this is because I feel like you've advanced
    quite a bit, so you should just try to challenge yourself and see whether what
    you think matches with the component that I've written and we've seen in *Figure
    8.17*.
  prefs: []
  type: TYPE_NORMAL
- en: As far as we can see, we can have a big `Block` component containing everything
    and making the content inside in a row. The first element in the row is our image.
    After that, we have another `Block` component with the prop of `flex`, which is
    basically telling our component to take as much space as it can.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that `Block` component, we have a `Text` component that receives the
    name of the item as a prop called `itemName`. We then have another `Block` component
    with the `row` prop applied, which will be used to separate the price and the
    quantity, both of which are going to be state variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what the styling looks like—trust me, the styling is a piece
    of cake. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Styling for our component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.20_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Styling for our component
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the styling we're using here is really not that complicated.
    So, let's get on with the logic behind how this component works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, I''ve said we''re going to use the state for our price
    and quantity, so let''s initialize our state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Initializing state for our component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.21_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Initializing state for our component
  prefs: []
  type: TYPE_NORMAL
- en: Now, I was thinking, we could pass the price via a prop; that way, this component
    is more reusable for future cases. Because this is done via a prop, we should've
    used a life cycle function, as if we were writing a class component as this is
    a functional component—and, as we remember, we can use `useEffect` instead of
    a life cycle function. So, let's import `useEffect` at the same place where `useState`
    is imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we should write the `useEffect` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – useEffect function used to initialize the price state variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.22_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – useEffect function used to initialize the price state variable
  prefs: []
  type: TYPE_NORMAL
- en: So, when `useEffect` gets called, the `setPrice` function inside of it will
    get called, which is going to set our `price` state variable to whatever number
    the prop is sending. But what's with the `[props.price]` argument used as the
    second argument for our `useEffect` function?
  prefs: []
  type: TYPE_NORMAL
- en: This tells our `useEffect` function to get called only when the `props.price`
    variable gets changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've initialized our `price` variable, let's change the price based
    on the quantity. How should we do that? I've written a function called `quantityMath`
    that receives a string variable named `action` that will tell our function whether
    the quantity should be dropping or rising.
  prefs: []
  type: TYPE_NORMAL
- en: As we all know, when we're shopping online, every item in our basket has a plus
    and a minus that, whenever pressed, either increments the quantity with one or
    decrements with one. Based on this, we calculate the total price of that item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at this function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – quantityMath function used to calculate the final price'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.23_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – quantityMath function used to calculate the final price
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created this function, let''s make sure that when our user
    presses the buttons, this function is getting called. `TouchableOpacity` is a
    component used to make other components pressable. So, let''s go to one of the
    `TouchableOpacity` components and change the `onPress` prop to `{() => quantityMath("minus")}`.
    Of course, we''ll use `minus` for the minus icon and `plus` for the plus icon
    as an argument for our `quantityMath` function. Let''s take a look at how that
    looks in our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – Implementing the quantityMath function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.24_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – Implementing the quantityMath function
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our component is finished, let''s go inside our `App.js` file and test
    it out. Comment out the previous component and let''s import our newly created
    component. Now, let''s add this component to our main function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – Main app function with our CommerceCard component inside of
    it'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_8.25_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – Main app function with our CommerceCard component inside of it
  prefs: []
  type: TYPE_NORMAL
- en: Save all files, refresh the app, and you should see our card. Go ahead and start
    playing with the plus and minus buttons, and you'll see how everything accurately
    changes based on the quantity you want.
  prefs: []
  type: TYPE_NORMAL
- en: This was pretty cool, right? We now have a cool little component we can use
    whenever we want to start prototyping for an e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning so much about how React and React Native work, we finally got
    to the point where more practical challenges are getting tackled head-on. We've
    started by creating a simple component, where we mostly focused on styling and
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: That was the easy part, and the first step into our next component was where
    we saw a different example of creating a layout, and we strengthened our brain
    muscles so that we can more easily start prototyping components on our own.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we got into more serious components, and that was the register
    form where we learned a new concept called controlled inputs. This was really
    fascinating as we learned how to actually attack the problem of forms in React
    Native.
  prefs: []
  type: TYPE_NORMAL
- en: Our next component was even cooler as we used the `useEffect` function to initialize
    one of our state variables with a prop received by our component. Now, that's
    some seriously cool stuff, and I hope you got as excited as I did when I first
    discovered the function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done more practical challenges, it's time to think about how
    debugging works so that we can make sure we know how to properly find out what's
    wrong with our component. We'll also learn about some limitations with debugging
    when it comes to React Native. Let's move on with this cool adventure and get
    closer to creating our own cross-platform mobile applications.
  prefs: []
  type: TYPE_NORMAL
