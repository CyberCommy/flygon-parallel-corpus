- en: Getting to Know PyOpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometrical shapes and figures play a vital role in game development. We tend
    to neglect their importance when it comes to the development of advanced graphics
    technologies. However, many popular games still use these shapes and figures to
    render game characters. Mathematical concepts such as transformations, vectored
    movements, and ZOOM IN and ZOOM OUT capabilities add weight when it comes to the
    manipulation of game objects. Python has several modules to support such manipulations.
    In this chapter, we are going to learn about one such powerful Python feature—the PyOpenGL
    module.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring PyOpenGL, we will learn how to create complex geometrical shapes
    using primitives (that is, vertices and edges). We will start by installing Python
    PyOpenGL and start drawing with it. We will make several objects, such as triangles
    and cubes, with it. We won't be using pygame to create such shapes; instead, we
    will use pure mathematical concepts for defining rectangular coordinate points
    for vertices and edges. We will also explore different PyOpenGL methods such as
    clipping and perspective. We will cover each of them to gain knowledge about how
    PyOpenGL can be used to create appealing game characters.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the traditional and mathematical
    ways of creating primitives. This way of creating shapes provides programmers
    and designers with the ability to manipulate their game objects and characters.
    You will also learn how to implement ZOOM-IN and ZOOM-OUT capabilities in the
    game, as well as how to use color properties by drawing geometric primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PyOpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making objects with PyOpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PyOpenGL methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding color properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following list of requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame editor (IDLE) version 3.5+ is recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need the Pycharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oJMfLM](http://bit.ly/2oJMfLM)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PyOpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, graphical programs containing three-dimensional scenes that had
    been processed with 3D-accelerated hardware was something every game programmer
    wanted. Even though this is normal by today's standards, the hardware is not the
    same as it was years ago. Most of the game's graphics had to be rendered with
    the software that resided in the low-processing devices. Hence, apart from creating
    such scenes, rendering would also take quite a bit of time and would ultimately
    make the game slow. The advent of gaming interfaces, also known as graphics cards,
    created a revolution in the gaming industry; programmers were now only bound to
    making interfaces, animation, and autonomous gaming logic rather than concerning
    themselves with processing power. Hence, games that have been created post-90s
    have richer gameplay and a touch of artificial intelligence (multiplayer games).
  prefs: []
  type: TYPE_NORMAL
- en: It is well-known that graphics cards can handle three-dimensional capabilities
    such as rendering and optimizing scenes. However, to use such features, we need
    a programming interface that communicates between our project and such interfaces.
    The **A****pplication Programming Interface** (**API**) we are going to use in
    this chapter is OpenGL. OpenGL is a cross-platform (the program runs on any machine)
    API that is generally used to render 2D and 3D graphics. The API is analogous
    to libraries that are used to facilitate interaction with a graphics processing
    unit, and it accelerates the graphics rendering method by using hardware-accelerated
    rendering. It comes pre-installed on most machines as part of a graphics driver,
    though you can check its version by using the *GL view* *utility*. Before we start
    writing programs so that we can draw geometrical shapes and figures using PyOpenGL,
    we need to install it on our machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PyOpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if OpenGL is already present on your system, you need to install the PyOpenGL
    module separately so that the required OpenGL drivers and Python frameworks can
    communicate with each other. The Pycharm IDE provides a service that can locate
    Python interpreters and install PyOpenGL, which removes the overhead of installing
    it manually. Follow these steps to install PyOpenGL in the Pycharm IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on File from the top navigation bar and then Settings. Then, hover over
    the left-hand side navigation window and select the project:interpreter option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the current project Python interpreter, that is, Python 3.8+ (followed
    by your project name), and press the to add (+) button from the menu screen next
    to the Interpreter drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for PyOpenGL in the search bar and press the Install package button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, if you want to install PyOpenGL externally, you can download
    it as a Python egg file.
  prefs: []
  type: TYPE_NORMAL
- en: A *Python egg* is a logical structure embodying the release of a specific version
    of a Python project, comprising its code, resources, and metadata. There are multiple
    formats that can be used to physically encode a Python egg, and others can be
    developed. However, a key principle of Python eggs is that they should be discoverable
    and importable. That is, it should be possible for a Python application to easily
    and efficiently find out what eggs are present on a system and ensure that the
    desired eggs' contents are importable.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types of files are bundled together to create Python modules that can
    be downloaded from the **Python Enterprise Application Kit** (**PEAK**) with the
    help of an easy install procedure. To download a Python egg file, you have to
    download the Python `easy_install` module. Go to [http://peak.telecommunity.com/DevCenter/EasyInstall](http://peak.telecommunity.com/DevCenter/EasyInstall)
    and then download and run the `ez_setup.py` file. After successfully installing
    easy install, run the following command in your command shell/Terminal to install
    PyOpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Easy install is not only used for installing PyOpenGL—you can download or upgrade
    a large range of Python modules with its help. For example, the `easy_install`
    SQLObject is used to install SQL PyPi packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, when we need to use packages, we need to import them into our project.
    In this case, you can make a demo project (`demo.py`) to start testing the OpenGL
    project. So that we can use features such as code maintainability and debugging,
    we will make a PyOpenGL project using the Pycharm IDE rather than using Python''s
    built-in IDE. Open any new project and follow these steps to check whether PyOpenGL
    is running or not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing every class of PyOpenGL with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, import the required OpenGL functions using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you should import `pygame` into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the display for your project with the `pygame` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run your project and analyze the result. If a new screen appears, you can continue
    making projects. However, if the prompt says PyOpenGL is not installed, make sure
    to follow the preceding installation procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding four lines are easy to follow. Let's discuss them one by one.
    The first step was quite simple—it tells the interpreter to import PyOpenGL along
    with its multiple classes, which can be used for different functions. Importing
    in such a way reduces the effort of importing each class of PyOpenGL one by one.
    The first import is mandatory as this line imports different OpenGL functions
    that begin with the `gl` keyword. For example, we can use a command such as `glVertex3fv()`,
    which can be used to draw different 3D shapes (we'll cover this later).
  prefs: []
  type: TYPE_NORMAL
- en: The next line of the import statement, that is, `from OpenGL.GLU import *`,
    is used so that we can use commands that start with `glu`, for example, `gluPerspective()`.
    These types of commands are useful in making changes to the view of the display
    screen, along with the objects it rendered. For example, we can make conversions
    such as cropping and clipping using such `glu` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the PyOpenGL GL library, GLU is a Python library that is used to
    explore the relationships within or between related datasets. They are mostly
    used to make changes on the display screen while affecting the shapes and dimensions
    of the rendered objects. To learn more about the internals of GLU, check out its
    official documentation page: [http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html](http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The next line simply imports `pygame` into our project. While the surface that
    was created using OpenGL is 3D, it needs the `pygame` module to render it. Before
    using any commands from the `gl` or `glu` modules, we need to call the `pygame`
    module to create a display using the `set_mode()` function (feel the power of
    the `pygame` module). The display that's created by the `pygame` module will be
    3D rather than 2D while using the `set_mode` function with the OpenGL library.
    After this, we are telling the Python interpreter to create an OpenGL surface
    and return it as a `window_screen` object. The tuple (`height`, `width`) that's
    passed inside the `set_mode` function represents the surface size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final step, I want you to focus on the optional parameters, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HWSURFACE`: It creates the surface in the hardware. It is primarily used for
    creating an accelerated 3D display screen, but it is only used in FULL SCREEN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPENGL`: It makes a suggestion to pygame regarding the creation of an OpenGL
    rendered surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOUBLEBUF`: It stands for double buffering, and is recommended for `HWSURFACE`
    and `OPENGL` by pygame. It reduces the flickering (the phenomena of burning and
    shining colors in the screen unsteadily).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few more optional parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FULLSCREEN`: This will make the display of the screen rendered to a  fullscreen
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESIZABLE`: This allows us to resize the window screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOFRAME`: This will make the window screen borderless, controlless, and so
    on. For more information regarding pygame optional parameters, please go to [https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have started installing PyOpenGL on our machine and set a window
    for screen objects, we can start drawing objects and primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Making objects with PyOpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL is primarily known for drawing different geometrical shapes or primitives,
    all of which can be used in the creation of scenes for a 3D canvas. We can make
    multiple-sided shapes (polygons), such as a triangle, quadrilateral, or hexagon.
    Several pieces of information, such as vertex and edges, should be given to the
    primitives so that PyOpenGL can render them accordingly. Since the information
    that's related to the vertex and edges is different for each shape, we have different
    functions to create different primitives. This is different compared to pygame's
    2D function (`pygame.draw`), which was used to create multiple shapes using the
    same single function. For example, a triangle has three vertices and three sides,
    whereas a quadrilateral has four vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a mathematical background, knowledge of vertices and edges will
    be a piece of cake for you. But for those of you who are not, the vertices of
    any geometrical shapes are the corners or points in which two or more lines meet.
    For example, a triangle has three vertices. In the following illustration, **A**,
    **B**, and **C** are vertices of the triangle ABC. Similarly, edges are the line
    segments on the boundary joining one vertex to another. In the following triangle,
    AB, BC, and AC are edges of the triangle ABC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26d029c3-1800-45d8-aedd-b1a92e547f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To draw such geometrical shapes with PyOpenGL, we need to start by invoking
    some basic OpenGL primitives, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, call the `glBegin()` function with any of the primitives you want
    to draw. For example, `glBegin(GL_TRIANGLES)` should be invoked to inform the
    interpreter about the triangular shapes we are going to draw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next piece of information regarding the vertices (A, B, C) is critical for
    drawing shapes. We send information regarding the vertices using the `glVertex()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apart from information about vertices and edges, you can provide additional
    information, such as the color of the shapes, using the `glColor()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After providing enough essential information, you can invoke the `glEnd()` method
    to inform OpenGL that enough information has been provided. Then, it can start
    drawing the specified shapes, as indicated by the constants that are provided
    by the `glBegin` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is the pseudocode for drawing triangular shapes using PyOpenGL
    (reference the preceding illustration to understand the operation of PyOpenGL
    functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustration shows the normal of the triangle. A normal is a
    mathematical term that means a unit vector (has a magnitude of 1 and has a direction—please refer
    to [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml), *Upgrading the Snake
    Game with Turtle*, to find out more about vectors). This piece of information
    (normal) is essential because it tells PyOpenGL where each vertex resides. For
    example, `glVertex3f(0, 1, 0)` will put a vertex on the *y*-axis. Therefore, (*x*,
    *y*, *z*) represents the magnitude in the *x*-axis, *y*-axis, and *z*-axis, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cfe2348d-185f-47f9-b2b2-73ed7cdd6841.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we know how to create basic triangular primitives, let''s take a look
    at the following table to understand the other different types of primitives that
    can be drawn using PyOpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constants keywords** | **Shapes** |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_POINTS` | Draws dots or points to the screen |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINES` | Draws lines (individual ones) |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLES` | Draws triangles |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_QUADS` | Draws quadrilaterals (four-sided polygons) |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_POLYGON` | Draws polygons (any edges or vertices) |'
  prefs: []
  type: TYPE_TB
- en: 'We are now capable of drawing any primitives using primitive constants, provided
    that we have information about their vertices. Let''s create the following quadrilateral:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3ae798eb-a9ce-4cdf-804d-e163c4c08409.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the pseudocode for drawing the preceding cube primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we started by defining the `GL_QUADS` constants
    to inform PyOpenGL about the name of the primitives we are drawing. Then, we added
    the color attributes with the `glColor` method. Similarly, we defined the four
    primary vertices of the cube using the `glVertex` method. The coordinates that
    were passed as an argument to the `glVertex` method represent the *x*, *y,* and
    *z*-axes in the plane.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to draw different geometrical shapes using PyOpenGL, let's
    learn about the different rendering functions/premiers of PyOpenGL so that we
    can make other complex structures.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PyOpenGL methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is well-known that a computer screen has a two-dimensional view (its height
    and width). In order to display the three-dimensional scene created by OpenGL,
    the scene must go through several matrix transformations, which are commonly known
    as projections. This allows the 3D scene to be rendered in a 2D view. Among the
    various transformation methods, two are commonly used for projections (clipping
    and normalization). These matrix transformations are applied to the 3D coordinate
    system and reduced to a 2D coordinate system. The `GL_PROJECTION` matrix is frequently
    used for performing the transformation associated with projections. The mathematical
    deduction of projection transformation is another story and we are never going
    to use those, but understanding how it works is important for any game programmer.
    Let''s go over how `GL_PROJECTION` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clipping**:This transforms the coordinates of the vertex of the scene to
    the clip coordinates of the scene. Clipping is a process that resizes the length
    of the scene so that some parts are clipped from `viewport` (a window display).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normalization**:This process is known as **Normalized Device Coordinates** (**NDC**),
    which transforms the clip coordinates into device coordinates by dividing by the
    `w` components of the clipping coordinates. For instance, the clip coordinates
    x[c], y[c], and z[c] are tested by comparing with w[c]. Vertices that does not
    lie in the range of -w[c] to +w[c] are discarded. Here the subscript *c* represents
    the clipping coordinate system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, it is easier to infer that the process of matrix transformation, including
    `GL_PROJECTION`, includes two steps: clipping, which is immediately followed by
    normalization to device coordinates. The following diagram illustrates how clipping
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4af7b0fe-7069-405c-9ba1-131b483d844d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly observe that the process of clipping (sometimes called culling)
    is only performed in the clipping coordinates, which are defined by the size of
    the 2D viewport. To find out which clip coordinates have been discarded, we need
    to look at an example. Let's assume that *x*, *y*, and *z* are clipping coordinates
    and that their values are compared with the coordinates of *w *(*x*, *y*), which
    decides whether any vertex (or part of shapes) remains in the screen or discarded.
    If any of the coordinates lie below the value of -w[c] and above the value of
    +w[c], that vertex is discarded. In the preceding diagram, vertex A lies above
    +w[c] while vertices B and C lie below -w[c], and so both vertices are discarded.
    Moreover, vertices D and E lie within the value of (-w[c], +w[c]), and so they
    remain in the view. The value of w[c] is determined by the width of the viewport.
    Hence, the projection matrix of OpenGL (`GL_PROJECTION`) takes the 3D coordinates
    and performs projection, which converts it into 2D coordinates that can be rendered
    into the 2D computer display screen. Although some information might be lost,
    it is considered one of the most effective methods of rendering 3D scenes into
    a 2D screen.
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet, though—after projection is performed, we have to convert
    the 3D scene into 2D, which requires the use of another OpenGL matrix transformation
    known as `GL_MODELVIEW`. The step of this transformation is, however, quite different.
    Firstly, matrix transformation is done, which multiplies the coordinate system
    by *view distance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert them into 2D components, *z*-components is provided for each of
    them. To understand the model-view matrix, we have to understand the two matrices
    that are a part of its composition: the model matrix and the view matrix. The
    model matrix performs several transformations such as rotation, scaling, and translations
    in the model world, whereas the view matrix adjusts the scene that''s relative
    to the camera''s position. The view matrix takes care of what the object looks
    like to the player who is watching the scene, something like the first player
    character screen/viewpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are aware of the transformation matrices of OpenGL, let''s make
    a simple program (`resize.py`) that can resize the display accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing OpenGL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a simple function, `change_View()`, that takes the size of the display
    screen, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that''s stated in from *Step 3* to *Step 6* should be added inside
    the `change_View()` function. Add a function call to `ViewPort`, which takes the
    initial values and size of the display as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to add a projection matrix. To add `GL_PROJECTION`, we have
    to call the `glMatrixMode()` method, which checks the mode of matrices being called,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after applying the projection matrix, two important methods should
    be invoked, that is, `glLoadIdentity()` and `gluPerspective()`, which set the
    "touchstone" for the projection matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the projection matrix, the next step is to set the model-view
    matrix. The model view matrix mode can be activated by calling the `GL_MODELVIEW` transformation
    matrix with the `glMatrixMode()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding six steps show us how we can resize the display screen in which
    a 3D scene is displayed in a 2D display screen. *Step 1* and *Step 2* are focused
    on importing openGL. In *Step 3*, we called the `glViewport()` method and passed
    an argument that ranges from (`0`, `0`) to (`width`, `height`), which informs
    OpenGL that we want to use the entire screen to display the scene. The next step
    calls the `glMatrixMode()` method, which tells OpenGL that every matrix transformation
    will apply the projection matrix in every successive function call.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* calls two new methods which, as the `glLoadIdentity()` signature states,
    are used to make the projection matrix identity, which means that all of the coordinates
    of the projection matrix should be changed to `1`. Eventually, we call another
    method, `gluPerspective()`, which sets the categorical/standard projection matrix.
    You may have noticed that the `gluPerspective()` method starts with `glu` and
    not `gl`; hence, this function is called from the GLU library. Four float arguments
    are passed with the `gluPerspective` method, that is, the field perspective of
    the camera viewpoint, the aspect ratio, and two clipping plane points (near and
    farther). Hence, clipping is done via the `gluPerspective` function. To observe
    how clipping is done, refer to the example of star geometrical shape that we discussed
    at the beginning of this topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to put what we've learned to the test by making a program that
    interacts with PyOpenGL structures. We will also define another attribute that
    will make objects more appealing. This is known as *c**olor properties*. We will
    define a cube, along with mathematical information regarding vertices and edges.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding color properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In real-world scenarios, there are profuse amounts of colors associated with
    objects, but computer devices are not intelligent or capable enough to distinguish
    and capture all of them. Hence, to accommodate every possible color in digital
    form is nearly impossible. Due to this, scientists have provided us with a way
    to represent different colors: the *RGB* pattern. This is a combination of three
    major color components: red, green, and blue. Combining these components, we can
    create almost every color possible. The value of each component ranges from 0
    to 255; changes to each component''s code results in a new color.'
  prefs: []
  type: TYPE_NORMAL
- en: The color properties that are used in OpenGL are quite similar to the real-world
    color reflection property. The color of the object that we observe is not actually
    its color; rather, it is the color that's reflected by the object. The object
    can have some properties of a wavelength, in which the object can absorb a certain
    color and might reflect a different one. For example, trees absorb sunlight except
    for green. We perceive and assume that it is green, but actually objects have
    no color. This concept of light reflection is fairly applied in OpenGL—we usually
    define a light source that might have a definite color code. Furthermore, we will
    also define the object's color code and then multiply it with the light source.
    The resultant color code or light is the result of reflection from the object,
    which is considered the color of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of OpenGL, color is given in the form of a tuple containing four
    components in which three are red, green, and blue. The fourth component represents
    alpha information, which indicates the level of transparency of the object. Instead
    of providing values of 0 to 255 for RGB components, we provide a value ranging
    from 0 to 1 in the case of OpenGL. For example, yellow is a combination of red
    and green, and so its alpha information is (1, 1, 0). Refer to [https://community.khronos.org/t/color-tables/22518](https://community.khronos.org/t/color-tables/22518)
    to find out more about OpenGL's color code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions/features are available in OpenGL''s color properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`glClearColor()`: This function sets a clear color, which means that it fills
    the color on a part of the area that hasn''t been drawn. The value of the color
    code can be given as a tuple containing a value ranging from 0 to 1\. For example,
    `glClearColor(1.0, 1.0, 1.0, 0.0)` represents filling with white.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glShadeModel()`: This function enables the lightening features of OpenGL.
    Usually, the argument that''s passed to `glShadeModel` is `GL_FLAT`, which is
    used for shading the faces or edges of shapes such as cubes and pyramids. If you
    want to shade curved objects rather than faceted ones, you can use `GL_SMOOTH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glEnable()`: This is not actually a method related to color properties, but
    it is used to enable them. For instance, `glEnable(GL_COLOR_MATERIAL)` will enable *materials*,
    which allows us to interact with the surface and light source. Furthermore, by
    adjusting the settings, the properties of the materials are mostly used to make
    any object lighter and sharper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are familiar with the concepts of color properties and ways of creating
    color attributes, let's make a simple program that will draw a cube using the
    color properties of PyOpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to code, it's always good practice to brainstorm a little bit
    and acquire the necessary information so that we can create a program. Since we
    are going to create a program that will render a cube—a surface that has eight
    vertices, 12 edges, and six faces—we need to define such information explicitly.
    We can define each of these attributes as nested tuples—tuples inside a single
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking one vertex as a reference, we can simultaneously get the positions of
    other vertices. Let''s assume that a cube has one vertex at (`1`, `-1`, `-1`).
    Now, assuming that all of the edges of a cube have a length of 1 unit, we can
    get the coordinates of the vertices. The following code shows a list of the vertices
    of the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, there are 12 edges (edges are the lines that are drawn from one
    vertex to another). Since there are eight vertices ( 0 to 7), let''s write some
    code that defines the 12 edges using eight vertices. The identifiers that are
    passed as tuples in the following code represent the edges or sides that are drawn
    from one vertex to another. For example, tuple (`0`, `1`) indicates the edge that
    was drawn from vertex 0 to vertex 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last piece of information that must be provided is about surfaces.
    A cube has six faces, each of which contains four vertices and four edges. We
    can provide this information like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order in which the vertices, edges, and surface are provided matters.
    For example, in the `cube_Surfaces` data structure, if you swapped the second
    item of the tuple with the first one, the shape of the cube will deteriorate.
    This is because each piece of information is linked with vertex information, that
    is, surface (`0`, `1`, `2`, `3`) contains the first, second, third, and fourth
    vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished brainstorming and gathered some useful information about
    the shape we are going to draw, it's time to start rendering the cube using PyOpenGL
    and its library, which is often referred to as the *GLU library*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GLU library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve collected information about the edges, sides, and vertices
    of our shape, we can start coding the model. We have already studied how we can
    draw shapes with OpenGL using methods such as `glBegin()` and `glVertex3fv()`.
    Let''s use them and create a function that can draw a cube structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing OpenGL and the GLU library. Right after importing the library,
    add the information we acquired regarding the vertices, edges, and surfaces that
    we defined while brainstorming to the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the function and fetch the surfaces and vertex. This process is
    quite simple; we will start by drawing the surfaces for the cube. We should use
    the `GL_QUADS` property to draw four-sided surfaces (confused? Refer to the *Making
    objects with OpenGL* section of this chapter for more information):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, inside the `renderCube()` method, write some code that can draw a
    line segment. The `GL_LINES` parameter is used to draw a line segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This three-line procedure is enough to create even complex geometrical shapes.
    Now, you can perform multiple operations on these cubes. For example, you can
    perform operations such as the rotation of objects by using mouse trackpads. As
    we know, handling such user events requires a `pygame` module. Hence, let''s define
    a function that will take care of event handling, along with some of the characteristics
    of PyOpenGL. Begin your code with the `import pygame` statement and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is quite simple to understand since we have been
    doing this from the beginning of this chapter. Here, we've used the `pygame` module,
    which sets the game screen with an OpenGL scene or interface. We have added a
    transformation matrix, which performs clipping using the `gluPerspective()` function.
    Finally, we added the initial position of the cube before actual rotation (where
    we might be at the beginning).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have addressed the basic primers of OpenGL, let''s use pygame''s
    event handling method to manipulate the structure of the cube, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After handling the events that are based on mouse button navigation, let''s
    use some of the methods provided by PyOpenGL to render the cube. We will use methods
    such as `glRotatef()`, which will perform matrix transformation. Write the following
    code just after where we handled the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted part of the preceding code denotes a resize transformation,
    which ultimately leads to the ZOOM-UP and ZOOM-DOWN features being used. Now,
    you can run the program and observe the cube being rendered at the center of the
    pygame screen, in yellow. Try using an external mouse and using the navigation
    buttons (buttons 4 and 5) to zoom in and zoom out. You can also observe how clipping
    is used in the project: whenever we make a cube so big that it exceeds the clipping
    plane, some parts of the cube are removed from the viewport.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can combine two powerful Python gaming modules, that is, *pygame*
    and *PyOpenGL*, to make 3D scenes and interfaces. We have only skimmed the ways
    of creating some shapes and how to transform them. Now, it's up to you to discover
    more about PyOpenGL and try to make a game that's much more user-friendly and
    attractive by providing rich textures and content.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered many interesting topics in this chapter, mostly regarding surfaces
    and geometrical shapes. Although we used the term *matrix* in this chapter, we
    didn't bother performing matrix computation using a mathematical approach because
    Python has everything built-in to perform such operations. Still, we should remember
    the old adage, *game programmers don't need to have a PhD in mathematics*, since
    knowing a basic level of math is enough if we want to make games. Here, we only
    learned about translation, scaling, and rotation, which are enough if we want
    to make a 3D scene. We didn't get bogged down by learning about the concepts of
    translations or scaling using the mathematical approach—instead, we learned about
    using the programming approach.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by learning how to set up the OpenGL display screen by using
    pygame's `setting` method. Since OpenGL is a vast and profound field of study,
    covering everything in a single chapter was impossible. Hence, we only covered
    how to load/store three-dimensional models and how to apply them to the OpenGL
    rendering surface by applying clipping, rotate, and resize transformations. We
    also studied color properties and used them with PyOpenGL and pygame. The main
    goal of this chapter was to make it easier for you to understand how to create
    3D shapes using OpenGL 3D scenes while providing critical geometrical information
    such as vertices, edges, and surfaces. You will now be able to work with OpenGL
    to create 3D shapes, figures, and visuals. You now also know how to distinguish
    the color property of OpenGL from any other coloring patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about another important module, which goes
    by the name of *Pymunk*. This is a very powerful physics library that adds physics
    capabilities for game characters. We will learn about the different terms that
    are used when we need to talk about real-world environments, such as velocity
    and acceleration, which are used to handle collisions and the movement of game
    characters. While learning about these concepts, we will also be making an Angry
    Bird game, which we will deploy across various platforms.
  prefs: []
  type: TYPE_NORMAL
