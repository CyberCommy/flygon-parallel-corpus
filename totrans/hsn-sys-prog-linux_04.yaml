- en: Dynamic Memory Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into a key aspect of system programming on a
    modern OS—the management of dynamic (runtime) memory allocation and deallocation.
    We'll first cover the basic glibc APIs used to allocate and free memory dynamically.
    We'll then move beyond these basics, examining the program break within the VAS
    and the behavior of `malloc(3)` under differing circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then immerse the reader in a few advanced discussions: demand-paging,
    memory locking and protection, and the usage of the `alloca` API.'
  prefs: []
  type: TYPE_NORMAL
- en: Code examples provide the reader with an opportunity to explore these topics
    in a hands-on manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic glibc dynamic memory-management APIs and their correct usage in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program break (and its management via the `sbrk(3)` API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal behavior of `malloc(3)` when allocating differing amounts of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The demand-paging concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory region protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `alloca (3)` API alternative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The glibc malloc(3) API family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*,
    we learned that there are regions or segments meant for the use of dynamic memory-allocation within
    the process of **Virtual Address Space** (**VAS**). The **heap segment** is one
    such dynamic region—a free gift of memory made available to the process for its
    runtime consumption.
  prefs: []
  type: TYPE_NORMAL
- en: How exactly does the developer exploit this gift of memory? Not just that, the
    developer has to be extremely careful with matching memory *allocations* to subsequent
    memory *frees*, otherwise the system isn't going to like it!
  prefs: []
  type: TYPE_NORMAL
- en: The **GNU C library** (**glibc**) provides a small but powerful set of APIs
    to enable the developer to manage dynamic memory; the details of their usage is
    the content of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will come to see, the memory-management APIs are literally a handful:
    `malloc(3)`, `calloc`, `realloc`, and `free`. Still, using them correctly remains
    a challenge! The subsequent sections (and chapters) will reveal why this is the
    case. Read on!'
  prefs: []
  type: TYPE_NORMAL
- en: The malloc(3) API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps one of the most common APIs used by application developers is the renowned
    `malloc(3)`*.*
  prefs: []
  type: TYPE_NORMAL
- en: The `foo(3)` syntax indicates that the `foo` function is in section 3 of the
    manual (the man pages) – a library API, not a system call. We recommend you develop
    the habit of reading the man pages. The man pages are available online, and you
    can find them at [https://linux.die.net/man/](https://linux.die.net/man/)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `malloc(3)` to dynamically allocate a chunk of memory at runtime. This
    is as opposed to static—or compile-time – memory-allocation where we make a statement,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, the memory has been statically allocated (at compile-time).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how exactly do you use `malloc(3)`? Let''s check out its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The parameter to `malloc(3)` is the number of bytes to allocate. But what is
    the `size_t` data type? Obviously, it's not a C primitive data type; it's a `typedef
    – long unsigned int` on your typical 64-bit platform (the exact data type does
    vary with the platform; the important point is that it's always unsigned – it
    cannot be negative. On a 32-bit Linux, it will be `unsigned int`). Ensuring that
    your code precisely matches the function signature and data types is crucial in
    writing robust and correct programs. While we're at it, ensure that you include
    the header file that the man page displays with the API signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print a variable of the `size_t` type within a `printf`, use the **`%zu`**
    format specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size_t sz = 4 * getpagesize();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[...]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`printf("size = %zu bytes\n", sz);`'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not delve into the internal implementation details regarding
    how `malloc(3)` and friends actually store, allocate, and free memory (refer the
    *Further reading* section on the GitHub repository.) Suffice to say, the internal
    implementation strives to be as efficient as can be; using these APIs is usually
    considered the right way to perform memory-management.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is a pointer to the zeroth byte of the newly-allocated memory
    region on success, and NULL on failure.
  prefs: []
  type: TYPE_NORMAL
- en: You will come across, shall we say *optimists*, who say things such as, "Don't
    bother checking malloc for failure, it never fails". Well, take that sage advice
    with a grain of salt. While it's true that malloc would rarely fail, the fact
    is (as you shall see), it could fail. Writing defensive code – code that checks
    for the failure case immediately – is a cornerstone of writing solid, robust programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, using the API is very straightforward: as an example, allocate 256 bytes
    of memory dynamically, and store the pointer to that newly allocated region in
    the `ptr` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As another typical example, the programmer needs to allocate memory for a data
    structure; let''s call it `struct sbar`. You could do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hey, astute reader! What about checking the failure case? It''s a key point,
    so we will rewrite the preceding code like so (and of course it would be the case
    for the `malloc(256)` code snippet too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use one of the powerful tracing tools  `ltrace` to check that this works
    as expected; `ltrace` is used to display all library APIs in the process-execution
    path (similarly, use `strace` to trace all system calls). Let''s assume that we
    compile the preceding code and the resulting binary executable file is called
    `tst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly see `malloc(3)` (and the fact that the example structure we used
    took up 592 bytes on an x86_64), and its return value (following the `=` sign).
    The `free` API follows, and then it simply exits.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that the *content* of the memory chunk allocated
    by  `malloc(3)` is considered to be random. Thus, it's the programmer's responsibility
    to initialize the memory before reading from it; if you fail to do so, it results
    in a bug called **Uninitialized Memory Read** (**UMR***) *(more on this in the
    next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary.
    Need larger alignment values? Use the `posix_memalign(3)` API. Deallocate its
    memory as usual with free(3).'
  prefs: []
  type: TYPE_NORMAL
- en: Details can be found on the man page at [https://linux.die.net/man/3/posix_memalign](https://linux.die.net/man/3/posix_memalign).Examples
    of using the `posix_memalign(3)` API can be found in the *Locking memory* and
    *Memory protection* sections.
  prefs: []
  type: TYPE_NORMAL
- en: malloc(3) – some FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some FAQs that will help us to learn more about `malloc(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ 1 : How much memory can `malloc(3)` allocate with a single call?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rather pointless question in practical terms, but one that is often asked!
  prefs: []
  type: TYPE_NORMAL
- en: The parameter to `malloc(3)` is an integer value of the `size_t` data type,
    so, logically, the maximum number we can pass as a parameter to `malloc(3)` is
    the maximum value a `size_t` can take on the platform*.* Practically speaking,
    on a 64-bit Linux, `size_t` will be 8 bytes, which of course, in bits is 8*8 =
    64\. Therefore, the maximum amount of memory that can be allocated in a single
    `malloc(3)` call is `2^64`!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how much is it? Let''s be empirical (it''s important to read in [Chapter
    19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml), *Troubleshooting and Best Practices*,
    and the brief discussion there on *The empirical approach*).and actually try it
    out (note that the following code snippet has to be linked with the math library
    using the `-lm` switch):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, on an x86_64:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`sizeof size_t = 8; max param to malloc = 18446744073709551616`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aha! That''s a mighty large number; more readably, it''s as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2^64 = 18,446,744,073,709,551,616 = 0xffffffffffffffff`'
  prefs: []
  type: TYPE_NORMAL
- en: That's 16 EB (exabytes, which is 16,384 PB, which is 16 million TB)!
  prefs: []
  type: TYPE_NORMAL
- en: So, on a 64-bit OS, `malloc(3)` can allocate a maximum of 16 EB in a single
    call. In theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, there''s more to it: please see *FAQ 2*; it will reveal that the
    *theoretical* answer to this question is **8 exabytes** (8 EB).'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, obviously, this would be impossible because, of course, that's
    the entire usermode VAS of the process itself. In reality, the amount of memory
    that can be allocated is limited by the amount of free memory contiguously available
    on the heap. Actually, there's more to it. As we shall soon learn (in the *How
    malloc(3) really behaves* section), memory for `malloc(3)` can come from other
    regions of the VAS, too. Don't forget there's a resource limit on data segment
    size; the default is usually unlimited, which as we discussed in this chapter,
    really means that there's no artificial limit imposed by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: So, in practice, it's best to be sensible, not assume anything, and check the
    return value for NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, what''s the maximum value a `size_t` can take on a 32-bit OS? Accordingly,
    we compile on x86_64 for 32-bit by passing the `-m32` switch to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, it's 4 GB (gigabytes) – again, the entire VAS of a 32-bit process.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ 2: What if I pass `malloc(3)` a negative argument?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data type of the parameter to `malloc(3)`, `size_t`, is an unsigned integerquantity –
    it cannot be negative. But, humans are imperfect, and **Integer OverFlow** (**IOF**)
    bugs do exist! You can imagine a scenario where a program attempts to calculate
    the number of bytes to allocate, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`num = qa * qb;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if `num` is declared as a signed integer variable and `qa` and `qb` are
    large enough that the result of the multiplication operation causes an overflow?
    The `num` result will then wrap around and become negative! `malloc(3)` should
    fail, of course. But hang on: if the `num` variable is declared as `size_t` (which
    should be the case), the negative quantity will turn into some positive quantity!'
  prefs: []
  type: TYPE_NORMAL
- en: The `mallocmax` program has a test case for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output when run on an x86_64 Linux box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the relevant variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try it with a 32-bit version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that on a default-install Ubuntu Linux box, the 32-bit compile may fail
    (with an error such as `fatal error: bits/libc-header-start.h: No such file or
    directory`*)*. Don''t panic: this usually implies that the compiler support for
    building 32-bit binaries isn''t present by default. To get it (as mentioned in
    the Hardware-Software List document), install the `multilib` compiler package:
    `sudo apt-get install gcc-multilib`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile it for 32-bit and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To be fair, the compiler does warn us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Interesting! The compiler answers our *FAQ 1* question now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The maximum value you can allocate as per the compiler seems to be **`9223372036854775807`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wow. A little calculator time reveals that this is 8192 PB = 8 EB! So, we must
    conclude that  the correct answer to the previous question: *How much memory can
    malloc allocate with a single call?* Answer: *8 exabytes*. Again, in theory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ 3: What if I use `malloc(0)`?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not much; depending on the implementation, `malloc(3)` will return NULL, or,
    a non-NULL pointer that can be passed to free. Of course, even if the pointer
    is non-NULL, there is no memory, so don't attempt to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile and then run it via `ltrace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `malloc(0)` did indeed return a non-NULL pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ 4: What if I use `malloc(2048)` and attempt to read/write beyond 2,048
    bytes?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a bug of course – an out-of-bounds memory-access bug, further defined
    as a read or write buffer overflow. Hang on please, the detailed discussion of
    memory bugs (and subsequently, how to find and fix them) is the subject of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*.
  prefs: []
  type: TYPE_NORMAL
- en: malloc(3) – a quick summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s summarize the key points regarding usage of the `malloc(3)` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc(3)` dynamically (at runtime) allocates memory from the process heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we shall soon learn, this is not always the case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single parameter to `malloc(3)` is an unsigned integer value—the number
    of bytes to allocate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return value is a pointer to the start of the newly allocated memory chunk
    on success, or NULL on failure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must check for the failure case; don't just assume it will succeed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content of the newly allocated memory region is considered to be random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must initialize it before reading from any part of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must free the memory you allocate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The free API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the golden rules of development in this ecosystem is that programmer-allocated
    memory must be freed.
  prefs: []
  type: TYPE_NORMAL
- en: Failure to do so leads to a bad situation – a bug, really – called **memory
    leakage**; this is covered in some depth in the next chapter. Carefully matching
    your allocations and frees is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Then again, in smaller real-world projects (utils), you do come across cases
    where memory is allocated exactly once; in such cases, freeing the memory is pedantic
    as the entire virtual address space is destroyed upon process-termination. Also,
    using the *alloca(3)* API implies that you do not need to free the memory region
    (seen later in, *Advanced features *section). Nevertheless, you are advised to
    err on the side of caution!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `free(3)` API is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void free(void *ptr);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It accepts one parameter: the pointer to the memory chunk to be freed. `ptr`
    must be a pointer returned by one of the `malloc(3)` family routines: `malloc(3)`,
    `calloc`, or `realloc[array]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`free` does not return any value; don''t even attempt to check whether it worked;
    if you used it correctly, it worked. More on free is found in the *Where does
    freed memory go?* section. Once a memory chunk is freed, you obviously cannot
    attempt to use any part of that memory chunk again; doing so will result in a
    bug (or what''s called **UB – undefined behavior**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common misconception regarding `free()` sometimes leads to its being used
    in a buggy fashion; take a look at this pseudocode snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will possibly crash in the loop (within the `<use ''ptr'' here>`
    code) in a few iterations. Why? Because the `ptr` memory pointer is freed and
    is attempting to be reused. But how come? Ah, look carefully: the code snippet
    is only going to `malloc(3)` the `ptr` pointer if it is currently NULL, that is,
    its programmer has assumed that once we `free()` memory, the pointer we just freed
    gets set to NULL. This is not the case!!'
  prefs: []
  type: TYPE_NORMAL
- en: Be wary and be defensive in writing code. Don't assume anything; it's a rich
    source of bugs. Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points)
  prefs: []
  type: TYPE_NORMAL
- en: free – a quick summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s summarize the key points regarding the usage of the *free* API:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter passed to `free(3)` must be a value returned by one of the `malloc(3)`
    family APIs (`malloc(3)`, `calloc`, or `realloc[array]`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free` has no return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `free(ptr)` does not set `ptr` to `NULL` (that would be nice, though).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once freed, do not attempt to use the freed memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not attempt to *free* the same memory chunk more than once (it's a bug –
    UB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, we will assume that freed memory goes back to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Heaven's sake, do not forget to free memory that was dynamically allocated
    earlier. The forgotten memory is said to have *leaked out* and that's a really
    hard bug to catch! Luckily, there are tools that help us catch these bugs. More
    in [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and
    [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for
    Memory Issues*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calloc API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `calloc(3)` API is almost identical to `malloc(3)`, differing in two main
    respects:'
  prefs: []
  type: TYPE_NORMAL
- en: It initializes the memory chunk it allocates to the zero value (that is, ASCII
    0 or NULL, not the number `0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accepts two parameters, not one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `calloc(3)` function signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '` void *calloc(size_t nmemb, size_t size);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter, `nmemb`, is n members; the second parameter, `size`, is
    the size of each member. In effect, `calloc(3)` allocates a memory chunk of `(nmemb*size)`
    bytes. So, if you want to allocate memory for an array of, say, 1,000 integers,
    you can do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the size of an integer is 4 bytes, we would have allocated a total
    of (1000*4) = 4000 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever one requires memory for an array of items (a frequent use case in applications
    is an array of structures), `calloc` is a convenient way to both allocate and
    simultaneously initialize the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Demand paging (covered later in this chapter), is another reason programmers
    use `calloc` rather than `malloc(3)` (in practice, this is mostly useful for realtime
    applications). Read up on this in the up coming section.
  prefs: []
  type: TYPE_NORMAL
- en: The realloc API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `realloc` API is used to *resize* an existing memory chunk—to grow or shrink
    it. This resizing can only be performed on a piece of memory previously allocated
    with one of the `malloc(3)` family of APIs (the usual suspects: `malloc(3)`, `calloc`,
    or `realloc[array]`). Here is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '` void *realloc(void *ptr, size_t size);`'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `ptr`, is a pointer to a chunk of memory previously allocated
    with one of the `malloc(3)` family of APIs; the second parameter, `size`, is the
    new size of the memory chunk—it can be larger or smaller than the original, thus
    growing or shrinking the memory chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick example code snippet will help us understand `realloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The pointer returned by `realloc` is the pointer to the newly resized chunk
    of memory; it may or may not be the same address as the original `ptr`. In effect,
    you should now completely disregard the original pointer `ptr`  and regard the realloc-returned
    `newptr` pointer as the one to work with. If it fails, the return value is NULL
    (check it!) and the original memory chunk is left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key point: the pointer returned by `realloc(3)`, `newptr`, is the one that
    must be subsequently freed, *not* the original pointer (`ptr`) to the (now resized)
    memory chunk. Of course, do not attempt to free both pointers, as that to is a
    bug.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the contents of the memory chunk that just got resized? They remain
    unchanged up to `MIN(original_size, new_size)`. Thus, in the preceding example,
    `MIN(100, 150) = 100`, the contents of memory up to 100 bytes will be unchanged.
    What about the remainder (50 bytes)? It's considered to be random content (just
    like `malloc(3)`).
  prefs: []
  type: TYPE_NORMAL
- en: The realloc(3) – corner cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The pointer passed to `realloc` is `NULL`? The library treats this as equivalent
    to a new allocation – `malloc(150)`; and all the implications of the `malloc(3)` That's
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The size parameter passed to `realloc` is `0`? The library treats this as equivalent
    to `free(ptr)`*.* That's it.
  prefs: []
  type: TYPE_NORMAL
- en: The reallocarray API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A scenario: you allocate memory for an array using `calloc(3)`; later, you
    want to resize it to be, say, a lot larger. We can do so with `realloc(3)`; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Fine. There''s an easier way, though—using the `reallocarray(3)` API. Its signature
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '` void *reallocarray(void *ptr, size_t nmemb, size_t size);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With it, the code becomes simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of `reallocarray` is pretty identical to that of the `realloc`
    API: the new pointer to the resized memory chunk on success (it may differ from
    the original), `NULL` on failure. If it fails, the original memory chunk is left
    untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: '`reallocarray` has one real advantage over `realloc` – safety. From the man
    page on *realloc(3),* see this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Also realize that the `reallocarray` API is a GNU extension; it will work on
    modern Linux but should not be considered portable to other OSes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, consider this: some projects have strict alignment requirements for
    their data objects; using `calloc`(or even allocating said objects via `malloc(3)`)
    can result in subtle bugs! Later in this chapter, we''ll use the `posix_memalign(3)`API—it
    guarantees allocating memory to a given byte alignment (you specify the number
    of bytes)! For example, requiring a memory-allocation to be aligned to a page
    boundary is a fairly common occurrence (Recall, malloc always returns a memory
    region that is aligned on an 8-byte boundary).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line: be careful. Read the documentation, think, and decide which
    API would be appropriate given the circumstances. More on this in the *Further
    reading *section on the GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dig a bit deeper into dynamic memory management with
    the `malloc(3)` API family. Understanding these areas, and the content of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and  [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*,
    will go a long way in helping developers effectively debug common memory bugs
    and issues.
  prefs: []
  type: TYPE_NORMAL
- en: The program break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process or thread wants memory, it invokes one of the dynamic memory
    routines—usually `malloc(3)` or `calloc(3)`; this memory (usually) comes from
    the **heap segment**. As mentioned earlier, the heap is a dynamic segment – it
    can grow (toward higher virtual addresses). Obviously though, at any given point
    in time, the heap has an endpoint or top beyond which memory cannot be taken.
    This endpoint—the last legally reference-able location on the heap – is called
    the **program break**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the sbrk() API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how do you know where the current program break is? That''s easy – the
    `sbrk(3)` API, when used with a parameter value of zero, returns the current program
    break! Let''s do a quick lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see some sample output as follows when the preceding line of code
    runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, but why does the program break value keep changing (seemingly randomly)?
    Well, it really *is* random: for security reasons, Linux randomizes the layout
    of a process''s virtual address space (we covered the process VAS layout in [Chapter
    2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*). This technique
    is called **Address Space Layout Randomization** (**ASLR**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a bit more: we will write a program that, if run without any parameters,
    merely displays the current program break and exits (like the one we just saw);
    if passed a parameter – the number of bytes of memory to dynamically allocate –
    it does so (with `malloc(3)`), then prints the heap address returned as well as
    the original and current program break. Here, you will only be allowed to request
    less than 128 KB, for reasons that will be made clear shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the `ch4/show_curbrk.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Interesting (see the following diagram)! With an allocation of 1,024 bytes,
    the heap pointer that's returned to the start of that memory chunk is `0x1488670`;
    that's `0x1488670 - 0x1488000 = 0x670 = 1648` bytes from the original break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the new break value is `0x14a9000`, which is `(0x14a9000 - 0x1488670
    = 133520)`, approximately 130 KB from the freshly allocated block. Why did the
    heap grow by so much for a mere 1 KB allocation? Patience; this, and more, will
    be examined in the next section, *How malloc(3) really behaves.* Meanwhile, refer
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecb44780-bcc1-448b-9677-5f2fa6f43f36.png)'
  prefs: []
  type: TYPE_IMG
- en: Heap and the Program Break
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that `sbrk(2)` can be used to increment or decrement the program break
    (by passing it an integer parameter). At first glance, this might seem like a
    good way to allocate and deallocate dynamic memory; in reality, it's always better
    to use the well-documented and portable glibc implementation, the `malloc(3)`
    family APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '`sbrk` is a convenient library wrapper over the `brk(2)` system call.'
  prefs: []
  type: TYPE_NORMAL
- en: How malloc(3) really behaves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general consensus it that `malloc(3)` (and `calloc(3)` and `realloc[array](3)`)
    obtains its memory from the heap segment. This is indeed the case, but digging
    a bit deeper reveals that it's not *always* the case. The modern glibc `malloc(3)`
    engine uses some subtle strategies to make the most optimal use of available memory
    regions and the process VAS—which, especially on today's 32-bit systems, is fast
    becoming a rather scarce resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does it work? The library uses a predefined `MMAP_THRESHOLD` variable – its
    value is 128 KB by default – to determine from where memory gets allocated. Let''s
    imagine we are allocating *n* bytes of memory with malloc(n):'
  prefs: []
  type: TYPE_NORMAL
- en: If *n < MMAP_THRESHOLD,* use the heap segment to allocate the requested *n*
    bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n >= MMAP_THRESHOLD*, and if n bytes are not available on the heap's free
    list, use an arbitrary free region of virtual address space to satisfy the requested
    *n* bytes allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How exactly is the memory allocated in the second case? Ah, `malloc(3)` internally
    calls `mmap(2)` – the memory map system call. The `mmap` system call is very versatile.
    In this case, it is made to reserve a free region of n bytes of the calling process's
    virtual address space!
  prefs: []
  type: TYPE_NORMAL
- en: Why use `mmap(2)`? The key reason is that mmap-ed memory can always be freed
    up (released back to the system) in an independent fashion whenever required;
    this is certainly not always the case with `free(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are some downsides: `mmap` allocations can be expensive because,
    the memory is page-aligned (and could thus be wasteful), and the kernel zeroes
    out the memory region (this hurts performance).
  prefs: []
  type: TYPE_NORMAL
- en: The `mallopt(3)` man page (circa December 2016) also notes that nowadays, glibc
    uses a dynamic mmap threshold; initially, the value is the usual 128 KB, but if
    a large memory chunk between the current threshold and `DEFAULT_MMAP_THRESHOLD_MAX`
    is freed, the threshold is increased to become the size of the freed block.
  prefs: []
  type: TYPE_NORMAL
- en: Code example – malloc(3) and the program break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Seeing for ourselves the effect of `malloc(3)` allocations on the heap and
    process virtual address space is interesting and educational. Check out the output
    of the following code example (the source is available in this book''s Git repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are several scenarios running in this application; let's examine some
    of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1 – default options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We run the `malloc_brk_test` program with no parameters, that is, using the
    defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The process prints out its initial program break value: `0x1c97000`. It then
    allocates just 8 bytes (via the `malloc(3)` API); under the hood, the glibc allocation
    engine invokes the *sbrk(2)* system call to grow the heap; the new break is now `0x1cb8000`,
    an increase of 135,168 bytes = 132 KB from the previous break (clearly seen in
    the `delta` column in the preceding code)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Optimization: glibc anticipates that, in the future, the process will
    require more heap space; instead of the expense of invoking a system call (*`sbrk/brk`)*
    each time, it performs one large-ish heap-growing operation. The next two `malloc(3)` APIs
    (numbers 1 and 2 in the left-most column) prove this is the case: we allocate
    4,083 and 3 bytes respectively, and what do you notice? The program break does
    *not* change – the heap is already large enough to accommodate the requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2 – showing malloc statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we pass the `1` parameter, asking it to display `malloc(3)` statistics
    as well (achieved using the `malloc_stats(3)` API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is similar, except the program invokes the useful `malloc_stats(3)`
    API, which queries and prints `malloc(3)` state information to `stderr` (by the
    way, an arena is an allocation area that''s internally maintained by the `malloc(3)`
    engine). From this output, notice that:'
  prefs: []
  type: TYPE_NORMAL
- en: The available free memory – system bytes – is 132 KB (after performing a tiny
    8 byte `malloc(3)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-use bytes increases with each allocation but system bytes remains the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmap` regions and `mmap` bytes is zero as no mmap-based allocations have occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenario 3 – large allocations option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we pass the `2` parameter, asking the program to perform larger
    allocations (greater than `MMAP_THRESHOLD`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (Note that the preceding code we have clipped the output of the first two small
    allocations and only show the relevant large ones).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we allocate 132 KB (point 3 in the preceding output); some thing to take
    note of are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The allocations (#3 and #4) are for 132 KB and 1 MB – both above the `MMAP_THRESHOLD`
    (value of 128 KB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (arena 0) heap *in-use bytes* (5,792) has *not* changed at all across these
    two allocations, indicating that heap memory has *not* been used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The max mmap regions and max mmap bytes numbers have changed to positive values
    (from zero), indicating the use of mmap-ed memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of remaining scenarios will be examined later.
  prefs: []
  type: TYPE_NORMAL
- en: Where does freed memory go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`free(3)`, of course, is a library routine – so it stands to reason that when
    we free up memory, previously allocated by one of the dynamic allocation routines,
    it does not get freed back to the system, but rather to the process heap (which,
    of course, is virtual memory).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are at least two cases where this may not occur:'
  prefs: []
  type: TYPE_NORMAL
- en: If the allocation was satisfied internally via *mmap* rather than via the heap
    segment, it gets immediately freed back to the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On modern glibc, if the amount of heap memory being freed is very large, this
    triggers the return of at least some of the memory chunks back to the OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few advanced features will now be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Demand paging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking memory in RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocation with the *alloca(3)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demand-paging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of us know that if a process dynamically allocates memory, with `malloc`,
    say it does `ptr = malloc(8192) ;`, then, assuming success, the process is now
    allocated 8 KB of physical RAM. It might come as a surprise, but, on modern OSes
    such as Linux, this is actually not the case.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the case? (In this book, we do not delve into kernel-level details.
    Also, as you might be aware, the granularity of memory at the level of the OS
    allocator is a *page*, which is typically 4 KB.)
  prefs: []
  type: TYPE_NORMAL
- en: It's not a good idea to assume anything when writing robust software. So, how
    can you correctly determine the page size on the OS? Use the `sysconf(3)` API;
    for example, `printf("page size = %ld\n", **sysconf(_SC_PAGESIZE)**);`, which
    outputs `page size = 4096`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, use the `getpagesize(2)` system call to retrieve the system
    page size. (Importantly, see [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covering similar points in the section *A
    Programmer’s Checklist: 7 Rules*).'
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, all malloc does is reserve virtual pages of memory from the process
    VAS.
  prefs: []
  type: TYPE_NORMAL
- en: So, when does the process get the actual physical pages? Ah, as and when the
    process actually peeks or pokes any byte in a page, in reality when it makes any
    kind of access on any byte of the page (attempting to read/write/execute it),
    the process traps into the OS – via a hardware exception called a page fault –
    and in the OS's fault handler, if all's well, the OS allocates a physical page
    frame for the virtual page. This highly optimized manner of handing out physical
    memory to processes is called **demand-paging** – the pages are only physically
    allocated when they are actually required, on-demand! This is closely related
    to what OS folks call the memory or VM overcommit feature; yes, it's a feature,
    not a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to guarantee that physical page frames are allocated after a virtual
    allocation you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Do `malloc(3)` followed by `memset(3)` on all the bytes in all pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just use the `calloc(3)`; it will set the memory to zero, thus faulting it in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On many implementations, the second method – using `calloc(3)` – is faster than
    the first.
  prefs: []
  type: TYPE_NORMAL
- en: It's really because of demand-paging that we can write an application that malloc's
    huge amounts of memory and never free's it; it will work as long as the process
    does not attempt to read, write, or execute any byte in any (virtual) page of
    the allocated region. Apparently, there are many real-world applications that
    are quite poorly designed and do exactly this kind of thing – allocate huge amounts
    of memory via `malloc(3)` just in case we need it. Demand-paging is an OS hedge
    against wastefully eating up huge amounts of physical memory that hardly gets
    used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you, the astute reader, will realize that to every upside there's
    probably a downside. In this scenario, this could conceivably happen with several
    processes simultaneously performing large memory allocations. If all of them allocate
    large portions of virtual memory and then want to actually claim those pages physically
    at around the same time, this would put a tremendous amount of memory pressure
    on the OS! And guess what, the OS makes absolutely no guarantee that it will succeed
    in servicing everyone. In fact, in the worst case, the Linux OS will run short
    of physical RAM to the extent that it must invoke a bit of a controversial component –
    the **Out-of-Memory** (**OOM**) Killer – whose job is to identify the memory-hogging
    process and kill it and its descendants, thus reclaiming memory and keeping the
    system alive. Reminds you of the Mafia, huh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the man page on `malloc(3)` clearly notes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If interested, dig deeper with the references in the *Further reading* section
    on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Resident or not?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we clearly understand that the pages allocated by *malloc* and friends
    are virtual and not guaranteed to be backed by physical frames (at least to start
    with), imagine we have a pointer to a (virtual) memory region and we know its
    length. We would now like to know whether the corresponding pages are in RAM,
    that is, whether they are resident or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out there''s a system call available that gives precisely this information:
    `mincore(2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mincore(2)` system call is pronounced m-in-core, not min-core. Co*re *is
    an old word used to describe physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Given the starting virtual address and length, `mincore(2)` populates the third
    parameter – a vector array. After the call successfully returns, for every byte
    of the vector array, if the LSB (Least Significant Bit) is set, it implies that
    the corresponding page *is* resident (in RAM), otherwise it's not (possibly not
    allocated or in swap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage details are available via the `mincore(2)` man page: [https://linux.die.net/man/2/mincore](https://linux.die.net/man/2/mincore).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you should realize that the information returned on page residency
    is merely a snapshot at that point in time of the state of the memory pages: it
    could change under us, that is, it is (or could be) very transient in nature.'
  prefs: []
  type: TYPE_NORMAL
- en: Locking memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We understand that on a virtual memory-based OS, such as Linux, a usermode
    page can be swapped at any point in time; the Linux kernel memory management code
    makes these decisions. To the regular application process, this should not matter:
    any time it attempts to access (read, write, or execute) the page content, the
    kernel will page it back into RAM, and allow it to use it as though nothing had
    occurred. This handling is generally called *servicing a page fault* (there is
    a lot more to it, but for the purpose of this discussion, this is sufficient),
    and is completely transparent to the usermode application process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some situations where memory pages being paged – written
    from RAM to swap and vice-versa – is undesirable:'
  prefs: []
  type: TYPE_NORMAL
- en: Realtime applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography (security) applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In real-time applications, the key factor (at least within its critical code
    paths) is determinism *–* the iron-clad guarantee that the work will take a certain
    worst-case amount of time, and no more, no matter the load on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the real-time process is executing a critical code path and a data
    page has to be paged in from the swap partition at that moment – the latency (delay)
    introduced could ruin the application's characteristics, resulting in dismal failure
    (or worse). In these cases, we, the developers, need a way to guarantee that said
    pages of memory can guaranteed to be resident in RAM, thus avoiding any page faulting.
  prefs: []
  type: TYPE_NORMAL
- en: In some types of security applications, they would likely store some secrets
    in memory (a password, a key); if the memory pages containing these are written
    out to disk (swap), there is always the possibility that it remains on disk well
    after the application exits – resulting in what's called information leakage,
    which is a bug attackers are just waiting to pounce upon! Here, again, the need
    of the hour is to guarantee that those pages cannot be swapped out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `mlock(2)` (and friends: *mlock2* and *mlockall*) system calls; the
    express purpose of these APIs is to lock memory pages within the calling process''s
    virtual address space. Let''s figure out how to use `mlock(2)`. Here is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int mlock(const void *addr, size_t len);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter, `addr`, is a pointer to the (virtual) memory region to
    lock; the second parameter, `len`, is the number of bytes to lock into RAM. As
    a trivial example, take look at the following code (here, to keep it easily readable,
    we don''t show error-checking code; in a real application, please do so!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Limits and privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A privileged process, either by running as *root*, or, better yet, by having
    the `CAP_IPC_LOCK` capability bit set in order to lock memory (we shall describe
    process credentials and capabilities in detail in their own chapters - [Chapter
    7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process Credentials*, and [Chapter
    8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*), can lock
    unlimited amounts of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Linux 2.6.9 onward, for a non-privileged process, it is limited by the `RLIMIT_MEMLOCK` soft
    resource limit (which, typically, is not set very high). Here is an example on
    an x86_64 Fedora box (as well as Ubuntu):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It's just 64 KB (ditto on an embedded ARM Linux, by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, on a recent *Fedora 28* distro running on
    x86_64, the resource limit for max locked memory seems to have been amped up to
    16 MB! The following *prlimit(1)* outputshows just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ prlimit | grep MEMLOCK`'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEMLOCK     max locked-in-memory address space     16777216  16777216 bytes`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hang on a second, though; while using mlock(2), the POSIX standard requires
    that `addr` is aligned to a page boundary (that is, if you take the memory start
    address and divide it by the system page size, the remainder will be zero, that
    is, `(addr % pgsz) == 0`. You can use the `posix_memalign(3)` API to guarantee
    this; so, we can change our code slightly to accommodate this alignment requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following (`ch4/mlock_try.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give it a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the successful cases, the address returned by `posix_memalign(3)`*;*
    it's on a page boundary. We can quickly tell by looking at the last three digits (from
    the right) of the address – if they are all zeroes, it's cleanly divisible by
    page size and thus on a page boundary. This is because the page size is usually
    4,096 bytes, and 4096 decimal = 0x1000 hex!
  prefs: []
  type: TYPE_NORMAL
- en: We request 32 pages; the allocation is successful, but *mlock* fails because
    32 pages = 32*4K = 128 KB; the resource limit is just 64 KB for locked memory.
    However, when we *sudo* it (thus running with root access), it works.
  prefs: []
  type: TYPE_NORMAL
- en: Locking all pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*mlock* basically allows us to tell the OS to lock a certain range of memory
    into RAM. In some real-world cases, though, we cannot predict exactly which pages
    of memory we will require resident in advance (a real-time application might require
    various, or all, memory pages to always be resident).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this tricky issue, another system call – *mlockall(2)* – exists; as
    you can guess, it allows you to lock all process memory pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '` int mlockall(int flags);`'
  prefs: []
  type: TYPE_NORMAL
- en: If successful (remember, the same privilege restrictions apply to *mlockall*
    as to *mlock*), all the process's memory pages *–* such as text, data segments,
    library pages, stack, and shared memory segments – are guaranteed to remain resident
    in RAM until unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *flags* argument provides further control to the application developer;
    it can be bitwise OR of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MCL_CURRENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MCL_FUTURE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MCL_ONFAULT (Linux 4.4 onward)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `MCL_CURRENT` asks the OS to lock all current pages within the calling
    process's VAS into memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you issue the *mlockall(2) *system call at initialization time,
    but the real-time process is going to perform an *malloc* of say, 200 kilobytes,
    5 minutes from now? We need to guarantee that those 200 KB of memory (which is
    50 pages, given a 4 KB page size) is always resident in RAM (otherwise, the real-time
    application will suffer too great a latency from possible future page faulting).
    That is the purpose of the `MCL_FUTURE` flag: it guarantees the memory pages that
    become part of the calling process''s VAS in the future will remain resident in
    memory until unlocked.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the *Demand-paging* section that performing *malloc* does nothing
    more than reserve virtual memory, not physical. As an example, if an (non-real-time)
    application performs a rather large allocation of a megabyte (that's 512 pages),
    we understand that only 512 virtual pages are reserved and the physical page frames
    are not actually allocated – they will get faulted in on-demand. A typical realtime
    application will therefore need to somehow guarantee that, once faulted in, these
    512 pages will remain locked (resident) in RAM. Use the `MCL_ONFAULT` flag to
    achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: This flag must be used in conjunction with either the `MCL_CURRENT` or  `MCL_FUTURE`
    flag, or both. The idea is that physical memory consumption remains extremely
    efficient (as no physical allocation is done at the time of *malloc*), and yet,
    once the application starts to touch the virtual pages (that is, read, write,
    or execute data or code within the page), the physical page frames get faulted
    in and they will then be locked. In other words, we do not pre-fault the memory,
    thus we get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: The other side of the coin is that, when done, the application can unlock all
    memory pages by issuing the counterpart API: *munlockall(2)*.
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application dynamically allocates, say, four pages of memory. By default,
    this memory is both readable and writable; we refer to these as the *memory protections*
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be nice if the application developer could dynamically modify memory
    protections on a per-page basis? For example, keep the first page with default
    protections, make the second page *read-only*, the third page *read+execute*,
    and on the fourth page, not allow any kind of access (a guard page, perhaps?).
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this feature is precisely what the `mprotect(2)` system call is designed
    for. Let''s delve into how we can exploit it to do all that. Here is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s really quite straightforward: starting at the (virtual) address, `addr,`
    for `len` bytes (that is, from `addr` up to `addr+len-1` ), apply the memory protections
    specified by the *prot* bitmask. As the granularity of *mprotect* is a page, the
    first parameter, *addr*, is expected to be page-aligned (on a page boundary; recall
    that this is exactly what `mlock[all](2)` expects too).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter, `prot`, is where you specify the actual protections; it
    is a bitmask and can either be just the `PROT_NONE` bit or the bitwise OR of the
    remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protection bit** | **Meaning of memory protection** |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_NONE` | No access allowed on the page |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_READ` | Reads allowed on the page |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_WRITE` | Writes allowed on the page |'
  prefs: []
  type: TYPE_TB
- en: '| `PROT_EXEC` | Execute access allowed on the page |'
  prefs: []
  type: TYPE_TB
- en: Within the man page on *mprotect(2),* there are several other rather arcane
    protection bits and useful information under the NOTES section. If required (or
    just curious), read about it here: [http://man7.org/linux/man-pages/man2/mprotect.2.html](http://man7.org/linux/man-pages/man2/mprotect.2.html)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection – a code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider an example program where the process dynamically allocates
    four pages of memory and wants to set them up so that the memory protections for
    each page are as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Page #** | **Page 0** | **Page 1** | **Page 2** | **Page 3** |'
  prefs: []
  type: TYPE_TB
- en: '| Protection bits | `rw-` | `r--` | `rwx` | `---` |'
  prefs: []
  type: TYPE_TB
- en: 'Relevant portions of the code are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the *main* function dynamically allocates page-aligned memory (four
    pages) with the `posix_memalign(3)` API, and then invokes the memory protection
    and the memory testing functions in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the memory protection function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the memory protections, we have the `main()`function invoke
    the memory testing function, `test_mem`. The second parameter determines whether
    we will attempt to write on read-only memory (we require this test case for page
    1 as it''s read-only protected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to attempting to test it, we check that the page has indeed been protected
    by the `mprotect`call (via our simple `okornot[]`array). Also, for readability,
    we build the simple `TEST_READ` and `TEST_WRITE` macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If the process violates any of the memory protections, the OS will summarily
    kill it via the usual *segfault* mechanism (explained in detail within [Chapter
    12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)*,* *Signaling Part II*).
  prefs: []
  type: TYPE_NORMAL
- en: Let's perform some test runs on the `memprot` program; first (for reasons that
    will become clear soon) we'll try it out on a generic Ubuntu Linux box, then on
    a Fedora system, and finally on an (emulated) ARM-32 platform!
  prefs: []
  type: TYPE_NORMAL
- en: 'Case #1.1: The `memprot`program on standard Ubuntu 18.04 LTS with parameter
    0(output reformatted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so the parameter to `memprot` is `0` or `1`; `0` implies that we do not
    perform a write-to-read-only-memory test, whereas `1` implies we do. Here, we've
    run it with the `0` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things to notice within the preceding output are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `protect_mem()` function sets up memory protections on a per-page basis.
    We have allocated 4 pages, thus we loop 4 times, and on each loop iteration `i`,
    perform `mprotect(2)` on the i-th memory page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can clearly see in the code, it's been done in this fashion, on each
    loop iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `0 : rw-`: Set page protections to `PROT_READ | PROT_WRITE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `1 : r--`: Set page protections to `PROT_READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `2 : rwx`: Set page protections to `PROT_READ| PROT_WRITE | PROT_EXEC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `3 : ---`: Set page protections to `PROT_NONE`, that is,  make the page
    inaccessible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding output, the output format displayed after *mprotect* is as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page <#>: protections: <PROT_xx|[...]> range [<start_addr>:<end_addr>]`'
  prefs: []
  type: TYPE_NORMAL
- en: All goes well; the four pages get new protections as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, the `test_mem()` function is invoked, which tests each page''s protections
    (the memory protection of the page is shown within square brackets in the usual
    [`rwx`] format):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 0 [default: `rw-`]: It writes and reads a random byte within the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 1 [`r--`]: It reads a random byte within the page, and if the user
    passed the parameter as `1` (not the case here, but it will be in the following
    case), it attempts to write to a random byte within that page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 2 [`rwx`]: As expected, reading and writing a random byte here succeeds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 3 [`---`]: It attempts to both read and write a random byte within
    the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The very first access – a *read* – fails with a *segfault*; this is expected
    of course – the page has no permissions whatsoever (we reproduce the output for
    this case): `**page 3: reading: byte @ 0x55796ccd8567 is Segmentation fault**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, with the parameter as `0`, test cases on pages 0, 1, and 2 succeed;
    as expected, any access on page 3 causes the OS to kill the process (via the segmentation-violation
    signal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case #1.2: The `memprot` program on standard Ubuntu 18.04 LTS with parameter
    1 (output reformatted for readability).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now re-run the program with the parameter set to `1`, thus attempting
    to write to the *read-only* page `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, as expected, it *segfaults* when it violates the read-only page permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case #2: The `memprot`program on a standard *Fedora 28* system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the latest and greatest *Fedora* workstation
    distribution is ver 28:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We build and run our `memprot`program on this standard *Fedora 28* workstation
    system (passing `0` as the parameter – implying that we do not attempt writing
    to the read-only memory page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we interpret the preceding output? The following is the explanation
    for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All goes well for pages 0, 1, and 3: the *mprotect* API succeeds in setting
    the page''s protections exactly as shown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we get a failure (and a *Warning* message) when we attempt the `mprotect(2)`
    system call on page 2 with the `PROT_READ | PROT_WRITE | PROT_EXEC` attributes.  *Why?*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usual OS security is the **Discretionary Access Control** (**DAC**) layer. Many
    modern Linux distros, including Fedora, come with a powerful security feature –
    an additional layer of security within the OS – the **Mandatory Access Control** (**MAC**) layer. These
    are implemented on Linux as **Linux Security Modules** (**LSMs**). Popular LSMs
    include the NSA's SELinux (Security-Enhanced Linux), AppArmor, Smack, TOMOYO,
    and Yama.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora uses SELinux while Ubuntu variants tend to use AppArmor. Whichever the
    case, it is often these LSMs that can fail userland-issued system calls when they
    violate a security policy. This is precisely what happened with our mprotect(2)
    system call on the third page (when the page protections were attempted to be
    set to [`rwx`])!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a quick proof-of-concept, and to just get it working for now, we temporarily
    **disable** *SELinux* and retry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*SELinux* is now in permissive mode; retry the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it works as expected! Don''t forget to re-enable the LSM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: An Aside – LSM logs, Ftrace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(If you are not interested in this, feel free to skip over this section). The
    astute reader might wonder: how does one realize that it''s the OS security layer
    (the LSM) that ultimately caused the system call to fail? Broadly, there are two
    ways: check the given LSM logs, or use the kernel''s `Ftrace` functionality. The
    first way is simpler, but the second can give us insight at the level of the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: LSM logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern Linux systems use the powerful systemd framework for process-initialization,
    logging, and more. The logging facility is called the journal and is accessed
    via the` journalctl(1)` utility. We use it to verify that it''s indeed the SELinux
    LSM that has caused the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It even shows us exactly how we can allow the access.
  prefs: []
  type: TYPE_NORMAL
- en: Ftrace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel has a very powerful built-in tracing mechanism (well, it''s
    one of them) – *Ftrace*. Using `ftrace`, you can verify that it''s indeed the
    *LSM* code that, while honoring its security policy, caused the userspace-issued
    system call to return failure. I ran a trace (with `ftrace`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82dbe338-ea14-4d08-b883-845de7a88777.png)'
  prefs: []
  type: TYPE_IMG
- en: ftrace output snippet
  prefs: []
  type: TYPE_NORMAL
- en: The `SyS_mprotect` function is what the *mprotect(2) *system call becomes withinthe
    kernel; `security_file_mprotect` is the LSM hook function that leads to the the
    actual SELinux function: `selinux_file_mprotect`; apparently, it fails the access.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, Ubuntu 18.04 LTS also uses an LSM – AppArmor. However, it seems
    that it has not been configured to catch this kind of *write+execute* (heap) page-protection
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these topics (LSMs, ftrace) are beyond the scope of this book. To
    the curious reader (the kind we love), please see more on *LSMs* and *Ftrace*
    in the *Further reading *section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: An experiment – running the memprot program on an ARM-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an interesting experiment, we will cross-compile our preceding *memprot*
    program for an **ARM system**. I have used a convenient way to do this without
    real hardware: using the powerful  **Free and Open Source Software **(**FOSS**)
    **Quick Emulator **(**QEMU**) project, to emulate an ARM Versatile Express Cortex-A9
    platform!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-compiling the code is indeed simple: notice that there is now a `CROSS_COMPILE`
    variable in our `Makefile`*;* it''s the cross-compiler prefix – the prefix string
    identifying the toolchain (common to all tools). It''s literally prefixed onto
    the `CC` (for `gcc`, or `CL`  for clang) variable, which is the compiler used
    to build the target. Unfortunately, going into more detail regarding cross-compiling
    and root-filesystem build is beyond the scope of this book; for some help, see
    the *Tip* that follows this example''s output. Also, to keep things simple, we
    will use a direct approach – a separate target for the ARM version within the
    `Makefile`. Let''s check out the relevant portion of the `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as shown here, we cross-compile the `memprot_arm` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha, it''s generated an ARM executable! We copy this over to our embedded root
    filesystem, boot the (emulated) ARM board, and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re on the (emulated) ARM-32 system prompt; let''s try running our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The reader will notice that, unlike on the *Fedora 28* distro on the x86_64
    system we ran this on earlier, the page 2 test case (highlighted in bold) where
    we attempt to set page 2's memory protections to [`rwx`] does succeed! Of course,
    there is no LSM installed.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to try similar experiments, running code on an emulated ARM-32,
    consider using the **Simple Embedded ARM Linux System** (**SEALS**) project, again
    pure open source, to easily build a very simple, yet working, ARM/Linux-embedded
    system: [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals).
  prefs: []
  type: TYPE_NORMAL
- en: Similar memory-protection – setting protection attributes (rwx or none) on a
    range of memory – can be achieved with the powerful `mmap(2)` system call (We
    cover `mmap(2)` with respect to file I/O in [Chapter 18](cf0e96e2-0e5d-4fb2-abc2-742bc93b61d0.xhtml),
    *Advanced File I/O*).
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection keys – a brief note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recent Intel 64-bit processors bring to the table a feature called **Memory
    Protection Keys** (**MPK**). Very briefly, MPK (or *pkeys*, as it''s called on
    Linux) allows userspace to set permissions with page granularity, too. So, if
    it does the same thing as *mprotect* or *mmap*, what benefit does it bring? See
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a hardware feature, so setting a huge range of pages (say, gigabytes of
    memory) to some particular memory permissions will be much faster than `mprotect(2)` 
    can manage; this is important for some types of applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications (in-memory databases, perhaps) could benefit by turning off writes
    on memory regions until absolutely required, reducing spurious write bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you exploit MPK? First, be aware that it is currently only implemented
    on recent Linux kernels and on the x86_64 processor architecture. To make use
    of it, read up on the man page (section 7) on *pkeys; *it has explanatory notes
    as well as sample code: [http://man7.org/linux/man-pages/man7/pkeys.7.html](http://man7.org/linux/man-pages/man7/pkeys.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using alloca to allocate automatic memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The glibc library provides an alternate to dynamic memory-allocation with malloc
    (and friends); the `alloca(3)` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'alloca can be thought of as something of a convenience routine: **it allocates
    memory on the stack** (of the function it is called within). The showcase feature
    is that free is not required and, the memory is automatically deallocated once
    the function returns. In fact, `free(3)` must not be called. This makes sense:
    memory allocated on the stack is called automatic memory – it will be freed upon
    that function''s return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, there are upsides and downsides – tradeoffs – to using  `alloca(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the `alloca(3)` pros:'
  prefs: []
  type: TYPE_NORMAL
- en: No free is required; this can make programming, readability, and maintainability
    much simpler. Thus we can avoid the dangerous memory-leakage bug – a significant
    gain!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is considered very fast, with zero internal fragmentation (wastage).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The primary reason to use it: sometimes, programmers use non-local exits, typically
    via the `longjmp(3)` and `siglongjmp(3)` APIs. If the programmer uses `malloc(3)`
    to allocate a memory region and then abruptly leaves the function via a non-local
    exit, a memory leak will occur. Using *alloca* will prevent this, and the code
    is easy to implement and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are the alloca cons:'
  prefs: []
  type: TYPE_NORMAL
- en: The primary downside of alloca is that there is no guarantee it returns failure
    when passed a value large enough to cause stack overflow; thus, if this actually
    does occur at runtime, the process is now in an **undefined behavior** (**UB**)
    state and will (eventually) crash. In other words, checking alloca for the NULL
    return, as you do with the `malloc(3)` family, is of no use!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portability is not a given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, alloca is implemented as an inline function; this prevents it from being
    overridden via a third-party library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the code as follows (`ch4/alloca_try.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build it and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter to `alloca_try` is the amount of memory to allocate (in
    bytes), while the second parameter, if `1`, has the `memset` process call on that
    memory region; if `0`, it does not.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we tried it with an allocation request of 50,000
    bytes – it succeeded for both the `memset` cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we deliberately pass `-1` as the first parameter, which will be treated
    as an unsigned quantity (thus becoming the enormous value of `0xffffffffffffffff` on
    a 64-bit OS!), which of course should cause `alloca(3)` to fail. Amazingly, it
    does not report failure; at least it thinks it''s okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: But then, doing `memset`(by passing the second parameter as `1`) causes the
    bug to surface; without it, we'd never know.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further verify this, try running the program under the control of the library
    call tracer software, `ltrace`; we pass `1` as the first parameter, forcing the
    process to invoke `memset` after `alloca(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Aha! We can see that following memset, the process receives the fatal signal
    and dies. But why doesn't the `alloca(3)` API show up in `ltrace`? Because it's
    an inlined function – ahem, one of its downsides.
  prefs: []
  type: TYPE_NORMAL
- en: 'But watch this; here, we pass `0` as the first parameter, bypassing the call
    to memset after `alloca(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It exits normally, as though there were no bug!
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, you will recall  from [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, we saw that the default stack size for a process is 8 MB. We can test
    this fact via our `alloca_try` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The moment we go beyond 8 MB, `alloca(3)` allocates too much space, but does
    not trigger a crash; instead, `memset(3)` causes segfault to occur. Also, ulimit
    verifies that the stack resource limit is 8,192 KB, that is, 8 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, a really, really key point: you can often end up writing software
    that seems to be correct but is, in fact, not. The only way to gain confidence
    with the software is to take the trouble to perform 100% code coverage and run
    test cases against them! It''s hard to do, but quality matters. Just do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused upon both the simple and more advanced aspects of dynamic
    memory management for C application developers on the Linux OS. In the initial
    section, the basic glibc dynamic memory-management APIs and their correct usage
    in code was dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to more advanced topics such as the program break (and the
    `sbrk(3)` API), how `malloc(3)` behaves internally when allocating memory of differing
    sizes, and the key concept of demand-paging. Then, we delved into the APIs that
    perform memory locking and memory region protection, and reasons to use them.
    Finally, we looked at `alloca(3)`, the alternate API. Several code examples were
    used to solidify the concepts that were learned. The next chapter will cover a
    really important topic—the variety of memory issues (defects) that can arise on
    Linux due to poor programming practices with the memory APIs
  prefs: []
  type: TYPE_NORMAL
