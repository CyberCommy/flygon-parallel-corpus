- en: Dynamic Memory Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: In this chapter, we will delve into a key aspect of system programming on a
    modern OS—the management of dynamic (runtime) memory allocation and deallocation.
    We'll first cover the basic glibc APIs used to allocate and free memory dynamically.
    We'll then move beyond these basics, examining the program break within the VAS
    and the behavior of `malloc(3)` under differing circumstances.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨现代操作系统上的系统编程的一个关键方面 – 动态（运行时）内存分配和释放的管理。我们将首先介绍用于动态分配和释放内存的基本glibc
    API。然后，我们将超越这些基础，研究VAS中的程序中断和`malloc(3)`在不同情况下的行为。
- en: 'We will then immerse the reader in a few advanced discussions: demand-paging,
    memory locking and protection, and the usage of the `alloca` API.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使读者沉浸在一些高级讨论中：需求分页、内存锁定和保护，以及`alloca`API的使用。
- en: Code examples provide the reader with an opportunity to explore these topics
    in a hands-on manner.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例为读者提供了一个探索这些主题的机会。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic glibc dynamic memory-management APIs and their correct usage in code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的glibc动态内存管理API及其在代码中的正确使用
- en: The program break (and its management via the `sbrk(3)` API)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中断（及其通过`sbrk(3)`API的管理）
- en: The internal behavior of `malloc(3)` when allocating differing amounts of memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`在分配不同数量的内存时的内部行为'
- en: 'Advanced features:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级特性：
- en: The demand-paging concept
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求分页概念
- en: Memory locking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存锁定
- en: Memory region protection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域保护
- en: Using the `alloca (3)` API alternative
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`alloca (3)`API的替代方案
- en: The glibc malloc(3) API family
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glibc malloc(3) API系列
- en: In [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*,
    we learned that there are regions or segments meant for the use of dynamic memory-allocation within
    the process of **Virtual Address Space** (**VAS**). The **heap segment** is one
    such dynamic region—a free gift of memory made available to the process for its
    runtime consumption.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中，*虚拟内存*，我们了解到在**虚拟地址空间**（**VAS**）的进程中有用于动态内存分配的区域或段。**堆段**就是这样一个动态区域
    – 一个为进程的运行时消耗提供的免费内存礼物。
- en: How exactly does the developer exploit this gift of memory? Not just that, the
    developer has to be extremely careful with matching memory *allocations* to subsequent
    memory *frees*, otherwise the system isn't going to like it!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员究竟如何利用这份内存的礼物？不仅如此，开发人员还必须非常小心地匹配内存*分配*和后续内存*释放*，否则系统将不会喜欢它！
- en: The **GNU C library** (**glibc**) provides a small but powerful set of APIs
    to enable the developer to manage dynamic memory; the details of their usage is
    the content of this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU C库**（**glibc**）提供了一组小而强大的API，使开发人员能够管理动态内存；它们的使用细节是本节的内容。'
- en: 'As you will come to see, the memory-management APIs are literally a handful:
    `malloc(3)`, `calloc`, `realloc`, and `free`. Still, using them correctly remains
    a challenge! The subsequent sections (and chapters) will reveal why this is the
    case. Read on!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将会看到的，内存管理API实际上只有几个：`malloc(3)`、`calloc`、`realloc`和`free`。然而，正确地使用它们仍然是一个挑战！接下来的章节（和章节）将揭示为什么会出现这种情况。继续阅读！
- en: The malloc(3) API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) API
- en: Perhaps one of the most common APIs used by application developers is the renowned
    `malloc(3)`*.*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也许应用程序开发人员最常用的API之一是著名的`malloc(3)`*。*
- en: The `foo(3)` syntax indicates that the `foo` function is in section 3 of the
    manual (the man pages) – a library API, not a system call. We recommend you develop
    the habit of reading the man pages. The man pages are available online, and you
    can find them at [https://linux.die.net/man/](https://linux.die.net/man/)*.*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo(3)`的语法表示`foo`函数在手册（man页面）的第3节中 – 一个库API，而不是系统调用。我们建议您养成阅读man页面的习惯。man页面可以在线获取，您可以在[https://linux.die.net/man/](https://linux.die.net/man/)找到它们*。*'
- en: 'We use `malloc(3)` to dynamically allocate a chunk of memory at runtime. This
    is as opposed to static—or compile-time – memory-allocation where we make a statement,
    such as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`malloc(3)`在运行时动态分配一块内存。这与静态 – 或编译时 – 内存分配相反，我们做出了一个声明，比如：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding case, the memory has been statically allocated (at compile-time).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，内存是静态分配的（在编译时）。
- en: 'So, how exactly do you use `malloc(3)`? Let''s check out its signature:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟如何使用`malloc(3)`？让我们来看看它的签名：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parameter to `malloc(3)` is the number of bytes to allocate. But what is
    the `size_t` data type? Obviously, it's not a C primitive data type; it's a `typedef
    – long unsigned int` on your typical 64-bit platform (the exact data type does
    vary with the platform; the important point is that it's always unsigned – it
    cannot be negative. On a 32-bit Linux, it will be `unsigned int`). Ensuring that
    your code precisely matches the function signature and data types is crucial in
    writing robust and correct programs. While we're at it, ensure that you include
    the header file that the man page displays with the API signature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数是要分配的字节数。但是`size_t`数据类型是什么？显然，它不是C原始数据类型；它是在典型的64位平台上的`typedef
    – long unsigned int`（确切的数据类型会随着平台的不同而变化；重要的是它总是无符号的 – 它不能是负数。在32位Linux上，它将是`unsigned
    int`）。确保您的代码与函数签名和数据类型精确匹配对于编写健壮和正确的程序至关重要。顺便说一句，确保您包含API签名所显示的头文件。'
- en: 'To print a variable of the `size_t` type within a `printf`, use the **`%zu`**
    format specifier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`printf`中打印`size_t`类型的变量，请使用**`%zu`**格式说明符：
- en: '`size_t sz = 4 * getpagesize();`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t sz = 4 * getpagesize();`'
- en: '`[...]`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`[...]`'
- en: '`printf("size = %zu bytes\n", sz);`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("size = %zu bytes\n", sz);`'
- en: In this book, we will not delve into the internal implementation details regarding
    how `malloc(3)` and friends actually store, allocate, and free memory (refer the
    *Further reading* section on the GitHub repository.) Suffice to say, the internal
    implementation strives to be as efficient as can be; using these APIs is usually
    considered the right way to perform memory-management.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会深入探讨`malloc(3)`和其它内部实现细节，实际上是如何存储、分配和释放内存的（请参阅GitHub存储库上的*进一步阅读*部分）。可以说，内部实现力求尽可能高效；通常认为使用这些API是执行内存管理的正确方式。
- en: The return value is a pointer to the zeroth byte of the newly-allocated memory
    region on success, and NULL on failure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回值是指向新分配的内存区域的第一个字节的指针，失败时返回NULL。
- en: You will come across, shall we say *optimists*, who say things such as, "Don't
    bother checking malloc for failure, it never fails". Well, take that sage advice
    with a grain of salt. While it's true that malloc would rarely fail, the fact
    is (as you shall see), it could fail. Writing defensive code – code that checks
    for the failure case immediately – is a cornerstone of writing solid, robust programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到，我们可以说是*乐观主义者*，他们会说诸如“不要费心检查`malloc`是否失败，它从不失败”。好吧，对这个明智的建议要持保留态度。虽然`malloc`很少会失败，但事实是（正如你将看到的），它可能会失败。编写防御性代码——立即检查失败情况的代码——是编写坚固、健壮程序的基石。
- en: 'So, using the API is very straightforward: as an example, allocate 256 bytes
    of memory dynamically, and store the pointer to that newly allocated region in
    the `ptr` variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这个API非常简单：例如，动态分配256字节的内存，并将指向新分配区域的指针存储在`ptr`变量中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As another typical example, the programmer needs to allocate memory for a data
    structure; let''s call it `struct sbar`. You could do so like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个典型的例子，程序员需要为一个数据结构分配内存；我们称之为`struct sbar`。你可以这样做：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hey, astute reader! What about checking the failure case? It''s a key point,
    so we will rewrite the preceding code like so (and of course it would be the case
    for the `malloc(256)` code snippet too):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，敏锐的读者！那么检查失败情况呢？这是一个关键点，所以我们将像这样重写前面的代码（当然，对于`malloc(256)`的代码片段也是如此）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s use one of the powerful tracing tools  `ltrace` to check that this works
    as expected; `ltrace` is used to display all library APIs in the process-execution
    path (similarly, use `strace` to trace all system calls). Let''s assume that we
    compile the preceding code and the resulting binary executable file is called
    `tst`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用强大的跟踪工具`ltrace`来检查这是否按预期工作；`ltrace`用于显示进程执行路径中的所有库API（类似地，使用`strace`来跟踪所有系统调用）。假设我们编译了前面的代码，生成的二进制可执行文件名为`tst`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can clearly see `malloc(3)` (and the fact that the example structure we used
    took up 592 bytes on an x86_64), and its return value (following the `=` sign).
    The `free` API follows, and then it simply exits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到`malloc(3)`（以及我们使用的示例结构在x86_64上占用了592字节），以及它的返回值（跟在`=`符号后面）。接着是`free`
    API，然后简单地退出。
- en: It's important to understand that the *content* of the memory chunk allocated
    by  `malloc(3)` is considered to be random. Thus, it's the programmer's responsibility
    to initialize the memory before reading from it; if you fail to do so, it results
    in a bug called **Uninitialized Memory Read** (**UMR***) *(more on this in the
    next chapter).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`malloc(3)`分配的内存块的*内容*被认为是随机的。因此，程序员有责任在从中读取之前初始化内存；如果未能这样做，将导致一个称为**未初始化内存读取**（UMR）的错误（在下一章中会更详细介绍）。
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary.
    Need larger alignment values? Use the `posix_memalign(3)` API. Deallocate its
    memory as usual with free(3).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`总是返回一个按8字节边界对齐的内存区域。需要更大的对齐值吗？使用`posix_memalign(3)` API。像通常一样使用`free(3)`释放其内存。'
- en: Details can be found on the man page at [https://linux.die.net/man/3/posix_memalign](https://linux.die.net/man/3/posix_memalign).Examples
    of using the `posix_memalign(3)` API can be found in the *Locking memory* and
    *Memory protection* sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`posix_memalign(3)`的详细信息可以在man页面上找到[https://linux.die.net/man/3/posix_memalign](https://linux.die.net/man/3/posix_memalign)。使用`posix_memalign(3)`
    API的示例可以在*锁定内存*和*内存保护*部分找到。
- en: malloc(3) – some FAQs
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) – 一些常见问题
- en: 'The following are some FAQs that will help us to learn more about `malloc(3)`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见问题，这些问题将帮助我们更多地了解`malloc(3)`：
- en: 'FAQ 1 : How much memory can `malloc(3)` allocate with a single call?'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题1：`malloc(3)`可以一次分配多少内存？
- en: A rather pointless question in practical terms, but one that is often asked!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下是一个相当无意义的问题，但经常被问到！
- en: The parameter to `malloc(3)` is an integer value of the `size_t` data type,
    so, logically, the maximum number we can pass as a parameter to `malloc(3)` is
    the maximum value a `size_t` can take on the platform*.* Practically speaking,
    on a 64-bit Linux, `size_t` will be 8 bytes, which of course, in bits is 8*8 =
    64\. Therefore, the maximum amount of memory that can be allocated in a single
    `malloc(3)` call is `2^64`!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数是`size_t`数据类型的整数值，因此，从逻辑上讲，我们可以作为参数传递给`malloc(3)`的最大数字是平台上`size_t`可以取的最大值。从实际上来说，在64位Linux上，`size_t`将是8字节，当然，以位来说是8*8
    = 64。因此，在单次`malloc(3)`调用中可以分配的最大内存量是`2^64`！'
- en: 'So, how much is it? Let''s be empirical (it''s important to read in [Chapter
    19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml), *Troubleshooting and Best Practices*,
    and the brief discussion there on *The empirical approach*).and actually try it
    out (note that the following code snippet has to be linked with the math library
    using the `-lm` switch):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是多少呢？让我们来实证（在[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)中阅读很重要，*故障排除和最佳实践*，以及关于*实证方法*的简要讨论）。并实际尝试一下（请注意，以下代码片段必须使用`-lm`开关链接数学库）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output, on an x86_64:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64上的输出：
- en: '**`sizeof size_t = 8; max param to malloc = 18446744073709551616`**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sizeof size_t = 8; max param to malloc = 18446744073709551616`**'
- en: 'Aha! That''s a mighty large number; more readably, it''s as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！这是一个非常大的数字；更易读地说，如下所示：
- en: '`2^64 = 18,446,744,073,709,551,616 = 0xffffffffffffffff`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`2^64 = 18,446,744,073,709,551,616 = 0xffffffffffffffff`'
- en: That's 16 EB (exabytes, which is 16,384 PB, which is 16 million TB)!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是16EB（EB，即16384PB，即1600万TB）！
- en: So, on a 64-bit OS, `malloc(3)` can allocate a maximum of 16 EB in a single
    call. In theory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在64位操作系统上，`malloc(3)`可以在一次调用中分配最多16EB。理论上。
- en: 'As usual, there''s more to it: please see *FAQ 2*; it will reveal that the
    *theoretical* answer to this question is **8 exabytes** (8 EB).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，还有更多：请参见*常见问题2*；它将揭示这个问题的*理论*答案是**8EB**（8EB）。
- en: In practice, obviously, this would be impossible because, of course, that's
    the entire usermode VAS of the process itself. In reality, the amount of memory
    that can be allocated is limited by the amount of free memory contiguously available
    on the heap. Actually, there's more to it. As we shall soon learn (in the *How
    malloc(3) really behaves* section), memory for `malloc(3)` can come from other
    regions of the VAS, too. Don't forget there's a resource limit on data segment
    size; the default is usually unlimited, which as we discussed in this chapter,
    really means that there's no artificial limit imposed by the OS.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是不可能的，因为这当然是进程本身的整个用户模式VAS。实际上，可以分配的内存量受堆上连续可用的空闲内存量的限制。实际上，还有更多。正如我们很快将了解的那样（在*malloc(3)的真正行为*部分），`malloc(3)`的内存也可以来自VAS的其他区域。不要忘记数据段大小有资源限制；默认情况下通常是无限的，这意味着没有操作系统施加的人为限制，正如我们在本章中讨论的那样。
- en: So, in practice, it's best to be sensible, not assume anything, and check the
    return value for NULL.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实践中，最好是明智一点，不要假设任何事情，并检查返回值是否为NULL。
- en: 'As an aside, what''s the maximum value a `size_t` can take on a 32-bit OS? Accordingly,
    we compile on x86_64 for 32-bit by passing the `-m32` switch to the compiler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在32位操作系统上，`size_t`可以取的最大值是多少？因此，我们通过向编译器传递`-m32`开关在x86_64上编译32位：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clearly, it's 4 GB (gigabytes) – again, the entire VAS of a 32-bit process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是4GB（千兆字节）- 再次，32位进程的整个VAS。
- en: 'FAQ 2: What if I pass `malloc(3)` a negative argument?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题2：如果我传递`malloc(3)`一个负参数会怎么样？
- en: 'The data type of the parameter to `malloc(3)`, `size_t`, is an unsigned integerquantity –
    it cannot be negative. But, humans are imperfect, and **Integer OverFlow** (**IOF**)
    bugs do exist! You can imagine a scenario where a program attempts to calculate
    the number of bytes to allocate, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数数据类型`size_t`是一个无符号整数量-它不能是负数。但是，人是不完美的，**整数溢出**（**IOF**）错误确实存在！你可以想象一个程序试图计算要分配的字节数的情况，就像这样：'
- en: '`num = qa * qb;`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`num = qa * qb;`'
- en: 'What if `num` is declared as a signed integer variable and `qa` and `qb` are
    large enough that the result of the multiplication operation causes an overflow?
    The `num` result will then wrap around and become negative! `malloc(3)` should
    fail, of course. But hang on: if the `num` variable is declared as `size_t` (which
    should be the case), the negative quantity will turn into some positive quantity!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`num`声明为有符号整数变量，`qa`和`qb`足够大，使得乘法操作的结果导致溢出，`num`的结果将会变成负数！`malloc(3)`当然应该失败。但是等等：如果`num`变量声明为`size_t`（这应该是情况），负数将变成一些正数！
- en: The `mallocmax` program has a test case for this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: mallocmax程序有一个针对此的测试用例。
- en: 'Here is the output when run on an x86_64 Linux box:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64 Linux系统上运行时的输出如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the relevant variable declarations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关的变量声明：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's try it with a 32-bit version of the program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试32位版本的程序。
- en: 'Note that on a default-install Ubuntu Linux box, the 32-bit compile may fail
    (with an error such as `fatal error: bits/libc-header-start.h: No such file or
    directory`*)*. Don''t panic: this usually implies that the compiler support for
    building 32-bit binaries isn''t present by default. To get it (as mentioned in
    the Hardware-Software List document), install the `multilib` compiler package:
    `sudo apt-get install gcc-multilib`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在默认安装的Ubuntu Linux系统上，32位编译可能会失败（出现诸如`fatal error: bits/libc-header-start.h:
    No such file or directory`*）*的错误。不要惊慌：这通常意味着默认情况下没有编译32位二进制文件的编译器支持。要获得它（如在*硬件-软件列表*文档中提到的），安装`multilib`编译器包：`sudo
    apt-get install gcc-multilib`。'
- en: 'Compile it for 32-bit and run it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为32位编译并运行它：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To be fair, the compiler does warn us:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，编译器确实警告我们：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Interesting! The compiler answers our *FAQ 1* question now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣！编译器现在回答了我们的*常见问题1*：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The maximum value you can allocate as per the compiler seems to be **`9223372036854775807`**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许分配的最大值似乎是9223372036854775807。
- en: 'Wow. A little calculator time reveals that this is 8192 PB = 8 EB! So, we must
    conclude that  the correct answer to the previous question: *How much memory can
    malloc allocate with a single call?* Answer: *8 exabytes*. Again, in theory.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。简单的计算时间表明这是8192PB = 8EB！因此，我们必须得出结论：对于上一个问题的正确答案是：*`malloc`一次调用可以分配多少内存？*答案：*8EB*。再次，理论上。
- en: 'FAQ 3: What if I use `malloc(0)`?'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题3：如果我使用`malloc(0)`会怎么样？
- en: Not much; depending on the implementation, `malloc(3)` will return NULL, or,
    a non-NULL pointer that can be passed to free. Of course, even if the pointer
    is non-NULL, there is no memory, so don't attempt to use it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不多；根据实现的不同，`malloc(3)`将返回NULL，或者一个可以传递给free的非NULL指针。当然，即使指针是非NULL的，也没有内存，所以不要尝试使用它。
- en: 'Let''s try it out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We compile and then run it via `ltrace`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译然后通过`ltrace`运行它：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `malloc(0)` did indeed return a non-NULL pointer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`malloc(0)`确实返回了一个非NULL指针。
- en: 'FAQ 4: What if I use `malloc(2048)` and attempt to read/write beyond 2,048
    bytes?'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题4：如果我使用`malloc(2048)`并尝试读/写超出2048字节会怎么样？
- en: This is a bug of course – an out-of-bounds memory-access bug, further defined
    as a read or write buffer overflow. Hang on please, the detailed discussion of
    memory bugs (and subsequently, how to find and fix them) is the subject of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个错误-一个越界内存访问错误，进一步定义为读取或写入缓冲区溢出。请稍等，关于内存错误的详细讨论（以及随后如何找到和修复它们）是[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)的主题，*Linux内存问题*，以及[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*。
- en: malloc(3) – a quick summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) - 快速总结
- en: 'So, let''s summarize the key points regarding usage of the `malloc(3)` API:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下关于`malloc(3)` API使用的关键点：
- en: '`malloc(3)` dynamically (at runtime) allocates memory from the process heap'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`在运行时从进程堆中动态分配内存'
- en: As we shall soon learn, this is not always the case
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们很快将了解的那样，这并不总是情况
- en: The single parameter to `malloc(3)` is an unsigned integer value—the number
    of bytes to allocate
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`的单个参数是一个无符号整数值-要分配的字节数。'
- en: 'The return value is a pointer to the start of the newly allocated memory chunk
    on success, or NULL on failure:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时返回值是指向新分配的内存块开头的指针，失败时返回NULL：
- en: You must check for the failure case; don't just assume it will succeed
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须检查失败的情况；不要假设它会成功
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`总是返回一个按8字节边界对齐的内存区域'
- en: The content of the newly allocated memory region is considered to be random
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新分配的内存区域的内容被认为是随机的
- en: You must initialize it before reading from any part of it
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从中读取任何部分之前，您必须对其进行初始化
- en: You must free the memory you allocate
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须释放您分配的内存
- en: The free API
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: free API
- en: One of the golden rules of development in this ecosystem is that programmer-allocated
    memory must be freed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生态系统中开发的黄金规则之一是程序员分配的内存必须被释放。
- en: Failure to do so leads to a bad situation – a bug, really – called **memory
    leakage**; this is covered in some depth in the next chapter. Carefully matching
    your allocations and frees is essential.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 未能这样做会导致糟糕的情况-一个错误，真的-称为**内存泄漏**；这在下一章中有比较深入的介绍。仔细匹配您的分配和释放是至关重要的。
- en: Then again, in smaller real-world projects (utils), you do come across cases
    where memory is allocated exactly once; in such cases, freeing the memory is pedantic
    as the entire virtual address space is destroyed upon process-termination. Also,
    using the *alloca(3)* API implies that you do not need to free the memory region
    (seen later in, *Advanced features *section). Nevertheless, you are advised to
    err on the side of caution!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在较小的实际项目（实用程序）中，您会遇到只分配一次内存的情况；在这种情况下，释放内存是迂腐的，因为整个虚拟地址空间在进程终止时被销毁。此外，使用`alloca(3)`
    API意味着您不需要释放内存区域（稍后在*高级特性*部分中看到）。尽管如此，建议您谨慎行事！
- en: 'Using the `free(3)` API is straightforward:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`free(3)` API很简单：
- en: '`void free(void *ptr);`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`void free(void *ptr);`'
- en: 'It accepts one parameter: the pointer to the memory chunk to be freed. `ptr`
    must be a pointer returned by one of the `malloc(3)` family routines: `malloc(3)`,
    `calloc`, or `realloc[array]`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个参数：要释放的内存块的指针。`ptr`必须是`malloc(3)`系列例程（`malloc(3)`，`calloc`或`realloc[array]`）返回的指针。
- en: '`free` does not return any value; don''t even attempt to check whether it worked;
    if you used it correctly, it worked. More on free is found in the *Where does
    freed memory go?* section. Once a memory chunk is freed, you obviously cannot
    attempt to use any part of that memory chunk again; doing so will result in a
    bug (or what''s called **UB – undefined behavior**).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`不返回任何值；甚至不要尝试检查它是否起作用；如果您使用正确，它就起作用了。有关free的更多信息，请参阅*释放的内存去哪里了？*部分。一旦释放了内存块，您显然不能尝试再次使用该内存块的任何部分；这样做将导致错误（或者所谓的**UB-未定义行为**）。'
- en: 'A common misconception regarding `free()` sometimes leads to its being used
    in a buggy fashion; take a look at this pseudocode snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`free()`的一个常见误解有时会导致其以错误的方式使用；看一下这个伪代码片段：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This program will possibly crash in the loop (within the `<use ''ptr'' here>`
    code) in a few iterations. Why? Because the `ptr` memory pointer is freed and
    is attempting to be reused. But how come? Ah, look carefully: the code snippet
    is only going to `malloc(3)` the `ptr` pointer if it is currently NULL, that is,
    its programmer has assumed that once we `free()` memory, the pointer we just freed
    gets set to NULL. This is not the case!!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可能会在循环中崩溃（在`<use 'ptr' here>`代码内）。为什么？因为`ptr`内存指针被释放并且正在尝试被重用。但是为什么？啊，仔细看：代码片段只有在`ptr`当前为NULL时才会`malloc(3)`指针，也就是说，其程序员假设一旦我们`free()`内存，我们刚刚释放的指针就会被设置为NULL。这并不是事实！
- en: Be wary and be defensive in writing code. Don't assume anything; it's a rich
    source of bugs. Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时要谨慎并且要有防御性。不要假设任何事情；这是一个错误的丰富来源。重要的是，我们的[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，涵盖了这些要点）
- en: free – a quick summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: free - 快速总结
- en: 'So, let''s summarize the key points regarding the usage of the *free* API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下关于*free* API使用的关键点：
- en: The parameter passed to `free(3)` must be a value returned by one of the `malloc(3)`
    family APIs (`malloc(3)`, `calloc`, or `realloc[array]`).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`free(3)`的参数必须是`malloc(3)`系列API（`malloc(3)`，`calloc`或`realloc[array]`）返回的值。
- en: '`free` has no return value.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free`没有返回值。'
- en: Calling `free(ptr)` does not set `ptr` to `NULL` (that would be nice, though).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`free(ptr)`不会将`ptr`设置为`NULL`（尽管这样做会很好）。
- en: Once freed, do not attempt to use the freed memory.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦释放，不要尝试使用已释放的内存。
- en: Do not attempt to *free* the same memory chunk more than once (it's a bug –
    UB).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试多次*free*相同的内存块（这是一个错误-UB）。
- en: For now, we will assume that freed memory goes back to the system.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们将假设释放的内存返回给系统。
- en: For Heaven's sake, do not forget to free memory that was dynamically allocated
    earlier. The forgotten memory is said to have *leaked out* and that's a really
    hard bug to catch! Luckily, there are tools that help us catch these bugs. More
    in [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and
    [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for
    Memory Issues*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天哪，不要忘记释放先前动态分配的内存。被遗忘的内存被称为*泄漏*，这是一个非常难以捕捉的错误！幸运的是，有一些工具可以帮助我们捕捉这些错误。更多内容请参阅[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)，*Linux内存问题*，和[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*。
- en: The calloc API
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calloc API
- en: 'The `calloc(3)` API is almost identical to `malloc(3)`, differing in two main
    respects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`calloc(3)` API与`malloc(3)`几乎相同，主要有两个不同之处：'
- en: It initializes the memory chunk it allocates to the zero value (that is, ASCII
    0 or NULL, not the number `0`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将分配的内存块初始化为零值（即ASCII 0或NULL，而不是数字`0`）
- en: It accepts two parameters, not one
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受两个参数，而不是一个
- en: 'The `calloc(3)` function signature is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`calloc(3)`函数签名如下：'
- en: '` void *calloc(size_t nmemb, size_t size);`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *calloc(size_t nmemb, size_t size);`'
- en: 'The first parameter, `nmemb`, is n members; the second parameter, `size`, is
    the size of each member. In effect, `calloc(3)` allocates a memory chunk of `(nmemb*size)`
    bytes. So, if you want to allocate memory for an array of, say, 1,000 integers,
    you can do so like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`nmemb`是n个成员；第二个参数`size`是每个成员的大小。实际上，`calloc(3)`分配了一个大小为`(nmemb*size)`字节的内存块。因此，如果你想为一个包含1,000个整数的数组分配内存，你可以这样做：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming the size of an integer is 4 bytes, we would have allocated a total
    of (1000*4) = 4000 bytes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设整数的大小为4字节，我们将总共分配了（1000*4）= 4000字节。
- en: Whenever one requires memory for an array of items (a frequent use case in applications
    is an array of structures), `calloc` is a convenient way to both allocate and
    simultaneously initialize the memory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要为一组项目分配内存（在应用程序中经常使用的一种情况是结构数组），`calloc`是一种方便的方式，既可以分配内存，又可以同时初始化内存。
- en: Demand paging (covered later in this chapter), is another reason programmers
    use `calloc` rather than `malloc(3)` (in practice, this is mostly useful for realtime
    applications). Read up on this in the up coming section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 需求分页（本章后面介绍），是程序员使用`calloc`而不是`malloc(3)`的另一个原因（在实践中，这对实时应用程序非常有用）。在即将到来的部分中了解更多信息。
- en: The realloc API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: realloc API
- en: 'The `realloc` API is used to *resize* an existing memory chunk—to grow or shrink
    it. This resizing can only be performed on a piece of memory previously allocated
    with one of the `malloc(3)` family of APIs (the usual suspects: `malloc(3)`, `calloc`,
    or `realloc[array]`). Here is its signature:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc` API用于*调整*现有内存块的大小——增大或缩小。这种调整只能在先前使用`malloc(3)`系列API之一（通常的嫌疑犯：`malloc(3)`，`calloc`或`realloc[array]`）分配的内存块上执行。以下是其签名：'
- en: '` void *realloc(void *ptr, size_t size);`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *realloc(void *ptr, size_t size);`'
- en: The first parameter, `ptr`, is a pointer to a chunk of memory previously allocated
    with one of the `malloc(3)` family of APIs; the second parameter, `size`, is the
    new size of the memory chunk—it can be larger or smaller than the original, thus
    growing or shrinking the memory chunk.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`ptr`是先前使用`malloc(3)`系列API之一分配的内存块的指针；第二个参数`size`是内存块的新大小——它可以比原来的大或小，从而增大或缩小内存块。
- en: 'A quick example code snippet will help us understand `realloc`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的示例代码片段将帮助我们理解`realloc`：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The pointer returned by `realloc` is the pointer to the newly resized chunk
    of memory; it may or may not be the same address as the original `ptr`. In effect,
    you should now completely disregard the original pointer `ptr`  and regard the realloc-returned
    `newptr` pointer as the one to work with. If it fails, the return value is NULL
    (check it!) and the original memory chunk is left untouched.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`返回的指针是新调整大小的内存块的指针；它可能与原始`ptr`的地址相同，也可能不同。实际上，你现在应该完全忽略原始指针`ptr`，并将`realloc`返回的`newptr`指针视为要处理的指针。如果失败，返回值为NULL（检查它！），原始内存块将保持不变。'
- en: 'A key point: the pointer returned by `realloc(3)`, `newptr`, is the one that
    must be subsequently freed, *not* the original pointer (`ptr`) to the (now resized)
    memory chunk. Of course, do not attempt to free both pointers, as that to is a
    bug.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点：`realloc(3)`返回的指针`newptr`是随后必须释放的指针，*而不是*指向（现在调整大小的）内存块的原始指针（`ptr`）。当然，不要尝试释放两个指针，因为那是一个错误。
- en: What about the contents of the memory chunk that just got resized? They remain
    unchanged up to `MIN(original_size, new_size)`. Thus, in the preceding example,
    `MIN(100, 150) = 100`, the contents of memory up to 100 bytes will be unchanged.
    What about the remainder (50 bytes)? It's considered to be random content (just
    like `malloc(3)`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚调整大小的内存块的内容呢？它们保持不变，直到`MIN(original_size, new_size)`。因此，在前面的例子中，`MIN(100,
    150) = 100`，100字节的内存内容将保持不变。剩下的部分（50字节）呢？它被视为随机内容（就像`malloc(3)`一样）。
- en: The realloc(3) – corner cases
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`realloc(3)——边界情况`'
- en: 'Consider the following code snippet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The pointer passed to `realloc` is `NULL`? The library treats this as equivalent
    to a new allocation – `malloc(150)`; and all the implications of the `malloc(3)` That's
    it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`传递的指针是`NULL`？库将其视为等同于新分配的`malloc(150)`；以及`malloc(3)`的所有含义。就是这样。'
- en: 'Now, consider the following code snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码片段：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The size parameter passed to `realloc` is `0`? The library treats this as equivalent
    to `free(ptr)`*.* That's it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`realloc`的大小参数是`0`？库将其视为等同于`free(ptr)`*.*就是这样。
- en: The reallocarray API
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reallocarray API
- en: 'A scenario: you allocate memory for an array using `calloc(3)`; later, you
    want to resize it to be, say, a lot larger. We can do so with `realloc(3)`; for
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一种情况：你使用`calloc(3)`为一个数组分配内存；后来，你想将其调整大小为更大。我们可以使用`realloc(3)`来做到；例如：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fine. There''s an easier way, though—using the `reallocarray(3)` API. Its signature
    is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。不过，有一种更简单的方法——使用`reallocarray(3)` API。其签名如下：
- en: '` void *reallocarray(void *ptr, size_t nmemb, size_t size);`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *reallocarray(void *ptr, size_t nmemb, size_t size);`'
- en: 'With it, the code becomes simpler:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了它，代码变得更简单：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The return value of `reallocarray` is pretty identical to that of the `realloc`
    API: the new pointer to the resized memory chunk on success (it may differ from
    the original), `NULL` on failure. If it fails, the original memory chunk is left
    untouched.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`reallocarray`的返回值与`realloc` API非常相似：成功时调整大小的新内存块的新指针（可能与原始指针不同），失败时为`NULL`。如果失败，原始内存块将保持不变。'
- en: '`reallocarray` has one real advantage over `realloc` – safety. From the man
    page on *realloc(3),* see this snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`reallocarray`相对于`realloc`有一个真正的优势——安全性。从*realloc(3)*的手册页上看到这段代码：'
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also realize that the `reallocarray` API is a GNU extension; it will work on
    modern Linux but should not be considered portable to other OSes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，`reallocarray`API是GNU的扩展；它将在现代Linux上工作，但不应被认为在其他操作系统上是可移植的。
- en: 'Finally, consider this: some projects have strict alignment requirements for
    their data objects; using `calloc`(or even allocating said objects via `malloc(3)`)
    can result in subtle bugs! Later in this chapter, we''ll use the `posix_memalign(3)`API—it
    guarantees allocating memory to a given byte alignment (you specify the number
    of bytes)! For example, requiring a memory-allocation to be aligned to a page
    boundary is a fairly common occurrence (Recall, malloc always returns a memory
    region that is aligned on an 8-byte boundary).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请考虑：一些项目对其数据对象有严格的对齐要求；使用`calloc`（甚至通过`malloc(3)`分配这些对象）可能导致微妙的错误！在本章后面，我们将使用`posix_memalign(3)`API——它保证按给定的字节对齐分配内存（您指定字节数）！例如，要求内存分配对齐到页面边界是相当常见的情况（请回忆，malloc总是返回一个按8字节边界对齐的内存区域）。
- en: 'The bottom line: be careful. Read the documentation, think, and decide which
    API would be appropriate given the circumstances. More on this in the *Further
    reading *section on the GitHub repository.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 底线：小心。阅读文档，思考，并决定在特定情况下哪个API更合适。在GitHub存储库的*进一步阅读*部分中有更多信息。
- en: Beyond the basics
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础之外
- en: In this section, we will dig a bit deeper into dynamic memory management with
    the `malloc(3)` API family. Understanding these areas, and the content of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and  [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*,
    will go a long way in helping developers effectively debug common memory bugs
    and issues.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨`malloc(3)`API系列的动态内存管理。了解这些领域，以及[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)的内容，*Linux内存问题*，以及[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*，将有助于开发人员有效地调试常见的内存错误和问题。
- en: The program break
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序中断
- en: When a process or thread wants memory, it invokes one of the dynamic memory
    routines—usually `malloc(3)` or `calloc(3)`; this memory (usually) comes from
    the **heap segment**. As mentioned earlier, the heap is a dynamic segment – it
    can grow (toward higher virtual addresses). Obviously though, at any given point
    in time, the heap has an endpoint or top beyond which memory cannot be taken.
    This endpoint—the last legally reference-able location on the heap – is called
    the **program break**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程或线程需要内存时，它调用动态内存例程之一——通常是`malloc(3)`或`calloc(3)`；这段内存（通常）来自**堆段**。如前所述，堆是一个动态段——它可以增长（朝着更高的虚拟地址）。显然，但是，在任何给定的时间点，堆都有一个终点或顶部，超过这个顶部就不能再取内存了。这个终点——堆上最后一个合法可引用的位置——称为**程序中断**。
- en: Using the sbrk() API
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sbrk() API
- en: 'So, how do you know where the current program break is? That''s easy – the
    `sbrk(3)` API, when used with a parameter value of zero, returns the current program
    break! Let''s do a quick lookup:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何知道当前程序中断在哪里？这很容易——当使用参数值为零的`sbrk(3)`API时，它会返回当前程序中断！让我们快速查找一下：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see some sample output as follows when the preceding line of code
    runs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码行运行时，您将看到以下示例输出：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It works, but why does the program break value keep changing (seemingly randomly)?
    Well, it really *is* random: for security reasons, Linux randomizes the layout
    of a process''s virtual address space (we covered the process VAS layout in [Chapter
    2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*). This technique
    is called **Address Space Layout Randomization** (**ASLR**).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，但为什么程序中断值保持改变（看起来是随机的）？嗯，它确实是随机的：出于安全原因，Linux随机化了进程的虚拟地址空间布局（我们在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中介绍了进程VAS布局，*虚拟内存*）。这种技术称为**地址空间布局随机化**（**ASLR**）。
- en: 'Let''s do a bit more: we will write a program that, if run without any parameters,
    merely displays the current program break and exits (like the one we just saw);
    if passed a parameter – the number of bytes of memory to dynamically allocate –
    it does so (with `malloc(3)`), then prints the heap address returned as well as
    the original and current program break. Here, you will only be allowed to request
    less than 128 KB, for reasons that will be made clear shortly.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一点：我们将编写一个程序，如果没有任何参数运行，仅显示当前程序中断并退出（就像我们刚才看到的那样）；如果传递一个参数——动态分配内存的字节数，它将这样做（使用`malloc(3)`），然后打印返回的堆地址以及原始和当前程序中断。在这里，您只能请求少于128KB的内存，稍后将会解释原因。
- en: 'Refer to the `ch4/show_curbrk.c`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参考`ch4/show_curbrk.c`：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s try it out:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Interesting (see the following diagram)! With an allocation of 1,024 bytes,
    the heap pointer that's returned to the start of that memory chunk is `0x1488670`;
    that's `0x1488670 - 0x1488000 = 0x670 = 1648` bytes from the original break.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣（见下图）！使用1024字节的分配，返回到该内存块开头的堆指针是`0x1488670`；这是从原始中断的`0x1488670 - 0x1488000
    = 0x670 = 1648`字节。
- en: 'Also, the new break value is `0x14a9000`, which is `(0x14a9000 - 0x1488670
    = 133520)`, approximately 130 KB from the freshly allocated block. Why did the
    heap grow by so much for a mere 1 KB allocation? Patience; this, and more, will
    be examined in the next section, *How malloc(3) really behaves.* Meanwhile, refer
    to the following diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，新的中断值是`0x14a9000`，即`(0x14a9000 - 0x1488670 = 133520)`，大约从新分配的块增加了130KB。为什么堆为了仅仅1KB的分配而增长了这么多？耐心等待；这个问题以及更多内容将在下一节*malloc(3)的真正行为*中进行探讨。同时，请参考下图：
- en: '![](img/ecb44780-bcc1-448b-9677-5f2fa6f43f36.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecb44780-bcc1-448b-9677-5f2fa6f43f36.png)'
- en: Heap and the Program Break
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和程序中断
- en: 'With respect to the preceding diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的图表：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `sbrk(2)` can be used to increment or decrement the program break
    (by passing it an integer parameter). At first glance, this might seem like a
    good way to allocate and deallocate dynamic memory; in reality, it's always better
    to use the well-documented and portable glibc implementation, the `malloc(3)`
    family APIs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sbrk(2)`可以用于增加或减少程序断点（通过传递整数参数）。乍一看，这似乎是分配和释放动态内存的一种好方法；实际上，最好使用经过充分记录和可移植的glibc实现，即`malloc(3)`家族的API。
- en: '`sbrk` is a convenient library wrapper over the `brk(2)` system call.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbrk`是对`brk(2)`系统调用的一个方便的库包装。'
- en: How malloc(3) really behaves
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3)的真正行为
- en: The general consensus it that `malloc(3)` (and `calloc(3)` and `realloc[array](3)`)
    obtains its memory from the heap segment. This is indeed the case, but digging
    a bit deeper reveals that it's not *always* the case. The modern glibc `malloc(3)`
    engine uses some subtle strategies to make the most optimal use of available memory
    regions and the process VAS—which, especially on today's 32-bit systems, is fast
    becoming a rather scarce resource.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍的共识是，`malloc(3)`（以及`calloc(3)`和`realloc[array](3)`）从堆段获取其内存。这确实是事实，但深入挖掘会发现这并非*总是*如此。现代的glibc
    `malloc(3)`引擎使用一些微妙的策略来最优化地利用可用的内存区域和进程VAS——尤其是在当今的32位系统上，这已经成为一种相当稀缺的资源。
- en: 'So, how does it work? The library uses a predefined `MMAP_THRESHOLD` variable – its
    value is 128 KB by default – to determine from where memory gets allocated. Let''s
    imagine we are allocating *n* bytes of memory with malloc(n):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？库使用预定义的`MMAP_THRESHOLD`变量–其默认值为128 KB–来确定从哪里分配内存。让我们想象一下，我们正在使用malloc(n)分配*n*字节的内存：
- en: If *n < MMAP_THRESHOLD,* use the heap segment to allocate the requested *n*
    bytes
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n < MMAP_THRESHOLD*，则使用堆段来分配请求的*n*字节
- en: If *n >= MMAP_THRESHOLD*, and if n bytes are not available on the heap's free
    list, use an arbitrary free region of virtual address space to satisfy the requested
    *n* bytes allocation
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n >= MMAP_THRESHOLD*，并且堆的空闲列表中没有n字节可用，则使用虚拟地址空间的任意空闲区域来满足请求的*n*字节分配。
- en: How exactly is the memory allocated in the second case? Ah, `malloc(3)` internally
    calls `mmap(2)` – the memory map system call. The `mmap` system call is very versatile.
    In this case, it is made to reserve a free region of n bytes of the calling process's
    virtual address space!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况下内存是如何分配的？啊，`malloc(3)`在内部调用`mmap(2)`——内存映射系统调用。`mmap`系统调用非常灵活。在这种情况下，它被用来保留调用进程的虚拟地址空间中的n字节的空闲区域！
- en: Why use `mmap(2)`? The key reason is that mmap-ed memory can always be freed
    up (released back to the system) in an independent fashion whenever required;
    this is certainly not always the case with `free(3)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`mmap(2)`？关键原因是mmap的内存总是可以在需要时以独立的方式释放（归还给系统）；这在使用`free(3)`时并非总是如此。
- en: Of course, there are some downsides: `mmap` allocations can be expensive because,
    the memory is page-aligned (and could thus be wasteful), and the kernel zeroes
    out the memory region (this hurts performance).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点：`mmap`分配可能很昂贵，因为内存是页面对齐的（因此可能是浪费的），而且内核会将内存区域清零（这会影响性能）。
- en: The `mallopt(3)` man page (circa December 2016) also notes that nowadays, glibc
    uses a dynamic mmap threshold; initially, the value is the usual 128 KB, but if
    a large memory chunk between the current threshold and `DEFAULT_MMAP_THRESHOLD_MAX`
    is freed, the threshold is increased to become the size of the freed block.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`mallopt(3)`手册页（截至2016年12月）还指出，现在的glibc使用动态mmap阈值；最初的值是通常的128 KB，但如果在当前阈值和`DEFAULT_MMAP_THRESHOLD_MAX`之间释放了一个大内存块，阈值就会增加到与释放块的大小相同。'
- en: Code example – malloc(3) and the program break
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例– malloc(3)和程序断点
- en: 'Seeing for ourselves the effect of `malloc(3)` allocations on the heap and
    process virtual address space is interesting and educational. Check out the output
    of the following code example (the source is available in this book''s Git repository):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们亲眼看到`malloc(3)`分配对堆和进程虚拟地址空间的影响是有趣且富有教育意义的。查看以下代码示例的输出（源代码可在本书的Git存储库中找到）：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are several scenarios running in this application; let's examine some
    of them now.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中有几种情景正在运行；现在让我们来检查其中的一些。
- en: Scenario 1 – default options
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景1–默认选项
- en: 'We run the `malloc_brk_test` program with no parameters, that is, using the
    defaults:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以默认方式运行`malloc_brk_test`程序，即不使用任何参数：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The process prints out its initial program break value: `0x1c97000`. It then
    allocates just 8 bytes (via the `malloc(3)` API); under the hood, the glibc allocation
    engine invokes the *sbrk(2)* system call to grow the heap; the new break is now `0x1cb8000`,
    an increase of 135,168 bytes = 132 KB from the previous break (clearly seen in
    the `delta` column in the preceding code)!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 进程打印出其初始程序断点值：`0x1c97000`。然后它只分配了8字节（通过`malloc(3)`API）；在幕后，glibc分配引擎调用了*sbrk(2)*系统调用来增加堆；新的断点现在是`0x1cb8000`，比之前的断点增加了135,168字节=
    132 KB（在前面的代码中的`delta`列中清楚可见）！
- en: 'Why? Optimization: glibc anticipates that, in the future, the process will
    require more heap space; instead of the expense of invoking a system call (*`sbrk/brk`)*
    each time, it performs one large-ish heap-growing operation. The next two `malloc(3)` APIs
    (numbers 1 and 2 in the left-most column) prove this is the case: we allocate
    4,083 and 3 bytes respectively, and what do you notice? The program break does
    *not* change – the heap is already large enough to accommodate the requests.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么？优化：glibc预期，将来进程将需要更多的堆空间；而不是每次调用系统调用（*`sbrk/brk`)*的开销，它执行一次相当大的堆增长操作。左侧列中的下两个`malloc(3)`API（编号为1和2）证明了这一点：我们分别分配了4,083和3字节，你注意到了什么？程序断点*没有*改变–堆已经足够大，可以容纳这些请求。 '
- en: Scenario 2 – showing malloc statistics
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景2–显示malloc统计信息
- en: 'This time, we pass the `1` parameter, asking it to display `malloc(3)` statistics
    as well (achieved using the `malloc_stats(3)` API):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们传递了`1`参数，要求它也显示`malloc(3)`的统计信息（使用`malloc_stats(3)`API实现）：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is similar, except the program invokes the useful `malloc_stats(3)`
    API, which queries and prints `malloc(3)` state information to `stderr` (by the
    way, an arena is an allocation area that''s internally maintained by the `malloc(3)`
    engine). From this output, notice that:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类似，除了程序调用有用的`malloc_stats(3)` API，该API查询并打印`malloc(3)`的状态信息到`stderr`（顺便说一句，arena是`malloc(3)`引擎内部维护的分配区域）。从这个输出中，注意到：
- en: The available free memory – system bytes – is 132 KB (after performing a tiny
    8 byte `malloc(3)`)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的空闲内存-系统字节-为132 KB（在执行一个小的8字节`malloc(3)`之后）
- en: In-use bytes increases with each allocation but system bytes remains the same
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次分配时，正在使用的字节都会增加，但系统字节保持不变
- en: '`mmap` regions and `mmap` bytes is zero as no mmap-based allocations have occurred.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`区域和`mmap`字节数为零，因为没有发生基于mmap的分配。'
- en: Scenario 3 – large allocations option
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景3-大分配选项
- en: 'This time, we pass the `2` parameter, asking the program to perform larger
    allocations (greater than `MMAP_THRESHOLD`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们传递了`2`参数，要求程序执行更大的分配（大于`MMAP_THRESHOLD`）：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (Note that the preceding code we have clipped the output of the first two small
    allocations and only show the relevant large ones).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们已经剪辑了前两个小分配的输出，并且只显示了相关的大分配）。
- en: 'Now, we allocate 132 KB (point 3 in the preceding output); some thing to take
    note of are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们分配132 KB（前面输出的第3点）；需要注意的是：
- en: 'The allocations (#3 and #4) are for 132 KB and 1 MB – both above the `MMAP_THRESHOLD`
    (value of 128 KB)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配（＃3和＃4）分别为132 KB和1 MB - 都超过了`MMAP_THRESHOLD`（值为128 KB）
- en: The (arena 0) heap *in-use bytes* (5,792) has *not* changed at all across these
    two allocations, indicating that heap memory has *not* been used
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （arena 0）堆*正在使用的字节*（5,792）在这两个分配中完全没有改变，表明堆内存*没有*被使用
- en: The max mmap regions and max mmap bytes numbers have changed to positive values
    (from zero), indicating the use of mmap-ed memory
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的mmap区域和最大的mmap字节数已经改变为正值（从零开始），表示使用了mmap内存
- en: A couple of remaining scenarios will be examined later.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后将检查剩下的几种情况。
- en: Where does freed memory go?
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放的内存去哪了？
- en: '`free(3)`, of course, is a library routine – so it stands to reason that when
    we free up memory, previously allocated by one of the dynamic allocation routines,
    it does not get freed back to the system, but rather to the process heap (which,
    of course, is virtual memory).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`free(3)`，当然，是一个库例程，所以可以推断，当我们释放内存，之前由动态分配例程之一分配的内存不会被释放回系统，而是被释放到进程堆（当然，这是虚拟内存）。'
- en: 'However, there are at least two cases where this may not occur:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，至少有两种情况下可能不会发生这种情况：
- en: If the allocation was satisfied internally via *mmap* rather than via the heap
    segment, it gets immediately freed back to the system
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分配是通过*mmap*而不是通过堆段内部满足的，它会立即被释放回系统。
- en: On modern glibc, if the amount of heap memory being freed is very large, this
    triggers the return of at least some of the memory chunks back to the OS.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代的glibc上，如果释放的堆内存量非常大，这会触发将至少一些内存块返回给操作系统。
- en: Advanced features
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级功能
- en: 'A few advanced features will now be covered:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将介绍一些高级功能：
- en: Demand paging
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求分页
- en: Locking memory in RAM
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定内存在RAM中
- en: Memory protection
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存保护
- en: Allocation with the *alloca(3)*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*alloca(3)*进行分配
- en: Demand-paging
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求分页
- en: Most of us know that if a process dynamically allocates memory, with `malloc`,
    say it does `ptr = malloc(8192) ;`, then, assuming success, the process is now
    allocated 8 KB of physical RAM. It might come as a surprise, but, on modern OSes
    such as Linux, this is actually not the case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都知道，如果一个进程动态分配内存，使用`malloc`，比如它做了`ptr = malloc(8192) ;`，然后，假设成功，进程现在分配了8
    KB的物理RAM。这可能会让人感到惊讶，但是，在现代的操作系统如Linux上，实际上并不是这样。
- en: So, what is the case? (In this book, we do not delve into kernel-level details.
    Also, as you might be aware, the granularity of memory at the level of the OS
    allocator is a *page*, which is typically 4 KB.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，情况是什么？（在本书中，我们不深入研究内核级细节。另外，正如你可能知道的，操作系统分配器的内存粒度是*页面*，通常为4 KB。）
- en: It's not a good idea to assume anything when writing robust software. So, how
    can you correctly determine the page size on the OS? Use the `sysconf(3)` API;
    for example, `printf("page size = %ld\n", **sysconf(_SC_PAGESIZE)**);`, which
    outputs `page size = 4096`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写健壮的软件时，假设任何事情都不是一个好主意。那么，如何正确确定操作系统的页面大小？使用`sysconf(3)` API；例如，`printf("page
    size = %ld\n", **sysconf(_SC_PAGESIZE)**);`，输出`page size = 4096`。
- en: 'Alternatively, use the `getpagesize(2)` system call to retrieve the system
    page size. (Importantly, see [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covering similar points in the section *A
    Programmer’s Checklist: 7 Rules*).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`getpagesize(2)`系统调用来检索系统页面大小。（重要的是，参见[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，在*程序员的清单：7条规则*部分涵盖了类似的观点）。
- en: Realistically, all malloc does is reserve virtual pages of memory from the process
    VAS.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有的malloc只是从进程VAS中保留虚拟页面的内存。
- en: So, when does the process get the actual physical pages? Ah, as and when the
    process actually peeks or pokes any byte in a page, in reality when it makes any
    kind of access on any byte of the page (attempting to read/write/execute it),
    the process traps into the OS – via a hardware exception called a page fault –
    and in the OS's fault handler, if all's well, the OS allocates a physical page
    frame for the virtual page. This highly optimized manner of handing out physical
    memory to processes is called **demand-paging** – the pages are only physically
    allocated when they are actually required, on-demand! This is closely related
    to what OS folks call the memory or VM overcommit feature; yes, it's a feature,
    not a bug.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to guarantee that physical page frames are allocated after a virtual
    allocation you can:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Do `malloc(3)` followed by `memset(3)` on all the bytes in all pages
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just use the `calloc(3)`; it will set the memory to zero, thus faulting it in
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On many implementations, the second method – using `calloc(3)` – is faster than
    the first.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: It's really because of demand-paging that we can write an application that malloc's
    huge amounts of memory and never free's it; it will work as long as the process
    does not attempt to read, write, or execute any byte in any (virtual) page of
    the allocated region. Apparently, there are many real-world applications that
    are quite poorly designed and do exactly this kind of thing – allocate huge amounts
    of memory via `malloc(3)` just in case we need it. Demand-paging is an OS hedge
    against wastefully eating up huge amounts of physical memory that hardly gets
    used in practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you, the astute reader, will realize that to every upside there's
    probably a downside. In this scenario, this could conceivably happen with several
    processes simultaneously performing large memory allocations. If all of them allocate
    large portions of virtual memory and then want to actually claim those pages physically
    at around the same time, this would put a tremendous amount of memory pressure
    on the OS! And guess what, the OS makes absolutely no guarantee that it will succeed
    in servicing everyone. In fact, in the worst case, the Linux OS will run short
    of physical RAM to the extent that it must invoke a bit of a controversial component –
    the **Out-of-Memory** (**OOM**) Killer – whose job is to identify the memory-hogging
    process and kill it and its descendants, thus reclaiming memory and keeping the
    system alive. Reminds you of the Mafia, huh.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the man page on `malloc(3)` clearly notes the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If interested, dig deeper with the references in the *Further reading* section
    on the GitHub repository.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Resident or not?
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we clearly understand that the pages allocated by *malloc* and friends
    are virtual and not guaranteed to be backed by physical frames (at least to start
    with), imagine we have a pointer to a (virtual) memory region and we know its
    length. We would now like to know whether the corresponding pages are in RAM,
    that is, whether they are resident or not.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out there''s a system call available that gives precisely this information:
    `mincore(2)`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `mincore(2)` system call is pronounced m-in-core, not min-core. Co*re *is
    an old word used to describe physical memory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Given the starting virtual address and length, `mincore(2)` populates the third
    parameter – a vector array. After the call successfully returns, for every byte
    of the vector array, if the LSB (Least Significant Bit) is set, it implies that
    the corresponding page *is* resident (in RAM), otherwise it's not (possibly not
    allocated or in swap).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage details are available via the `mincore(2)` man page: [https://linux.die.net/man/2/mincore](https://linux.die.net/man/2/mincore).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you should realize that the information returned on page residency
    is merely a snapshot at that point in time of the state of the memory pages: it
    could change under us, that is, it is (or could be) very transient in nature.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Locking memory
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We understand that on a virtual memory-based OS, such as Linux, a usermode
    page can be swapped at any point in time; the Linux kernel memory management code
    makes these decisions. To the regular application process, this should not matter:
    any time it attempts to access (read, write, or execute) the page content, the
    kernel will page it back into RAM, and allow it to use it as though nothing had
    occurred. This handling is generally called *servicing a page fault* (there is
    a lot more to it, but for the purpose of this discussion, this is sufficient),
    and is completely transparent to the usermode application process.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some situations where memory pages being paged – written
    from RAM to swap and vice-versa – is undesirable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Realtime applications
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography (security) applications
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In real-time applications, the key factor (at least within its critical code
    paths) is determinism *–* the iron-clad guarantee that the work will take a certain
    worst-case amount of time, and no more, no matter the load on the system.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the real-time process is executing a critical code path and a data
    page has to be paged in from the swap partition at that moment – the latency (delay)
    introduced could ruin the application's characteristics, resulting in dismal failure
    (or worse). In these cases, we, the developers, need a way to guarantee that said
    pages of memory can guaranteed to be resident in RAM, thus avoiding any page faulting.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In some types of security applications, they would likely store some secrets
    in memory (a password, a key); if the memory pages containing these are written
    out to disk (swap), there is always the possibility that it remains on disk well
    after the application exits – resulting in what's called information leakage,
    which is a bug attackers are just waiting to pounce upon! Here, again, the need
    of the hour is to guarantee that those pages cannot be swapped out.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `mlock(2)` (and friends: *mlock2* and *mlockall*) system calls; the
    express purpose of these APIs is to lock memory pages within the calling process''s
    virtual address space. Let''s figure out how to use `mlock(2)`. Here is its signature:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`int mlock(const void *addr, size_t len);`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter, `addr`, is a pointer to the (virtual) memory region to
    lock; the second parameter, `len`, is the number of bytes to lock into RAM. As
    a trivial example, take look at the following code (here, to keep it easily readable,
    we don''t show error-checking code; in a real application, please do so!):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Limits and privileges
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A privileged process, either by running as *root*, or, better yet, by having
    the `CAP_IPC_LOCK` capability bit set in order to lock memory (we shall describe
    process credentials and capabilities in detail in their own chapters - [Chapter
    7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process Credentials*, and [Chapter
    8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*), can lock
    unlimited amounts of memory.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'From Linux 2.6.9 onward, for a non-privileged process, it is limited by the `RLIMIT_MEMLOCK` soft
    resource limit (which, typically, is not set very high). Here is an example on
    an x86_64 Fedora box (as well as Ubuntu):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's just 64 KB (ditto on an embedded ARM Linux, by default).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, on a recent *Fedora 28* distro running on
    x86_64, the resource limit for max locked memory seems to have been amped up to
    16 MB! The following *prlimit(1)* outputshows just this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '`$ prlimit | grep MEMLOCK`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`MEMLOCK     max locked-in-memory address space     16777216  16777216 bytes`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Hang on a second, though; while using mlock(2), the POSIX standard requires
    that `addr` is aligned to a page boundary (that is, if you take the memory start
    address and divide it by the system page size, the remainder will be zero, that
    is, `(addr % pgsz) == 0`. You can use the `posix_memalign(3)` API to guarantee
    this; so, we can change our code slightly to accommodate this alignment requirement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following (`ch4/mlock_try.c`):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s give it a spin:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice, in the successful cases, the address returned by `posix_memalign(3)`*;*
    it's on a page boundary. We can quickly tell by looking at the last three digits (from
    the right) of the address – if they are all zeroes, it's cleanly divisible by
    page size and thus on a page boundary. This is because the page size is usually
    4,096 bytes, and 4096 decimal = 0x1000 hex!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We request 32 pages; the allocation is successful, but *mlock* fails because
    32 pages = 32*4K = 128 KB; the resource limit is just 64 KB for locked memory.
    However, when we *sudo* it (thus running with root access), it works.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Locking all pages
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*mlock* basically allows us to tell the OS to lock a certain range of memory
    into RAM. In some real-world cases, though, we cannot predict exactly which pages
    of memory we will require resident in advance (a real-time application might require
    various, or all, memory pages to always be resident).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this tricky issue, another system call – *mlockall(2)* – exists; as
    you can guess, it allows you to lock all process memory pages:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '` int mlockall(int flags);`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: If successful (remember, the same privilege restrictions apply to *mlockall*
    as to *mlock*), all the process's memory pages *–* such as text, data segments,
    library pages, stack, and shared memory segments – are guaranteed to remain resident
    in RAM until unlocked.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The *flags* argument provides further control to the application developer;
    it can be bitwise OR of the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`MCL_CURRENT`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MCL_FUTURE`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MCL_ONFAULT (Linux 4.4 onward)`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `MCL_CURRENT` asks the OS to lock all current pages within the calling
    process's VAS into memory.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you issue the *mlockall(2) *system call at initialization time,
    but the real-time process is going to perform an *malloc* of say, 200 kilobytes,
    5 minutes from now? We need to guarantee that those 200 KB of memory (which is
    50 pages, given a 4 KB page size) is always resident in RAM (otherwise, the real-time
    application will suffer too great a latency from possible future page faulting).
    That is the purpose of the `MCL_FUTURE` flag: it guarantees the memory pages that
    become part of the calling process''s VAS in the future will remain resident in
    memory until unlocked.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the *Demand-paging* section that performing *malloc* does nothing
    more than reserve virtual memory, not physical. As an example, if an (non-real-time)
    application performs a rather large allocation of a megabyte (that's 512 pages),
    we understand that only 512 virtual pages are reserved and the physical page frames
    are not actually allocated – they will get faulted in on-demand. A typical realtime
    application will therefore need to somehow guarantee that, once faulted in, these
    512 pages will remain locked (resident) in RAM. Use the `MCL_ONFAULT` flag to
    achieve this.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: This flag must be used in conjunction with either the `MCL_CURRENT` or  `MCL_FUTURE`
    flag, or both. The idea is that physical memory consumption remains extremely
    efficient (as no physical allocation is done at the time of *malloc*), and yet,
    once the application starts to touch the virtual pages (that is, read, write,
    or execute data or code within the page), the physical page frames get faulted
    in and they will then be locked. In other words, we do not pre-fault the memory,
    thus we get the best of both worlds.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The other side of the coin is that, when done, the application can unlock all
    memory pages by issuing the counterpart API: *munlockall(2)*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application dynamically allocates, say, four pages of memory. By default,
    this memory is both readable and writable; we refer to these as the *memory protections*
    on the page.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be nice if the application developer could dynamically modify memory
    protections on a per-page basis? For example, keep the first page with default
    protections, make the second page *read-only*, the third page *read+execute*,
    and on the fourth page, not allow any kind of access (a guard page, perhaps?).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this feature is precisely what the `mprotect(2)` system call is designed
    for. Let''s delve into how we can exploit it to do all that. Here is its signature:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s really quite straightforward: starting at the (virtual) address, `addr,`
    for `len` bytes (that is, from `addr` up to `addr+len-1` ), apply the memory protections
    specified by the *prot* bitmask. As the granularity of *mprotect* is a page, the
    first parameter, *addr*, is expected to be page-aligned (on a page boundary; recall
    that this is exactly what `mlock[all](2)` expects too).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter, `prot`, is where you specify the actual protections; it
    is a bitmask and can either be just the `PROT_NONE` bit or the bitwise OR of the
    remainder:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protection bit** | **Meaning of memory protection** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| `PROT_NONE` | No access allowed on the page |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| `PROT_READ` | Reads allowed on the page |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| `PROT_WRITE` | Writes allowed on the page |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `PROT_EXEC` | Execute access allowed on the page |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: Within the man page on *mprotect(2),* there are several other rather arcane
    protection bits and useful information under the NOTES section. If required (or
    just curious), read about it here: [http://man7.org/linux/man-pages/man2/mprotect.2.html](http://man7.org/linux/man-pages/man2/mprotect.2.html)*.*
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection – a code example
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider an example program where the process dynamically allocates
    four pages of memory and wants to set them up so that the memory protections for
    each page are as shown in the following table:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '| **Page #** | **Page 0** | **Page 1** | **Page 2** | **Page 3** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| Protection bits | `rw-` | `r--` | `rwx` | `---` |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: 'Relevant portions of the code are shown as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the *main* function dynamically allocates page-aligned memory (four
    pages) with the `posix_memalign(3)` API, and then invokes the memory protection
    and the memory testing functions in turn:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the memory protection function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After setting up the memory protections, we have the `main()`function invoke
    the memory testing function, `test_mem`. The second parameter determines whether
    we will attempt to write on read-only memory (we require this test case for page
    1 as it''s read-only protected):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Prior to attempting to test it, we check that the page has indeed been protected
    by the `mprotect`call (via our simple `okornot[]`array). Also, for readability,
    we build the simple `TEST_READ` and `TEST_WRITE` macros:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the process violates any of the memory protections, the OS will summarily
    kill it via the usual *segfault* mechanism (explained in detail within [Chapter
    12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)*,* *Signaling Part II*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Let's perform some test runs on the `memprot` program; first (for reasons that
    will become clear soon) we'll try it out on a generic Ubuntu Linux box, then on
    a Fedora system, and finally on an (emulated) ARM-32 platform!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Case #1.1: The `memprot`program on standard Ubuntu 18.04 LTS with parameter
    0(output reformatted for readability):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Okay, so the parameter to `memprot` is `0` or `1`; `0` implies that we do not
    perform a write-to-read-only-memory test, whereas `1` implies we do. Here, we've
    run it with the `0` parameter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things to notice within the preceding output are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The `protect_mem()` function sets up memory protections on a per-page basis.
    We have allocated 4 pages, thus we loop 4 times, and on each loop iteration `i`,
    perform `mprotect(2)` on the i-th memory page.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can clearly see in the code, it's been done in this fashion, on each
    loop iteration
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `0 : rw-`: Set page protections to `PROT_READ | PROT_WRITE`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `1 : r--`: Set page protections to `PROT_READ`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `2 : rwx`: Set page protections to `PROT_READ| PROT_WRITE | PROT_EXEC`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Page `3 : ---`: Set page protections to `PROT_NONE`, that is,  make the page
    inaccessible'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding output, the output format displayed after *mprotect* is as
    follows:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page <#>: protections: <PROT_xx|[...]> range [<start_addr>:<end_addr>]`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: All goes well; the four pages get new protections as required.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, the `test_mem()` function is invoked, which tests each page''s protections
    (the memory protection of the page is shown within square brackets in the usual
    [`rwx`] format):'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 0 [default: `rw-`]: It writes and reads a random byte within the page'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 1 [`r--`]: It reads a random byte within the page, and if the user
    passed the parameter as `1` (not the case here, but it will be in the following
    case), it attempts to write to a random byte within that page'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 2 [`rwx`]: As expected, reading and writing a random byte here succeeds'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On page 3 [`---`]: It attempts to both read and write a random byte within
    the page.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The very first access – a *read* – fails with a *segfault*; this is expected
    of course – the page has no permissions whatsoever (we reproduce the output for
    this case): `**page 3: reading: byte @ 0x55796ccd8567 is Segmentation fault**`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, with the parameter as `0`, test cases on pages 0, 1, and 2 succeed;
    as expected, any access on page 3 causes the OS to kill the process (via the segmentation-violation
    signal).
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case #1.2: The `memprot` program on standard Ubuntu 18.04 LTS with parameter
    1 (output reformatted for readability).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now re-run the program with the parameter set to `1`, thus attempting
    to write to the *read-only* page `1`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Indeed, as expected, it *segfaults* when it violates the read-only page permissions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Case #2: The `memprot`program on a standard *Fedora 28* system.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the latest and greatest *Fedora* workstation
    distribution is ver 28:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We build and run our `memprot`program on this standard *Fedora 28* workstation
    system (passing `0` as the parameter – implying that we do not attempt writing
    to the read-only memory page):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'How do we interpret the preceding output? The following is the explanation
    for the same:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'All goes well for pages 0, 1, and 3: the *mprotect* API succeeds in setting
    the page''s protections exactly as shown'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we get a failure (and a *Warning* message) when we attempt the `mprotect(2)`
    system call on page 2 with the `PROT_READ | PROT_WRITE | PROT_EXEC` attributes.  *Why?*
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usual OS security is the **Discretionary Access Control** (**DAC**) layer. Many
    modern Linux distros, including Fedora, come with a powerful security feature –
    an additional layer of security within the OS – the **Mandatory Access Control** (**MAC**) layer. These
    are implemented on Linux as **Linux Security Modules** (**LSMs**). Popular LSMs
    include the NSA's SELinux (Security-Enhanced Linux), AppArmor, Smack, TOMOYO,
    and Yama.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora uses SELinux while Ubuntu variants tend to use AppArmor. Whichever the
    case, it is often these LSMs that can fail userland-issued system calls when they
    violate a security policy. This is precisely what happened with our mprotect(2)
    system call on the third page (when the page protections were attempted to be
    set to [`rwx`])!
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a quick proof-of-concept, and to just get it working for now, we temporarily
    **disable** *SELinux* and retry:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*SELinux* is now in permissive mode; retry the application:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, it works as expected! Don''t forget to re-enable the LSM:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: An Aside – LSM logs, Ftrace
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(If you are not interested in this, feel free to skip over this section). The
    astute reader might wonder: how does one realize that it''s the OS security layer
    (the LSM) that ultimately caused the system call to fail? Broadly, there are two
    ways: check the given LSM logs, or use the kernel''s `Ftrace` functionality. The
    first way is simpler, but the second can give us insight at the level of the OS.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: LSM logs
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern Linux systems use the powerful systemd framework for process-initialization,
    logging, and more. The logging facility is called the journal and is accessed
    via the` journalctl(1)` utility. We use it to verify that it''s indeed the SELinux
    LSM that has caused the issue:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It even shows us exactly how we can allow the access.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Ftrace
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel has a very powerful built-in tracing mechanism (well, it''s
    one of them) – *Ftrace*. Using `ftrace`, you can verify that it''s indeed the
    *LSM* code that, while honoring its security policy, caused the userspace-issued
    system call to return failure. I ran a trace (with `ftrace`):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82dbe338-ea14-4d08-b883-845de7a88777.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: ftrace output snippet
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The `SyS_mprotect` function is what the *mprotect(2) *system call becomes withinthe
    kernel; `security_file_mprotect` is the LSM hook function that leads to the the
    actual SELinux function: `selinux_file_mprotect`; apparently, it fails the access.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, Ubuntu 18.04 LTS also uses an LSM – AppArmor. However, it seems
    that it has not been configured to catch this kind of *write+execute* (heap) page-protection
    case.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these topics (LSMs, ftrace) are beyond the scope of this book. To
    the curious reader (the kind we love), please see more on *LSMs* and *Ftrace*
    in the *Further reading *section on the GitHub repository.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: An experiment – running the memprot program on an ARM-32
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an interesting experiment, we will cross-compile our preceding *memprot*
    program for an **ARM system**. I have used a convenient way to do this without
    real hardware: using the powerful  **Free and Open Source Software **(**FOSS**)
    **Quick Emulator **(**QEMU**) project, to emulate an ARM Versatile Express Cortex-A9
    platform!'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-compiling the code is indeed simple: notice that there is now a `CROSS_COMPILE`
    variable in our `Makefile`*;* it''s the cross-compiler prefix – the prefix string
    identifying the toolchain (common to all tools). It''s literally prefixed onto
    the `CC` (for `gcc`, or `CL`  for clang) variable, which is the compiler used
    to build the target. Unfortunately, going into more detail regarding cross-compiling
    and root-filesystem build is beyond the scope of this book; for some help, see
    the *Tip* that follows this example''s output. Also, to keep things simple, we
    will use a direct approach – a separate target for the ARM version within the
    `Makefile`. Let''s check out the relevant portion of the `Makefile`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, as shown here, we cross-compile the `memprot_arm` program:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Aha, it''s generated an ARM executable! We copy this over to our embedded root
    filesystem, boot the (emulated) ARM board, and try it out:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''re on the (emulated) ARM-32 system prompt; let''s try running our program:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The reader will notice that, unlike on the *Fedora 28* distro on the x86_64
    system we ran this on earlier, the page 2 test case (highlighted in bold) where
    we attempt to set page 2's memory protections to [`rwx`] does succeed! Of course,
    there is no LSM installed.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to try similar experiments, running code on an emulated ARM-32,
    consider using the **Simple Embedded ARM Linux System** (**SEALS**) project, again
    pure open source, to easily build a very simple, yet working, ARM/Linux-embedded
    system: [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Similar memory-protection – setting protection attributes (rwx or none) on a
    range of memory – can be achieved with the powerful `mmap(2)` system call (We
    cover `mmap(2)` with respect to file I/O in [Chapter 18](cf0e96e2-0e5d-4fb2-abc2-742bc93b61d0.xhtml),
    *Advanced File I/O*).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection keys – a brief note
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recent Intel 64-bit processors bring to the table a feature called **Memory
    Protection Keys** (**MPK**). Very briefly, MPK (or *pkeys*, as it''s called on
    Linux) allows userspace to set permissions with page granularity, too. So, if
    it does the same thing as *mprotect* or *mmap*, what benefit does it bring? See
    the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: It's a hardware feature, so setting a huge range of pages (say, gigabytes of
    memory) to some particular memory permissions will be much faster than `mprotect(2)` 
    can manage; this is important for some types of applications
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications (in-memory databases, perhaps) could benefit by turning off writes
    on memory regions until absolutely required, reducing spurious write bugs
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you exploit MPK? First, be aware that it is currently only implemented
    on recent Linux kernels and on the x86_64 processor architecture. To make use
    of it, read up on the man page (section 7) on *pkeys; *it has explanatory notes
    as well as sample code: [http://man7.org/linux/man-pages/man7/pkeys.7.html](http://man7.org/linux/man-pages/man7/pkeys.7.html).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Using alloca to allocate automatic memory
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The glibc library provides an alternate to dynamic memory-allocation with malloc
    (and friends); the `alloca(3)` API.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'alloca can be thought of as something of a convenience routine: **it allocates
    memory on the stack** (of the function it is called within). The showcase feature
    is that free is not required and, the memory is automatically deallocated once
    the function returns. In fact, `free(3)` must not be called. This makes sense:
    memory allocated on the stack is called automatic memory – it will be freed upon
    that function''s return.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, there are upsides and downsides – tradeoffs – to using  `alloca(3)`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the `alloca(3)` pros:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: No free is required; this can make programming, readability, and maintainability
    much simpler. Thus we can avoid the dangerous memory-leakage bug – a significant
    gain!
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is considered very fast, with zero internal fragmentation (wastage).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The primary reason to use it: sometimes, programmers use non-local exits, typically
    via the `longjmp(3)` and `siglongjmp(3)` APIs. If the programmer uses `malloc(3)`
    to allocate a memory region and then abruptly leaves the function via a non-local
    exit, a memory leak will occur. Using *alloca* will prevent this, and the code
    is easy to implement and understand.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are the alloca cons:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The primary downside of alloca is that there is no guarantee it returns failure
    when passed a value large enough to cause stack overflow; thus, if this actually
    does occur at runtime, the process is now in an **undefined behavior** (**UB**)
    state and will (eventually) crash. In other words, checking alloca for the NULL
    return, as you do with the `malloc(3)` family, is of no use!
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portability is not a given.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, alloca is implemented as an inline function; this prevents it from being
    overridden via a third-party library.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the code as follows (`ch4/alloca_try.c`):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s build it and try it out:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first parameter to `alloca_try` is the amount of memory to allocate (in
    bytes), while the second parameter, if `1`, has the `memset` process call on that
    memory region; if `0`, it does not.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we tried it with an allocation request of 50,000
    bytes – it succeeded for both the `memset` cases.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we deliberately pass `-1` as the first parameter, which will be treated
    as an unsigned quantity (thus becoming the enormous value of `0xffffffffffffffff` on
    a 64-bit OS!), which of course should cause `alloca(3)` to fail. Amazingly, it
    does not report failure; at least it thinks it''s okay:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But then, doing `memset`(by passing the second parameter as `1`) causes the
    bug to surface; without it, we'd never know.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'To further verify this, try running the program under the control of the library
    call tracer software, `ltrace`; we pass `1` as the first parameter, forcing the
    process to invoke `memset` after `alloca(3)`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Aha! We can see that following memset, the process receives the fatal signal
    and dies. But why doesn't the `alloca(3)` API show up in `ltrace`? Because it's
    an inlined function – ahem, one of its downsides.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'But watch this; here, we pass `0` as the first parameter, bypassing the call
    to memset after `alloca(3)`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It exits normally, as though there were no bug!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, you will recall  from [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, we saw that the default stack size for a process is 8 MB. We can test
    this fact via our `alloca_try` program:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The moment we go beyond 8 MB, `alloca(3)` allocates too much space, but does
    not trigger a crash; instead, `memset(3)` causes segfault to occur. Also, ulimit
    verifies that the stack resource limit is 8,192 KB, that is, 8 MB.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, a really, really key point: you can often end up writing software
    that seems to be correct but is, in fact, not. The only way to gain confidence
    with the software is to take the trouble to perform 100% code coverage and run
    test cases against them! It''s hard to do, but quality matters. Just do it.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused upon both the simple and more advanced aspects of dynamic
    memory management for C application developers on the Linux OS. In the initial
    section, the basic glibc dynamic memory-management APIs and their correct usage
    in code was dealt with.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to more advanced topics such as the program break (and the
    `sbrk(3)` API), how `malloc(3)` behaves internally when allocating memory of differing
    sizes, and the key concept of demand-paging. Then, we delved into the APIs that
    perform memory locking and memory region protection, and reasons to use them.
    Finally, we looked at `alloca(3)`, the alternate API. Several code examples were
    used to solidify the concepts that were learned. The next chapter will cover a
    really important topic—the variety of memory issues (defects) that can arise on
    Linux due to poor programming practices with the memory APIs
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
