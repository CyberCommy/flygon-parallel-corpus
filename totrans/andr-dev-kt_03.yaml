- en: Playing with Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we've seen Kotlin variables, type systems, and control
    structures. But to create applications, we need building blocks that allow us
    to make structures. In Java, the class is the building block of the code. Kotlin,
    on the other hand, supports functional programming; therefore, it makes it possible
    to create whole programs or libraries without any classes. Function is the most
    basic building block in Kotlin. This chapter introduces functions in Kotlin, together
    with different function features and types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic function usage in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unit` return type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vararg parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-expression functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail-recursive functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default argument values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named argument syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-level functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nothing` return type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic function declaration and usages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common first program that programmers write to test some programming
    language is the `Hello, World!` program. It is a full program that is just displaying
    `Hello, World!` text on the console. We are also going to start with this program,
    because in Kotlin it is based on a function and only on a function (no class is
    needed). So the Kotlin `Hello, World!` program looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A function defines single parameter args, which contains an array of all arguments
    used to run the program (from the command line). It is defined as non-nullable,
    because an empty array is passed to a method when the program is started without
    any arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `println` function is a Kotlin function defined in the Kotlin standard library
    that is equivalent of the Java function `System.out.println` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This program tells us a lot about Kotlin. It shows how function looks like
    and that we can define function without any class. First, let''s analyze the structure
    of the function. It starts with the `fun` keyword, and then comes the name of
    the function, parameters in the bracket, and the function body. Here is another
    example of a simple function, but this one is returning a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Good to know frame**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is much confusion around the difference between methods and function.
    Common definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A function is a piece of code that is called by name.
  prefs: []
  type: TYPE_NORMAL
- en: The method is a function associated with an instance of class (object). Sometimes
    it is called member function.
  prefs: []
  type: TYPE_NORMAL
- en: So in simpler words, functions inside classes are called **methods** . In Java,
    there are officially only methods, but academic environments are often arguing
    that static Java methods are in fact functions. In Kotlin we can define functions
    that are not associated with any object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax to call a function is the same in Kotlin as in Java, and most modern
    programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We call the double function and assign a value returned by it to a variable.
    Let's discuss the details of parameters and return types of Kotlin functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameters in Kotlin functions are declared using the Pascal notation, and
    the type of each parameter must be explicitly specified. All parameters are defined
    as a read-only variable. There is no way to make parameters mutable, because such
    behavior is error-prone and in Java it was often abused by the programmers. If
    there is a need for that, then we can explicitly shadow parameters by declaring
    local variables with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is possible, but it is treated as bad practice, so a warning will be displayed.
    A better approach is to name parameters by data they provide and variables by
    the purpose they serve. These names should be then different in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameters versus arguments** In the programming community, arguments and
    parameters are often though to be the same thing. These words cannot be used interchangeably
    because they have different meanings. An argument is an actual value that is passed
    to the function when a function is called. Parameter refers to the variables declared
    inside function declaration. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fun printSum(a1: Int, a2: Int) { // 1.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(a1 + a2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(3, 5) // 2.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`1 - a1 and a2 are parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2 - 3 and 5 are arguments`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Java, functions in Kotlin can contain multiple parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments provided to functions can be subtypes of the type specified in parameter
    declaration. As we know, in Kotlin, the supertype of all the non-nullable types
    is `Any` , so we need to use it, if we want to accept all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow null on arguments, the type needs to be specified as nullable. Note
    that `Any?` is supertype of all nullable and non-nullable types, so we can pass
    objects of any type as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Returning functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, most of the functions were defined like procedures (functions that
    does not return any values). But in fact, there are no procedures in Kotlin and
    all functions return some value. When it is not specified, the default return
    value is the `Unit` instance. We can set it explicitly for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in Java, we are defining the return type after function name and parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Unit` object is the equivalent of Java''s `void` , but it can be treated
    as any other object. So we can store it in variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, Kotlin coding conventions claims that when a function is returning
    `Unit` then the type definition **should** be omitted. This way code is more readable
    and simpler to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Good to know frame** Unit is a singleton, what means that there is only one
    instance of it. So all three conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`println(p is Unit) // Print: true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`println(p == Unit) // Print: true` `println(p === Unit) // Print: true`'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern is highly supported in Kotlin and it will be more thoroughly
    covered in [Chapter 4](text00088.html) , *Classes and objects* .
  prefs: []
  type: TYPE_NORMAL
- en: 'To return output from functions with `Unit` return type, we can simply use
    a return statement without any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no return type specified, so return type is implicitly set to Unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can just use return without any value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a function returns Unit, then return call is optional. We don't have to
    use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could also use return `Unit` , but it should not be used because that would
    be misleading and less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we specify the return type, other than the `Unit` , then we always need
    to return the value explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Function will not compile it, because no return value was specified, the if
    condition is not fulfilled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The problem can be fixed by adding a second return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Vararg parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the number of parameters is not known in advance. In such cases
    we can add a `vararg` modifier to a parameter. It allows the function to accept
    any number of arguments. Here is an example, where the function is printing the
    sum of multiple integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments will be accessible inside the method as an array that holds all the
    provided values. The type of the array will correspond to a `vararg` parameter
    type. Normally we would expect it to be a generic array holding a specified type
    (`Array<T>` ), but as we know, Kotlin has an optimized type for array of `Int`
    called `IntArray` , so this type will be used. Here, for example, is the type
    of the `vararg` parameter with the type `String` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are still able to specify more parameters before or after the
    `vararg` parameter, as long as it is clear which argument is directed to which
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, arguments provided to `vararg` parameters can be subtypes of
    the specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `joinToString` function can be invoked on lists. It is joining elements
    into a single string. On the first argument there is a separator specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One limitation with `vararg` usage is that there is only one `vararg` parameter
    allowed per function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `vararg` parameters, we can pass argument values one-by-one, but
    we can also pass an array of values. This can be done using the `spread` operator
    (`*` prefixing array), as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Single-expression functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During typical programming, many functions contain only one expression. Here
    is an example of this kind of function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or another one, which can be often found in Android projects, is a pattern
    used in `Activity` , to define methods that are just getting text from some view
    or providing some other data from the view to allow a presenter to get them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions are defined to return results of a single expression. In the
    first example, it is the result of `x * x` multiplication, and in the second one
    it is the result of the expression `emailView.text.toString()` . These kinds of
    functions are used all around Android projects. Here are some common use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting some small operations (like in the preceding `square` function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using polymorphism to provide values specific to a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that are only creating some object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that are passing data between architecture layers (like in the preceding
    example, `Activity` is passing data from the view to the presenter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming style functions that are based on recurrence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such functions are often used, so Kotlin has a notation for this kind of them.
    When a function returns a single expression, then curly braces and body of the
    function can be omitted. We specify expression directly using the equality character.
    Functions defined this way are called **single-expression** functions. Let''s
    update our `square` function, and define it as a single-expression function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, single-expression functions have expression body instead of block
    body. This notation is shorter, but whole body needs to be just a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In single-expression functions, declaring the return type is optional, because
    it can be inferred by the compiler from the type of expression. This is why we
    can simplify the `square` function, and define it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many places inside Android applications where we can utilize single
    expression functions. Let''s consider the `RecyclerView` adapter that is providing
    the layout ID and creating `ViewHolder` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we achieve high readability thanks to a single expression
    function. Single expression functions are also very popular in the functional
    world. The example will be described later, in the section about tail-recursive
    functions. Single expression function notation also pairs well with the `when`
    structure. Here is an example of their connection, used to get specific data from
    an object according to a key (use case from big Kotlin project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We don't need a type, because it is inferred from the when expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another common Android example is that we can combine when expressions with
    `activity` method `onOptionsItemSelected` that handles top bar menu clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example where the syntax of the single-expression function is useful
    is when we chain multiple operations on a single object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, single expression functions can make our code more concise and
    improve readability. Single-expression functions are commonly used in Kotlin Android
    projects and they are really popular for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative versus declarative programming** **Imperative programming** :
    This programming paradigm describes the exact sequence of steps required to perform
    an operation. It is most intuitive for most programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative programming** : This programming paradigm describes a desired
    result, but not necessarily steps to achieve it (implementation of behavior).
    This means that programming is done with expressions or declarations instead of
    statements. Both *functional* and *logic* programming are characterized as declarative
    programming style. Declarative programming is often shorter and more readable
    than imperative.'
  prefs: []
  type: TYPE_NORMAL
- en: Tail-recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursive functions are functions that are calling themselves. Let''s see an
    example of recursive function, `getState` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: They are an important part of functional programming style, but the problem
    is that each recursive function call needs to keep the return address of the previous
    function on the stack. When an application recurse too deeply (there are too many
    functions on the stack), `StackOverflowError` is thrown. This limitation presents
    a very serious problem for recurrence usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic solution for this problem was to use iteration instead of recurrence,
    but this approach is less expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A proper solution for this problem is usage of the *tail-recursive* function
    supported by modern languages such as Kotlin. Tail-recursive function is a special
    kind of recursive function, where the function is calling itself as the last operation
    it performs (in other words: recursion takes place in last operation of a function).
    This allows us to optimize recursive calls by compiler and perform recursive operations
    in a more efficient way without worrying about potential `StackOverflowError`
    . To make a function tail-recursive, we need to mark it with a `tailrec` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To check out how it is working, let''s compile this code and decompile to Java.
    Here is what can be found then (code after simplification):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation is based on iteration, so there is no way that stack overflow
    error might happen. To make the `tailrec` modifier work, there are some requirements
    to be met:'
  prefs: []
  type: TYPE_NORMAL
- en: The function must call itself only as the last operation it performs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be used within `try` /`catch` /`finally` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, it was allowed only in Kotlin compiled to JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways of calling a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to call a function and provide only selected arguments. In
    Java, we could create multiple overloads of the same method, but this solution
    has some limitations. The first problem is that the number of possible permutations
    of a given method is growing very quickly (2^n ), making them very difficult to
    maintain. The second problem is that overloads must be distinguishable from each
    other, so compiler may know which overload to call, so when a method defines a
    few parameters with the same type we can''t define all possible overloads. That''s
    why in Java, we often need to pass multiple null values to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Multiple null parameters provide boilerplate. Such a situation greatly decreases
    method readability. In Kotlin, there is no such problem, because Kotlin has a
    feature called *default arguments* and *named argument syntax* .
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Default arguments are mostly known from C++, which is one of the oldest languages
    supporting it. A default argument provides a value for a parameter in case it
    is not provided during method call. Each function parameter can have a default
    value. It might be any value that is matching a specified type including null.
    This way we can simply define functions that can be called in multiple ways. This
    is an example of a function with default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function the same way as a normal function (a function without
    default argument values) by providing values for each parameter (all arguments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the default argument values, we can call a function by providing
    arguments only for parameters without default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also provide all parameters without default values, and only some that
    have a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Named arguments syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we want only to pass a value for the last argument. Let''s suppose
    that we define want to value for a suffix, but not for a prefix and `inBracket`
    (which is defined before suffix). Normally we would have to provide values for
    all previous parameters including the default parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'By using named argument syntax, we can pass specific arguments using the argument
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows very flexible syntax, where we can supply only chosen arguments
    when calling a function (that is, the first one and the second from the end).
    It is often used to specify what this argument is because such a call is more
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set any parameters we want using named parameter syntax in any order
    as long as all parameters without default values are provided. The order of the
    arguments is relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Order of arguments is different, but both preceding calls are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use *named argument syntax* together with *classic call* . The
    only restriction is if we start using named syntax, we cannot use a classic one
    for next arguments we are serving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This feature allows us to call methods in a very flexible way without the need
    to define multiple method overloads.
  prefs: []
  type: TYPE_NORMAL
- en: The named argument syntax imposes some extra responsibility for Kotlin programmers.
    We need to keep in mind that when we change a parameter name, we may cause errors
    in the project, because the parameter name may be used in other classes. Android
    Studio will take care of it if we rename the parameter using built-in refactoring
    tools, but this will work only inside our project. The Kotlin library creators
    should be very careful while using named argument syntax. Change of the parameter
    name will break the API. Note that the named argument syntax cannot be used when
    calling Java functions, because Java bytecode does not always preserve names of
    function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Top-level functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another thing we can observe in a simple `Hello, World!` program, is that the
    `main` function is not located inside any class. In [Chapter 2](text00035.html)
    , *Laying a Foundation* , we already mentioned that Kotlin can define various
    entities at the top level. A function that is defined at top-level is called the
    **top-level function** . Here is an example of one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Top-level functions can be used all around the code (assuming that they are
    public, what is default visibility modifier). We can call them in the same way
    as functions from the local context. To access top-level function, we need to
    explicitly import it into a file by using the import statement. Functions are
    available in code hint list in Android Studio, so imports are automatically added
    when a function is selected (used). As an example, let''s see a top-level function
    defined in `Test.kt` and use it inside the `Main.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Top-level functions are often useful, but it is important to use them wisely.
    Keep in mind that defining public top-level functions will increase the number
    of functions available in code *hint list* (by *hint list* I mean a list of methods
    suggested by the IDE as hints, when we are writing code). It is because public
    top-level functions are suggested by the IDE in every context (because they can
    be used everywhere). If the name of the top-level function does not clearly state
    that this is a top-level function, then it may be confused with a method from
    the local context and used accidentally. Here are some good examples of top-level
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`factorial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxOf` and `minOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`println`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of functions that may be poor candidates for top level
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sendUserData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`showPossiblePlayers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is applicable only in Kotlin object-oriented programming projects.
    In function-oriented programming projects, these are valid top-level names, but
    then we suppose that nearly all functions are defined in the top-level and not
    as methods.
  prefs: []
  type: TYPE_NORMAL
- en: Often we define functions we want to use only in specific modules or specific
    classes. To limit function visibility (place where it can be used) we can use
    visibility modifiers. We will discuss visibility modifiers in [Chapter 4](text00088.html)
    *, Classes and Objects* .
  prefs: []
  type: TYPE_NORMAL
- en: Top-level functions under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Android projects, Kotlin is compiled to Java bytecode that runs on
    Dalvik Virtual Machine (before Android 5.0) or Android Runtime (Android 5.0 and
    newer). Both virtual machines can execute only the code that is defined inside
    a class. To solve this problem Kotlin compiler generates classes for top-level
    functions. The class name is constructed from the file name and `Kt` suffix. Inside
    such a class, all functions and properties are static. For example, let''s suppose
    that we define a function within the `Printer.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin code is compiled into Java bytecode. The generated bytecode will be
    analogical to the code generated from the following Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`PrinterKt` is the name made from the name of file and `*Kt*` suffix.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All top-level functions and properties are compiled to static methods and variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print` is a Kotlin function, but since it is an inline function, its call
    is replaced by its body during compilation time. And its body includes only `System.out.println
    call` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inline functions will be described in [Chapter 5](text00125.html) , *Functions
    as a First Class Citizen* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin class at Java bytecode level will contain more data (for example, name
    of parameters). We can also access Kotlin top-level functions from Java files
    by prefixing a function call with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, Kotlin top-level functions calls from Java are fully supported. As
    we can see, Kotlin is really interoperable with Java. To make Kotlin top-level
    functions usage more comfortable in Java, we can add an annotation that will change
    the name of a JVM generated class. This comes in handy when making usage of top-level
    Kotlin properties and functions from Java classes. This annotation looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the `JvmName` annotation at the top of the file (before package
    name). When this is applied, the name of the generated class will be changed to
    `Printer` . This allows us to call the `printTwo` function in Java using Printer
    as the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes we are defining top-level functions, and we want to define them in
    separate files, but we also want them in the same class after compilation to JVM.
    This is possible if we use the following annotation in top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s assume that we are making a library with mathematical helpers
    that we want to use from Java. We can define the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use it from Java classes this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this, we can keep files short and simple, while keeping them all easy
    to use from Java.
  prefs: []
  type: TYPE_NORMAL
- en: The `JvmName` annotation to change generated class names is especially useful
    when we create libraries in Kotlin that are also directed to be used in Java classes.
    It can be useful in case of name conflicts too. Such a situation can occur when
    we create both an `X.kt` file with some top-level functions or properties and
    an `XKt` class in the same package. But it is rare and should never take place
    since there is a convention that no classes should have `Kt` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin allows defining functions in many contexts. We can define functions
    at top-level, as members (inside the `class` , `interface` , and so on), and inside
    other function (local function). Consider the following example of the definition
    of local function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`printThree` is a local function, because it is located inside another function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local functions are not accessible from outside the function they were declared
    in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Elements accessible inside local functions don''t have to be passed from enclosing
    functions as arguments because they are accessible directly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Local function can access comment parameter and local variables (downloaded
    and IDs), defined inside an enclosing function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we would like to define `printLog` as a top-level function then we would
    have to pass as arguments both `ids` and `downloaded` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is not only longer, but also harder to maintain. Changes
    in `printLog` might demand different parameters, and a change in parameters demands
    changes in arguments in this function call. Also, if we change the `loadUsers`
    parameter type that is used in `printLog` then we will need to also change the
    parameter of `printLog` . There would be no such problems if `printLog` was a
    local function. This explains when local functions should be used: When we are
    extracting functionality that is used only by a single function, and that functionality
    is using elements (variables, values, parameters) of this function. Also, local
    functions are allowed to modify local variables. Like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can extract and reuse functionality that could not be extracted
    in Java. It is good to remember about local functions, because they sometimes
    allow code extraction that is hard to implement in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing return type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to define a function that is always throwing exceptions (never
    terminating normally)*.* Two real-life use cases are:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that simplify error throwing. This is especially useful in libraries
    where error system is important and there is a need to provide more data about
    error occurrence. (As an example look at the `throwError` function presented in
    this section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions used for throwing errors in unit tests. This is useful when we need
    to test error handling in our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these kinds of situations, there is a special class called `Nothing` .
    The `Nothing` class is empty type (uninhabited type), meaning it has no instances.
    A function that has `Nothing` return type won''t return anything and it will never
    reach `return` statement. It can only throw an exception. This is why when we
    see that function is returning `Nothing` , then it is designed to throw exceptions.
    This way we can distinguish functions that do not return a value (like Java''s
    `void` , Kotlin''s `Unit` ) from functions that never terminate (returns `Nothing`
    ). Let us have a look at an example of functions that might be used to simplify
    error throwing in unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And functions that are constructing complex error messages using elements available
    in context where it is defined (in class or function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of function is that it can be used, just like a `throw` statement,
    as an alternative that is not influencing function returned type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'How is it possible? This is a special trait of the `Nothing` class, which is
    acting as if it is a subtype of all the possible types: both nullable and not-nullable.
    This is why `Nothing` is referred as an **empty type** , which means that no value
    can have this type at runtime, and it''s also a subtype of every other class.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The concept of uninhabited type is new in the world of Java, and this is why
    it might be confusing. The idea is actually pretty simple. The `Nothing` instance
    is never existing, while there is only an error that might be returned from functions
    that are specifying it as a return type. And there is no need for `Nothing` added
    to something to influence its type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve seen how to define and use functions. We learned how
    functions can be defined on the top-level or inside other functions. There was
    also a discussion on different features connected to functions--vararg parameters,
    default names, and named argument syntax. Finally, we saw some Kotlin special
    return types: `Unit` , which is equivalent of Java `void` , and `Nothing` , which
    is a type that cannot be defined and means that nothing can be returned (only
    exceptions).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see how classes are defined in Kotlin.
    Classes are also specially supported by the Kotlin language, and there are lots
    of improvements introduced over Java definitions.
  prefs: []
  type: TYPE_NORMAL
