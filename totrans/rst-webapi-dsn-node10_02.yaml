- en: Getting Started with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will gain your first real Node.js experience. We will start
    by installing Node.js, along with some modules we will use throughout this book.
    Then, we will set up a development environment. Throughout the book, the Atom
    IDE will be used. Yes, GitHub's online editor has finally landed for desktop environment
    and is available on a platform of your preference!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a workspace and start developing our first Node.js application.
    It will be a simple server application processing incoming HTTP requests. We will
    go one step further, demonstrating how to modularize and unit test our JavaScript
    code. Finally, we will deploy our first application on the Heroku Cloud Application
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Express framework and other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our journey through Node.js with a Node.js installation. Installers
    are available for both Windows and macOS at [https://nodejs.org/en/download/](https://nodejs.org/en/download/). 
    At the time of writing, Node.js 10 has just been released as the current version,
    and is about to become the next Long Term Support version, in August 2018\. Linux
    users can either build Node.js from the available Linux binaries or make use of
    their package manager, as Node.js is available with most of the popular package
    repositories for different Linux distributions. For instance, Ubuntu and other
    Debian-based distributions should first point to the latest Node.js 10 package
    and then install via the `apt-get` command from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you decide to go with an installer available for macOS or Windows, a wizard
    will guide you through a rather typical installation procedure, where you will
    have to accept the Node.js license agreement and then provide an installation
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Linux users performing installations via package managers will need to install
    **Node Package Manager (npm)** separately; we will do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: After a successful installation, you should have Node set on your `PATH` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The installer will have preselected for you the Node.js runtime, npm, shortcuts
    to online documentation resources, as well as the option to add Node.js and npm
    to your operating system `PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that your installation was successful, execute the following from
    your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the latest Node.js version is 10.0.0 so, as expected,
    this version number will be the output of the version check. Node.js 10 will be
    the next Long Term Supported version, so it will stay actual for the next few
    years
  prefs: []
  type: TYPE_NORMAL
- en: Npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js eases support to third-party open source-developed modules by providing **npm**.
    It allows you, as a developer, to easily install, manage, and even provide your
    own module packages. The npm package repository is available at [http://www.npmjs.org/](http://www.npmjs.org/)
    and is accessible via its command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t use the installer, then you will need to install `npm` separately.
    For example, Ubuntu users can make use of their package installer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you upgraded your Node.js installation and you had previously installed
    npm 5.6, you would be asked to upgrade it to version 6\. To do that, just execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once npm is installed, it is useful to set it permanently in your user profile''s
    `PATH` environment variable by editing the `~/.profile` file to export the path
    to npm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful npm installation, use npm''s `ls` option to display the
    currently-installed Node.js modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Express framework and other modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `npm` installed, let''s make use of it and install some of
    the modules we will be using heavily throughout this book. The most important
    among them is the Express framework ([http://www.expressjs.com/](http://www.expressjs.com/)).
    It is a flexible web application framework for Node.js, providing a robust RESTful
    API for developing single or multi-page web applications. The following command
    will download the Express module from the npm repository and make it available
    for our local Node.js installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the `express` module among the results of an `npm ls` after a
    successful installation. Later in this chapter, we will learn how to write unit
    tests for our Node.js modules. We will need the `nodeunit` module for that purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-g` option will install `nodeunit` globally. This means that the module
    will be stored at a central place on your filesystem; usually, that is either `/usr/lib/node_modules` or** `/usr/lib/node`**,
    but that can be configured to the global configuration of your Node.js. Globally
    installed modules are available to all running node applications.
  prefs: []
  type: TYPE_NORMAL
- en: Locally installed modules will be stored in a `node_modules` subdirectory of
    the current working directory of your project and will be available only to that
    single project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, coming back to the `nodeunit` module—it provides basic assert test functions
    for creating basic unit tests as well as tools for executing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to develop with Node.js, we have one more thing to look into:
    the package descriptor file of a Node.js application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All Node.js applications or modules contain a `package.json` descriptor file.
    It provides meta-information about the module, its authors, and the dependencies
    it uses. Let''s take a look at the `package.json` file of the `express` module
    we installed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The name and the version of the package are mandatory properties for every module.
    All other pieces of meta-information, such as the contributors list, repository
    type and location, license information, and so on, are optional. One of the most
    interesting properties, which is worth mentioning, is the `dependencies` property.
    It tells npm which modules your package depends on. Let's take a deeper look at
    how this is specified. Each dependency has a name and a version.
  prefs: []
  type: TYPE_NORMAL
- en: This tells npm that the package depends on the `accepts` module with version
    1.3.4 and the `body-parse` module with version 1.8.2\. So, when npm installs the
    module, it will implicitly download and install the latest minor versions of the
    dependencies, in case they are not already available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version of a dependency is specified in the following format: `major.minor.patch-version`. 
    You can specify npm if you want npm to use exactly the specified version, or you
    can have npm always download the latest available minor version, by starting the
    version with `~`; see the `accepts` dependency for reference.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on versioning, visit the website of the semantic versioning
    specification at [http://www.semver.org/](http://www.semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on automatically managed version may result in backward incompatibility,
    make sure you test your application each time you switch a version.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript developers are rarely used to developing their projects in an IDE;
    most of them use text editors and tend to be prejudiced against anything that
    contradicts their views. GitHub has finally managed to calm most of them down
    by releasing the Atom IDE for the desktop environment. This may not solve all
    of the arguments about which is the best environment, but will at least bring
    some peace, and let people concentrate on their code, not on the tooling, which
    in the end is a matter of personal preference. The samples in this book are developed
    in the Atom IDE, but feel free to use any piece of software that can create files,
    including command-line editors such as vi or vim, if that would make you feel
    like a JS superhero, though bear in mind that superheroes are so 20^(th) century!
  prefs: []
  type: TYPE_NORMAL
- en: You can download the Atom IDE from [https://ide.atom.io/](https://ide.atom.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to start our first Node.js application, a simple web server responding
    with `Hello from Node.js`. Select a directory from your project, for example, `hello-node`,
    then open a shell Terminal from it and execute `npm init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A command-line interaction wizard will ask you for your project name, its version,
    as well as some other metadata such as Git repository, your name, and so on, and
    will finally preview the `package.json` file it is to generate; when complete,
    your first Node.js project is ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the appropriate time to spend some time on the code convention used in
    this book; ES6 inline anonymous functions will be used when short callback functions
    should be defined, while regular javascript function will be used when reusability
    and testability is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Atom IDE, select File | Add Project Folder..., and import the directory
    you defined the project in. Finally, after a successful import, you will see the
    generated `package.json` file in the project. Right-click on the directory, select New
    File, and create a file called `hello-node.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello-node.js` file uses the Node.js HTTP module to start listening for
    incoming requests on port `8180`. It will reply with static `Hello from Node.JS`
    to each request and will log a hello log entry in the console. Before starting
    the application, we have to install the `http` module that creates an HTTP server
    for it. Let''s install it globally together with the `--save` option, which will
    add a dependency to it in the `package.json` file of the project. Then we can
    start the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening `http://localhost:8180/` from your browser will result in sending a
    request to the server application, which will make a log entry in the console
    and will output `Hello from Node.JS` in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c01bdd5-3c7e-4458-a8f3-88140949e0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our server application will behave in the same way, no matter what
    kind of HTTP request is processed. Let's extend it in such a way that it behaves
    more like an HTTP server, and start differentiating the incoming requests based
    on their type, by implementing handler functions for each type of request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `hello-node-http-server.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this application, our HTTP server will recognize the `GET`, `POST`, `PUT`,
    and `DELETE` HTTP methods, and will handle them in different functions. To all
    other HTTP requests, it will gracefully respond with the `HTTP 400 BAD REQUEST`
    status code. To interact with the HTTP applications,  we will use Postman, available
    to download from [https://www.getpostman.com/](https://www.getpostman.com/). It
    is a lightweight application for sending HTTP requests to an endpoint, specifying
    HTTP headers, and providing payload. Give it a try and execute test requests for
    each of the handler functions we implemented previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46971774-7421-435b-98a2-125e36aa07f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Modularizing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have developed so far is a simple HTTP server application that listens
    and processes known request types; however, it is not so well structured, as the
    functions handling the requests are not reusable. Node.js supports modules embracing
    code isolation and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: A user**-**defined module is a logical unit consisting of one or more related
    functions. The module can export one or more functions to other components while
    keeping other functions visible only to itself.
  prefs: []
  type: TYPE_NORMAL
- en: We will rework our HTTP server application in such a way that the entire request
    handling functionality will be wrapped in a module. The module will export only
    a generic handler function that will take a request object as argument and, based
    on its request type, it will delegate the handling to inner functions not visible
    outside the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new module directory within our project. We will
    refactor our previous source file by extracting the following functions to a new
    `http-module.js` file inside the newly created directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This file creates a user-defined module that exports the `handleRequest` function,
    making it available to the other components. All the other functions are accessible
    only within the module. Although the sample exports only one function, a module
    can export as many functions as is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the new `http-module` in the `main.js` file in the `main` directory
    of our first project. We have to create an `http` server using the Node.js built-in `http`
    module, and its `createServer` will pass its `handleRequest` function as its argument.
    It will serve as a callback function that the server will invoke on each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We separated the creation of the server socket from the business logic that
    handles the incoming requests bound to it. The `require` directive is used to
    import our module. It uses a relative path to it. Try this version as well by
    executing another test request with the Postman tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we will not be creating our own HTTP handlers when implementing our
    RESTful-enabled applications. The Express framework will do this for us. The examples
    in this chapter are meant to provide a clear example of the Node.js possibilities
    when it comes to handling HTTP requests and how user modules are implemented.
    We will take a detailed look at the Express framework in [Chapter 3](5196664d-ad9d-4430-ae89-0f514a9508f5.xhtml),
    *Building a Typical Web API*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will extend our project by providing a unit test for the HTTP module,
    but before diving into that, let's have a look at how Node.js supports unit testing
    in general. At the beginning of this chapter, we installed the Nodeunit module.
    Well, it's about time we started playing around with it.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create another simple Node.js module that we will use to implement
    our first unit test. Then we will move to more advanced topics, such as mocking
    JavaScript objects and using them to create unit tests for our HTTP module.
  prefs: []
  type: TYPE_NORMAL
- en: I have chosen to develop a simple math module that exports functions for adding
    and subtracting integer numbers, as it is straightforward enough and the results
    of each operation are strictly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the module and create the following `math.js` file in our
    `module` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will be to create a `test-math.js` file in the `test` subdirectory
    of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the test module from a shell Terminal with `nodeunit test/test-math.js`.
    The output will show the results of all the test methods, specifying whether they
    passed successfully or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify `addTest` in such a way that it gets broken and to see how test
    failures are reported by the Nodeunit module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the test this time results in a failure with some assert failure
    messages, and in the end, there is an aggregation saying how many of the executed
    tests failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We just created our Nodeunit's first unit test. However, it tests math function
    in a rather isolated way. I suppose you are wondering how we can use Nodeunit
    to test functions with complex arguments such as HTTP request and response, that
    are bound to a context. This is possible using so-called **mock objects**. They
    are a predefined version of the state of complex context-based arguments or functions,
    in objects that we want to use in our unit test in order to test the behavior
    of our module for the exact state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: To use mock objects, we will need to install a module that supports object mocking.
    There are various types of testing tools and modules available out there. Most
    of them, however, are designed to test the JavaScript client functionality. There
    are modules such as JsMockito, a JavaScript fork of the famous Mockito framework
    for Java, and node-inspector, a module that provides a JavaScript debugger that
    starts implicitly in the Google Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: Native support for the Chrome browser is logical, since Node.js is built on
    top of the Google V8 JavaScript Engine. As we are developing a server-side application,
    these are not the most convenient tools, as JsMockito is not pluggable as a Node.js
    module, and using a debugger within your browser to debug backed applications
    just doesn't seem right to me. Anyway, if you are about to dive deeper into Node.js,
    you should definitely give them a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing server-side JavaScript modules, we will use the Sinon.JS module.
    Like all the other modules, it is available in the npm repository, so execute
    the following command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sinon.JS is a very flexible JavaScript testing library providing functionality
    for mocking, stubbing, and spying on JavaScript objects. It is available at [http://sinonjs.org](http://sinonjs.org)
    and can be used with any JavaScript testing framework. Let's see what we need
    in order to test our HTTP module. It exports a single method, `handleRequest`,
    which takes the HTTP request and response objects as arguments. Based on the requested
    method, the module calls its internal functions to handle different requests.
    Each request handler writes a different output to the response.
  prefs: []
  type: TYPE_NORMAL
- en: To test this functionality in an isolated environment such as Nodeunit, we need
    mock objects, which will then be passed as arguments. To ensure that the module
    behaves as expected, we will need to have access to the data stored in those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps that need to be carried out when using mock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `require` function with `sinon` as a parameter and export a `test`
    function from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an API description of the method you want to mock as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `sinon` within the exported function in order to create mock objects out
    of the `api` description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the expectations on the mock objects. Expectations are set on the mocked
    objects by describing how the mocked method should behave, what arguments it is
    supposed to take, and what value it is supposed to return. When the mocked method
    is called with a different state than what is described, the expectation will
    fail when verified later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample expects that `methodX` gets called exactly once with the
    `xyz` argument, and it will force the method to return `abc`. The Sinon.JS module
    makes that possible for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method of the description object is called and not that of the mocked object.
    The mocked object is used to set the expectations for the mocked method, and later
    to check whether those expectations have been fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Use the mocked object in the test environment and, later, call its `verify()`
    method. This method will check whether the code being tested interacted correctly
    with mock, that is, how many times the method has been called and whether it has
    been called with the expected arguments. If any of the expectations is not met,
    then an error will be thrown, causing the test to fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The exported `test` function of our test module has an argument. That argument
    provides assert methods that can be used to check test conditions. In our example,
    we mocked the method to always return `abc` when called with the `''xyz''` arguments.
    So, to complete the test, the following assert can be done, and in the end, the
    mock object needs to be verified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Try modifying the arguments passed to `methodX` such that they don't match the
    expectation, and you will see this breaking your test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put these steps into practice and create the following `test-http-module.js`
    file in the `test` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the test with Nodeunit''s `test-http-module.js` to verify that it passes
    successfully. Your next step will be to extend the test so that it covers the
    handling of all the HTTP methods in our HTTP module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Deploying an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has an event-driven, non-blocking I/O model, which makes it perfect
    for real-time applications that scale well in distributed environments, such as
    public or private cloud platforms. Each cloud platform offers tools that allow
    seamless deployment, distribution, and scaling of its hosted applications. In
    this section, we will look at two publicly available Node.js application cloud
    providers—Nodejitsu and Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's spend some time on the clustering support, as it is fundamental
    for understanding why Node.js fits so well into the cloud environment. Node.js
    comes with clustering support built in to its core. Using the cluster module in
    your applications allows them to start as many workers as necessary to handle
    the load they will face. Generally, it is recommended to match the number of workers
    to the number of threads or logical cores your environment has.
  prefs: []
  type: TYPE_NORMAL
- en: The heart of your application is the master process. It is responsible for keeping
    a registry of active workers and the load of the application, and how to create
    it. It also creates more workers when needed and reduces them when the load decreases.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud platform should also ensure that there is zero downtime when deploying
    new versions of the applications. In such cases, the master process needs to be
    notified that a newer version should be distributed. It should fork the new workers'
    new application version, and notify the workers currently running with the old
    version to close their listeners; thus, it stops accepting connections and exits
    gracefully once they finish. Thus, all the new incoming requests will be handled
    by the newly-started workers, and after the obsolete workers terminate, all the
    running workers will be running the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Nodejitsu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a closer look at some of the Node.js **Platform as a Service** (**PaaS**)
    offerings. The first PaaS we will look at is Nodejitsu, available at [https://www.nodejitsu.com](https://www.nodejitsu.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows seamless deployment of Node.js applications on the cloud, with
    many useful features for development, management, deployment, and monitoring of
    Node.js applications. To interact with jitsu, you need to install its command-line
    interface, which is available as a Node.js module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing jitsu and starting it with `jitsu`, you will be given a warm
    welcome, with a friendly console screen that will introduce you to the basic jitsu
    commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57d146c5-2355-45cd-a97c-de2762730c20.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to interact with jitsu, you will need to sign up for it. Jitsu offers
    different pricing plans, as well as free trial services.
  prefs: []
  type: TYPE_NORMAL
- en: You can do that either from their website or with the `jitsu signup` command.
    Then you can start making use of the tools the command-line interface offers.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft's cloud platform as a service, Azure, also offers hosting of Node.js
    applications. They have chosen a slightly different approach, and instead of providing
    a command-line interface to interact with their repositories, they make use of
    their Git integration; that is, you interact with Azure as you would interact
    with any other Git repository. If you are not familiar with Git, I strongly recommend
    that you learn more about this distributed source code version control system.
  prefs: []
  type: TYPE_NORMAL
- en: If you've chosen Azure as your platform, you will find the following link very
    useful: [http://azure.microsoft.com/en-us/develop/nodejs/](http://azure.microsoft.com/en-us/develop/nodejs/).
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heroku is a public cloud offering that allows you to manage, deploy, and scale
    Node.js applications. Preparing your Node application for the Heroku environment
    does not take too much effort, as long as you install its command-line interface,
    available either at [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
    or through your package manager with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All you have to do is provide a `'start script'` element in the `package.json`
    file, push it to your relevant origin Git repository using `git push master heroku`,
    then log in and create your application, using the `heroku login` and `heroku
    create` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get additional confidence about your newly-gained knowledge, go through
    the next set of statements and state whether they are true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: Node modules can export more than one function to outer components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node modules are extensible
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modules always need to explicitly declare their dependencies to other modules
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using mocking in a test environment, the mocked method is called on the
    mocked object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debugging Node.js code is not as straightforward as other pieces of non-JavaScript
    code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you gained your first Node.js experience, starting from a simple
    `Hello world` application and moving on to a more complex sample HTTP server-like
    application that handles incoming HTTP requests. Being more confident with Node.js,
    you refactored the application to use user modules, and then created unit tests
    for your module using a mocking framework to eliminate dependencies on complex
    objects in your test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've understood how to handle and test incoming HTTP requests, in
    the next chapter, our next step will be to define what a typical web API looks
    like and how it can be tested.
  prefs: []
  type: TYPE_NORMAL
