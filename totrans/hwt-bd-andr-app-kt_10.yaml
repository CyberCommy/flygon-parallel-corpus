- en: 10\. Android Architecture Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the key components of the Android Jetpack
    libraries and what benefits they bring to the standard Android framework. You
    will also learn how to structure your code and give different responsibilities
    to your classes with the help of Jetpack components. Finally, you'll improve the
    test coverage of your code.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be able to create applications that handle
    the life cycles of activities and fragments with ease. You'll also know more about
    how to persist data on an Android device using Room, as well as how to use ViewModels
    to separate your logic from your Views.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, you learned how to write unit tests. The question
    is: what can you unit test? Can you unit test activities and fragments? They are
    pretty hard to unit test on your machine because of the way they are built. Testing
    would be easier if you could move the code away from activities and fragments.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider the situation where you are building an application that supports
    different orientations, such as landscape and portrait, and supports multiple
    languages. What tends to happen in these scenarios by default is that when the
    user rotates the screen, the activities and fragments are recreated for the new
    display orientation. Now, imagine that happens while your application is in the
    middle of processing data. You have to keep track of the data you are processing,
    you have to keep track of what the user was doing to interact with your screens,
    and you have to avoid causing a context leak.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A context leak occurs when your destroyed activity cannot be garbage collected
    because it is referenced in a component with a longer life cycle – like a thread
    that is currently processing your data.
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, you would have to resort to using `onSaveInstanceState`
    in order to save the current state of your activity/fragment, and then in `onCreate`
    or `onRestoreInstanceState`, you would need to restore the state of your activity/fragment.
    This would add extra complexity to your code and would also make it repetitive,
    especially if the processing code is going to be part of your activity or fragment.
  prefs: []
  type: TYPE_NORMAL
- en: These scenarios are where `ViewModel` and `LiveData` come in. `ViewModels` are
    components built with the express goal of holding data in case of life cycle changes.
    They also separate the logic from the Views, which makes them very easy to unit
    test. `LiveData` is a component used to hold data and notify observers when changes
    occur while taking their life cycle into account. In simpler terms, the fragment
    only deals with the Views, `ViewModel` does the heavy lifting, and `LiveData`
    deals with delivering the results to the fragment, but only when the fragment
    is there and ready.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever used WhatsApp or a similar messaging app and you've turned off
    the internet, you'll have noticed that you are still able to use the application.
    The reason for this is because the messages are stored locally on your device.
    This is achieved through the use of a database file called **SQLite** in most
    cases. The Android Framework already allows you to use this feature for your application.
    This requires a lot of boilerplate code in order to read and write data. Every
    time you want to interact with the local storage, you must write a SQL query.
    When you read the SQLite data, you must convert it into a Java/Kotlin object.
    All of this requires a lot of code, time, and unit testing. What if someone else
    handles the SQLite connection and all you have to do is focus on the code part?
    This is where **Room** comes in. This is a library that is a wrapper over SQLite.
    All you need to do is define how your data should be saved and let the library
    take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you want your activity to know when there is an internet connection
    and when the internet drops. You can use something called `BroadcastReceiver`
    for this. A slight problem with this is that every time you register a `BroadcastReceiver`
    in an activity, you have to unregister it when the activity is destroyed. You
    can use `Lifecycle` to observe the state of your activity, thereby allowing your
    receiver to be registered in the desired state and unregistered in the complementary
    one (for example, `RESUMED-PAUSED`, `STARTED-STOPPED`, or `CREATED-DESTROYED`).
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`, `LiveData`, and `Room` are all part of the Android architecture
    components, which are part of the Android Jetpack libraries. The architecture
    components are designed to help developers structure their code, write testable
    components, and help reduce boilerplate code. Other architecture components include
    `Databinding` (which binds views with models or `ViewModels`, allowing the data
    to be directly set in the Views), `WorkManager` (which allows developers to handle
    background work with ease), `Navigation` (which allows developers to create visual
    navigation graphs and specify relationships between activities and fragments),
    and `Paging` (which allows developers to load paginated data, which helps in situations
    where infinite scrolling is required).'
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel and LiveData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `ViewModel` and `LiveData` represent specialized implementations of the
    life cycle mechanisms. They come in handy in situations where you want to keep
    your data saved when the screen rotates and when you want your data to be displayed
    only when the Views are available, thus avoiding one of the most common issues
    developers face – a `NullPointerException` – when trying to update a View. A good
    use of this is when you want to display the live score of your favorite team's
    game and the current minute of the game.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ViewModel` component is responsible for holding and processing data required
    by the UI. It has the benefit of surviving configuration changes that destroy
    and recreate fragments and activities, which allows it to retain the data that
    can then be used to re-populate the UI. It will be eventually destroyed when the
    activity or fragment will be destroyed without being recreated or when the application
    process is terminated. This allows `ViewModel` to serve its responsibility and
    to be garbage collected when it is no longer necessary. The only method `ViewModel`
    has is the `onCleared()` method, which is called when `ViewModel` terminates.
    You can overwrite this method to terminate ongoing tasks and deallocate resources
    that will no longer be required.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating data processing from the activities into the `ViewModel`s helps in
    creating better and faster unit tests. Testing an activity requires an Android
    test that will be executed on a device. Activities also have states, which means
    that your test should get the activity into the proper state for the assertions
    to work. A `ViewModel` can be unit tested locally on your development machine
    and can be stateless, which means that your data processing logic can be tested
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important features of ViewModels is that they allow communication
    between fragments. To communicate between fragments without a `ViewModel`, you
    would have to make your fragment communicate with the activity, which will then
    call the fragment you wish to communicate with. To achieve this with ViewModels,
    you can just attach them to the parent activity and use the same `ViewModel` in
    the fragment you wish to communicate with. This will reduce the boilerplate code
    that was required previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see that a `ViewModel` can be created at
    any point in an activity''s life cycle (in practice they are normally initialized
    in the `onCreate` for Activities and `onCreateView` or `onViewCreated` for Fragments
    because these represent the points where the views are created and ready to be
    updated), and that once created, it will live as long as the activity does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The life cycle of an activity compared to the ViewModel life
    cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: The life cycle of an activity compared to the ViewModel life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how `ViewModel` connects to a fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The life cycle of a fragment compared to the ViewModel life
    cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: The life cycle of a fragment compared to the ViewModel life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: LiveData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LiveData` is a life cycle-aware component that permits updates to your UI,
    but only if the UI is in an active state (for example, if the activity or fragment
    is in the `STARTED` or `RESUMED` state). To monitor changes on your `LiveData`,
    you need an observer combined with a `LifecycleOwner`. When the activity is set
    to an active state, the observers will be notified when changes occur. If the
    activity is recreated, then the observer will be destroyed and a new one will
    be reattached. Once this happens, the last value of `LiveData` will be emitted
    to allow us to restore the state. Activities and fragments are `LifecycleOwners`,
    but fragments have a separate `LifecycleOwner` for the View states. Fragments
    have this particular `LifecycleOwner` due to their behavior in the fragment `BackStack`.
    When fragments are replaced within the back stack, they are not fully destroyed;
    only their Views are. Some of the common callbacks that developers use to trigger
    processing logic are `onViewCreated()`, `onActivityResumed()`, and `onCreateView()`.
    If we were to register observers on `LiveData` in these methods, we might end
    up with scenarios where multiple observers will be created every time our fragment
    pops back onto the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When updating a `LiveData` model, we are presented with two options: `setValue()`
    and `postValue()`. `setValue()` will deliver the result immediately and is meant
    to be called only on the UI thread. On the other hand, `postValue()` can be called
    on any thread. When `postValue()` is called, `LiveData` will schedule an update
    of the value on the UI thread and update the value when the UI thread becomes
    free.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LiveData` class, these methods are protected, which means that there
    are subclasses that allow us to change the data. `MutableLiveData` makes the methods
    public, which gives us a simple solution for observing data in most cases. `MediatorLiveData`
    is a specialized implementation of `LiveData` that allows us to merge multiple
    `LiveData` objects into one (this is useful in situations where our data is kept
    in different repositories and we want to show a combined result). `TransformLiveData`
    is another specialized implementation that allows us to convert from one object
    into another (this helps us in situations where we're grabbing data from one repository
    and we want to request data from another repository that depends on the previous
    data, as well as in situations where we want to apply extra logic to a result
    from a repository). `Custom LiveData` allows us to create our own `LiveData` implementations
    (usually when we periodically receive updates, such as the odds in a sports betting
    app, stock market updates, and Facebook and Twitter feeds).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to use `LiveData` in a `ViewModel`. Holding `LiveData`
    in the fragment or activity will cause losses in data when configuration changes
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how `LiveData` is connected to the life cycle of
    a `LifecycleOwner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The relationship between LiveData and life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: observers with LifecycleOwners
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: The relationship between LiveData and life cycle observers with
    LifecycleOwners'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can register multiple observers on a `LiveData` and each observer can be
    registered for a different `LifecycleOwner`. In this situation, a `LiveData` will
    become inactive, but only when all the observers are inactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Creating a Layout with Configuration Changes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been tasked with building an app that has one screen that is split
    into two vertically when in portrait mode and horizontally when in landscape mode.
    The first half contains some text and below it is a button. The second half contains
    only text. When the screen is opened, the text in both halves displays `Total:
    0`. When the button is clicked, the text will change to `Total: 1`. When clicked
    again, the text will change to `Total: 2`, and so on. When the device is rotated,
    the last total will be displayed on the new orientation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this task, we will define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An activity that will hold two fragments – one layout for portrait and another
    layout for landscape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One fragment with one layout containing `TextView` and a button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One fragment with one layout containing `TextView`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One `ViewModel` that will be shared between the two fragments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One `LiveData` that will hold the total.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin by setting up our configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `ViewModelLiveData` and add an empty activity called
    `SplitActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the root `build.gradle` file, add the `google()` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will allow Gradle (the build system) to know where to locate the Android
    Jetpack libraries, which are developed by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `ViewModel` and `LiveData` libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will bring both the `ViewModel` and `LiveData` code into our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and define `SplitFragmentOne`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `fragment_split_`one`.xml` file to the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create and define `SplitFragmentTwo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `fragment_split_two.xml` file to the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `SplitActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `activity_split.xml` file in the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a `layout-land` folder in the `res` folder. Then, in the
    `layout-land` folder, we''ll create an `activity_split.xml` file with the following
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following strings should be added to `res/strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that `ActivitySplit` is present in the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the only activity in your manifest, then make sure to add the launcher
    `intent-filter` tags so that the system knows which activity it should open when
    your app is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<intent-filter> <action android:name="android.intent.action.MAIN" /> <category
    android:name="android.intent.category.LAUNCHER" /></intent-filter>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the project. After it''s run, you can rotate the device and
    see that the screens are oriented according to the specifications. The `Total`
    is set to 0 and clicking on the button will do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Output of Exercise 10.01'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: Output of Exercise 10.01'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to build the logic required for adding 1 every time the button
    is clicked. That logic will need to be testable as well. We can build a `ViewModel`
    and attach it to each fragment. This will make the logic testable and it will
    also solve the issues with the life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Adding a ViewModel'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need to implement the logic for connecting our `ViewModel` to the button
    click and ensuring that the value is kept across configuration changes, such as
    rotations. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `TotalsViewModel` that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we extended from the `ViewModel` class, which is part of the life
    cycle library. In the `ViewModel` class, we defined one method that increases
    the value of the total and returns the updated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `updateText` and `prepareViewModel` methods to the `SplitFragment1`
    fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `prepareViewModel()` function, let''s start adding our `ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is how the `ViewModel` instance is accessed. `ViewModelProvider(this)`
    will make `TotalsViewModel` be bound to the life cycle of the fragment. `.get(TotalsViewModel::class.java)`
    will retrieve the instance of `TotalsViewModel` that we defined previously. If
    the fragment is being created for the first time, it will produce a new instance,
    while if the fragment is recreated after a rotation, it will provide the previously
    created instance. The reason we pass the class as an argument is because a fragment
    or activity can have multiple ViewModels and the class serves as an identifier
    for the type of `ViewModel` we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set the last known value on the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the View when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the app, press the button, and rotate the screen to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5: Output of Exercise 10.02'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Output of Exercise 10.02'
  prefs: []
  type: TYPE_NORMAL
- en: As you press the button, you will see the total increase, and when you rotate
    the display, the value is kept constant. If you press the back button and reopen
    the activity, you will notice that the total is set to 0\. We will need to notify
    the other fragment that the value has changed. We can do this by using an interface
    and letting the activity know so that the activity can alert `SplitFragmentOne`.
    Alternatively, we can attach our `ViewModel` to the activity, which will allow
    us to share it between fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Sharing our ViewModel between the Fragments'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to access `TotalsViewModel` in `SplitFragmentOne` and attach our `ViewModel`
    to the activity. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the same `ViewModel` we used previously to our `SplitFragmentTwo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify our fragments. In both fragments, we need to find and change
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6: Output of Exercise 10.03'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: Output of Exercise 10.03'
  prefs: []
  type: TYPE_NORMAL
- en: Again, here, we can observe something interesting. When the button is clicked,
    we don't see any changes in our second fragment, but we do see the total. This
    means that the fragments communicate, but not in real time. We can solve this
    through `LiveData`. By observing `LiveData` in both fragments, we can update each
    of the fragments' `TextView` classes when the value changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewModels to communicate between fragments will only work when the fragments
    are placed in the same activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.04: Adding LiveData'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we need to ensure that our fragments communicate in real time with each
    other. We can use `LiveData` to achieve this. This way, every time one fragment
    makes a change, the other fragment will be notified about the change and will
    make the necessary adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `TotalsViewModel` should be modified so that it supports `LiveData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `MutableLiveData`, a subclass of `LiveData` that allows us
    to change the value of the data. When `ViewModel` is created, we set the default
    value of `0`, and then when we increase the total, we post the previous value
    plus 1\. We also created the `getTotal()` method, which returns a `LiveData` class
    that can be observed but not modified from the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to modify our fragments so that they adjust to the new `ViewModel`.
    For `SplitFragmentOne`, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For `SplitFragmentTwo`, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `LifecycleOwner` parameter for the `observe` method is called `viewLifecycleOwner`.
    This is inherited from the `fragment` class and it helps when we are observing
    data while the View that the fragment manages is being rendered. In our example,
    swapping `viewLifecycleOwner` with `this` would've caused no impact. But if our
    fragment would've been part of a back stack feature, then there would've been
    the risk of creating multiple observers, which would've lead to being notified
    multiple times for the same dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a test for our new `ViewModel`. We will name it `TotalsViewModelTest`
    and place it in the `test` package, not `androidTest`. This is because we want
    this test to execute on our workstation, not the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test, before testing begins, we assert that the initial value
    of `LiveData` is set to 0\. Then, we write a small test in which we increase the
    total five times and we assert that the final value is `5`. Let''s run the test
    and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A message similar to the preceding one will appear. This is because of how
    `LiveData` is implemented. Internally, it uses Handlers and Loopers, which are
    part of the Android framework, thus preventing us from executing the test. Luckily,
    there is a way around this. We will need the following configuration in our Gradle
    file for our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds a testing library to our testing code, not our application code.
    Now, let''s add the following line to our code, above the instantiation of the
    `ViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is added a `TestRule` that says that every time a `LiveData`
    has its value changed, it will make the change instantly and will avoid using
    the Android Framework components. Every test we will write in this class will
    be impacted by this rule, thus giving us the freedom to play with the `LiveData`
    class for each new test method. If we run the test again, we will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this mean that our new rule didn''t work? Not exactly. If you look in
    your `TotalsViewModels` class, you''ll see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that because we created the `ViewModel` class outside of the scope
    of the rule, the rule will not apply. We can do two things to avoid this scenario:
    we can change our code to handle a null value that will be sent when we first
    subscribe to the `LiveData` class, or we can adjust our test so that we put the
    `ViewModel` class in the scope of the rule. Let''s go with the second approach
    and change how we create our `ViewModel` class in the test. It should look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the test again and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'See if you can spot where the error in the test is, fix it, and then rerun
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Output of Exercise 10.04'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: Output of Exercise 10.04'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same output in landscape mode will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Output of Exercise 10.04 in landscape mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Output of Exercise 10.04 in landscape mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the preceding example, we can see how using a combination of
    the `LiveData` and `ViewModel` approaches helped us solve our problem while taking
    into account the particularities of the Android operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` helped us hold the data across device orientation change and it
    solved the issue of communicating between fragments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveData` helped us retrieve the most up-to-date information that we''ve processed
    while taking into account the fragment''s life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of the two helped us delegate our processing logic in an efficient
    way, allowing us to unit test this processing logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Room persistence library acts as a wrapper between your application code
    and the SQLite storage. You can think of SQLite as a database that runs without
    its own server and saves all the application data in an internal file that''s
    only accessible by your application (if the device is not rooted). Room will sit
    between the application code and the SQLite Android Framework, and it will handle
    the necessary Create, Read, Update, and Delete (CRUD) operations while exposing
    an abstraction that your application can use to define the data and how you want
    the data to be handled. This abstraction comes in the form of the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities**: You can specify how you want your data to be stored and the relationships
    between your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access Object** (**DAO**): The operations that can be done on your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: You can specify the configurations that your database should
    have (the name of the database and migration scenarios).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Relationship between your application and Room components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Relationship between your application and Room components'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see how the Room components interact with each
    other. It's easier to visualize this with an example. Let's assume you want to
    make a messaging app and store each message in your local storage. In this case,
    `Entity` would be a `Message` object that will have an ID, and will contain the
    contents of the message, the sender, the time, status, and so on. In order to
    access messages from the local storage, you will need a `MessageDao`, which will
    contain methods such as `insertMessage()`, `getMessagesFromUser()`, `deleteMessage()`,
    and `updateMessage()`. Since it's a messaging application, you will need a `Contact`
    entity to hold information about the senders and receivers of a message. The `Contact`
    entity would contain information such as name, last online time, phone number,
    email, and so on. In order to access the contact information, you would need a
    `ContactDao` interface, which will contain `createUser()`, `updateUser()`, `deleteUser()`,
    and `getAllUsers()`. Both entities will create a matching table in SQLite that
    contains the fields we defined inside the entity classes as columns. In order
    to achieve this, we'll have to create a `MessagingDatabase` in which we will reference
    both of these entities.
  prefs: []
  type: TYPE_NORMAL
- en: In a world without Room or similar DAO libraries, we would need to use the Android
    Framework's SQLite components. This typically involves code when setting up our
    database, such as a query to create a table and applying similar queries for every
    table we would have. Every time we would query a table for data, we would need
    to convert the resulting object into a Java or Kotlin one. Then, for every object
    we updated or created, we would need to perform a conversion in the other direction
    and invoke the appropriate method. Room removes all this boilerplate code, allowing
    us to focus on our app's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Room does not allow any operations on the UI thread to enforce the
    Android standards related to input-output operations. In order to make asynchronous
    calls to access data, Room is compatible with a number of libraries and frameworks,
    such as Kotlin coroutines, RxJava, and `LiveData`, on top of its default definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Entities serve two purposes: to define the structure of tables and to hold
    the data from a table row. Let''s use our scenario of the messaging app and define
    two entities: one for the user and one for the message. The `User` entity will
    contain information about who sent the messages, while the `Message` entity will
    contain information about the contents of a message, the time it was sent, and
    a reference to the sender of the message. The following code snippet provides
    an example of how entities are defined with Room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, entities are just *data classes* with annotations that will
    tell Room how the tables should be built in SQLite. The annotations we used are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` annotation defines the table. By default, the table name will
    be the name of the class. We can change the name of the table through the `tableName`
    method in the `Entity` annotation. This is useful in situations where we want
    our code obfuscated but wish to keep the consistency of the SQLite structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ColumnInfo` defines configurations for a certain column. The most common
    one is the name of the column. We can also specify a default value, the SQLite
    type of the field, and whether the field should be indexed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PrimaryKey` indicates what in our entity will make it unique. Every entity
    should have at least one primary key. If your primary key is an integer or a long,
    then we can add the `autogenerate` field. This means that every entity that gets
    inserted into the `Primary Key` field is automatically generated by SQLite. Usually,
    this is done by incrementing the previous ID. If you wish to define multiple fields
    as primary keys, then you can adjust the `@Entity` annotation to accommodate this;
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that our messaging application wants to send locations. Locations
    have latitude, longitude, and name. We can add them to the `Message` class, but
    that would increase the complexity of the class. What we can do is create another
    entity and reference the ID in our class. The problem with this approach is that
    we would then query the `Location` entity every time we query the `Message` entity.
    Room has a third approach through the `@Embedded` annotation. Now, let''s look
    at the updated `Message` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What this code does is add three columns (`lat`, `long`, and `location_name`)
    to the messages table. This allows us to avoid having objects with a large number
    of fields while keeping the consistency of our tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our entities, we''ll see that they exist independent of each
    other. The `Message` entity has a `userId` field, but there''s nothing preventing
    us from adding messages from invalid users. This may lead to situations where
    we collect data without any purpose. If we want to delete a particular user, along
    with their messages, then we have to do so manually. Room provides us with a way
    to define this relationship through a `ForeignKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added the `foreignKeys` field and created a new
    `ForeignKey` to the `User` entity, while for the parent column, we defined the
    `user_id` field in the `User` class and for the child column, the `user` field
    in the `Message` class. Every time we add a message to the table, there needs
    to be a `User` entry in the `users` table. If we try to delete a user and there
    are any messages from that user that still exist, then, by default, this will
    not work because of the dependencies. However, we can tell Room to do a cascade
    delete, which will erase the user and the associated messages.
  prefs: []
  type: TYPE_NORMAL
- en: DAO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If entities specify how we define and hold our data, then DAOs specify what
    to do with that data. A DAO class is a place where we define our CRUD operations.
    Ideally, each entity should have a corresponding DAO, but there are situations
    where crossovers occur (usually, this happens when we have to deal with JOINs
    between two tables).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our previous example, let''s build some corresponding DAOs
    for our entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our messages, we have defined the following functions: insert
    one or more messages, update one or more messages, delete one or more messages,
    and retrieve all the messages from a certain user that are older than a particular
    time. For our users, we can insert one user, update one user, delete one user,
    and retrieve all the users.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our `Insert` methods, you'll see we have defined that in the
    case of a conflict (when we try to insert something with an ID that already exists),
    it will replace the existing entry. The `Update` field has a similar configuration,
    but in our case, we have chosen the default. This means that nothing will happen
    if the update cannot occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Query` annotation stands out from all the others. This is where we use
    SQLite code to define how our read operations work. `SELECT *` means we want to
    read all the data for every row in the table, which will populate all our entities''
    fields. The `WHERE` clause indicates a restriction that we want to apply to our
    query. We can also define a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to filter messages from multiple users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a new class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to extract information from certain columns at a time, not
    the entire row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that you want to add the user information of the sender to
    every message. Here, we''ll need to use a similar approach to the one we used
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the new data class, we can define this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the user information for every message we want to display. This
    will come in handy in scenarios such as group chats, where we should display the
    name of the sender of every message.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have so far is a bunch of DAOs and entities. Now, it''s time to put
    them together. First, let''s define our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the `@Database` annotation, we specify what entities go in our database,
    and we also specify our version. Then, for every DAO, we define an abstract method
    in our `RoomDatabase`. This allows the build system to build a subclass of our
    class in which it provides the implementations for these methods. The build system
    will also create the tables related to our entities.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDatabase` method in the companion object is used to illustrate how we
    create an instance of the `ChatDatabase` class. Ideally, there should be one instance
    of the database for our application due to the complexity involved in building
    a new database object. This can be better achieved through a dependency injection framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume you''ve released your chat application. Your database is currently
    version 1, but your users are complaining that the message status feature is missing.
    You decide to add this feature in the next release. This involves changing the
    structure of the database, which can impact databases that have already built
    their structures. Luckily, Room offers something called a migration. In the migration,
    we can define how our database changed between versions 1 and 2\. So, let''s look
    at our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the status flag to the `Message` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our `ChatDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In our database, we've increased the version to 2 and added a migration between
    versions 1 and 2\. Here, we added the status column to the table. We'll add this
    migration when we build the database. Once we've released the new code, when the
    updated app is opened and the code to build the database is executed, it will
    compare the version on the stored data with the one specified in our class and
    it will notice a difference. Then, it will execute the migrations we specified
    until it reaches the latest version. This allows us to maintain an application
    for years without impacting the user's experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at our `Message` class, you may have noticed that we defined the
    time as a Long. In Java and Kotlin, we have the `Date` object, which may be more
    useful than the timestamp of the message. Luckily, Room has a solution for this
    in the form of TypeConverters. The following table shows what data types we can
    use in our code and the SQLite equivalent. Complex data types need to be brought
    down to these levels using TypeConverters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Relationship between Kotlin/Java data types and the SQLite
    data types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: Relationship between Kotlin/Java data types and the SQLite data
    types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ve modified the `lastOnline` field so that it''s of the `Date` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve defined a couple of methods that convert a `Date` object into
    a `Long` and vice versa. The `@TypeConverter` annotation helps Room identify where
    the conversion takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add our converter to Room through the `@TypeConverters` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at some third-party frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Room works well with third-party frameworks such as LiveData, RxJava, and coroutines.
    This solves two issues: multi-threading and observing data changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveData` will make the `@Query` annotated methods in your DAOs reactive,
    which means that if new data is added, `LiveData` will notify the observers of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin coroutines complement `LiveData` by making the `@Insert`, `@Delete`,
    and `@Update` methods asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`@Query` methods reactive through components such as `Publisher`, `Observable`,
    or `Flowable` and making the rest of the methods asynchronous through `Completable`,
    `Single`, or `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Executors and threads** come with the Java framework and can be a useful
    solution to solve threading issues with Room if none of the aforementioned third-party
    integrations are part of your project. Your DAO classes will not suffer from any
    modifications; however, you will need the components that access your DAOs to
    adjust and use either an executor or a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of accessing the DAO is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will create a new thread and start it every time we want
    to retrieve the list of users. There are two major issues with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation is an expensive operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is hard to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to the first issue can be solved with `ThreadPools` and `Executors`.
    The Java framework offers a robust set of options when it comes to `ThreadPools`.
    A thread pool is a component that is responsible for thread creation and destruction
    and allows the developer to specify the number of threads in the pool. Multiple
    threads in a thread pool will ensure that multiple tasks can be executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an executor that will use a pool of 1 thread.
    When we want to access the list of users, we move the query inside the executor,
    and when the data is loaded, our callback lambda will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.05: Making a Little Room'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been hired by a news agency to build a news application. The application
    will display a list of articles written by journalists. An article can be written
    by one or more journalists, and each journalist can write one or more articles.
    The data information for each article includes the article's title, content, and
    date. The journalist's information includes their first name, last name, and job
    title. You will need to build a Room database that holds this information so it
    can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let''s look at the relationship between the entities. In the
    chat application example, we defined the rule that one user can send one or multiple
    messages. This relationship is known as a one-to-many relationship. That relationship
    is implemented as a reference between one entity to another (the user was defined
    in the message table in order to be connected to the sender). In this case, we
    have a many-to-many relationship. In order to implement a many-to-many relationship,
    we need to create an entity that''s holding references that will link the other
    two entities. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the annotation processing plugin to `app/build.gradle`.
    This will read the annotations used by Room and generate the code necessary for
    interacting with the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the Room libraries in `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the library version, the second line brings in the Room
    library for Java and Kotlin, and the last line is for the Kotlin annotation processor.
    This allows the build system to generate boilerplate code from the Room annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define the entity that connects the journalist to the article and the
    appropriate constraints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined our connecting entity. As you can see, we
    haven't defined an ID for uniqueness, but both the article and the journalist,
    when used together, will be unique. We also defined foreign keys for each of the
    other entities referred to by our entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ArticleDao` DAO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `JournalistDao` data access object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `JoinedArticleJournalistDao` DAO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze our code a little bit. For the articles and journalists, we have
    the ability to add, insert, delete, and update queries. For articles, we have
    the ability to extract all of the articles but also extract articles from a certain
    author. We also have the option to extract all the journalists that wrote an article.
    This is done through a JOIN with our intermediary entity. For that entity, we
    define the options to insert (which will link an article to a journalist) and
    delete (which will remove that link).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s define our `Database` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We avoided defining the `getInstance` method here because we won't be calling
    the database anywhere. But if we don't do that, how will we know if it works?
    The answer to this is that we'll test it. This won't be a test that will run on
    your machine but one that will run on the device. This means that we will create
    it in the `androidTest` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up the test data. Here, we will add some articles and
    journalists to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test whether the data is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s test clearing the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a few examples of how to test a Room database. What's
    interesting is how we build the database. Our database is an in-memory database.
    This means that all the data will be kept as long as the test is run and will
    be discarded afterward. This allows us to start with a clean slate for each new
    state and avoids the consequences of each of our testing sessions affecting each
    other. In our test, we've set up five articles and ten journalists. The first
    article was written by the top two journalists, while the second article was written
    by the first journalist. The rest of the articles have no authors. By doing this,
    we can test our update and delete methods. For the delete method, we can test
    our foreign key relationship as well. In the test, we can see that if we delete
    article 1, it will delete the relationship between the article and the journalists
    that wrote it. When testing your database, you should add the scenarios that your
    app will use. Feel free to add other testing scenarios and improve the preceding
    tests in your own database.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Life Cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we discussed `LiveData` and how it can be observed through a `LifecycleOwner`.
    We can use LifecycleOwners to subscribe to a `LifecycleObserver` so that it will
    monitor when the state of an owner changes. This is useful in situations where
    you would want to trigger certain functions when certain life cycle callbacks
    are invoked; for example, requesting locations, starting/stopping videos, and
    monitoring connectivity changes from your activity/fragment. We can achieve this
    with the use of a `LifecycleObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined a class that implements the `LifecycleObserver`
    interface and defined a method that will be called when the life cycle goes into
    the `ON_START` event. The `@OnLifecycleEvent` annotation will be used by the build
    system to generate boilerplate code that will invoke the annotation it is used
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do next is register our observer in the activity/fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we registered the observer on a `Lifecycle` object. The
    `Lifecycle` object is inherited from the parent activity class through the `getLifecycle()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveData` are specialized uses of this principle. In the `LiveData` scenario,
    you would have multiple LifecycleOwners subscribing to a single `LiveData`. Here,
    you can just subscribe new owners for the same `LifecycleOwner`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.06: Reinventing the Wheel'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a custom `LifecycleOwner` that triggers
    the `Lifecycle.Event.ON_START` event in `ToastyLifecycleObserver` when the activity
    starts. Let''s get started by creating a new Android Studio Project with an empty
    activity named SplitActivity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the observer to our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code and open the activity, rotate the device, put the app in
    the background, and resume the app, you will see the `Started` toast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, define a new activity that will reinvent the wheel and make it worse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the `AndroidManifest.xml` file you can replace the SplitActivity with LifecycleActivity
    and it will look something like this
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code, we will see that a toast will appear every time
    an activity is started.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Output of Exercise 10.06'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: Output of Exercise 10.06'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this is triggered without overriding the `onStart()` method from
    the `Activity` class. You can further experiment with the `LifecycleObserver`
    class to trigger the toast in other states of the `Activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's analyze the code for our new activity. Notice that we've extended
    the activity and not the `AppCompatActivity` class. This is because the `AppCompatActivity`
    class already contains the `LifecycleRegistry` logic. In our new activity, we
    defined a `LifecycleRegistry`, which will be responsible for adding our observers
    and changing the states. Then, we implemented the `LifecycleOwner` interface and
    in the `getLifecycle()` method, we return `LifecycleRegistry`. Then, for each
    of our callbacks, we can change the state of the registry. In the `onCreate()`
    method, we set the registry in the `CREATED` state (which will trigger the `ON_CREATE`
    event on the LifecycleObservers) and then we registered our `LifecycleObserver`.
    In order to achieve our task, we sent the `STARTED` event in the `onStop()` method.
    If we run the preceding example and minimize our activity, we should see our `Started`
    toast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Shopping Notes App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want to keep track of your shopping items, so you decide to build an app
    in which you can save the items you wish to buy during your next trip to the store.
    The requirements for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI will be split into two: top/bottom in portrait mode and left/right in
    landscape mode. The UI will look similar to what is shown in the following screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first half will display the number of notes, a text field, and a button.
    Every time the button is pressed, a note will be added with the text that was
    placed in the text field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second half will display the list of notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each half, you will have a View model that will hold the relevant data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should define a repository that will be used on top of the Room database
    to access your data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should also define a Room database that will hold your notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The note entity will have the following attributes: id, text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.12: Example of a possible output for Activity 10.01'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Example of a possible output for Activity 10.01'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with Room integration by creating the `Entity`, `Dao`, and `Database`
    methods. For `Dao`, the `@Query` annotated methods can directly return a `LiveData`
    object so that if the data changes, the observers can be directly notified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a template of our repository in the form of an interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the repository. The repository will have one reference to the `Dao`
    object we defined previously. The code for inserting the data will need to be
    moved to a separate thread. Create the `NotesApplication` class to provide one
    instance of the repository that will be used across the application. Make sure
    to update the `<application>` tag in the `AndroidManifest.xml` file to add your
    new application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unit test the repository and define `ViewModels`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `NoteListViewModel` and the associated test. This will have a reference
    to the repository and return the list of notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `CountNotesViewModel` and the associated test. `CountViewModel` will
    have a reference to the repository and return the total number of notes as a `LiveData`.
    It will also be responsible for inserting new notes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `CountNotesFragment` and the associated `fragment_count_notes.xml` layout.
    In the layout, define a `TextView` that will display the total number, an `EditText`
    for the name of the new notes, and a button that will insert the note that was
    introduced in `EditText`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define an adapter for the list of notes called `NoteListAdapter` and an associated
    layout file for the rows called `view_note_item.xml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the associated layout file, called `fragment_note_list.xml`, which will
    contain a `RecyclerView`. The layout will be used by `NoteListFragment`, which
    will connect `NoteListAdapter` to `RecyclerView`. It will also observe the data
    from `NoteListViewModel` and update the adapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `NotesActivity` with an associated layout for landscape mode and portrait
    mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you have all the necessary data in `strings.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the building blocks required to build a maintainable
    application. We also looked into one of the most common issues that developers
    come across when using the Android Framework, which is maintaining the states
    of objects during life cycle changes.
  prefs: []
  type: TYPE_NORMAL
- en: We started by analyzing `ViewModels` and how they solve the issue of holding
    data during orientation changes. We added `LiveData` to `ViewModels` to show how
    the two complement each other.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to Room to show how we can persist data with minimal effort
    and without a lot of SQLite boilerplate code. We also explored one-to-many and
    many-to-many relationships, as well as how to migrate data and break down complex
    objects into primitives for storage.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we reinvented the `Lifecycle` wheel in order to show how `LifecycleOwners`
    and `LifecycleObservers` interact.
  prefs: []
  type: TYPE_NORMAL
- en: We also built our first repository, which we will expand upon in the following
    chapters when other data sources are added into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: The activity we completed in this chapter serves as an example of what direction
    Android apps are heading in. However, this was not a complete example due to the
    numerous frameworks and libraries that you will discover that give developers
    the flexibility to go in different directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information you''ve learned about in this chapter will serve you well for
    the next one, which will expand on the concept of repositories. This will allow
    you to save data that''s been obtained from a server into a room database. The
    concept of persisting data will also be expanded on as you will explore other
    ways to persist data, such as through `SharedPreferences` and files. Our focus
    will be on certain types of files: media files obtained from the camera of the
    device.'
  prefs: []
  type: TYPE_NORMAL
