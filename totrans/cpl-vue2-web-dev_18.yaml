- en: Large Application Patterns with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex的大型应用程序模式
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Dynamically loading pages in your vue-router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Building a simple storage for the application state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序状态构建一个简单的存储
- en: Understanding Vuex mutations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Vuex的mutations
- en: Listing your actions in Vuex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vuex中列出你的操作
- en: Separating concerns with modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块分离关注点
- en: Building getters to help retrieve your data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建getter来帮助检索数据
- en: Testing your store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的存储
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will learn how Vuex works and how to use it to support
    a scalable application. Vuex implements a pattern that is popular in frontend
    frameworks and consists of dividing the different concerns to manage a big global
    application state. The mutations are the only things that can change the state,
    so you have only one place to look for that. Much of the logic, along with all
    the asynchronous logic, is contained in the actions; finally, getters and modules
    further help to spread the cognitive load when it comes to computing the derived
    state and splitting your code into different files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习Vuex的工作原理以及如何使用它来支持可扩展的应用程序。Vuex实现了一种在前端框架中流行的模式，它包括将不同的关注点分开来管理一个大型全局应用程序状态。mutations是唯一可以改变状态的东西，所以你只需要在一个地方查找它。大部分逻辑，以及所有的异步逻辑，都包含在actions中；最后，getters和modules进一步帮助分散认知负荷，当涉及计算派生状态和将代码拆分成不同的文件时。
- en: Along with recipes, you will find grains of wisdom that I found useful when
    developing real large applications; some have to do with naming conventions and
    others with little tricks to avoid bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方，你还会发现我在开发真正大型应用程序时发现有用的智慧之言；有些与命名约定有关，有些与避免错误的小技巧有关。
- en: If you complete all the recipes, you will be ready to develop big frontend applications
    with fewer bugs and seamless collaboration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了所有的配方，你将准备好开发大型前端应用程序，减少错误并实现无缝协作。
- en: Dynamically loading pages in your vue-router
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在vue-router中动态加载页面
- en: Soon, you will build huge Vue websites with loads of components. Loading a lot
    of JavaScript may generate wasteful and useless upfront delay.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将建立大量组件的大型Vue网站。加载大量JavaScript可能会产生浪费和无用的前期延迟。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of vue-router.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解vue-router。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new project with `vue-cli` by making a new directory and running the
    following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建新目录并运行以下命令来使用`vue-cli`创建一个新项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can answer the question as you prefer, as long as you add the `vue-router`
    to the template when asked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的喜好回答问题，只要在要求时将`vue-router`添加到模板中即可。
- en: 'We will create two components: one will be our home page and it will be small
    and light, the other component will be very big and very slow to load. What we
    want to achieve is to load the home page immediately, without having to wait for
    the huge component to be downloaded by the browser.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个组件：一个将是我们的主页，它将是小而轻的，另一个组件将非常大且加载速度很慢。我们想要实现的是立即加载主页，而不必等待浏览器下载巨大的组件。
- en: 'Open the `Hello.vue` file in the `components` folder. Delete everything and
    only leave the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`components`文件夹中的`Hello.vue`文件。删除所有内容，只留下以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same folder, create another file named `Massive.vue` and write the following
    inside it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个文件夹中，创建另一个名为`Massive.vue`的文件，并在其中写入以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Leave an open back tick at the last line because we have to bloat the file with
    a lot of useless data. Save and close `Massive.vue`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行留一个开放的反引号，因为我们必须用大量无用的数据膨胀文件。保存并关闭`Massive.vue`。
- en: 'In a console, go to the same directory where the file is stored and use the
    following file to put a lot of garbage into it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What this command does is append the `XXX` line to the file repeatedly 10⁶ times;
    this will add 4 million bytes to the file, making it too huge for a fast browsing
    experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to close the back tick we opened. Don''t try to open the file now,
    as your text editor may not be capable of opening such a big file; instead, use
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Massive` component is now complete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` inside the `router` folder and add the component and its route:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After installing all the dependencies with `npm install`, we are now ready to
    launch our very large app with the `npm run dev` command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will load quite fast, but that''s because it''s loading directly from
    your local storage; to simulate a more realistic scenario, open the developer
    tools at the Network tab and select network throttling. Pick something slow, such
    as GPRS or maybe good 3G, which most of us may have:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f48c0eb8-f26b-46a4-8776-b55eb26bb7a9.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Now right-click on the refresh button and select Hard Reload to bypass the
    cache (or press *Shift* + *Cmd* + *R*):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2b2d058-173a-4601-bdc1-1c92008de325.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: You will notice that the page doesn't load for a few minutes. You can stop the
    loading of the page by clicking on the refresh button again when it becomes an
    X.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, go back to the `index.js` file in the `router` folder. Delete
    the following line, where you import the `Massive` component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding line is telling Webpack to include all the code contained in the
    `Massive` component in a single js bundle. Instead, we want to tell Webpack to
    keep the `Massive` component as a separate bundle and to load it only when necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of directly importing the component, declare `Massive` with the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Webpack will turn this special syntax into a separate file that will be loaded
    lazily. Save and do another hard refresh with the throttling still set to slow
    speed (like GPRS to good 3G). After a few seconds, you should be able to see the
    hello page. If you want to load the `Massive` component, just add `massive` to
    the URL, but you'll be in for some waiting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you obviously won't have such a big component in a real application, but
    you can easily see that if the `Massive` component represents all the other components
    of your app, they can quickly amount to such a big size.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The trick here is to load them asynchronously; Webpack will help you separate
    them into smaller bundles so that they will be loaded only if and when required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an alternative syntax to import components lazily. It may become an
    ECMA standard in the future, so you should be aware of it. Open `index.js` inside
    the `router` directory and completely remove the import of the `Massive` component
    or the `Massive` constant line we added in this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the routes, try the following when specifying the component for the
    `/massive` route:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will be equivalent to what we have done before because Webpack will take
    the line and instead of directly importing the code of the Massive component,
    it will create a different js file, loaded lazily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple storage for the application state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will understand the fundamentals of Vuex when building a
    big application. This recipe is a little unorthodox because to understand how
    Vuex's store work, we will manipulate it directly; you should never do that in
    a real application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before trying this recipe, you should know how to make components talk with
    Vuex.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project based on the Webpack template with the following command
    run in a new directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How you answer the question is not relevant. Run `npm intall` and install Vuex
    with `npm install vuex --save` or `yarn add vuex` if you use yarn.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the  `main.js` file inside the `src` folder and add the following highlighted
    lines to finish installing Vuex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, there is no `store` module right now, so you need to create one.
    To do this, create a folder just under the `src` folder and call it `store`. Inside
    it, create a file named `index.js`. In the `main.js` file, we didn't specify to
    use the `index.js` file, but that's the default behavior when no file is specified
    but only the folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will implement is a simplified stock market. We have three assets:
    stars (STAR), lamps (LAMP), and diamonds (DIAM). We will define two routes: one
    for the STAR/LAMP market and another for the LAMP/DIAM market.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `index.js` file in the store folder, write the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are creating a new `Vuex` store that will hold our balance. Initially, we
    have 100 of each asset; in the store, the exchange rate between stars and lamps
    and between lamps and diamonds is also fixed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component under the `components` directory, named `Market.vue`.
    It will have the following template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`symbol1` and `symbol2` represent the two assets traded. In the JavaScript
    of this component, where we define the `sell` and `buy` methods, we operate directly
    on the global `Vuex` store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should never touch the state directly like I've done here. You should always
    use mutations. Here, we are skipping the middleman to keep the recipe minimalistic.
    There's more on mutations in the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to use this component in `index.js`, inside the `router` folder, in
    the following way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we are using the `Market` component for any route that
    contains a couple of trade symbols. As a home page, we are using the STAR/LAMP
    market.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'To display some navigation links to a different market and our current balance,
    we can edit the `App.vue` component with the following template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We don't need any JavaScript for this component, so you can delete the `<script>`
    tag.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app is now ready; launch it and start trading with it. The following image
    is our completed app without the styles contained in `App.vue`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/95c7b7aa-c82a-487c-b2a0-ef250352da04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The balance in the bottom is like a summary of the global state. With Vuex,
    we were able to affect other components by accessing the `$store` variable that
    gets injected into every component by the Vuex plugin. You can easily imagine
    how to use this strategy in a big application when you want to basically expand
    the scope of a variable beyond the component itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Some of the states may be local, for example, if you need some animations or
    you need some variables to show modal dialogs for the component; it's perfectly
    okay to not put these values in the store. Otherwise, having a structured centralized
    state in one place helps a lot. In the subsequent recipes, you'll use more advanced
    techniques to exploit the power of Vuex better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vuex mutations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proper way to mutate the state in a Vuex application is with the help of
    mutations. Mutations are a very useful abstraction to decompose state changes
    in the atomic unit. In this recipe, we will explore just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be completed without knowing too much about Vuex, but completing
    the previous recipe first is suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add Vuex as a dependency to your project (the CDN address is `https://unpkg.com/vuex`).
    I will assume that you are using JSFiddle to follow along; otherwise, just remember
    to put `Vue.use(Vuex)` before the store code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The sample application we will build is to broadcast notifications to the users
    of the website.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML layout looks as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The idea is to have a textbox to write messages and the broadcasted messages
    will be displayed on the top with the most recent appearing first. The messages
    can be dismissed by clicking on the little x.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build a store that will hold the list of broadcasted messages
    and enumerate the possible mutations we can make to said list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, we have a list of messages; we can push one to the top of the list or we
    can remove a message by knowing its index.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to write the logic of the application itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now launch the app and start broadcasting messages to our imaginary
    users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0df8753-e8a1-468a-a5a8-9f6d4998a4ef.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think it's important to note the names of the mutations; they are called `pushMessage`
    and `removeMessage`, but what they really do in this application is show the message
    in a stack on the screen and (fictionally) broadcast messages to users. Would
    it be better to call them `showMessage`, or `broadcastMessage` and `hideMessage`?
    No, that's because there has to be a clear separation of intent between the mutation
    itself and the particular effects of that mutation. The problem becomes clear
    when, for example, we decide to give users the ability to ignore these notifications
    or we introduce a delay before actually broadcasting the notifications. Then we
    will have a `showMessage` mutation that does not actually show a message.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The computed syntax we have used is as illustrated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You don't have to explicitly use Vuex in your expression when you are importing
    Vuex as an ES6 module. You just need to write
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`import { mapState } from ''Vuex''`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `mapState` function will be available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The `mapState` method takes an array of strings as a parameter, looks for a
    `state` variable in the store with the same name as the string, and creates a
    computed property with the same name. You can do this with as many variables as
    you want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you followed along on a local npm project, open the Vue developer tools
    (unfortunately Vue developer tools is not available when using JSFiddle) and you
    will see that a new mutation is issued with each message. Consider that you click
    on the little clock:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/988d23d1-8897-430e-bf94-be7b51e37be7.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'You can actually undo the mutation with that, as shown in the following illustration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19f87abf-9a68-4259-8bfc-55d060a5fce4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Note how the state didn't change when clicking the time travel option; that's
    because the purple ribbon is still at the last state. To examine a different state,
    just click on the name of the mutation itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This debug mechanism is possible because mutations are always synchronous; this
    means that it's possible to take a snapshot of the state before and after the
    mutation and navigate through time. In the next recipe, you will learn how to
    use Vuex to perform asynchronous actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Listing your actions in Vuex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All your mutations must be synchronous, so how do you do things such as waiting
    for a timeout or using Axios for an AJAX request? Actions are the next level of
    abstraction that will help you with this. Inside an action, you can commit multiple
    mutations and make asynchronous operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutations are the building blocks of actions, so it's highly suggested you complete
    the preceding recipe before trying this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the setup from the *Building a simple storage for the application
    state* recipe; you can use your own as well, but in any case, this recipe is based
    on a slight modification of the official Webpack template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a clone of the popular Xkcd website. Actually, it will be a wrapper
    more than a real clone, since we will reuse the panels from the website.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Vue project based on the Webpack template with `vue init webpack`.
    The first thing we will do is wire up the API to the Xkcd website in the `index.js`
    inside the `config` folder. Put the following lines inside the `proxyTable` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will redirect all the requests we make to `/comic` to the Xkcd website.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src`, make a new `store` directory and an `index.js` inside it; here,
    start building the application store:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should import this inside `main.js` like in previous recipes. We want to
    trace the current panel number, the link to the panel image, and the possible
    errors. The only way to modify the state is through mutations, while actions can
    perform asynchronous work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app is loaded, we plan to display the latest comic. For this, we create
    an action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For this code to work, we need to declare the endpoint and install Axios:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It should be easy for you to write the corresponding mutations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll recycle the `Hello.vue` component and put the following template inside
    it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make the last panel appear on loading you can use the following JavaScript
    in the component:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Also, you can delete most of the `App.vue` template and leave only the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `proxyTable` object will configure the `http-proxy-middleware`. This is
    useful every time we are developing the UI of a bigger web application and we
    launch our developer server on `localhost`, but our API responds to another web
    server. This is especially relevant when we want to use CORS and we don't allow
    other websites to use our API. The Xkcd API doesn't allow `localhost` to consume
    the web service. This is why, even if we try to use the Xkcd API directly, our
    browser won't let us. The `changeOrigin` option will send the request with Xkcd
    as host, making CORS unnecessary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To call an action from a component, we used the `dispatch` function. It's also
    possible to pass the second argument, the first being the name of the action itself.
    The second argument is then passed when you define the action as the second parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: A last note on the naming--it being implicit that actions are asynchronous while
    mutations are synchronous, there is no need, in my opinion, to make the asynchronicity
    in the name of the actions explicit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Separating concerns with modules
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building big applications, the Vuex store can become crowded. Luckily,
    it's possible to divide the different concerns of the applications into separate
    compartments with modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be a reference if you want to use modules. You are expected
    to already know enough about Vuex.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, you will have to be a little familiar with Webpack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will model a fully functional human body in a slightly simplified
    manner. Every organ will have a separate module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack` and `npm install vuex`.
    Create a new directory with the `src/store/index.js` file in it. Inside, write
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `heart` module is like this; put it before the store declaration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note how the state passed inside the mutations is not the root state, but the
    local state of the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes the brain, which is divided into the left and right lobes; write
    the following before the store:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can implement them as simple Boolean states (write them before the brain
    on which they depend):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting `namespaced` to true modifies the way you can call the mutator. Since
    they are both called `toggle`, now you can specify which lobe, for example, for
    the left lobe the mutation string becomes `left/toggle`, where `left` says it
    is the key used in the brain to refer to the left lobe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To see your store in action, you can create a component that uses all the mutations.
    For the brain, we can have two pictures of the lobes, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will create two drawings of brain lobes in red pencil; note the use of
    the name of the modules in a nested way. The following `off` CSS rule grays the
    lobes out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To call the mutations, we use the aforementioned strings in the right methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also create an input textbox and call the other two mutations, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This was very easy, but how do you retrieve the loved name? You can put these
    mustachios in your template:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You obviously have to declare the `partner` variable on your Vue instance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dfd584ca-c301-4db6-acda-b82b5e5b36c6.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use modules to split your application concerns into different
    units. This ability may become important as the project grows in size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The common pattern is that while inside a mutation, you have direct access
    to the local state:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In a mutation, it makes sense to have access only to the local state. The brain,
    for example, cannot change the heart and vice versa, but what about actions? If
    we declare an action inside a module, we are passed an object called context that
    looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, if we want to declare an action in the left lobe and we want to affect
    the heart, we have to do something like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Building getters to help retrieve your data
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't want to keep too much data in your state. It can be especially dangerous
    to keep duplicate or derivative data because it can be brought out of sync very
    easily. Getters help you with this without shifting the burden onto the components
    by keeping all the logic in one place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is for you if you already have some Vuex knowledge and want to expand
    your horizons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are building a Bitcoin wallet. You want to give your users
    an overview of their balance, and you want them to see how many Euros it corresponds
    to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Webpack template with `vue init webpack` and `npm install vuex`.
    Create a new `src/store/index.js` file and write the following inside it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code is prone to errors. The first error can be a miscalculation of the
    Euro amount if we don't get the multiplication right. The second kind of error
    can be that we tell the user the `bitcoin` and `euro` balance during a transaction,
    resulting in a stale and wrong amount for one of the two.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To tackle these issues, we use `getters`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way the `euro` amount is never in the state but always computed. Moreover,
    it is centralized in the store, so we don't need to add anything to our components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s easy to retrieve the two amounts from a template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `&#3647 ;` is the HTML entity for the Bitcoin symbol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a `getter` for derived data is always a good idea if we are not talking
    about input data. A notable feature of getters we have not yet discussed is their
    ability to interact with other getters and take an argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Accessing other getters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second argument passed to a getter when called is the object that contains
    the other `getters`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our recipe, we could call the `euro` getter to have some more derived data,
    like roughly how many houses we can buy with our Bitcoin given an average price
    of 150,000 euros:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Passing an argument
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a getter returns a function with an argument, that argument will be the
    argument of the getter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our recipe, a practical example could specify the average cost of a house
    in the getter from the previous paragraph:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Testing your store
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will write tests for a Vuex store.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge of Unit testing and End-To-End testing and little
    familiarity with Vuex.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, I'll define some features that our store must implement; then you will
    write tests that prove that the features are present and working.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our store consists of items in a to-do list, like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have two requirements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We must have an `MARK_ITEM_AS_DONE` mutation that changes the `done` field from
    false to true
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must have a `downloadNew` action that downloads the latest items from our
    server and adds them to the list
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing mutations
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to test your mutations, you have to make them available for your
    test files. To do this, you have to extract the mutation object from your store.
    Consider something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You have to extract it to something similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This way, you can import the mutations in your test files with the following
    line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The test for requirement number 1 can be written as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you are using the official Webpack template, you can run your tests with
    `npm run unit`. This uses PhantomJS by default, which doesn't implement some features.
    You can either use Babel polyfills or simply go into `karma.conf.js` and write
    `Chrome` instead of `PhantomJS` in the `browsers` array. Remember to install the
    Chrome launcher with `npm install karma-chrome-launcher --save-dev`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Testing actions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing actions** means testing that the action commits the expected mutations.
    We are not interested in the mutations themselves (not in unit tests at least)
    because they are already tested separately. We might, though, need to mock some
    dependencies.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any dependencies from Vue or Vuex (since we don''t need them and they
    may pollute the tests), we create a new `actions.js` file inside the `store` directory.
    Install Axios with `npm install axios`. The `actions.js` file can look like the
    following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To test for requirement number 2, we start by mocking the call to the server
    that should download the new to-do items:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will ensure that any call to the get method of `axios` will always return
    a new to-do item.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to ensure that the `ADD_ITEMS` mutation is called upon dispatch:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the testing of the mutations is pretty straightforward, I think the testing
    of the actions deserves some more explaining.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Since we didn't want to depend on external services for actions, we had to mock
    the `axios` service. We used the `inject-loader`, which takes the original library
    and mocks the parts we specify with arbitrary code (the `@` symbol is a shorthand
    for `src`); in our case, we mocked the `axios` library and, precisely, the `get`
    method. We had to use the CommonJS syntax (with the `require`) because that's
    the only way to tell Webpack to use loaders in imports.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: What we have done in the test is that we also mocked the `commit` function.
    Normally, this function calls a mutation that modifies the state. We just want
    to know if the correct mutation is called and with the right arguments. Moreover,
    we had to wrap everything in a `try` block; without it, the test would fail over
    a timeout and we'd lose the error. Instead, now we fail immediately and we can
    read, from the console, what error caused the test to fail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
