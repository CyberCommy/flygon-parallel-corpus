- en: Coding the Tetris Game with Pygame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Think out of the box*, an old adage that for the game developer might sound
    cliche, but is still very applicable. Most of the games that have revolutionized
    the gaming industry contain some unique elements and represent the taste of general
    audiences. But this worldwide assumption overestimates by discarding approaches
    that might be common among most game developers. After all, mathematical paradigms,
    object-rendering tools, and software remain the same. Thus, in this chapter, we
    are going to explore some of the advanced mathematical transformations and paradigms
    that every game programmer must know.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create one of the most played and downloaded
    games of the century that's very recognizable among 90s kids—*Tetris*. We will
    learn how to create it from scratch by building shapes that have been formatted
    from multi-dimensional lists. We will learn how to draw primitives and game grids,
    which will help us to locate the game objects. We will also learn how to implement
    rotational transformations of geometrical shapes and figures. Although this concept
    might sound simple, the application of these concepts ranges from different 2D
    to 3D **role-playing games** (**RPGs**).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with different concepts such
    as creating grid (virtual and physical) structures to locate game objects based
    on the position and color code. Then, you will learn about multi-dimensional list
    processing by using list comprehension. Furthermore, readers will also learn about
    the different shifting transformations and collision-checking principles. In the
    previous chapter, we implemented collision checks with the help of masking using
    pygame. However, in this chapter, we will do it in a programmer's way—it may be
    little complicated but it contains a profuse amount of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Tetris essentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a grid and random shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the windows and game loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the shape format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing the rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following requirements in order to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame editor (IDLE)—version 3.5+ is recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm IDE—refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code assets for the Tetris game can be found on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oDbq2J](http://bit.ly/2oDbq2J)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Tetris essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating pygame sprites and images into our Python game is a straightforward
    process. It requires a built-in Python module—*os—*that will load files from your
    machine. In the previous chapter, while building the Flappy Bird game, we learned
    how to make rotations, translations, and collisions of the sprites, and dealt
    with them one by one. Such transformations are not merely applied to images, but
    also to different geometrical figures and shapes. Tetris is a game that comes
    to everyone's mind when we talk about using such transformation operations—where
    a player is allowed to change the shape and size of the geometrical shapes through
    periodic motion. This periodic motion will create a realistic rotational transformation
    of the geometrical shapes, in both anticlockwise and clockwise directions. For
    those who are not familiar with Tetris, check out [https://www.freetetris.org/game.php](https://www.freetetris.org/game.php) and
    observe the grid and the environment of the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'By observing the environment of the gameplay, you will notice three primary
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geometrical shapes, such as L, T, S, I, and square**: These geometrical shapes
    will be presented in the form of alphabetical characters, and to distinguish between
    them, each shape will have different colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid**: This will be the place where the geometrical shapes can move. This
    will be the game canvas, where geometrical shapes will fall from the top to the
    bottom. The player cannot control this grid, but they can control the shapes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotate the shapes**: As shapes/blocks will be falling downwards, players
    can use the arrow keys from the keyboard in order to alter the structure of the
    shapes (remember that only rotation transformation is allowed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the shapes that we will be using for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ea74cf4a-be7c-4741-a349-b3cf92a2a87e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you've played the game in the aforementioned link, you will have seen that
    the preceding shapes move within the grid (canvas) of the game. The respective
    letters represent each the geometrical shape they resemble.  Players can only
    use the arrow key to rotate such shapes. For instance, when shape **I** is falling
    to the grid, players can switch between a vertical I and a horizontal **I**. But
    in the case of the square shapes, we do not have to define any rotations since
    the square (due to its equal sides) looks exactly the same after a rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the game characters for our Tetris game (geometrical
    shapes), let's brainstorm further in order to extract some critical information
    about the game. Let's talk about the essentials of Tetris. Since Tetris requires
    the creation of different geometrical shapes, it is undoubtedly true that we will
    require the `pygame` module. The `pygame` module can be used to create grids,
    borders, and game characters. Do you remember the `draw` module (from [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*) of pygame? Obviously, you cannot make good games without using the
    `pygame` `draw` module. Similarly, to handle user action events such as keyboard
    actions, we need pygame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The blueprint of functions represents the top-level view of Tetris that can
    be built by the Python `pygame` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build_Grid()`:This function will draw the grid into the game canvas. The grid
    is the place where we can render geometrical shapes with different colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_Grid()`: This function will create different horizontal lines into
    the grid so that we can track each shape for rotational transformation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotating_shapes`: This technique will rotate the geometrical shapes within
    the same origin. This means that rotation will not alter the dimension (length
    and height) of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've completed the brainstorming process, let's dive into the fundamental
    concepts of Tetris. The environment of Tetris is simple, yet powerful. We have
    to draw grids into it so that we can track each (*x*,*y*) position of the different
    shapes. Similarly, for tracking each geometrical shape, we need to create a dictionary,
    which will store the **position** of an object as *key* and the **color** of an
    object as *value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing the template code for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have finished declaring the global for our game, which mostly takes
    care of the width and height of the screen, we can start defining the shapes format
    for the game objects. In the next section, we will define a nested list, which
    we can use to define the multiple structures of the game objects (mostly for geometrical
    shapes).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shapes format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upcoming information is tricky. We are going to declare the shapes format
    (all the essential geometrical shapes) for Tetris. Let''s look at a simple example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the shapes format from the preceding code. It is a nested list, and
    we require it because `I` supports one rotation, which will change the vertical
    `I` into a horizontal `I`. Observe the first element of the preceding list; it
    contains a period (`.`), along with an identifier (`0`), to indicate null and
    block placement. In the place of the dot or period, we won''t have anything, and
    so it will remain empty. But in the place of `0`, we will store the block. To
    do this, remove the dot from the preceding code, and observe only element `0`.
    You will see vertical `I` in the zero^([th]) index and horizontal `I` in the first
    index. In the case of square shapes, we don''t need an extra *rotation*, and so
    we will end up declaring only one element inside the list for the square shape.
    It will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to create a format for the geometrical shapes, let''s
    create the starter piece of code for different shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s define the shape format for another few geometrical shapes,
    like we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully defined the characters for our game, let''s make
    a data structure to hold these objects, along with their color. Let''s write the
    following code to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since we have completed the basic starter file, that is, we have understood
    and created our game objects, in the next section, we will start creating a grid
    for our game, as well as render the game objects onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a grid and random shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined the format of the shapes, it is time to give actual
    characteristics to them. The way that we provide characteristics to the shapes
    is by defining dimensions and color. Previously, we defined the dimension of the
    block as being 30 in size, which is not arbitrary; the dimension of the shapes
    must be equal in height and width. Every geometrical shape that we are going to
    draw in this chapter will resemble at least square shapes. Confused? Look at the
    code where we defined the shape format, including period (`.`) and character (`0`).
    If you observe each element of the list closely, you will see the format of the
    square, with equal numbers of dots arranged in rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned in the *Understanding Tetris essentials* section, the grid
    is the place or environment where our game characters will reside. The player
    control, or action, will be activated only within the grid area. Let''s talk about
    how the grid can be used in our game. The grid is the division of the screen in
    the form of vertical and horizontal lines, which will make up each row and column.
    Let''s make one for ourselves and observe the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is complex, but it is an essential building block for most
    of the games that are made out of pygame. The preceding code will return a grid,
    which is obviously the environment for our Tetris game, but it can also be used
    for multiple purposes, such as building tic-tac-toe with little modification,
    or Pac-Man, and so on. The argument to the `build_Grid()` function is a single
    argument—the *occupied* dictionary. This dictionary will be passed to this function
    from the place where this function is called. Mainly, this function will be called
    inside the main function, which will initiate the process of creating a grid for
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The occupied dictionary that is passed to `build_Grid` will contain a key and
    a value (as it is a dictionary). The key will represent the position where each
    block or shapes resides. The value will contain the color code of each shape that
    is represented by the key. For example, in your print dictionary, you will see
    something like `{position: color_code}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line of the operation should be a gotcha moment for you. If not, you
    are missing something! This can be found in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml),
    *List Comprehension and Properties*. With the help of one line of code, we defined
    an arrangement of rows and columns (multi-dimensional list). It will provide us
    with a range of values that can be used to create a grid of lines. Of course,
    lines will be drawn later in the main function, with the help of the `pygame`
    `draw` module. We will create a list of 10 rows and a list of 20 columns. Now,
    let's talk about the last couple of lines of code (the highlighted part). These
    lines of code will loop through each occupied position and add that to the grid
    by modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the environment for our game, the next thing we need to do is
    define the shapes for our game. Remember that each shape will have attributes
    like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Row and column position**: The grid-specific position will be specified as
    a certain row and column of shapes or geometrical pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shape name**: The identifier for a shape, which indicates which shapes to
    render. We will add alphabetical characters for each shape, for example, character
    S for shape S.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: The color of each shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation**: The angle of rotation for each shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we are aware of the available attributes for each shape, let''s define
    the class for shape and attach each attribute to it. Write the following code
    in order to create `Shape` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `objects_color and game_objects` variable was defined previously, and is
    two different lists that contain alphabetical characters in one list. The color
    code for each of them in the other list.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment, if you run your game, you won''t see anything except for an
    empty black screen, which is because our grid background was rendered with the
    color code of black. We know that, if we want anything to draw, it can be done
    with the help of the Python `pygame` module. Furthermore, we are drawing shapes
    from the top to the bottom of the grid, and so we have to generate shapes randomly.
    Since we have five shapes, that is, I, O, J, L, and T, we need to render them
    randomly, one by one. Let''s make a function to implement in the following code
    snippet. Remember, we already imported a random module at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding backend logic is vital for any game that has something to do with
    geometrical shapes and pieces. The scope of this knowledge is much broader than
    you will have expected. Many RPG games, including Minecraft, have the player interact
    with different geometrical shapes. Thus, creating a grid is vital so that we can
    reference the position and color of each piece. Now that we have created some
    general logic that will create pieces of different shapes and color, we need a
    tool that can render such shapes into the grid, which is normally done by either
    OpenGL or pygame (PyOpenGL will be covered in the upcoming [Chapter 14](6682d3f2-927b-4434-a452-dc64329ae6a3.xhtml),
    *Getting to Know PyOpenGL*). However, the superior tool will be pygame, in the
    case of Python. Thus, we will make the Tetris game shapes and characters with
    the help of the `pygame` module.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create some logic that will set up a game window
    for the grid structure. We will also try to run our game and observe its environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the window and game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next big thing in our game, after setting up the game objects, is to render
    the grid. Don't get confused by thinking that we have already created the grid,
    after we defined the `build_Grid()` method. Although it is a valid point, the
    grid that we built is virtual up to this point. If you simply call the `build_Grid`
    method, you won't see anything but a black screen, which is the background of
    the grid. Here, we are going to provide a structure to this grid. Using each position,
    specified by row and column, we are going to create a straight line using the
    `pygame` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a simple function to draw a window for our game (the main window)
    in which the grid will reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code will create the physical structure of the grid, which
    will have different rows and columns. After looping through the entire grid scene
    or positions of the grid, we will enter the grid scope in order to draw a rectangle
    and a grid border with the previously highlighted part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s provide a physical structure to this grid by defining borders
    for it. Each row and column will be distinguished by creating lines within it.
    Since we can draw lines with the pygame `draw` module, we will use it to write
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function has one main loop, which loops into several rows, as
    determined by the `build_Grid` method. After going into each row of the grid structure,
    it will use the `pygame` `draw` module to draw lines with a color code of (128,
    128, 128), starting from (`side_x`, `side_y`) and then pointing to the next coordinate
    (`side_x + game_width, side_y + eachRow *30`). The starting point (`side_x`, `side_y`)
    is the left-most corner of the grid, while the next coordinate value of (`side_x
    + game_width, side_y + eachRow *30`) represents the coordinate of the right-most
    corner of grid. Thus, we will a draw line from the left-most corner of the grid
    to the right-most corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you explicitly call the previous function, you will see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/308f5211-105f-4eb1-b438-b076b37c299b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After setting up the aforementioned grid or environment, we will hop into the
    fun stuff, which is creating the main function. The main function will have a
    different bunch of stuff in it, mostly for calling up and setting the grid, and
    handling user events or actions, such as what happens when the user presses quit
    or presses an arrow key on the keyboard. Let''s define it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have started defining the main function, which is the director of
    our game, let''s define what things it must do, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Call multiple functions, such as `build_Grid()` and `create_Grid()`, which will
    set up the environment for games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a method that will perform rotations for a shape that represents characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define some logic that will add fall time constraints to the game, that is,
    the speed at which objects fall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a shape in, after one shape fall to the ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create some logic to check the occupied position of the shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned processes are the main function capabilities, and we should
    address them. We will address the first two in this section, but the remaining
    two will be covered in the upcoming sections. So, the first operation of the main
    function is to call some essential functions that will create the grid for the
    game. If you look at the aforementioned line of code, you will see that we have
    already called the  `build_Grid` method, which is responsible for creating the
    virtual positions for rows and columns of a grid-like structure. Now, the remaining
    task is to only call the `create_Grid()` method, which will give a proper physical
    structure to this virtual grid, using the `pygame` `draw` module. We have already
    defined both of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn about one of the important mathematical paradigms
    of transformation, which is known as rotation, and will add the feature of rotating
    game objects to our Tetris game.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding rotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we continue to code and modify the main function, let''s get into the
    mathematical stuff. Games are nothing if they are not related to a mathematical
    paradigm. Movement, motions, shapes, characters, and controls are all handled
    by mathematical expressions. In this section, we are going to cover another important
    concept of math: transformations. Although transformations is a nebulous concepts
    in math, we will try our best to learn this concept. Specifically, there are different
    types of transformations: rotation, translation, reflection, and enlargement.
    In most games, we will need only two types of transformation: rotation and enlargement.
    In this chapter, we will implement rotational transformations using Tetris, and
    then we will implement the enlargement transformation (while building an Angry
    Birds game in [Chapter 16](f8991a99-2dc4-4d55-8a7d-bb9b71f04109.xhtml), *Learning
    Game AI – Building a Bot to Play*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *rotation* is a mathematical concept which states that *When an object
    is rotated, it means that it is turned either clockwise or anticlockwise with
    a certain amount of specified degree*. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7370dec7-a5e6-4beb-a586-3e05a340cc64.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have a rectangular shape, which represents the
    alphabetical `I` character of our Tetris game. Now, imagine that the player presses
    the *up* arrow key on the keyboard. In such an event, the rectangular shape of
    `I` must be rotated with an angle of 90 degrees and placed as the horizontal `I`
    character, as shown in the preceding diagram. Thus, these rotations are done to
    change the shape of the figure, but not the dimensions. Horizontal `I` and vertical
    `I` have the same dimensions (height and width). Now that you know a little bit
    about rotations, you can go back to the code where we defined the shape format
    for each character (I, O, J, L, and T) and observe the multi-dimensional list.
    In the case of `I`, you could observe that it has two elements. The first element
    of the list is the original shape of the game object, `I`, and the second element
    of the list is a distorted shape after a rotation of about 90 degrees. Observe
    the same for the `O` character, which is square. The square will remain the same,
    even after a rotation by any degree. Thus, in the case of the square shape, we
    have only one element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we''ve learned this trivia about rotations, and how they are attached
    with the each shape format, the question still remains that: when can we render
    each shape, and when should the operation of rotations be carried out? The answer
    is simple. While a player presses any arrow key on the keyboard, we are going
    to perform rotations. But where is the code that implies that the user is pressing
    a keyboard key? Obviously, it is done inside the event handling process! In the
    main function, we started to capture the event, and we handled the actions for
    the `QUIT` key. Now, let''s perform the rotations for any arrow key with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: The code should be added inside the event handling steps, right after handling
    the `QUIT` key. Make sure that you provide a proper indentation for the code.
    The code will be available at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to learn more about how the rotation of objects works under the
    hood, make sure that you check out the following URL: [https://mathsdoctor.co.uk](https://mathsdoctor.co.uk).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up the window canvas or game screen, we can simply call the
    `pygame set_mode` method and render the window of the grid accordingly. The following
    line of the method call should be added within the main function, right after
    you have set up the user handling events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created a grid for the screen, let''s set up the main screen
    and call up the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have covered almost all of the important things, including rendering the
    display, rotating objects, creating grids, and rendering borders for grids; but
    one question still remains: how do we render the shapes into the grid? Obviously,
    our computer is not smart enough to understand the multi-dimensional list that
    we created earlier to define the shapes format. Still confused? Check the multi-dimensional
    list that we created for each character, such as I, O, J, L, and T—our computer
    won''t understand such a list. Thus, we have to convert these list values or attributes
    into the dimensions that will be recognized by our computer for further processing.
    The dimensional value that our computer will understand refers to the positional
    value. Since we have established the grid already, we can use rows and columns
    from the grid structure to give positional value to the computer. Thus, let''s
    make a function to implement it.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the shape format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our computer doesn''t have the capability to understand the obscure content
    of data structures, such as the content that is stored inside the multi-dimensional
    list. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous square-shaped pattern, we have coupled a list of periods (`.`)
    with `0`. The computer won''t recognize what 0 means, and what the period refers
    to. We only have the knowledge that the period is in a position that is an empty
    place, which means its position can be ignored, and the position where `0` resides
    is the position for the block. Thus, we need to write a program to tell the computer
    to extract the position from the grid where only `0` resides for each of the pieces.
    We will implement it by defining the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the previous code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, this function returns the position of the block of the objects.
    Thus, we start by creating a block dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, we store several lists of shapes, as defined by a multi-dimensional
    list of characters, which are defined by `game_objects` (I, O, J, L, and T) with
    rotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the important part: what are the positions that must be returned by this
    function? These positions are the position of `0`, placed in the grid.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the multi-dimensional list again. You will see a bunch of dots (`.`)
    and `0` placed as elements. We only want the position where `0` resides, and not
    where the period or dot resides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we check each column for `0` with the `if column == \'0\'` command, we
    only store such positions into the positions dictionary, and return it from the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When operations such as rotation and movements are done, it is often the case
    that the user might trigger some invalid movements, such as rotating the objects
    outside of the grid. Thus, we have to check such invalid movements and prevent
    them from happening. We will create the `check_Moves()` function to implement
    this. The argument to this function will be the shape and grid position; shape
    is essential to check if a specific rotation is allowed or not within the position
    that is indicated by the grid argument. If the current position specified by the
    grid in which shape resides is already occupied, then we will get rid of such
    moves. There are different ways to implement it, but the quickest and easiest
    way is to check the color of the grid background. If the color of the particular
    position in the grid is anything other than black, it means that the position
    is occupied. Thus, you can make an articulated reference from this logic as to
    why we made the background color of the grid black. By doing so, we can check
    if the objects are already in the grid or not. If any new object comes down to
    the grid, we should not pass it through the object that is already present in
    the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a function to check if the position is occupied or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, we were building the backend logic for our game, which refers
    to rendering the grid, manipulating the grid, changing grid positions, implementing
    logic that determines what happens when two objects collide, and so on. Even though
    we have done so much already, when you run your game, you will still see only
    the formation of the grid, and nothing more. This is because our main loop is
    the director of our game—it will sequentially order the other functions, but inside
    the main loop, we have nothing except the code that handles the user events. Thus,
    in the next section, we will the modify main loop for the game and observe the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, our main game loop is accountable for performing
    many tasks, including handling user events, handing the grid, checking possible
    moves, and so on. We have been making functions that will check such actions,
    movements, and environments, but we have not called them once, which we will do
    in this section. If you observe the main game loop from a high-level perspective,
    it will contain four primary architectural building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the grid and handling movements of the game objects. For instance,
    what should be the speed of the objects that will fall down into the grid?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user events. We have already done this, when we checked the events
    and rotated the objects accordingly. But the preceding code didn't accommodate
    the `check_Moves()` function, which will check if the moves are valid or not.
    Thus, we will modify the preceding code accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding color to the game objects (unique color). For instance, the color of
    `S` should be different to `I`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the logic that will check what happens when the object hits the ground
    of the grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will implement each of the aforementioned steps one by one. Let''s start
    by adding speed to the object. Speed refers to the free-falling speed of the objects
    in the grid structure. The following code should be added inside the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that the player tries to make an invalid move. Even in that case, the
    game objects (shapes) must fall freely downwards. Such an operation is done in
    the last three lines of the previous code. Other than that, the code is self-explanatory;
    we have defined the speed for the object to fall into the grid and used a clock
    module to implement the time constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the next logic, this is relatively easier. We have already discussed
    handling user events in Tetris while considering details such as rotating objects
    and performing simple left-to-right movements. However, in those lines of code,
    we didn''t check if the moves that the user tried to make were valid or not. We
    have to check this first in order to make sure that users are prevented from making
    any invalid moves. To implement this, we are going to call the `check_Moves()`
    method, which we created previously. The following code will handle user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, focus on the code that is highlighted. The first highlighted part
    of the code refers to whether the move is valid into the grid, which is checked
    by the `check_Moves()` function. We are allowing the current shapes to move to
    the right corner, which is toward the positive *x*-axis. Similarly, regarding
    the up key, it is responsible for checking if rotation of the object is allowed
    or not (only the up key will rotate the objects; the *left* and *right* keys will
    move the objects from left to right, and vice versa).  In the case of rotation,
    we are rotating it through pixel transformations, which is done by selecting one
    of the positions indicated by the multi-dimensional list. For example, in the
    case of shape I, we have two elements in the list: one original shape and another
    rotational shape. Thus, to use another rotational shape, we will check if the
    move is valid or not, and if it is, we will render the new shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third piece of code that should be added into the main function will deal
    with the technique that will add the color to the shapes in the grid for drawing.
    The following line of code will add the color to each of the objects that is inside
    the scope of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last piece of logic that must be added to the main function will
    address the situation of when an object hits the ground. Let''s add the following
    code into the main function in order to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are checking whether the objects are falling freely
    or not by checking the contents of the Boolean variable, `change_shape`. Then,
    we are checking the current position of the shapes and creating (*x*, *y*), which
    will represent the occupied position. We then add such a position to the dictionary
    named occupied*.* You must remember that the value of this dictionary is the color
    code of the same object. After assigning the current object to the grid scope,
    we will generate a new shape with the help of the `generate_shapes ()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s end our main function by calling the `create_Grid()` function
    with the argument of the grid and surface objects that were initialized by the
    pygame `set_mode()` method in the following code (we initialized the pygame `surface`
    object previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our game and observe the output for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c2d46b20-3945-47a1-b433-1dd79e686249.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can clearly see that we are able to make a Tetris game where the users
    are able to transform the objects and play accordingly. But wait! We are missing
    one important piece of logic in our game. How do we incentivize our player to
    play this game? If the game was all about making rotations of objects, and filling
    up grids with the objects, it would not have been the historical game that it
    is (the game that revolutionized the 90s gaming industry). Yes! There is some
    logic that must be added into the game, and when this logic is called, we will
    observe that whenever the row positions are *occupied* by the blocks, we have
    to clear such rows and shift the row one step down, which will leave us with fewer
    rows than before. We will implement this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, in this section, we will check if every position,
    of all the rows, is entirely occupied or not. If they are occupied, we will delete
    such rows from the grid, and this will create a shift in each row by one step
    down into the grid. This logic is simple to implement. We will check whether or
    not the entire row is occupied and delete such rows accordingly. Do you remember
    the case of creating the `check_Moves()` function? If this function checked the
    background color of each row, and if in each row there is no black background
    color, it means that such a row is occupied. But even if we have one position
    empty, this means that the background color of such a position will be black,
    and will be considered as not occupied. Thus, we can use a similar type of technique
    in the case of clearing the rows: if, in any row, the background color of any
    position is black, it means that the position is not occupied, and such rows cannot
    be cleared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a function to implement the logic of clearing the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s digest the preceding code. It is quite a complex piece of logic, so
    make sure that you learn everything about it; these concepts are not only suitable
    for game creation but are also asked many times in a technical interview. The
    question lies in how to shift the values of the data structure by creating logic,
    and not by using the Python built-in function. I wanted to teach you this in this
    way instead of using any built-in method because knowing this might be helpful
    in any technical field of programming. Now, let''s observe the code. It starts
    with creating a `number_of_rows_deleted` variable, which indicates the number
    of rows that have been deleted from the grid. The information regarding the number
    of deleted rows is important because after deleting that number of rows, we need
    to shift the rows which reside above the deleted row(s) by an equal number down
    the grid. For example, look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/712a0c70-671e-482c-a693-9565bc90a21a.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, now that we know what to delete with the `if black_background_color
    not in eachRow` expression, we can determine whether or not each row of the grid
    has empty places or not. If there are empty places, this means that the rows are
    not occupied, and if yes, then a black background color, that is, (0, 0, 0), won't
    be within any row. If we didn't find a black background color, then we can be
    sure that the rows are occupied, and we can delete them by checking further conditions.
    In the highlighted part of the code, you can observe that we are taking only the
    j^([th]) element, which is only a column. This is because, while deleting row,
    the value of `I` remains the same, but the j^([th]) column value differs. Thus,
    we loop on an entire column within a single row and use the `del` command to delete
    the occupied position.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding line of code, we were able to delete entire rows if any
    rows were occupied, but we didn''t address what should happen after we delete
    it, and this is the tricky part. After we delete every occupied row, not only
    the blocks will be deleted—the entire grid containing rows will be deleted. Thus,
    in place of deleted block, we won''t have empty rows; instead, whole rows containing
    the grid will be deleted. Thus, to make sure that we do not decrease the count
    of the actual grid, we need to add another row from the top to compensate for
    it. Let''s write some code to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay! Let''s digest it. This is quite complex but extremely powerful information.
    The preceding code will implement shifting the block of rows from the top, down
    into the grid. Firstly, the shift is required only if we have deleted any row;
    if yes, we enter into the logic to perform shifting. First of all, let''s only
    observe the code that involves the lambda function, that is, `list(occupied),
    position=lambda x: x[1]`. The code will create a list of all the positions of
    the grid and then use the lambda function to take the *y*-part of the position
    only. Remember, taking the *x* position of the block is superfluous—for each row,
    the value of *x* remains constant, but the *y* values differs. Thus, we will take
    the value of the *y*-position and then sort it with the `sorted(x)` function.
    The sorted function will sort the position based on the value of the *y*-coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the sorting will be done based on the lower value of *y* to the upper
    value of *y*. For example, look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f4cf74ea-2a52-4699-bc7a-b649e98cbffb.png)'
  prefs: []
  type: TYPE_IMG
- en: Calling the sorted method and then reversing the list (refer to [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*, to learn more about how to reverse lists) is important
    because sometimes the bottom part of the grid won't be occupied, and only the
    upper layer will. In such cases, we don't want the shifting operation to cause
    any harm to the bottom rows, which are not occupied.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, after taking track of the position of each row, we will check if
    there are any rows above the deleted row with the `if y < index_of_deleted_rows` expression.
    Again, in this case, the value of *x* is irrelevant because it will be the same
    within the single row; after we check if there is any row above the row that is
    deleted, we perform the shifting operation. The operation of shifting is quite
    simple; we will try to assign the new position for each of the rows that reside
    just above the deleted row. We can create a new position by increasing the value
    of *y* with the number of deleted rows. For instance, if there are two rows being
    deleted, we need to add two to the value of *y* so that the block just above the
    deleted rows, and the subsequent ones, will shift two rows down. After we shift
    the rows down into the grid, we have to pop the blocks out from the previous position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined a function that will clear the entire row if it is
    occupied, let''s call it from the main function to observe its effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, with this protracted and tedious day of coding, we have a very productive
    result. When you run your module where the main function is declared, you will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/529f38a4-88da-4c63-9baa-01e261a7d2de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The game looks appealing, and I have tested everything in the code. The code
    looks thorough and exhaustive, with no loop holes. Similarly, you can play it
    and share it with your friends and uncover the possible modifications that can
    be done with this game. This is an advanced game and it adequately raises its
    bar, when it is coded with Python from scratch. We have learned so many things
    while building this game. We learned how to define the shapes format (we have
    done even more complicated stuff before, such as the transformation of sprites,
    and handling the collision of sprites), but this chapter was challenging on different
    aspects. For example, we had to take care of things such as invalid moves, possible
    collisions, shifting, and so on. We implemented some logic that determined if
    an object is placed in a certain position or not by comparing two distinct color
    objects: the **background color** of the grid or surface against the **game-object
    color**.'
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet; we will try to implement some more logic in the next section.
    We will see what other modifications we can make to our game. We will try to build
    some logic that will increase the difficulty level of our game as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several modifications can be made to our game, but the most important ones
    will be to add a welcome screen, an increased difficulty level, and a score screen.
    Let''s start with the welcome screen, since it is easy to implement. We can use
    the `pygame` module to create a window, and a text surface to provide a message
    to the user. The following code shows how to create a main screen for our Tetris
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the game, you will see the following output, in which the welcome
    screen will be rendered. After pressing any key, you will be redirected to the
    Tetris game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ff97e2d4-de62-4a0c-8075-dda1d8e9657b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, let''s add some logic that will increase the difficulty of the game.
    There are two ways of implementing this logic. Firstly, you can create a timer,
    and if a player plays more than the range of the associated timer, we can decrease
    the fall speed so that shapes will fall faster than before (increase speed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can implement another piece of logic to increase the difficulty
    of the game. This method is better one than the preceding one. In this method,
    we will use *score* to increase the difficulty of the game. The following code
    represents a blueprint of how to implement the score of the player in order to
    increase the level of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implemented the relationship between the score and
    the speed of objects. Let's suppose a player's score is higher. This means that
    the user has been playing a less difficult level, and thus, such a high score
    value will be multiplied with the higher speed of fall value, resulting in an
    increase in `speedforFall`, which will be then subtracted from the speed of the
    objects, which will create a faster fall motion. In contrast, a player playing
    on a higher level will have a lower score, which will be multiplied with a lower
    value of the speed of objects, resulting in a lower number, which will be then
    subtracted from the `speedforFall` variable. This will result in less change in
    the speed for the player who is playing the harder level. But let's say a player
    is a pro and has scored higher in a harder level. In this case, the speed of the
    fall of an object is increased accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We have finally completed a fully functional Tetris game. We have learned several
    advanced concepts of game programming using Python in this chapter. In the process
    of its creation, we revised a few of the concepts that we learned about previously
    while discovering the fundamental concepts of Python, such as manipulating multi-dimensional
    lists, list comprehensions, object-oriented paradigms, and mathematical transformations.
    Along with revising those concepts, we uncovered several novel concepts such as
    implementing rotations, implementing shifting operations, creating a shape format
    from scratch, creating a grid (virtual and physical) structure, and populating
    objects within the grids.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the *Pythonic* way of implementing multi-dimensional
    list processing. We have created a multi-dimensional list to store the format
    for different geometrical shapes, and manipulated it using mathematical transformations.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the simple example of Tetris to demonstrate the usage of several
    data structures in the game, along with its manipulation. We have implemented
    a dictionary to store key as a position and value as the color code of those objects.
    Building such a dictionary is a life-saver for games such as Tetris. While making
    logic to check the collisions and shifting operations, we used the dictionary
    to observe whether the background color of any object is the same as the background
    of any position. Although Tetris is only one case study, the techniques that are
    used in this game are also used in many real-world games, including Minecraft,
    and in almost every RPG game.
  prefs: []
  type: TYPE_NORMAL
- en: The operations involving mathematical transformation were vital for us. We used
    rotational principles in this chapter in order to change the structure of the
    objects without changing their dimensions. The knowledge that you will have grasped
    from this chapter is enormous. Concepts such as the manipulation of a multi-dimensional
    list can be extended to data applications, and is termed as a 2D Numpy array,
    which is used in creating different analogies, such as street analogy, the multiple
    travelers problem, and so on. Although it is considered that the dictionary is
    the king of the data structures, processing a multi-dimensional list is not too
    far behind as it is combined with the simplicity of list comprehensions. Along
    with the implementation of such complex data structures, we learned how to implement
    mathematical transformations, that is, the rotational movement of game objects.
    This feature is extremely useful in any 3D game as it will provide the user with
    a 360-dimensional view of the scene. Similarly, we have learned how to create
    a grid structure.
  prefs: []
  type: TYPE_NORMAL
- en: A grid structure is used to track the positions of the objects. In complex games
    such as WorldCraft, it is a mandatory task of any game developer to track the
    objects and resources for the game, and in such cases, the grid works perfectly.
    Invisible grids can be implemented as a dictionary, or as any complex collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goal of this chapter was to familiarize you with 2D game graphics,
    that is, drawing primitives and game grids. Similarly, you learned about another
    way of detecting collisions between game objects (in the Flappy Bird game, we
    used the pygame masking technique to detect collisions). In this chapter, we implemented
    a universal and traditional way of implementing collision checks: by checking
    the background color attributes with the object color attributes. Similarly, we
    learned how to create different objects (that differed in structure) by using
    rotations. This technique can be used to spawn multiple enemies into games. Instead
    of designing multiple different objects for each character (which can be time-consuming
    and costly), we used transformations to change the structures of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about Python OpenGL, which is often termed PyOpenGL. We
    will see how we can create different geometrical structures using openGL, and
    observe how to use PyOpenGL and pygame together. We will primarily focus on different
    mathematical paradigms. We will see how attributes such as vertices and edges
    are used to create different complex mathematical shapes. Furthermore, we will
    see how we can implement ZOOM IN and ZOOM OUT features in the game using PyOpenGL.
  prefs: []
  type: TYPE_NORMAL
