- en: Building Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to get you started building container images.
    We will look at several different ways with which you can define and build your
    images using the tools built into Docker. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images using a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images using an existing container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images using environmental variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images using multi-stage builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we installed Docker on the following target operating
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS High Sierra and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 10 Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 18.04
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be using our Docker installation to build images. While
    the screenshots in this chapter will be from my preferred operating system, which
    is macOS, the Docker commands we will be running will work on all three of the
    operating systems on which we have installed Docker so far. However, some of the
    supporting commands, which will be few and far between, may only be applicable
    to macOS and Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: A full copy of the code used in this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2D0JA6v](http://bit.ly/2D0JA6v)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover Dockerfiles in depth, along with the best practices
    to use. So what is a Dockerfile?
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Dockerfile** is simply a plain text file that contains a set of user-defined
    instructions. When the Dockerfile is called by the `docker image build` command,
    which we will look at next, it is used to assemble a container image. A Dockerfile
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even with no explanation, it is quite easy to get an idea of
    what each step of the Dockerfile instructs the `build` command to do.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to working our way through the previous file, we should quickly
    touch upon Alpine Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alpine Linux** is a small, independently developed, non-commercial Linux
    distribution designed for security, efficiency, and ease of use. While small (see
    the following section), it offers a solid foundation for container images due
    to its extensive repository of packages, and also thanks to the unofficial port
    of grsecurity/PaX, which is patched into its kernel it offers proactive protection
    dozens of potential zero-day and other vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alpine Linux, due both to its size, and how powerful it is, has become the
    default image base for the official container images supplied by Docker. Because
    of this, we will be using it throughout this book. To give you an idea of just
    how small the official image for Alpine Linux is, let''s compare it to some of
    the other distributions available at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2105ef9d-b875-4566-8cab-73e416e7fd93.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the Terminal output, Alpine Linux weighs in at only 4.41
    MB, as opposed to the biggest image, which is Fedora, at 253 MB. A bare-metal
    installation of Alpine Linux comes in at around 130 MB, which is still almost
    half the size of the Fedora container image.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Dockerfile in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the instructions used in the Dockerfile example. We will
    look at them in the order in which they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM   `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LABEL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY` and `ADD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` and `CMD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Dockerfile instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FROM` instruction tells Docker which base you would like to use for your
    image; as already mentioned, we are using Alpine Linux, so we simply have to put
    the name of the image and the release tag we wish to use. In our case, to use
    the latest official Alpine Linux image, we simply need to add `alpine:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: LABEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LABEL` instruction can be used to add extra information to the image. This
    information can be anything from a version number to a description. It's also
    recommended that you limit the number of labels you use. A good label structure
    will help others who have to use our image later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, using too many labels can cause the image to become inefficient as
    well, so I would recommend using the label schema detailed at [http://label-schema.org/](http://label-s%20chema.org/).
    You can view the containers'' labels with the following Docker `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following to filter just the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example Dockerfile, we add two labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maintainer="Russ McKendrick <russ@mckendrick.io>"` adds a label which helps identify,
    to the end user of the image, who is maintaining it'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`description="This example Dockerfile installs NGINX."` adds a brief description
    of what the image is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, it is better to define your labels when you create a container from
    your image, rather than at build time, so it is best to keep labels down to just
    metadata about the image and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: RUN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RUN` instruction is where we interact with our image to install software
    and run scripts, commands, and other tasks. As you can see from our `RUN` instruction,
    we are actually running three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of our three commands is the equivalent of running the following
    command if we had a shell on an Alpine Linux host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command installs nginx using Alpine Linux's package manager.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `&&` operator to move on to the next command if the previous
    command was successful. To make it more obvious which commands we are running,
    we are also using `\` so that we can split the command over multiple lines, making
    it easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command in our chain removes any temporary files and so on to keep
    the size of our image to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final command in our chain  creates a folder with a path of `/tmp/nginx/`,
    so that nginx will start correctly when we run the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have also used the following in our Dockerfile to achieve the same
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, much like adding multiple labels, this is considered to be considered
    inefficient as it can add to the overall size of the image, which for the most
    part we should try to avoid. There are some valid use cases for this, which we
    will look at later in the chapter. For the most part, this approach to running
    commands should be avoided when your image is being built.
  prefs: []
  type: TYPE_NORMAL
- en: COPY and ADD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, `COPY` and `ADD` look like they are doing the same task; however,
    there are some important differences. The `COPY` instruction is the more straightforward
    of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have probably guessed, we are copying two files from the files folder
    on the host we are building our image on. The first file is `nginx.conf`, which
    contains a basic nginx configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will overwrite the NGINX configuration that was installed as part of the
    APK installation in the `RUN` instruction. The next file, `default.conf`, is the
    most simple virtual host that we can configure, and has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this will overwrite any existing files. So far, so good, so why might
    we use the `ADD` instruction? In our case, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are adding a file called `html.tar.gz`, but we are not actually
    doing anything with the archive to uncompress it in our Dockerfile. This is because
    `ADD` automatically uploads, uncompresses, and puts the resulting folders and
    files at the path we tell it to, which in our case is `/usr/share/nginx/`. This
    gives us our web root of `/usr/share/nginx/html/`, as we defined in the virtual
    host block in the `default.conf` file that we copied to the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ADD` instruction can also be used to add content from remote sources.
    For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command line would download `html.tar.gz` from `http://www.myremotesource.com/files/`
    and place the file in the `/usr/share/nginx/` folder on the image. Archive files
    from a remote source are treated as files and are not uncompressed, which you
    will have to take into account when using them, meaning that the file would have
    to be added before the `RUN` instruction, so that we could manually unarchive
    the folder and also remove the `html.tar.gz`file.
  prefs: []
  type: TYPE_NORMAL
- en: EXPOSE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction lets Docker know that when the image is executed, the
    port and protocol defined will be exposed at runtime. This instruction does not
    map the port to the host machine, but instead, opens the port to allow access
    to the service on the container network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our Dockerfile, we are telling Docker to open port `80` every
    time the image runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ENTRYPOINT and CMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The benefit of using `ENTRYPOINT` over `CMD`, which we will look at next, is
    that you can use them in conjunction with each other. `ENTRYPOINT` can be used
    by itself, but remember that you would want to use `ENTRYPOINT` by itself only
    if you wanted to have your container be executable.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, if you think of some of the CLI commands you might use, you have
    to specify more than just the CLI command. You might have to add extra parameters
    that you want the command to interpret. This would be the use case for using `ENTRYPOINT`
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to have a default command that you want to execute
    inside a container, you could do something similar to the following example, but
    be sure to use a command that keeps the container alive. In our case, we are using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is that whenever we launch a container from our image, the
    nginx binary is executed, as we have defined that as our `ENTRYPOINT`, and then
    whatever we have as the `CMD` is executed, giving us the equivalent of running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of how `ENTRYPOINT` can be used is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be the equivalent of running the following command on our host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't have to tell Docker to use nginx. As we have the nginx
    binary as our entry point, any command we pass overrides the `CMD` that had been
    defined in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: This would display the version of nginx we have installed, and our container
    would stop, as the nginx binary would only be executed to display the version
    information and then the process would stop. We will look at this example later
    in this chapter, once we have built our image.
  prefs: []
  type: TYPE_NORMAL
- en: Other Dockerfile instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some instructions that we have not included in our example Dockerfile.
    Let's take a look at them here.
  prefs: []
  type: TYPE_NORMAL
- en: USER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `USER` instruction lets you specify the username to be used when a command
    is run. The `USER` instruction can be used on the `RUN` instruction, the `CMD`
    instruction, or the `ENTRYPOINT` instruction in the Dockerfile. Also, the user
    defined in the `USER` instruction has to exist, or your image will fail to build.
    Using the `USER` instruction can also introduce permission issues, not only on
    the container itself, but also if you mount volumes.
  prefs: []
  type: TYPE_NORMAL
- en: WORKDIR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WORKDIR` instruction sets the working directory for the same set of instructions
    that the `USER` instruction can use (`RUN`, `CMD`, and `ENTRYPOINT`). It will
    allow you to use the `CMD` and `ADD` instructions as well.
  prefs: []
  type: TYPE_NORMAL
- en: ONBUILD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ONBUILD` instruction lets you stash a set of commands to be used when the
    image is used in future, as a base image for another container image.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to give an image to developers and they all have a
    different code base that they want to test, you can use the `ONBUILD` instruction
    to lay the groundwork ahead of the fact of needing the actual code. Then, the
    developers will simply add their code to the directory you tell them, and when
    they run a new Docker build command, it will add their code to the running image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ONBUILD` instruction can be used in conjunction with the `ADD` and `RUN`
    instructions, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would run an update and package upgrade every time our image is used as
    a base for another container image.
  prefs: []
  type: TYPE_NORMAL
- en: ENV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ENV` instruction sets environment variables within the image both when
    it is built and when it is executed. These variables can be overridden when you
    launch your image.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfiles – best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have covered Dockerfile instructions, let''s take a look at the
    best practices of writing our own Dockerfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: You should try to get into the habit of using a `.dockerignore` file. We will
    cover the `.dockerignore` file in the next section; it will seem very familiar
    if you are used to using a `.gitignore` file. It will essentially ignore the items
    you have specified in the file during the build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to only have one Dockerfile per folder to help you organize your containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a version control system, such as Git, for your Dockerfile; just like any
    other text-based document, version control will help you move not only forward,
    but also backward, as necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the number of packages you install per image. One of the biggest goals
    you want to achieve while building your images is to keep them as small as possible.
    Not installing unnecessary packages will greatly help in achieving this goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure there is only one application process per container. Every time you
    need a new application process, it is best practice to use a new container to
    run that application in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep things simple; over-complicating your Dockerfile will add bloat and also
    potentially cause you issues further down the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn by example! Docker themselves have quite a detailed style guide for publishing
    the official images they host on Docker Hub. You can find a link to this in the
    further reading section at the end of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the `docker image build` command. This is where
    the rubber meets the road, as they say. It's time for us to build the base upon
    which we will start building our future images. We will be looking at different
    ways to accomplish this goal. Consider this as a template that you may have created
    earlier with virtual machines. This will help save time by completing the hard
    work; you will just have to create the application that needs to be added to the
    new images.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of switches that you could use while using the `docker build`
    command. So, let''s use the always handy `--help` switch on the `docker image
    build` command to view all that we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are then a lot of different flags listed that you can pass when building
    your image. Now, it may seem like a lot to digest, but out of all of these options,
    we only need to use `-- tag`, or its shorthand `-t`, to name our image.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the other options to limit how much CPU and memory the build process
    will use. In some cases, you may not want the `build` command to take as much
    CPU or memory as it can have. The process may run a little slower, but if you
    are running it on your local machine or a production server and it's a long build
    process, you may want to set a limit. There are also options that affect the networking
    configuration of the container launched to build our image.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you don't use the `--file` or `-f` switch, as you run the `docker
    build` command from the same folder that the Dockerfile is in. Keeping the Dockerfile
    in separate folders helps sort the files and keeps the naming convention of the
    files the same.
  prefs: []
  type: TYPE_NORMAL
- en: It also worth mentioning that, while you are able to pass additional environment
    variables as arguments at build time, they are used at build time and your container
    image does not inherit them. This is useful for passing information such as proxy
    settings, which may only be applicable to your initial build/test environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `.dockerignore` file, as we discussed earlier, is used to exclude those
    files or folders we don't want to be included in the `docker build` as, by default,
    all files in the same folder as the Dockerfile will be uploaded. We also discussed
    placing the Dockerfile in a separate folder, and the same applies to `.dockerignore`.
    It should go in the folder where the Dockerfile was placed.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping all the items you want to use in an image in the same folder will help
    you keep the number of items, if any, in the `.dockerignore` file to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Dockerfile to build a container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first method that we are going to look at for use in building your base
    container images is by creating a Dockerfile. In fact, we will be using the Dockerfile
    from the previous section and then executing a `docker image build` command against
    it to get ourselves an nginx image. So, let''s start off by looking at the Dockerfile
    once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that you will also need the `default.conf`, `html.tar.gz`,and `nginx.conf` files
    in the files folder. You can find these in the accompanying GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there are two ways we can go about building this image. The first way would
    be by specifying the `-f` switch when we use the `docker image build` command.
    We will also utilize the `-t` switch to give the new image a unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `<REPOSITORY>` is typically the username you signed up for on Docker Hub.
    We will look at this in more detail in [Chapter 3](1a34f1f1-0e97-4973-bce1-c9750afd5c0a.xhtml)*,
    Storing and Distributing Images*; for now, we will be using `local`, and `<TAG>`
    is the unique container value you want to provide. Typically, this will be a version
    number or other descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, the `--file` switch isn''t used, and it can be a little tricky when
    you have other files that need to be included with the new image. An easier way
    to do the build is to place the Dockerfile in a separate folder by itself, along
    with any other file that you will be injecting into your image using the `ADD`
    or `COPY` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing to remember is the dot (or period) at the very end.
    This is to tell the `docker image build` command to build in the current folder.
    When you build your image, you should see something similar to the following Terminal
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6e1391b3-78b9-41bb-be22-c2da8c578d51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it''s built, you should be able to run the following command to check
    whether the image is available, and also the size of your image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, my image size is 5.98 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/32a631a1-77f7-461d-8248-8080e5641502.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can launch a container with your newly built image by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a container called `dockerfile-example`, you can check it
    is running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser and going to `http://localhost:8080/` should show you
    an extremely simple webpage that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7eb0d970-366a-4736-89e2-9d1a482d4161.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, we can quickly run a few of the commands mentioned in the previous
    section of the chapter, starting with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, we are currently running
    nginx version 1.14.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c6575287-1cf9-45d9-8d35-d1a8125cc814.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next command we can look at running, now that we have our first image built,
    displays the labels that we embedded at build time. To view this information run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, this displays the information we
    entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/27e551d4-99ed-4040-800e-986df10b1958.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move on, you can stop and remove the containers we launched with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will go into more detail about Docker container commands in Chapter 4, *Managing
    Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to build a base image is to start off by using one of the official
    images from the Docker Hub. Docker also keeps the Dockerfile for these official
    builds in their GitHub repositories. So there are at least two choices you have
    for using existing images that others have already created. By using the Dockerfile,
    you can see exactly what is included in the build and add what you need. You can
    then version control that Dockerfile if you want to change or share it later.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to achieve this; however, it is not recommended or considered
    to be good practice, and I would strongly discourage you from using it.
  prefs: []
  type: TYPE_NORMAL
- en: I would only use this method during a prototyping phase to check that the commands
    I am running work as expected in an interactive shell before putting them in a
    Dockerfile. You should always use a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should download the image we want to use as our base; as before,
    we will be using Alpine Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to run a container in the foreground so that we can interact
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once the container runs, you can add the packages as necessary using the `apk`
    command in this case, or whatever the package management commands are for your
    Linux flavour.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following commands would install nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed the packages you require, you need to save the container.
    The `exit` command at the end of the preceding set of commands will stop the running
    container, since the shell process we are detaching ourselves from just happens
    to be the process keeping the container running in the foreground. You can see
    this in the Terminal output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8dd37ad8-124e-4bdd-99da-053fe0af7dfe.png)'
  prefs: []
  type: TYPE_IMG
- en: It is at this point that you should really stop; I do not recommend you use
    the preceding commands to create and distribute images, apart from the one use
    case we will cover in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to save our stopped container as an image, you need to do something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, I ran the following command to save a copy of the container we
    launched and customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice how I called my image `broken-container`? As one of the use cases for
    taking this approach is that if, for some reason, you have a problem with a container,
    then it is extremely useful to save the failed container as an image, or even
    export it as a TAR file to share with others if you need some assistance in getting
    to the root of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save the image file, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for our example, I ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This gave me a 6.6 MB file called `broken-container.tar`. While we have this
    file, you can uncompress it and have a look around, as you can see from the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b9291bbe-f356-443c-a892-c4198c3c5695.png)'
  prefs: []
  type: TYPE_IMG
- en: The image is made up of a collection of JSON files, folders, and other TAR files.
    All images follow this structure, so you may be thinking to yourself, *Why is
    this method so bad*?
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason is trust—as already mentioned, your end user will not be
    able to easily see what is in the image they are running. Would you randomly download
    a prepackaged image from an unknown source to run your workload, without checking
    how the image was built? Who knows how it was configured and what packages have
    been installed? With a Dockerfile, you can see exactly what was executed to create
    the image, but with the method described here, you have zero visibility of this.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that it is difficult for you to build in a good set of defaults;
    for example, if you were to build your image this way, then you would not really
    be able to take advantage of features such as `ENTRYPOINT` and `CMD`, or even
    the most basic instructions, such as `EXPOSE`. Instead, the user would have to
    define everything required during their `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of Docker, distributing images that had been prepared in this
    way was common practice. In fact, I was guilty of it myself, as coming from an
    operations background, it made perfect sense to launch a "machine," bootstrap
    it, and then create a gold master. Luckily, over the last few years, Docker has
    extended the build functionality to the point where this option is not even a
    consideration anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Building a container image from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using prepared images from the Docker Hub as our base image.
    It is possible to avoid this altogether (sort of) and roll out your own image
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you usually hear the phrase *from **scratch*, it literally means that
    you start from nothing. That's what we have here—you get absolutely nothing and
    have to build upon it. Now, this can be a benefit, because it will keep the image
    size very small, but it can also be detrimental if you are fairly new to Docker,
    as it can get complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has done some of the hard work for us already, and created an empty TAR
    file on the Docker Hub named `scratch`; you can use it in the `FROM` section of
    your Dockerfile. You can base your entire Docker build on this, and then add parts
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Again, let's look at using Alpine Linux as our base operating system for the
    image. The reasons for doing this include not only the fact that it is distributed
    as an ISO, Docker image, and various virtual machine images, but also that the
    entire operating system is available as a compressed TAR file. You can find the
    download in the repository, or on the Alpine Linux download page.
  prefs: []
  type: TYPE_NORMAL
- en: To download a copy, just select the appropriate download from the downloads
    page, which can be found at [https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads/).
    The one I used was **x86_64** from the **MINI ROOT FILESYSTEM** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s downloaded, you need to create a Dockerfile that uses `scratch`
    and then add the `tar.gz` file, making sure to use the correct file, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your Dockerfile and operating system in a TAR file, you can
    build your image as you would any other Docker image by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare the image size to the other container images we have built
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, the image I built is exactly the
    same size as the Alpine Linux image we have been using from Docker Hug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/743714e2-4da6-4fe1-a592-85dfe819b8cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our own image has been built, we can test it by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you get an error, then you may already have a container called alpine-test
    created or running . Remove it by running `docker` `container stop alpine-test`,
    followed by `docker container rm alpine-test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should launch into a shell on the Alpine Linux image. You can check this
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display information on the release the container is running. To get
    an idea of what this entire process looks like, see the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/357eb630-d8aa-4d78-b99e-17ca4fa62f75.png)'
  prefs: []
  type: TYPE_IMG
- en: While everything appears straightforward, this is only thanks to the way Alpine
    Linux packages their operating system. It can start to get more complicated when
    you choose to use other distributions who package their operating systems in a who
    package their operating systems in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that can be used to generate a bundle of an operating
    system. We are not going to go into any detail on how to use any of these tools
    here because, if you have to consider this approach, you probably have some pretty
    specific requirements. There is a list of tools in the further reading section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So what could those requirements be? For most people, it will be legacy applications;
    for example, what happens if you have an application that requires an operating
    system that is no longer supported or available from Docker Hub, but you need
    a more modern platform to support the application? Well, you should be able to
    spin your image and install the application there, allowing you to host your old
    legacy application on a modern, supportable operating system/architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Using environmental variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the very powerful **environmental variables**
    (**ENVs**), as you will be seeing a lot of them. You can use ENVs for a lot of
    things in your Dockerfile. If you are familiar with coding, these will probably
    be familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: For others like myself, at first they seemed intimidating, but don't get discouraged.
    They will become a great resource once you get the hang of them. They can be used
    to set information when running the container, which means that you don't have
    to go and update lots of the commands in your Dockerfile or in scripts that you
    run on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use ENVs in your Dockerfile, you can use the `ENV` instruction. The structure
    of the `ENV` instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can always use an equals sign between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the question is, why are there two ways that you can define them, and
    what are the differences? With the first example, you can only set one `ENV` per
    line; however, it is easy to read and follow. With the second `ENV` example, you
    can set multiple environmental variables on the same line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view which ENVs are set on an image using the Docker `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how they need to be set in our Dockerfile, let''s take a look
    at them in action. So far we have been using a Dockerfile to build a simple image
    with just nginx installed. Let''s look at building something a little more dynamic.
    Using Alpine Linux, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set an `ENV` to define which version of PHP we would like to install.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Apache2 and our chosen PHP version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the image so Apache2 starts without issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the default `index.html` and add an `index.php` file that displays the
    results of the `phpinfo` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose port `80` on the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set Apache so it is the default process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our Dockerfile looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have chosen to install PHP7; we can build the image by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we have changed the command slightly. This time, we are calling
    the image `local/apache-php` and tagging the version as `7`. The full output obtained
    by running the preceding command can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether everything ran as expected by running the following command
    to launch a container using the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s launched, open a browser and go to `http://localhost:8080/` and
    you should see a page showing that PHP7 is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c5500d90-2c9c-4f4e-bfeb-f768b2c031b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Don't be confused by the next part; there is no PHP6\. For an explanation of
    why not, go to [https://wiki.php.net/rfc/php6](https://wiki.php.net/rfc/php6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in your Dockerfile, change `PHPVERSION` from `7` to `5` and then run the
    following command to build a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, the majority of the output
    is the same, apart from the packages that are being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch a container, this time on port `9090`, by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening your browser again, but this time going to `http://localhost:9090/`, should
    show that we are running PHP5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/41bd2e7e-8182-4035-be75-312200013d41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can compare the size of the images by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/47fc018c-fd1e-4dd5-bc96-1c3d87281a7c.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the PHP7 image is a lot smaller than the PHP5 one. Let's discuss
    what actually happened when we built the two different container images.
  prefs: []
  type: TYPE_NORMAL
- en: So what happened? Well, when Docker launched the Alpine Linux image to create
    our image, the first thing it did was set the ENVs we defined, making them available
    to all of the shells within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, the naming scheme for PHP in Alpine Linux simply substitutes
    the version number and maintains the same name for the packages we need to install,
    meaning that we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is actually interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for PHP5, it is interpreted as the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This means that we do not have to go through the whole Dockerfile, manually
    substituting version numbers. This approach is especially useful when installing
    packages from remote URLs, such as software release pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a more advanced example—a Dockerfile that installs and configures
    Consul by HashiCorp. In this Dockerfile, we are using environment variables to
    define the version numbers and the SHA256 hash of the file we downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Dockerfiles can get quite complex, and use of ENVs can help
    with the maintenance. Whenever a new version of Consul is released, I simply need
    to update the `ENV` line and commit it to GitHub, which will trigger the building
    of a new image—well, it would do if we had configured it to do so; we will be
    looking at this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You might have also noticed we are using an instruction within the Dockerfile
    we have not covered. Don't worry, we will look at the `VOLUME` instruction in
    [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml), *Managing Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Using multi-stage builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, the final part of our journey into using Dockerfiles and building container
    images, we will look at using a relatively new method for building an image. In
    the previous sections of this part of the chapter, we looked at adding binaries
    directly to our images either via a package manager, such as Alpine Linux's APK,
    or, in the last example, by downloading a precompiled binary from the software
    vendor.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to compile our own software as part of the build? Historically,
    we would have had to use a container image containing a full build environment,
    which can be very big. This means that we probably would have had to cobble together
    a script that ran through something like the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the build environment container image and starting a "build" container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the source code to the "build" container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiling the source code on the "build" container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the compiled binary outside of the "build" container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing the "build" container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a pre-written Dockerfile to build an image and copy the binary to it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is a lot of logic—in an ideal world, it should be part of Docker. Luckily,
    the Docker community thought so, and the functionality to achieve this, called
    a multi-stage build, was introduced in Docker 17.05.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile contains two different build stages. The first, named `builder`,
    uses the official Go container image from the Docker Hub. Here, we are installing
    a prerequisite, downloading the source code directly from GitHub, and then compiling
    it into a static binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As our static binary has a built-in web server, we do not really need anything
    else to be present from an operating system point of view. Because of this, we
    are able to use `scratch` as the base image, meaning that all our image will contain
    is the static binary that we have copied from the builder image, and won't contain
    any of the `builder` environment at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, we just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command can be found in the following code block—the interesting
    bits happen between steps 5 and 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, between steps 5 and 6, our binary has been compiled and the
    container that contains the `builder` environment is removed, leaving us with
    an image storing our binary. Step 7 copies the binary to a fresh container which
    has been launched using scratch, leaving us with just the content we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to run the following command, you would get an idea of why it is
    a good idea not to ship an application with its build environment intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot of our output shows that the `golang` image is `794MB`;
    with our source code and prerequisites added, the size increases to `832MB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c73e731e-21c0-461b-9e40-0ef64d69cfb5.png)'
  prefs: []
  type: TYPE_IMG
- en: However, the final image is just `6.56MB`. I am sure you will agree that this
    is quite a dramatic saving of space. It also adheres to the best practices, discussed
    earlier in the chapter, by only having content relevant to our application shipped
    within the image, as well as being really, really small.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the application by launching a container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The application is accessible over a browser and simply increments a counter
    each time the page is loaded. To test it on macOS and Linux, you can use the `curl`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0dd95dc9-af1e-401b-82c8-567ecff6abee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Windows users can simply visit `http://localhost:8000/` in a browser. To stop
    and remove the running container, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using a multi-stage build is a relatively simple process and
    is in keeping with the instructions that should already be starting to feel familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at an in-depth view of Dockerfiles, the best practices
    for writing them, the docker image build command, and the various ways we can
    build containers. We also learned about the environmental variables that you can
    use to pass from your Dockerfile to the various items inside your containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, now that we know how to build images using Dockerfiles,
    we will be taking a look at the Docker Hub and all of the advantages that using
    a registry service brings. We will also look at the Docker registry, which is
    open source, so you can roll your own place to store images without the fees of
    Docker Enterprise, as well as third-party registry services.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: The `LABEL` instruction tags your image once it has been built?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between the `ENTRYPOINT` and `CMD` instructions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: when using the `ADD` instruction, you can’t download and automatically
    uncompress an externally hosted archive?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a valid use for using an existing container as the base of your image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `EXPOSE` instruction expose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the guidelines for the official Docker container images at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the tools to help you create containers from existing installations
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Debootstrap: [https://wiki.debian.org/Debootstrap/](https://wiki.debian.org/Debootstrap/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yumbootstrap: [https://github.com/dozzie/yumbootstrap/](https://github.com/dozzie/yumbootstrap/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rinse: [https://salsa.debian.org/debian/rinse/](https://salsa.debian.org/debian/rinse/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker contrib scripts: [https://github.com/moby/moby/tree/master/contrib/](https://github.com/moby/moby/tree/master/contrib/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the full GitHub repository for the Go HTTP Hello World application
    can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/geetarista/go-http-hello-world/](https://github.com/geetarista/go-http-hello-world/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
