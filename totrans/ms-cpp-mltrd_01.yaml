- en: Revisiting Multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chances are that if you're reading this book, you have already done some multithreaded
    programming in C++, or, possibly, other languages. This chapter is meant to recap
    the topic purely from a C++ point of view, going through a basic multithreaded
    application, while also covering the tools we'll be using throughout the book.
    At the end of this chapter, you will have all the knowledge and information needed
    to proceed with the further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic multithreading in C++ using the native API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing basic makefiles and usage of GCC/MinGW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling a program using `make` and executing it on the command-line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this book, we'll be assuming the use of a GCC-based toolchain
    (GCC or MinGW on Windows). If you wish to use alternative toolchains (clang, MSVC,
    ICC, and so on), please consult the documentation provided with these for compatible
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: To compile the examples provided in this book, makefiles will be used. For those
    unfamiliar with makefiles, they are a simple but powerful text-based format used
    with the `make` tool for automating build tasks including compiling source code
    and adjusting the build environment. First released in 1977, `make` remains among
    the most popular build automation tools today.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarity with the command line (Bash or equivalent) is assumed, with MSYS2
    (Bash on Windows) recommended for those using Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The multithreaded application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its most basic form, a multithreaded application consists of a singular process
    with two or more threads. These threads can be used in a variety of ways; for
    example, to allow the process to respond to events in an asynchronous manner by
    using one thread per incoming event or type of event, or to speed up the processing
    of data by splitting the work across multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of asynchronous responses to events include the processing of the graphical
    user interface (GUI) and network events on separate threads so that neither type
    of event has to wait on the other, or can block events from being responded to
    in time. Generally, a single thread performs a single task, such as the processing
    of GUI or network events, or the processing of data.
  prefs: []
  type: TYPE_NORMAL
- en: For this basic example, the application will start with a singular thread, which
    will then launch a number of threads, and wait for them to finish. Each of these
    new threads will perform its own task before finishing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the includes and global variables for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the I/O stream and vector headers should be familiar to anyone who has
    ever used C++: the former is here used for the standard output (`cout`), and the
    vector for storing a sequence of values.'
  prefs: []
  type: TYPE_NORMAL
- en: The random header is new in `c++11`, and as the name suggests, it offers classes
    and methods for generating random sequences. We use it here to make our threads
    do something interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the thread and mutex includes are the core of our multithreaded application;
    they provide the basic means for creating threads, and allow for thread-safe interactions
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we create two mutexes: one for the global vector and one for `cout`,
    since the latter is not thread-safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we create the main function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We push a fixed value onto the vector instance; this one will be used by the
    threads we create in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We create new threads, and provide them with the name of the method to use,
    passing along any parameters--in this case, just a single integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we wait for each thread to finish before we continue by calling `join()`
    on each thread instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we expect that each thread has done whatever it's supposed to
    do, and added the result to the vector, which we then read out and show the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this shows almost nothing of what really happens in the application,
    mostly just the essential simplicity of using threads. Next, let''s see what happens
    inside this method that we pass to each thread instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the integer parameter being passed to
    the thread method is a thread identifier. To indicate that the thread is starting,
    a message containing the thread identifier is output. Since we''re using a `non-thread-safe`
    method for this, we use the `cout_mtx` mutex instance to do this safely, ensuring
    that just one thread can write to `cout` at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we obtain the initial value set in the vector, we copy it to a local variable
    so that we can immediately release the mutex for the vector to enable other threads
    to use the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These last two lines contain the essence of what the threads created do: they
    take the initial value, and add a randomly generated value to it. The `randGen()`
    method takes two parameters, defining the range of the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we (safely) log a message informing the user of the result of this
    action before adding the new value to the vector. In both cases, we use the respective
    mutex to ensure that there can be no overlap when accessing the resource with
    any of the other threads.
  prefs: []
  type: TYPE_NORMAL
- en: Once the method reaches this point, the thread containing it will terminate,
    and the main thread will have one less thread to wait for to rejoin. The joining
    of a thread basically means that it stops existing, usually with a return value
    passed to the thread which created the thread. This can happen explicitly, with
    the main thread waiting for the child thread to finish, or in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we''ll take a look at the `randGen()` method. Here we can see some
    multithreaded specific additions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This preceding method takes a minimum and maximum value as explained earlier,
    which limits the range of the random numbers this method can return. At its core,
    it uses a mt19937-based `generator`, which employs a 32-bit **Mersenne Twister**
    algorithm with a state size of 19937 bits. This is a common and appropriate choice
    for most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Of note here is the use of the `thread_local` keyword. What this means is that
    even though it is defined as a static variable, its scope will be limited to the
    thread using it. Every thread will thus create its own `generator` instance, which
    is important when using the random number API in the STL.
  prefs: []
  type: TYPE_NORMAL
- en: A hash of the internal thread identifier is used as a seed for the `generator`.
    This ensures that each thread gets a fairly unique seed for its `generator` instance,
    allowing for better random number sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a new `uniform_int_distribution` instance using the provided
    minimum and maximum limits, and use it together with the `generator` instance
    to generate the random number which we return.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to compile the code described earlier, one could use an IDE, or type
    the command on the command line. As mentioned in the beginning of this chapter,
    we'll be using makefiles for the examples in this book. The big advantages of
    this are that one does not have to repeatedly type in the same extensive command,
    and it is portable to any system which supports `make`.
  prefs: []
  type: TYPE_NORMAL
- en: Further advantages include being able to have previous generated artifacts removed
    automatically and to only compile those source files which have changed, along
    with a detailed control over build steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The makefile for this example is rather basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the top down, we first define the compiler that we'll use (`g++`), set
    the name of the output binary (the `.exe` extension on Windows will be post-fixed
    automatically), followed by the gathering of the sources and any important compiler
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard feature allows one to collect the names of all files matching the
    string following it in one go without having to define the name of each source
    file in the folder individually.
  prefs: []
  type: TYPE_NORMAL
- en: For the compiler flags, we're only really interested in enabling the `c++11`
    features, for which GCC still requires one to supply this compiler flag.
  prefs: []
  type: TYPE_NORMAL
- en: For the `all` method, we just tell `make` to run `g++` with the supplied information.
    Next we define a simple clean method which just removes the produced binary, and
    finally, we tell `make` to not interpret any folder or file named `all` in the
    folder, but to use the internal method with the `.PHONY` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this makefile, we see the following command-line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we find an executable file called `ch01_mt_example` (with the `.exe`
    extension attached on Windows) in the same folder. Executing this binary will
    result in a command-line output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What one can see here already is the somewhat asynchronous nature of threads
    and their output. While threads `1` and `2` appear to run synchronously, starting
    and quitting seemingly in order, threads `3` and `4` clearly run asynchronously
    as both start simultaneously before logging their action. For this reason, and
    especially in longer-running threads, it's virtually impossible to say in which
    order the log output and results will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: While we use a simple vector to collect the results of the threads, there is
    no saying whether `Result 1` truly originates from the thread which we assigned
    ID 1 in the beginning. If we need this information, we need to extend the data
    we return by using an information structure with details on the processing thread
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'One could, for example, use `struct` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The vector would then be changed to contain result instances rather than integer
    instances. One could pass the initial integer value directly to the thread as
    part of its parameters, or pass it via some other way.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this chapter is primarily useful for applications where data
    or tasks have to be handled in parallel. For the earlier mentioned use case of
    a GUI-based application with business logic and network-related features, the
    basic setup of a main application, which launches the required threads, would
    remain the same. However, instead of having each thread to be the same, each would
    be a completely different method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this type of application, the thread layout would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.gif)'
  prefs: []
  type: TYPE_IMG
- en: As the graphic shows, the main thread would launch the GUI, network, and business
    logic thread, with the latter communicating with the network thread to send and
    receive data. The business logic thread would also receive user input from the
    GUI thread, and send updates back to be displayed on the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over the basics of a multithreaded application in C++
    using the native threading API. We looked at how to have multiple threads perform
    a task in parallel, and also explored how to properly use the random number API
    in the STL within a multithreaded application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss how multithreading is implemented both in
    hardware and in operating systems. We'll see how this implementation differs per
    processor architecture and operating system, and how this affects our multithreaded
    application.
  prefs: []
  type: TYPE_NORMAL
