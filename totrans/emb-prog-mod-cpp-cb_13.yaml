- en: Guidelines for Real-Time Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Real-time systems are a class of embedded systems where the time of reaction
    is critical. The consequences of not reacting in time vary between different applications.
    Based on severity, real-time systems are classified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard real time**: Missing a deadline is not acceptable and considered a system
    failure. These are usually mission-critical systems in airplanes, cars, and power
    plants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firm real time**: Missing a deadline is acceptable in rare cases. The usefulness
    of the result is zero after the deadline. Think about a live streaming service.
    A video frame delivered too late can only be discarded. This is tolerable provided
    it happens infrequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soft real time**: Missing a deadline is acceptable. The usefulness of results
    degrades after the deadline, causing degradation of the overall quality, and should
    be avoided. Such an example is capturing and synchronizing data from multiple
    sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time systems are not necessarily required to be super fast. What they need
    is predictable reaction time. If a system can normally respond to an event within
    10 milliseconds, but it often takes much longer, it is not a real-time system.
    If a system responds within 1 second guaranteed, this constitutes hard real time.
  prefs: []
  type: TYPE_NORMAL
- en: Determinism and predictability are the main traits of real-time systems. In
    this chapter, we will explore potential sources of unpredictable behavior and
    ways to mitigate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using real-time schedulers in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using statically allocated memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding exceptions for error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring real-time operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this chapter will help you better understand the specifics of
    real-time systems and learn some best practices of software development for this
    kind of embedded system.
  prefs: []
  type: TYPE_NORMAL
- en: Using real-time schedulers in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux is a general-purpose operating system that is commonly used in various
    embedded devices because of its versatility. It can be tailored to the particular
    hardware and is free.
  prefs: []
  type: TYPE_NORMAL
- en: Linux is not a real-time operating system and is not the best choice for implementing
    a hard real-time system. However, it can be used efficiently to build a soft real-time
    system, since it provides a real-time scheduler for time-critical applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the real-time scheduler in Linux in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that uses the real-time scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, `~/test`, create a subdirectory called `realtime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `realtime.cpp` file in the `realtime` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add all the necessary includes and namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a function that configures a thread to use the real-time scheduler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a thread function that we want to run with normal priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by a real-time thread function and a `main` function that
    starts both threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux has several scheduling policies that it applies to application processes
    and threads. `SCHED_OTHER` is the default Linux time-sharing policy. It is intended
    for all threads and does not provide real-time mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we use another policy, `SCHED_FIFO`. This is a simple scheduling
    algorithm. All threads that use this scheduler can only be preempted by a thread
    with a higher priority. If the thread goes to sleep, it is placed at the back
    of the queue of those threads with the same priority.
  prefs: []
  type: TYPE_NORMAL
- en: The priority of a thread with a `SCHED_FIFO` policy is always higher than the
    priority of any thread with a `SCHED_OTHER` policy, and as soon as a `SCHED_FIFO`
    thread becomes runnable, it immediately preempts a running `SCHED_OTHER` thread.
    From a practical standpoint, if there is only one `SCHED_FIFO` thread running
    in the system, it can use as much CPU time as it requires. The deterministic behavior
    and high priority of the `SCHED_FIFO` scheduler make it a good fit for real-time
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a real-time priority to a thread, we define a `ConfigureRealtime` function. This
    accepts two parameters—a thread ID and the desired priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function populates data for the `pthread_setschedparam` function that uses
    the low-level API of the operating system to change the scheduler and the priority
    of a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a `Measure` function that runs a busy loop, invoking a `nanosleep`
    function with parameters requiring it to sleep for 10 nanoseconds – way too short
    to yield execution to another thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function captures timestamps before and after the loop and calculates
    the elapsed time in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `RealTimeThread` function as a wrapper around the `Measure` function. This
    sets the priority of the current thread to real time and immediately invokes `Measure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we start two threads, passing text literals as parameters
    to differentiate their output. If we run the program on a Raspberry Pi device,
    we can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56a567f4-a5ee-43ce-8a70-8e6471fc11d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Real-time threads took four times lesser time because this was not preempted
    by normal threads. This technique can be efficiently used to meet the soft real-time
    requirements in the Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using statically allocated memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As has already been discussed in [Chapter 6](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml)*,
    Memory Management*, dynamic memory allocation should be avoided in real-time systems
    because generic memory allocators are not time-bound. While, in most cases, memory
    allocation does not take much time, it is not guaranteed. It is not acceptable
    for real-time systems.
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward way to avoid dynamic memory allocation is to replace
    it with static allocation. C++ developers often use `std::vector` to store sequences
    of elements. On account of its similarity with C arrays, it is efficient and easy
    to use and its interface is consistent with other containers in the standard library.
    Since vectors have a variable number of elements, they use dynamic memory allocation
    extensively. In many situations, however, the `std::array` class can be used instead
    of `std::vector`. It has the same interface, except that the number of its elements
    is fixed and so its instances can be allocated statically. This makes it a good
    alternative to `std::vector` when memory allocation time is critical.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how `std::array` can be efficiently used to represent
    a sequence of elements of fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that uses the power of the C++ standard
    library algorithms to generate and process fixed data frames without using dynamic
    memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, `~/test`, create a subdirectory called `array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `array.cpp` file in the `array` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add includes and a new type definition to the `array.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a function that generates data frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the function to process data frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main` function that ties data generation and processing together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `std::array` template to declare a custom `DataFrame` data type. For
    our sample application, a `DataFrame` is a sequence of eight 32-bit integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the new data type in functions to generate and process data
    frames. Since the data frame is an array, we pass it by reference to the `GenerateData`
    function to avoid extra copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`GenerateData` fills the data frame with random numbers. Since `std::array`
    has the same interface as other containers in the standard library, we can use
    standard algorithms to make the code shorter and more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `ProcessData` function in a similar manner. It also accepts a
    `DataFrame`, but it is not supposed to modify it. We use a constant reference
    to explicitly state that data will not be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ProcessData` prints all values in the data frame, and then finds the minimum
    and the maximum values in the frame. Unlike built-in arrays, `std::arrays` do
    not decay to raw pointers when passed to functions, so we can use range-based
    loop syntax. You may notice that we do not pass the size of the array into the
    function, and do not use any global constant to query it. It is part of the `std::array`
    interface. It not only reduces the number of parameters to the function, but also
    ensures that we cannot pass an incorrect size when calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the minimum and maximum values, we use the `std::minmax_` element function
    of the standard library instead of writing a custom loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we create an instance of `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we run a loop. On each iteration, a new data frame is generated and processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the application, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5443008c-9e80-4ed5-818e-9b2df50b60c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Our application generated four data frames and processed its data with only
    a few lines of code and using only statically allocated data. This makes `std::array`
    a good choice for developers of real-time systems. Moreover, unlike built-in arrays,
    our functions are type-safe and we can detect and fix a number of coding errors
    at build time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 standard introduced a new function, `to_array`, that allows developers
    to create instances of `std::array` from one-dimensional built-in arrays. See
    more details and examples on the `to_array` reference page ([https://en.cppreference.com/w/cpp/container/array/to_array](https://en.cppreference.com/w/cpp/container/array/to_array)).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding exceptions for error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mechanism of exceptions is an integral part of the C++ standard. It is a recommended
    way to design error handling in C++ programs. It does, however, have limitations
    that do not always make it acceptable for real-time systems, especially safety-critical
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: C++ exception handling depends heavily on stack unwinding. Once an exception
    is thrown, it propagates by the call stack up to the catch block that can handle
    it. This means that destructors of all local objects in all stack frames in its
    path are invoked, and it is hard to determine and formally prove the worst-case
    time of this process.
  prefs: []
  type: TYPE_NORMAL
- en: That is why coding guidelines for safety-critical systems, such as MISRA or
    JSF, explicitly forbid the use of exceptions for error handling.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that C++ developers have to revert to the traditional plain
    C error codes. In this recipe, we will learn how to use C++ templates to define
    data types that can hold either the result or the error code of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that uses the power of the C++ standard
    library algorithms to generate and process fixed data frames without using dynamic
    memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, `~/test`, create a subdirectory called `expected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create an `expected.cpp` file in the `expected` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add includes and a new type definition to the `expected.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a wrapper for the open POSIX function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main` function that shows how to use the `OpenForRead` wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we create a data type that can hold either an expected value
    or an error code in a type-safe way. C++17 provides a type-safe union class, `std::variant,`
    which we are going to use as an underlying data type for our templated class, `Expected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Expected` class encapsulates an `std::variant` field that can hold one
    of two data types, either templated type `T` or `std::error_code`, which is a
    standard C++ generalization of error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is possible to work with `std::variant` directly, we expose public
    methods that make it more convenient. The `valid` method returns `true` if the
    result holds the templated type, otherwise `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `value` and `error` methods are used to access returned values or error
    code, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `Expected` class is defined, we create an `OpenForReading` function
    that uses it. This invokes the open system function and, based on the return value,
    creates an instance of `Expected` that holds either a file descriptor or error
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, when we call `OpenForReading` for non-existing files,
    it is expected to fail. When we run the application, we can see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60b67f21-dfee-4227-8fa9-b3367d95f288.png)'
  prefs: []
  type: TYPE_IMG
- en: Our `Expected` class allows us to write functions that may return error codes,
    and do it in a type-safe way. Compile time-type validation helps developers to
    avoid many issues common to traditional error codes, making our applications more
    robust and safe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our implementation of the `Expected` data type is a variation of the `std::expected`
    class ([http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0323r7.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0323r7.html))
    proposed for standardization, but not approved. One of the implementations of
    `std::expected` can be found on GitHub at [https://github.com/TartanLlama/expected](https://github.com/TartanLlama/expected).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring real-time operating systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As has already been discussed in this chapter, Linux is not a real-time system.
    It is a good choice for soft real-time tasks, but despite the fact that it provides
    a real-time scheduler, its kernel is too complex to guarantee the level of determinism
    needed for hard real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: Time-critical applications require either a real-time operating system to run,
    or are designed and implemented to run on bare metal, with no operating system
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time operating systems are usually much simpler than general-purpose operating
    systems such as Linux. Also, they require tailoring to the particular hardware
    platform, usually a microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of real-time operating systems, with most of them being proprietary
    and not free. FreeRTOS is a good starting point to explore the capabilities of
    real-time operating systems. Unlike most of the alternatives, it is open source
    and free to use since it is distributed under the MIT license. It is ported to
    a number of microcontrollers and small microprocessors, but even if you do not
    have the specific hardware, Windows and POSIX simulators are available.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to download and run the FreeRTOS POSIX simulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to download and build a FreeRTOS simulator in our build environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to your Ubuntu Terminal and change the current directory to `/mnt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the source code of the FreeRTOS simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the downloaded archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the current directory to `Posix_GCC_Simulator/FreeRTOS_Posix/Debug`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Fix the minor mistake in `makefile` by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the simulator from the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Start it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the simulator is running.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, the kernels of real-time operating systems are usually much
    simpler than the kernels of general-purpose operating systems. The same is also
    true for FreeRTOS.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of this simplicity, the kernel can be built and run as a process
    in a general-purpose operating system, such as Linux or Windows. When used from
    within another operating system, it stops being truly real time, but can be used
    as a starting point to explore the FreeRTOS API and start working on applications
    that can later be run in the real-time environment of the target hardware platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we downloaded and built the FreeRTOS kernel for the POSIX operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build stage is straightforward. Once the code has been downloaded and extracted
    from the archive, we run `make`, and this builds a single executable, `FreeRTOS-POSIX`.
    Before running the `make` command, we fix a mistake in `makefile` by placing the
    `-lrt` option at the end of the GCC command line. We do this by running `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application starts the kernel and pre-packaged applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/592082ae-35ae-405e-8d7d-fefe26872dae.png)'
  prefs: []
  type: TYPE_IMG
- en: We were able to run FreeRTOS in our build environment. You can dive deeper into
    its code base and documentation to get a better understanding of the internals
    and APIs of real-time operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you work in the Windows environment, there is a better supported Windows
    version of the FreeRTOS simulator. It can be downloaded from [https://www.freertos.org/FreeRTOS-Windows-Simulator-Emulator-for-Visual-Studio-and-Eclipse-MingW.html](https://www.freertos.org/FreeRTOS-Windows-Simulator-Emulator-for-Visual-Studio-and-Eclipse-MingW.html),
    along with documentation and tutorials.
  prefs: []
  type: TYPE_NORMAL
