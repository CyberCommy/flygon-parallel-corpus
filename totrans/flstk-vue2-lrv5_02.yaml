- en: Prototyping Vuebnb, Your First Vue.js Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basic features of Vue.js. We'll then put
    this knowledge into practice by building a prototype of the case-study project,
    Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and basic configuration of Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue.js essential concepts, such as data binding, directives, watchers and lifecycle
    hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Vue's reactivity system works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project requirements for the case-study project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vue.js to add page content including dynamic text, lists, and a header
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an image modal UI feature with Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vuebnb prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be building a prototype of Vuebnb, the case-study project
    that runs for the duration of this book. The prototype will just be of the listing
    page, and by the end of the chapter will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9596f4dc-9623-43d0-8f51-f6ab7f04aa46.png)Figure 2.1\. Vuebnb prototype'
  prefs: []
  type: TYPE_NORMAL
- en: Once we've set up our backend in [Chapter 3](e50310e5-b580-47d0-aff6-015808cc3b1c.xhtml),
    *Setting Up a Laravel Development Environment*, and [Chapter 4](86698fb7-c4c0-4a6e-831d-4b8cdde3a4b8.xhtml),
    *Building a Web Service with Laravel*, we'll migrate this prototype into the main
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Project code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, you'll need to download the code base to your computer by cloning
    it from GitHub. Instructions are given in the section *Code base* in [Chapter
    1](29c092e4-bc60-42f4-892f-fb74440d3765.xhtml), *Hello Vue - An Introduction to
    Vue.js*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The folder `vuebnb-prototype` has the project code for the prototype we''ll
    now be building. Change into that folder and list the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The folder contents should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da98e41f-aca7-4d8c-9f95-07ea87433c5a.png)Figure 2.2\. vuebnb-prototype
    project filesUnless otherwise specified, all further Terminal commands in this
    chapter will assume you''re in the `vuebnb-prototype` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: NPM install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll now need to install the third-party scripts used in this project, including
    Vue.js itself. The NPM `install` method will read the included `package.json` file
    and download the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You'll now see a new  `node_modules` directory has appeared in your project
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Main files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `vuebnb-prototype`directory in your IDE. Note that the following `index.html`file
    is included. It's mostly comprised of boilerplate code, but also has some structural
    markup included in the `body` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this file links to `style.css`, where our CSS rules will be added,
    and `app.js`, where our JavaScript will be added.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Currently `app.js` is an empty file, but I have included some CSS rules in `style.css` to
    get us started.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Opening in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To view the project, locate the `index.html`file in your web browser. In Chrome,
    it's as simple as File *| Open File*. When it loads, you'll see a page that is
    mostly empty, other than the toolbar at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to add the `Vue.js` library to our project. Vue was downloaded
    as part of our NPM install, so now we can simply link to the browser-build of
    `Vue.js` with a `script` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's important that we include the Vue library *before* our own custom `app.js` script,
    as scripts run sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue will now be registered as a global object. We can test this by going to
    our browser and typing the following in the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25755703-7819-4ee5-b148-6b33180bb963.png)Figure 2.3\. Checking Vue
    is registered as a global object'
  prefs: []
  type: TYPE_NORMAL
- en: Page content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our environment set up and starter code installed, we're now ready to take
    the first steps in building the Vuebnb prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some content to the page, including the header image, the title, and
    the About section. We'll be adding structure to our HTML file and using `Vue.js`
    to insert the correct content where we need it.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at our `app.js` file, let's now create our root instance of Vue.js by
    using the `new` operator with the `Vue` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you create a `Vue` instance, you will usually want to pass in a configuration
    object as an argument. This object is where your project's custom data and functions
    are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As our project progresses, we'll be adding much more to this configuration object,
    but for now we've just added the `el` property that tells Vue where to mount itself
    in the page.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign to it a string (a CSS selector) or an HTML node object. In our
    case, we've used the `#app` string, which is a CSS selector referring to the element
    with the `app` ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Vue has dominion over the element it mounts on and any child node. For our project
    so far, Vue could manipulate the `div` with the `header` class, but it could not
    manipulate the `div` with the `toolbar`ID. Anything placed within this latter `div`
    will be invisible to Vue.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we'll refer to our mount node and its children as our template.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple task for Vue is to bind some JavaScript data to the template. Let's
    create a `data` property in our configuration object and assign to it an object
    including a `title` property with a `'My apartment'` string value.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Any property of this `data` object will be available within our template. To
    tell Vue where to bind this data, we can use *mustache* syntax, that is, double
    curly brackets, for example, `{{ myProperty }}`. When Vue instantiates, it compiles
    the template, replaces the mustache syntax with the appropriate text, and updates
    the DOM to reflect this. This process is called *text interpolation* and is demonstrated
    in the following code block.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a few more data properties now and enhance our template to include
    more of the page structure.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's also add some new CSS rules.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now save and refresh your page, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbb14c0f-4e35-413a-8b62-2250d8786bec.png)Figure 2.4\. Listing page
    with basic data binding'
  prefs: []
  type: TYPE_NORMAL
- en: Mock listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we're developing, it'd be nice to work with some mock data so that we
    can see how our completed page will look. I've included `sample/data.js` in the
    project for this very reason. Let's load it in our document, making sure it goes
    above our `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the file and you'll see that it declares a `sample` object. We
    will now utilize it in our data configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you save and refresh, you''ll see more realistic data on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b44d2a8b-d651-4e4c-8f99-85ee662df265.png)Figure 2.5\. Page including
    mock-listing sampleUsing global variables split over different script files in
    this way is not an ideal practice. We''ll only be doing this in the prototype,
    though, and later we''ll get this mock-listing sample from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Header image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No room listing would be complete without a big, glossy image to show it off.
    We've got a header image in our mock listing that we'll now include. Add this
    markup to the page.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And this to the CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why we're using a `div` rather than an `img` tag. To help
    with positioning, we're going to set our image as the background of the `div` with
    the `header-img` class.
  prefs: []
  type: TYPE_NORMAL
- en: Style binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set a background image, we must provide the URL as a property in a CSS rule
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, our header image should be specific to each individual listing, so
    we don't want to hard code this CSS rule. Instead, we can have Vue bind the URL
    from data to our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue can''t access our CSS style sheet, but it can bind to an inline `style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think using a text interpolation is the solution here, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But this is not valid Vue.js syntax. This is, instead, a job for another Vue.js
    feature called a `directive`. Let's explore directives first and then come back
    to solving this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue''s directives are special HTML attributes with the *v-* prefix, for example, `v-if`,
    which provide a simple way to add functionality to our templates. Some examples
    of directives you can add to an element are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-if`: Conditionally render the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-for`: Render the element multiple times based on an array or object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-bind`: Dynamically bind an attribute of the element to a JavaScript expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-on`: Attach an event listener to the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more that we will explore throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like normal HTML attributes, directives are usually name/value pairs in
    the form `name="value"`. To use a directive, simply add it to an HTML tag as you
    would an attribute, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a directive requires a value, it will be an *expression*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript language, expressions are small, evaluable statements that
    produce a single value. Expressions can be used wherever a value is expected,
    for example in the parenthesis of an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression here could be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical expression, for example `x + 7`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comparison, for example `v <= 7`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Vue `data` property, for example `this.myval`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directives and text interpolations both accept expression values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: v-if'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-if` will conditionally render an element if its value is a *truthy* expression.
    In the following case, `v-if` will remove/insert the `p` element depending on
    the `myval` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Will renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add a consecutive element with the `v-else` directive (a special directive
    that requires no value), it will be symmetrically removed/inserted as `myval` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some directives take an *argument*, denoted by a colon after the directive
    name. For example, the `v-on` directive, which listens to DOM events, requires
    an argument to specify which event should be listened to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `click`, the argument could be `mouseenter`, `keypress`, `scroll`, or
    any other event (including custom events).
  prefs: []
  type: TYPE_NORMAL
- en: Style binding (continued)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming back to our header image, we can use the `v-bind` directive with the `style` argument to
    bind a value to the `style` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`headerImageStyle` is an expression that evaluates to a CSS rule that sets
    the background image to the correct URL. It sounds very confusing, but when you
    see it working, it will be quite clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create `headerImageStyle`as a data property. When binding to a style
    attribute, you can use an object where the properties and values are equivalent
    to the CSS properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the code, refresh the page, and the header image will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6601a188-3ce0-4e1e-8b6e-7480bb40e6ff.png)Figure 2.6\. Page including
    header image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect the page with your browser Dev Tools and notice how the `v-bind` directive
    has evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Lists section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next bit of content we''ll add to our page is the Amenities and Prices lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b06075a-4384-4cc7-88c9-ce8d3e540bd0.png)Figure 2.7\. Lists section'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the mock-listing sample, you'll see that the `amenities` and `prices` properties
    on the object are both arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '`sample/data.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Wouldn't it be easy if we could just loop over these arrays and print each item
    to the page? We can! This is what the `v-for` directive does.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's add these as data properties on our root instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: List rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `v-for` directive requires a special type of expression in the form of `item
    in items`, where `items` is the source array, and `item` is an alias for the current
    array element being looped over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on the `amenities` array first. Each member of this array is an
    object with a `title` and `icon` property, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We'll add the `v-for` directive into the template and the expression we assign
    to it will be `amenity in amenities`. The alias part of the expression, that is
    `amenity`, will refer, throughout the loop sequence, to each object in the array,
    starting with the first.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second property of our amenity objects is `icon`. This is actually a class
    relating to an icon in the Font Awesome icon font. We've installed Font Awesome
    as an NPM module already, so add this to the head of the page to now use it.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we can complete the structure of our amenities section in the template.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, the DOM nodes generated by `v-for="amenity in amenities"` are
    reactively bound to the `amenities` array. If the content of `amenities` changes,
    Vue will automatically re-render the nodes to reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: When using `v-for`, it's recommended you provide a unique `key` property to
    each item in the list. This allows Vue to target the exact DOM nodes that need
    to be changed, making DOM updates more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the key would be a numeric ID, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For the amenities and prices lists, the content is not going to change over
    the life of the app, so there's no need for us to provide a key. Some linters
    may warn you about this, but in this case, the warning can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now add the price list to our template as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you'll agree that looping a template is far easier than writing out
    every item. However, you may notice that there is still some common markup between
    these two lists. Later in the book we'll utilize components to make this part
    of the template even more modular.
  prefs: []
  type: TYPE_NORMAL
- en: Show more feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've run into a problem now that the lists section is after the About section.
    The About section has an arbitrary length, and in some of the mock listings that
    we'll add you'll see that this section is quite long.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want it to dominate the page and force the user to do a lot of unwelcome
    scrolling to see the lists section, so we need a way to hide some of the text
    if it's too long, yet allow the user to view the full text if they choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a show more UI feature that will crop the About text after a certain
    length and give the user a button to reveal the hidden text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2097c214-5dcc-43d3-82d1-2d682fe49996.png)Figure 2.8. Show more feature'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by adding a `contracted` class to the `p` tag that contains the `about` text
    interpolation. The CSS rule for this class will restrict its height to 250 pixels
    and hide any text overflowing the element.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We'll also put a button after the `p` tag that the user can click to expand
    the section to full height.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here's the CSS that's needed, including a generic button rule that will provide
    base styling for all buttons that we'll add throughout the project.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, we need a way to remove the `contracted` class when the user
    clicks the More button. Seems like a good job for directives!
  prefs: []
  type: TYPE_NORMAL
- en: Class binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How we'll approach this is to dynamically bind the `contracted` class. Let's
    create a `contracted` data property and set its initial value to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Like our style binding, we can bind this class to an object. In the expression,
    the `contracted` property is the name of the class to be bound, the `contracted` value is
    a reference to the data property of that same name, which is a Boolean. So if
    the `contracted` data property evaluates to `true`, that class will be bound to
    the element, and if it evaluates to `false`, it will not.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It follows that when the page loads the `contracted` class is bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Event listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now want to remove the `contracted` class automatically when the user clicks
    the More button. To do this job, we'll use the `v-on` directive, which listens
    to DOM events with a `click` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `v-on` directive can be an expression that assigns `contracted` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we click the More button, the `contracted` value changes and Vue will instantly
    update the page to reflect this change.
  prefs: []
  type: TYPE_NORMAL
- en: How does Vue know to do this? To answer this question we must first understand
    the concept of getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assign a value to a property of a JavaScript object is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve it is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There's no trick here. The point I want to make though, is that we can replace
    this normal assignment/retrieval mechanism of an object through use of getters
    and setters. These are special functions that allow custom logic for getting or
    setting the property's value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters and setters are especially useful when one property''s value is determined
    by another. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` and `set` functions of the `fullName` property are invoked whenever
    we attempt a normal assignment/retrieval of its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Reactive data properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another one of Vue''s initialization steps is to walk through all of the data
    properties and assign them getters and setters. If you look in the following screenshot,
    you can see how each property in our current app has a `get` and `set` function
    added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/66c022e6-0030-4d84-a3ad-c05e38b395a6.png)Figure 2.9\. Getters and
    setters'
  prefs: []
  type: TYPE_NORMAL
- en: Vue added these getters and setters to enable it to perform dependency tracking
    and change notification when the properties are accessed or modified. So, when
    the `contracted` value is changed by the `click` event, its `set` method is triggered.
    The `set` method will set the new value, but will also carry out a secondary task
    of informing Vue that a value has changed and any part of the page relying on
    it may need to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to know more about Vue's reactivity system, check out the article *Reactivity
    In Vue.js (And Its Pitfalls)* at [https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/](https://vuejsdevelopers.com/2017/03/05/vue-js-reactivity/).
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the More button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the About section has been expanded, we want to hide the More button as
    it's no longer needed. We can use the `v-if` directive to achieve this in conjunction
    with the `contracted` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Image modal window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent our header image from dominating the page, we've cropped it and limited
    its height. But what if the user wants to see the image in its full glory? A great
    UI design pattern to allow the user to focus on a single item of content is a *modal
    window*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our modal will look like when opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2d1ce89f-6747-4219-9540-615a7a3f6d17.png)Figure 2.10\. Header image
    modal'
  prefs: []
  type: TYPE_NORMAL
- en: Our modal will give a properly scaled view of the header image so the user can
    focus on the appearance of the lodgings without the distraction of the rest of
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we will insert an image carousel into the modal so the user
    can browse through a whole collection of room images!
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, here are the required features for our modal:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the modal by clicking the header image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeze the main window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the modal window with a close button or the *Escape* key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's add a Boolean data property that will represent the opened or closed
    state of our modal. We'll initialize it to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We'll make it so that clicking our header image will set the modal to open.
    We'll also overlay a button labelled View Photos in the bottom-left corner of
    the header image to give a stronger signal to the user that they should click
    to show the image.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that, by putting the click listener on the wrapping `div`, the click event
    will be captured regardless of whether the user clicks the `button` or the `div` due
    to DOM event propagation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add some more CSS to our header image to make the cursor a *pointer*,
    letting the user know the header can be clicked, and giving the header a relative
    position so the button can be positioned within it. We'll also add rules to style
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add the markup for our modal. I've put it after the other elements
    in the page, though it doesn't really matter as the modal will be out of the regular
    flow of the document. We remove it from the flow by giving it a `fixed` position
    in the following CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The main modal `div` will act as a container for the rest of the modal content,
    but also as a background panel that will cover up the main window content. To
    achieve this, we use CSS rules to stretch it to completely cover the viewport
    by giving it `top`, `right`, `bottom`, and `left` values of `0`. We'll set the `z-index` to
    a high number to ensure the modal is stacked in front of any other element in
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the `display` is initially set to `none`, but we're dynamically
    binding a class to the modal called `show` that gives it block display. The addition/removal
    of this class will, of course, be bound to the value of `modalOpen`.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now add markup for the window that will be overlaid on our background
    panel. The window will have a width constraint and will be centered in the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Disabling the main window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the modal is open, we want to prevent any interaction with the main window
    and also make a clear distinction between the main window and the child window.
    We can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Dimming the main window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing body scroll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimming the main window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could simply hide our main window when the modal is open, but it's better
    if the user can still be aware of where they are in flow of the app. To achieve
    this, we will *dim* the main window under a semi-transparent panel.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by giving our modal panel an opaque black background.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Preventing body scroll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a problem, though. Our modal panel, despite being full screen, is still
    a child of the `body` tag. This means we can still *scroll* the main window! We
    don't want users to interact with the main window in any way while the modal is
    open, so we must disable scrolling on the `body`.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to add the CSS `overflow` property to the `body` tag and set it
    to `hidden`. This has the effect of clipping any *overflow* (that is, part of
    the page not currently in view), and the rest of the content will be made invisible.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to dynamically add and remove this CSS rule, as we obviously want
    to be able to scroll through the page when the modal is closed. So, let's create
    a class called `modal-open` that we can apply to the `body` tag when the modal
    is open.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `v-bind:class` to add/remove this class, right? Unfortunately, no.
    Remember that Vue only has dominion over the element where it is mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If we add a directive to the `body` tag, it will *not* be seen by Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Vue's mount element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we just mounted Vue on the `body` tag, wouldn''t that solve our problems?
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not permitted by Vue and if you attempt it you will get this error:
    Do not mount Vue to <html> or <body> - mount to normal elements instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Vue has to compile the template and replaces the mount node. If
    you have script tags as children of the mount node, as you often do with `body`,
    or if your user has browser plugins that modify the document (many do) then all
    sorts of hell might break loose on the page when it replaces that node.
  prefs: []
  type: TYPE_NORMAL
- en: If you define your own root element with a unique ID, there should be no such
    conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how can we add/remove classes from the `body` if it''s out of Vue''s dominion?
    We''ll have to do it the old-fashioned way with the browser''s Web API. We need
    to run the following statements when the modal is opened or closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As discussed, Vue adds reactive getters and setters to each data property so
    that when data changes it knows to update the DOM appropriately. Vue also allows
    you to write custom logic that hooks into reactive data changes via a feature
    called *watchers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a watcher, first add the `watch` property to your Vue instance. Assign
    an object to this where each property has the name of a declared data property,
    and each value is a function. The function has two arguments: the old value and
    new value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a data property changes, Vue will trigger any declared watcher methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Vue can't update the `body` tag for us, but it can trigger custom logic that
    will. Let's use a watcher to update the `body` tag when our modal is opened and
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now when you try to scroll the page you'll see it won't budge!
  prefs: []
  type: TYPE_NORMAL
- en: Closing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users will need a way to close their modal and return to the main window. We'll
    overlay a button in the top-right corner that, when clicked, evaluates an expression
    to set `modalOpen` to `false`. The `show` class on our wrapper `div` will consequentially
    be removed, which means the `display` CSS property will return to `none`, thus
    removing the modal from the page.
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Escape key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a close button for our modal is handy, but most people's instinctual
    action for closing a window is the *Escape *key.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-on` is Vue''s mechanism for listening to events and seems like a good candidate
    for this job. Adding the `keyup` argument will trigger a handler callback after *any* key
    is pressed while this input is focused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Event modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue makes it easy to listen for *specific* keys by offering *modifiers* to
    the `v-on` directive. Modifiers are postfixes denoted by a dot (`.`), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''d probably guess, the `.enter` modifier tells Vue to only call the
    handler when the event is triggered by the *Enter* key. Modifiers save you from
    having to remember the specific key code, and also make your template logic more
    obvious. Vue offers a variety of other key modifiers, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`esc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, it seems like we could close our modal with this directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: But then what tag do we attach this directive to? Unfortunately, unless an input
    is focused on, key events are dispatched from the `body` element, which, as we
    know, is out of Vue's jurisdiction!
  prefs: []
  type: TYPE_NORMAL
- en: To handle this event we'll, once again, resort to the Web API.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This works, with one caveat (discussed in the next section). But Vue can help
    us make it perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your main script is run and your instance of Vue is set up, it goes through
    a series of initialization steps. As we said earlier, Vue will walk through your
    data objects and make them reactive, as well as compile the template and mount
    to the DOM. Later in the lifecycle, Vue will also go through updating steps, and
    later still, tear-down steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of the lifecycle instance taken from [http://vuejs.org](http://vuejs.org).
    Many of these steps concern concepts that we haven''t yet covered, but you should
    get the gist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f308e86-bbbe-489c-9f93-06abe2675081.png)Figure 2.11\. Vue.js lifecycle
    diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Vue allows you to execute custom logic at these different steps via *lifecycle
    hooks,* which are callbacks defined in the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we utilize the `beforeCreate` and `created` hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Vue will alias data properties to the context object *after* the `beforeCreate` hook
    is called but *before* the `created` hook is called, hence why `this.message` is `undefined` in
    the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'The caveat I mentioned earlier about the *Escape* key listener is this: although
    unlikely, if the *Escape* key was pressed and our callback was called *before* Vue
    has proxied the data properties, `app.modalOpen` would be `undefined` rather than `true` and
    so our `if` statement would not control flow like we expect.'
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this we can set up the listener in the `created` lifecycle hook
    that will be called *after* Vue has proxied the data properties. This gives us
    a guarantee that `modalOpen` will be defined when the callback is run.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vue configuration object also has a section for *methods*. Methods are not
    reactive, so you could define them outside of the Vue configuration without any
    difference in functionality, but the advantage to Vue methods is that they are
    passed the Vue instance as context and therefore have easy access to your other
    properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refactor our `escapeKeyListener` to be a `Vue` instance method.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Proxied properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that our `escapeKeyListener` method can refer to `this.modalOpen`.
    Shouldn't it be `this.methods.modalOpen`?
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Vue instance is constructed, it proxies any data properties, methods,
    and computed properties to the instance object. This means that from within any
    method you can refer to `this.myDataProperty`, `this.myMethod`, and so on, rather
    than `this.data.myDataProperty` or `this.methods.myMethod`, as you might assume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see these proxied properties by printing the Vue object in the browser
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6771753-2628-41d4-809f-4e0f2ab6381e.png)Figure 2.12\. Our app''s
    Vue instance'
  prefs: []
  type: TYPE_NORMAL
- en: Now the simplicity of text interpolations might make more sense, they have the
    context of the Vue instance, and thanks to proxied properties, can be referenced
    like `{{ myDataProperty }}`.
  prefs: []
  type: TYPE_NORMAL
- en: However, while proxying to the root makes syntax terser, a consequence is that
    you can't name your data properties, methods, or computed properties with the
    same name!
  prefs: []
  type: TYPE_NORMAL
- en: Removing listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid any memory leaks, we should also use `removeEventListener` to get rid
    of the listener when the Vue instance is torn down. We can use the `destroy` hook
    and call our `escapeKeyListener` method for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got familiar with the essential features of Vue including
    installation and basic configuration, data binding, text interpolation, directives,
    methods, watchers and lifecycle hooks. We also learned about Vue's inner workings,
    including the reactivity system.
  prefs: []
  type: TYPE_NORMAL
- en: We then used this knowledge to set up a basic Vue project and create page content
    for the Vuebnb prototype with text, lists of information, a header image, and
    UI widgets like the show more button and the modal window.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a brief break from Vue while we set up a backend
    for Vuebnb using Laravel.
  prefs: []
  type: TYPE_NORMAL
