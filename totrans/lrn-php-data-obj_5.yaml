- en: Chapter 5. Handling Rowsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real life dynamic, data-driven web applications are very different from each
    other, as their complexity is dictated by the purposes that they serve. However,
    almost all of them have some common characteristics. One of these characteristics
    is the ability to paginate long result lists for ease of use and faster page loading
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Correct pagination requires the calculation of the number of total rows returned
    from the database, the page size (which is a configurable option), and the number
    of current page. Based on this data, it is easy to calculate the starting offset
    into the result set to display only a subset of rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine:'
  prefs: []
  type: TYPE_NORMAL
- en: How to retrieve the number of rows in the result sets returned by PDO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fetch results starting at a specified row number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the Number of Rows in a Result Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already discussed in [Chapter 2](ch02.html "Chapter 2. Using PHP
    Data Objects: First Steps"), the `PDOStatement::rowCount()` method does not return
    the correct number of rows in a query. (It returns zero for both MySQL and SQLite.)
    The reason for such behavior is that the database management systems do not actually
    know this number until the last row of the query has been returned. The reason
    for the `mysql_num_rows()` function (and similar functions for other databases)
    returns the row count is that it preloads the whole result set into memory when
    you issue the query.'
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem convenient, this behavior is not recommended. If the query
    returns 20 rows, then the script can afford the memory usage. But what if the
    query returns several hundred thousands rows? They will all be kept in memory
    so that, on high traffic sites, the server may run out of resources.
  prefs: []
  type: TYPE_NORMAL
- en: The only logical measure (and the only option available with PDO) is to instruct
    the database to count the number of rows itself. No matter how complicated the
    query is, it can be rewritten to use the SQL `COUNT()` function to return just
    the number of rows that will satisfy the main query.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the queries used in our application. (We will only examine
    the queries that return multiple rows.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In `books.php` we have a query that joins two tables to present the list of
    books along with their authors :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the number of rows that this query returns we should rewrite it to look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need the `ORDER BY` clause here as the order does not really
    matter for the count of rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `authors.php` we simply select all the authors ordered by their last name
    and then their first name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply rewrites to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another query that returns multiple rows is in `author.php`—it retrieves all
    the books written by a particular author:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we rewrote all these queries in a similar way—by replacing
    the list of columns with `COUNT(*)` and trimming the `ORDER BY` clause. With this
    in mind, we can create a function that will accept a string containing the SQL
    to be executed and return the number of rows that the query will return. This
    function will have to perform these simple transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace everything between `SELECT` and `FROM` with `COUNT(*)` in the passed
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove `ORDER BY` and all the text after it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to achieve this transformation is to use regular expressions.
    As in previous chapters, we will use the PCRE extension. We will put the function
    into `common.inc.php` as we will call it from various places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run over the function to see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: It imports the PDO connection object (`$conn`) into the local function scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It trims the possible spaces from the beginning and the end of the SQL query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two calls to `preg_replace()` do the main task of transforming the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note how we use the pattern modifiers—the *s* modifier instructs PCRE to match
    newline characters with the dot, and the *D* modifier forces the $ to match the
    end of the whole string (not just before the first newline). We use these modifiers
    to make sure that the function will work properly with multiline queries.
  prefs: []
  type: TYPE_NORMAL
- en: We will now modify the three scripts to display the number of rows in each table
    that they return. Let's start with `books.php:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the modifications are pretty straightforward—we use the `$sql`
    variable to hold the query and pass it to both the `getRowCount()` function and
    the `$conn->query()` method. We also display a message above the table, which
    tells us how many books there are in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you refresh the `books.php` page, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the Number of Rows in a Result Set](graphics/2660_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The changes to `authors.php` are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `authors.php` now should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the Number of Rows in a Result Set](graphics/2660_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, `author.php` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this. (I scrolled the page down a bit to save space):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the Number of Rows in a Result Set](graphics/2660_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should switch between MySQL and SQLite in `common.inc.php` to make sure
    both databases work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach may work for many cases, but is not suitable for all queries.
    One such example is a query that uses a `GROUP BY` clause. If you rewrite such
    query with the `getRowCount()` function you will get incorrect results as the
    grouping will be applied and the query will return several rows. (The number of
    rows will be equal to the number of distinct values in the column you are grouping
    by.)
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the Number of Rows Returned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, when we know how to count the rows in the results set, let''s see how
    we can fetch first N rows only. Here we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use database-specific features in the SQL query itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can process the result set ourselves and stop after the required number of
    rows has been fetched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Database-Specific SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been working mainly with MySQL, then you will be familiar with
    the `LIMIT x,y` clause. For example, if we want to fetch the first five authors
    sorted by last name, the following query could be issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing could be done with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first query will work for MySQL and SQLite, while the second will work for
    PostgreSQL as well. However, databases like Oracle or MS SQL Server don't use
    such syntax, so these queries will fail for them.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the Top N Rows Only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see, database-specific SQL does not allow us to solve the task of
    performing pagination in the database-independent way. However, we can issue the
    query as we would for all the rows, without the `LIMIT....OFFSET` clause. After
    each row has been fetched, we can increase the counter variable, so that we break
    the loop when we have processed the required amount of rows. The following code
    snippet could serve this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the loop condition—it checks whether the counter variable is less than
    or equal to 5\. (Of course, you can put any number there), as well as it verifies
    that there still are rows to fetch, as it is important that we break the loop
    if there are no more rows. (For example, if the table has only 3 rows and we want
    to show 5 of them we should break after the last row, not after the counter reaches
    5.) Note that using database-specific SQL would take care of such a situation
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing is the call to `PDOStatement::closeCursor()` (as on
    the second last line in the previous code snippet). It is necessary to tell the
    database that we don't want more rows. If we don't do this, the subsequent queries
    issued on the same PDO object will cause exceptions, because database management
    systems cannot process a new query while they are still sending the rows from
    the previous query. This is why we had to call this method in `author.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At present (for PHP version 5.2.1), it may be necessary to unset the statement
    object by assigning it to null (as in `author.php`, line 17). On the other hand,
    at least one CVS snapshot released around April 1, 2007 didn't require closing
    the cursor at all. However, it is still good practice to call `PDOStatement::closeCursor()`
    after you have finished with the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at an Arbitrary Offset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to process a specified number of rows, we can use the
    same technique to skip a certain number of rows. Suppose that we want to show
    authors from 6th to 10th (as though we are showing page 2 when the page size allows
    for 5 authors per page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first loop is used to skip the necessary starting row and the second
    loop displays the requested subset of rows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach may work well for small tables, but its performance is not good.
    You should always use database-specific SQL to return the subset of the resulting
    rows. If you need database independence, you should examine the underlying database
    software and issue a query specific to the database. The reason for this is that
    the database can perform certain optimizations on the query, use less memory so
    that less data will be exchanged between the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, PDO does not provide database-independent ways to effectively
    fetch subsets of the resulting rows as PDO is a connection abstraction, not a
    database abstraction, tool. If you need to write portable code, you should explore
    tools such as MDB2.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach may seem more complicated than using the `PDOStatement::fetchAll()`
    method. Indeed, we could rewrite the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code is much shorter, it has a major drawback: It instructs PDO
    to return all rows from the table and then take a portion of them. With our approach,
    the unnecessary rows are discarded and the loop instructs the database to stop
    sending rows as soon as enough rows have been returned. However, the database
    has to send us the rows preceding the current page in both cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to work with unbuffered queries and to get
    the row count for a result set. We have also looked at an application where database-specific
    SQL could not be avoided, as this would require a workaround that might be unsuitable.
    However, this chapter should be helpful for someone who is developing a complex
    web application that uses databases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the advanced features of PDO, including
    persistent connections and other driver-specific options. We will also discuss
    transactions and examine some more methods of the `PDO` and `PDOStatement` classes.
  prefs: []
  type: TYPE_NORMAL
