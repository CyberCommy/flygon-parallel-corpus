- en: Scanning and Enumeration Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing an overview and the techniques of scanning.
    If we recall from [Chapter 2](209bef8c-2e18-43ca-921c-6e551196d0fe.xhtml), *Understanding
    the Phases of Pentesting Process*, scanning is the second phase of hacking. What
    is scanning? It enables a penetration tester to identify devices that are online/live
    within a network, and identify open and closed services ports, service versions,
    and vulnerabilities; these are just a few of its benefits. Nmap and hping3 are a
    couple of well-known scanning tools.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, penetration testers usually need to extract information to quickly
    identify the attack points on a target system. Information can be network shares,
    routing tables from devices, users and groups, and DNS records. This way of extracting
    information is known as enumeration. A couple of powerful and simple-to-use tools
    for enumeration are nbtstat, nbtscan, enum4linux, and nslookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether a host is up or down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banner grabbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration with NetHunter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SMB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete this chapter, you will need to have Kali NetHunter installed.
    Please see the detailed instructions in [Chapter 1](b476b62d-1c2f-445a-b334-eabdf1f15847.xhtml),
    *Introduction to Kali NetHunter*, for setting up Kali NetHunter on your Android
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to act on the information we've gathered using the tools both native
    to and outside of NetHunter, we typically start with a series of scans. To probe
    the target, we will use a series of tools designed to perform different types
    of scans, each designed to group the information using certain criteria. These
    scans will help us locate valid hosts to target, network structures, running services,
    and vulnerabilities. The scanning process further refines and processes the information
    we have gained from [Chapter 3](1de9f775-4ead-4291-b6d8-914cc2066d24.xhtml), *Intelligence-gathering
    Tools*, to provide you with a better understanding of the target as well as to
    help you pick areas to better carry out the enumeration process (more on that
    in *Enumeration with NetHunter* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning can help us gather the following important information, which will
    prove useful in later in the exploitation process:'
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses of systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open and Closed ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating systems and their version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WHOIS information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting a scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what do we mean by **scanning**? Let''s break down the process. To understand
    it better, refer to the *Port scanning* section. Further into this chapter, we
    will look at the practical aspects of scanning by using the Nmap tool and various
    scanning techniques. The following steps need to perform to conduct a scan:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze a range of IP addresses to locate live systems, that is, the target
    device will either respond to a  ping scan with an ICMP ECHO Replay. If ICMP is
    disabled on a target, using Nmap, we can send probes to detect whether the target
    will respond, Nmap analyzes the responses to help us determine whether a system
    is online. This stage helps us avoid scanning IP addresses that are not online
    and thus not able to be scanned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we conduct port scanning to target a specific IP address and probe it
    to determine which ports are open or closed, which will be used to extract information
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probe the open ports more closely to determine whether a service or application
    is actually running on that port and, if so, what information can be extracted.
    This process is similar to making a phone call to a company and punching in an
    extension, then listening to the voicemail to see whether it gives information
    about the person at that extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a vulnerability scan on open ports to identify weak spots that may
    provide an entry point into the system. Note that this scan finds the weaknesses
    but does not exploit them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be creative with your scans; try new tools and combinations to get different
    results. NetHunter has numerous scanning tools included, as well as being able
    to run many additional ones, many of which can be downloaded and installed for
    free. While many professionals, websites, and books will concentrate on using
    one specific scanner, don't hesitate to try others.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting scanning results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you don't get everything on this list? In most cases, you should be
    able to obtain IP addresses, WHOIS information, and so on quite easily. However,
    if you have find a dearth of substantive or useful information, you may want to
    circle back to the gathering phase to see whether you overlooked anything or you
    need to take a different approach to information gathering. Gathering a high amount
    of information will reap dividends in the scanning phase by making your assessment
    more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether a host is up or down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're going to attempt to enter a system, you first need to have a target
    to examine and explore, which requires finding out which hosts are online or live
    and which are not.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – working with ping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to use the `ping` utility to check for live
    targets:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Command Prompt on Windows or the Terminal in Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ping `-c <number of pings> <target IP or hostname>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `-c` is omitted, the `ping` command will continue to ping the provided
    hostname or address until you press *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you receive success replies from the target, the host is considered to be
    live. If you get a request timeout message, this means one of two things: the
    target is offline or the target has disabled ICMP responses. Systems administrators
    usually disable ICMP replies for security reasons; if a script kiddie is attempting
    a ping scan, they would think the target is offline and move on. However, a skilled
    penetration tester would use another method to determine the true status of the
    target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main methods in using the ping utility: using ping followed by
    a  target IP address, or by a hostname. If you ping a hostname and don''t get
    any responses, there may be a problem with your DNS settings. If the DNS settings
    are accurate, the target made actually be down. Hence, it''s good to ping using
    an IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, let's do one more exercise and take a look at nmap, which is a utility that
    you are about to become very familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore a different way to perform pings with a new tool called nmap.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap (Network Mapper) is like the king of all network scanners. Nmap has may
    functionalities, such as enabling a penetration tester to scan for open ports,
    determine services and their versions, detect the target operating systems and
    versions, and detect network sniffers and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: NetHunter gives us several options to perform a scan, but here we will focus
    on arguably the most powerful and well-known one, called nmap. Nmap has proven
    to be a very popular port-scanning utility across most major operating systems
    due to its flexibility, power, ease of use, and extensibility. Many penetration
    testers, as well as network admins, have come to rely on the software application
    over the years. If you have never used it before, you may find yourself relying
    on it more after our usage of it here in NetHunter.
  prefs: []
  type: TYPE_NORMAL
- en: NetHunter comes preinstalled with nmap, like all of the tools covered in this
    book. I recommend for this section that you open up nmap from either the command
    line or from the NetHunter app.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with nmap from using Kali Linux or using nmap on Microsoft
    Windows, you will find that opening a Terminal allows you to issue the exact same
    commands that you are used to.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Performing a Ping Sweep with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to perform a ping sweep on a local subnet to
    check for any live host devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In NetHunter, open the terminal or access Nmap through the NetHunter app by
    tapping on the three horizontal lines in the upper-right corner of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](img/3cca7e87-eb4b-4380-a670-67c891f485d8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nmap within the NetHunter app
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the following option from the nmap menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](img/5860747d-b8d5-4d70-8f66-946ad1f0cd45.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the Ping Scan option, just tap on it to enable the scan type
  prefs: []
  type: TYPE_NORMAL
- en: Enter an IP address (that is, `192.168.1.1`) or a range of IP addresses (that
    is, `192.168.1.1-130`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tap the **Scan** button, which will open up a Terminal window and show the
    command executing and the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](img/af047518-3374-4fa8-9b20-1839593045a2.png).'
  prefs: []
  type: TYPE_NORMAL
- en: When the scan is completed, the results will be populated on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the scan does not execute, you may have to select an interface for the scan
    to operate on. If this is the case, select the interface (that is, `wlan0`) from
    the interface dropdown, as noted in the nmap window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/2437ab34-6778-4a3b-aea2-cfa7e1888e51.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing the interface dropdown window
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After live systems have been identified, it's time to check for any open ports
    on the target.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a port? First, let's assume that every host on our network has a
    unique address assigned to it, known as an IP address. This address is a unique
    number assigned to a host to differentiate it from other hosts on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we also need to concern ourselves with when information is sent
    from system to system and how a computer knows how to accept that information.
    The answer is ports. I will use the `192.168.1.4` IP address as our target system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how many ports are available on a system? There are 65,535 port numbers.
    Some network services uses TCP ports to ensure their data is delivered to the
    recipient, while other network services use UDP for fast communication but do
    not guarantee a fast delivery like TCP. The port ranges which we use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Well-known ports range from `1` - `1024`. These ports are most commonly used,
    an example would be port `80` for HTTP traffic, all web servers have port `80`
    open by default..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registered ports are from `1025` - `49151`. These ports are allocated and reserved
    for specific vendor and applications uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic ports are from `49152` - `65535`. These ports are used temporarily during
    communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **packet** is a piece of information transmitted during normal network communications.
    A packet is like an envelope with both the sender and receiver's address information,
    and within the packet, just like an envelope, is the message to be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table is an illustration of some of the more common ports, but
    there are many more than are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/18227444-b41e-43d5-a6e5-dc0e4443aaad.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of some common ports
  prefs: []
  type: TYPE_NORMAL
- en: In our earlier discussions, we talked about some specifics of the TCP/IP suite
    that facilitated communication, specifically TCP and UDP. The **Transmission Control
    Protocol** (**TCP**) and the **User Datagram Protocol** (**UDP**) exist within
    the Transport Layer of both the OSI Reference Model and the TCP/IP Protocol Suite.
    The purpose of these protocols is to provide a mechanism for the delivery of the
    data from one device to another.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the three-way handshake happens with the TCP Protocol and not
    with UDP.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the TCP three-way handshake, the following actions take place:'
  prefs: []
  type: TYPE_NORMAL
- en: A sends a **SYN** packet to B to initiate a session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B responds with a **SYN+ACK.** B would respond with an ACK and also send a SYN
    to attempt to establish a connection as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A would respond with an **ACK** to confirm. The following diagram shows the
    TCP three-way handshake:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](img/4191391b-a7ca-4b51-b751-1cb80fb91646.png)'
  prefs: []
  type: TYPE_IMG
- en: TCP three-way handshake
  prefs: []
  type: TYPE_NORMAL
- en: TCP provides sequence numbering for each segment. This ensures the recipient
    device is able to reassemble the pieces of bits received in order and rebuild
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is a bit different from TCP.  UDP sends messages out on the network without
    providing any sort of guarantee of delivery and does not provide any sequence
    numbering. Therefore, messages are sometimes received in an out-of-order fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We need to expand our knowledge on the topic of flags, some of which we have
    encountered. Flags are set within each packet to inform the receiver about the
    characteristics of the packet and how it should be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows various flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| SYN | Used to initiate a session |'
  prefs: []
  type: TYPE_TB
- en: '| ACK | Used to acknowledge a message |'
  prefs: []
  type: TYPE_TB
- en: '| URG | Implies high priority |'
  prefs: []
  type: TYPE_TB
- en: '| PSH | Sends all data immediately |'
  prefs: []
  type: TYPE_TB
- en: '| FIN | Informs a remote device to gracefully end a session |'
  prefs: []
  type: TYPE_TB
- en: '| RST | A reset packet is used to reset a connection. |'
  prefs: []
  type: TYPE_TB
- en: So, let's put our knowledge of flags and ports together to do some port scans.
    As we learned earlier, ports are a way of connecting and transferring information
    to a system such as web traffic. Through port scanning, we are attempting to determine
    which ports are "open" and which are "closed." So what does that mean? Simply
    put, if a service port is open, it can receiving incoming traffic on it; however,
    if a port is closed, it's like a locked door, no traffic is allowed to enter.
  prefs: []
  type: TYPE_NORMAL
- en: You want to learn the pros and cons of each scan. Every scan offers benefits
    as well as drawbacks; it is up to you to know the pros and cons so you can determine
    the best time to use one over the others.
  prefs: []
  type: TYPE_NORMAL
- en: Full Open/TCP connect scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the scans, the full open scan is very easy to visualize and understand,
    as we have kind of already seen it. A full open scan establishes a TCP three-Way
    handshake prior to performing any port scans on the target system, with the goal
    of determining their status if they are open and closed.
  prefs: []
  type: TYPE_NORMAL
- en: This type of scan is able to quickly determine whether a port is open or closed
     because it establishes a TCP three-way handshake with the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the initiate no longer wants to communicate with the target, the initiate
    will send a TCP FIN packet to let the target know it would like to gracefully
    end the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/c52f4a30-128c-40a0-854b-b374dd3fc8e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Close and Open Port responses
  prefs: []
  type: TYPE_NORMAL
- en: If a port is open on a target device, the target responds with an ACK packet.
    If the port is closed, an RST packet is sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a full connect scan, select **Connect ()** from the list in the
    nmap window in the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/fcd3de2b-2e3a-4cad-85d7-a72e89227074.png)'
  prefs: []
  type: TYPE_IMG
- en: The TCP SYN option
  prefs: []
  type: TYPE_NORMAL
- en: Stealth scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **stealth scan** (sometimes known as a half open scan) is much like a full
    open scan with a minor difference that makes it less suspicious on the victim''s
    device. The primary difference is that a full TCP three-way handshake does not
    occur. Looking at the following diagram, the initiator (device A) would send a
    TCP SYN packet to device B for the purpose of determining whether a port is open.
    Device B will respond with a SYN/ACK packet to the initiator (device A) if the
    port is open. Next, device A will send an RST to terminate the connection. If
    the port is closed, device B will sent an RST packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/a91171a2-beef-49f2-b66f-4b5decc40dae.png)'
  prefs: []
  type: TYPE_IMG
- en: Stealth scan showing open and closed service ports
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of using this type of scan is that it reduces the chances of being
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a stealth scan, select (**TCP SYN**) from the list in the nmap window
    in the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/cc020e2e-c68d-4cfc-8222-492408255d21.png)'
  prefs: []
  type: TYPE_IMG
- en: Selection of TCP SYN
  prefs: []
  type: TYPE_NORMAL
- en: XMAS scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scan, the **ACK**, **SYN**, **URG**, **RST**, and **FIN** flags are
    all set at once on the same packet. The issue with this is that since all the
    flags are set, the target system may have difficulties in interpreting the packets
    it has received. The following diagram shows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/32e55a18-9fc6-46b0-b97b-7222aa6a8b1c.png)'
  prefs: []
  type: TYPE_IMG
- en: XMAS tree scan
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute an XMAS scan, select **XMAS** from the list in the nmap window in
    the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/384ea6d6-cf75-45b6-8f3d-618d69760dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: XMAS scan selection from dropdown
  prefs: []
  type: TYPE_NORMAL
- en: FIN scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **FIN scan** is when an attacker sends a packet with only the FIN flag enabled.
    If an attacker sends the FIN packet to the target, it means the attacker is requesting
    the connection be terminate but there was no established connection to close.
    This would confuse the target. If the target does not respond, it means the port
    is open. If the target replies with an RST packet, the port on the target is closed.
    The following figure illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/bcc909ab-e5f1-40cb-ba9d-f9ae980ff82e.png)'
  prefs: []
  type: TYPE_IMG
- en: A FIN scan detecting a closed and open port
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a FIN scan, select **FIN** from the list in the nmap window in the
    NetHunter App and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/018bca46-559e-4748-9114-c429b7cea9b6.png)'
  prefs: []
  type: TYPE_IMG
- en: FIN scan selection from dropdown
  prefs: []
  type: TYPE_NORMAL
- en: NULL scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a null scan, the attacker sends a packet to the target without any flags
    set within it. Once again, the target will be confused and will not respond. This
    will indicate the port is open on the target. However, if the target responds
    with an **RST** packet, this means the port is closed on the device**.** The following
    diagram illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/aab887ef-1d83-4e07-9f17-a69a84c28f21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To execute a NULL scan, select **TCP Null** from the list in the nmap window
    in the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/fe493afe-25fe-4288-a132-1b744e05f814.png)'
  prefs: []
  type: TYPE_IMG
- en: TCP Null scan selection from dropdown
  prefs: []
  type: TYPE_NORMAL
- en: ACK scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting method of scanning is enabling the ACK flag within a packet.
    This technique is used to determine any form of filtering that may be performed
    by a network security device, such as a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: While we haven't talked about firewalls yet, we are going to a little later.
    However, for right now, we will say that firewalls perform filtering of traffic
    from one network to another (for example, the internet to your local intranet
  prefs: []
  type: TYPE_NORMAL
- en: During a penetration test, we may be on the external network of the organization,
    such as the internet. Most organizations deploy a firewall at their perimeter,
    between the internet and their local area network (LAN) to help prevent any threats
    from entering or leaving their network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use an ACK scan to help us determine whether our target organization
    has a firewall in place. To execute an ACK scan, select **ACK** from the list
    in the nmap window in the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/7b546b9f-d0c2-4ca5-bb64-662520fb0b6a.png)'
  prefs: []
  type: TYPE_IMG
- en: ACK scan selection from dropdown
  prefs: []
  type: TYPE_NORMAL
- en: Tuning and tweaking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, what we are doing with nmap so far is only the tip of the iceberg.
    Nmap allows for customization of scans to a very high degree. Let's look at a
    few options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a NULL scan, select **NULL** from the list in the nmap window in
    the NetHunter app and enter the target IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/41b8a9e3-632a-4ff0-be63-5817b0b78d9d.png)'
  prefs: []
  type: TYPE_IMG
- en: The menu and options available within the Nmap app on Kali NetHunter
  prefs: []
  type: TYPE_NORMAL
- en: 'On this line, you can enter the ports you wish to scan in different ways, such
    as a range; we are using the `-p` switch to indicate we are scanning specific
    ports, and then we follow it with ports `21`, `22`, and `45` and the IP address
    of the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to scan a range of ports, for example, ports `1` to `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Want to scan specific ports and detect the OS and services? Nmap would send
    a series of both TCP and UDP datagrams to the target device; each response is
    carefully analyzed. The results would be compared with the Nmap OS database, which
    consists of over 2,600 OS fingerprints. For more information on OS detecting using
    Nmap, please see [https://nmap.org/book/man-os-detection.html](https://nmap.org/book/man-os-detection.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check in the box in the Nmap window as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/01953e9a-6e55-4f82-962f-29ddf7538a49.png)'
  prefs: []
  type: TYPE_IMG
- en: OS-detection option
  prefs: []
  type: TYPE_NORMAL
- en: There are many more switches than what is being shown here, but know that you
    can combine switches to further refine your scans to get better and more efficient
    results.
  prefs: []
  type: TYPE_NORMAL
- en: UDP scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to discuss the concepts of UDP scanning and its
    benefits to a penetration tester. The first thing we need to understand is what
    happens in UDP scanning when an open or closed port is encountered. That answer
    is displayed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Port status** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| Open | No response |'
  prefs: []
  type: TYPE_TB
- en: '| Closed | ICMP Port Unreachable message returned |'
  prefs: []
  type: TYPE_TB
- en: 'Performing a UDP-based scan in Nmap is easy. To do so, we select the UDP scan
    option from the Nmap window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/a774e830-a7ba-4360-beb5-cdebd272435d.png)'
  prefs: []
  type: TYPE_IMG
- en: UDP scan option
  prefs: []
  type: TYPE_NORMAL
- en: These types of scans are worth attempting however as the network admins have
    been known to pay less attention to UDP scans based on their perceived performance
    issues like  not being attractive to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Banner grabbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Banner grabbing is a technique that identifies the services that are running
    on a system. For example, let's say you did a basic port scan on a target and
    you saw port 80 is open, this means there is a web server providing HTTP service.
    However, if we would like to determine/retrieve the web server platform (IIS,
    Apache, or Nginx) and its version number, we would have to perform banner grabbing.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise using Telnet to banner-grab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we re going to use Telnet to determine the type of web server
    on a target system. We''ll be able to see whether it''s IIS, Apache, or Nginx.
    Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the console, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `GET/ http/1.0` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your results may vary on your target, however, the results would be in a similar
    format to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the output, you will notice that, in the line marked server, there
    is information on the type of server, which is Apache/2.0.46 running on UNIX or
    Red Hat/Linux. This information, which may appear to be harmless, is useful for
    targeting an action later on against a web server or OS since we have some information
    on both.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – using nmap to banner-grab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to use NMap tp help us retrieve the banner(s) of a target
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a command console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the console, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that compared to the results with telnet, these results are
    somewhat abbreviated, but they give the basics on those services that are running
    on open ports. If you want more in-depth results, you can vary the command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**More aggressive Service Detection**: `nmap -sV --version-intensity 5 <target
    IP address or hostname>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighter banner-grabbing detection**: `nmap -sV --version-intensity 0 <target
    IP address or hostname>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version Intensity uses values between 0 - 9\. A lower number uses probes that
    tend to be more effective on a wider variety of common services. A higher number
    uses probes that are rarely or sometimes useful. However, using a higher number
    will increase the time it takes to complete a scan, but increases the chances
    of properly identifying a service correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way to use nmap to pull detailed information about services,
    and that is to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This was mentioned earlier as a way to detect the OS and services, but it should
    be mentioned again here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration with NetHunter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have your information collected from scanning, such as open ports and
    information about running services, you can move to enumeration. During this process,
    you can expect to gain a lot more information that can be acted on later. If you
    are lucky and score big, you may find yourself in possession of information such
    as user accounts, the device hostnames, network shares, and services. It is also
    worth noting that you are increasing your visibility and, along with it, your
    possibility of being detected, so you want to tread as lightly as possible and
    be measured in your actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some information that is gathered during the enumeration
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Network shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running services and their banner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With DNS being a core service on just about any network you will encounter,
    it makes sense that it would be on your list of potential targets. DNS is a valuable
    source of information to the pentester because of the information that can be
    discovered there. Remember, DNS is responsible for resolving hostnames to IP addresses,
    and vice versa, in what are termed Forward and Reverse Lookups, respectively.
    The service plays an important part in many of the networks as it eases administration
    as well as makes it  remember a host by name instead of an IP. The service is
    also integral to the proper operation of directory services, such as Microsoft's
    Active Directory product and others. The information regarding hosts and services
    contained within DNS makes it an attractive target for a pentester. Fortunately,
    NetHunter provides a handful of tools to work with the service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a very effective and simple tool, DNSenum, to get the process
    going. **DNSenum** was created to gather information from a targeted domain. The
    information gathered comes in the form of DNS records, which will include information
    such as IP address and hostname. Additionally, the tool can gather host addresses
    for the target as well as attempt zone transfers from the DNS servers servicing
    the domain.
  prefs: []
  type: TYPE_NORMAL
- en: To use the tool, you will need to run it at the terminal window by executing
    the `dnsenum` command, however you will need to choose which switches to use to
    customize the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s run a basic query against the `www.setset.com` domain and
    output the results to a file named `dns.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command completes, we can open the resulting XML file in a text editor
    or an application designed to read XML files. The results returned and written
    to the file will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Host addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mail servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempted and successful zone transfers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the more useful pieces of information pertains to zone transfers. If
    a zone transfer is successful, you can expect a list of records extracted from
    DNS, which will have information regarding hosts, services, and other items that
    are stored within the name servers. However, before you get too excited and attempt
    a zone transfer at your first opportunity, realize that with most modern environments,
    zone-transfer requests from unknown hosts will not be allowed. Why is this? First,
    port `53` TCP must be open and DNS must be present to even successfully make a
    connection to the system. Second, most DNS servers have been configured to reject
    requests for zone transfers to unauthorized parties by default. Even though it
    may not be successful, it is still worth attempting and worth letting DNSenum
    make the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that can perform the same type of function is DNSrecon. This utility
    can perform an additional step that DNSenum does not, which is to retrieve SRV
    or service records as well as some others. An **SRV** is the most interesting
    of the records as it is used by many applications, such as Microsoft's Active
    Directory, as well as services such as instant messaging, telephony applications,
    and voice/video services. Records of this type could allow a pentester to locate
    and identify many useful items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a basic operation with DNSrecon, issue the following at the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SMTP** is a protocol used to transfer messages and is commonly used in both
    mail servers and mail clients. The simplicity and reliability of the protocol
    has led to its widespread adoption and a handful of revisions since it was first
    introduced way back in 1982.'
  prefs: []
  type: TYPE_NORMAL
- en: SMTP, in the context of a messaging system, is used two different ways. In the
    case of mail servers, the protocol is used to transfer messages from one server
    to another until it reaches the server where the recipient's mailbox is located
    where it is  stored for later retrieval. On the mail client side, the protocol
    is used to send messages to a mail server and make use of other protocols for
    retrieving messages from the server.
  prefs: []
  type: TYPE_NORMAL
- en: For pentesters, SMTP can represent a valuable source of information, in particular,
    user names and email addresses. The technique we will use here is designed to
    query an SMTP service and retrieve usernames along with domain names. You may
    not consciously think about it, but you see this information in your email address
    all the time in the form of two parts; the part before the `@` is the username
    and what comes after is the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: This format is standard in environments with usernames that follow a pattern,
    such as first name dot last name or some variation thereof. For example, john.doe
    as the name before the `@` sign.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we extract email address information from SMTP with the tools in
    NetHunter? Well, it all starts with a Mail Exchange, or MX, record that we would
    have obtained from our enumeration of DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the tool you used, the results may be displayed a little differently
    on screen, but what you are looking for is a record (or records, in some cases)
    that is specifically flagged at MX. Once you find these, you are looking for the
    IP address assigned to each. If you have multiple MX servers, you will want to
    see which one has the lowest priority number assigned to it as this will be the
    primary for the domain. If the primary doesn't work, move on to the next highest
    priority for later attempts at enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we typically choose the server with the lowest preference number,
    which is the first record in this case. The MX preference number is used in normal
    operations of SMTP to indicate which server should be used first. The lower the
    number, the higher the priority, thus two records with an MX preference set and
    one is set to the value `1` and the other to `50` will result in the 1 being attempted
    first then the `50`. While we could use one of the others instead, it makes sense
    to use them in the same order they are used by mail-routing services. Once we
    have this, we can move to the second section of the results and focus on the lines.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – using NMAP to enumerate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have an IP address of an MX record, we can start extracting information
    (or attempting to). One way we can do this is by using the nmap tool along with
    its built-in scripting ability. We can do this by entering the following at the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the command closely, you can see  the addition of the `-script`
    switch, which instructs the nmap tool to run an NSE script. The NSE component
    of nmap stands for Nmap Scripting Engine, which allows for the creation of custom
    scripts, the use of preinstalled ones, or the acquisition of ones from a third
    party. In this case, the script chosen is preinstalled and extracts names from
    SMTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution:Many corporations no longer host their email servers and have
    chosen to move them to a third-party provider, such as google or Microsoft. If
    you see MX records that point to a domain name other than the client's, do not
    target these servers. While the tools may work, and give you information, you
    probably don't have permission to penetrate these servers as they are owned by
    a third party. In these cases, the client cannot give you permission to carry
    out a pentest against these assets because they don't own them. Check with the
    hosting provider to assess the security of these assets and how to proceed with
    their permission.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – working with smtp-user-enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second tool we can use is `smtp-user-enum`, which is a Perl script designed
    to determine user names via SMTP, among other tasks. To run `smtp-user-enum`,
    open the Terminal and issue the `smtp-user-enum` command with the desired switches.
    Let's take a look at some examples of the script commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples use the same server address from before with nmap (here
    I noted the address with an `<IP>` tag instead of the full address for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should notice with these commands that we have a series of switches; let''s
    take a look at these three commands that are being user. First, `-U` informs the
    script that you want it to use the list of users contained in the `names.txt`
    file. The next switch is `-t`, which passes information the script as to which
    server it will be targeting. Finally, `-M` tells the utility which mode it is
    running in. Let''s take a close look at these three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VRFY** (default): This mode simply validates the list of usernames by watching
    the responses returned by the SMTP server when valid and invalid usernames are
    returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXPN**: This mode selection takes a username and, if it exists, expands it
    out to show the full name in the form of "username@domain".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RCPT**: When this command is run, it will use the full name (email address)
    of the intended user. If the user exists, the server will respond with code 250,
    otherwise code 550 will be returned. Note that many SMTP servers tend to have
    the VRFY and EXPN commands disabled so RCPT may be the best option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So why use SMTP command to extract and verify information from an SMTP server?
    Simply put, using this method is one of the many ways to extract a list of valid
    usernames from a target running SMTP. Each one of the usernames that is validated
    provides immediate feedback that we have uncovered an active account, which should
    be noted for later actions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SMB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server Message Block (SMB)** is mainly sent to provide network and file sharing
    between computers, servers, and other network devices, such as printers. However,
    SMB is the predecessor of the Common Internet Filesystem (CIFS).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – using enum4linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: enum4linux is a tool that is included with NetHunter that is very useful for
    extracting information from an SMB enabled system. Systems that use SMB are going
    to be primarily Windows, but they can also be Samba-enabled systems, such as Linux
    and UNIX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool offers several important features:'
  prefs: []
  type: TYPE_NORMAL
- en: RID cycling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List group memberships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List network shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting whether a host is in a workgroup or a domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the remote computer's OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have performed a port scan against a target and have found any of the
    following ports open, you may want to try using this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP Port `445`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP ports `137`, `138` & TCP ports `137`, `139` (NetBIOS over TCP/IP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To execute the tool to retrieve a list of users, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/f1c1fd36-b6b5-444a-9a11-e9553791e7ac.png)'
  prefs: []
  type: TYPE_IMG
- en: A list of users returned from enum4linux
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a search for available shares, we can issue the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/526a1bc3-9c7a-4ece-ac96-1ee9b485acca.png)'
  prefs: []
  type: TYPE_IMG
- en: The results of the -S switch in enum4linux
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get more detailed information, you can use the `-d` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, if you want to retrieve all the information in one command, you can
    simply use the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Expect a lot of information to sort through, but fortunately `enum4linux` presents
    it well, leaving you to browse through it looking for useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `enum4linux` presents information about printers, password policy,
    domain or workgroup membership, and lots of other items. What information is presented
    will vary depending on system settings and the environment being targeted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows 2000 and later systems, the results of a scan with this tool will
    vary depending on two items: firewall settings and a registry setting.'
  prefs: []
  type: TYPE_NORMAL
- en: First, if the firewall is enabled or disabled on a Windows system, you will
    get different results . Second, if the system has set the `RestrictAnonymous`
    registry setting to 1 or 2 (it can be set to 0,1, or 2), some information will
    not be available to be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other thing: if the owner of the system simply disables the SMB service
    and NetBIOS, this utility will not work.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – using acccheck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are in a position where you have retrieved user information from running
    `enum4linux`, you can now attempt a basic password crack. A tool that could be
    used at this point is known as `acccheck` and is ideally suited for cracking passwords
    associated with the SMB protocol. While we aren't going to do our more advanced
    password-cracking until later, we can at least attempt a basic one now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I will target a user with the username `user`; I can do this
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, the switches show us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` for verbose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` for the target IP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u` followed by the specified username'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P` for the text file containing a list of passwords to attempt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In NetHunter Linux, password dictionaries are commonly found within the `usr/share/dirb` directory.
    In this case, I used the common.txt file, which is a list of popular passwords
    and variations of those passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Once executed, this command will keep attempting passwords against the "user"
    account on the target system until it runs through all the names in the file or
    it finds a match.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you may be stopped by an "account lockout" setting on the target
    system, which is designed to lock an account after a number of failed attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – using SMBmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's focus on the shares we retrieved with enum4linux. Those shares (if you
    were returned information on shares) can be further examined with smbmap. SMBMap
    allows you to list share drives and permissions, provide upload and download functions,
    and even execute remote commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s take a look at using smbmap to identify permissions on the
    shares. We can do that by using smbmap like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `smbmap -H <IP address>` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will display a list of shares on the target system along with their respective
    permissions. Keep in mind that you are viewing these without a username or password
    for the remote system, so you may not see everything. If we want to use or attempt
    to use a set of credentials to see more, we can do so. Let's do just that by using
    `user` for our username and `user` for our password (from what we received in
    our acccheck attempt).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will use the preceding command with these credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the privileges of the account, you may see a lot more information.
    As you can ascertain the `-u` and `-p` flags are for defining the username and
    password to be used during the execution of the command. Let''s go one step further
    by adding more to this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this last example, the `-r` switch reveals detailed information about each
    share, its location on the disk, and the permissions assigned to it. Again, the
    account you use to execute this command will determine how much information is
    revealed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scanning and the later enumeration of a target is an important step in compromising
    a system. Through this process, you will learn about an environment, what ports
    are open and what possibly can be extracted from the services behind those ports.
    This information will help you plan your next steps better and more accurately
    than you could otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: While scanning will inform you where the live targets are, as well as what ports
    have been left open, enumeration moves you to the next step of attempting to extract
    useful and meaningful information. Using tools such as nmap, nslookup, and smtp-user-enum,
    it is possible to reveal users, groups, and other information about the host and
    the network surrounding it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore gaining access to a target system by finding
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check the following link for more information about the topics covered in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tools.kali.org/](https://tools.kali.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
