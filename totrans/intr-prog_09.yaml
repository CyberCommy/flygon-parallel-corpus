- en: Object-Oriented Design (OOD) Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to get back to a high-level view of programming
    and Java programming in particular. We will show the role of design in the process
    of a software system, starting with the earliest feasibility phase, going through
    high-level design, detailed design, and ending with the coding and testing. We
    will discuss the criteria for a good design and provide a guide to the well-proven
    OOD principles. The discussion will be illustrated by code examples that demonstrate
    the application of the main OOD principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of design?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating and programming to an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling as much as you can
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferring aggregation over inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So many OOD principles and so little time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Closed Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of design?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any project requires planning and a vision of what is going to be built. It
    is especially important when several members of the same team have to coordinate
    their activity. But even if you work alone, you have to make some kind of plan,
    whether it is a design document or just the code you are writing without capturing
    your ideas in any other form. And that is the purpose of design—to envision the
    future system clearly enough to be able to start building it.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, the design evolves, changes, and becomes more detailed. Each
    step of a project life cycle requires something different. And that is what we
    are going to discuss now—how the purpose of design evolves as the project progresses
    from the first idea to the complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The project steps described here look sequential, but in fact, they are executed
    with significant overlap. Even more, the agile methodology of software development
    encourages moving each feature through all the project steps without waiting until
    all the features of the future product are discovered.
  prefs: []
  type: TYPE_NORMAL
- en: The deliverable, in agile methodology, is not the requirements, design, or any
    other document, but a functional code deployed to production and producing value
    (also called a **minimum viable product** (**MVP**)). It has to be accomplished
    every iteration—in a span of one or two weeks. Then, the feedback loop based on
    real customer experience allows continuous adjusting of the original vision and
    drives all the effort to the most valuable solution in the shortest period of
    time and with a minimal waste of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Many, if not the majority, of modern successful products have been brought to
    the market this way. Their authors often confess that only a handful of original
    ideas have been implemented, if any. Life is a great joker, isn't it? It favors
    those who adapt to a change quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's walk through the project life cycle and see how the system design
    evolves along with it.
  prefs: []
  type: TYPE_NORMAL
- en: The project's feasibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decision that a certain project is worth financing has to be made very early.
    Otherwise, it might not start at all. This means that the decision maker has to
    be supplied with enough information to provide a level of confidence that the
    risk is reasonable and worth taking. This information includes high-level requirements,
    a high-level design, and even prototyping or some other proof that the available
    technologies can be used for the successful implementation. Based on this data
    and market research, the project advocates estimate the level of effort, expenses,
    potential income, and future profit—the mother of all goals.
  prefs: []
  type: TYPE_NORMAL
- en: Even before the project gets a green light, the most critical for the success
    of the product features are identified, presented in a form that can be communicated
    to the future customers, and discussed or even tested with them. If the team includes
    people who did something similar in the past, it definitely helps to shortcut
    the decision making.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this phase is to present the future system in a form that could
    be understood by all participants and potential customers.
  prefs: []
  type: TYPE_NORMAL
- en: Requirement gathering and prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as the project is approved and budgeted, the requirement gathering goes
    ahead full-speed along with the prototype implementation. In fact, the prototype
    is often used as a tool for requirements-gathering. It helps to discuss specific
    critical details and avoid misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: In this project stage, the high-level design progresses, along with the discovery
    of more details about the sources of the input information, the processes necessary
    to consume it (and produce the necessary results), the technologies that can be
    used to do it, and how the customers may interact with the system.
  prefs: []
  type: TYPE_NORMAL
- en: With more data about the future system, how it might work and be implemented,
    it is possible to identify obstacles that can impede the progress or make the
    whole project impossible. So, the decision makers continue to closely watch the
    results and critically evaluate them.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of design at this stage is bringing all the incoming data together
    into a cohesive dynamic picture of the future functioning system. Of the four
    pillars of OOP, encapsulation and interface are at the forefront of high-level
    design. The implementation details should be spot-checked in the critical areas
    and proved to be possible with the selected technologies. But they stay hidden—encapsulated—behind
    the interface, the latter being focused on the system's interaction with the customers
    and on the discovery of new functional and non-functional requirements for the
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: High-level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most apparent feature of the high-level design is its focus on the system
    structure on the level of the subsystems and the interfaces between them. If the
    product has to interact with external systems, the interface and protocol of such
    interactions are part of the high-level design, too. The architecture is identified
    and validated as being able to support the design, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a typical mid-size software system, the high-level design can
    be expressed in the list of packages and their public interfaces. If the system
    has a graphic user interface, its prototype and wireframes are usually enough.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detailed design comes into play as soon as the use cases to be implemented are
    first identified. The business representatives set priorities for the new product
    features. The programmers identify and adjust the interfaces to support the first
    features and start creating classes to implement the first use cases that are
    going to be delivered in the first iterations.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the implementation may have hardcode (dummy) data in some places.
    So, the use cases might have a limited range of applications.  Still, such an
    implementation is valuable as it allows executing all the required processes,
    so the customers in production can test the feature and get a feeling of what
    to expect. The programmers also create unit tests for each of the implemented
    methods, even for the dummy ones. At the same time, the use cases are captured
    in the integration tests that execute scenarios across classes and subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the first iteration, the high-priority use cases are implemented
    and fully tested using the automated tests. The first iteration usually is very
    busy. But programmers are motivated not to repeat their mistakes this time and
    typically work with a lot of enthusiasm and higher-than-usual productivity.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of detailed design is to provide a template for coding. Once the
    template is established, all the future classes will be mostly cut-and-paste from
    the existing ones. That is why the first classes are usually implemented by the
    senior programmers or under their close supervision. While doing that, they try
    to keep the encapsulation as closed as possible, for having minimal and intuitive
    interfaces, and for taking advantage of inheritance and polymorphism where possible.
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention is a big part of the first iterations too. It has to reflect
    the domain terminology and be well understood by all the team members. Thus, the
    purpose of the design on this stage is to create a pattern for the coding and
    vocabulary for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, coding has been going since high-level design and possibly even
    earlier. As the detailed design produces the first results, coding gets more steam.
    New members can be added to the team, and some of them can be juniors. Adding
    people to the team is the favorite managerial activity, but it has to be done
    in a controlled manner so that every new member can be instructed and learn project
    vocabulary well enough to understand all the business discussions around new product
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The design activity on this stage is focused on the details of the implementation
    and its tests. The pattern created during detailed design has to be applied and
    adjusted as needed. The purpose of the design during coding is to verify all the
    design decisions made so far and to produce specific solutions expressed as the
    lines of code. Refactoring is one of the main activities during this phase and
    several first iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the time the coding is finished, the tests are also written and are run many
    times. They are usually executed every time a new chunk of changes are committed
    to a source code repository. Some companies are practicing a continuous integration
    model when the change, once committed to the source repository, triggers the automated
    regression and integration testing with subsequent deployment to production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, there are many development teams that still have dedicated test specialists
    who—after the code is deployed into a test environment—are testing it manually
    and using some specialized tools.
  prefs: []
  type: TYPE_NORMAL
- en: The design effort in this phase is focused on test coverage, test automation,
    and integration with other systems, automated or not. Deployment and limited testing
    (called **smoke testing**) in a production environment is also part of the design
    effort of this phase.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of design during testing is to make sure that all the delivered
    use cases are covered with tests, including negative and non-functional testing.
    Monitoring and reporting on the system performance are important activities of
    this phase, too.
  prefs: []
  type: TYPE_NORMAL
- en: A roadmap to a good design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed the design evolution in previous section, we have already hinted
    at the criteria that ensure design quality:'
  prefs: []
  type: TYPE_NORMAL
- en: It has to be flexible enough to adapt to the incoming changes (they are as inevitable
    as taxes, so you'd better be ready)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to clearly communicate the project structure and specialization of each
    part
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to use well-defined domain terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to allow testing parts in isolation and integrated together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to be presented in a form that allows us to discuss it with the future
    customers and, ideally, is tested by them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to take full advantage of the four OOP concepts—encapsulation, interface,
    inheritance, and polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are general criteria for any project and any OOP language. But in this
    book, we introduce Java best practices, so we need to mainly discuss the detailed
    design, coding, and testing in Java – all related to the last of these criteria.
    That is what we are going to do now.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating and coding to an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have mentioned encapsulation and interface many times and in different contexts.
    It was neither accidental nor intentional. It was unavoidable. Encapsulation and
    interface were born out of necessity to keep the implementation hidden as much
    as possible. It addresses two problems that plagued early programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Unregulated shared access to the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficulties in changing the code when the relations between parts are not well
    structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP is a successful solution. It ensures controlled access to the data (object
    state) and flexibility (freedom to change) the implementation as needed as long
    as the interface is not changed. In addition, it helps to organize the design
    and development of software. After the interfaces are defined, everybody can work
    on the implementation independently. There is no need to spend time on meetings
    and discussions if the interfaces do not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have demonstrated in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, making an object''s state private
    also addressed the difference in accessibility between instance fields and instance
    methods when inheritance is involved. A child cannot override non-private fields
    of the parent but only hide them. Only methods can be overridden. To demonstrate
    the difference, let''s create the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Grandad {
  prefs: []
  type: TYPE_NORMAL
- en: public String name = "Grandad";
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent extends Grandad {
  prefs: []
  type: TYPE_NORMAL
- en: public String name = "Parent";
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent {
  prefs: []
  type: TYPE_NORMAL
- en: public String name = "Child";
  prefs: []
  type: TYPE_NORMAL
- en: public String getName() { return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each has a public field with the same name and method with the same signature.
    Now, without looking down the page, try to guess what will be the output of the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Grandad grandad = new Child();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(grandad.name);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(grandad.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ff835e5-929c-4271-b026-757e044dd29e.png)'
  prefs: []
  type: TYPE_IMG
- en: This difference often creates confusion and can cause difficult-to-debug errors.
    To avoid them, we recommend never allowing access to the object state (fields)
    directly, only via methods (getters and setters at the very least). That is another
    reason to always keep the state encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: We will now create a small software modeling system that illustrates the application
    of the design steps we are discussing. Let's assume that we were tasked with creating
    a model of traffic that allows calculating the speed of every vehicle based on
    a typical mix of cars and trucks in a certain city where the model is going to
    be tested first. The value returned by the model should be the speed (miles per
    hour) the vehicle reaches after a certain number of seconds. The results will be
    used for assessing the traffic density on a multi-lane road a few seconds after
    the traffic light turns green. It will be part of the decision-making during the
    introduction of new traffic regulations related to the minimum number of passengers
    (for cars) and the maximum weight of the payload (for trucks).
  prefs: []
  type: TYPE_NORMAL
- en: We definitely simplify possible real-life requirements in order to make the
    code easier to read. In a real system, such calculations would require more input
    data and a much more complicated algorithm based on the machine learning modeling.
    But even the simple system we develop will have all the design aspects that the
    real-life system has.
  prefs: []
  type: TYPE_NORMAL
- en: 'After discussing the requirements, the high-level design has identified the
    API. It has to accept three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of seconds after all the vehicles began moving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The vehicle load: number of passengers for cars and the payload for trucks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last parameter should be optional. It can be one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeled based on the current traffic statistics in the targeted city
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set to a specific value for the purpose of the evaluation of the effect of the
    new traffic regulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the detailed design of the modeling system API located in
    the `com.packt.javapath.ch08demo.traffic` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: double getSpeedMph(double timeSec);
  prefs: []
  type: TYPE_NORMAL
- en: static List<Vehicle> getTraffic(int vehiclesCount){
  prefs: []
  type: TYPE_NORMAL
- en: return TrafficFactory.get(vehiclesCount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Car extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: void setPassengersCount(int passengersCount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Truck extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: void setPayloadPounds(int payloadPounds);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we only expose the interface to the client and hide the implementation
    (more about this in the next section). It allows us the freedom of implementing
    the interfaces whichever way we think is best as long as it fulfills the contract.
    And if we change the implementation later, the clients are not required to change
    their code. That is an example of encapsulation and decoupling the interface from
    the implementation. As we discussed in the previous chapter, it also facilitates
    code maintainability, testability, and reusability. More about the latter in the *Preferring
    aggregation over inheritance* section, although we should point out that inheritance
    facilitates code reuse too and we will see proof of it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: By extending the `Car` and `Truck` interfaces from the `Vehicle` interface, we
    have hinted already that we are going to use polymorphism, and that is what we
    are going to discuss in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Car` and `Truck` interfaces are extending (children of) the `Vehicle`
    interface. It means that the class that implements the `Car` interface (let''s
    give such a class the name `CarImpl`), for example, when instantiated, creates
    an object that has three types – `Vehicle`, `Car`, and `CarImpl`. These types
    are similar to passports of a person who is a citizen of three countries. Each
    citizenship carries specific rights and restrictions, and a person chooses how
    to present themselves in different situations of international travel, the same
    way an object of the `CarImpl` class can be *cast* to any of these types, provided
    the type is accessible in the code that does the casting. And here is what we
    mean by type accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: We have already declared the `Car`, `Truck`, and `Vehicle` interfaces as public,
    which means that any code of any package can access these types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't want client code able to access the implementations of these interfaces,
    so we create the `com.packt.javapath.ch08demo.traffic.impl` package and put all
    the implementations there without specifying an access modifier (thus using the
    default access that makes them visible only to other members of the same package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the implementations of the traffic interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class VehicleImpl implements Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return 42;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class TruckImpl implements Truck {
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds){
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class CarImpl implements Car {
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount){
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We have created these classes in the `com.packt.javapath.ch08demo.traffic.impl`
    package with some dummy data—just to make them compile. But the `CarImpl` and
    `TruckImpl` classes still generate a compilation error because there is the `getSpeedMph()`
    method listed in the `Vehicle` interface which is not implemented in these two
    classes. The `Car` and `Truck` interfaces extend the `Vehicle` interface and,
    thus, inherit its abstract `getSpeedMph()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we need to either implement the `getSpeedMph()` method in each of these
    two classes or make each of them a child of the `VehicleImpl` class, where this
    method is implemented already. We have decided that the speed will probably be
    calculated the same way for a car and for a truck, so extending the `VehicleImpl` class
    is the way to go. If later we discover that the `CarImpl` or `TruckImpl` class
    needs a different implementation, we can override the one in the parent class.
    Here is the new version of the same two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return 42;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class TruckImpl extends VehicleImpl implements Truck {
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds){
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class CarImpl extends VehicleImpl implements Car {
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount){
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice, please, that we have also made the `VehicleImpl` class abstract, which
    makes it impossible to create an object of the `VehicleImpl` class. Only objects
    of its children can be created. We did this because we use it as a base class
    that contains some common functionality, but we are never going to need the generic
    `Vehicle` object, only a specific one—either `Car` or `Truck`.
  prefs: []
  type: TYPE_NORMAL
- en: We have followed the recommendation of keeping everything as encapsulated as
    possible. The restricted access can be changed to be more accessible later. And
    it is easier to do than to restrict access after some client code is written already
    that relies on the existing level of less-restricted access.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to the `CarImpl` and `TruckImpl`  traffic interfaces implementation.
    They are inaccessible from outside the package, but that is not a problem because
    the API we have defined does not require it. If the `TrafficFactory` class can
    access them, that it would be enough. That is why we create the `TrafficFactor`
    class in the `com.packt.javapath.ch08demo.traffic.impl` package, where it can
    access both implementations as a member of the same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath.ch08demo.traffic.impl;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch08demo.traffic.Vehicle;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.ArrayList;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.List;
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It does not do much, but it is good enough for the design phase, to make sure
    that all the classes are in place and have appropriate access before we start
    coding. We will talk more about the `List<Vehicle>` construct in [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java C**ollections*. For now, it would be enough to assume it represents a list
    of objects that implement the `Vehicle` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the following client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double timeSec = 5;
  prefs: []
  type: TYPE_NORMAL
- en: int vehiclesCount = 4;
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> traffic = Vehicle.getTraffic(vehiclesCount);
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Vehicle vehicle: traffic){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Loaded: " + vehicle.getSpeedMph(timeSec));'
  prefs: []
  type: TYPE_NORMAL
- en: if(vehicle instanceof Car){
  prefs: []
  type: TYPE_NORMAL
- en: ((Car) vehicle).setPassengersCount(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Car(no load): " + vehicle.getSpeedMph(timeSec));'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: ((Truck) vehicle).setPayloadPounds(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Truck(no load): " + vehicle.getSpeedMph(timeSec));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code retrieves any number of vehicles (four, in this case) from `TrafficFactory`.
    The factory hides (encapsulates) the details of the implementation of traffic
    modeling. Then, the code iterates over the list in a for-loop (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*) and prints out the speed of each vehicle calculated at the point
    five seconds after the vehicle has started to move.
  prefs: []
  type: TYPE_NORMAL
- en: The code then demonstrates that the client can change the load the vehicle carries,
    as was required. For cars, we set the number of passengers to zero, and for trucks,
    we set their payloads to zero.
  prefs: []
  type: TYPE_NORMAL
- en: We execute this code and get no results because the traffic factory returns
    an empty list. But the code compiles and runs, and we can start implementing the
    interfaces. We can give the assignments to different team members and we do not
     have to worry about coordinating the effort between them as long as they do not
    change the interface.
  prefs: []
  type: TYPE_NORMAL
- en: After making sure the interface, inheritance, and polymorphism are used to their
    full (as far as we could do it) capacity, we can turn our attention to the coding
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling as much as you can
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have chosen inheritance for code sharing across different implementations.
    The result looks as follows. Here is the `VehicleImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: private int weightPounds, horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: public VehicleImpl(int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: this.weightPounds = weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: this.horsePower = horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){ return this.weightPounds; }
  prefs: []
  type: TYPE_NORMAL
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  prefs: []
  type: TYPE_NORMAL
- en: double v = 2.0 * this.horsePower * 746 * timeSec *
  prefs: []
  type: TYPE_NORMAL
- en: 32.174 / weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(Math.sqrt(v) * 0.68);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that some methods have `protected` access, meaning only members of the
    same package and class children can access them. That is done for better encapsulation,
    too. Our code clients do not need access to these methods, only children do. And
    here is one of  them:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class CarImpl extends VehicleImpl implements Car {
  prefs: []
  type: TYPE_NORMAL
- en: private int passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(int passengersCount, int weightPounds, int horsePower){
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds , horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount) {
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.passengersCount * 200 + super.getWeightPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `this` and `super` keywords in the preceding code allow us to distinguish
    which method has to be called – the one in the current child object or the one
    in the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two aspects of the preceding implementation are worth noticing:'
  prefs: []
  type: TYPE_NORMAL
- en: The access modifier of the `getWeightPounds()` method is set to `protected`.
    That is because the method with the same signature and `protected` access modifier
    is declared in the parent, class too. But the overriding method cannot have more
    restrictive access than the overridden one. Alternatively, to tighten the encapsulation,
    we could change the method name in `CarImpl` to `getCarWeightPounds()`, for example,
    and make it private. Then, there would be no need to use the `this` and `super` keywords.
    But classes of another package cannot access the `protected` method anyway, so
    we have decided to keep the `getWeightPounds()` name and use the `this` and `super` keywords,
    admitting that it is just a matter of style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access to the constructor can be made default (package-level), too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TruckImpl` class looks similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class TruckImpl extends VehicleImpl implements Truck {
  prefs: []
  type: TYPE_NORMAL
- en: private int payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: TruckImpl(int payloadPounds, int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds, horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds) {
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.payloadPounds + super.getWeightPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the `TrafficFactory` class can access these classes and their constructors
    to create objects as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < vehiclesCount; i++){
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle vehicle;
  prefs: []
  type: TYPE_NORMAL
- en: if (Math.random() <= 0.5) {
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new CarImpl(2, 2000, 150);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new TruckImpl(500, 3000, 300);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(vehicle);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `random()` static method of the `Math` class generates a random decimal
    number between 0 and 1\. We use it to make the resulting mix of traffic look somewhat
    real. And we have hardcoded, for now, the values we pass into each of the vehicles'
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the following code (we discussed it already a few pages ago):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficApp {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args){
  prefs: []
  type: TYPE_NORMAL
- en: double timeSec = 5;
  prefs: []
  type: TYPE_NORMAL
- en: int vehiclesCount = 4;
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> traffic = Vehicle.getTraffic(vehiclesCount);
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Vehicle vehicle: traffic){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Loaded: " + vehicle.getSpeedMph(timeSec));'
  prefs: []
  type: TYPE_NORMAL
- en: if(vehicle instanceof Car){
  prefs: []
  type: TYPE_NORMAL
- en: ((Car) vehicle).setPassengersCount(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Car(no load): " +'
  prefs: []
  type: TYPE_NORMAL
- en: vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: ((Truck) vehicle).setPayloadPounds(0);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Truck(no load): " +'
  prefs: []
  type: TYPE_NORMAL
- en: vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ff20e22-6228-435a-9211-4fcd408691b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The calculated speed is the same because the input data is hardcoded in `TrafficFactory`.
    But before we move on and make the input data different, let''s create a speed
    calculation test:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath.ch08demo.traffic.impl;
  prefs: []
  type: TYPE_NORMAL
- en: class SpeedCalculationTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void speedCalculation() {
  prefs: []
  type: TYPE_NORMAL
- en: double timeSec = 5;
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle vehicle = new CarImpl(2, 2000, 150);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(83.0, vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: ((Car) vehicle).setPassengersCount(0);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(91.0, vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new TruckImpl(500, 3000, 300);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(98.0, vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: ((Truck) vehicle).setPayloadPounds(0);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(105.0, vehicle.getSpeedMph(timeSec));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We could access the `CarImpl` and `TruckImpl` classes because the test belongs
    to the same package, although it's located in a different directory of our project
    (under the `test` directory, instead of `main`). On the classpath, they are placed
    according to their package, even if the source comes from another source tree.
  prefs: []
  type: TYPE_NORMAL
- en: We have tested our code and now we can concentrate on processing real data and
    creating the corresponding objects for the client in `TrafficFactory`. The implementation
    is decoupled from the interface and, until it is ready, we can keep it hardcoded,
    so the client can start writing and testing their code without waiting until our
    system is fully functional. That is another advantage of encapsulation and interface.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring aggregation over inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who worked on real-life projects know that the requirements can change
    at any moment. In the case of our project, even before the second iteration was
    completed, new methods had to be added to the `Car` and `Truck` interfaces, while
    speed calculation grew in its own project. The programmers who worked on the implementation
    of the interfaces and those working on the speed calculation started to change
    the `CarImpl`, `TruckImpl`, and `VehicleImpl` files.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but another project decided to use our speed calculation functionality,
    but they wanted to apply it to other objects, not cars and trucks. That is when
    we realized that we need to change our implementation in favor of aggregating
    the functionality instead of inheriting it, which is one of the recommended design
    strategies in general anyway, because it increases decoupling and facilitates
    more flexible design. Here is what it means.
  prefs: []
  type: TYPE_NORMAL
- en: 'We copy the `getSpeedMph()` method of the `VehicleImpl` class and put it in
    the `SpeedModelImpl` class in a new `com.packt.javapath.ch08demo.speedmodel.impl`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SpeedModelImpl implements SpeedModel {
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec, int weightPounds,
  prefs: []
  type: TYPE_NORMAL
- en: int horsePower){
  prefs: []
  type: TYPE_NORMAL
- en: double v = 2.0 * horsePower * 746 * timeSec * 32.174 / weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(Math.sqrt(v) * 0.68);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add `SpeedModelFactory` to the same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SpeedModelFactory {
  prefs: []
  type: TYPE_NORMAL
- en: public static SpeedModel speedModel(){
  prefs: []
  type: TYPE_NORMAL
- en: return new SpeedModelImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we create a `SpeedModel` interface in the `com.packt.javapath.ch08demo.speedmodel`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface SpeedModel {
  prefs: []
  type: TYPE_NORMAL
- en: double getSpeedMph(double timeSec, int weightPounds, int horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: static SpeedModel getInstance(Month month, int dayOfMonth, int hour){
  prefs: []
  type: TYPE_NORMAL
- en: return SpeedModelFactory.speedModel(month, dayOfMonth, hour);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we change the `VehicleImpl` class by adding a setter for the `SpeedModel`
    object and by using this object in the speed calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: private int weightPounds, horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: private SpeedModel speedModel;
  prefs: []
  type: TYPE_NORMAL
- en: public VehicleImpl(int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: this.weightPounds = weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: this.horsePower = horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){ return this.weightPounds; }
  prefs: []
  type: TYPE_NORMAL
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  prefs: []
  type: TYPE_NORMAL
- en: if(this.speedModel == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Speed model is required");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: return speedModel.getSpeedMph(timeSec, weightPounds, horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setSpeedModel(SpeedModel speedModel) {
  prefs: []
  type: TYPE_NORMAL
- en: this.speedModel = speedModel;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `getSpeedMph()` method now throws an exception (and stops
    working) if it is called before the `SpeedModel` object is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also change `TrafficFactory` and let it set `SpeedModel` on the traffic
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  prefs: []
  type: TYPE_NORMAL
- en: SpeedModel speedModel = SpeedModelFactory.speedModel();
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < vehiclesCount; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle vehicle;
  prefs: []
  type: TYPE_NORMAL
- en: if (Math.random() <= 0.5) {
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new CarImpl(2, 2000, 150);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new TruckImpl(500, 3000, 300);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ((VehicleImpl)vehicle).setSpeedModel(speedModel);
  prefs: []
  type: TYPE_NORMAL
- en: list.add(vehicle);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the speed model continues to be developed independently of the traffic
    model, and we accomplished all that without changing the client's code (such an
    internal code change that does not affect an interface is called **refactoring**).
    That is the benefit of decoupling based on encapsulation and interface. The behavior
    of the `Vehicle` object is now aggregated, which allow us to change its behavior
    without modifying its code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the title of this section is *Preferring aggregation over inheritance*,
    it does not mean that inheritance should always be avoided. Inheritance has its
    own uses and is especially beneficial for polymorphic behavior. But when we talk
    about design flexibility and code reusability, it has two weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Java classes do not allow us to extend more than one parent, so, if the class
    is already a child, it cannot extend another class in order to reuse its method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance requires a parent-child relationship between classes, while the
    same functionality is often shared by the unrelated classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, inheritance is the only way to solve the problem at hand and sometimes
    using it causes problems later. The reality is that we can never reliably predict
    what the future holds, so do not feel bad if the decision to use inheritance or
    not turns out to be wrong later.
  prefs: []
  type: TYPE_NORMAL
- en: So many OOD principles and so little time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you search for OOD principles on the internet, you can easily find many lists
    that include dozens of recommended design principles. And all of them make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are the five most popular OOD principles often bundled together
    under the abbreviation SOLID (composed from the first letters of the principles''
    titles):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle**: A class should have only one responsibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Closed Principle**: A class should encapsulate its functionality (be
    closed) but be able to be extended'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle**: An object should be replaceable (substituted)
    by its child and still not break the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle**: Many client-oriented interfaces are better
    than one general-purpose interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle**: Code should depend on the interface, not
    implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, as we have said before, there are many other good ideas about how to achieve
    better design. Should you study all of them? The answer very much depends on the
    way you prefer to learn new skills. Some people do it by experimenting, others
    by learning from other people's experience, and the majority learns from a combination
    of these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the design criteria, OOP concepts, and the roadmap for
    a good design that we have discussed in this chapter are able to lead you to a
    solid OOP solution in most of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: But if you decide to read more about OOD and see how other people have solved
    software design problems, do not hesitate to check them out. After all, that was
    how humanity got out of the caves and boarded a spacecraft – by passing their
    experience on to the next generation.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many OOD patterns that have shared software-design solutions of specific coding
    problems. OOD patterns are also often used by programmers as the way to talk about
    different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are traditionally grouped into four categories: creational, behavioral,
    structural, and concurrency patterns. Read about them and:'
  prefs: []
  type: TYPE_NORMAL
- en: Name one pattern in each category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three patterns we have used already
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four patterns—one from each of the four categories—could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: Factory method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: Composite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: Visitor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency patterns**: Messaging pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we have already used the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy initialization**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, we initialized the `SingletonClassExample
    OBJECT` static field, not automatically, but only when the `getInstance()` method
    was called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, see the `SingletonClassExample` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, when we created a `Calculator` interface that
    captures all possible interactions with the implemented functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revisited a high-level view of programming and Java programming
    in particular. We discussed design evolution in the process of software system
    development, starting with the earliest feasibility phase, going through high-level
    design, detailed design, and ending with coding and testing.  We discussed the
    criteria for a good design, OOP concepts, the main OOD principles, and provided
    a roadmap to a good OOP design. The discussion was illustrated by code examples
    that demonstrated the application of all the OOD principles discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will dive deeper into three core elements of Java programming:
    operators, expressions, and statements. We will define and discuss all Java operators,
    explore the most popular ones in more detail, and demonstrate them in specific
    examples, along with expressions and statements as well.'
  prefs: []
  type: TYPE_NORMAL
