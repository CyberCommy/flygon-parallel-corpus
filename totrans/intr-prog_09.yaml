- en: Object-Oriented Design (OOD) Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计（OOD）原则
- en: In this chapter, we are going to get back to a high-level view of programming
    and Java programming in particular. We will show the role of design in the process
    of a software system, starting with the earliest feasibility phase, going through
    high-level design, detailed design, and ending with the coding and testing. We
    will discuss the criteria for a good design and provide a guide to the well-proven
    OOD principles. The discussion will be illustrated by code examples that demonstrate
    the application of the main OOD principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到对编程和特别是Java编程的高层视图。我们将展示设计在软件系统过程中的作用，从最早的可行性阶段开始，经过高层设计、详细设计，最终到编码和测试。我们将讨论良好设计的标准，并提供一份经过验证的OOD原则指南。讨论将通过代码示例加以说明，演示主要OOD原则的应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is the purpose of design?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计的目的是什么？
- en: Encapsulating and programming to an interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装和编程到接口
- en: Taking advantage of polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用多态性
- en: Decoupling as much as you can
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能解耦
- en: Preferring aggregation over inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用聚合而不是继承
- en: So many OOD principles and so little time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这么多OOD原则，时间却如此有限
- en: Single Responsibility Principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open Closed Principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov Substitution Principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则
- en: Interface Segregation Principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency Inversion Principle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: Exercise – Design patterns
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习 - 设计模式
- en: What is the purpose of design?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计的目的是什么？
- en: Any project requires planning and a vision of what is going to be built. It
    is especially important when several members of the same team have to coordinate
    their activity. But even if you work alone, you have to make some kind of plan,
    whether it is a design document or just the code you are writing without capturing
    your ideas in any other form. And that is the purpose of design—to envision the
    future system clearly enough to be able to start building it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目都需要规划和对将要构建的东西的愿景。当同一个团队的几个成员必须协调他们的活动时，这尤为重要。但即使你是一个人工作，你也必须制定某种计划，无论是设计文档还是只是编写代码而没有以其他形式记录你的想法。这就是设计的目的——清晰地设想未来的系统，以便能够开始构建它。
- en: In the process, the design evolves, changes, and becomes more detailed. Each
    step of a project life cycle requires something different. And that is what we
    are going to discuss now—how the purpose of design evolves as the project progresses
    from the first idea to the complete implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，设计会不断演变、改变并变得更加详细。项目生命周期的每个阶段都需要不同的东西。这就是我们现在要讨论的——随着项目从最初的想法到完整实施的进展，设计的目的如何演变。
- en: The project steps described here look sequential, but in fact, they are executed
    with significant overlap. Even more, the agile methodology of software development
    encourages moving each feature through all the project steps without waiting until
    all the features of the future product are discovered.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的项目步骤看起来是顺序的，但实际上它们是有重叠的。更重要的是，软件开发的敏捷方法鼓励将每个功能移动到所有项目步骤中，而不是等到发现未来产品的所有功能。
- en: The deliverable, in agile methodology, is not the requirements, design, or any
    other document, but a functional code deployed to production and producing value
    (also called a **minimum viable product** (**MVP**)). It has to be accomplished
    every iteration—in a span of one or two weeks. Then, the feedback loop based on
    real customer experience allows continuous adjusting of the original vision and
    drives all the effort to the most valuable solution in the shortest period of
    time and with a minimal waste of resources.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷方法论中，交付物不是需求、设计或任何其他文档，而是部署到生产环境并产生价值的功能代码（也称为最小可行产品（MVP））。每次迭代都必须在一两周内完成。然后，基于真实客户体验的反馈循环允许不断调整最初的愿景，并驱动所有努力以在最短时间内实现最有价值的解决方案，并最小化资源浪费。
- en: Many, if not the majority, of modern successful products have been brought to
    the market this way. Their authors often confess that only a handful of original
    ideas have been implemented, if any. Life is a great joker, isn't it? It favors
    those who adapt to a change quicker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代成功的产品，如果不是大多数，都是以这种方式推向市场的。它们的作者经常承认，只有少数原创的想法被实现了，如果有的话。生活是一个伟大的笑话，不是吗？它偏爱那些更快适应变化的人。
- en: Now, let's walk through the project life cycle and see how the system design
    evolves along with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们走过项目生命周期，看看系统设计是如何随着项目的进展而演变的。
- en: The project's feasibility
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目的可行性
- en: Decision that a certain project is worth financing has to be made very early.
    Otherwise, it might not start at all. This means that the decision maker has to
    be supplied with enough information to provide a level of confidence that the
    risk is reasonable and worth taking. This information includes high-level requirements,
    a high-level design, and even prototyping or some other proof that the available
    technologies can be used for the successful implementation. Based on this data
    and market research, the project advocates estimate the level of effort, expenses,
    potential income, and future profit—the mother of all goals.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 决定某个项目是否值得融资必须在非常早期就做出。否则，它可能根本就不会开始。这意味着决策者必须提供足够的信息，以提供一定程度的信心，即风险是合理的，值得承担。这些信息包括高层需求、高层设计，甚至原型设计或其他证明可用技术可以用于成功实施。基于这些数据和市场调研，项目倡导者估计工作量、费用、潜在收入和未来利润——一切目标的母亲。
- en: Even before the project gets a green light, the most critical for the success
    of the product features are identified, presented in a form that can be communicated
    to the future customers, and discussed or even tested with them. If the team includes
    people who did something similar in the past, it definitely helps to shortcut
    the decision making.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在项目获得绿灯之前，产品成功最关键的特性就已经被确定，并以可与未来客户沟通的形式呈现，并与他们讨论甚至测试。如果团队中包括过去做过类似事情的人，肯定有助于简化决策过程。
- en: The purpose of this phase is to present the future system in a form that could
    be understood by all participants and potential customers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的目的是以一种所有参与者和潜在客户都能理解的形式呈现未来的系统。
- en: Requirement gathering and prototyping
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求收集和原型制作
- en: As soon as the project is approved and budgeted, the requirement gathering goes
    ahead full-speed along with the prototype implementation. In fact, the prototype
    is often used as a tool for requirements-gathering. It helps to discuss specific
    critical details and avoid misunderstandings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目获得批准和预算，需求收集就会全速进行，同时进行原型实现。事实上，原型通常被用作需求收集的工具。它有助于讨论具体的关键细节并避免误解。
- en: In this project stage, the high-level design progresses, along with the discovery
    of more details about the sources of the input information, the processes necessary
    to consume it (and produce the necessary results), the technologies that can be
    used to do it, and how the customers may interact with the system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目阶段，高级设计不断进展，同时发现有关输入信息来源、消耗它所需的过程（和产生必要结果的过程）、可以用来执行它的技术，以及客户可能如何与系统交互的更多细节。
- en: With more data about the future system, how it might work and be implemented,
    it is possible to identify obstacles that can impede the progress or make the
    whole project impossible. So, the decision makers continue to closely watch the
    results and critically evaluate them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对未来系统的更多数据，以及它可能如何工作和实现，可以确定可能妨碍进展或使整个项目不可能的障碍。因此，决策者继续密切关注结果并进行批判性评估。
- en: The purpose of design at this stage is bringing all the incoming data together
    into a cohesive dynamic picture of the future functioning system. Of the four
    pillars of OOP, encapsulation and interface are at the forefront of high-level
    design. The implementation details should be spot-checked in the critical areas
    and proved to be possible with the selected technologies. But they stay hidden—encapsulated—behind
    the interface, the latter being focused on the system's interaction with the customers
    and on the discovery of new functional and non-functional requirements for the
    implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，设计的目的是将所有输入数据整合成未来运行系统的连贯动态图像。在面向对象编程的四个支柱中，封装和接口处于高级设计的前沿。实现细节应在关键领域进行核查，并证明可以使用所选的技术。但它们保持隐藏在接口后面，后者专注于系统与客户的互动以及发现实现的新功能和非功能要求。
- en: High-level design
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设计
- en: The most apparent feature of the high-level design is its focus on the system
    structure on the level of the subsystems and the interfaces between them. If the
    product has to interact with external systems, the interface and protocol of such
    interactions are part of the high-level design, too. The architecture is identified
    and validated as being able to support the design, too.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 高级设计最明显的特征是其专注于子系统和它们之间的接口的系统结构。如果产品必须与外部系统交互，这些交互的接口和协议也是高级设计的一部分。架构也被确认和验证为能够支持设计。
- en: In the case of a typical mid-size software system, the high-level design can
    be expressed in the list of packages and their public interfaces. If the system
    has a graphic user interface, its prototype and wireframes are usually enough.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的中型软件系统，高级设计可以用包及其公共接口的列表来表达。如果系统具有图形用户界面，通常原型和线框图就足够了。
- en: Detailed design
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细设计
- en: Detailed design comes into play as soon as the use cases to be implemented are
    first identified. The business representatives set priorities for the new product
    features. The programmers identify and adjust the interfaces to support the first
    features and start creating classes to implement the first use cases that are
    going to be delivered in the first iterations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定要实现的用例，详细设计就开始发挥作用。业务代表为新产品功能设置优先级。程序员确定并调整接口以支持第一个功能，并开始创建类来实现将在第一次迭代中交付的第一个用例。
- en: At first, the implementation may have hardcode (dummy) data in some places.
    So, the use cases might have a limited range of applications.  Still, such an
    implementation is valuable as it allows executing all the required processes,
    so the customers in production can test the feature and get a feeling of what
    to expect. The programmers also create unit tests for each of the implemented
    methods, even for the dummy ones. At the same time, the use cases are captured
    in the integration tests that execute scenarios across classes and subsystems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，实现可能在某些地方使用硬编码（虚拟）数据。因此，用例可能具有有限的应用范围。尽管如此，这样的实现是有价值的，因为它允许执行所有必需的过程，因此生产中的客户可以测试该功能并了解预期的情况。程序员还为每个实现的方法创建单元测试，即使是虚拟的方法也是如此。与此同时，用例被捕获在执行跨类和子系统的场景的集成测试中。
- en: By the end of the first iteration, the high-priority use cases are implemented
    and fully tested using the automated tests. The first iteration usually is very
    busy. But programmers are motivated not to repeat their mistakes this time and
    typically work with a lot of enthusiasm and higher-than-usual productivity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代结束时，高优先级的用例已经实现并通过自动化测试进行了全面测试。第一次迭代通常非常忙碌。但程序员们有动力不再重复他们的错误，通常会充满热情并具有比平时更高的生产力。
- en: The purpose of detailed design is to provide a template for coding. Once the
    template is established, all the future classes will be mostly cut-and-paste from
    the existing ones. That is why the first classes are usually implemented by the
    senior programmers or under their close supervision. While doing that, they try
    to keep the encapsulation as closed as possible, for having minimal and intuitive
    interfaces, and for taking advantage of inheritance and polymorphism where possible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 详细设计的目的是为编码提供模板。一旦模板建立，所有未来的类将主要是从现有类中剪切和粘贴。这就是为什么第一个类通常由高级程序员实现或在他们的密切监督下实现。在这样做的同时，他们试图尽可能保持封装封闭，以获得最小和直观的接口，并在可能的情况下利用继承和多态性。
- en: The naming convention is a big part of the first iterations too. It has to reflect
    the domain terminology and be well understood by all the team members. Thus, the
    purpose of the design on this stage is to create a pattern for the coding and
    vocabulary for the project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定也是第一次迭代的重要组成部分。它必须反映领域术语，并且所有团队成员都能理解。因此，这个阶段的设计目的是为项目创建编码模式和词汇。
- en: Coding
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: As you can see, coding has been going since high-level design and possibly even
    earlier. As the detailed design produces the first results, coding gets more steam.
    New members can be added to the team, and some of them can be juniors. Adding
    people to the team is the favorite managerial activity, but it has to be done
    in a controlled manner so that every new member can be instructed and learn project
    vocabulary well enough to understand all the business discussions around new product
    features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，编码从高层设计开始，甚至可能更早。随着详细设计产生了第一个结果，编码变得更加紧张。新成员可以加入团队，其中一些可能是初级成员。增加团队成员是最喜欢的管理活动，但必须以受控的方式进行，以便每个新成员都能得到指导，并且能够充分理解所有关于新产品功能的业务讨论。
- en: The design activity on this stage is focused on the details of the implementation
    and its tests. The pattern created during detailed design has to be applied and
    adjusted as needed. The purpose of the design during coding is to verify all the
    design decisions made so far and to produce specific solutions expressed as the
    lines of code. Refactoring is one of the main activities during this phase and
    several first iterations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的设计活动侧重于实现细节及其测试。在详细设计期间创建的模式必须根据需要进行应用和调整。编码期间的设计目的是验证到目前为止所做的所有设计决策，并产生具体的解决方案，表达为代码行。重构是这个阶段的主要活动之一，也有几次迭代。
- en: Testing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: By the time the coding is finished, the tests are also written and are run many
    times. They are usually executed every time a new chunk of changes are committed
    to a source code repository. Some companies are practicing a continuous integration
    model when the change, once committed to the source repository, triggers the automated
    regression and integration testing with subsequent deployment to production environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码完成时，测试也已编写，并且运行了多次。它们通常在每次向源代码库提交新的更改块时执行。一些公司正在实践持续集成模型，一旦提交到源代码库，就会触发自动回归和集成测试，并随后部署到生产环境。
- en: Yet, there are many development teams that still have dedicated test specialists
    who—after the code is deployed into a test environment—are testing it manually
    and using some specialized tools.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有许多开发团队专门有专门的测试专家，在代码部署到测试环境后，会手动测试并使用一些专门的工具。
- en: The design effort in this phase is focused on test coverage, test automation,
    and integration with other systems, automated or not. Deployment and limited testing
    (called **smoke testing**) in a production environment is also part of the design
    effort of this phase.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的设计工作侧重于测试覆盖率、测试自动化以及与其他系统的集成，无论是自动化的还是非自动化的。部署和在生产环境中进行有限测试（称为**冒烟测试**）也是这个阶段设计工作的一部分。
- en: The purpose of design during testing is to make sure that all the delivered
    use cases are covered with tests, including negative and non-functional testing.
    Monitoring and reporting on the system performance are important activities of
    this phase, too.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 测试期间的设计目的是确保所有交付的用例都经过测试，包括负面和非功能性测试。监控和报告系统性能也是这个阶段的重要活动。
- en: A roadmap to a good design
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好设计的路线图
- en: 'As we discussed the design evolution in previous section, we have already hinted
    at the criteria that ensure design quality:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的设计演变，我们已经暗示了确保设计质量的标准：
- en: It has to be flexible enough to adapt to the incoming changes (they are as inevitable
    as taxes, so you'd better be ready)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须足够灵活，以适应即将到来的变化（它们像税收一样不可避免，所以最好做好准备）
- en: It has to clearly communicate the project structure and specialization of each
    part
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须清晰地传达项目结构和每个部分的专业化
- en: It has to use well-defined domain terminology
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须使用明确定义的领域术语
- en: It has to allow testing parts in isolation and integrated together
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须允许独立测试部分并将其集成在一起
- en: It has to be presented in a form that allows us to discuss it with the future
    customers and, ideally, is tested by them
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须以一种允许我们与未来客户讨论的形式呈现，并且理想情况下，由他们测试。
- en: It has to take full advantage of the four OOP concepts—encapsulation, interface,
    inheritance, and polymorphism
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须充分利用四个面向对象的概念——封装、接口、继承和多态性
- en: Those are general criteria for any project and any OOP language. But in this
    book, we introduce Java best practices, so we need to mainly discuss the detailed
    design, coding, and testing in Java – all related to the last of these criteria.
    That is what we are going to do now.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是任何项目和任何面向对象语言的一般标准。但在本书中，我们介绍了Java最佳实践，因此我们需要主要讨论Java中的详细设计、编码和测试，所有这些都与最后一个标准有关。这就是我们现在要做的。
- en: Encapsulating and coding to an interface
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和编码到接口
- en: 'We have mentioned encapsulation and interface many times and in different contexts.
    It was neither accidental nor intentional. It was unavoidable. Encapsulation and
    interface were born out of necessity to keep the implementation hidden as much
    as possible. It addresses two problems that plagued early programming:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次在不同的上下文中提到了封装和接口。这既不是偶然的，也不是有意的。这是不可避免的。封装和接口是出于尽可能隐藏实现的必要性而产生的。它解决了早期编程中的两个问题：
- en: Unregulated shared access to the data
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未受监管的数据共享访问
- en: Difficulties in changing the code when the relations between parts are not well
    structured
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是输出的屏幕截图：
- en: OOP is a successful solution. It ensures controlled access to the data (object
    state) and flexibility (freedom to change) the implementation as needed as long
    as the interface is not changed. In addition, it helps to organize the design
    and development of software. After the interfaces are defined, everybody can work
    on the implementation independently. There is no need to spend time on meetings
    and discussions if the interfaces do not change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当部分之间的关系结构不够完善时更改代码时的困难
- en: 'As we have demonstrated in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, making an object''s state private
    also addressed the difference in accessibility between instance fields and instance
    methods when inheritance is involved. A child cannot override non-private fields
    of the parent but only hide them. Only methods can be overridden. To demonstrate
    the difference, let''s create the following three classes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中所演示的，*接口、类和对象构造*，使对象的状态私有化也解决了涉及继承时实例字段和实例方法之间可访问性的差异。子类不能覆盖父类的非私有字段，只能隐藏它们。只有方法可以被覆盖。为了演示这种差异，让我们创建以下三个类：
- en: '```java'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Grandad {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: public class Grandad {
- en: public String name = "Grandad";
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: public String name = "爷爷";
- en: public String getName() { return this.name; }
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Parent extends Grandad {
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent extends Grandad {
- en: public String name = "Parent";
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: public String name = "父亲";
- en: public String getName() { return this.name; }
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Child extends Parent {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent {
- en: public String name = "Child";
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: public String name = "孩子";
- en: public String getName() { return this.name; }
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: '}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异经常会引起混淆，并且可能导致难以调试的错误。为了避免这些错误，我们建议永远不直接允许访问对象状态（字段），只能通过方法（至少是getter和setter）访问。这也是始终保持状态封装的另一个原因。
- en: 'Each has a public field with the same name and method with the same signature.
    Now, without looking down the page, try to guess what will be the output of the
    following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一个成功的解决方案。它确保对数据（对象状态）的受控访问，并且在不改变接口的情况下灵活地（根据需要）更改实现。此外，它有助于组织软件的设计和开发。在定义了接口之后，每个人都可以独立地进行实现。如果接口不发生变化，就不需要花时间开会和讨论。
- en: '```java'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个小型软件建模系统，演示我们正在讨论的设计步骤的应用。假设我们的任务是创建一个交通模型，允许根据特定城市中汽车和卡车的典型混合来计算每辆车的速度。该模型将首先在该城市进行测试。模型返回的值应该是车辆在一定秒数后达到的速度（每小时英里）。结果将用于评估交通灯变绿后几秒钟内多车道道路上的交通密度。它将成为引入与汽车最低乘客数量（对于汽车）和有效载荷最大重量（对于卡车）相关的新交通法规时的决策的一部分。
- en: Grandad grandad = new Child();
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Grandad grandad = new Child();
- en: System.out.println(grandad.name);
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(grandad.name);
- en: System.out.println(grandad.getName());
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(grandad.getName());
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here is the screenshot of the output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆数量
- en: '![](img/8ff835e5-929c-4271-b026-757e044dd29e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ff835e5-929c-4271-b026-757e044dd29e.png)'
- en: This difference often creates confusion and can cause difficult-to-debug errors.
    To avoid them, we recommend never allowing access to the object state (fields)
    directly, only via methods (getters and setters at the very least). That is another
    reason to always keep the state encapsulated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有一个具有相同名称的公共字段和相同签名的方法。现在，在不往下看的情况下，尝试猜测以下代码的输出：
- en: We will now create a small software modeling system that illustrates the application
    of the design steps we are discussing. Let's assume that we were tasked with creating
    a model of traffic that allows calculating the speed of every vehicle based on
    a typical mix of cars and trucks in a certain city where the model is going to
    be tested first. The value returned by the model should be the speed (miles per
    hour) the vehicle reaches after a certain number of seconds. The results will be
    used for assessing the traffic density on a multi-lane road a few seconds after
    the traffic light turns green. It will be part of the decision-making during the
    introduction of new traffic regulations related to the minimum number of passengers
    (for cars) and the maximum weight of the payload (for trucks).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We definitely simplify possible real-life requirements in order to make the
    code easier to read. In a real system, such calculations would require more input
    data and a much more complicated algorithm based on the machine learning modeling.
    But even the simple system we develop will have all the design aspects that the
    real-life system has.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定简化了可能的现实需求，以使代码更易于阅读。在真实系统中，这样的计算将需要更多的输入数据和基于机器学习建模的更复杂的算法。但是，即使我们开发的简单系统也将具有真实系统具有的所有设计方面。
- en: 'After discussing the requirements, the high-level design has identified the
    API. It has to accept three parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论需求后，高级设计已经确定了API。它必须接受三个参数：
- en: The number of vehicles
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '```java'
- en: The number of seconds after all the vehicles began moving
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有车辆开始移动后的秒数
- en: 'The vehicle load: number of passengers for cars and the payload for trucks'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆负载：汽车乘客数量和卡车的有效载荷
- en: 'The last parameter should be optional. It can be one of these:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数应该是可选的。它可以是以下之一：
- en: Modeled based on the current traffic statistics in the targeted city
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于目标城市的当前交通统计数据建模
- en: Set to a specific value for the purpose of the evaluation of the effect of the
    new traffic regulations
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置特定值，以评估新交通法规的影响
- en: 'The following is the detailed design of the modeling system API located in
    the `com.packt.javapath.ch08demo.traffic` package:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是位于`com.packt.javapath.ch08demo.traffic`包中的建模系统API的详细设计：
- en: '```java'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface Vehicle {
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Vehicle {
- en: double getSpeedMph(double timeSec);
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: double getSpeedMph(double timeSec);
- en: static List<Vehicle> getTraffic(int vehiclesCount){
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: static List<Vehicle> getTraffic(int vehiclesCount){
- en: return TrafficFactory.get(vehiclesCount);
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: return TrafficFactory.get(vehiclesCount);
- en: '}'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public interface Car extends Vehicle {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Car extends Vehicle {
- en: void setPassengersCount(int passengersCount);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: void setPassengersCount(int passengersCount);
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public interface Truck extends Vehicle {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Truck extends Vehicle {
- en: void setPayloadPounds(int payloadPounds);
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: void setPayloadPounds(int payloadPounds);
- en: '}'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we only expose the interface to the client and hide the implementation
    (more about this in the next section). It allows us the freedom of implementing
    the interfaces whichever way we think is best as long as it fulfills the contract.
    And if we change the implementation later, the clients are not required to change
    their code. That is an example of encapsulation and decoupling the interface from
    the implementation. As we discussed in the previous chapter, it also facilitates
    code maintainability, testability, and reusability. More about the latter in the *Preferring
    aggregation over inheritance* section, although we should point out that inheritance
    facilitates code reuse too and we will see proof of it in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只向客户端公开接口并隐藏实现（关于这一点我们将在下一节详细讨论）。只要满足合同，它允许我们以我们认为最好的方式实现接口。如果以后更改了实现，客户端不需要更改他们的代码。这是封装和解耦接口与实现的一个例子。正如我们在上一章中讨论的那样，它还有助于代码的可维护性、可测试性和可重用性。更多关于后者的内容请参见*更喜欢聚合而不是继承*部分，尽管我们应该指出，继承也有助于代码重用，我们将在下一节中看到它的证明。
- en: By extending the `Car` and `Truck` interfaces from the `Vehicle` interface, we
    have hinted already that we are going to use polymorphism, and that is what we
    are going to discuss in the following section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`Vehicle`接口扩展`Car`和`Truck`接口，我们已经暗示了我们将使用多态性，这就是我们将在接下来的部分讨论的内容。
- en: Taking advantage of polymorphism
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用多态性
- en: 'The `Car` and `Truck` interfaces are extending (children of) the `Vehicle`
    interface. It means that the class that implements the `Car` interface (let''s
    give such a class the name `CarImpl`), for example, when instantiated, creates
    an object that has three types – `Vehicle`, `Car`, and `CarImpl`. These types
    are similar to passports of a person who is a citizen of three countries. Each
    citizenship carries specific rights and restrictions, and a person chooses how
    to present themselves in different situations of international travel, the same
    way an object of the `CarImpl` class can be *cast* to any of these types, provided
    the type is accessible in the code that does the casting. And here is what we
    mean by type accessibility:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`和`Truck`接口正在扩展（子类）`Vehicle`接口。这意味着实现`Car`接口的类（例如，我们给这样的类命名为`CarImpl`），在实例化时，创建了一个具有三种类型的对象——`Vehicle`、`Car`和`CarImpl`。这些类型类似于一个人拥有三个国家的护照。每种国籍都有特定的权利和限制，一个人可以选择在国际旅行的不同情况下如何呈现自己，同样，`CarImpl`类的对象可以*转换*为这些类型中的任何一个，只要在进行转换的代码中可以访问该类型。这就是我们所说的类型可访问性的含义：'
- en: We have already declared the `Car`, `Truck`, and `Vehicle` interfaces as public,
    which means that any code of any package can access these types
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将`Car`、`Truck`和`Vehicle`接口声明为public，这意味着任何包中的任何代码都可以访问这些类型
- en: We don't want client code able to access the implementations of these interfaces,
    so we create the `com.packt.javapath.ch08demo.traffic.impl` package and put all
    the implementations there without specifying an access modifier (thus using the
    default access that makes them visible only to other members of the same package)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不希望客户端代码能够访问这些接口的实现，因此我们创建了`com.packt.javapath.ch08demo.traffic.impl`包，并将所有实现放在那里，而不指定访问修饰符（因此使用默认访问，使它们只对同一包中的其他成员可见）
- en: 'Here are the implementations of the traffic interfaces:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是交通接口的实现：
- en: '```java'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class VehicleImpl implements Vehicle {
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: class VehicleImpl implements Vehicle {
- en: public double getSpeedMph(double timeSec){
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph(double timeSec){
- en: return 42;
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: return 42;
- en: '}'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class TruckImpl implements Truck {
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: class TruckImpl implements Truck {
- en: public void setPayloadPounds(int payloadPounds){
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: public void setPayloadPounds(int payloadPounds){
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class CarImpl implements Car {
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆实现类实现了车辆接口：
- en: public void setPassengersCount(int passengersCount){
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: public void setPassengersCount(int passengersCount){
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We have created these classes in the `com.packt.javapath.ch08demo.traffic.impl`
    package with some dummy data—just to make them compile. But the `CarImpl` and
    `TruckImpl` classes still generate a compilation error because there is the `getSpeedMph()`
    method listed in the `Vehicle` interface which is not implemented in these two
    classes. The `Car` and `Truck` interfaces extend the `Vehicle` interface and,
    thus, inherit its abstract `getSpeedMph()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`com.packt.javapath.ch08demo.traffic.impl`包中创建了这些类，并使用了一些虚拟数据，只是为了使它们编译通过。但是`CarImpl`和`TruckImpl`类仍然会生成编译错误，因为`Vehicle`接口中列出了`getSpeedMph()`方法，而这两个类中没有实现。`Car`和`Truck`接口扩展了`Vehicle`接口，因此继承了它的抽象`getSpeedMph()`方法。
- en: 'So, now we need to either implement the `getSpeedMph()` method in each of these
    two classes or make each of them a child of the `VehicleImpl` class, where this
    method is implemented already. We have decided that the speed will probably be
    calculated the same way for a car and for a truck, so extending the `VehicleImpl` class
    is the way to go. If later we discover that the `CarImpl` or `TruckImpl` class
    needs a different implementation, we can override the one in the parent class.
    Here is the new version of the same two classes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: return 42;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: class TruckImpl extends VehicleImpl implements Truck {
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds){
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: class CarImpl extends VehicleImpl implements Car {
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount){
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Notice, please, that we have also made the `VehicleImpl` class abstract, which
    makes it impossible to create an object of the `VehicleImpl` class. Only objects
    of its children can be created. We did this because we use it as a base class
    that contains some common functionality, but we are never going to need the generic
    `Vehicle` object, only a specific one—either `Car` or `Truck`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We have followed the recommendation of keeping everything as encapsulated as
    possible. The restricted access can be changed to be more accessible later. And
    it is easier to do than to restrict access after some client code is written already
    that relies on the existing level of less-restricted access.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to the `CarImpl` and `TruckImpl`  traffic interfaces implementation.
    They are inaccessible from outside the package, but that is not a problem because
    the API we have defined does not require it. If the `TrafficFactory` class can
    access them, that it would be enough. That is why we create the `TrafficFactor`
    class in the `com.packt.javapath.ch08demo.traffic.impl` package, where it can
    access both implementations as a member of the same package:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath.ch08demo.traffic.impl;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch08demo.traffic.Vehicle;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.ArrayList;
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.List;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: It does not do much, but it is good enough for the design phase, to make sure
    that all the classes are in place and have appropriate access before we start
    coding. We will talk more about the `List<Vehicle>` construct in [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java C**ollections*. For now, it would be enough to assume it represents a list
    of objects that implement the `Vehicle` interface.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the following client code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: double timeSec = 5;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: int vehiclesCount = 4;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> traffic = Vehicle.getTraffic(vehiclesCount);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Vehicle vehicle: traffic){'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Loaded: " + vehicle.getSpeedMph(timeSec));'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: if(vehicle instanceof Car){
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: ((Car) vehicle).setPassengersCount(0);
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Car(no load): " + vehicle.getSpeedMph(timeSec));'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: ((Truck) vehicle).setPayloadPounds(0);
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Truck(no load): " + vehicle.getSpeedMph(timeSec));'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code retrieves any number of vehicles (four, in this case) from `TrafficFactory`.
    The factory hides (encapsulates) the details of the implementation of traffic
    modeling. Then, the code iterates over the list in a for-loop (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*) and prints out the speed of each vehicle calculated at the point
    five seconds after the vehicle has started to move.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The code then demonstrates that the client can change the load the vehicle carries,
    as was required. For cars, we set the number of passengers to zero, and for trucks,
    we set their payloads to zero.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We execute this code and get no results because the traffic factory returns
    an empty list. But the code compiles and runs, and we can start implementing the
    interfaces. We can give the assignments to different team members and we do not
     have to worry about coordinating the effort between them as long as they do not
    change the interface.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: After making sure the interface, inheritance, and polymorphism are used to their
    full (as far as we could do it) capacity, we can turn our attention to the coding
    details.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling as much as you can
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have chosen inheritance for code sharing across different implementations.
    The result looks as follows. Here is the `VehicleImpl` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: private int weightPounds, horsePower;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: public VehicleImpl(int weightPounds, int horsePower) {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: this.weightPounds = weightPounds;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: this.horsePower = horsePower;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){ return this.weightPounds; }
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: double v = 2.0 * this.horsePower * 746 * timeSec *
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 32.174 / weightPounds;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(Math.sqrt(v) * 0.68);
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that some methods have `protected` access, meaning only members of the
    same package and class children can access them. That is done for better encapsulation,
    too. Our code clients do not need access to these methods, only children do. And
    here is one of  them:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: class CarImpl extends VehicleImpl implements Car {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: private int passengersCount;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(int passengersCount, int weightPounds, int horsePower){
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds , horsePower);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount) {
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: return this.passengersCount * 200 + super.getWeightPounds();
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The `this` and `super` keywords in the preceding code allow us to distinguish
    which method has to be called – the one in the current child object or the one
    in the parent object.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two aspects of the preceding implementation are worth noticing:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The access modifier of the `getWeightPounds()` method is set to `protected`.
    That is because the method with the same signature and `protected` access modifier
    is declared in the parent, class too. But the overriding method cannot have more
    restrictive access than the overridden one. Alternatively, to tighten the encapsulation,
    we could change the method name in `CarImpl` to `getCarWeightPounds()`, for example,
    and make it private. Then, there would be no need to use the `this` and `super` keywords.
    But classes of another package cannot access the `protected` method anyway, so
    we have decided to keep the `getWeightPounds()` name and use the `this` and `super` keywords,
    admitting that it is just a matter of style.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access to the constructor can be made default (package-level), too.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TruckImpl` class looks similar to the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: class TruckImpl extends VehicleImpl implements Truck {
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: private int payloadPounds;
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: TruckImpl(int payloadPounds, int weightPounds, int horsePower) {
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds, horsePower);
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds) {
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: return this.payloadPounds + super.getWeightPounds();
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'And the `TrafficFactory` class can access these classes and their constructors
    to create objects as needed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < vehiclesCount; i++){
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle vehicle;
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: if (Math.random() <= 0.5) {
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new CarImpl(2, 2000, 150);
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new TruckImpl(500, 3000, 300);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: list.add(vehicle);
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: return list;
- en: '}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `random()` static method of the `Math` class generates a random decimal
    number between 0 and 1\. We use it to make the resulting mix of traffic look somewhat
    real. And we have hardcoded, for now, the values we pass into each of the vehicles'
    constructors.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: The `random()` static method of the `Math` class generates a random decimal
    number between 0 and 1\. We use it to make the resulting mix of traffic look somewhat
    real. And we have hardcoded, for now, the values we pass into each of the vehicles'
    constructors.
- en: 'Now, we can run the following code (we discussed it already a few pages ago):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, we can run the following code (we discussed it already a few pages ago):'
- en: '```java'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class TrafficApp {
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: public class TrafficApp {
- en: public static void main(String... args){
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args){
- en: double timeSec = 5;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: double timeSec = 5;
- en: int vehiclesCount = 4;
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: int vehiclesCount = 4;
- en: List<Vehicle> traffic = Vehicle.getTraffic(vehiclesCount);
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: List<Vehicle> traffic = Vehicle.getTraffic(vehiclesCount);
- en: 'for(Vehicle vehicle: traffic){'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Vehicle vehicle: traffic){'
- en: 'System.out.println("Loaded: " + vehicle.getSpeedMph(timeSec));'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Loaded: " + vehicle.getSpeedMph(timeSec));'
- en: if(vehicle instanceof Car){
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: if(vehicle instanceof Car){
- en: ((Car) vehicle).setPassengersCount(0);
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ((Car) vehicle).setPassengersCount(0);
- en: 'System.out.println("Car(no load): " +'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Car(no load): " +'
- en: vehicle.getSpeedMph(timeSec));
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: vehicle.getSpeedMph(timeSec));
- en: '} else {'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: ((Truck) vehicle).setPayloadPounds(0);
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ((Truck) vehicle).setPayloadPounds(0);
- en: 'System.out.println("Truck(no load): " +'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Truck(no load): " +'
- en: vehicle.getSpeedMph(timeSec));
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: vehicle.getSpeedMph(timeSec));
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result is:'
- en: '![](img/3ff20e22-6228-435a-9211-4fcd408691b6.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ff20e22-6228-435a-9211-4fcd408691b6.png)'
- en: 'The calculated speed is the same because the input data is hardcoded in `TrafficFactory`.
    But before we move on and make the input data different, let''s create a speed
    calculation test:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'The calculated speed is the same because the input data is hardcoded in `TrafficFactory`.
    But before we move on and make the input data different, let''s create a speed
    calculation test:'
- en: '```java'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch08demo.traffic.impl;
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch08demo.traffic.impl;
- en: class SpeedCalculationTest {
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: class SpeedCalculationTest {
- en: '@Test'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: void speedCalculation() {
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: void speedCalculation() {
- en: double timeSec = 5;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: double timeSec = 5;
- en: Vehicle vehicle = new CarImpl(2, 2000, 150);
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Vehicle vehicle = new CarImpl(2, 2000, 150);
- en: assertEquals(83.0, vehicle.getSpeedMph(timeSec));
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(83.0, vehicle.getSpeedMph(timeSec));
- en: ((Car) vehicle).setPassengersCount(0);
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ((Car) vehicle).setPassengersCount(0);
- en: assertEquals(91.0, vehicle.getSpeedMph(timeSec));
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(91.0, vehicle.getSpeedMph(timeSec));
- en: vehicle = new TruckImpl(500, 3000, 300);
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: vehicle = new TruckImpl(500, 3000, 300);
- en: assertEquals(98.0, vehicle.getSpeedMph(timeSec));
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(98.0, vehicle.getSpeedMph(timeSec));
- en: ((Truck) vehicle).setPayloadPounds(0);
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ((Truck) vehicle).setPayloadPounds(0);
- en: assertEquals(105.0, vehicle.getSpeedMph(timeSec));
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(105.0, vehicle.getSpeedMph(timeSec));
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We could access the `CarImpl` and `TruckImpl` classes because the test belongs
    to the same package, although it's located in a different directory of our project
    (under the `test` directory, instead of `main`). On the classpath, they are placed
    according to their package, even if the source comes from another source tree.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: We could access the `CarImpl` and `TruckImpl` classes because the test belongs
    to the same package, although it's located in a different directory of our project
    (under the `test` directory, instead of `main`). On the classpath, they are placed
    according to their package, even if the source comes from another source tree.
- en: We have tested our code and now we can concentrate on processing real data and
    creating the corresponding objects for the client in `TrafficFactory`. The implementation
    is decoupled from the interface and, until it is ready, we can keep it hardcoded,
    so the client can start writing and testing their code without waiting until our
    system is fully functional. That is another advantage of encapsulation and interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: We have tested our code and now we can concentrate on processing real data and
    creating the corresponding objects for the client in `TrafficFactory`. The implementation
    is decoupled from the interface and, until it is ready, we can keep it hardcoded,
    so the client can start writing and testing their code without waiting until our
    system is fully functional. That is another advantage of encapsulation and interface.
- en: Preferring aggregation over inheritance
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Preferring aggregation over inheritance
- en: Those who worked on real-life projects know that the requirements can change
    at any moment. In the case of our project, even before the second iteration was
    completed, new methods had to be added to the `Car` and `Truck` interfaces, while
    speed calculation grew in its own project. The programmers who worked on the implementation
    of the interfaces and those working on the speed calculation started to change
    the `CarImpl`, `TruckImpl`, and `VehicleImpl` files.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Those who worked on real-life projects know that the requirements can change
    at any moment. In the case of our project, even before the second iteration was
    completed, new methods had to be added to the `Car` and `Truck` interfaces, while
    speed calculation grew in its own project. The programmers who worked on the implementation
    of the interfaces and those working on the speed calculation started to change
    the `CarImpl`, `TruckImpl`, and `VehicleImpl` files.
- en: Not only that, but another project decided to use our speed calculation functionality,
    but they wanted to apply it to other objects, not cars and trucks. That is when
    we realized that we need to change our implementation in favor of aggregating
    the functionality instead of inheriting it, which is one of the recommended design
    strategies in general anyway, because it increases decoupling and facilitates
    more flexible design. Here is what it means.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Not only that, but another project decided to use our speed calculation functionality,
    but they wanted to apply it to other objects, not cars and trucks. That is when
    we realized that we need to change our implementation in favor of aggregating
    the functionality instead of inheriting it, which is one of the recommended design
    strategies in general anyway, because it increases decoupling and facilitates
    more flexible design. Here is what it means.
- en: 'We copy the `getSpeedMph()` method of the `VehicleImpl` class and put it in
    the `SpeedModelImpl` class in a new `com.packt.javapath.ch08demo.speedmodel.impl`
    package:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'We copy the `getSpeedMph()` method of the `VehicleImpl` class and put it in
    the `SpeedModelImpl` class in a new `com.packt.javapath.ch08demo.speedmodel.impl`
    package:'
- en: '```java'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SpeedModelImpl implements SpeedModel {
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: class SpeedModelImpl implements SpeedModel {
- en: public double getSpeedMph(double timeSec, int weightPounds,
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph(double timeSec, int weightPounds,
- en: int horsePower){
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: int horsePower){
- en: double v = 2.0 * horsePower * 746 * timeSec * 32.174 / weightPounds;
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: double v = 2.0 * horsePower * 746 * timeSec * 32.174 / weightPounds;
- en: return Math.round(Math.sqrt(v) * 0.68);
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: return Math.round(Math.sqrt(v) * 0.68);
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We add `SpeedModelFactory` to the same package:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'We add `SpeedModelFactory` to the same package:'
- en: '```java'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SpeedModelFactory {
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: public class SpeedModelFactory {
- en: public static SpeedModel speedModel(){
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: public static SpeedModel speedModel(){
- en: return new SpeedModelImpl();
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: return new SpeedModelImpl();
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And we create a `SpeedModel` interface in the `com.packt.javapath.ch08demo.speedmodel`
    package:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: public interface SpeedModel {
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: double getSpeedMph(double timeSec, int weightPounds, int horsePower);
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: static SpeedModel getInstance(Month month, int dayOfMonth, int hour){
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: return SpeedModelFactory.speedModel(month, dayOfMonth, hour);
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we change the `VehicleImpl` class by adding a setter for the `SpeedModel`
    object and by using this object in the speed calculations:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: abstract class VehicleImpl implements Vehicle {
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: private int weightPounds, horsePower;
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: private SpeedModel speedModel;
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: public VehicleImpl(int weightPounds, int horsePower) {
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: this.weightPounds = weightPounds;
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: this.horsePower = horsePower;
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){ return this.weightPounds; }
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: if(this.speedModel == null){
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Speed model is required");
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: return speedModel.getSpeedMph(timeSec, weightPounds, horsePower);
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: public void setSpeedModel(SpeedModel speedModel) {
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: this.speedModel = speedModel;
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `getSpeedMph()` method now throws an exception (and stops
    working) if it is called before the `SpeedModel` object is set.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'We also change `TrafficFactory` and let it set `SpeedModel` on the traffic
    objects:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: public class TrafficFactory {
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: public static List<Vehicle> get(int vehiclesCount) {
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: SpeedModel speedModel = SpeedModelFactory.speedModel();
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: List<Vehicle> list = new ArrayList();
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < vehiclesCount; i++) {
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle vehicle;
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: if (Math.random() <= 0.5) {
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new CarImpl(2, 2000, 150);
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: vehicle = new TruckImpl(500, 3000, 300);
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: ((VehicleImpl)vehicle).setSpeedModel(speedModel);
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: list.add(vehicle);
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Now, the speed model continues to be developed independently of the traffic
    model, and we accomplished all that without changing the client's code (such an
    internal code change that does not affect an interface is called **refactoring**).
    That is the benefit of decoupling based on encapsulation and interface. The behavior
    of the `Vehicle` object is now aggregated, which allow us to change its behavior
    without modifying its code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the title of this section is *Preferring aggregation over inheritance*,
    it does not mean that inheritance should always be avoided. Inheritance has its
    own uses and is especially beneficial for polymorphic behavior. But when we talk
    about design flexibility and code reusability, it has two weaknesses:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Java classes do not allow us to extend more than one parent, so, if the class
    is already a child, it cannot extend another class in order to reuse its method
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance requires a parent-child relationship between classes, while the
    same functionality is often shared by the unrelated classes
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, inheritance is the only way to solve the problem at hand and sometimes
    using it causes problems later. The reality is that we can never reliably predict
    what the future holds, so do not feel bad if the decision to use inheritance or
    not turns out to be wrong later.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: So many OOD principles and so little time
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you search for OOD principles on the internet, you can easily find many lists
    that include dozens of recommended design principles. And all of them make sense.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are the five most popular OOD principles often bundled together
    under the abbreviation SOLID (composed from the first letters of the principles''
    titles):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle**: A class should have only one responsibility'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Closed Principle**: A class should encapsulate its functionality (be
    closed) but be able to be extended'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle**: An object should be replaceable (substituted)
    by its child and still not break the program'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle**: Many client-oriented interfaces are better
    than one general-purpose interface'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle**: Code should depend on the interface, not
    implementations'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, as we have said before, there are many other good ideas about how to achieve
    better design. Should you study all of them? The answer very much depends on the
    way you prefer to learn new skills. Some people do it by experimenting, others
    by learning from other people's experience, and the majority learns from a combination
    of these approaches.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the design criteria, OOP concepts, and the roadmap for
    a good design that we have discussed in this chapter are able to lead you to a
    solid OOP solution in most of the cases.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: But if you decide to read more about OOD and see how other people have solved
    software design problems, do not hesitate to check them out. After all, that was
    how humanity got out of the caves and boarded a spacecraft – by passing their
    experience on to the next generation.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Design patterns
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many OOD patterns that have shared software-design solutions of specific coding
    problems. OOD patterns are also often used by programmers as the way to talk about
    different implementations.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'They are traditionally grouped into four categories: creational, behavioral,
    structural, and concurrency patterns. Read about them and:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Name one pattern in each category
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three patterns we have used already
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four patterns—one from each of the four categories—could be the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: Factory method'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: Composite'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: Visitor'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency patterns**: Messaging pattern'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we have already used the following patterns:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy initialization**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, we initialized the `SingletonClassExample
    OBJECT` static field, not automatically, but only when the `getInstance()` method
    was called'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*, see the `SingletonClassExample` class'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, when we created a `Calculator` interface that
    captures all possible interactions with the implemented functionality'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revisited a high-level view of programming and Java programming
    in particular. We discussed design evolution in the process of software system
    development, starting with the earliest feasibility phase, going through high-level
    design, detailed design, and ending with coding and testing.  We discussed the
    criteria for a good design, OOP concepts, the main OOD principles, and provided
    a roadmap to a good OOP design. The discussion was illustrated by code examples
    that demonstrated the application of all the OOD principles discussed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will dive deeper into three core elements of Java programming:
    operators, expressions, and statements. We will define and discuss all Java operators,
    explore the most popular ones in more detail, and demonstrate them in specific
    examples, along with expressions and statements as well.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
