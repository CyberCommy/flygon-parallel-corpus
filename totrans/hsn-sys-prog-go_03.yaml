- en: Unix OS Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will be focusing on Unix OS and on the components that the user
    will interact with: files and filesystems, processes, users and permissions, and
    so on. It will also explain some basic process communication and how system program
    error handling works. All these parts of the operating system will be the ones
    we will be interacting with when creating system applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files and filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users, groups, and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way as the previous chapter, this one does not require any software
    to be installed: any other POSIX-compliant shell is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: You could choose, for instance, Bash ([https://www.gnu.org/software/bash/](https://www.gnu.org/software/bash/)),
    which is recommended, Zsh ([http://www.zsh.org/](http://www.zsh.org/)), or fish
    ([https://fishshell.com/](https://fishshell.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The operating system handles the primary and secondary memory usage of the applications.
    It keeps track of how much of the memory is used, by which process, and what parts
    are free. It also handles allocation of new memory from the processes and memory
    de-allocation when the processes are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques of management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different techniques for handling memory, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single allocation**: All the memory, besides the part reserved for the OS,
    is available for the application. This means that there can only be one application in
    execution at a time, like in **Microsoft Disk Operating System** (**MS-DOS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partitioned allocation**: This divides the memory into different blocks called
    partitions. Using one of these blocks per process makes it possible to execute
    more than one process at once. The partitions can be relocated and compacted in
    order to obtain more contiguous memory space for the next processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paged memory**: The memory is divided into parts called frames, which have
    a fixed size. A process'' memory is divided into parts of the same size called
    **pages**. There is a mapping between pages and frames that makes the process
    see its own virtual memory as contiguous. This process is also known as **pagination**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix uses the paged memory management technique, abstracting its memory for
    each application into contiguous virtual memory. It also uses a technique called
    swapping, which extends the virtual memory to the secondary memory (hard drive
    or **solid state drives** (**SSD**)) using a swap file.
  prefs: []
  type: TYPE_NORMAL
- en: When memory is scarce, the operating system puts pages from processes that are
    sleeping in the swap partition in order to make space for active processes that
    are requesting more memory, executing an operation called **swap-out**. When a
    page that is in the swap file is needed by a process in execution it gets loaded
    back into the main memory for executing it. This is called **swap-in**.
  prefs: []
  type: TYPE_NORMAL
- en: The main issue of swapping is the performance drop when interacting with secondary
    memory, but it is very useful for extending multitasking capabilities and for
    dealing with applications that are bigger than the physical memory, by loading
    just the pieces that are actually needed at a given time. Creating memory-efficient
    applications is a way of increasing performance by avoiding or reducing swapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `top` command shows details about available memory, swap, and memory consumption
    for each process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RES` is the physical primary memory used by the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIRT` is the total memory used by the process, including the swapped memory,
    so it''s equal to or bigger than `RES`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHR` is the part of `VIRT` that is actually shareable, such as loaded libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding files and filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem is a method used to structure data in a disk, and a file is the
    abstraction used for indicating a piece of self-contained information. If the
    filesystem is hierarchical, it means that files are organized in a tree of directories,
    which are special files used for arranging stored files.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems and filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last 50 years, a large number of filesystems have been invented and
    used, and each one has its own characteristics regarding space management, filenames
    and directories, metadata, and access restriction. Each modern operating system mainly uses
    a single type of filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux's **filesystem** (**FS**) of choice is the **extended filesystem** (**EXT**)
    family, but other ones are also supported, including XFS, **Journaled File System**
    (**JFS**), and **B-tree File System** (**Btrfs**). It is also compatible with
    the older **File Allocation** **Table** (**FAT**) family (FAT16 and FAT32) and **New
    Technology File System** (**NTFS**). The filesystem most commonly used remains
    the latest version of EXT (EXT4), which was released in 2006 and expanded its
    predecessor's capacities, including support for bigger disks.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: macOS uses the **Apple File System** (**APFS**), which supports Unix permission
    and has journaling. It is also metadata-rich and case-preserving, while being
    a case-insensitive filesystem. It offers support for other filesystems, including
    HFS+ and FAT32, supporting NTFS for read-only operations. To write to such a filesystem,
    we can use an experimental feature or third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main filesystem used by Windows is NTFS. As well as being case-insensitive,
    the signature feature that distinguishes Windows FS from others is the use of
    a letter followed by a colon to represent a partition in paths, combined with
    the use of backslash as a folder separator, instead of a forward slash. Drive
    letters, and the use of C for the primary partition, comes from MS-DOS, where
    A and B were reserved drive letters used for floppy disk drives.
  prefs: []
  type: TYPE_NORMAL
- en: Windows also natively supports other filesystems, such as FAT, which is a filesystem
    family that was very popular between the late seventies and the late nineties,
    and **Extended File Allocation Table** (**exFAT**), which is a format developed
    by Microsoft on top of FAT for removable devices.
  prefs: []
  type: TYPE_NORMAL
- en: Files and hard and soft links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most files are regular files, containing a certain amount of data. For instance,
    a text file contains a sequence of human-readable characters represented by a
    certain encoding, while a bitmap contains some metadata about the size and the
    bit used for each pixel, followed by the content of each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Files are arranged inside directories that make it possible to have different
    namespaces to reuse filenames. These are referred to with a name, their human-readable
    identifier, and organized in a tree structure. The path is a unique identifier
    that represents a directory, and it is made by the names of all the parents of
    the directory joined by a separator (`/` in Unix, `\` in Windows), descending
    from the root to the desired leaf. For instance if a directory named `a` is located
    under another named `b`, which is under one called `c`, it will have a path that
    starts from the root and concatenates all the directories, up to the file: `/c/b/a`.
  prefs: []
  type: TYPE_NORMAL
- en: When more than one file points to the same content, we have a **hard link**,
    but this is not allowed in all filesystems (for example, NTFS and FAT). A **soft
    link** is a file that points to another soft link or to a hard link. Hard links
    can be removed or deleted without breaking the original link, but this is not
    true for soft links. A **symbolic link** is a regular file with its own data that
    is the path of another file. It can also link other filesystems or files and directories
    that do not exist (that will be a broken link).
  prefs: []
  type: TYPE_NORMAL
- en: In Unix, some resources that are not actually files are represented as files,
    and communication with these resources is achieved by writing to or reading from
    their corresponding files. For instance, the `/dev/sda` file represents an entire
    disk, while `/dev/stdout`, `dev/stdin`, and `/dev/stderr` are standard output,
    input, and error. The main advantage of *Everything is a file* is that the same
    tools that can be used for files can also interact with other devices (network
    and pipes) or entities (processes).
  prefs: []
  type: TYPE_NORMAL
- en: Unix filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principles contained in this section are specific to the filesystems used
    by Linux, such as EXT4.
  prefs: []
  type: TYPE_NORMAL
- en: Root and inodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux and macOS, each file and directory is represented by an **inode**,
    which is a special data structure that stores all the information about the file
    except its name and its actual data.
  prefs: []
  type: TYPE_NORMAL
- en: Inode `0` is used for a null value, which means that there is no inode. Inode
    `1` is used to record any bad block on the disk. The root of the hierarchical
    structure of the filesystem uses inode `2`. It is represented by `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the latest Linux kernel source, we can see how the first inodes are reserved.
    This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This link is the source for the preceding code block: [https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h#L212](https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h#L212).
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unix filesystems, there is a series of other directories under the root,
    each one used for a specific purpose, making it possible to maintain a certain
    interoperability between different operating systems and enabling compiled software
    to run on different OSes, making the binaries portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a comprehensive list of the directories with their scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/bin` | Executable files for all users |'
  prefs: []
  type: TYPE_TB
- en: '| `/boot` | Files for booting the system |'
  prefs: []
  type: TYPE_TB
- en: '| `/dev` | Device drivers |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc` | Configuration files for applications and system |'
  prefs: []
  type: TYPE_TB
- en: '| `/home` | Home directory for users |'
  prefs: []
  type: TYPE_TB
- en: '| `/kernel` | Kernel files |'
  prefs: []
  type: TYPE_TB
- en: '| `/lib` | Shared library files and other kernel-related files |'
  prefs: []
  type: TYPE_TB
- en: '| `/mnt` | Temporary filesystems, from floppy disks and CDs to flash drives
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc` | File with process numbers for active processes |'
  prefs: []
  type: TYPE_TB
- en: '| `/sbin` | Executable files for administrators |'
  prefs: []
  type: TYPE_TB
- en: '| `/tmp` | Temporary files that should be safe to delete |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr` | Administrative commands, shared files, library files, and others
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/var` | Variable-length files (logs and print files)  |'
  prefs: []
  type: TYPE_TB
- en: Navigation and interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using a shell, one of the directories will be the **working directory**,
    when paths are relative (for example, `file.sh` or `dir/subdir/file.txt`). The
    working directory is used as a prefix to obtain an absolute one. This is usually
    shown in the prompt of the command line, but it can be printed with the `pwd`
    command (print working directory).
  prefs: []
  type: TYPE_NORMAL
- en: The `cd` (change directory) command can be used to change the current working
    directory. To create a new directory, there's the `mkdir` (make directory) command.
  prefs: []
  type: TYPE_NORMAL
- en: To show the list of files for a directory, there's the `ls` command, which accepts
    a series of options, including more information (`-l`), showing hidden files and
    directories (`-a`), and sorting by time (`-t`) and size (`-S`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a series of other commands that can be used to interact with files:
    the `touch` command creates a new empty file with the given name, and to edit
    its content you can use a series of editors, including vi and nano, while `cat`,
    `more`, and `less` are some of the commands that make it possible to read them.'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting and unmounting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operating system splits the hard drive into logical units called partitions,
    and each one can be a different file system. When the operating system starts,
    it makes some partitions available using the `mount` command for each line of
    the `/etc/fstab` file, which looks more or less like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This configuration mounts `/dev/sda1` to `*/*disk` using an `ext4` filesystem
    and default options, no backing up (`0`), and root integrity check (`1`). The
    `mount` command can be used at any time to expose partitions in the filesystem.
    Its counterpart, `umount`, is needed to remove these partitions from the main
    filesystem. The empty directory used for the operation is called **mount point**,
    and it represents the root under which the filesystem is connected.
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an application is launched, it becomes a process: a special instance provided
    by the operating system that includes all the resources that are used by the running
    application. This program must be in **Executable and Linkable Format** (**ELF**),
    in order to allow the operating system to interpret its instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: Process properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each process is a five-digit identifier **process ID** (**PID**), and it represents
    the process for all its life cycle. This means that there cannot be two processes
    with the same PID at the same time. Their uniqueness makes it possible to access
    a specific process by knowing its PID. Once a process is terminated, its PID can
    be reused for another process, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to PID, there are other properties that characterize a process. These
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P****PID**: The parent process ID of the process that started this process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nice number**: Degree of friendliness of this process toward other processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal or TTY**: Terminal to which the process is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUID/EUID**: The real/effective user ID, which belongs to the owner of the
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RGID/EGID**: The real/effective group owner, the group owner of a process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see a list of the active processes, there''s the `ps` (process status) command,
    which shows the current list of running processes for the active user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Process life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The creation of a new process can happen in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `fork`: This duplicates the calling process. The child (new process)
    is an exact copy (memory) of the parent (calling process), except for the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PIDs are different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PPID of the child equals the PID of the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The child does not inherit the following from the parent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore adjustments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outstanding asynchronous I/O operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous I/O contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using an `exec`: This replaces the current process image with a new one, loading
    the program into the current process space and running it from its entry point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground and background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process is launched, it is normally in the **foreground**, which will
    prevent communication with the shell until the job is finished or interrupted.
    Launching a process with an `&` symbol at the end of the command (`cat file.txt
    &`) will launch it in the **background**, making it possible to keep using the
    shell. The `SIGTSTP` signal can be sent with *C**trl *+ *Z*, which allows the
    user to suspend the foreground process from the shell. It can be resumed with
    the `fg` command, or in the background with the `bg` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `jobs`command reports the jobs running and their numbers. In the output,
    the numbers in square brackets are the job numbers that are used by the process
    control commands, such as `fg` and `bg`.
  prefs: []
  type: TYPE_NORMAL
- en: Killing a job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foreground process can be terminated with the `SIGINT` signal using *C**trl *+ *Z*.
    In order to kill a background process, or send any signal to the process, the
    `kill` command can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill` command receives an argument that can be either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The signal sent to the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PID or the job number (with a `%` prefix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The more notable signals used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGINT`: Indicates a termination caused by user input and can be sent by `kill`
    command with the `-2` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM`: Represents a general purpose termination request not generated by
    a user as well as a default signal for the `kill` command with a  `-6` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL`: A termination handled directly by the operating system that kills
    the process immediately and has a `-9` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users, groups, and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users and groups, together with permissions, are the main entities that are
    used in Unix operating systems to control access to resources.
  prefs: []
  type: TYPE_NORMAL
- en: Users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authorization to files and other resources are provided by users and groups.
    Users have unique usernames that are human-friendly identifiers, but from the
    operating system side, each user is represent by a unique positive integer: the
    **User ID** (**UID**). Groups are the other authorization mechanism and, as users,
    they have a name and a **Group ID** (**GID**). In the operating system, each process
    is associated with a user and each file and directory belongs to both a user and
    a group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/etc/passwd` file contains all this information and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Users don't use UID directly; they use a combination of username and password
    in order to start their first process, the interactive shell. Children of the
    first shell inherit their UID from it, so they keep belonging to the same user.
  prefs: []
  type: TYPE_NORMAL
- en: The UID `0` is reserved for a user known as root, which has special privileges
    and can do almost anything on the system, such as read/write/execute any file,
    kill any process, and change running process UIDs.
  prefs: []
  type: TYPE_NORMAL
- en: A group is a logical collection of users, used to share files and directories
    between them. Each group is independent of other groups and there is no specific
    relationship between them. For a list of the groups that the current user belongs
    to, there's the `groups` command. To change group ownership of a file, there's `chgrp`.
  prefs: []
  type: TYPE_NORMAL
- en: Owner, group, and others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unix files belong to a user and a group. This creates three levels of authorization hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner**: The UID associated with the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: UIDS that belong to the GID associated with the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others**: Everyone else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different permissions can be specified for each of these groups, and these permissions
    are usually decreasing from owner to others. It does not make sense that the owner
    of a file has less permission on it than its own group or the users outside that
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Read, write, and execute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users and groups are used as the first two layers of protection for accessing
    a file. The user that owns a file has a set of permissions that differs from the
    file group. Whoever is not the owner and does not belong to the group has different
    permissions. These three sets of permissions are known as **owner**, **group**,
    and **other**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each element of the set there are three actions that may be carried out:
    reading, writing, and executing. This is very straightforward for files but it
    means something different for directories. Read makes it possible to list the
    contents, write is used to add new links inside, and execute is used to navigate
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three permissions are represented by an octal value, where the first bit is
    read permission, the second is write, and the third is execute. They can also
    be represented by the letters `r`, `w`, and `x` in sequence and the possible values
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0 or ---`: No permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 or --x`: Execute permission (execute a file or navigate to a directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2 or -w-`: Write permission (write a file or add new files in a directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3 or -wx`: Write and execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4 or r--`: Read permission (read a file or list the contents of a directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5 or r-x`: Read and execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6 or rw-`: Read and write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7 or rwx`: Read, write, and execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sequence of three octal values represent permission for user, group, and
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '`777`: Everyone can read, write, and execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`700`: Owner can read, write, and execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`664`: Owner and group can read and write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`640`: Owner can read and write and group can read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`755`: Owner can read, write, and execute, while group and others can read
    and execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ls` command with the `-l` flag (or its alias, `ll`) shows the list of files
    and the folder for the current directory with their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Changing permission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chmod` command makes it possible to change permission on a file or directory.
    This can be used to override current permissions or to modify them:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to replace permissions, the `chmod xxx file` command must be issued. `*xxx*`
    can be the three octal values representing the permission for the respective tiers
    or a string that specifies permissions, such as `u=rwx`, `g=rx`, or  `o=r`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add or remove one or more permissions, `chmod +x file` or `chmod -x file`
    can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, use the `chmod` command with the help flag (`chmod --help`).
  prefs: []
  type: TYPE_NORMAL
- en: Process communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The operating system is responsible for communication between processes and
    has different mechanisms to exchange information. These processes are unidirectional,
    such as exit codes, signals, and pipes, or bidirectional, such as sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications communicate their result to the operating system by returning
    a value called **exit status**. This is an integer value passed to the parent
    process when the process ends. A list of common exit codes can be found in the `/usr/include/sysexits.h` file,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The source for this is as follows: [https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h#L212](https://elixir.bootlin.com/linux/latest/source/fs/ext4/ext4.h#L212).
  prefs: []
  type: TYPE_NORMAL
- en: The exit code of the last command is stored in the `$?` variable, and it can
    be tested in order to control the flow of the operations. A commonly used operator
    is `&&` (double ampersand), which executes the next instruction only if the exit
    code of the first one is `0`, such as `stat file && echo something >> file`, which
    appends something to a file only if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exit codes connect processes and their parents, but signals make it possible
    to interface any process with another, including itself. They are also asynchronous
    and unidirectional, but they represent communication from the outside of a process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common signal is `SIGINT`, which tells the application to terminate,
    and can be sent to a foreground process in a shell with the *Ctrl* + *C* key combination.
    However, there are many more options, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Number** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGHUP` | 1 | Controlling terminal is closed |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGINT` | 2 | Interrupt signal (*Ctrl* + *C*) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGQUIT` | 3 | Quit signal (*Ctrl* + *D*) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGFPE` | 8 | Illegal mathematical operation is attempted |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGKILL` | 9 | Quits the application immediately  |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGALRM` | 14 | Alarm clock signal |'
  prefs: []
  type: TYPE_TB
- en: 'The `kill` command allows you to send a signal to any application, and a comprehensive
    list of available signals can be shown with the `-l` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe0c00b9-45c3-4c14-acc5-02d28aa7a744.png)'
  prefs: []
  type: TYPE_IMG
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes are the last unidirectional communication method between processes. As
    the name suggests, pipes connect two ends – a process input with another process
    output – making it possible to process on the same host to communicate in order
    to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are classified as anonymous or named:'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipes link one process standard output to another process standard
    input. It can be easily done inside a shell with the `|` operator, linking the
    output of the command before the pipe as input for the one after the pipe. `ls
    -l | grep "user"` gets the output of the `ls` command and uses it as input for
    `grep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipes use a specific file in order to execute the redirect. The output
    can be redirected to a file with the `>` (greater) operator, while the `<` (less)
    sign allows you to use a file as input for another process. `ls -l > file.txt` saves
    the output of the command to a file. `cat < file.txt` sends the contents of the
    file to the command's standard input, and the standard input copies them to the
    standard output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to append content to a named pipe using the `>>` (double
    greater) operator, which will start writing from the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix domain sockets are a bidirectional communication method between applications
    on the same machine. They are a logical endpoint that is handled by the kernel
    and manages the data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of sockets permits using them as stream-oriented, or datagram-oriented.
    Stream-oriented protocols ensure that messages are delivered before moving to
    the next chunk of data in order to preserve message integrity. In contrast, message-oriented
    protocols ignore the data that is not received and keeps sending the following
    messages, making it a faster but less reliable protocol with very low latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sockets are classified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SOCK_STREAM`: Connection-oriented, ordered, and reliable transmission of a
    stream of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_SEQPACKET`: Connection-oriented, ordered, and reliable transmission of
    message data that has record boundaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_DGRAM`: Unordered and unreliable transmission of messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a general overview of the main Unix components and how
    they interact with each other. We started with memory management and how it works
    in Unix, understanding concepts such as **pagination** and **swap.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we analyzed the filesystem, taking a look at the support from modern operating
    systems, and explained the difference between the existing file types: files,
    directories, and hard and soft links.'
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the concept of inode, we took a look at the structure of
    a directory in a Unix operating system and explained how to navigate and interact
    with the filesystem, as well as how to mount and unmount other partitions.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to processes, running applications in Unix, and their structure
    and attributes. We analyzed process life cycle, from its creation through `fork`
    or `exec`, to its end or termination with the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: Another important topic was users, groups, and permissions. We saw what a user
    is, what groups are, how to join them, and how these concepts are used to divide
    permissions into three groups: user, group, and others. This helped to better
    understand the Unix permission model, as well as how to change permissions for
    files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how communication between processes works with one-way channels
    such as signals and exit codes, or bidirectional communication such as sockets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a quick overview of the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which filesystem is used by modern operating systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an inode? What is inode `0` in Unix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between PID and PPID?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you terminate a process running in the background?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between user and group?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the scope of the Unix permission model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you explain the difference between signals and exit codes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a swap file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
