- en: Chapter 4. Understanding Mocha
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we installed and introduced Mocha. Mocha is a JavaScript
    test framework that runs inside Node.js or inside a browser. You can use it to
    define and run your own tests. Mocha reports back on the outcome: which tests
    ran fine and which tests failed and where any failures occurred. Mocha runs each
    of the tests in turn, waiting for one test to finish or timeout before running
    the next one.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Even though Mocha is designed to be able to run on any modern browser, we will
    only be running it through Node.js via the command line. There are other things
    Mocha can do, which will be explained in this chapter. For a more complete reference
    to Mocha's capabilities, please visit Mocha's official documentation website,
    [http://visionmedia.github.com/mocha/](http://visionmedia.github.com/mocha/) to
    find out more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Describing features and using assertions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Mocha performs asynchronous tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to use Mocha to perform asynchronous
    tests and understand how Mocha controls test flow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two strategies you can use to organize your tests. The first is to
    divide them somehow into separate files, each file representing a functional or
    logical unit of your application. The other strategy, which can be used in tandem
    with the first one, is to group them by feature.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Having a separate file for each functional unit of your app is a good way of
    separating your testing concerns. You should analyze the structure of your application
    and separate it into distinct concerns that have a minimum amount of overlap.
    For instance, your application may have to deal with user registrations—that could
    be one functional group. Another functional group may be user login. If your application
    deals with to-do lists, you may want to have a separate file that contains the
    tests for that part of your application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: By having separate files for each functional group, you can call your tests
    in isolation while you're working on that particular group. This technique also
    allows you to keep the line count low on each file, which is helpful when you're
    navigating and maintaining your tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Describing features**: When defining your tests, you can also group application
    functionality by feature. For instance, when describing the to-do list functionality,
    you could further separate these features as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Creating a to-do item
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a to-do item
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the to-do list
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the order of to-do list items
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within our test scripts, we would describe the previously mentioned testable
    to-do features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of the to-do items test file could then be as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can nest as many `describe` statements as you wish, refining the scope
    of the tests as much as you want, but as a rule of thumb, you should use two description
    levels: one for the functional group (for instance, to-do items) and another level
    for each feature. Inside each feature definition, you can place all the relevant
    tests.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Using before and after hooks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any given group of tests, you can set certain pieces of code to run before
    or after all the tests. This can be useful for setting up databases, cleaning
    up some state after the tests, or generally, for setting up or tearing down some
    state that you need in order to run the test itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, the function named `runBefore` runs before any of the
    described tests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save this file code into a file named `test.js` and install Mocha locally:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the tests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It should give you the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a similar way, you can also specify a function to be executed after all
    the tests are done:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code produces the following output, as you might expect:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A function can also be defined to be called before (or after) each and every
    test in the block, using the `beforeEach` and `afterEach` keywords respectively.
    Sample usage of the `beforeEach` keyword is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run this test, the output will be:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Naturally, the `afterEach` code calls the function after each test is performed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous hooks
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any of these functions that you run before any or all your tests can be asynchronous.
    If a function is asynchronous, simply accept a callback argument like this one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When running this test code, you will notice the one-second lag before running
    each test, which—had we not provided the callback argument—would not have been
    observed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: How hooks interact with test groups
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve seen, inside a describe scope, you can have respective `before`,
    `after`, `beforeEach`, and `afterEach` hooks. If you have a nested `describe`
    scope, that scope can also have hooks. In addition to the hooks on the current
    scope, Mocha will also call the hooks on all the parent scopes. Consider this
    code where we declare a two-level nesting:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When running the preceding code, the output is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using assertions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a place for testing your code, you need some way of verifying
    that your code runs as expected. For this, you need an assertion testing library.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many assertion testing libraries for many programming styles, but
    here we''re going to use the one that already comes bundled with Node.js, the
    `assert` module. It contains the smallest set of utility functions you need to
    describe what expectations you have for each test. At the top of each testing
    file, you need the assertion library using `require`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can assert the "truthiness" of any expression. "Truthy" and "falsy" are
    concepts in JavaScript (and other languages), where type coercion allows certain
    values to equate to Boolean true or false, respectively. Some examples are as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The falsy values are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the empty string
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` (the number zero)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are truthy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test for equality using `assert.equal`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also conversely test for inequality using `assert.notEqual`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These last two tests are equivalent to the JavaScript `==` (loose equals) operator,
    which means that they work for Booleans, strings, `undefined`, and `null` but
    fail for objects and arrays. For instance, this assertion will fail:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It will fail because, in JavaScript, there is no native way to compare the
    equivalence of two objects rendering the following expression false:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To compare objects (including arrays), you should use `assert.deepEqual`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function recurses through both comparing objects to find whether they
    somehow differ. This function also works, as the name implies, for deeply nested
    objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also test for deep inequality:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Changing the assertion message
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an assertion fails, an error is thrown containing a message where both
    the expected and the actual values are printed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you wish, you can replace this default message type with another, more contextualized
    one. This is achieved by passing in the message as the last argument for any of
    the assertion functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Performing asynchronous tests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha runs all the tests in series, where each test can be synchronous or asynchronous.
    For a synchronous test, the test callback function should not accept any argument,
    as in the previous examples. But since Node.js doesn't block I/O operations, and
    we need to perform I/O operations for each of our tests (making at least an HTTP
    request to our server), our tests need to be asynchronous.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a test asynchronous, the test function should accept a callback function
    such as this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `done` callback function also accepts an error as the first argument, which
    means that instead of throwing an error, you can just call `done` directly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you don''t need to test the asynchronous function return value, you can
    pass the `done` function directly, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Timeouts**: By default, Mocha reserves 2 seconds for each asynchronous test.
    You can change that globally by passing in the `-t` argument to Mocha:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, you can use the number of seconds suffixed by `s`, as shown, or you can
    simply pass the number of milliseconds:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用以`s`为后缀的秒数，如所示，或者您可以简单地传递毫秒数：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also specify the timeout on any test by using `this.timeout(ms)` like
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`this.timeout(ms)`来指定任何测试的超时，就像这样：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Mocha is a framework that runs your tests. You should split your tests into
    several files according to the functional areas you want to cover, and then describe
    each feature and define the necessary tests for each feature.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是一个运行您的测试的框架。您应该根据您想要覆盖的功能区域将测试拆分为几个文件，然后描述每个功能并为每个功能定义必要的测试。
- en: For each of these test groups, you optionally specify callback to be invoked
    using `before`, `beforeEach`, `after`, and `afterEach`. These callbacks are where
    the setup and teardown functions are specified. Each of these teardown or setup
    functions can be either synchronous or asynchronous. Furthermore, each of the
    tests themselves can be made to function asynchronously simply by passing a callback
    to the test, which will be invoked once the test is complete.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些测试组中的每一个，您可以选择指定要使用`before`、`beforeEach`、`after`和`afterEach`来调用的回调函数。这些回调函数是指定设置和拆卸函数的地方。这些拆卸或设置函数中的每一个都可以是同步的或异步的。此外，这些测试本身也可以通过简单地将回调传递给测试来使其异步运行，一旦测试完成，回调就会被调用。
- en: For asynchronous tests, Mocha reserves a default timeout of 2 seconds that you
    can override globally or on a per-test basis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步测试，Mocha保留了默认的2秒超时，您可以在全局范围或每个测试的基础上进行覆盖。
- en: In the following chapter we will see how you can start using Zombie.js to simulate
    and manipulate a browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何开始使用Zombie.js来模拟和操纵浏览器。
