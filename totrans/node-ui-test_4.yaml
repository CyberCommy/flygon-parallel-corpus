- en: Chapter 4. Understanding Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we installed and introduced Mocha. Mocha is a JavaScript
    test framework that runs inside Node.js or inside a browser. You can use it to
    define and run your own tests. Mocha reports back on the outcome: which tests
    ran fine and which tests failed and where any failures occurred. Mocha runs each
    of the tests in turn, waiting for one test to finish or timeout before running
    the next one.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though Mocha is designed to be able to run on any modern browser, we will
    only be running it through Node.js via the command line. There are other things
    Mocha can do, which will be explained in this chapter. For a more complete reference
    to Mocha's capabilities, please visit Mocha's official documentation website,
    [http://visionmedia.github.com/mocha/](http://visionmedia.github.com/mocha/) to
    find out more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing features and using assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Mocha performs asynchronous tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to use Mocha to perform asynchronous
    tests and understand how Mocha controls test flow.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two strategies you can use to organize your tests. The first is to
    divide them somehow into separate files, each file representing a functional or
    logical unit of your application. The other strategy, which can be used in tandem
    with the first one, is to group them by feature.
  prefs: []
  type: TYPE_NORMAL
- en: Having a separate file for each functional unit of your app is a good way of
    separating your testing concerns. You should analyze the structure of your application
    and separate it into distinct concerns that have a minimum amount of overlap.
    For instance, your application may have to deal with user registrations—that could
    be one functional group. Another functional group may be user login. If your application
    deals with to-do lists, you may want to have a separate file that contains the
    tests for that part of your application.
  prefs: []
  type: TYPE_NORMAL
- en: By having separate files for each functional group, you can call your tests
    in isolation while you're working on that particular group. This technique also
    allows you to keep the line count low on each file, which is helpful when you're
    navigating and maintaining your tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Describing features**: When defining your tests, you can also group application
    functionality by feature. For instance, when describing the to-do list functionality,
    you could further separate these features as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a to-do item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a to-do item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the to-do list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the order of to-do list items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within our test scripts, we would describe the previously mentioned testable
    to-do features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of the to-do items test file could then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest as many `describe` statements as you wish, refining the scope
    of the tests as much as you want, but as a rule of thumb, you should use two description
    levels: one for the functional group (for instance, to-do items) and another level
    for each feature. Inside each feature definition, you can place all the relevant
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Using before and after hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any given group of tests, you can set certain pieces of code to run before
    or after all the tests. This can be useful for setting up databases, cleaning
    up some state after the tests, or generally, for setting up or tearing down some
    state that you need in order to run the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, the function named `runBefore` runs before any of the
    described tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file code into a file named `test.js` and install Mocha locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, you can also specify a function to be executed after all
    the tests are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code produces the following output, as you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can also be defined to be called before (or after) each and every
    test in the block, using the `beforeEach` and `afterEach` keywords respectively.
    Sample usage of the `beforeEach` keyword is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this test, the output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, the `afterEach` code calls the function after each test is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any of these functions that you run before any or all your tests can be asynchronous.
    If a function is asynchronous, simply accept a callback argument like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When running this test code, you will notice the one-second lag before running
    each test, which—had we not provided the callback argument—would not have been
    observed.
  prefs: []
  type: TYPE_NORMAL
- en: How hooks interact with test groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve seen, inside a describe scope, you can have respective `before`,
    `after`, `beforeEach`, and `afterEach` hooks. If you have a nested `describe`
    scope, that scope can also have hooks. In addition to the hooks on the current
    scope, Mocha will also call the hooks on all the parent scopes. Consider this
    code where we declare a two-level nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the preceding code, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a place for testing your code, you need some way of verifying
    that your code runs as expected. For this, you need an assertion testing library.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many assertion testing libraries for many programming styles, but
    here we''re going to use the one that already comes bundled with Node.js, the
    `assert` module. It contains the smallest set of utility functions you need to
    describe what expectations you have for each test. At the top of each testing
    file, you need the assertion library using `require`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can assert the "truthiness" of any expression. "Truthy" and "falsy" are
    concepts in JavaScript (and other languages), where type coercion allows certain
    values to equate to Boolean true or false, respectively. Some examples are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The falsy values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` (the number zero)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are truthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test for equality using `assert.equal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also conversely test for inequality using `assert.notEqual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These last two tests are equivalent to the JavaScript `==` (loose equals) operator,
    which means that they work for Booleans, strings, `undefined`, and `null` but
    fail for objects and arrays. For instance, this assertion will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It will fail because, in JavaScript, there is no native way to compare the
    equivalence of two objects rendering the following expression false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare objects (including arrays), you should use `assert.deepEqual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This function recurses through both comparing objects to find whether they
    somehow differ. This function also works, as the name implies, for deeply nested
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also test for deep inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Changing the assertion message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an assertion fails, an error is thrown containing a message where both
    the expected and the actual values are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish, you can replace this default message type with another, more contextualized
    one. This is achieved by passing in the message as the last argument for any of
    the assertion functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Performing asynchronous tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha runs all the tests in series, where each test can be synchronous or asynchronous.
    For a synchronous test, the test callback function should not accept any argument,
    as in the previous examples. But since Node.js doesn't block I/O operations, and
    we need to perform I/O operations for each of our tests (making at least an HTTP
    request to our server), our tests need to be asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a test asynchronous, the test function should accept a callback function
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `done` callback function also accepts an error as the first argument, which
    means that instead of throwing an error, you can just call `done` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t need to test the asynchronous function return value, you can
    pass the `done` function directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Timeouts**: By default, Mocha reserves 2 seconds for each asynchronous test.
    You can change that globally by passing in the `-t` argument to Mocha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can use the number of seconds suffixed by `s`, as shown, or you can
    simply pass the number of milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the timeout on any test by using `this.timeout(ms)` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is a framework that runs your tests. You should split your tests into
    several files according to the functional areas you want to cover, and then describe
    each feature and define the necessary tests for each feature.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these test groups, you optionally specify callback to be invoked
    using `before`, `beforeEach`, `after`, and `afterEach`. These callbacks are where
    the setup and teardown functions are specified. Each of these teardown or setup
    functions can be either synchronous or asynchronous. Furthermore, each of the
    tests themselves can be made to function asynchronously simply by passing a callback
    to the test, which will be invoked once the test is complete.
  prefs: []
  type: TYPE_NORMAL
- en: For asynchronous tests, Mocha reserves a default timeout of 2 seconds that you
    can override globally or on a per-test basis.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter we will see how you can start using Zombie.js to simulate
    and manipulate a browser.
  prefs: []
  type: TYPE_NORMAL
