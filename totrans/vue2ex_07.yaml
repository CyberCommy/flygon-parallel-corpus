- en: Pre-Caching Other Folders and Files for Faster Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the last of this section, we are going to look at speeding
    up our Dropbox file explorer further by introducing, even more, caching to the
    app. So far, we have built an app that can query the Dropbox API, and return files
    and folders. From there, we added folder navigation, including updating the URL
    for link sharing and being able to use the back and forward buttons. With that
    in place, in [Chapter 6](part0103.html#3279U0-985bf4ae118d4f62b18ae64204cb251c), *Caching
    the Current Folder Structure Using Vuex*, we introduced Vuex for storing the current
    folder path and the contents of the folders we had visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-caching not only the folder the user is currently in but also the child
    folders. This will be done by looping through the folders in the current display
    and checking if they have been cached yet. If not, we can gather the data from
    the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the parent folder's contents, should the user have entered via a direct
    URL. This will be done by utilizing the breadcrumb path to traverse up the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache the download links for the files. This currently requires an API for every
    file encountered, regardless of whether the folder has been cached by our code
    or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these improvements, we can ensure the app only contacts the API once for
    every item, rather than the countless times it was originally doing.
  prefs: []
  type: TYPE_NORMAL
- en: Caching subfolders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With both the subfolder and parent folder caching, we won't necessarily be writing
    new code, but reorganizing and repurposing the existing code into a more modular
    system, so that each part can be called separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flowchart should help you visualize the steps required to cache
    the current folder and subfolders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When looking at the flowchart, you can immediately see some duplication in events
    required for the app. At two points the app needs to decide whether a folder exists
    in the cache and, if it does not, query the API to get the data and store the
    result. Although it appears only twice on the flowchart, this functionality is
    required several times, once for every folder in the current location.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to separate out our displaying logic from our querying and
    storing logic, as we may need to load from the API and store, without updating
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: Planning app methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the previous section in mind, we can take the opportunity to revise and
    refactor the methods on our `dropbox-viewer` app, ensuring each action has its
    own method. This would allow us to call each action as and when we want to. Before
    we head into the code, let's plan out the methods we need to create based on the
    preceding flowchart.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that every time the API is queried, we need to store
    the result in the cache. As we don't need to store anything in the cache *unless*
    the API is called, we can combine these two actions in the same method. We also
    often need to check whether there are contents in the cache for a particular path
    and either load it or retrieve it from the API. We can add this to its own method
    that returns the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s map out the methods we need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getFolderStructure`: This method will accept a single parameter of the path
    and return an object of the folder entries. This will be responsible for checking
    if the data is in the cache and, if not, querying the Dropbox API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayFolderStructure`: This method will fire the preceding function and
    use the data to update the `structure` object on the component to display the
    files and folders in the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheFolderStructure`: This method will include the `getFolderStructure` method
    to cache each subfolder—we''ll explore a couple of ways this can be triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We may need to create more methods than this, but these three will be the backbone
    of the component. We will keep the path and slug-computed properties, along with
    the `dropbox()` method. Remove the rest of the objects, methods, and functions
    so your `dropbox-viewer` is back to basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating the getFolderStructure method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new method on your component called `getFolderStructure`. As mentioned
    previously, this method needs to accept a single path parameter. This is so we
    can use with both the current path and children paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This method needs to check the cache and return the data. Make a new variable,
    titled `output`, inside the method and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When caching the data in [Chapter 6](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=82&action=edit#post_71), *Caching
    the Current Folder Structure Using Vuex*, we were using the `slug` as the key
    in the store. The `slug` was generated by using the current path; however, we
    cannot use this in the new methods as it is fixed to its current location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method called `generateSlug`. This will accept one parameter,
    the path, and return a converted string using the replacements from the slug-computed
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can now delete the computed `slug` function, so we don't have any repeating
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our `getFolderStructure` method, create a new variable that stores
    the slug version of the path using the new method. For this, we are going to use
    `const` to create a variable that cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last variable we will create is the data path, as we did in [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c),
    *Introducing Vue-Router and Loading URL-Based Components*. This will use the new
    `slug` variable we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `data` `if` statement from the previous code inside of here,
    with space for the Dropbox function call. We can assign the `data` to `output`
    straight away if it exists in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the Dropbox API call, however, we can tweak it to suit this new code. Previously,
    it was retrieving the data from the API and then firing a method that then saved
    and displayed the structure. As we need to store the data retrieved in the `output`
    variable, we are going to alter the flow of data. Instead of firing a method,
    we are going to use this opportunity to first store the response in the cache
    and then return the data to the `output` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we only use the entries from the API call, we are also going to update the
    store to only cache this part of the response. This will reduce the code and complexity
    of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Dropbox `filesListFolder` method uses the passed-in `path` variable, rather
    than the global one it was previously using. The entries from the response are
    then stored in a variable before being cached in the Vuex store using the same
    mutation. The `entries` variable is then returned from the promise, which stores
    the result in `output`. The `catch()` function is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: With the data being returned from either the cache or the API, we can trigger
    and process this data when the component is created and when the path is updated.
    Before we do that, however, we have a mix of data types to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'When returned from the API, the data is still a promise that needs to be resolved;
    assigning it to a variable merely passes on the promise to be resolved later.
    Data from the store, however, is a plain array that is handled very differently.
    To give us a single data type to deal with, we are going to `resolve` the stored
    array as a promise, meaning the `getFolderStructure` returns a promise, regardless
    of where the data is loaded from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this `getFolderStructure` method, we now have the ability to load some
    data from the API and store the result in the global cache without updating the
    view. The function does, however, return the information should we wish to process
    it further with a JavaScript promise.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed with creating our next method, `displayFolderStructure`,
    which will take the result of the method we have just created and update our View,
    so the app is navigable once again.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the data with the displayFolderStructure method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our data now ready to be cached and served up from the store, we can go
    ahead and actually *display* the data with our new method. Create a new method
    in your `dropbox-viewer` component labeled `displayFolderStructure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method will borrow a lot of code from the previous incarnation of this
    component. Remember, this method is used purely for displaying the folder and
    has nothing to do with caching the contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of the method will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the loading state as `active` in the app. This lets the user know something
    is happening.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty `structure` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the contents of the `getFolderStructure` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through the result and add each item to either the `folders` or `files`
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the global structure object to the new one created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the loading state to `false` so the contents can be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the loading state to true and create an empty structure object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step of this method is to hide the structure tree and show the loading
    message. This can be done as before, by setting the `isLoading` variable to `true`.
    We can also create our empty `structure` object here, ready to be populated by
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Load the contents of the getFolderStructure method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the `getFolderStructure` method returns a promise, we need to resolve the
    result before proceeding on to manipulate it. This is done with the `.then()`
    function; we have already used this with the Dropbox class. Call the method and
    then assign the result to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code passes the `path` object of the component into the method. This path
    is the *current* path that the user is trying to view. Once the data is returned,
    we can assign it to the `data` variable, which can then be used inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Loop through the result and add each item to either the folders or files array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with the code that loops through the entries and examines
    the `.tag` attribute of each one. If this results in a folder, it is added to
    the `structure.folders` array, otherwise it is appended to `structure.files`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only storing the entries in the cache, so make sure the `for` loop is
    updated to use the data as is, rather than accessing the property of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Update the global structure object and remove the loading state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last task in this method is to update the global structure and remove the
    loading state. This code is unchanged from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We now have a method that will display the result of our data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Instigating the method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method can now be called when the `dropbox-viewer` component gets created.
    The path will already be populated, thanks to the `created` function on the global
    Vue instance that commits the URL hash to the store, thus creating the path variable.
    Because of this, we don''t need to pass anything to the function. Add the `created`
    function to your component and call the new method inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Refreshing the app now will load your folder contents. Updating the URL hash
    and reloading the page will also show the contents of that folder; however, clicking
    any folder links will update the breadcrumb, but not the data structure. This
    can be resolved by watching the computed `path` variable. This will get updated
    when the hash updates and so can trigger a function in the `watch` object. Add
    a function that watches for the `path` variable to update and fires the new method
    when it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have created an app that, once again, caches any folder you have
    visited. Clicking through the structure the first time will seem quite slow, but
    once you navigate back up the tree and re-enter subfolders you will barely see
    the loading screen.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the app having the same functionality as it did at the beginning of
    the chapter, we have refactored the code to separate out the retrieval and caching
    and the displaying of the data. Let's move on to enhancing our app further by
    pre-caching the subfolders of the selected path.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the subfolders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the ability to cache a folder without updating the Vue, we
    can use our `structure` object to get the contents of the subfolders. Using the
    `folders` array in the `structure` object, we can loop through this and cache
    each folder in turn.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure we do not hinder the performance of the app; the caching
    must be done asynchronously, so the user is not aware of this process. We also
    need to make sure we aren't running the caching unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can watch the `structure` object. This only gets updated
    once the data has been loaded from the cache or the API and the Vue has updated.
    With the user viewing the contents of the folder, we can proceed with looping
    through the folders to store their contents.
  prefs: []
  type: TYPE_NORMAL
- en: There is a slight issue, however. If we watch the `structure` variable, our
    code will never run as the direct *contents* of the object does not update, despite
    the fact we replace the `structure` object with a new one every time. From folder
    to folder, the structure object always has two keys, of `files` and `folders`,
    which are both arrays. As far as Vue and JavaScript are concerned, the `structure`
    object never changes.
  prefs: []
  type: TYPE_NORMAL
- en: Vue can, however, detect nested changes with the `deep` variable. This can be
    enabled on a per variable basis. Similar to the props on a component, to enable
    more options on a watch property, you pass it an object instead of a direct function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `watch` key for structure, which is an object with two values, `deep`
    and `handler`. The `deep` key will be set to `true`, while the `handler` will
    be the function fired when the variable is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `handler`, we can now loop through each of the folders and run
    the `getFolderStructure` method for each one, using the `path_lower` property
    of each one as the function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this simple piece of code, our app appears to speed up tenfold. Every
    subfolder you navigate to loads instantly (unless you have a particularly long
    folder list and you navigate to the last one very quickly). To give you an idea
    of the speed and timing of the caching, add a `console.log()` inside your `getFolderStructure`
    method and open the browser developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to see all the API calls are done asynchronously too—the app
    isn't waiting for the previous folder to be loaded and cached before moving on
    to the next one. This has the advantage of allowing smaller folders to be cached
    without waiting for bigger ones to be returned from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative caching method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with everything, when making an app, there are many approaches to achieving
    the same result. The downside with this method is that even if your folder contains
    only files, this function will trigger—albeit with nothing to do.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach would be to use our `created` function once again, this
    time on the `folder` component itself, triggering the parent method with the path
    as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: One way of doing this is using the `$parent` property. When in the `folder`
    component, using `this.$parent` will allow access to the variables, methods, and
    computed values on the `dropbox-viewer` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `created` function to the `folder` component and delete the `structure`
    `watch` property from the Dropbox component. From there, call the parent `getFolderStructure`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Previewing the app proves the validity of this method. Only triggering when
    there are folders in the structure, this cleaner technique ties the folder-caching
    with the folder itself, rather than getting mixed in with the Dropbox code.
  prefs: []
  type: TYPE_NORMAL
- en: However, `this.$parent` should be avoided unless necessary, and should only
    be used in edge cases. As we have the opportunity to use props, we should do so.
    It also gives us the chance to give the function a more meaningful name in the
    folder context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your HTML view and update the folder component to accept a new
    prop. We''ll call the prop cache and pass the function in as the value. As the
    property is dynamic, don''t forget to add a preceding colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `cache` keyword to the props key in the JavaScript `folder` component.
    Inform Vue that the input will be a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can call our new `cache()` method in the `created` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The caching can be verified, once again, by using the console logs as before.
    This creates cleaner code that is easier for yourself, and any other developers, to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: With our Dropbox app now progressing, we can move on to caching parent folders,
    should you enter a subfolder using a hash in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Caching parent folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching the parent structure is the next preemptive thing we can do to help
    speed up our app. Say we had navigated to our images directory,img/holiday/summer`,
    and wished to share this with a friend or colleague. We would send them the URL
    with this in the URL hash and, on page load, they would see the contents. If they
    then navigated up the tree using the breadcrumb toimg/holiday`, for example, they
    would need to wait for the app to retrieve the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `breadcrumb` component, we can cache the parent directories and so,
    on navigating to the `holiday` folder, the user would be presented instantly with
    its contents. While the user is then browsing this folder, all of its subfolders
    are being cached with the previous methods.
  prefs: []
  type: TYPE_NORMAL
- en: To cache the parent folders, we already have a component displaying the path
    with access to the slugs of all the parent folders we can loop through—the breadcrumb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start the caching process, we need to update the `folders` computed
    function within the component. This is because currently, we store the path with
    the hash prepended, which creates an invalid path for the Dropbox API. Remove
    the hash from the object being pushed to the output array and add it in the template,
    in a similar fashion to the `folder` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the output for both displaying the breadcrumb and caching the
    parent structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to allow the `breadcrumb` component access to the caching
    function. In a similar fashion to the `folder` component, add the function as
    a prop to the `breadcrumb` component in your View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `props` object to the component in the JavaScript code. Declare the
    `cache` prop as a function so Vue knows what to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The parent structure is going to be on the creation of the `breadcrumb` component.
    However, as we don't want this to hold up the loading process, we are going to
    trigger it when the component is `mounted`, not `created`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `mounted` function to your component and assign the folder''s computed
    value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We now need to start caching the folders; however, we can be smart in the order
    that we do it. We can assume that the user will generally go back up the folder
    tree, so we should ideally cache the direct parent before moving onto its parent,
    and so on and so forth. As our folder's variable goes from the top down, we need
    to reverse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing we can do to improve performance is to remove the current folder;
    as we are already in it, the app would have cached it already. In your component,
    reverse the array and remove the first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add a console log to the function of the parent''s variable, we can see
    it contains the folders we now wish to cache. We can now loop through this array,
    calling the `cache` function for each item in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this, our parent and child folders are being cached by the app, making
    navigation both up and down the tree lightning fast. However, running a `console.log()`
    inside the `mounted` function reveals the breadcrumb gets re-mounted every time
    a folder gets navigated to. This is because of the `v-if` statements in the View,
    which removes and adds the HTML each time.
  prefs: []
  type: TYPE_NORMAL
- en: As we only need to cache the parent folders once, on initial app load, let's
    look at changing where it gets triggered. We only need to run this function the
    first time; once the user has started navigating up and back down the tree, all
    the folders visited will be cached along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Caching parent folders once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure we are using the least amount of resources, we can keep the array
    of folders used for the breadcrumb in the store. This means that both the `breadcrumb`
    component and our parent caching function can access the same array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `breadcrumb` key to your store state—this is where we will store the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, move the code from the `breadcrumb` component into the `updateHash` mutation
    so we can update both the `path` and `breadcrumb` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that rather than returning the `output` array, it is getting stored in
    the `state` object. We can now update the folder''s computed function on the `breadcrumb`
    component to return the store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With the data now available globally, we can create a new method on the `dropbox-viewer`
    component, `cacheParentFolders`, which triggers the code we wrote for the `breadcrumb`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method on the `Dropbox` component and move your code to it. Update
    the location of the parents and ensure you are firing the correct path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now fire this method once when the Dropbox component gets created. Add
    it after the existing method call in the `created` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now do some housekeeping and delete the `mounted` method from the `breadcrumb`
    component, along with the `props` object and the `:cache` prop from the view.
    This means our `breadcrumb` component is now simpler than it was before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML returns to what it was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also tidy up the `updateHash` mutation in the store to be a bit neater
    and more understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All the variables are now being declared at the top, with the `state` being
    updated at the bottom. The number of variables has also been reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the app now, it appears to work correctly; however, upon closer inspection,
    the `breadcrumb` seems to lag a bit with the folder structure on initial page
    load. Once a folder has been navigated to, it catches up but on the first load
    it seems to have one fewer item, and when viewing the root of the Dropbox none
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the store has not been fully initialized before we are committing
    the `updateHash` mutation. If we remember back to the Vue instance life cycle,
    covered in Chapter 4, *Getting a List of Files Using the Dropbox API*, we can
    see the created function gets fired very early on. Updating the main Vue instance
    to trigger the mutation on `mounted` instead resolves the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With all the folders being cached as well as they can be, we can move on to
    caching more API calls by storing the download link for each file.
  prefs: []
  type: TYPE_NORMAL
- en: We could also look into caching subfolders of subfolders, looping through the
    contents of each cached folder to eventually cache the whole tree. We won't go
    into that, but feel free to give it a go yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Caching download links on files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user is navigating around the document tree, the Dropbox API is still
    being queried more than necessary. This is because every time a file is displayed,
    we query the API to retrieve the download link. Extra API queries can be negated
    by storing the download link response in the cache and re-displaying the folder
    it is navigated back into.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a file is displayed, a new component gets initialized using data
    from the store. We can use this to our advantage as it means we only need to update
    the component instance and then the result gets cached.
  prefs: []
  type: TYPE_NORMAL
- en: In your file component, update the API response to not only save the result
    on the `link` property of the data attribute but the on the file instance, `f`,
    as well. This will be stored as a new key, `download_link`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When storing the data, rather than having two separate commands, we can combine
    them into one with two equal signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This essentially means `this.f.download_link` is equal to `this.link`, which
    is also equal to `data.link`, the download link from the API. With this being
    stored and displayed when the folder is navigated to, we can add an `if` statement
    to see whether the data exists and, if not, query the API to get it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Doing this on file creation saves the API being queried unnecessarily. If we
    obtained this information when caching the folders, we could slow down the app
    and be storing non-essential information. Imagine a folder with hundreds of photos
    in it—we wouldn't want to query the API for every one of these just on the off
    chance the user might enter that folder.
  prefs: []
  type: TYPE_NORMAL
- en: This means everything in our app only needs to query the API once to get the
    information. The user can navigate up and down folder structures as many times
    as they want, with the app only getting faster as they do so.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code—with added documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our app complete, we can now add some much-needed documentation. It's always
    good to document your code as this gives it reasoning and explanation. Good documentation
    should not just say what the code does, but why it does it, what is allowed, and
    what is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular method for documentation is the JavaScript DocBlock standard. This
    set of conventions lays out style guide-like rules for you to follow when documenting
    your code. DocBlock is formatted in a comment block and features keywords starting
    with an `@`, such as `@author`, `@example`, or listing what parameters a function
    can accept with the `@param` keyword. An example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Starting off with a description, DocBlock has several keywords to help lay out
    the documentation. We'll walk through our completed Dropbox app with added documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first take a look at the `breadcrumb` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the `folder` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in line, we see the `file` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we take a look at the `dropbox-viewer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us also check the Vuex store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We furthermore move to the Vue app*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the end, we go through the `window.onhashchange` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the HTML from the view looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And the template for the Dropbox viewer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You will notice not *everything* has been documented. A simple function or variable
    assignment doesn't need to re-explain what it does, but a note of the main variables
    will help anyone looking at it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of the book, we've covered quite a lot! We started with querying
    the Dropbox API to get a list of files and folders. We then moved on to adding
    navigation, allowing the user to click on folders and download files. We then
    introduced Vuex and the store into our app, which meant we could centralize the
    path, breadcrumb, and most importantly, cache the folder contents. Lastly, we
    looked at caching sub-folders and the file download link.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we are going to look at making a shop. This
    will include browsing products in a category and product pages using a new Vue
    plugin called Vue router. We will also look at adding products to a basket and
    storing both the product list and preferences in the Vuex store.
  prefs: []
  type: TYPE_NORMAL
