- en: Chapter 4. Creating and Calling Subroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows how to create and call subroutines in a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Show some simple subroutines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show more advanced routines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mention return codes again and how they work in scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapters we have seen mostly simple scripts that were not very
    complicated. Scripts can actually do a whole lot more which we are about to see.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start with a selection of simple but powerful scripts. These are
    mainly shown to give the reader an idea of just what can be done quickly with
    a script.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tput clear` terminal command can be used to clear the current command-line
    session. You could type `tput clear` all the time, but wouldn't just `cls` be
    nicer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple script that clears the current screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this was so simple I didn''t even bother to include a `Usage` message
    or return code. Remember, to make this a command on your system do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd $HOME/bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create/edit a file named `cls`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: copy and paste the preceding code into this file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: save the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run `chmod 755 cls`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can now type `cls` from any terminal (under that user) and your screen will
    clear. Try it.
  prefs: []
  type: TYPE_NORMAL
- en: File redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we need to go over file redirection. This is the ability to have
    the output from a command or script be copied into a file instead of going to
    the screen. This is done by using the redirection operator, which is really just
    the greater than sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot of some commands that were run on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File redirection](img/B07040_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the output from the `ifconfig` command was sent (or redirected)
    to the `ifconfig.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Command piping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at command piping, which is the ability to run a command and
    have the output from it serve as the input to another command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose a program or script named `loop1` is running on your system and you
    want to know the PID of it. You could run the `ps auxw` command to a file, and
    then `grep` the file for `loop1`. Alternatively, you could do it in one step by
    using a pipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command piping](img/B07040_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pretty cool, right? This is a very powerful feature in a Linux system and is
    used extensively. We will be seeing a lot more of this soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section shows another very short script using some command piping.
    This clears the screen and then shows only the first 10 lines from `dmesg`:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 4 - Script 2](img/B07040_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next section shows file redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Try it on your system.
  prefs: []
  type: TYPE_NORMAL
- en: This shows how easy it is to create a script to perform commands that you would
    normally type on the command line. Also notice the use of the `FN` variable. If
    you want to use a different filename later, you only have to make the change in
    one place.
  prefs: []
  type: TYPE_NORMAL
- en: Subroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s really get into subroutines. To do this we will use more of the
    `tput` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here is the script. This was mainly written to show the concept of a subroutine,
    however, it can also be used as a guide on writing interactive tools.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 4 - Script 4](img/B07040_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try this on your system. If you run it with the `home` parameter it might look
    a little strange to you. The code puts a capital `X` at the `home position` (0,0)
    and this causes the prompt to print one character over. Nothing is wrong here,
    it just looks a little weird. Don't worry if this still doesn't make sense to
    you, just go ahead and look at *Script 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Using parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, let''s add some routines to this script to show how to use parameters
    with a `subroutine`. In order to make the output look better the `cls` routine
    is called first to clear the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this script only has two extra functions you can just run them. This
    will be shown one command at a time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Chapter 4 - Script 5](img/B07040_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Chapter 4 - Script 5](img/B07040_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Chapter 4 - Script 5](img/B07040_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we are now placing the cursor at a specific location, the output should
    make more sense to you. Notice how the command-line prompt reappears where the
    last cursor position was.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that the parameters to a subroutine work just like with
    a script. Parameter 1 is `$1`, parameter 2 is `$2`, and so on. This is good and
    bad, good because you don't have to learn anything radically different. But bad
    in that it is very easy to get the `$1`, `$2`, vars mixed up if you are not careful.
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution, and the one I use, is to assign the `$1`, `$2`, and so
    on variables in the main script to a variable with a good meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in these example scripts I set `parm1` equal to `$1 (parm1=$1)`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a good look at the script in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Script 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And here's the output
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 4 - Script 6](img/B07040_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are some new concepts here and so we will go through this one very carefully.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the subroutines. Notice that a return code has been added.
    A `cls` routine has also been included so that a return code could be shown.
  prefs: []
  type: TYPE_NORMAL
- en: We are now at the start of the code. The `cls` routine is called and then the
    return value from it is stored in the `rc` variable. Then the `echo` statement
    showing which script this is will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: So, why did I have to put the return code from the `cls` command into the `rc`
    var? Couldn't I have just displayed it after the `echo` of the script title? No,
    because the `echo $?` always refers to the command immediately preceding it. This
    is easy to forget so make sure you understand this point.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so now we reset the `rc` var to `0` and continue on. I could have used
    a different variable for this, but since the value of `rc` is not going to be
    needed again I chose to just reuse the `rc` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the check for parameters, the `Usage` statement will be displayed if
    three parameters are not there.
  prefs: []
  type: TYPE_NORMAL
- en: After three parameters are entered we display them. This is always a good idea
    especially when first writing a script/program. You can always take it out later
    if it is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: The first subroutine, `sub1`, is run with `1` parameter. This is checked and
    an error is displayed if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happens with `sub2`, but in this case I intentionally set it
    to run with only one parameter so that the error message would be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: For `sub3`, you can see that the main parameters are still accessible from a
    subroutine. In fact, all of the named variables are, and also the wildcard `*`
    and other file expansion tokens. Only the main script parameters cannot be accessed,
    which is why we put them into variables.
  prefs: []
  type: TYPE_NORMAL
- en: The final routine was created in order to show how errors can be handled. You
    can see that the `tput` command itself displayed the error, and then we also captured
    it in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the script exits with the main `rc` variable.
  prefs: []
  type: TYPE_NORMAL
- en: As was mentioned earlier, this script has a lot in it so be sure to study it
    carefully. Note that when I wanted to show an error in `tput`, I just assumed
    that `firephasers` was going to be an unknown command. I would have been rather
    surprised if some phasers had actually shot out of (or worse, into) my computer!
  prefs: []
  type: TYPE_NORMAL
- en: Making a current backup of your work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And now, for another bonus the next section shows the script I used to backup
    my current book''s chapter every 60 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 – Script 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And for the output on my system
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 4 – Script 7](img/B07040_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's not much in this script that we have not already covered. The informal
    comments at the top are mainly for me, so that I don't forget what I wrote or
    why.
  prefs: []
  type: TYPE_NORMAL
- en: The parms are checked and the back subdirectory is created if it does not already
    exist. I never seem to be able to remember to create it, so I let the script do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the main variables are set up and then the `.bak` file is created if it
    doesn't exist (this helps with the logic).
  prefs: []
  type: TYPE_NORMAL
- en: In the `while` loop, which you can see runs forever, the `cmp` Linux command
    is used to see if the original file has changed from the backup file. If so, the
    `cmp` command returns non-zero and the file is copied back to the `subdir` as
    a numbered backup using our `cbS` script. The file is also copied to the backup
    directory, which in this case is my USB drive. The loop continues until I start
    a new chapter, in which case I press *Ctrl* + *C* to quit.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of script automation, which will be covered in more detail
    in [Chapter 6](ch06.html "Chapter 6. Automating Tasks with Scripts"), *Automating
    Tasks with Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started with some very simple scripts and then proceeded to show some simple
    subroutines.
  prefs: []
  type: TYPE_NORMAL
- en: We then showed some subroutines that take parameters. Return codes were mentioned
    again to show how they work in subroutines. We including several scripts to show
    the concepts, and also included a special bonus script at no extra charge.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will go over how to create interactive scripts.
  prefs: []
  type: TYPE_NORMAL
