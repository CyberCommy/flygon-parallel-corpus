- en: Chapter 2. Getting Started with Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gives us the basic knowledge that we need to set up a web application
    project and manage our entities by using Spring Data JPA. In the course of this
    chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use **Maven** for downloading the required dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use **programmatic configuration** for configuring the Spring **application
    context**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure our web application to load the Spring application context
    by using programmatic configuration (without using `web.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement **CRUD** (**Create**, **Read**, **Update,** and **Delete**)
    functions for an entity class with Spring Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading dependencies with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book covers the 1.2.0.RELEASE version of Spring Data JPA, which is the
    newest available version during the authoring of this book. The other components
    required by Spring Data JPA are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Description | Version |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Data source | BoneCP is a fast connection pool library that is used as a
    data source for our application. | 0.7.1.RELEASE |'
  prefs: []
  type: TYPE_TB
- en: '| JPA provider | A JPA provider is a library that implements the Java Persistence
    API. We will use Hibernate as a JPA provider. | 4.1.4.Final |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Framework | Spring Framework is used to develop modern enterprise
    applications with Java. | 3.1.2.RELEASE |'
  prefs: []
  type: TYPE_TB
- en: '| Database | H2 is an embedded in-memory database that supports standard SQL
    and the JDBC API. | 1.3.166 |'
  prefs: []
  type: TYPE_TB
- en: We will use the newest available version of our application's other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download the required dependencies with Maven by declaring them in the
    `POM` file. In order to do this, we have to add the following dependency declarations
    to the dependencies section of the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring application context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, we would use declarative configuration with XML configuration
    files, but after Spring Framework 3.0 was released, it has been possible to configure
    the Spring application context by using programmatic configuration. This is our
    weapon of choice when we are configuring the application context of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the Spring application context by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a properties file for the values of the configuration parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the application context configuration class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the properties file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The actual values of the configuration parameters are stored in a properties
    file called `application.properties`. This file contains database connection details,
    Hibernate configuration, and the base package of our entities. The content of
    this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the application context configuration class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create the application context configuration class by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an application context configuration skeleton that contains the general
    configuration of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the data source bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the entity manager factory bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the transaction manager bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the application context configuration skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The steps that are needed to create a skeleton configuration class of the Spring
    application context are described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Configuration` annotation identifies the class as an application context
    configuration class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component scanning directives are configured with the `@ComponentScan` annotation.
    In our example, the Spring IoC container is configured to scan the packages containing
    our controller and service classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@EnableJpaRepositories` annotation is used to enable Spring Data JPA and
    configure the base package of our repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@EnableTransactionManagement` annotation enables the annotation-driven
    transaction management of Spring Framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@EnableWebMcv` annotation imports the default configuration of Spring MVC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The properties file containing the values of the configuration parameters is
    imported by using the `@PropertySource` annotation. We can access the property
    values stored in this file by using the implementation of the `Environment` interface
    that is injected by the Spring IoC container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our application context configuration skeleton is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also configure Spring Data JPA by using XML. We can do this by adding
    the `repositories` namespace element of Spring Data JPA to our application context
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the data source bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start the configuration of the data source bean by adding a `dataSource()`
    method to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. The implementation of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `BoneCPDataSource` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the database connection details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration of the data source bean is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the entity manager factory bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure the entity manager factory bean by adding a method called
    `entityManagerFactory()` to the `ApplicationContext` class and annotating that
    method with the `@Bean` annotation. The implementation of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `LocalContainerEntityManagerFactoryBean` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass a reference of the used data source bean to the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the default configuration of Hibernate to the entity manager factory bean.
    We can do this by creating a new `HibernateJpaVendorAdapter` object and passing
    it to the entity manager factory bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the base package of our entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the additional configuration that is fetched from our properties file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the created method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the transaction manager bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure the transaction manager bean by adding a `transactionManager()`
    method to the `ApplicationContext` class and annotating this method with the `@Bean`
    annotation. The implementation of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `JpaTransactionManager` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a reference of the used entity manager factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the transaction manager bean configuration is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Loading the application context configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The old way to load the application context configuration of our application
    is to use the **web application deployment descriptor** file, which is more commonly
    known as `web.xml`. However, because we are using the Spring Framework 3.1 in
    a Servlet 3.0 environment, we can create a web application configuration class
    by implementing the `WebApplicationInitializer` interface. This ensures that Spring
    Framework automatically detects our configuration class when a servlet container
    is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use our web application configuration class to:'
  prefs: []
  type: TYPE_NORMAL
- en: Load our application context configuration class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the **dispatcher servlet**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the **context loader listener** and add it to our **servlet context**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our configuration class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implementing CRUD functionality for an entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now configured the Spring application context and configured our web
    application to load it during startup. We will now implement CRUD functions for
    a simple entity. Our example application is used to view and manage contact information,
    and we can implement it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a domain model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository for an entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement CRUD functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter describes only such parts of our application that are required
    to understand how Spring Data JPA works.
  prefs: []
  type: TYPE_NORMAL
- en: Domain model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The domain model of our application consists of two classes: `Contact` and
    `Address`. This subsection will address the following matters:'
  prefs: []
  type: TYPE_NORMAL
- en: The information content of each class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How we can create new objects by using the **builder pattern** (see also: *Effective
    Java* (*Second Edition*), *Joshua Bloch*, *Addison-Wesley*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can update the information of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Contact` class is the only entity of our domain model and it contains
    the information of a single contact. This information consists mostly of simple
    properties. The only exception to this rule is the `Address` class that is used
    to store address information. The relevant parts of the `Contact` class'' source
    code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on and find out how we can create new contacts and update contact
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new contact objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will use the builder pattern for creating new contacts. In order to do so,
    we have to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a static inner class that is used to build new `Contact` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a static `getBuilder()` method to the `Contact` class. This method is used
    to get a reference to the used builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start by adding a static inner class to the `Contact` class by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a constructor that takes the required properties as parameters. The
    required properties of a contact are first name and last name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement property methods for optional properties. These properties include
    e-mail address, phone number, and address information. Each property method returns
    a reference to the used builder object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `build()` method that returns the build object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `Contact.Builder` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to also add a static `getBuilder()` method to the `Contact` class.
    Our implementation is pretty straightforward. We create a new `Contact.Builder`
    object and return the created object. The source code of this method is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Updating contact information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Contact` class has two methods that we can use to update contact information:
    the `update()` method that updates the contact information and the `updateAddress()`
    method that updates the address information of the contact. The source code of
    these methods is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Address` class is an embedded class that is used to store address information.
    An **embedded class** is a class that can be persisted only with its parent class.
    Embedded classes are typically used to present the common concepts of the domain
    model and to emphasize its object-oriented nature. The source code of the `Address`
    class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will find out how we can create new `Address` objects and update the
    address information of existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new addresses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will create new `Address` objects by using the builder pattern. We can implement
    the builder pattern by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a static inner class that is used to build new `Address` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a static `getBuilder()` method to the `Address` class. This method is used
    to get a reference to the used builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can implement the static inner class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a constructor that takes the required properties as parameters. The
    required properties of the `Address` class are `streetAddress`, `postCode`, and
    `postOffice`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement property methods that are used to set optional address information.
    This information includes state and country. Each property method returns a reference
    to the used builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `build()` method that returns the build object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `Address.Builder` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also implement a method that is used to get a reference to the used
    builder object. We can do this by simply creating a new `Address.Builder` object
    and returning the created object. The source code of the static `getBuilder()`
    method of the `Address` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Updating address information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can update the information of an `Address` object by calling its `update()`
    method. The source code of this method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to truly understand the simplicity of Spring Data JPA, we must take
    a trip to a not so distant past and learn how concrete repositories were created
    before Spring Data JPA was released. This should give us a clear picture about
    the benefits of Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom repository in the old school way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traditionally, the creation of concrete repositories has been a process that
    includes six steps. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base class that provides property mappings for its subclasses. It is
    often used to provide ID, version, and timestamp mappings for our entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a generic repository interface that declares the methods shared by all
    repositories. Typically these methods provide CRUD operations for our entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a generic repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entity class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entity specific repository interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entity specific concrete repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we have to create an abstract base class that is extended by each entity
    class. We can create this class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an abstract class that takes the type of the entity's ID as a type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the created class with `@MappedSuperclass` annotation. It is used to
    state that the mappings found from this class are applied to its subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an abstract `getId()` method that returns the id of a concrete class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `BaseEntity` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to create a generic repository interface that declares the
    methods shared by all concrete repositories. We can create this interface by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the type of the entity and the type of the entity's ID as type parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the methods that are shared by all concrete repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `BaseRepository` interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we must create an abstract generic repository. We can do this by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an abstract class that takes the type of the concrete entity and the
    type of the entity's ID as a type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a reference to the used entity manager by using the `@PersistenceContext`
    annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `BaseRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a constructor that fetches the type of the entity class from the type
    parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a `getEntityManager()` method that returns a reference to the used entity
    manager. The subclasses of this class will use this method for obtaining the entity
    manager reference that is used to build database queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a `getEntityClass()` method that returns the type of the entity. Subclasses
    use this method to build database queries by using the Criteria API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `BaseRepositoryImpl` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must create an entity class. We can create this class by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `BaseEntity` class and provide the type of the entity's ID as a type
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `getId()` method that returns the entity's ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `Contact` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must create an interface for our entity specific repository. We can
    do this by extending the `BaseRepository` interface and providing the type of
    our entity and the type of its ID as type parameters. The source code of the `ContactRepository`
    interface is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must create the entity specific concrete repository. We can create
    a concrete repository by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotate the concrete repository class with `@Repository` annotation that identifies
    the created class as a repository class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the `BaseRepositoryImpl` class and give the type of the entity and the
    type of the entity's ID as a type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `ContactRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `ContactRepositoryImpl` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! We have now created a single concrete repository in the old
    fashioned way. The structure of our repository implementation is illustrated in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom repository in the old school way](img/9045_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we have noticed, implementing concrete repositories is a complicated process
    that takes a lot of time, which we could spend being actually productive. Luckily,
    this is not the only way to create repositories for our entities. Next we will
    learn a simpler and easier way to create custom repositories. Naturally, we are
    talking about Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom repository with Spring Data JPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Data JPA is capable of creating concrete repository implementations automatically
    from special repository interfaces. This capability simplifies the creation process
    of custom repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a JPA repository for an entity by creating an interface, which
    extends the `JpaRepository` interface. When we are extending the `JpaRepository`
    interface, we have to provide two type parameters: the type of the entity and
    the type of the entity''s object identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we need to create a repository for the `Contact` entity. The type
    of its object identifier is `Long`. Thus, the source code of the `ContactRepository`
    interface should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. We have now created a repository for the `Contact` entity. The
    structure of our repository implementation is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom repository with Spring Data JPA](img/9045_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the creation of a custom repository could not be any simpler
    than this. Spring Data JPA reduces the amount of code we need to write and maintain,
    and the time that is needed to write it. In other words, we can get the same functionality
    by writing simpler code in a shorter time. This perk is pretty hard to beat.
  prefs: []
  type: TYPE_NORMAL
- en: 'By extending the `JpaRepository` interface, we have now gained access to four
    methods that are needed for implementing the CRUD application. These methods are
    described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Void delete(Contact contact)` | Deletes a single contact from the database.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact findOne(Long id)` | Returns a single contact or null if no contact
    is found. |'
  prefs: []
  type: TYPE_TB
- en: '| `List<Contact> findAll()` | Returns all contacts stored to the database.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact save(Contact contact)` | Saves the given contact to the database
    and returns the saved contact. |'
  prefs: []
  type: TYPE_TB
- en: CRUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now configured the Spring application context, implemented the domain
    model of our application, and created the repository for the `Contact` entity.
    We are finally ready to write the source code of the service class that provides
    CRUD functions for the `Contact` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an interface for our service. Its role is to declare
    the methods used to handle contact information. Let''s call this interface `ContactService`.
    The source code of our interface is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ContactService` interface mentions a class called `ContactDTO` . It is
    a **data transfer object** (**DTO**) used to pass information to our service implementation.
    This DTO is used as a form object in the web layer of our application and it contains
    only the information needed to add or update contact information. In other words,
    it has no logic in it. That is why its source code is not discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of data transfer objects is described at [http://martinfowler.com/eaaCatalog/dataTransferObject.html](http://martinfowler.com/eaaCatalog/dataTransferObject.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to create an implementation to the `ContactService` interface.
    Let''s start by creating a dummy implementation and add the actual logic later.
    The dummy service implementation is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Service` annotation is used to mark our implementation as a service class.
    By adding this annotation we ensure that the class will be automatically detected
    during classpath scanning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `@Resource` annotation to tell the Spring **IoC container** that
    it has to inject the created repository implementation to the service's `repository`
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each method of the service class is marked as transactional by using the `@Transactional`
    annotation. The `rollbackFor` configuration option ensures that the transaction
    is rolled back if any of the configured exceptions is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of our dummy service class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next we will get our hands dirty and learn how we can create, read, update,
    and delete entities with Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a new entity by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Contact` object by using the builder pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the created object to the `save()` method of our repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `add()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Read
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our application has to provide a list of all contacts and the information of
    a single contact to its user. The `ContactService` interface declares two methods,
    which are relevant to these use cases. These methods are: `findAll()` and `findById()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the `findAll()` method is fairly simple. We simply delegate
    the method call forward to the repository. The source code of the `findAll()`
    method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to create an implementation of the `findById()` method. Our implementation
    contains the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the contact by calling our repository's `findOne()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no contact is found, throw a `NotFoundException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the found contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findById()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can update the information of a contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the service's `findById()` method for finding the updated contact. Thus,
    if no contact is found, a `NotFoundException` is thrown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the contact information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the address information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the updated contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `update()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't have to explicitly call the `save()` method of a repository after we
    update the information of an entity if we are inside a read-write transaction.
    All changes made to a persistent entity are automatically updated to the database
    when the transaction is committed.
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can delete a contact by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the deleted contact by calling the `findById()` method that throws a `NotFoundException`
    if no contact is found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the contact to our repository's `delete()` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the deleted contact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `deleteById()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned that:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven provides an easy way to set up a Spring Data JPA project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can configure the application context of our application by using programmatic
    configuration if we use Spring Framework 3.0 or newer versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use Spring Framework 3.1 in a Servlet 3.0 environment, we can configure
    our web application without `web.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JPA simplifies the creation of custom repositories because it can
    automatically create concrete implementations of our repository interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CRUD application is a good start but it does not help us create real-life
    applications. In the next chapter, we will address this issue and describe how
    we can create database queries with Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
