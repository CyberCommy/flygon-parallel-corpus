- en: Chapter 4. Exploring API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible plugins are an advanced topic. There are various plugins available for
    Ansible. This chapter will cover different Python API and lookup plugins in brief
    and explore how they fit into the general Ansible architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is pluggable in a lot of ways. It is possible that there are components
    of business logic that don't quite fit in. Hence, Ansible provides extension points
    that can be used to fit your business needs. Ansible plugins are another such
    extension point where you can build your own plugins to extend Ansible to address
    your business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Python API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before exploring plugins, it''s important to understand the Ansible Python
    API. The Ansible Python API can be used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To control the nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To respond to the various Python events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To write various plugins as per the requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory data from various external data stores can also be plugged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python API for Ansible allows Ansible to run programmatically. Running Ansible
    programmatically through the Python API has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better error handling**: Since everything is Python, it becomes easy to handle
    errors as and when they occur. This gives more control and confidence in the code
    by providing a better context in case of errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending Ansible**: One of the drawbacks, as you might have noticed in the
    previous runs, is that, by default, Ansible simply writes the output on `stdout`
    and does not log anything to a file. To address this, you can write your own custom
    plugins to save output to a file or database for future reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unknown variables**: There may be cases where complete knowledge of the required
    variables may be discovered only during runtime, for example, when an IP of an
    instance launched on the cloud during the Ansible play. Running Ansible programmatically
    using the Python API can address this issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know the advantages of using Python API for Ansible, let's explore
    the Python API and take a look at how one can interact with Ansible through the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the three most important classes that are used extensively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runner**: Used to execute individual modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playbook**: Helps in executing the Ansible playbook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callbacks**: Gets back the run results on the controller node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take an in-depth look at what these classes are and explore the various
    extension points.
  prefs: []
  type: TYPE_NORMAL
- en: Runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `runner` class is the core API interface of Ansible. The `runner` class
    is used to execute individual modules. If there is one single module that needs
    to be executed, for example, the `setup` module, we can use the `runner` class
    to execute this module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can have multiple `runner` objects in the same Python file to run different
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore a sample code, where the `runner` class will be used to execute
    the `setup` module on localhost. This will print a lot of details about localhost
    such as time, operating system (distribution), IP, Netmask, and hardware details
    such as architecture, free memory, used memory, machine ID, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will execute the `setup` module on localhost. This is equivalent to running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To run the preceding module on remote machines or a group of machines, one can
    specify hosts in an inventory that can later be passed as an argument in the `runner`
    object, along with a remote user that should be used to log into the remote machine.
    You can also specify a pattern of hosts, specifically on which the module needs
    to be executed. This is done by passing the pattern argument to the `runner` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also pass in a module argument using the `module_args` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you need to get memory details of remote machines that have
    their domain names set as `store1.mytestlab.com`, `store2.mytestlab.com`, `store12.mytestlab.com`,
    and so on, this can be simply achieved in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will execute the `setup` module on all twelve hosts and print
    the memory status that is reachable by each host. Reachable hosts will be listed
    under "contacted," while those that are un-reachable will be listed under "dark."
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the arguments discussed above, the `runner` class provides a large
    number of interfacing options through the arguments that it accepts. The following
    is a list of a few arguments as defined in the source code, along with their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments/default values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `host_list=C.DEFAULT_HOST_LIST` | Example: `/etc/ansible/hosts`, legacy usage
    |'
  prefs: []
  type: TYPE_TB
- en: '| `module_path=None` | Example: `/usr/share/ansible` |'
  prefs: []
  type: TYPE_TB
- en: '| `module_name=C.DEFAULT_MODULE_NAME` | Example: `copy` |'
  prefs: []
  type: TYPE_TB
- en: '| `module_args=C.DEFAULT_MODULE_ARGS` | Example: "`src=/tmp/a dest=/tmp/b`"
    |'
  prefs: []
  type: TYPE_TB
- en: '| `forks=C.DEFAULT_FORKS` | Parallelism level |'
  prefs: []
  type: TYPE_TB
- en: '| `timeout=C.DEFAULT_TIMEOUT` | SSH timeout |'
  prefs: []
  type: TYPE_TB
- en: '| `pattern=C.DEFAULT_PATTERN` | Which hosts? Example: "all" `acme.example.org`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_user=C.DEFAULT_REMOTE_USER` | Example: "`username`" |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_pass=C.DEFAULT_REMOTE_PASS` | Example: "`password123`" or "`None`"
    if using key |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_port=None` | If SSH on different ports |'
  prefs: []
  type: TYPE_TB
- en: '| `private_key_file=C.DEFAULT_PRIVATE_KEY_FILE` | If not using keys/passwords
    |'
  prefs: []
  type: TYPE_TB
- en: '| `transport=C.DEFAULT_TRANSPORT` | "`SSH`," "`paramiko`," "`Local`" |'
  prefs: []
  type: TYPE_TB
- en: '| `conditional=True` | Run only if this fact expression evals to `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `callbacks=None` | Used for output |'
  prefs: []
  type: TYPE_TB
- en: '| `sudo=False` | Whether to run sudo or not |'
  prefs: []
  type: TYPE_TB
- en: '| `inventory=None` | Reference to inventory object |'
  prefs: []
  type: TYPE_TB
- en: '| `environment=None` | Environment variables (as `dict`) to use inside the
    command |'
  prefs: []
  type: TYPE_TB
- en: '| `complex_args=None` | Structured data in addition to `module_args`, must
    be a `dict` |'
  prefs: []
  type: TYPE_TB
- en: Playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbook, as you have learned in the previous chapters, is a set of instructions
    or commands in a YAML format that runs in a sequential order. Python API for Ansible
    provides a rich interface to run the already created playbooks through the `PlayBook`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `PlayBook` object and pass in an existing Ansible playbook
    as an argument along with the required parameters. One thing to note is that multiple
    plays do not execute simultaneously, but the tasks in a play can be executed in
    parallel based on the requested number of forks. Once the object is created, you
    can easily execute the Ansible playbook by calling the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a `Playbook` object that can later be executed using the following
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note here is that a `PlayBook` object requires at least four mandatory
    arguments to be passed. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`playbook`: the path to a Playbook file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stats`: Holds aggregated data about events occurring in each host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callbacks`: Outputs callbacks for the playbook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_callbacks`: Callbacks for the `runner` API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also define the verbosity in a range of `0`-`4`, which is required by
    the `callbacks` and `runner_callbacks` objects. If verbosity is not defined, the
    default value is taken as `0`. Defining verbosity as a `4` is equivalent to using
    `-vvvv` while executing the Ansible playbook from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you have your inventory file named `hosts` and a playbook named
    `webservers.yaml`. To execute this playbook on the inventory hosts using the Python
    API, you need to create a `PlayBook` object with the required parameters. You
    also need to require a verbose output. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will execute the playbook `webservers.yaml` on the remote hosts specified
    in the `hosts` inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: To execute the same playbook locally, just as you did in the `runner` object
    earlier, you need to pass the argument `transport=local` in the `PlayBook` object
    and remove the `host_list` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the discussed parameters, PlayBook accepts a whole lot more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of all the arguments accepted by the `PlayBook` object
    along with their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `playbook` | Path to a playbook file |'
  prefs: []
  type: TYPE_TB
- en: '| `host_list` | Path to a file like `/etc/ansible/hosts` |'
  prefs: []
  type: TYPE_TB
- en: '| `module_path` | Path to Ansible modules, like `/usr/share/ansible/` |'
  prefs: []
  type: TYPE_TB
- en: '| `forks` | Desired level of parallelism |'
  prefs: []
  type: TYPE_TB
- en: '| `timeout` | Connection timeout |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_user` | Run as this user if not specified in a particular play |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_pass` | Use this remote password (for all plays) vs using SSH keys
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sudo_pass` | If `sudo=true` and a password is required, this is the sudo
    password |'
  prefs: []
  type: TYPE_TB
- en: '| `remote_port` | Default remote port to use if not specified with the host
    or play |'
  prefs: []
  type: TYPE_TB
- en: '| `transport` | How to connect to hosts that don''t specify a transport (local,
    paramiko, and so on.) |'
  prefs: []
  type: TYPE_TB
- en: '| `callbacks` | Output callbacks for the playbook |'
  prefs: []
  type: TYPE_TB
- en: '| `runner_callbacks` | More callbacks, this time for the runner API |'
  prefs: []
  type: TYPE_TB
- en: '| `stats` | Holds aggregate data about events occurring to each host |'
  prefs: []
  type: TYPE_TB
- en: '| `sudo` | If not specified per play, requests all plays use `sudo` mode |'
  prefs: []
  type: TYPE_TB
- en: '| `inventory` | Can be specified instead of `host_list` to use a pre-existing
    inventory object |'
  prefs: []
  type: TYPE_TB
- en: '| `check` | Don''t change anything; just try to detect some potential changes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `any_errors_fatal` | Terminate the entire execution immediately when one
    of the hosts has failed |'
  prefs: []
  type: TYPE_TB
- en: '| `force_handlers` | Continue to notify and run handlers even if a task fails
    |'
  prefs: []
  type: TYPE_TB
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible provides hooks for running custom callbacks on the host machine as it
    invokes various modules. Callbacks allow us to log the events and operations that
    are started or completed and aggregate results from the module execution. Python
    API provides callbacks for this purpose, which can be used in its default state
    as well as to develop your own callback plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks allow various operations to be performed. Callbacks can also be exploited
    as an extension point for Ansible. Some of the most widely used callbacks operations
    while wrapping up Ansible in Python API are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AggregateStats`: As the name suggests, `AggregateStats` holds the aggregated
    stats surrounding per host activity during a playbook run. An object of `AggregateStats`
    can be passed on as an argument for `stats` in the `PlayBook` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaybookRunnerCallbacks`: An object of `PlaybookRunnerCallbacks` is used for
    `Runner()`, for example, when a single module is executed using the `Runner` API
    interface, `PlaybookRunnerCallbacks` is used to return the task status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaybookCallbacks`: An object of `PlaybookCallbacks` is used by the playbook
    API interface of the Python API when a playbook is executed from the Python API.
    These callbacks are used by `/usr/bin/ansible-playbook`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultRunnerCallbacks`: When there are no callbacks specified for `Runner`
    to use, `DefaultRunnerCallbacks` is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CliRunnerCallbacks`: This extends `DefaultRunnerCallbacks` and overrides the
    on-event trigger functions, basically optimized to be used with `/usr/bin/ansible`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are another extension point that haven't yet been touched on in this
    book. Also, there is very limited documentation available, even on the Internet,
    regarding plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins are an advanced topic that will be covered in the next chapter. However,
    it's important to understand the Python API behind plugins in order to understand
    how plugins work and how they can be extended.
  prefs: []
  type: TYPE_NORMAL
- en: PluginLoader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the code documentation states, `PluginLoader` is the base class that loads
    plugins from the configured plugin directories. It iterates through the list of
    play basedirs, configured paths, and Python paths to search for a plugin. The
    first match is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object of `PluginLoader` takes in the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class_name`: The specific class name for plugin type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required_base_class`: The base class required by the plugin module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package`: Package information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: Specifies the default path from configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subdir`: All subdirectories in a package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aliases`: Alternate name for the plugin type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For every Ansible plugin, there is a defined class name that needs to be used.
    This class in `PluginLoader` is identified by `required_base_class`. The different
    categories of Ansible plugins along with their base names are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plugin type | Class name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Action plugins | `ActionModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Cache plugins | `CacheModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Callback plugins | `CallbackModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Connection plugins | `Connection` |'
  prefs: []
  type: TYPE_TB
- en: '| Shell plugins | `ShellModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Lookup plugins | `LookupModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Vars plugins | `VarsModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Filter plugins | `FilterModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Test plugins | `TestModule` |'
  prefs: []
  type: TYPE_TB
- en: '| Strategy plugins | `StrategyModule` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took you through the Python API for Ansible and introduced you
    to more advanced ways of using Ansible. This included executing single tasks without
    creating an entire playbook to executing a playbook programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced you to the various components of the Ansible Python
    API from a more technical point of view, exploring the various extension points
    and ways to exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter additionally sets a base for the next chapter, which will be a
    deep dive into the Ansible plugins. The next chapter will utilize the knowledge
    gained from this chapter to create custom Ansible plugins. We will explore different
    Ansible plugins and guide you through writing your own Ansible plugin in the following
    chapter.
  prefs: []
  type: TYPE_NORMAL
